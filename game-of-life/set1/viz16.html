<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organic Blobs - Game of Life</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        canvas {
            border: 2px solid #553c9a;
            box-shadow: 0 0 40px rgba(118,75,162,0.5);
            border-radius: 20px;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
        }
        button {
            margin: 5px;
            padding: 10px 15px;
            cursor: pointer;
            background: #764ba2;
            color: white;
            border: none;
            border-radius: 5px;
        }
        a.back {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            text-decoration: none;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back">‚Üê Back</a>
    <div class="controls">
        <h3>ü´ß Organic Blobs</h3>
        <button onclick="game.toggle()">Play/Pause</button>
        <button onclick="game.random()">Random</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        class Blob {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.radius = 15;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.02 + Math.random() * 0.03;
                this.wobble = Math.random() * Math.PI * 2;
            }

            update(time) {
                this.angle += this.speed;
                this.wobble += 0.05;
                this.x = this.baseX + Math.sin(this.angle) * 5;
                this.y = this.baseY + Math.cos(this.angle) * 5;
            }

            getPoints(numPoints, time) {
                const points = [];
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const wobbleOffset = Math.sin(angle * 3 + this.wobble + time * 0.05) * 5;
                    const r = this.radius + wobbleOffset;
                    points.push({
                        x: this.x + Math.cos(angle) * r,
                        y: this.y + Math.sin(angle) * r
                    });
                }
                return points;
            }
        }

        class OrganicLife {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 800;
                this.canvas.height = 600;
                this.cellSize = 25;
                this.cols = Math.floor(this.canvas.width / this.cellSize);
                this.rows = Math.floor(this.canvas.height / this.cellSize);
                this.grid = this.createGrid();
                this.blobs = [];
                this.running = true;
                this.time = 0;
                this.random();
                this.animate();
            }

            createGrid() {
                return Array(this.rows).fill(null).map(() =>
                    Array(this.cols).fill(0));
            }

            random() {
                this.blobs = [];
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        this.grid[i][j] = Math.random() > 0.75 ? 1 : 0;
                        if (this.grid[i][j]) {
                            const x = j * this.cellSize + this.cellSize / 2;
                            const y = i * this.cellSize + this.cellSize / 2;
                            this.blobs.push(new Blob(x, y));
                        }
                    }
                }
            }

            toggle() {
                this.running = !this.running;
            }

            countNeighbors(row, col) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const r = (row + i + this.rows) % this.rows;
                        const c = (col + j + this.cols) % this.cols;
                        count += this.grid[r][c] ? 1 : 0;
                    }
                }
                return count;
            }

            update() {
                if (!this.running) return;

                const newGrid = this.createGrid();
                const newBlobs = [];

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const neighbors = this.countNeighbors(i, j);
                        const cell = this.grid[i][j];

                        if ((cell && (neighbors === 2 || neighbors === 3)) ||
                            (!cell && neighbors === 3)) {
                            newGrid[i][j] = 1;
                            const x = j * this.cellSize + this.cellSize / 2;
                            const y = i * this.cellSize + this.cellSize / 2;
                            newBlobs.push(new Blob(x, y));
                        }
                    }
                }

                this.grid = newGrid;
                this.blobs = newBlobs;
                this.time++;
            }

            drawBlob(blob, color) {
                const points = blob.getPoints(8, this.time);
                if (points.length === 0) return;

                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);

                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];
                    const cpx = (p1.x + p2.x) / 2;
                    const cpy = (p1.y + p2.y) / 2;
                    this.ctx.quadraticCurveTo(p1.x, p1.y, cpx, cpy);
                }

                this.ctx.closePath();

                const gradient = this.ctx.createRadialGradient(
                    blob.x, blob.y, 0,
                    blob.x, blob.y, blob.radius * 1.5
                );
                gradient.addColorStop(0, color.light);
                gradient.addColorStop(1, color.dark);

                this.ctx.fillStyle = gradient;
                this.ctx.fill();

                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            draw() {
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.blobs.forEach((blob, idx) => {
                    blob.update(this.time);

                    const hue = (idx * 30 + this.time) % 360;
                    const color = {
                        light: `hsla(${hue}, 70%, 70%, 0.8)`,
                        dark: `hsla(${hue}, 70%, 40%, 0.6)`
                    };

                    this.drawBlob(blob, color);
                });

                for (let i = 0; i < this.blobs.length - 1; i++) {
                    for (let j = i + 1; j < this.blobs.length; j++) {
                        const b1 = this.blobs[i];
                        const b2 = this.blobs[j];
                        const dist = Math.sqrt((b1.x - b2.x) ** 2 + (b1.y - b2.y) ** 2);

                        if (dist < this.cellSize * 2) {
                            this.ctx.strokeStyle = `rgba(200, 150, 255, ${1 - dist / (this.cellSize * 2)})`;
                            this.ctx.lineWidth = 3;
                            this.ctx.beginPath();
                            this.ctx.moveTo(b1.x, b1.y);
                            this.ctx.lineTo(b2.x, b2.y);
                            this.ctx.stroke();
                        }
                    }
                }
            }

            animate() {
                this.update();
                this.draw();
                setTimeout(() => requestAnimationFrame(() => this.animate()), 100);
            }
        }

        const game = new OrganicLife();
    </script>
</body>
</html>
