<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life - Heat Map by Age (TSL)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000;
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas {
            border: 2px solid #222;
            box-shadow: 0 0 40px rgba(255,0,0,0.3);
        }
        h1 {
            font-size: 24px;
            margin: 0 0 10px 0;
        }
        .tech-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 15px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Heat Map Game of Life (Color by Age)</h1>
    <div class="tech-badge">GPU-Accelerated • Three.js TSL • Age Tracking</div>
    <canvas id="canvas"></canvas>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
            "three/nodes": "https://unpkg.com/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as Nodes from 'three/nodes';

        const {
            texture, uniform, uv, vec2, vec3, vec4, float,
            Fn, fract, mix, step, min, clamp
        } = Nodes;

        const cellSize = 8;
        const cols = 100;
        const rows = 80;
        const canvas = document.getElementById('canvas');
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(cols * cellSize, rows * cellSize);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Grid textures
        const gridData = new Uint8Array(cols * rows * 4);
        const ageData = new Uint8Array(cols * rows * 4);
        for (let i = 0; i < cols * rows; i++) {
            const alive = Math.random() > 0.7 ? 255 : 0;
            gridData[i * 4] = alive;
            gridData[i * 4 + 1] = alive;
            gridData[i * 4 + 2] = alive;
            gridData[i * 4 + 3] = 255;
            ageData[i * 4] = 0;
            ageData[i * 4 + 1] = 0;
            ageData[i * 4 + 2] = 0;
            ageData[i * 4 + 3] = 255;
        }

        const gridTexture1 = new THREE.DataTexture(gridData, cols, rows, THREE.RGBAFormat);
        gridTexture1.needsUpdate = true;
        gridTexture1.magFilter = THREE.NearestFilter;
        gridTexture1.minFilter = THREE.NearestFilter;

        const gridTexture2 = gridTexture1.clone();
        gridTexture2.needsUpdate = true;

        const ageTexture1 = new THREE.DataTexture(ageData, cols, rows, THREE.RGBAFormat);
        ageTexture1.needsUpdate = true;
        ageTexture1.magFilter = THREE.NearestFilter;
        ageTexture1.minFilter = THREE.NearestFilter;

        const ageTexture2 = ageTexture1.clone();
        ageTexture2.needsUpdate = true;

        let currentTexture = gridTexture1;
        let nextTexture = gridTexture2;
        let currentAgeTexture = ageTexture1;
        let nextAgeTexture = ageTexture2;

        // TSL: Count neighbors
        const countNeighbors = Fn(([gridTex, coord, gridSize]) => {
            let count = float(0);
            const pixelSize = vec2(1.0).div(gridSize);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const offset = vec2(dx, dy).mul(pixelSize);
                    const neighborCoord = fract(coord.add(offset));
                    const neighborValue = texture(gridTex, neighborCoord).r;
                    count = count.add(step(0.5, neighborValue));
                }
            }
            return count;
        });

        // TSL: Game of Life compute with age tracking
        const gameOfLifeWithAge = Fn(([currentTex, currentAgeTex, gridSize]) => {
            const coord = uv();
            const currentState = texture(currentTex, coord).r;
            const currentAge = texture(currentAgeTex, coord).r;
            const isAlive = step(0.5, currentState);
            const neighbors = countNeighbors(currentTex, coord, gridSize);

            const survives = isAlive.mul(step(1.5, neighbors)).mul(step(neighbors, 3.5));
            const born = isAlive.oneMinus().mul(step(2.9, neighbors)).mul(step(neighbors, 3.1));
            const newState = survives.add(born);

            // Age: increment if surviving, reset to 1 if born, 0 if dead
            const newAge = survives.mul(min(currentAge.add(1.0 / 255.0), 100.0 / 255.0))
                .add(born.mul(1.0 / 255.0));

            return vec4(newState, newAge, 0, 1);
        });

        // TSL: Heat color mapping (Black -> Red -> Orange -> Yellow -> White)
        const getHeatColor = Fn(([age]) => {
            const normalized = clamp(age.mul(100.0 / 255.0).div(100), 0, 1);

            // Black to Red (0-0.25)
            const r1 = normalized.div(0.25);
            const color1 = vec3(r1, 0, 0);

            // Red to Orange (0.25-0.5)
            const t2 = normalized.sub(0.25).div(0.25);
            const color2 = vec3(1, t2.mul(165.0 / 255.0), 0);

            // Orange to Yellow (0.5-0.75)
            const t3 = normalized.sub(0.5).div(0.25);
            const color3 = vec3(1, 165.0 / 255.0 + t3.mul(90.0 / 255.0), t3);

            // Yellow to White (0.75-1.0)
            const color4 = vec3(1, 1, 1);

            const c1 = mix(color1, color2, step(0.25, normalized));
            const c2 = mix(c1, color3, step(0.5, normalized));
            const finalColor = mix(c2, color4, step(0.75, normalized));

            return finalColor;
        });

        // TSL: Heat map display
        const heatMapDisplay = Fn(([gridTex, ageTex]) => {
            const coord = uv();
            const cellState = texture(gridTex, coord).r;
            const cellAge = texture(ageTex, coord).r;
            const isAlive = step(0.5, cellState);

            const heatColor = getHeatColor(cellAge);
            const finalColor = heatColor.mul(isAlive);

            return vec4(finalColor, 1);
        });

        // Compute scene setup
        const gridSizeNode = vec2(cols, rows);
        const computeMaterial = new THREE.MeshBasicMaterial();
        computeMaterial.colorNode = gameOfLifeWithAge(
            texture(currentTexture),
            texture(currentAgeTexture),
            gridSizeNode
        );

        const computeGeometry = new THREE.PlaneGeometry(2, 2);
        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(computeGeometry, computeMaterial);
        computeScene.add(computeMesh);

        const renderTarget = new THREE.WebGLRenderTarget(cols, rows, {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter
        });

        // Display scene
        const displayMaterial = new THREE.MeshBasicMaterial();
        displayMaterial.colorNode = heatMapDisplay(
            texture(currentTexture),
            texture(currentAgeTexture)
        );

        const displayGeometry = new THREE.PlaneGeometry(2, 2);
        const displayMesh = new THREE.Mesh(displayGeometry, displayMaterial);
        scene.add(displayMesh);

        let frameCount = 0;

        function animate() {
            frameCount++;

            // Update every 3 frames
            if (frameCount % 3 === 0) {
                // Compute next generation
                computeMaterial.colorNode = gameOfLifeWithAge(
                    texture(currentTexture),
                    texture(currentAgeTexture),
                    gridSizeNode
                );
                computeMaterial.needsUpdate = true;
                renderer.setRenderTarget(renderTarget);
                renderer.render(computeScene, camera);

                const pixels = new Uint8Array(cols * rows * 4);
                renderer.readRenderTargetPixels(renderTarget, 0, 0, cols, rows, pixels);

                // Extract state and age from result
                for (let i = 0; i < cols * rows; i++) {
                    const state = pixels[i * 4];     // R = state
                    const age = pixels[i * 4 + 1];   // G = age
                    nextTexture.image.data[i * 4] = state;
                    nextTexture.image.data[i * 4 + 1] = state;
                    nextTexture.image.data[i * 4 + 2] = state;
                    nextTexture.image.data[i * 4 + 3] = 255;
                    nextAgeTexture.image.data[i * 4] = age;
                    nextAgeTexture.image.data[i * 4 + 1] = age;
                    nextAgeTexture.image.data[i * 4 + 2] = age;
                    nextAgeTexture.image.data[i * 4 + 3] = 255;
                }

                nextTexture.needsUpdate = true;
                nextAgeTexture.needsUpdate = true;

                [currentTexture, nextTexture] = [nextTexture, currentTexture];
                [currentAgeTexture, nextAgeTexture] = [nextAgeTexture, currentAgeTexture];

                renderer.setRenderTarget(null);
            }

            // Render display
            displayMaterial.colorNode = heatMapDisplay(
                texture(currentTexture),
                texture(currentAgeTexture)
            );
            displayMaterial.needsUpdate = true;
            renderer.render(scene, camera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
