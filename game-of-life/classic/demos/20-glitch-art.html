<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life - Glitch Art</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
        }
        canvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(255,0,255,0.5), 0 0 40px rgba(0,255,255,0.3);
            filter: contrast(1.2);
        }
        h1 {
            font-size: 24px;
            margin: 0 0 20px 0;
            animation: glitch 1s infinite;
        }
        @keyframes glitch {
            0%, 100% { text-shadow: 2px 0 #ff00ff, -2px 0 #00ffff; }
            25% { text-shadow: -2px 0 #ff00ff, 2px 0 #00ffff; }
            50% { text-shadow: 2px 2px #ff00ff, -2px -2px #00ffff; }
            75% { text-shadow: -2px 2px #ff00ff, 2px -2px #00ffff; }
        }
    </style>
</head>
<body>
    <h1>GL1TCH ART G4ME 0F L1FE</h1>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 10;
        const cols = 80;
        const rows = 60;
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        let grid = [];
        let glitchIntensity = 0;
        let colorShift = 0;

        function initGrid() {
            grid = [];
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = Math.random() > 0.7 ? 1 : 0;
                }
            }
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const col = (x + i + cols) % cols;
                    const row = (y + j + rows) % rows;
                    count += grid[col][row];
                }
            }
            return count;
        }

        function nextGeneration() {
            const next = [];
            for (let i = 0; i < cols; i++) {
                next[i] = [];
                for (let j = 0; j < rows; j++) {
                    const state = grid[i][j];
                    const neighbors = countNeighbors(i, j);

                    if (state === 0 && neighbors === 3) {
                        next[i][j] = 1;
                        glitchIntensity = Math.min(glitchIntensity + 0.1, 1);
                    } else if (state === 1 && (neighbors === 2 || neighbors === 3)) {
                        next[i][j] = 1;
                    } else {
                        next[i][j] = 0;
                        if (state === 1) {
                            glitchIntensity = Math.min(glitchIntensity + 0.05, 1);
                        }
                    }
                }
            }
            return next;
        }

        function applyGlitchEffect() {
            if (Math.random() < glitchIntensity * 0.3) {
                // Horizontal displacement glitch
                const sliceY = Math.floor(Math.random() * canvas.height);
                const sliceHeight = Math.floor(Math.random() * 50) + 10;
                const displacement = (Math.random() - 0.5) * 50;

                const imageData = ctx.getImageData(0, sliceY, canvas.width, sliceHeight);
                ctx.putImageData(imageData, displacement, sliceY);
            }

            if (Math.random() < glitchIntensity * 0.2) {
                // RGB channel shift
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const shiftedData = ctx.createImageData(canvas.width, canvas.height);

                for (let i = 0; i < imageData.data.length; i += 4) {
                    const offset = Math.floor(Math.random() * 20 - 10) * 4;
                    const srcIndex = Math.max(0, Math.min(imageData.data.length - 4, i + offset));

                    shiftedData.data[i] = imageData.data[srcIndex]; // R from shifted
                    shiftedData.data[i + 1] = imageData.data[i + 1]; // G original
                    shiftedData.data[i + 2] = imageData.data[srcIndex + 2]; // B from shifted
                    shiftedData.data[i + 3] = imageData.data[i + 3]; // A original
                }

                ctx.putImageData(shiftedData, 0, 0);
            }

            glitchIntensity *= 0.95;
        }

        function drawWithGlitch() {
            // Base layer
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw cells with chromatic aberration
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j] === 1) {
                        const x = i * cellSize;
                        const y = j * cellSize;

                        // Random glitch offset
                        const offsetX = Math.random() < 0.1 ? (Math.random() - 0.5) * 4 : 0;
                        const offsetY = Math.random() < 0.1 ? (Math.random() - 0.5) * 4 : 0;

                        // Red channel
                        ctx.fillStyle = `rgba(255, 0, 255, 0.6)`;
                        ctx.fillRect(x - 2 + offsetX, y + offsetY, cellSize - 1, cellSize - 1);

                        // Cyan channel
                        ctx.fillStyle = `rgba(0, 255, 255, 0.6)`;
                        ctx.fillRect(x + 2 + offsetX, y + offsetY, cellSize - 1, cellSize - 1);

                        // White core
                        ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
                        ctx.fillRect(x + offsetX, y + offsetY, cellSize - 1, cellSize - 1);

                        // Random digital noise
                        if (Math.random() < 0.05) {
                            ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ffff';
                            ctx.fillRect(
                                x + Math.random() * cellSize,
                                y + Math.random() * cellSize,
                                2, 2
                            );
                        }
                    }
                }
            }

            // Scanlines
            ctx.fillStyle = 'rgba(0, 255, 255, 0.03)';
            for (let y = 0; y < canvas.height; y += 2) {
                ctx.fillRect(0, y, canvas.width, 1);
            }

            // Apply glitch effects
            applyGlitchEffect();

            // Random pixel corruption
            if (Math.random() < 0.1) {
                const corruptX = Math.floor(Math.random() * canvas.width);
                const corruptY = Math.floor(Math.random() * canvas.height);
                const corruptSize = Math.floor(Math.random() * 20) + 5;

                ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ffff';
                ctx.fillRect(corruptX, corruptY, corruptSize, Math.random() * 3);
            }
        }

        function draw() {
            drawWithGlitch();
            colorShift += 0.1;
        }

        function update() {
            draw();
            grid = nextGeneration();
            requestAnimationFrame(update);
        }

        initGrid();
        update();
    </script>
</body>
</html>
