<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life - Ghost Trails (TSL)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000;
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas {
            border: 2px solid #222;
            box-shadow: 0 0 30px rgba(147,51,234,0.5);
        }
        h1 {
            font-size: 24px;
            margin: 0 0 10px 0;
        }
        .tech-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 15px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Ghost Trails Game of Life</h1>
    <div class="tech-badge">GPU-Accelerated • Three.js TSL • Persistence Effects</div>
    <canvas id="canvas"></canvas>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
            "three/nodes": "https://unpkg.com/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as Nodes from 'three/nodes';

        const {
            texture, uniform, uv, vec2, vec3, vec4, float,
            Fn, fract, mix, step, max
        } = Nodes;

        const cellSize = 8;
        const cols = 100;
        const rows = 80;
        const canvas = document.getElementById('canvas');
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(cols * cellSize, rows * cellSize);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Grid textures
        const gridData = new Uint8Array(cols * rows * 4);
        for (let i = 0; i < cols * rows; i++) {
            const alive = Math.random() > 0.7 ? 255 : 0;
            gridData[i * 4] = alive;
            gridData[i * 4 + 1] = alive;
            gridData[i * 4 + 2] = alive;
            gridData[i * 4 + 3] = 255;
        }

        const gridTexture1 = new THREE.DataTexture(gridData, cols, rows, THREE.RGBAFormat);
        gridTexture1.needsUpdate = true;
        gridTexture1.magFilter = THREE.NearestFilter;
        gridTexture1.minFilter = THREE.NearestFilter;

        const gridTexture2 = gridTexture1.clone();
        gridTexture2.needsUpdate = true;

        // Trail texture (accumulates over time)
        const trailData = new Uint8Array(cols * rows * 4);
        trailData.fill(0);
        const trailTexture = new THREE.DataTexture(trailData, cols, rows, THREE.RGBAFormat);
        trailTexture.needsUpdate = true;
        trailTexture.magFilter = THREE.LinearFilter;
        trailTexture.minFilter = THREE.LinearFilter;

        let currentTexture = gridTexture1;
        let nextTexture = gridTexture2;

        // TSL: Count neighbors
        const countNeighbors = Fn(([gridTex, coord, gridSize]) => {
            let count = float(0);
            const pixelSize = vec2(1.0).div(gridSize);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const offset = vec2(dx, dy).mul(pixelSize);
                    const neighborCoord = fract(coord.add(offset));
                    const neighborValue = texture(gridTex, neighborCoord).r;
                    count = count.add(step(0.5, neighborValue));
                }
            }
            return count;
        });

        // TSL: Game of Life compute
        const gameOfLifeCompute = Fn(([currentTex, gridSize]) => {
            const coord = uv();
            const currentState = texture(currentTex, coord).r;
            const isAlive = step(0.5, currentState);
            const neighbors = countNeighbors(currentTex, coord, gridSize);

            const survives = isAlive.mul(step(1.5, neighbors)).mul(step(neighbors, 3.5));
            const born = isAlive.oneMinus().mul(step(2.9, neighbors)).mul(step(neighbors, 3.1));
            const newState = survives.add(born);

            return vec4(newState, newState, newState, 1);
        });

        // TSL: Trail update with fade
        const updateTrails = Fn(([gridTex, trailTex]) => {
            const coord = uv();
            const currentState = texture(gridTex, coord).r;
            const oldTrail = texture(trailTex, coord).r;

            // Fade old trail by 95% and add current state
            const newTrail = max(currentState, oldTrail.mul(0.95));

            return vec4(newTrail, newTrail, newTrail, 1);
        });

        // TSL: Ghost trails display
        const ghostTrailsDisplay = Fn(([gridTex, trailTex]) => {
            const coord = uv();
            const cellState = texture(gridTex, coord).r;
            const trailValue = texture(trailTex, coord).r;
            const isAlive = step(0.5, cellState);

            // Active cells: bright purple
            const activeColor = vec3(147.0/255.0, 51.0/255.0, 234.0/255.0);

            // Ghost trail: fading purple
            const ghostAlpha = trailValue.mul(0.3);
            const finalColor = mix(
                activeColor.mul(ghostAlpha),
                activeColor,
                isAlive
            );
            const finalAlpha = max(isAlive, ghostAlpha);

            return vec4(finalColor, finalAlpha);
        });

        // Compute scene setup
        const gridSizeNode = vec2(cols, rows);
        const computeMaterial = new THREE.MeshBasicMaterial();
        computeMaterial.colorNode = gameOfLifeCompute(texture(currentTexture), gridSizeNode);

        const computeGeometry = new THREE.PlaneGeometry(2, 2);
        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(computeGeometry, computeMaterial);
        computeScene.add(computeMesh);

        const renderTarget = new THREE.WebGLRenderTarget(cols, rows, {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter
        });

        // Trail update scene
        const trailMaterial = new THREE.MeshBasicMaterial();
        trailMaterial.colorNode = updateTrails(texture(currentTexture), texture(trailTexture));

        const trailScene = new THREE.Scene();
        const trailMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), trailMaterial);
        trailScene.add(trailMesh);

        const trailTarget = new THREE.WebGLRenderTarget(cols, rows, {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        });

        // Display scene
        const displayMaterial = new THREE.MeshBasicMaterial();
        displayMaterial.transparent = true;
        displayMaterial.colorNode = ghostTrailsDisplay(texture(currentTexture), texture(trailTexture));

        const displayGeometry = new THREE.PlaneGeometry(2, 2);
        const displayMesh = new THREE.Mesh(displayGeometry, displayMaterial);
        scene.add(displayMesh);

        let frameCount = 0;

        function animate() {
            frameCount++;

            // Update every 2 frames
            if (frameCount % 2 === 0) {
                // Compute next generation
                computeMaterial.colorNode = gameOfLifeCompute(texture(currentTexture), gridSizeNode);
                computeMaterial.needsUpdate = true;
                renderer.setRenderTarget(renderTarget);
                renderer.render(computeScene, camera);

                const pixels = new Uint8Array(cols * rows * 4);
                renderer.readRenderTargetPixels(renderTarget, 0, 0, cols, rows, pixels);
                nextTexture.image.data = pixels;
                nextTexture.needsUpdate = true;

                [currentTexture, nextTexture] = [nextTexture, currentTexture];

                // Update trail texture
                trailMaterial.colorNode = updateTrails(texture(currentTexture), texture(trailTexture));
                trailMaterial.needsUpdate = true;
                renderer.setRenderTarget(trailTarget);
                renderer.render(trailScene, camera);

                const trailPixels = new Uint8Array(cols * rows * 4);
                renderer.readRenderTargetPixels(trailTarget, 0, 0, cols, rows, trailPixels);
                trailTexture.image.data = trailPixels;
                trailTexture.needsUpdate = true;

                renderer.setRenderTarget(null);
            }

            // Render display
            displayMaterial.colorNode = ghostTrailsDisplay(texture(currentTexture), texture(trailTexture));
            displayMaterial.needsUpdate = true;
            renderer.render(scene, camera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
