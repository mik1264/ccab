<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Chromatic - Game of Life (TSL)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            flex-direction: column;
        }
        canvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        h1 {
            color: white;
            font-size: 24px;
            margin: 0 0 10px 0;
        }
        .tech-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 15px;
            font-weight: bold;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Classic Chromatic</h1>
    <div class="tech-badge">GPU-Accelerated • Three.js TSL • Generational Colors</div>
    <canvas id="canvas"></canvas>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
            "three/nodes": "https://unpkg.com/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as Nodes from 'three/nodes';

        const {
            texture, uv, vec2, vec3, vec4, float,
            Fn, fract, mix, step, min, mod, clamp
        } = Nodes;

        const cellSize = 8;
        const cols = 100;
        const rows = 75;
        const canvas = document.getElementById('canvas');
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(cols * cellSize, rows * cellSize);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Initialize textures
        const gridData = new Uint8Array(cols * rows * 4);
        const generationData = new Uint8Array(cols * rows * 4);
        for (let i = 0; i < cols * rows; i++) {
            const alive = Math.random() > 0.7 ? 255 : 0;
            gridData[i * 4] = alive;
            gridData[i * 4 + 1] = alive;
            gridData[i * 4 + 2] = alive;
            gridData[i * 4 + 3] = 255;
            generationData[i * 4] = 0;
            generationData[i * 4 + 1] = 0;
            generationData[i * 4 + 2] = 0;
            generationData[i * 4 + 3] = 255;
        }

        const gridTexture1 = new THREE.DataTexture(gridData, cols, rows, THREE.RGBAFormat);
        gridTexture1.needsUpdate = true;
        gridTexture1.magFilter = THREE.NearestFilter;
        gridTexture1.minFilter = THREE.NearestFilter;

        const gridTexture2 = gridTexture1.clone();
        gridTexture2.needsUpdate = true;

        const generationTexture1 = new THREE.DataTexture(generationData, cols, rows, THREE.RGBAFormat);
        generationTexture1.needsUpdate = true;
        generationTexture1.magFilter = THREE.NearestFilter;
        generationTexture1.minFilter = THREE.NearestFilter;

        const generationTexture2 = generationTexture1.clone();
        generationTexture2.needsUpdate = true;

        let currentTexture = gridTexture1;
        let nextTexture = gridTexture2;
        let currentGenTexture = generationTexture1;
        let nextGenTexture = generationTexture2;

        // TSL: Count neighbors
        const countNeighbors = Fn(([gridTex, coord, gridSize]) => {
            let count = float(0);
            const pixelSize = vec2(1.0).div(gridSize);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const offset = vec2(dx, dy).mul(pixelSize);
                    const neighborCoord = fract(coord.add(offset));
                    const neighborValue = texture(gridTex, neighborCoord).r;
                    count = count.add(step(0.5, neighborValue));
                }
            }
            return count;
        });

        // TSL: Game of Life with generation tracking
        const gameOfLifeWithGen = Fn(([currentTex, currentGenTex, gridSize]) => {
            const coord = uv();
            const currentState = texture(currentTex, coord).r;
            const currentGen = texture(currentGenTex, coord).r;
            const isAlive = step(0.5, currentState);
            const neighbors = countNeighbors(currentTex, coord, gridSize);

            const survives = isAlive.mul(step(1.5, neighbors)).mul(step(neighbors, 3.5));
            const born = isAlive.oneMinus().mul(step(2.9, neighbors)).mul(step(neighbors, 3.1));
            const newState = survives.add(born);

            // Increment generation for surviving cells, reset to 1 for births, 0 for dead
            const newGen = survives.mul(min(currentGen.add(1.0 / 255.0), 50.0 / 255.0))
                .add(born.mul(1.0 / 255.0));

            return vec4(newState, newGen, 0, 1);
        });

        // TSL: HSL to RGB conversion
        const hslToRgb = Fn(([h, s, l]) => {
            const c = l.sub(l.mul(l.sub(0.5).abs()).mul(2)).mul(s);
            const x = c.mul(mod(h.mul(6), 2).sub(1).abs().oneMinus());
            const m = l.sub(c.div(2));

            const hue6 = h.mul(6);
            const r = clamp(mix(mix(mix(c, x, step(1, hue6)), float(0), step(2, hue6)),
                         mix(float(0), x, step(4, hue6)), step(3, hue6)).add(m), 0, 1);
            const g = clamp(mix(mix(x, c, step(1, hue6)), x, step(4, hue6)).add(m), 0, 1);
            const b = clamp(mix(mix(float(0), x, step(3, hue6)), c, step(5, hue6)).add(m), 0, 1);

            return vec3(r, g, b);
        });

        // TSL: Chromatic display
        const chromaticDisplay = Fn(([gridTex, genTex]) => {
            const coord = uv();
            const cellState = texture(gridTex, coord).r;
            const gen = texture(genTex, coord).r.mul(255);
            const isAlive = step(0.5, cellState);

            // HSL color based on generation
            const hue = mod(gen.mul(7), 360).div(360);
            const saturation = 0.7 + mod(gen, 30).div(100);
            const lightness = 0.5 + mod(gen, 20).div(100);

            const color = hslToRgb(hue, saturation, lightness);
            const finalColor = color.mul(isAlive);

            return vec4(finalColor, 1);
        });

        // Compute scene
        const gridSizeNode = vec2(cols, rows);
        const computeMaterial = new THREE.MeshBasicMaterial();
        computeMaterial.colorNode = gameOfLifeWithGen(
            texture(currentTexture),
            texture(currentGenTexture),
            gridSizeNode
        );

        const computeGeometry = new THREE.PlaneGeometry(2, 2);
        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(computeGeometry, computeMaterial);
        computeScene.add(computeMesh);

        const renderTarget = new THREE.WebGLRenderTarget(cols, rows, {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter
        });

        // Display scene
        const displayMaterial = new THREE.MeshBasicMaterial();
        displayMaterial.colorNode = chromaticDisplay(
            texture(currentTexture),
            texture(currentGenTexture)
        );

        const displayGeometry = new THREE.PlaneGeometry(2, 2);
        const displayMesh = new THREE.Mesh(displayGeometry, displayMaterial);
        scene.add(displayMesh);

        let frameCount = 0;

        function animate() {
            frameCount++;

            // Update every 3 frames
            if (frameCount % 3 === 0) {
                computeMaterial.colorNode = gameOfLifeWithGen(
                    texture(currentTexture),
                    texture(currentGenTexture),
                    gridSizeNode
                );
                computeMaterial.needsUpdate = true;
                renderer.setRenderTarget(renderTarget);
                renderer.render(computeScene, camera);

                const pixels = new Uint8Array(cols * rows * 4);
                renderer.readRenderTargetPixels(renderTarget, 0, 0, cols, rows, pixels);

                for (let i = 0; i < cols * rows; i++) {
                    const state = pixels[i * 4];
                    const gen = pixels[i * 4 + 1];
                    nextTexture.image.data[i * 4] = state;
                    nextTexture.image.data[i * 4 + 1] = state;
                    nextTexture.image.data[i * 4 + 2] = state;
                    nextTexture.image.data[i * 4 + 3] = 255;
                    nextGenTexture.image.data[i * 4] = gen;
                    nextGenTexture.image.data[i * 4 + 1] = gen;
                    nextGenTexture.image.data[i * 4 + 2] = gen;
                    nextGenTexture.image.data[i * 4 + 3] = 255;
                }

                nextTexture.needsUpdate = true;
                nextGenTexture.needsUpdate = true;

                [currentTexture, nextTexture] = [nextTexture, currentTexture];
                [currentGenTexture, nextGenTexture] = [nextGenTexture, currentGenTexture];

                renderer.setRenderTarget(null);
            }

            displayMaterial.colorNode = chromaticDisplay(
                texture(currentTexture),
                texture(currentGenTexture)
            );
            displayMaterial.needsUpdate = true;
            renderer.render(scene, camera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
