<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life - Color Trails (TSL)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        canvas {
            border: 2px solid #333;
            margin: 20px 0;
        }
        h1 {
            font-size: 24px;
            margin: 0 0 10px 0;
        }
        .tech-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 15px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>ðŸŒˆ Game of Life - Color Trails</h1>
    <div class="tech-badge">GPU-Accelerated â€¢ Three.js TSL â€¢ Rainbow Trails</div>
    <p>Cells leave rainbow trails based on their age</p>
    <canvas id="canvas"></canvas>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
            "three/nodes": "https://unpkg.com/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as Nodes from 'three/nodes';

        const {
            texture, uv, vec2, vec3, vec4, float,
            Fn, fract, mix, step, min, mod
        } = Nodes;

        const cellSize = 8;
        const cols = 100;
        const rows = 80;
        const canvas = document.getElementById('canvas');
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(cols * cellSize, rows * cellSize);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Initialize grids
        const gridData = new Uint8Array(cols * rows * 4);
        const ageData = new Uint8Array(cols * rows * 4);
        for (let i = 0; i < cols * rows; i++) {
            const alive = Math.random() > 0.7 ? 255 : 0;
            gridData[i * 4] = alive;
            gridData[i * 4 + 1] = alive;
            gridData[i * 4 + 2] = alive;
            gridData[i * 4 + 3] = 255;
            ageData[i * 4] = 0;
            ageData[i * 4 + 1] = 0;
            ageData[i * 4 + 2] = 0;
            ageData[i * 4 + 3] = 255;
        }

        const gridTexture1 = new THREE.DataTexture(gridData, cols, rows, THREE.RGBAFormat);
        gridTexture1.needsUpdate = true;
        gridTexture1.magFilter = THREE.NearestFilter;
        gridTexture1.minFilter = THREE.NearestFilter;

        const gridTexture2 = gridTexture1.clone();
        gridTexture2.needsUpdate = true;

        const ageTexture1 = new THREE.DataTexture(ageData, cols, rows, THREE.RGBAFormat);
        ageTexture1.needsUpdate = true;
        ageTexture1.magFilter = THREE.NearestFilter;
        ageTexture1.minFilter = THREE.NearestFilter;

        const ageTexture2 = ageTexture1.clone();
        ageTexture2.needsUpdate = true;

        let currentTexture = gridTexture1;
        let nextTexture = gridTexture2;
        let currentAgeTexture = ageTexture1;
        let nextAgeTexture = ageTexture2;

        // TSL: Count neighbors
        const countNeighbors = Fn(([gridTex, coord, gridSize]) => {
            let count = float(0);
            const pixelSize = vec2(1.0).div(gridSize);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const offset = vec2(dx, dy).mul(pixelSize);
                    const neighborCoord = fract(coord.add(offset));
                    const neighborValue = texture(gridTex, neighborCoord).r;
                    count = count.add(step(0.5, neighborValue));
                }
            }
            return count;
        });

        // TSL: Game of Life with age
        const gameOfLifeWithAge = Fn(([currentTex, currentAgeTex, gridSize]) => {
            const coord = uv();
            const currentState = texture(currentTex, coord).r;
            const currentAge = texture(currentAgeTex, coord).r;
            const isAlive = step(0.5, currentState);
            const neighbors = countNeighbors(currentTex, coord, gridSize);

            const survives = isAlive.mul(step(1.5, neighbors)).mul(step(neighbors, 3.5));
            const born = isAlive.oneMinus().mul(step(2.9, neighbors)).mul(step(neighbors, 3.1));
            const newState = survives.add(born);

            // Increment age for surviving cells, reset for new births
            const newAge = survives.mul(currentAge.add(1.0 / 255.0))
                .add(born.mul(0));

            return vec4(newState, newAge, 0, 1);
        });

        // TSL: HSV to RGB
        const hsvToRgb = Fn(([h, s, v]) => {
            const c = v.mul(s);
            const x = c.mul(mod(h.mul(6), 2).sub(1).abs().oneMinus());
            const m = v.sub(c);

            const hue6 = h.mul(6);
            const r = mix(mix(mix(c, x, step(1, hue6)), float(0), step(2, hue6)),
                         mix(float(0), x, step(4, hue6)), step(3, hue6));
            const g = mix(mix(x, c, step(1, hue6)), x, step(4, hue6));
            const b = mix(mix(float(0), x, step(3, hue6)), c, step(5, hue6));

            return vec3(r.add(m), g.add(m), b.add(m));
        });

        // TSL: Color trails display
        const colorTrailsDisplay = Fn(([gridTex, ageTex]) => {
            const coord = uv();
            const cellState = texture(gridTex, coord).r;
            const cellAge = texture(ageTex, coord).r;
            const isAlive = step(0.5, cellState);

            // Create rainbow effect based on age
            const hue = mod(cellAge.mul(10), 1.0);
            const saturation = 0.8 + mod(cellAge.mul(20), 0.2);
            const lightness = 0.5 + mod(cellAge.mul(30), 0.3);

            const color = hsvToRgb(hue, saturation, lightness);
            const finalColor = color.mul(isAlive);

            return vec4(finalColor, 1);
        });

        // Compute scene
        const gridSizeNode = vec2(cols, rows);
        const computeMaterial = new THREE.MeshBasicMaterial();
        computeMaterial.colorNode = gameOfLifeWithAge(
            texture(currentTexture),
            texture(currentAgeTexture),
            gridSizeNode
        );

        const computeGeometry = new THREE.PlaneGeometry(2, 2);
        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(computeGeometry, computeMaterial);
        computeScene.add(computeMesh);

        const renderTarget = new THREE.WebGLRenderTarget(cols, rows, {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter
        });

        // Display scene
        const displayMaterial = new THREE.MeshBasicMaterial();
        displayMaterial.colorNode = colorTrailsDisplay(
            texture(currentTexture),
            texture(currentAgeTexture)
        );

        const displayGeometry = new THREE.PlaneGeometry(2, 2);
        const displayMesh = new THREE.Mesh(displayGeometry, displayMaterial);
        scene.add(displayMesh);

        let frameCount = 0;

        function animate() {
            frameCount++;

            // Update every 3 frames
            if (frameCount % 3 === 0) {
                computeMaterial.colorNode = gameOfLifeWithAge(
                    texture(currentTexture),
                    texture(currentAgeTexture),
                    gridSizeNode
                );
                computeMaterial.needsUpdate = true;
                renderer.setRenderTarget(renderTarget);
                renderer.render(computeScene, camera);

                const pixels = new Uint8Array(cols * rows * 4);
                renderer.readRenderTargetPixels(renderTarget, 0, 0, cols, rows, pixels);

                for (let i = 0; i < cols * rows; i++) {
                    const state = pixels[i * 4];
                    const age = pixels[i * 4 + 1];
                    nextTexture.image.data[i * 4] = state;
                    nextTexture.image.data[i * 4 + 1] = state;
                    nextTexture.image.data[i * 4 + 2] = state;
                    nextTexture.image.data[i * 4 + 3] = 255;
                    nextAgeTexture.image.data[i * 4] = age;
                    nextAgeTexture.image.data[i * 4 + 1] = age;
                    nextAgeTexture.image.data[i * 4 + 2] = age;
                    nextAgeTexture.image.data[i * 4 + 3] = 255;
                }

                nextTexture.needsUpdate = true;
                nextAgeTexture.needsUpdate = true;

                [currentTexture, nextTexture] = [nextTexture, currentTexture];
                [currentAgeTexture, nextAgeTexture] = [nextAgeTexture, currentAgeTexture];

                renderer.setRenderTarget(null);
            }

            displayMaterial.colorNode = colorTrailsDisplay(
                texture(currentTexture),
                texture(currentAgeTexture)
            );
            displayMaterial.needsUpdate = true;
            renderer.render(scene, camera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
