<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shepard Tone Spiral Illusion - Cymatics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #8A9A5B;
            background: rgba(10,14,26,0.8);
            border-radius: 25px;
            border: 2px solid #8A9A5B;
            padding: 10px 20px;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
            transition: background 0.3s, color 0.3s;
        }
        .back-link:hover {
            background: #8A9A5B;
            color: #0a0e1a;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10,14,26,0.85);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            max-width: 300px;
            border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h3 {
            color: #8A9A5B;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #8A9A5B;
        }
        .control-group .value {
            font-size: 11px;
            color: #8A9A5B;
            float: right;
        }
        .control-group button {
            width: 100%;
            padding: 8px;
            background: rgba(138,154,91,0.3);
            color: #8A9A5B;
            border: 1px solid #8A9A5B;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.3s;
        }
        .control-group button:hover {
            background: rgba(138,154,91,0.5);
        }
        .control-group button.active {
            background: #8A9A5B;
            color: #0a0e1a;
        }
        .info-text {
            font-size: 10px;
            color: #666;
            line-height: 1.5;
            margin-top: 10px;
            border-top: 1px solid rgba(100,100,100,0.3);
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Cymatics</a>
    <div class="controls">
        <h3>Shepard Tone</h3>
        <div class="control-group">
            <label>Speed <span class="value" id="speedVal">1.0</span></label>
            <input type="range" id="speed" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Octave Components <span class="value" id="octavesVal">8</span></label>
            <input type="range" id="octaves" min="4" max="12" step="1" value="8">
        </div>
        <div class="control-group">
            <label>Envelope Width <span class="value" id="envVal">0.40</span></label>
            <input type="range" id="envWidth" min="0.15" max="0.8" step="0.05" value="0.4">
        </div>
        <div class="control-group">
            <button id="audioBtn">Play Audio</button>
        </div>
        <div class="info-text">
            The Shepard tone creates an auditory illusion of a pitch that seems to rise (or fall) forever. Multiple sine tones spaced an octave apart fade in and out via a Gaussian spectral envelope.
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }
        resize();
        window.addEventListener('resize', resize);

        const W = () => window.innerWidth;
        const H = () => window.innerHeight;

        const speedSlider = document.getElementById('speed');
        const octavesSlider = document.getElementById('octaves');
        const envSlider = document.getElementById('envWidth');
        const audioBtn = document.getElementById('audioBtn');

        let audioPlaying = false;
        let audioCtx = null;
        let oscillators = [];
        let gainNodes = [];

        function startAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            stopAudio();
            const numOsc = parseInt(octavesSlider.value);
            for (let i = 0; i < numOsc; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 100;
                gain.gain.value = 0;
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                oscillators.push(osc);
                gainNodes.push(gain);
            }
            audioPlaying = true;
            audioBtn.textContent = 'Mute Audio';
            audioBtn.classList.add('active');
        }

        function stopAudio() {
            for (const osc of oscillators) {
                try { osc.stop(); } catch (e) {}
            }
            oscillators = [];
            gainNodes = [];
            audioPlaying = false;
            audioBtn.textContent = 'Play Audio';
            audioBtn.classList.remove('active');
        }

        audioBtn.addEventListener('click', () => {
            if (audioPlaying) stopAudio();
            else startAudio();
        });

        let phase = 0;
        let paused = false;
        let animId;

        // Gaussian envelope
        function gaussian(x, sigma) {
            return Math.exp(-(x * x) / (2 * sigma * sigma));
        }

        function reset() {
            phase = 0;
            stopAudio();
        }
        window.reset = reset;

        function animate() {
            animId = requestAnimationFrame(animate);
            if (paused) return;

            const w = W();
            const h = H();
            ctx.clearRect(0, 0, w, h);

            const speed = parseFloat(speedSlider.value);
            const numOctaves = parseInt(octavesSlider.value);
            const envWidth = parseFloat(envSlider.value);

            document.getElementById('speedVal').textContent = speed.toFixed(1);
            document.getElementById('octavesVal').textContent = numOctaves;
            document.getElementById('envVal').textContent = envWidth.toFixed(2);

            phase += speed * 0.005;
            if (phase >= 1.0) phase -= 1.0;

            const cx = w * 0.42;
            const cy = h * 0.5;
            const maxRadius = Math.min(w, h) * 0.35;
            const minRadius = 30;

            // Draw the helix / barber-pole pattern
            // Each component is a ring at a certain radius, the rings shift outward over time

            // Background circles (guides)
            for (let r = minRadius; r <= maxRadius; r += (maxRadius - minRadius) / numOctaves) {
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(60,70,90,0.15)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Center label
            ctx.fillStyle = 'rgba(138,154,91,0.3)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('LOW', cx, cy + minRadius - 10);
            ctx.fillText('HIGH', cx, cy - maxRadius + 15);

            // Draw components
            const components = [];
            for (let i = 0; i < numOctaves; i++) {
                // Each component slides through the octave range
                let pos = (i / numOctaves + phase) % 1.0; // 0=lowest, 1=highest

                // Gaussian envelope based on position in the spectral range
                const envCenter = 0.5;
                const amplitude = gaussian(pos - envCenter, envWidth);

                // Radius from center based on position (low=inner, high=outer)
                const radius = minRadius + pos * (maxRadius - minRadius);

                // Frequency for audio
                const baseFreq = 65.41; // C2
                const freq = baseFreq * Math.pow(2, pos * (numOctaves / 2));

                components.push({ pos, amplitude, radius, freq, index: i });
            }

            // Draw spiral arms connecting components
            const spiralResolution = 200;
            for (let arm = 0; arm < 3; arm++) {
                const armOffset = arm / 3;
                ctx.beginPath();
                for (let s = 0; s <= spiralResolution; s++) {
                    const frac = s / spiralResolution;
                    const r = minRadius + frac * (maxRadius - minRadius);
                    const angle = frac * Math.PI * 8 + phase * Math.PI * 2 + armOffset * Math.PI * 2;
                    const px = cx + Math.cos(angle) * r;
                    const py = cy + Math.sin(angle) * r;

                    const envAmp = gaussian(frac - 0.5, envWidth);

                    if (s === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.strokeStyle = `rgba(221,161,94,0.06)`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw each component as arcs
            for (const comp of components) {
                const alpha = comp.amplitude;
                if (alpha < 0.01) continue;

                // Rotating angle based on position
                const angle = comp.pos * Math.PI * 8 + phase * Math.PI * 6;
                const arcLen = Math.PI * 0.6;

                // Color: warm gradient fading at extremes
                const hue = 30 + comp.pos * 30; // orange to yellow
                const sat = 80 + alpha * 20;
                const light = 40 + alpha * 35;

                // Glow
                ctx.beginPath();
                ctx.arc(cx, cy, comp.radius, angle - arcLen / 2, angle + arcLen / 2);
                ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.15})`;
                ctx.lineWidth = 20 * alpha;
                ctx.stroke();

                // Main arc
                ctx.beginPath();
                ctx.arc(cx, cy, comp.radius, angle - arcLen / 2, angle + arcLen / 2);
                ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.9})`;
                ctx.lineWidth = 6 * alpha + 2;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Dot at arc center
                const dotX = cx + Math.cos(angle) * comp.radius;
                const dotY = cy + Math.sin(angle) * comp.radius;

                ctx.beginPath();
                ctx.arc(dotX, dotY, 4 * alpha + 2, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${hue}, ${sat}%, ${Math.min(light + 20, 90)}%, ${alpha})`;
                ctx.fill();
            }

            // Draw the spectral envelope on the right side
            const envX = w * 0.78;
            const envY = h * 0.15;
            const envH = h * 0.7;
            const envW = 80;

            ctx.strokeStyle = 'rgba(138,154,91,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(envX, envY);
            ctx.lineTo(envX, envY + envH);
            ctx.stroke();

            ctx.fillStyle = '#8A9A5B';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Spectral', envX + envW / 2, envY - 15);
            ctx.fillText('Envelope', envX + envW / 2, envY - 3);
            ctx.fillStyle = '#666';
            ctx.fillText('HIGH', envX - 15, envY + 10);
            ctx.fillText('LOW', envX - 15, envY + envH - 5);

            // Envelope curve
            ctx.beginPath();
            for (let y = 0; y <= envH; y++) {
                const frac = y / envH;
                const amp = gaussian(frac - 0.5, envWidth);
                const px = envX + amp * envW;
                if (y === 0) ctx.moveTo(px, envY + y);
                else ctx.lineTo(px, envY + y);
            }
            ctx.strokeStyle = 'rgba(221,161,94,0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Fill
            ctx.lineTo(envX, envY + envH);
            ctx.lineTo(envX, envY);
            ctx.closePath();
            ctx.fillStyle = 'rgba(221,161,94,0.08)';
            ctx.fill();

            // Component markers on envelope
            for (const comp of components) {
                const ey = envY + comp.pos * envH;
                const ex = envX + comp.amplitude * envW;
                ctx.beginPath();
                ctx.arc(ex, ey, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(221,161,94,${comp.amplitude})`;
                ctx.fill();
            }

            // Update audio
            if (audioPlaying && oscillators.length > 0) {
                const now = audioCtx.currentTime;
                for (let i = 0; i < Math.min(oscillators.length, components.length); i++) {
                    const comp = components[i];
                    const clampedFreq = Math.max(20, Math.min(comp.freq, 8000));
                    oscillators[i].frequency.setTargetAtTime(clampedFreq, now, 0.02);
                    gainNodes[i].gain.setTargetAtTime(comp.amplitude * 0.08, now, 0.02);
                }
            }

            // Direction arrow
            ctx.fillStyle = 'rgba(138,154,91,0.5)';
            ctx.font = '13px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('\u2191 Endlessly ascending \u2191', cx, h - 30);
            ctx.fillStyle = '#666';
            ctx.font = '11px sans-serif';
            ctx.fillText('Components fade in at bottom, fade out at top - pitch rises forever', cx, h - 12);
        }

        animate();

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cancelAnimationFrame(animId);
                if (audioPlaying) {
                    for (const g of gainNodes) g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
                }
            } else {
                animate();
            }
        });
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>