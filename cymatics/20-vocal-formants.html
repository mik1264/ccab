<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vowel Frequency Patterns - Cymatics</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; color: #c8d0e0; }
canvas { display: block; }
.back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
    background: rgba(10,14,26,0.8); border-radius: 25px;
    border: 2px solid #8A9A5B; padding: 10px 20px;
    transition: all 0.3s ease;
}
.back-link:hover { background: #8A9A5B; color: #0a0e1a; }
.controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
    border-radius: 10px; padding: 20px; max-width: 300px;
    border: 1px solid rgba(138,154,91,0.3);
}
.controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
.control-row { margin-bottom: 10px; }
.control-row label { display: block; font-size: 12px; color: #8a92a8; margin-bottom: 3px; }
.control-row input[type="range"] { width: 100%; accent-color: #8A9A5B; }
.control-row .value { float: right; color: #DDA15E; font-size: 12px; font-weight: 600; }
.control-row button {
    background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
    padding: 8px 14px; border-radius: 5px; cursor: pointer; font-size: 13px; margin: 2px;
    transition: all 0.2s; min-width: 42px;
}
.control-row button:hover { background: rgba(138,154,91,0.4); }
.control-row button.active { background: #8A9A5B; color: #0a0e1a; }
.control-row .vowel-btns { display: flex; flex-wrap: wrap; gap: 4px; }
.control-row .toggle-btns { display: flex; gap: 4px; margin-top: 6px; }
.control-row .toggle-btns button { font-size: 10px; padding: 4px 8px; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Cymatics</a>

<div class="controls">
    <h3>Vocal Formants</h3>
    <div class="control-row">
        <label>Vowel</label>
        <div class="vowel-btns">
            <button class="vowel-btn active" data-vowel="ah">"ah" /&#x0251;/</button>
            <button class="vowel-btn" data-vowel="ee">"ee" /i/</button>
            <button class="vowel-btn" data-vowel="oo">"oo" /u/</button>
            <button class="vowel-btn" data-vowel="eh">"eh" /&#x025B;/</button>
            <button class="vowel-btn" data-vowel="oh">"oh" /o/</button>
        </div>
    </div>
    <div class="control-row">
        <label>Fundamental Freq (Pitch) <span class="value" id="f0Val">120</span> Hz</label>
        <input type="range" id="f0Slider" min="60" max="300" value="120">
    </div>
    <div class="control-row">
        <label>Formant Bandwidth <span class="value" id="bwVal">80</span> Hz</label>
        <input type="range" id="bwSlider" min="30" max="200" value="80">
    </div>
    <div class="control-row">
        <label>Show</label>
        <div class="toggle-btns">
            <button id="showWave" class="active">Waveform</button>
            <button id="showSpec" class="active">Spectrum</button>
            <button id="showVowel" class="active">Vowel Space</button>
        </div>
    </div>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
let time = 0;
let running = true;

// Vowel formant data: F1, F2, F3 (Hz)
const vowels = {
    ah: { label: '"ah" /\u0251/', f1: 700, f2: 1200, f3: 2600, color: '#ff6b6b', tongue: 'low-back' },
    ee: { label: '"ee" /i/', f1: 300, f2: 2300, f3: 3000, color: '#4ecdc4', tongue: 'high-front' },
    oo: { label: '"oo" /u/', f1: 300, f2: 900, f3: 2300, color: '#45b7d1', tongue: 'high-back' },
    eh: { label: '"eh" /\u025B/', f1: 500, f2: 1800, f3: 2700, color: '#f7dc6f', tongue: 'mid-front' },
    oh: { label: '"oh" /o/', f1: 400, f2: 800, f3: 2500, color: '#bb8fce', tongue: 'mid-back' }
};

let currentVowel = 'ah';
let f0 = 120; // fundamental frequency
let bandwidth = 80;
let showWaveform = true, showSpectrum = true, showVowelSpace = true;

// Waveform buffer
const WAVE_SAMPLES = 512;
let waveBuffer = new Float64Array(WAVE_SAMPLES);

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Generate formant-filtered glottal pulse
function generateVowelSignal(t, N) {
    const vowel = vowels[currentVowel];
    const samples = new Float64Array(N);
    const dt = 1 / 16000;

    for (let i = 0; i < N; i++) {
        const ti = t + i * dt;

        // Glottal pulse (sum of harmonics)
        let glottal = 0;
        const numHarmonics = Math.floor(4000 / f0);
        for (let h = 1; h <= numHarmonics; h++) {
            const freq = f0 * h;
            // Glottal spectrum rolls off at -12dB/octave
            const amp = 1.0 / (h * h);

            // Apply formant filter (resonances)
            let gain = 0;
            const formants = [vowel.f1, vowel.f2, vowel.f3];
            const bw = bandwidth;
            for (let f = 0; f < 3; f++) {
                const diff = freq - formants[f];
                const resonance = 1.0 / (1 + (diff * diff) / (bw * bw));
                gain += resonance;
            }

            glottal += amp * gain * Math.sin(2 * Math.PI * freq * ti);
        }

        samples[i] = glottal;
    }

    // Normalize
    let maxAbs = 0;
    for (let i = 0; i < N; i++) maxAbs = Math.max(maxAbs, Math.abs(samples[i]));
    if (maxAbs > 0) for (let i = 0; i < N; i++) samples[i] /= maxAbs;

    return samples;
}

// Compute spectrum for display
function computeSpectrum(samples) {
    const N = samples.length;
    const spectrum = new Float64Array(N / 2);

    for (let k = 0; k < N / 2; k++) {
        let re = 0, im = 0;
        for (let n = 0; n < N; n++) {
            const angle = -2 * Math.PI * k * n / N;
            re += samples[n] * Math.cos(angle);
            im += samples[n] * Math.sin(angle);
        }
        spectrum[k] = Math.sqrt(re * re + im * im) / N;
    }
    return spectrum;
}

// Formant filter envelope (for spectrum overlay)
function formantEnvelope(freq) {
    const vowel = vowels[currentVowel];
    const formants = [vowel.f1, vowel.f2, vowel.f3];
    const bw = bandwidth;
    let gain = 0;
    for (let f = 0; f < 3; f++) {
        const diff = freq - formants[f];
        gain += 1.0 / (1 + (diff * diff) / (bw * bw));
    }
    return gain;
}

function drawWaveform() {
    if (!showWaveform) return;

    const plotX = W * 0.05;
    const plotY = H * 0.04;
    const plotW = W * 0.55;
    const plotH = H * 0.2;

    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.6)';
    ctx.fillRect(plotX, plotY, plotW, plotH);
    ctx.strokeStyle = 'rgba(138,154,91,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(plotX, plotY, plotW, plotH);

    // Zero line
    ctx.strokeStyle = 'rgba(138,154,91,0.15)';
    ctx.beginPath();
    ctx.moveTo(plotX, plotY + plotH / 2);
    ctx.lineTo(plotX + plotW, plotY + plotH / 2);
    ctx.stroke();

    // Waveform
    const vowel = vowels[currentVowel];
    ctx.beginPath();
    ctx.strokeStyle = vowel.color;
    ctx.lineWidth = 1.5;
    for (let i = 0; i < waveBuffer.length; i++) {
        const x = plotX + (i / waveBuffer.length) * plotW;
        const y = plotY + plotH / 2 - waveBuffer[i] * plotH * 0.4;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Label
    ctx.fillStyle = '#8A9A5B';
    ctx.font = '11px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Waveform - ' + vowel.label, plotX + 8, plotY + 14);
}

function drawSpectrum() {
    if (!showSpectrum) return;

    const plotX = W * 0.05;
    const plotY = showWaveform ? H * 0.28 : H * 0.04;
    const plotW = W * 0.55;
    const plotH = H * 0.35;
    const maxFreq = 4000;
    const sampleRate = 16000;

    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.6)';
    ctx.fillRect(plotX, plotY, plotW, plotH);
    ctx.strokeStyle = 'rgba(138,154,91,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(plotX, plotY, plotW, plotH);

    const vowel = vowels[currentVowel];
    const formants = [vowel.f1, vowel.f2, vowel.f3];
    const formantColors = ['#ff6b6b', '#4ecdc4', '#f7dc6f'];

    // Compute and draw spectrum
    const samples = generateVowelSignal(time, 512);
    const spectrum = computeSpectrum(samples);
    const freqBins = spectrum.length;

    // Normalize spectrum
    let maxSpec = 0;
    for (let i = 0; i < freqBins; i++) maxSpec = Math.max(maxSpec, spectrum[i]);

    // Draw filled spectrum with gradient per formant region
    ctx.beginPath();
    ctx.moveTo(plotX, plotY + plotH);
    for (let i = 0; i < freqBins; i++) {
        const freq = (i / freqBins) * (sampleRate / 2);
        if (freq > maxFreq) break;
        const x = plotX + (freq / maxFreq) * plotW;
        const y = plotY + plotH - (maxSpec > 0 ? (spectrum[i] / maxSpec) : 0) * plotH * 0.85;
        ctx.lineTo(x, y);
    }
    ctx.lineTo(plotX + plotW, plotY + plotH);
    ctx.closePath();

    // Gradient fill
    const grad = ctx.createLinearGradient(plotX, plotY, plotX, plotY + plotH);
    grad.addColorStop(0, vowel.color + '40');
    grad.addColorStop(1, vowel.color + '05');
    ctx.fillStyle = grad;
    ctx.fill();

    // Spectrum line
    ctx.beginPath();
    ctx.strokeStyle = vowel.color;
    ctx.lineWidth = 1.5;
    for (let i = 0; i < freqBins; i++) {
        const freq = (i / freqBins) * (sampleRate / 2);
        if (freq > maxFreq) break;
        const x = plotX + (freq / maxFreq) * plotW;
        const y = plotY + plotH - (maxSpec > 0 ? (spectrum[i] / maxSpec) : 0) * plotH * 0.85;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw formant envelope
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    let maxEnv = 0;
    for (let f = 0; f <= maxFreq; f += 10) maxEnv = Math.max(maxEnv, formantEnvelope(f));
    for (let f = 0; f <= maxFreq; f += 5) {
        const x = plotX + (f / maxFreq) * plotW;
        const env = formantEnvelope(f) / maxEnv;
        const y = plotY + plotH - env * plotH * 0.85;
        if (f === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Mark formant peaks
    for (let f = 0; f < 3; f++) {
        const fx = plotX + (formants[f] / maxFreq) * plotW;

        // Vertical line
        ctx.strokeStyle = formantColors[f] + '60';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(fx, plotY);
        ctx.lineTo(fx, plotY + plotH);
        ctx.stroke();
        ctx.setLineDash([]);

        // Label
        ctx.fillStyle = formantColors[f];
        ctx.font = 'bold 11px Segoe UI, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`F${f + 1}`, fx, plotY + 14);
        ctx.font = '10px Segoe UI, system-ui, sans-serif';
        ctx.fillText(`${formants[f]} Hz`, fx, plotY + 26);
    }

    // Frequency axis
    ctx.fillStyle = '#5a6278';
    ctx.font = '10px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    for (let f = 0; f <= maxFreq; f += 500) {
        const x = plotX + (f / maxFreq) * plotW;
        ctx.fillText(f + '', x, plotY + plotH + 14);
    }
    ctx.fillText('Frequency (Hz)', plotX + plotW / 2, plotY + plotH + 28);

    // Title
    ctx.fillStyle = '#8A9A5B';
    ctx.font = '11px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Frequency Spectrum (0-4000 Hz)', plotX + 8, plotY - 5);
}

function drawVowelSpace() {
    if (!showVowelSpace) return;

    // F1-F2 vowel space plot (standard linguistics diagram)
    // F2 on x-axis (reversed: high on left), F1 on y-axis (reversed: low at top)
    const plotX = W * 0.65;
    const plotY = H * 0.04;
    const plotW = W * 0.3;
    const plotH = H * 0.45;

    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.6)';
    ctx.fillRect(plotX, plotY, plotW, plotH);
    ctx.strokeStyle = 'rgba(138,154,91,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(plotX, plotY, plotW, plotH);

    // F2 range: 600-2500, F1 range: 200-800
    const f2Min = 600, f2Max = 2500;
    const f1Min = 200, f1Max = 800;

    // Grid
    ctx.strokeStyle = 'rgba(138,154,91,0.1)';
    ctx.lineWidth = 0.5;
    for (let f2 = 800; f2 <= 2400; f2 += 400) {
        const x = plotX + plotW - ((f2 - f2Min) / (f2Max - f2Min)) * plotW;
        ctx.beginPath();
        ctx.moveTo(x, plotY);
        ctx.lineTo(x, plotY + plotH);
        ctx.stroke();
        ctx.fillStyle = '#5a6278';
        ctx.font = '9px Segoe UI, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(f2 + '', x, plotY + plotH + 12);
    }
    for (let f1 = 300; f1 <= 700; f1 += 100) {
        const y = plotY + ((f1 - f1Min) / (f1Max - f1Min)) * plotH;
        ctx.beginPath();
        ctx.moveTo(plotX, y);
        ctx.lineTo(plotX + plotW, y);
        ctx.stroke();
        ctx.fillStyle = '#5a6278';
        ctx.font = '9px Segoe UI, system-ui, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(f1 + '', plotX - 5, y + 3);
    }

    // Axis labels
    ctx.fillStyle = '#8a92a8';
    ctx.font = '11px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('F2 (Hz) \u2190', plotX + plotW / 2, plotY + plotH + 26);
    ctx.save();
    ctx.translate(plotX - 25, plotY + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('\u2190 F1 (Hz)', 0, 0);
    ctx.restore();

    // Vowel trapezoid (connecting vowel positions)
    const vowelOrder = ['ee', 'eh', 'ah', 'oh', 'oo'];
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(138,154,91,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    for (let i = 0; i <= vowelOrder.length; i++) {
        const v = vowels[vowelOrder[i % vowelOrder.length]];
        const x = plotX + plotW - ((v.f2 - f2Min) / (f2Max - f2Min)) * plotW;
        const y = plotY + ((v.f1 - f1Min) / (f1Max - f1Min)) * plotH;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Plot each vowel
    for (const key in vowels) {
        const v = vowels[key];
        const x = plotX + plotW - ((v.f2 - f2Min) / (f2Max - f2Min)) * plotW;
        const y = plotY + ((v.f1 - f1Min) / (f1Max - f1Min)) * plotH;

        const isActive = key === currentVowel;
        const radius = isActive ? 12 : 8;

        // Glow for active
        if (isActive) {
            ctx.beginPath();
            ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
            ctx.fillStyle = v.color + '20';
            ctx.fill();
        }

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = isActive ? v.color : v.color + '80';
        ctx.fill();
        ctx.strokeStyle = isActive ? '#fff' : v.color;
        ctx.lineWidth = isActive ? 2 : 1;
        ctx.stroke();

        // Label
        ctx.fillStyle = isActive ? '#fff' : '#8a92a8';
        ctx.font = (isActive ? 'bold ' : '') + '12px Segoe UI, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(v.label, x, y - radius - 6);
    }

    // Title
    ctx.fillStyle = '#8A9A5B';
    ctx.font = '11px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('F1-F2 Vowel Space', plotX + 8, plotY - 5);

    // Corner labels
    ctx.fillStyle = '#5a6278';
    ctx.font = '9px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Front', plotX + plotW - 30, plotY + 12);
    ctx.textAlign = 'right';
    ctx.fillText('Back', plotX + 30, plotY + 12);
    ctx.textAlign = 'left';
    ctx.fillText('High', plotX + 5, plotY + 14);
    ctx.fillText('Low', plotX + 5, plotY + plotH - 5);
}

function drawVocalTract() {
    const vowel = vowels[currentVowel];
    const tractX = W * 0.65;
    const tractY = H * 0.55;
    const tractW = W * 0.3;
    const tractH = H * 0.38;

    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.6)';
    ctx.fillRect(tractX, tractY, tractW, tractH);
    ctx.strokeStyle = 'rgba(138,154,91,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(tractX, tractY, tractW, tractH);

    const cx = tractX + tractW / 2;
    const cy = tractY + tractH / 2;
    const scale = Math.min(tractW, tractH) * 0.35;

    // Simplified vocal tract cross-section
    // Show mouth outline, tongue position, lips

    // Outer mouth/pharynx shape
    ctx.beginPath();
    ctx.strokeStyle = '#8a92a8';
    ctx.lineWidth = 2;

    // Back wall (pharynx)
    ctx.moveTo(cx - scale * 0.6, cy - scale * 0.8);
    ctx.lineTo(cx - scale * 0.6, cy + scale * 0.5);

    // Bottom (floor of mouth)
    ctx.quadraticCurveTo(cx - scale * 0.3, cy + scale * 0.7, cx + scale * 0.6, cy + scale * 0.5);

    // Front (lips area)
    ctx.stroke();

    // Palate (roof)
    ctx.beginPath();
    ctx.moveTo(cx - scale * 0.6, cy - scale * 0.8);
    ctx.quadraticCurveTo(cx, cy - scale, cx + scale * 0.6, cy - scale * 0.3);
    ctx.strokeStyle = '#8a92a8';
    ctx.stroke();

    // Tongue shape depends on vowel
    ctx.beginPath();
    ctx.fillStyle = vowel.color + '40';
    ctx.strokeStyle = vowel.color;
    ctx.lineWidth = 2.5;

    switch (vowel.tongue) {
        case 'high-front': // ee
            ctx.moveTo(cx - scale * 0.5, cy + scale * 0.3);
            ctx.quadraticCurveTo(cx - scale * 0.1, cy - scale * 0.6, cx + scale * 0.3, cy - scale * 0.1);
            ctx.quadraticCurveTo(cx + scale * 0.5, cy + scale * 0.1, cx + scale * 0.5, cy + scale * 0.3);
            break;
        case 'low-back': // ah
            ctx.moveTo(cx - scale * 0.5, cy + scale * 0.3);
            ctx.quadraticCurveTo(cx - scale * 0.3, cy + scale * 0.1, cx, cy + scale * 0.2);
            ctx.quadraticCurveTo(cx + scale * 0.3, cy + scale * 0.3, cx + scale * 0.5, cy + scale * 0.3);
            break;
        case 'high-back': // oo
            ctx.moveTo(cx - scale * 0.5, cy + scale * 0.3);
            ctx.quadraticCurveTo(cx - scale * 0.35, cy - scale * 0.4, cx - scale * 0.1, cy - scale * 0.1);
            ctx.quadraticCurveTo(cx + scale * 0.2, cy + scale * 0.2, cx + scale * 0.5, cy + scale * 0.3);
            break;
        case 'mid-front': // eh
            ctx.moveTo(cx - scale * 0.5, cy + scale * 0.3);
            ctx.quadraticCurveTo(cx - scale * 0.1, cy - scale * 0.2, cx + scale * 0.2, cy + scale * 0.05);
            ctx.quadraticCurveTo(cx + scale * 0.4, cy + scale * 0.2, cx + scale * 0.5, cy + scale * 0.3);
            break;
        case 'mid-back': // oh
            ctx.moveTo(cx - scale * 0.5, cy + scale * 0.3);
            ctx.quadraticCurveTo(cx - scale * 0.25, cy - scale * 0.1, cx, cy + scale * 0.1);
            ctx.quadraticCurveTo(cx + scale * 0.3, cy + scale * 0.25, cx + scale * 0.5, cy + scale * 0.3);
            break;
    }

    ctx.fill();
    ctx.stroke();

    // Lip opening (varies by vowel)
    const lipOpenings = {
        ah: 0.6, ee: 0.25, oo: 0.15, eh: 0.4, oh: 0.2
    };
    const lipOpen = lipOpenings[currentVowel] * scale;
    const lipX = cx + scale * 0.6;
    const lipY = cy - scale * 0.1;

    // Lips
    ctx.beginPath();
    ctx.strokeStyle = '#cc7777';
    ctx.lineWidth = 3;
    ctx.moveTo(lipX, lipY - lipOpen);
    ctx.lineTo(lipX + scale * 0.15, lipY - lipOpen * 0.5);
    ctx.moveTo(lipX, lipY + lipOpen);
    ctx.lineTo(lipX + scale * 0.15, lipY + lipOpen * 0.5);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#5a6278';
    ctx.font = '9px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('pharynx', cx - scale * 0.55, cy - scale * 0.9);
    ctx.fillText('palate', cx, cy - scale * 1.05);
    ctx.fillText('lips', lipX + scale * 0.15, lipY - lipOpen - 8);

    // Tongue label
    ctx.fillStyle = vowel.color;
    ctx.font = 'bold 10px Segoe UI, system-ui, sans-serif';
    ctx.fillText('tongue', cx, cy + scale * 0.55);

    // Title
    ctx.fillStyle = '#8A9A5B';
    ctx.font = '11px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Vocal Tract Shape - ' + vowel.label, tractX + 8, tractY - 5);
}

function animate() {
    if (running) {
        time += 0.01;
    }

    // Generate new waveform samples
    waveBuffer = generateVowelSignal(time, WAVE_SAMPLES);

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    drawWaveform();
    drawSpectrum();
    drawVowelSpace();
    drawVocalTract();

    requestAnimationFrame(animate);
}

// Vowel buttons
document.querySelectorAll('.vowel-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        currentVowel = this.dataset.vowel;
        document.querySelectorAll('.vowel-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
    });
});

document.getElementById('f0Slider').addEventListener('input', function() {
    f0 = parseInt(this.value);
    document.getElementById('f0Val').textContent = f0;
});

document.getElementById('bwSlider').addEventListener('input', function() {
    bandwidth = parseInt(this.value);
    document.getElementById('bwVal').textContent = bandwidth;
});

document.getElementById('showWave').addEventListener('click', function() {
    showWaveform = !showWaveform;
    this.classList.toggle('active', showWaveform);
});

document.getElementById('showSpec').addEventListener('click', function() {
    showSpectrum = !showSpectrum;
    this.classList.toggle('active', showSpectrum);
});

document.getElementById('showVowel').addEventListener('click', function() {
    showVowelSpace = !showVowelSpace;
    this.classList.toggle('active', showVowelSpace);
});

window.reset = function() {
    currentVowel = 'ah'; f0 = 120; bandwidth = 80; time = 0;
    showWaveform = true; showSpectrum = true; showVowelSpace = true;
    document.getElementById('f0Slider').value = 120;
    document.getElementById('bwSlider').value = 80;
    document.getElementById('f0Val').textContent = '120';
    document.getElementById('bwVal').textContent = '80';
    document.querySelectorAll('.vowel-btn').forEach(b => b.classList.remove('active'));
    document.querySelector('[data-vowel="ah"]').classList.add('active');
    document.getElementById('showWave').classList.add('active');
    document.getElementById('showSpec').classList.add('active');
    document.getElementById('showVowel').classList.add('active');
    resize();
};

window.togglePause = function() { running = !running; };

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
