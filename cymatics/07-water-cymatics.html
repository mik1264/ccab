<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Surface Cymatics - Cymatics - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #8A9A5B;
            text-decoration: none;
            font-weight: 600;
            background: rgba(10, 14, 26, 0.8);
            border-radius: 25px;
            border: 2px solid #8A9A5B;
            padding: 10px 20px;
            transition: background 0.3s, transform 0.3s;
        }
        .back-link:hover {
            background: rgba(138, 154, 91, 0.2);
            transform: translateX(-3px);
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 14, 26, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            max-width: 300px;
            border: 1px solid rgba(138, 154, 91, 0.3);
        }
        .controls h3 {
            color: #8A9A5B;
            margin-bottom: 15px;
            font-size: 1rem;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            color: #8A9A5B;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #8A9A5B;
        }
        .control-group .value {
            color: #aaa;
            font-size: 0.75rem;
            text-align: right;
        }
        .hint {
            color: rgba(138, 154, 91, 0.6);
            font-size: 0.7rem;
            margin-top: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Cymatics</a>
    <div class="controls">
        <h3>Water Surface Patterns</h3>
        <div class="control-group">
            <label>Frequency: <span id="freqVal">12</span> Hz</label>
            <input type="range" id="freq" min="3" max="40" value="12" step="0.5">
        </div>
        <div class="control-group">
            <label>Amplitude: <span id="ampVal">60</span>%</label>
            <input type="range" id="amplitude" min="10" max="100" value="60" step="1">
        </div>
        <div class="control-group">
            <label>Damping: <span id="dampVal">2</span>%</label>
            <input type="range" id="damping" min="0" max="10" value="2" step="0.5">
        </div>
        <div class="control-group">
            <label>Dish Radius: <span id="radiusVal">85</span>%</label>
            <input type="range" id="radius" min="40" max="95" value="85" step="1">
        </div>
        <p class="hint">Click anywhere on the dish to add a disturbance</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Wave simulation grid
        const N = 200;
        let u = new Float32Array(N * N);      // current
        let uPrev = new Float32Array(N * N);  // previous
        let uNext = new Float32Array(N * N);  // next

        // Parameters
        let frequency = 12;
        let amplitude = 0.6;
        let damping = 0.02;
        let dishRadiusPct = 0.85;

        // Precompute circular mask
        let mask = new Uint8Array(N * N);
        function computeMask() {
            const cx = N / 2, cy = N / 2;
            const r = (N / 2) * dishRadiusPct;
            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const dx = i - cx, dy = j - cy;
                    mask[j * N + i] = (dx * dx + dy * dy < r * r) ? 1 : 0;
                }
            }
        }
        computeMask();

        // Controls
        document.getElementById('freq').addEventListener('input', e => {
            frequency = parseFloat(e.target.value);
            document.getElementById('freqVal').textContent = frequency;
        });
        document.getElementById('amplitude').addEventListener('input', e => {
            amplitude = parseInt(e.target.value) / 100;
            document.getElementById('ampVal').textContent = e.target.value;
        });
        document.getElementById('damping').addEventListener('input', e => {
            damping = parseFloat(e.target.value) / 100;
            document.getElementById('dampVal').textContent = e.target.value;
        });
        document.getElementById('radius').addEventListener('input', e => {
            dishRadiusPct = parseInt(e.target.value) / 100;
            document.getElementById('radiusVal').textContent = e.target.value;
            computeMask();
        });

        // Click to disturb
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) / rect.width;
            const my = (e.clientY - rect.top) / rect.height;

            // Map to simulation grid
            const size = Math.min(W, H) * dishRadiusPct;
            const offX = (W - size) / 2;
            const offY = (H - size) / 2;

            const gi = Math.floor(((e.clientX - offX) / size) * N);
            const gj = Math.floor(((e.clientY - offY) / size) * N);

            if (gi >= 0 && gi < N && gj >= 0 && gj < N) {
                // Add gaussian disturbance
                const rad = 8;
                for (let dy = -rad; dy <= rad; dy++) {
                    for (let dx = -rad; dx <= rad; dx++) {
                        const ii = gi + dx, jj = gj + dy;
                        if (ii >= 0 && ii < N && jj >= 0 && jj < N && mask[jj * N + ii]) {
                            const dist2 = dx * dx + dy * dy;
                            const val = 5 * amplitude * Math.exp(-dist2 / (rad * rad * 0.3));
                            u[jj * N + ii] += val;
                        }
                    }
                }
            }
        });

        let time = 0;
        let paused = false;
        const c2 = 0.25; // wave speed squared (CFL stable for dt=1, dx=1)

        // ImageData for rendering
        let imgData = null;

        function step() {
            time += 1;

            // Drive center point sinusoidally
            const cx = Math.floor(N / 2);
            const cy = Math.floor(N / 2);
            const omega = 2 * Math.PI * frequency / 60; // scale for frame rate
            const driveVal = amplitude * 3 * Math.sin(omega * time);
            u[cy * N + cx] = driveVal;

            // Finite difference wave equation with damping
            const damp = 1 - damping;
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    if (!mask[idx]) {
                        uNext[idx] = 0;
                        continue;
                    }
                    const laplacian = u[idx - 1] + u[idx + 1] + u[(j - 1) * N + i] + u[(j + 1) * N + i] - 4 * u[idx];
                    uNext[idx] = (2 * u[idx] - uPrev[idx] + c2 * laplacian) * damp;

                    // Extra damping near boundary
                    const dx = i - N / 2, dy = j - N / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const r = (N / 2) * dishRadiusPct;
                    if (dist > r * 0.85) {
                        const edgeFactor = (dist - r * 0.85) / (r * 0.15);
                        uNext[idx] *= (1 - edgeFactor * 0.1);
                    }
                }
            }

            // Boundary: reflect (Neumann)
            for (let i = 0; i < N; i++) {
                uNext[i] = 0; // top
                uNext[(N - 1) * N + i] = 0; // bottom
                uNext[i * N] = 0; // left
                uNext[i * N + N - 1] = 0; // right
            }

            // Swap buffers
            const tmp = uPrev;
            uPrev = u;
            u = uNext;
            uNext = tmp;
        }

        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            const size = Math.min(W, H) * 0.85;
            const offX = (W - size) / 2;
            const offY = (H - size) / 2;

            // Render to small canvas, then scale
            if (!imgData || imgData.width !== N) {
                imgData = ctx.createImageData(N, N);
            }
            const data = imgData.data;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;
                    const pIdx = idx * 4;

                    if (!mask[idx]) {
                        data[pIdx] = 10;
                        data[pIdx + 1] = 14;
                        data[pIdx + 2] = 26;
                        data[pIdx + 3] = 255;
                        continue;
                    }

                    const val = u[idx];
                    // Map to water colors
                    // Trough = dark blue, crest = white/light, flat = medium blue
                    const normalized = Math.max(-1, Math.min(1, val * 2));

                    let r, g, b;
                    if (normalized > 0) {
                        // Crest: medium blue -> white
                        r = Math.floor(40 + 215 * normalized);
                        g = Math.floor(80 + 175 * normalized);
                        b = Math.floor(140 + 115 * normalized);
                    } else {
                        // Trough: medium blue -> dark blue
                        const v = -normalized;
                        r = Math.floor(40 - 30 * v);
                        g = Math.floor(80 - 60 * v);
                        b = Math.floor(140 - 40 * v);
                    }

                    data[pIdx] = r;
                    data[pIdx + 1] = g;
                    data[pIdx + 2] = b;
                    data[pIdx + 3] = 255;
                }
            }

            // Put small image and scale
            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = N;
            tmpCanvas.height = N;
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.putImageData(imgData, 0, 0);

            // Draw circular dish outline
            ctx.save();
            ctx.beginPath();
            ctx.arc(W / 2, H / 2, size / 2, 0, Math.PI * 2);
            ctx.clip();
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(tmpCanvas, offX, offY, size, size);
            ctx.restore();

            // Dish rim
            ctx.strokeStyle = 'rgba(138, 154, 91, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(W / 2, H / 2, size / 2, 0, Math.PI * 2);
            ctx.stroke();

            // Glow effect for rim
            ctx.strokeStyle = 'rgba(138, 154, 91, 0.15)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(W / 2, H / 2, size / 2, 0, Math.PI * 2);
            ctx.stroke();

            // Center dot indicator
            ctx.fillStyle = 'rgba(255, 200, 100, 0.6)';
            ctx.beginPath();
            ctx.arc(W / 2, H / 2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Info
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.font = '12px sans-serif';
            ctx.fillText(`Wave equation: d²u/dt² = c²∇²u | Center driven at ${frequency} Hz`, 20, H - 20);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (paused) return;

            // Run multiple simulation steps per frame for faster wave propagation
            for (let s = 0; s < 3; s++) {
                step();
            }
            render();
        }

        animate();

        window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                e.preventDefault();
                paused = !paused;
            }
        });

        window.reset = function() {
            time = 0;
            u.fill(0);
            uPrev.fill(0);
            uNext.fill(0);
            frequency = 12;
            amplitude = 0.6;
            damping = 0.02;
            dishRadiusPct = 0.85;
            document.getElementById('freq').value = 12;
            document.getElementById('amplitude').value = 60;
            document.getElementById('damping').value = 2;
            document.getElementById('radius').value = 85;
            document.getElementById('freqVal').textContent = '12';
            document.getElementById('ampVal').textContent = '60';
            document.getElementById('dampVal').textContent = '2';
            document.getElementById('radiusVal').textContent = '85';
            computeMask();
        };
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>