<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chladni Explorer - Cymatics</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; color: #c8d0e0; }
canvas { display: block; }
.back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
    background: rgba(10,14,26,0.8); border-radius: 25px;
    border: 2px solid #8A9A5B; padding: 10px 20px;
    transition: all 0.3s ease;
}
.back-link:hover { background: #8A9A5B; color: #0a0e1a; }
.controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
    border-radius: 10px; padding: 20px; max-width: 300px;
    border: 1px solid rgba(138,154,91,0.3);
}
.controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
.control-row { margin-bottom: 10px; }
.control-row label { display: block; font-size: 12px; color: #8a92a8; margin-bottom: 3px; }
.control-row input[type="range"] { width: 100%; accent-color: #8A9A5B; }
.control-row .value { float: right; color: #DDA15E; font-size: 12px; font-weight: 600; }
.control-row button {
    background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
    padding: 6px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; margin: 2px;
    transition: all 0.2s;
}
.control-row button:hover { background: rgba(138,154,91,0.4); }
.control-row button.active { background: #8A9A5B; color: #0a0e1a; }
.tooltip {
    position: fixed; z-index: 200; pointer-events: none;
    background: rgba(10,14,26,0.9); backdrop-filter: blur(10px);
    border-radius: 8px; padding: 8px 14px;
    border: 1px solid rgba(221,161,94,0.5);
    font-size: 13px; color: #DDA15E; font-weight: 600;
    display: none;
}
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Cymatics</a>

<div class="controls">
    <h3>Chladni Explorer</h3>
    <div class="control-row">
        <label>Grid Size <span class="value" id="gridVal">8</span></label>
        <input type="range" id="gridSlider" min="4" max="10" value="8" step="1">
    </div>
    <div class="control-row">
        <label>Resolution <span class="value" id="resVal">64</span></label>
        <input type="range" id="resSlider" min="32" max="128" value="64" step="16">
    </div>
    <div class="control-row">
        <label>Color Mode</label>
        <button id="modeNodal" class="active">Nodal Lines</button>
        <button id="modeAmp">Amplitude</button>
        <button id="modePhase">Phase</button>
    </div>
    <div class="control-row" id="expandedInfo" style="display:none;">
        <label>Expanded: mode (<span id="expN">-</span>, <span id="expM">-</span>)</label>
        <button id="closeExpand">Back to Grid</button>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

let W, H;
let gridSize = 8, cellRes = 64, colorMode = 'nodal';
let gridCells = [];
let expanded = null;
let expandedParticles = [];
let hoverCell = null;
let running = true;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    buildGrid();
}
window.addEventListener('resize', resize);

function chladni(x, y, nn, mm) {
    const px = Math.PI * x;
    const py = Math.PI * y;
    return Math.sin(nn * px) * Math.sin(mm * py) + Math.sin(mm * px) * Math.sin(nn * py);
}

function computeCell(nn, mm, res) {
    const offCanvas = document.createElement('canvas');
    offCanvas.width = res;
    offCanvas.height = res;
    const octx = offCanvas.getContext('2d');
    const imgData = octx.createImageData(res, res);
    const d = imgData.data;
    const inv = 1.0 / (res - 1);
    for (let j = 0; j < res; j++) {
        for (let i = 0; i < res; i++) {
            const x = i * inv;
            const y = j * inv;
            const v = chladni(x, y, nn, mm);
            const pidx = (j * res + i) * 4;
            if (colorMode === 'nodal') {
                const absV = Math.abs(v);
                const nodal = Math.exp(-absV * 8);
                d[pidx] = Math.floor(nodal * 240);
                d[pidx + 1] = Math.floor(nodal * 240);
                d[pidx + 2] = Math.floor(nodal * 255);
                d[pidx + 3] = 255;
            } else if (colorMode === 'amplitude') {
                const absV = Math.min(Math.abs(v) / 2, 1);
                const nodal = Math.exp(-Math.abs(v) * 8);
                if (v > 0) {
                    d[pidx] = Math.floor(absV * 220 + nodal * 35);
                    d[pidx + 1] = Math.floor(absV * 60 + nodal * 60);
                    d[pidx + 2] = Math.floor(absV * 30 + nodal * 80);
                } else {
                    d[pidx] = Math.floor(absV * 30 + nodal * 60);
                    d[pidx + 1] = Math.floor(absV * 80 + nodal * 80);
                    d[pidx + 2] = Math.floor(absV * 220 + nodal * 35);
                }
                d[pidx + 3] = 255;
            } else {
                const phase = Math.atan2(Math.sin(mm * Math.PI * x) * Math.sin(nn * Math.PI * y),
                                          Math.sin(nn * Math.PI * x) * Math.sin(mm * Math.PI * y));
                const hp = (phase + Math.PI) / (2 * Math.PI);
                const nodal = Math.exp(-Math.abs(v) * 8);
                const r = Math.sin(hp * Math.PI * 2) * 0.5 + 0.5;
                const g = Math.sin(hp * Math.PI * 2 + 2.094) * 0.5 + 0.5;
                const b = Math.sin(hp * Math.PI * 2 + 4.189) * 0.5 + 0.5;
                const bright = 0.3 + (1 - nodal) * 0.7;
                d[pidx] = Math.floor(r * bright * 255);
                d[pidx + 1] = Math.floor(g * bright * 255);
                d[pidx + 2] = Math.floor(b * bright * 255);
                d[pidx + 3] = 255;
            }
        }
    }
    octx.putImageData(imgData, 0, 0);
    return offCanvas;
}

function buildGrid() {
    gridCells = [];
    const margin = 80;
    const availW = W - margin * 2;
    const availH = H - margin * 2;
    const cellSize = Math.floor(Math.min(availW, availH) / gridSize) - 4;
    const totalW = gridSize * (cellSize + 4);
    const totalH = gridSize * (cellSize + 4);
    const startX = (W - totalW) / 2;
    const startY = (H - totalH) / 2;
    for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
            const nn = col + 1;
            const mm = row + 1;
            const cx = startX + col * (cellSize + 4);
            const cy = startY + row * (cellSize + 4);
            gridCells.push({
                n: nn, m: mm,
                x: cx, y: cy, size: cellSize,
                img: computeCell(nn, mm, cellRes)
            });
        }
    }
}

function initExpandedParticles(nn, mm) {
    expandedParticles = [];
    for (let i = 0; i < 5000; i++) {
        expandedParticles.push({ x: Math.random(), y: Math.random(), vx: 0, vy: 0 });
    }
}

function updateExpandedParticles() {
    if (!expanded) return;
    const nn = expanded.n, mm = expanded.m;
    const dt = 0.003;
    const noise = 0.0005;
    const damping = 0.92;
    for (let i = 0; i < expandedParticles.length; i++) {
        const p = expandedParticles[i];
        const x = p.x, y = p.y;
        const v = chladni(x, y, nn, mm);
        const eps = 0.002;
        const gx = (chladni(x + eps, y, nn, mm) - chladni(x - eps, y, nn, mm)) / (2 * eps);
        const gy = (chladni(x, y + eps, nn, mm) - chladni(x, y - eps, nn, mm)) / (2 * eps);
        const gm = Math.sqrt(gx * gx + gy * gy) + 0.001;
        const force = Math.abs(v) * 0.5;
        p.vx += (-v * gx / gm) * force * dt + (Math.random() - 0.5) * noise;
        p.vy += (-v * gy / gm) * force * dt + (Math.random() - 0.5) * noise;
        p.vx *= damping;
        p.vy *= damping;
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0) { p.x = 0; p.vx *= -0.5; }
        if (p.x > 1) { p.x = 1; p.vx *= -0.5; }
        if (p.y < 0) { p.y = 0; p.vy *= -0.5; }
        if (p.y > 1) { p.y = 1; p.vy *= -0.5; }
    }
}

canvas.addEventListener('mousemove', (e) => {
    if (expanded) return;
    hoverCell = null;
    for (const cell of gridCells) {
        if (e.clientX >= cell.x && e.clientX <= cell.x + cell.size &&
            e.clientY >= cell.y && e.clientY <= cell.y + cell.size) {
            hoverCell = cell;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY - 10) + 'px';
            tooltip.textContent = `Mode (n=${cell.n}, m=${cell.m})`;
            return;
        }
    }
    tooltip.style.display = 'none';
});

canvas.addEventListener('click', (e) => {
    if (expanded) return;
    for (const cell of gridCells) {
        if (e.clientX >= cell.x && e.clientX <= cell.x + cell.size &&
            e.clientY >= cell.y && e.clientY <= cell.y + cell.size) {
            expanded = cell;
            initExpandedParticles(cell.n, cell.m);
            tooltip.style.display = 'none';
            document.getElementById('expandedInfo').style.display = 'block';
            document.getElementById('expN').textContent = cell.n;
            document.getElementById('expM').textContent = cell.m;
            return;
        }
    }
});

document.getElementById('closeExpand').addEventListener('click', () => {
    expanded = null;
    document.getElementById('expandedInfo').style.display = 'none';
});

function drawGrid() {
    for (const cell of gridCells) {
        ctx.save();
        if (hoverCell === cell) {
            ctx.shadowColor = '#DDA15E';
            ctx.shadowBlur = 15;
        }
        ctx.drawImage(cell.img, cell.x, cell.y, cell.size, cell.size);
        ctx.strokeStyle = hoverCell === cell ? 'rgba(221,161,94,0.8)' : 'rgba(138,154,91,0.2)';
        ctx.lineWidth = hoverCell === cell ? 2 : 1;
        ctx.strokeRect(cell.x, cell.y, cell.size, cell.size);
        ctx.restore();
    }
}

function drawExpanded() {
    const size = Math.min(W, H) * 0.75;
    const ex = (W - size) / 2;
    const ey = (H - size) / 2;
    const bigImg = computeCell(expanded.n, expanded.m, 256);
    ctx.drawImage(bigImg, ex, ey, size, size);
    for (const p of expandedParticles) {
        const px = ex + p.x * size;
        const py = ey + p.y * size;
        const v = Math.abs(chladni(p.x, p.y, expanded.n, expanded.m));
        const alpha = Math.max(0.3, 1.0 - v * 2);
        ctx.fillStyle = `rgba(221,161,94,${alpha})`;
        ctx.fillRect(px, py, 1.5, 1.5);
    }
    ctx.strokeStyle = 'rgba(138,154,91,0.4)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ex, ey, size, size);
    ctx.fillStyle = 'rgba(221,161,94,0.8)';
    ctx.font = '16px system-ui';
    ctx.fillText(`Mode (n=${expanded.n}, m=${expanded.m})`, ex, ey - 10);
}

function animate() {
    if (!running) { requestAnimationFrame(animate); return; }
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    if (expanded) {
        for (let s = 0; s < 3; s++) updateExpandedParticles();
        drawExpanded();
    } else {
        drawGrid();
    }
    requestAnimationFrame(animate);
}

document.getElementById('gridSlider').addEventListener('input', function() {
    gridSize = parseInt(this.value);
    document.getElementById('gridVal').textContent = gridSize;
    expanded = null;
    document.getElementById('expandedInfo').style.display = 'none';
    buildGrid();
});

document.getElementById('resSlider').addEventListener('input', function() {
    cellRes = parseInt(this.value);
    document.getElementById('resVal').textContent = cellRes;
    buildGrid();
});

function setColorMode(mode) {
    colorMode = mode;
    document.getElementById('modeNodal').classList.toggle('active', mode === 'nodal');
    document.getElementById('modeAmp').classList.toggle('active', mode === 'amplitude');
    document.getElementById('modePhase').classList.toggle('active', mode === 'phase');
    buildGrid();
}
document.getElementById('modeNodal').addEventListener('click', () => setColorMode('nodal'));
document.getElementById('modeAmp').addEventListener('click', () => setColorMode('amplitude'));
document.getElementById('modePhase').addEventListener('click', () => setColorMode('phase'));

window.reset = function() {
    gridSize = 8; cellRes = 64; colorMode = 'nodal'; expanded = null;
    document.getElementById('gridSlider').value = 8;
    document.getElementById('resSlider').value = 64;
    document.getElementById('gridVal').textContent = '8';
    document.getElementById('resVal').textContent = '64';
    document.getElementById('expandedInfo').style.display = 'none';
    setColorMode('nodal');
    resize();
};

window.togglePause = function() { running = !running; };

resize();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
