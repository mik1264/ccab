<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Terrain Generator - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* CCAB color scheme */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --header-height: 64px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
            font-family: var(--font-heading);
            font-style: italic;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
            font-family: var(--font-mono);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
            font-family: var(--font-mono);
        }

        input[type="range"] {
            width: 150px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-family: var(--font-mono);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin: 20px auto;
        }

        canvas {
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
            font-family: var(--font-display);
        }

        .info-box p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--theme-color);
            font-family: var(--font-mono);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <div class="nav-breadcrumb">
                <span class="separator">/</span>
                <span class="current">Procedural Terrain</span>
            </div>
        </div>
    </nav>

    <div class="container">
        <h1>Procedural Terrain Generator</h1>
        <p class="subtitle">Fractal Brownian Motion with Hydraulic Erosion</p>

        <div class="tabs">
            <div class="tab active" data-view="heightmap">2D Heightmap</div>
            <div class="tab" data-view="terrain3d">3D Terrain</div>
            <div class="tab" data-view="erosion">Erosion Simulation</div>
        </div>

        <!-- 2D Heightmap View -->
        <div class="view active" id="heightmap">
            <div class="info-box">
                <h3>Fractal Brownian Motion (fBm)</h3>
                <p>Generate realistic terrain using layered Simplex noise. Multiple octaves of noise at different frequencies
                are combined to create natural-looking landscapes with features at multiple scales - from mountain ranges to
                small hills.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="octaves2d">Octaves: <span id="octaves2dVal">6</span></label>
                    <input type="range" id="octaves2d" min="1" max="8" step="1" value="6">
                </div>
                <div class="control-group">
                    <label for="persistence2d">Persistence: <span id="persistence2dVal">0.5</span></label>
                    <input type="range" id="persistence2d" min="0.1" max="1" step="0.05" value="0.5">
                </div>
                <div class="control-group">
                    <label for="scale2d">Scale: <span id="scale2dVal">50</span></label>
                    <input type="range" id="scale2d" min="10" max="200" step="5" value="50">
                </div>
                <div class="control-group">
                    <label for="seed2d">Seed: <span id="seed2dVal">12345</span></label>
                    <input type="number" id="seed2d" min="0" max="99999" value="12345">
                </div>
                <button onclick="generate2D()">Generate</button>
                <button onclick="randomSeed2D()">Random Seed</button>
            </div>

            <div class="canvas-container">
                <canvas id="canvas2d" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="minHeight2d">0.0</div>
                        <div class="stat-label">Min Height</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxHeight2d">1.0</div>
                        <div class="stat-label">Max Height</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgHeight2d">0.5</div>
                        <div class="stat-label">Avg Height</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3D Terrain View -->
        <div class="view" id="terrain3d">
            <div class="info-box">
                <h3>Interactive 3D Terrain</h3>
                <p>View the generated terrain as a 3D mesh with biome-based coloring. Use your mouse to rotate, zoom,
                and pan around the landscape. The terrain uses vertex height modification and normal recalculation for
                realistic shading.</p>
                <ul>
                    <li><strong>Deep Water:</strong> Dark blue (#001845) - heights below 0.3</li>
                    <li><strong>Shallow Water:</strong> Blue (#0066cc) - heights 0.3-0.4</li>
                    <li><strong>Sand:</strong> Tan (#c2b280) - heights 0.4-0.45</li>
                    <li><strong>Grass:</strong> Green (#228b22) - heights 0.45-0.6</li>
                    <li><strong>Forest:</strong> Dark green (#0f5f0f) - heights 0.6-0.7</li>
                    <li><strong>Rock:</strong> Gray (#696969) - heights 0.7-0.85</li>
                    <li><strong>Snow:</strong> White (#f0f0f0) - heights above 0.85</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="octaves3d">Octaves: <span id="octaves3dVal">6</span></label>
                    <input type="range" id="octaves3d" min="1" max="8" step="1" value="6">
                </div>
                <div class="control-group">
                    <label for="persistence3d">Persistence: <span id="persistence3dVal">0.5</span></label>
                    <input type="range" id="persistence3d" min="0.1" max="1" step="0.05" value="0.5">
                </div>
                <div class="control-group">
                    <label for="scale3d">Scale: <span id="scale3dVal">50</span></label>
                    <input type="range" id="scale3d" min="10" max="200" step="5" value="50">
                </div>
                <div class="control-group">
                    <label for="heightMult">Height Mult: <span id="heightMultVal">30</span></label>
                    <input type="range" id="heightMult" min="5" max="100" step="5" value="30">
                </div>
                <div class="control-group">
                    <label for="seed3d">Seed: <span id="seed3dVal">12345</span></label>
                    <input type="number" id="seed3d" min="0" max="99999" value="12345">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="wireframe" onchange="toggleWireframe()">
                    <label for="wireframe">Wireframe</label>
                </div>
                <button onclick="generate3D()">Generate</button>
                <button onclick="randomSeed3D()">Random Seed</button>
            </div>

            <div class="canvas-container">
                <canvas id="canvas3d" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="vertices3d">0</div>
                        <div class="stat-label">Vertices</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="faces3d">0</div>
                        <div class="stat-label">Faces</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Erosion View -->
        <div class="view" id="erosion">
            <div class="info-box">
                <h3>Hydraulic Erosion Simulation</h3>
                <p>Simulate water erosion to create more realistic terrain features like valleys, riverbeds, and sediment
                deposits. Droplets fall on the terrain, pick up sediment, flow downhill, and deposit material in flatter areas.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="erosionSteps">Iterations: <span id="erosionStepsVal">1000</span></label>
                    <input type="range" id="erosionSteps" min="100" max="5000" step="100" value="1000">
                </div>
                <div class="control-group">
                    <label for="erosionRate">Erosion Rate: <span id="erosionRateVal">0.3</span></label>
                    <input type="range" id="erosionRate" min="0.1" max="1" step="0.05" value="0.3">
                </div>
                <div class="control-group">
                    <label for="depositionRate">Deposition: <span id="depositionRateVal">0.3</span></label>
                    <input type="range" id="depositionRate" min="0.1" max="1" step="0.05" value="0.3">
                </div>
                <div class="control-group">
                    <label for="evaporationRate">Evaporation: <span id="evaporationRateVal">0.01</span></label>
                    <input type="range" id="evaporationRate" min="0.01" max="0.1" step="0.01" value="0.01">
                </div>
                <button onclick="generateErosion()">Generate Base</button>
                <button onclick="applyErosion()">Apply Erosion</button>
                <button onclick="resetErosion()">Reset</button>
            </div>

            <div class="canvas-container">
                <canvas id="canvasErosion" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="erosionProgress">0%</div>
                        <div class="stat-label">Progress</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sedimentMoved">0.0</div>
                        <div class="stat-label">Sediment Moved</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Simplex Noise Implementation
        class SimplexNoise {
            constructor(seed = 0) {
                this.p = [];
                this.perm = [];
                this.gradP = [];

                const random = this.seedRandom(seed);
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(random() * 256);
                }

                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.gradP[i] = this.grad3[this.perm[i] % 12];
                }
            }

            seedRandom(seed) {
                return function() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
            }

            grad3 = [
                [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
            ];

            dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }

            noise2D(xin, yin) {
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);

                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;

                let i1, j1;
                if (x0 > y0) {
                    i1 = 1; j1 = 0;
                } else {
                    i1 = 0; j1 = 1;
                }

                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;

                const ii = i & 255;
                const jj = j & 255;

                let n0 = 0, n1 = 0, n2 = 0;

                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    const gi0 = this.gradP[ii + this.perm[jj]];
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(gi0, x0, y0);
                }

                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    const gi1 = this.gradP[ii + i1 + this.perm[jj + j1]];
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(gi1, x1, y1);
                }

                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    const gi2 = this.gradP[ii + 1 + this.perm[jj + 1]];
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(gi2, x2, y2);
                }

                return 70.0 * (n0 + n1 + n2);
            }
        }

        // Global variables
        let noise2d, noise3d, noiseErosion;
        let heightmap2d = [];
        let heightmap3d = [];
        let heightmapErosion = [];
        let erosionOriginal = [];

        // Three.js variables
        let scene3d, camera3d, renderer3d, controls3d, terrain3d;

        // Setup tabs
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        // Setup controls
        function setupControls() {
            // 2D controls
            document.getElementById('octaves2d').addEventListener('input', (e) => {
                document.getElementById('octaves2dVal').textContent = e.target.value;
            });
            document.getElementById('persistence2d').addEventListener('input', (e) => {
                document.getElementById('persistence2dVal').textContent = e.target.value;
            });
            document.getElementById('scale2d').addEventListener('input', (e) => {
                document.getElementById('scale2dVal').textContent = e.target.value;
            });
            document.getElementById('seed2d').addEventListener('input', (e) => {
                document.getElementById('seed2dVal').textContent = e.target.value;
            });

            // 3D controls
            document.getElementById('octaves3d').addEventListener('input', (e) => {
                document.getElementById('octaves3dVal').textContent = e.target.value;
            });
            document.getElementById('persistence3d').addEventListener('input', (e) => {
                document.getElementById('persistence3dVal').textContent = e.target.value;
            });
            document.getElementById('scale3d').addEventListener('input', (e) => {
                document.getElementById('scale3dVal').textContent = e.target.value;
            });
            document.getElementById('heightMult').addEventListener('input', (e) => {
                document.getElementById('heightMultVal').textContent = e.target.value;
            });
            document.getElementById('seed3d').addEventListener('input', (e) => {
                document.getElementById('seed3dVal').textContent = e.target.value;
            });

            // Erosion controls
            document.getElementById('erosionSteps').addEventListener('input', (e) => {
                document.getElementById('erosionStepsVal').textContent = e.target.value;
            });
            document.getElementById('erosionRate').addEventListener('input', (e) => {
                document.getElementById('erosionRateVal').textContent = e.target.value;
            });
            document.getElementById('depositionRate').addEventListener('input', (e) => {
                document.getElementById('depositionRateVal').textContent = e.target.value;
            });
            document.getElementById('evaporationRate').addEventListener('input', (e) => {
                document.getElementById('evaporationRateVal').textContent = e.target.value;
            });
        }

        // Fractal Brownian Motion
        function fbm(noise, x, y, octaves, persistence, scale) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise.noise2D(x * frequency / scale, y * frequency / scale);
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }

            return (value / maxValue + 1) / 2; // Normalize to 0-1
        }

        // Get biome color based on height
        function getBiomeColor(height) {
            if (height < 0.3) return '#001845'; // Deep water
            if (height < 0.4) return '#0066cc'; // Shallow water
            if (height < 0.45) return '#c2b280'; // Sand
            if (height < 0.6) return '#228b22'; // Grass
            if (height < 0.7) return '#0f5f0f'; // Forest
            if (height < 0.85) return '#696969'; // Rock
            return '#f0f0f0'; // Snow
        }

        // Generate 2D heightmap
        window.generate2D = function() {
            const canvas = document.getElementById('canvas2d');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const octaves = parseInt(document.getElementById('octaves2d').value);
            const persistence = parseFloat(document.getElementById('persistence2d').value);
            const scale = parseFloat(document.getElementById('scale2d').value);
            const seed = parseInt(document.getElementById('seed2d').value);

            noise2d = new SimplexNoise(seed);
            heightmap2d = [];

            let minH = Infinity;
            let maxH = -Infinity;
            let sumH = 0;

            for (let y = 0; y < height; y++) {
                heightmap2d[y] = [];
                for (let x = 0; x < width; x++) {
                    const h = fbm(noise2d, x, y, octaves, persistence, scale);
                    heightmap2d[y][x] = h;
                    minH = Math.min(minH, h);
                    maxH = Math.max(maxH, h);
                    sumH += h;

                    const color = getBiomeColor(h);
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            document.getElementById('minHeight2d').textContent = minH.toFixed(3);
            document.getElementById('maxHeight2d').textContent = maxH.toFixed(3);
            document.getElementById('avgHeight2d').textContent = (sumH / (width * height)).toFixed(3);
        };

        window.randomSeed2D = function() {
            const newSeed = Math.floor(Math.random() * 99999);
            document.getElementById('seed2d').value = newSeed;
            document.getElementById('seed2dVal').textContent = newSeed;
            generate2D();
        };

        // Setup 3D scene
        function setup3D() {
            const canvas = document.getElementById('canvas3d');

            scene3d = new THREE.Scene();
            scene3d.background = new THREE.Color(0x87ceeb);
            scene3d.fog = new THREE.Fog(0x87ceeb, 100, 300);

            camera3d = new THREE.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 500);
            camera3d.position.set(0, 50, 100);

            renderer3d = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer3d.setSize(canvas.width, canvas.height);
            renderer3d.shadowMap.enabled = true;

            controls3d = new OrbitControls(camera3d, renderer3d.domElement);
            controls3d.enableDamping = true;
            controls3d.dampingFactor = 0.05;
            controls3d.maxPolarAngle = Math.PI / 2 - 0.1;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene3d.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene3d.add(directionalLight);

            animate3D();
        }

        // Generate 3D terrain
        window.generate3D = function() {
            const octaves = parseInt(document.getElementById('octaves3d').value);
            const persistence = parseFloat(document.getElementById('persistence3d').value);
            const scale = parseFloat(document.getElementById('scale3d').value);
            const heightMult = parseFloat(document.getElementById('heightMult').value);
            const seed = parseInt(document.getElementById('seed3d').value);

            noise3d = new SimplexNoise(seed);

            // Remove old terrain
            if (terrain3d) {
                scene3d.remove(terrain3d);
            }

            const resolution = 100;
            const size = 100;
            const geometry = new THREE.PlaneGeometry(size, size, resolution - 1, resolution - 1);

            const vertices = geometry.attributes.position.array;
            heightmap3d = [];

            for (let i = 0; i < resolution; i++) {
                heightmap3d[i] = [];
                for (let j = 0; j < resolution; j++) {
                    const idx = (i * resolution + j) * 3;
                    const x = j;
                    const y = i;
                    const h = fbm(noise3d, x * 2, y * 2, octaves, persistence, scale);
                    heightmap3d[i][j] = h;
                    vertices[idx + 2] = h * heightMult;
                }
            }

            geometry.computeVertexNormals();

            // Apply biome colors
            const colors = new Float32Array(vertices.length);
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const idx = (i * resolution + j) * 3;
                    const h = heightmap3d[i][j];
                    const colorHex = getBiomeColor(h);
                    const color = new THREE.Color(colorHex);
                    colors[idx] = color.r;
                    colors[idx + 1] = color.g;
                    colors[idx + 2] = color.b;
                }
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                flatShading: false,
                wireframe: document.getElementById('wireframe').checked
            });

            terrain3d = new THREE.Mesh(geometry, material);
            terrain3d.rotation.x = -Math.PI / 2;
            terrain3d.receiveShadow = true;
            scene3d.add(terrain3d);

            camera3d.lookAt(0, 0, 0);

            // Update stats
            document.getElementById('vertices3d').textContent = (resolution * resolution).toLocaleString();
            document.getElementById('faces3d').textContent = ((resolution - 1) * (resolution - 1) * 2).toLocaleString();
        };

        window.randomSeed3D = function() {
            const newSeed = Math.floor(Math.random() * 99999);
            document.getElementById('seed3d').value = newSeed;
            document.getElementById('seed3dVal').textContent = newSeed;
            generate3D();
        };

        window.toggleWireframe = function() {
            if (terrain3d) {
                terrain3d.material.wireframe = document.getElementById('wireframe').checked;
            }
        };

        function animate3D() {
            requestAnimationFrame(animate3D);
            controls3d.update();
            renderer3d.render(scene3d, camera3d);
        }

        // Erosion simulation
        window.generateErosion = function() {
            const canvas = document.getElementById('canvasErosion');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const octaves = 6;
            const persistence = 0.5;
            const scale = 50;
            const seed = Math.floor(Math.random() * 99999);

            noiseErosion = new SimplexNoise(seed);
            heightmapErosion = [];
            erosionOriginal = [];

            for (let y = 0; y < height; y++) {
                heightmapErosion[y] = [];
                erosionOriginal[y] = [];
                for (let x = 0; x < width; x++) {
                    const h = fbm(noiseErosion, x, y, octaves, persistence, scale);
                    heightmapErosion[y][x] = h;
                    erosionOriginal[y][x] = h;

                    const color = getBiomeColor(h);
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            document.getElementById('erosionProgress').textContent = '0%';
            document.getElementById('sedimentMoved').textContent = '0.0';
        };

        window.applyErosion = function() {
            const canvas = document.getElementById('canvasErosion');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const iterations = parseInt(document.getElementById('erosionSteps').value);
            const erosionRate = parseFloat(document.getElementById('erosionRate').value);
            const depositionRate = parseFloat(document.getElementById('depositionRate').value);
            const evaporationRate = parseFloat(document.getElementById('evaporationRate').value);

            let totalSediment = 0;

            for (let iter = 0; iter < iterations; iter++) {
                // Random droplet position
                let x = Math.floor(Math.random() * width);
                let y = Math.floor(Math.random() * height);

                let sediment = 0;
                let water = 1.0;

                // Simulate droplet path (max 100 steps)
                for (let step = 0; step < 100 && water > 0.01; step++) {
                    const currentHeight = heightmapErosion[y]?.[x] || 0;

                    // Find steepest descent
                    let minHeight = currentHeight;
                    let nextX = x, nextY = y;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nh = heightmapErosion[ny][nx];
                                if (nh < minHeight) {
                                    minHeight = nh;
                                    nextX = nx;
                                    nextY = ny;
                                }
                            }
                        }
                    }

                    // If at local minimum, deposit sediment
                    if (nextX === x && nextY === y) {
                        heightmapErosion[y][x] += sediment * depositionRate;
                        totalSediment += sediment * depositionRate;
                        break;
                    }

                    // Erode current cell
                    const slope = currentHeight - minHeight;
                    const capacity = water * slope;

                    if (sediment < capacity) {
                        const toErode = Math.min((capacity - sediment) * erosionRate, currentHeight * 0.1);
                        heightmapErosion[y][x] -= toErode;
                        sediment += toErode;
                        totalSediment += toErode;
                    } else {
                        const toDeposit = (sediment - capacity) * depositionRate;
                        heightmapErosion[y][x] += toDeposit;
                        sediment -= toDeposit;
                    }

                    // Move to next cell
                    x = nextX;
                    y = nextY;
                    water *= (1 - evaporationRate);
                }

                // Update progress
                if (iter % 100 === 0) {
                    const progress = ((iter / iterations) * 100).toFixed(0);
                    document.getElementById('erosionProgress').textContent = progress + '%';
                }
            }

            // Redraw heightmap
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const h = Math.max(0, Math.min(1, heightmapErosion[y][x]));
                    const color = getBiomeColor(h);
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            document.getElementById('erosionProgress').textContent = '100%';
            document.getElementById('sedimentMoved').textContent = totalSediment.toFixed(1);
        };

        window.resetErosion = function() {
            const canvas = document.getElementById('canvasErosion');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    heightmapErosion[y][x] = erosionOriginal[y][x];
                    const color = getBiomeColor(erosionOriginal[y][x]);
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            document.getElementById('erosionProgress').textContent = '0%';
            document.getElementById('sedimentMoved').textContent = '0.0';
        };

        // Initialize
        window.addEventListener('load', () => {
            setupTabs();
            setupControls();
            setup3D();
            generate2D();
            generate3D();
            generateErosion();
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
