<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nuclear Fission Chain Reaction</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 22px; font-weight: 600;
    text-shadow: 0 0 20px rgba(251,191,36,0.5); z-index: 10;
    pointer-events: none; text-align: center;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.85); border: 1px solid rgba(251,191,36,0.3);
    border-radius: 12px; padding: 14px 20px; display: flex; gap: 16px;
    align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
}
.control-group { display: flex; flex-direction: column; align-items: center; gap: 4px; }
label { color: #fbbf24; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; }
input[type="range"] { width: 120px; accent-color: #fbbf24; }
.value-display { color: #fff; font-size: 13px; font-weight: bold; }
button {
    background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid #fbbf24;
    padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px;
    font-weight: bold; transition: background 0.2s;
}
button:hover { background: rgba(251,191,36,0.4); }
button.danger { color: #ff4444; border-color: #ff4444; background: rgba(255,68,68,0.15); }
button.danger:hover { background: rgba(255,68,68,0.35); }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title">Nuclear Fission Chain Reaction</div>
<canvas id="canvas"></canvas>
<div id="controls">
    <div class="control-group">
        <label>Enrichment %</label>
        <input type="range" id="enrichment" min="5" max="95" value="40">
        <span class="value-display" id="enrichVal">40%</span>
    </div>
    <div class="control-group">
        <label>Control Rods</label>
        <input type="range" id="controlRods" min="0" max="100" value="50">
        <span class="value-display" id="rodVal">50%</span>
    </div>
    <button id="fireBtn" class="danger">Fire Neutron</button>
    <button id="resetBtn">Reset</button>
    <div class="control-group">
        <label>Regime</label>
        <span class="value-display" id="regime" style="font-size:11px;">Sub-critical</span>
    </div>
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const enrichmentSlider = document.getElementById('enrichment');
const controlRodsSlider = document.getElementById('controlRods');
const regimeLabel = document.getElementById('regime');

let enrichment = 40;
let controlRodLevel = 50;
let atoms = [];
let neutrons = [];
let fragments = [];
let flashes = [];
let totalFissions = 0;
let fissionsPerSecond = 0;
let fissionTimes = [];
let energyReleased = 0;
let neutronHistory = [];

const GRID_COLS = 20, GRID_ROWS = 14;
const ATOM_RADIUS = 12;

enrichmentSlider.addEventListener('input', e => { enrichment = +e.target.value; document.getElementById('enrichVal').textContent = enrichment + '%'; resetSim(); });
controlRodsSlider.addEventListener('input', e => { controlRodLevel = +e.target.value; document.getElementById('rodVal').textContent = controlRodLevel + '%'; });
document.getElementById('fireBtn').addEventListener('click', fireNeutron);
document.getElementById('resetBtn').addEventListener('click', resetSim);

function resetSim() {
    atoms = [];
    neutrons = [];
    fragments = [];
    flashes = [];
    totalFissions = 0;
    fissionTimes = [];
    energyReleased = 0;
    neutronHistory = [];
    const startX = W * 0.1;
    const startY = H * 0.15;
    const spacingX = (W * 0.55) / GRID_COLS;
    const spacingY = (H * 0.65) / GRID_ROWS;
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const isU235 = Math.random() * 100 < enrichment;
            atoms.push({
                x: startX + c * spacingX + spacingX / 2 + (Math.random() - 0.5) * 4,
                y: startY + r * spacingY + spacingY / 2 + (Math.random() - 0.5) * 4,
                type: isU235 ? 'U235' : 'U238',
                alive: true,
                pulsePhase: Math.random() * Math.PI * 2
            });
        }
    }
}
resetSim();

function fireNeutron() {
    neutrons.push({
        x: W * 0.08,
        y: H * 0.45 + (Math.random() - 0.5) * 80,
        vx: 200 + Math.random() * 100,
        vy: (Math.random() - 0.5) * 60,
        age: 0
    });
}

function fissionAtom(atom, neutron) {
    atom.alive = false;
    totalFissions++;
    fissionTimes.push(performance.now());
    energyReleased += 200;
    flashes.push({ x: atom.x, y: atom.y, r: 0, maxR: 40 + Math.random() * 20, alpha: 1 });
    const numNewNeutrons = 2 + Math.floor(Math.random() * 2);
    for (let i = 0; i < numNewNeutrons; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 150 + Math.random() * 150;
        const absorbed = Math.random() * 100 < controlRodLevel * 0.6;
        if (!absorbed) {
            neutrons.push({
                x: atom.x,
                y: atom.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                age: 0
            });
        }
    }
    for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 50 + Math.random() * 100;
        fragments.push({
            x: atom.x,
            y: atom.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            color: Math.random() > 0.5 ? '#ff6' : '#f84'
        });
    }
}

function drawAtom(a) {
    if (!a.alive) return;
    a.pulsePhase += 0.03;
    const pulse = 1 + Math.sin(a.pulsePhase) * 0.05;
    const r = ATOM_RADIUS * pulse;
    if (a.type === 'U235') {
        const g = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, r);
        g.addColorStop(0, '#4fa');
        g.addColorStop(0.6, '#2a8');
        g.addColorStop(1, '#184');
        ctx.fillStyle = g;
    } else {
        const g = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, r);
        g.addColorStop(0, '#88a');
        g.addColorStop(0.6, '#557');
        g.addColorStop(1, '#334');
        ctx.fillStyle = g;
    }
    ctx.beginPath();
    ctx.arc(a.x, a.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = a.type === 'U235' ? 'rgba(100,255,180,0.3)' : 'rgba(120,120,180,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
}

function drawNeutron(n) {
    ctx.beginPath();
    ctx.arc(n.x, n.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(n.x, n.y, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,200,0.15)';
    ctx.fill();
}

function drawControlRods() {
    const rodCount = 5;
    const startX = W * 0.1;
    const endX = W * 0.1 + (W * 0.55);
    const topY = H * 0.08;
    const bottomY = H * 0.15 + (H * 0.65);
    const insertionDepth = controlRodLevel / 100;
    const rodHeight = (bottomY - topY) * insertionDepth;
    for (let i = 0; i < rodCount; i++) {
        const rx = startX + (i + 0.5) * (endX - startX) / rodCount;
        ctx.fillStyle = 'rgba(80,80,80,0.6)';
        ctx.fillRect(rx - 4, topY, 8, rodHeight);
        ctx.strokeStyle = 'rgba(180,180,180,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(rx - 4, topY, 8, rodHeight);
        ctx.fillStyle = '#888';
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        if (i === 2) ctx.fillText('Control Rod', rx, topY - 4);
    }
}

function drawStats(x, y) {
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.strokeStyle = 'rgba(251,191,36,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, 200, 180, 10);
    ctx.fill();
    ctx.stroke();
    const now = performance.now();
    fissionTimes = fissionTimes.filter(t => now - t < 1000);
    fissionsPerSecond = fissionTimes.length;
    const aliveU235 = atoms.filter(a => a.alive && a.type === 'U235').length;
    const aliveU238 = atoms.filter(a => a.alive && a.type === 'U238').length;
    const keff = neutrons.length > 0 ? (1 - controlRodLevel * 0.006) * (enrichment / 50) : 0;
    let regime = 'Sub-critical';
    let rColor = '#4af';
    if (keff > 1.05) { regime = 'Super-critical'; rColor = '#f44'; }
    else if (keff > 0.95) { regime = 'Critical'; rColor = '#fbbf24'; }
    regimeLabel.textContent = regime;
    regimeLabel.style.color = rColor;

    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Reactor Statistics', x + 12, y + 22);
    const lines = [
        ['U-235 Atoms', aliveU235, '#4fa'],
        ['U-238 Atoms', aliveU238, '#88a'],
        ['Active Neutrons', neutrons.length, '#fff'],
        ['Total Fissions', totalFissions, '#fbbf24'],
        ['Fissions/sec', fissionsPerSecond, '#f84'],
        ['Energy (MeV)', energyReleased.toFixed(0), '#ff6'],
        ['k-effective', keff.toFixed(3), rColor],
        ['Regime', regime, rColor]
    ];
    lines.forEach((l, i) => {
        ctx.fillStyle = '#888';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(l[0], x + 12, y + 44 + i * 17);
        ctx.fillStyle = l[2];
        ctx.textAlign = 'right';
        ctx.fillText('' + l[1], x + 188, y + 44 + i * 17);
    });
}

function drawNeutronGraph(x, y, w, h) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeStyle = 'rgba(251,191,36,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, 8);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Neutron Population', x + w / 2, y + 14);
    if (neutronHistory.length < 2) return;
    const gx = x + 6, gy = y + 22, gw = w - 12, gh = h - 30;
    const maxN = Math.max(10, ...neutronHistory.map(n => n.v));
    ctx.beginPath();
    ctx.strokeStyle = '#4af';
    ctx.lineWidth = 1.5;
    const startIdx = Math.max(0, neutronHistory.length - gw);
    for (let i = startIdx; i < neutronHistory.length; i++) {
        const px = gx + gw - (neutronHistory.length - 1 - i);
        const py = gy + gh - (neutronHistory[i].v / maxN) * gh;
        if (i === startIdx) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();
}

function drawLegend(x, y) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.beginPath();
    ctx.roundRect(x, y, 140, 70, 8);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 20, y + 18, 8, 0, Math.PI * 2);
    ctx.fillStyle = '#4fa';
    ctx.fill();
    ctx.fillStyle = '#ccc';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Uranium-235 (fissile)', x + 34, y + 22);
    ctx.beginPath();
    ctx.arc(x + 20, y + 40, 8, 0, Math.PI * 2);
    ctx.fillStyle = '#88a';
    ctx.fill();
    ctx.fillStyle = '#ccc';
    ctx.fillText('Uranium-238', x + 34, y + 44);
    ctx.beginPath();
    ctx.arc(x + 20, y + 58, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.fillStyle = '#ccc';
    ctx.fillText('Neutron', x + 34, y + 62);
}

let lastTime = performance.now();
let historyTimer = 0;
function animate(now) {
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    historyTimer += dt;
    if (historyTimer > 0.1) {
        historyTimer = 0;
        neutronHistory.push({ v: neutrons.length });
        if (neutronHistory.length > 400) neutronHistory.shift();
    }

    neutrons.forEach(n => {
        n.x += n.vx * dt;
        n.y += n.vy * dt;
        n.age += dt;
    });
    neutrons = neutrons.filter(n => n.x > -50 && n.x < W + 50 && n.y > -50 && n.y < H + 50 && n.age < 8);

    neutrons.forEach(n => {
        for (let a of atoms) {
            if (!a.alive) continue;
            const dx = n.x - a.x, dy = n.y - a.y;
            if (dx * dx + dy * dy < (ATOM_RADIUS + 3) * (ATOM_RADIUS + 3)) {
                if (a.type === 'U235') {
                    fissionAtom(a, n);
                    n.age = 999;
                    break;
                } else {
                    if (Math.random() < 0.1) {
                        n.age = 999;
                        break;
                    }
                }
            }
        }
    });
    neutrons = neutrons.filter(n => n.age < 8);

    fragments.forEach(f => {
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        f.life -= dt * 1.5;
    });
    fragments = fragments.filter(f => f.life > 0);

    flashes.forEach(f => {
        f.r += (f.maxR - f.r) * dt * 8;
        f.alpha -= dt * 3;
    });
    flashes = flashes.filter(f => f.alpha > 0);

    ctx.clearRect(0, 0, W, H);
    const bg = ctx.createRadialGradient(W * 0.35, H * 0.45, 0, W * 0.35, H * 0.45, W * 0.5);
    bg.addColorStop(0, '#0f1428');
    bg.addColorStop(1, '#0a0e1a');
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    drawControlRods();
    atoms.forEach(drawAtom);

    flashes.forEach(f => {
        const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.r);
        g.addColorStop(0, `rgba(255,255,200,${f.alpha * 0.5})`);
        g.addColorStop(0.5, `rgba(255,200,50,${f.alpha * 0.3})`);
        g.addColorStop(1, `rgba(255,100,20,0)`);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
        ctx.fill();
    });

    fragments.forEach(f => {
        ctx.beginPath();
        ctx.arc(f.x, f.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = f.color + Math.floor(f.life * 255).toString(16).padStart(2, '0');
        ctx.fill();
    });

    neutrons.forEach(drawNeutron);

    const panelX = W * 0.72;
    drawStats(panelX, 80);
    const graphW = Math.min(220, W * 0.22);
    drawNeutronGraph(panelX, 275, 200, 100);
    drawLegend(panelX, 390);

    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
