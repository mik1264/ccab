<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imprinting - NetLogo Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #ff9800;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .simulation-area {
            background: #1e1e2e;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            background: #0a0a15;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .controls {
            background: #1e1e2e;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #ff9800;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #ff9800;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            text-align: right;
            color: #ff9800;
            font-weight: bold;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        #startBtn {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
        }

        #resetBtn {
            background: linear-gradient(135deg, #444, #555);
            color: white;
        }

        #hatchBtn {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            color: white;
            grid-column: span 2;
        }

        .stats {
            background: #252535;
            border-radius: 10px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #ff9800;
            font-weight: bold;
        }

        .theory-box {
            background: linear-gradient(135deg, #252535, #2a2a3a);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #ff9800;
        }

        .theory-box h4 {
            color: #ff9800;
            margin-bottom: 10px;
        }

        .theory-box p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .phase-indicator {
            padding: 10px;
            background: #252535;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .phase-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .phase-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff9800, #ffcc80);
            transition: width 0.3s;
        }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 40px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #fbbf24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üê• Imprinting</h1>
        <p class="subtitle">Critical Period Learning and Filial Attachment</p>

        <div class="main-content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="simCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>‚è∞ Critical Period</h3>
                    <div class="phase-indicator">
                        <span id="phaseLabel">Pre-Hatching</span>
                        <div class="phase-bar">
                            <div class="phase-fill" id="phaseFill" style="width: 0%"></div>
                        </div>
                    </div>
                    <button id="hatchBtn">Hatch Goslings ü•ö</button>
                </div>

                <div class="control-section">
                    <h3>‚öôÔ∏è Parameters</h3>
                    <div class="control-group">
                        <label>Brood Size</label>
                        <input type="range" id="broodSize" min="3" max="10" step="1" value="6">
                        <div class="value"><span id="broodSizeVal">6</span></div>
                    </div>
                    <div class="control-group">
                        <label>Critical Period Duration</label>
                        <input type="range" id="criticalPeriod" min="100" max="500" step="50" value="200">
                        <div class="value"><span id="criticalPeriodVal">200</span> frames</div>
                    </div>
                    <div class="control-group">
                        <label>Learning Rate</label>
                        <input type="range" id="learningRate" min="0.01" max="0.1" step="0.01" value="0.05">
                        <div class="value"><span id="learningRateVal">0.05</span></div>
                    </div>
                    <div class="control-group">
                        <label>Following Strength</label>
                        <input type="range" id="followStrength" min="0.2" max="1" step="0.1" value="0.5">
                        <div class="value"><span id="followStrengthVal">0.5</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üéÆ Controls</h3>
                    <div class="button-group">
                        <button id="startBtn">Start</button>
                        <button id="resetBtn">Reset</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìä Statistics</h3>
                    <div class="stats">
                        <div class="stat-row">
                            <span class="stat-label">Generation:</span>
                            <span class="stat-value" id="generation">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Time Since Hatch:</span>
                            <span class="stat-value" id="timeSinceHatch">--</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Imprinted:</span>
                            <span class="stat-value" id="imprinted">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Avg Bond Strength:</span>
                            <span class="stat-value" id="avgBond">0.00</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Following Distance:</span>
                            <span class="stat-value" id="followDist">--</span>
                        </div>
                    </div>
                </div>

                <div class="theory-box">
                    <h4>üìö Lorenz's Imprinting</h4>
                    <p>
                        Imprinting is rapid learning during a critical period
                        shortly after hatching. Young birds form lasting
                        attachments to the first moving object they encounter.
                        This filial imprinting ensures offspring follow their
                        mother, crucial for survival and learning.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let running = false;
        let generation = 0;

        // Imprinting state
        let hatched = false;
        let hatchTime = 0;
        let criticalPeriodActive = true;

        // Agents
        let mother = null;
        let goslings = [];
        let decoy = null; // Alternative imprinting target

        // Parameters
        function getParams() {
            return {
                broodSize: parseInt(document.getElementById('broodSize').value),
                criticalPeriod: parseInt(document.getElementById('criticalPeriod').value),
                learningRate: parseFloat(document.getElementById('learningRate').value),
                followStrength: parseFloat(document.getElementById('followStrength').value)
            };
        }

        // Update parameter displays
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', (e) => {
                const valSpan = document.getElementById(e.target.id + 'Val');
                if (valSpan) {
                    valSpan.textContent = e.target.value;
                }
            });
        });

        function initAgents() {
            // Mother goose
            mother = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: 0,
                vy: 0,
                targetX: canvas.width / 2,
                targetY: canvas.height / 2,
                size: 25
            };

            // Decoy (alternative target)
            decoy = {
                x: canvas.width * 0.8,
                y: canvas.height * 0.3,
                vx: 0,
                vy: 0,
                size: 20,
                type: 'box' // Non-biological object
            };

            goslings = [];
            hatched = false;
            hatchTime = 0;
            criticalPeriodActive = true;
        }

        // Hatch goslings
        document.getElementById('hatchBtn').addEventListener('click', () => {
            if (!hatched) {
                const params = getParams();
                hatched = true;
                hatchTime = generation;

                // Create goslings near random position (may or may not be near mother)
                const startX = canvas.width * 0.3 + Math.random() * canvas.width * 0.4;
                const startY = canvas.height * 0.3 + Math.random() * canvas.height * 0.4;

                for (let i = 0; i < params.broodSize; i++) {
                    const angle = (i / params.broodSize) * Math.PI * 2;
                    goslings.push({
                        id: i,
                        x: startX + Math.cos(angle) * 30,
                        y: startY + Math.sin(angle) * 30,
                        vx: 0,
                        vy: 0,
                        imprintedOn: null, // null, 'mother', or 'decoy'
                        bondStrength: 0,
                        exposure: { mother: 0, decoy: 0 },
                        age: 0
                    });
                }
            }
        });

        function update() {
            if (!running) return;

            generation++;
            const params = getParams();

            // Update mother movement (controlled by mouse or autonomous)
            const dx = mother.targetX - mother.x;
            const dy = mother.targetY - mother.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5) {
                mother.vx += (dx / dist) * 0.2;
                mother.vy += (dy / dist) * 0.2;
            } else {
                // Random new target
                if (Math.random() < 0.01) {
                    mother.targetX = 100 + Math.random() * (canvas.width - 200);
                    mother.targetY = 100 + Math.random() * (canvas.height - 200);
                }
            }

            // Speed limit
            const speed = Math.sqrt(mother.vx * mother.vx + mother.vy * mother.vy);
            if (speed > 3) {
                mother.vx = (mother.vx / speed) * 3;
                mother.vy = (mother.vy / speed) * 3;
            }

            mother.x += mother.vx;
            mother.y += mother.vy;
            mother.vx *= 0.95;
            mother.vy *= 0.95;

            // Move decoy in a pattern
            decoy.x = canvas.width * 0.75 + Math.sin(generation * 0.02) * 50;
            decoy.y = canvas.height * 0.25 + Math.cos(generation * 0.015) * 30;

            // Check critical period
            if (hatched) {
                const timeSinceHatch = generation - hatchTime;
                if (timeSinceHatch > params.criticalPeriod) {
                    criticalPeriodActive = false;
                }
            }

            // Update goslings
            for (let gosling of goslings) {
                if (!hatched) continue;

                gosling.age++;

                // Calculate distances to potential imprinting targets
                const dxMother = mother.x - gosling.x;
                const dyMother = mother.y - gosling.y;
                const distMother = Math.sqrt(dxMother * dxMother + dyMother * dyMother);

                const dxDecoy = decoy.x - gosling.x;
                const dyDecoy = decoy.y - gosling.y;
                const distDecoy = Math.sqrt(dxDecoy * dxDecoy + dyDecoy * dyDecoy);

                // During critical period, accumulate exposure
                if (criticalPeriodActive) {
                    if (distMother < 150) {
                        gosling.exposure.mother += (1 - distMother / 150) * params.learningRate;
                    }
                    if (distDecoy < 150) {
                        gosling.exposure.decoy += (1 - distDecoy / 150) * params.learningRate * 0.7;
                    }

                    // Imprinting decision
                    if (!gosling.imprintedOn) {
                        if (gosling.exposure.mother > 1) {
                            gosling.imprintedOn = 'mother';
                            gosling.bondStrength = gosling.exposure.mother;
                        } else if (gosling.exposure.decoy > 1.2) {
                            gosling.imprintedOn = 'decoy';
                            gosling.bondStrength = gosling.exposure.decoy;
                        }
                    }
                }

                // Following behavior based on imprinting
                if (gosling.imprintedOn) {
                    let targetX, targetY, targetDist;

                    if (gosling.imprintedOn === 'mother') {
                        targetX = mother.x;
                        targetY = mother.y;
                        targetDist = distMother;
                    } else {
                        targetX = decoy.x;
                        targetY = decoy.y;
                        targetDist = distDecoy;
                    }

                    // Follow at a comfortable distance
                    const idealDist = 40 + gosling.id * 5;
                    if (targetDist > idealDist) {
                        const dxT = targetX - gosling.x;
                        const dyT = targetY - gosling.y;
                        gosling.vx += (dxT / targetDist) * params.followStrength * 0.3;
                        gosling.vy += (dyT / targetDist) * params.followStrength * 0.3;
                    }

                    // Strengthen bond over time with proximity
                    if (targetDist < 100) {
                        gosling.bondStrength = Math.min(3, gosling.bondStrength + 0.001);
                    }
                } else {
                    // Not imprinted - random movement with slight attraction to movement
                    gosling.vx += (Math.random() - 0.5) * 0.3;
                    gosling.vy += (Math.random() - 0.5) * 0.3;
                }

                // Flock cohesion with siblings
                for (let other of goslings) {
                    if (other === gosling) continue;

                    const dxS = other.x - gosling.x;
                    const dyS = other.y - gosling.y;
                    const distS = Math.sqrt(dxS * dxS + dyS * dyS);

                    if (distS < 20) {
                        // Too close - separate
                        gosling.vx -= (dxS / distS) * 0.1;
                        gosling.vy -= (dyS / distS) * 0.1;
                    } else if (distS < 60 && distS > 30) {
                        // Cohesion
                        gosling.vx += (dxS / distS) * 0.05;
                        gosling.vy += (dyS / distS) * 0.05;
                    }
                }

                // Speed limit
                const gSpeed = Math.sqrt(gosling.vx * gosling.vx + gosling.vy * gosling.vy);
                if (gSpeed > 2.5) {
                    gosling.vx = (gosling.vx / gSpeed) * 2.5;
                    gosling.vy = (gosling.vy / gSpeed) * 2.5;
                }

                gosling.x += gosling.vx;
                gosling.y += gosling.vy;
                gosling.vx *= 0.95;
                gosling.vy *= 0.95;

                // Bounds
                gosling.x = Math.max(20, Math.min(canvas.width - 20, gosling.x));
                gosling.y = Math.max(20, Math.min(canvas.height - 20, gosling.y));
            }

            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const params = getParams();

            // Background - pond/grass
            ctx.fillStyle = '#1a3a2a';
            ctx.fillRect(0, 0, w, h);

            // Water area
            ctx.fillStyle = '#1a4a5a';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.6, w * 0.35, h * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Critical period visualization
            if (hatched && criticalPeriodActive) {
                const timeSinceHatch = generation - hatchTime;
                const remaining = Math.max(0, params.criticalPeriod - timeSinceHatch);
                const intensity = remaining / params.criticalPeriod;

                ctx.strokeStyle = `rgba(255, 152, 0, ${intensity * 0.5})`;
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(20, 20, w - 40, h - 40);
                ctx.setLineDash([]);

                ctx.fillStyle = `rgba(255, 152, 0, ${intensity})`;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üîî CRITICAL PERIOD ACTIVE', w / 2, 40);
            }

            // Draw decoy
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.roundRect(decoy.x - 15, decoy.y - 10, 30, 20, 5);
            ctx.fill();
            ctx.fillStyle = '#a0522d';
            ctx.beginPath();
            ctx.arc(decoy.x, decoy.y - 15, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Decoy', decoy.x, decoy.y + 25);

            // Draw mother goose
            ctx.save();
            ctx.translate(mother.x, mother.y);

            // Body
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Neck and head
            ctx.fillStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(-5, -10);
            ctx.quadraticCurveTo(-15, -35, -8, -45);
            ctx.quadraticCurveTo(0, -50, 8, -45);
            ctx.quadraticCurveTo(15, -35, 5, -10);
            ctx.closePath();
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(0, -42, 10, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.moveTo(8, -42);
            ctx.lineTo(20, -40);
            ctx.lineTo(8, -38);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(4, -44, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            ctx.fillStyle = '#ff9800';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Mother', mother.x, mother.y + 35);

            // Draw goslings
            for (let gosling of goslings) {
                const x = gosling.x;
                const y = gosling.y;

                // Color based on imprinting status
                let bodyColor, label;
                if (gosling.imprintedOn === 'mother') {
                    bodyColor = '#ffeb3b';
                    label = '‚ô•';
                } else if (gosling.imprintedOn === 'decoy') {
                    bodyColor = '#ff5722';
                    label = '‚ö†';
                } else {
                    bodyColor = '#ffd54f';
                    label = '?';
                }

                // Imprinting bond line
                if (gosling.imprintedOn) {
                    const target = gosling.imprintedOn === 'mother' ? mother : decoy;
                    ctx.strokeStyle = `rgba(255, 152, 0, ${Math.min(1, gosling.bondStrength * 0.3)})`;
                    ctx.lineWidth = gosling.bondStrength;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Body
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(x, y, 10, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.arc(x + 5, y - 5, 6, 0, Math.PI * 2);
                ctx.fill();

                // Beak
                ctx.fillStyle = '#f57c00';
                ctx.beginPath();
                ctx.moveTo(x + 10, y - 5);
                ctx.lineTo(x + 16, y - 4);
                ctx.lineTo(x + 10, y - 3);
                ctx.closePath();
                ctx.fill();

                // Status indicator
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y - 15);

                // Bond strength bar
                if (gosling.imprintedOn) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x - 10, y + 12, 20, 3);
                    ctx.fillStyle = '#ff9800';
                    ctx.fillRect(x - 10, y + 12, Math.min(20, gosling.bondStrength * 7), 3);
                }
            }

            // Info panel
            ctx.fillStyle = 'rgba(30, 30, 50, 0.9)';
            ctx.beginPath();
            ctx.roundRect(10, h - 80, 200, 70, 10);
            ctx.fill();

            ctx.fillStyle = '#ff9800';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Imprinting Simulation', 20, h - 62);

            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            const imprinted = goslings.filter(g => g.imprintedOn).length;
            const onMother = goslings.filter(g => g.imprintedOn === 'mother').length;
            ctx.fillText(`Status: ${hatched ? (criticalPeriodActive ? 'Critical Period' : 'Period Closed') : 'Pre-hatch'}`, 20, h - 45);
            ctx.fillText(`Imprinted: ${imprinted}/${goslings.length}`, 20, h - 28);
            ctx.fillText(`On Mother: ${onMother}, On Decoy: ${imprinted - onMother}`, 20, h - 12);
        }

        function updateStats() {
            const params = getParams();

            document.getElementById('generation').textContent = generation;

            if (hatched) {
                const timeSinceHatch = generation - hatchTime;
                document.getElementById('timeSinceHatch').textContent = timeSinceHatch;

                const remaining = Math.max(0, params.criticalPeriod - timeSinceHatch);
                const percent = (1 - remaining / params.criticalPeriod) * 100;
                document.getElementById('phaseFill').style.width = `${percent}%`;
                document.getElementById('phaseLabel').textContent =
                    remaining > 0 ? `Critical Period (${remaining} left)` : 'Period Closed';

                const imprinted = goslings.filter(g => g.imprintedOn).length;
                document.getElementById('imprinted').textContent = `${imprinted}/${goslings.length}`;

                const avgBond = goslings.length > 0 ?
                    goslings.reduce((sum, g) => sum + g.bondStrength, 0) / goslings.length : 0;
                document.getElementById('avgBond').textContent = avgBond.toFixed(2);

                // Average following distance
                if (imprinted > 0) {
                    let totalDist = 0;
                    for (let g of goslings.filter(g => g.imprintedOn)) {
                        const target = g.imprintedOn === 'mother' ? mother : decoy;
                        const dx = target.x - g.x;
                        const dy = target.y - g.y;
                        totalDist += Math.sqrt(dx * dx + dy * dy);
                    }
                    document.getElementById('followDist').textContent =
                        Math.round(totalDist / imprinted) + ' px';
                }
            } else {
                document.getElementById('timeSinceHatch').textContent = '--';
                document.getElementById('phaseLabel').textContent = 'Pre-Hatching';
                document.getElementById('phaseFill').style.width = '0%';
            }
        }

        // Mouse control for mother
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            mother.targetX = (e.clientX - rect.left) * (canvas.width / rect.width);
            mother.targetY = (e.clientY - rect.top) * (canvas.height / rect.height);
        });

        function reset() {
            running = false;
            generation = 0;
            initAgents();
            updateStats();
            draw();
            document.getElementById('startBtn').textContent = 'Start';
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        initAgents();
        draw();
    

    // Modal functionality
    const modal = document.getElementById('explainModal');
    if (modal) {
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                modal.classList.remove('active');
            }
        });
    }

    </script>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Imprinting</h2>
            <div class="modal-body">
                <p>This agent-based simulation explores concepts from <strong>neural systems and behavioral patterns</strong>.</p>

                <h3>What This Simulation Models</h3>
                <p>Implement filial imprinting with sensitive periods and preference formation.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Agent-Based Modeling:</strong> Individual agents follow simple rules, producing complex emergent behaviors</li>
                    <li><strong>Emergent Properties:</strong> System-level patterns arise from local interactions</li>
                    <li><strong>Parameter Exploration:</strong> Adjust controls to explore different scenarios and outcomes</li>
                </ul>

                <h3>How to Explore</h3>
                <ul>
                    <li>Use the sliders to modify simulation parameters</li>
                    <li>Observe how changes affect the overall system behavior</li>
                    <li>Look for phase transitions and tipping points</li>
                    <li>Consider what real-world phenomena this model might represent</li>
                </ul>

                <h3>Category: Neuroscience & Behavior</h3>
                <p>This simulation is part of the <em>Neuroscience & Behavior</em> collection, which explores various aspects of neural systems and behavioral patterns.</p>
            </div>
        </div>
    </div>

</body>
</html>
