<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holobiont Evolution - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #ec4899; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #ec4899; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #ec4899; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #db2777; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #ec4899; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #ec4899; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(236,72,153,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #ec4899; }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">‚Üê Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>üß¨ Holobiont Evolution</h1>
            <p class="description">
                Host + microbiome = holobiont. The "hologenome" (host + microbial genes)
                as unit of selection. Track vertical transmission, microbiome heritability,
                and hologenome-level adaptation.
            </p>

            <div class="control-group">
                <label>Vertical Transmission: <span class="value-display" id="vertValue">0.7</span></label>
                <input type="range" id="vertSlider" min="0" max="1" step="0.1" value="0.7">
                <div style="font-size: 0.65rem; color: #666;">Parent ‚Üí offspring microbiome</div>
            </div>

            <div class="control-group">
                <label>Microbiome Diversity: <span class="value-display" id="divValue">5</span></label>
                <input type="range" id="divSlider" min="2" max="10" value="5">
                <div style="font-size: 0.65rem; color: #666;">Number of microbial species</div>
            </div>

            <div class="control-group">
                <label>Host-Microbe Coupling: <span class="value-display" id="coupValue">0.5</span></label>
                <input type="range" id="coupSlider" min="0" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Environmental Pressure: <span class="value-display" id="envValue">0.3</span></label>
                <input type="range" id="envSlider" min="0" max="1" step="0.1" value="0.3">
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Holobionts: <span id="holobionts">0</span></div>
                <div>Microbiome Heritability: <span id="heritability">0</span></div>
                <div>Avg Microbiome Richness: <span id="richness">0</span></div>
                <div>Hologenome Fitness: <span id="holoFit">0</span></div>
                <div>Host-Microbe Correlation: <span id="correlation">0</span></div>
            </div>

            <div class="theory">
                <strong>Hologenome Theory:</strong> The holobiont (host + microbiome) is
                a unit of selection. Vertical transmission ensures microbiome heritability,
                enabling hologenome-level adaptation. Microbiome can provide rapid adaptation
                to new environments.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;
        let holobionts = [];
        let fitnessHistory = [];
        let heritabilityHistory = [];

        let verticalTransmission = 0.7;
        let microbiomeDiversity = 5;
        let hostMicrobeCoupling = 0.5;
        let environmentalPressure = 0.3;

        // Microbial species with different functions
        const MICROBE_FUNCTIONS = ['digestion', 'immunity', 'metabolism', 'development', 'behavior'];

        class Microbe {
            constructor(species) {
                this.species = species;
                this.function = MICROBE_FUNCTIONS[species % MICROBE_FUNCTIONS.length];
                this.abundance = Math.random();
                this.benefitToHost = Math.random(); // How much this microbe helps
            }

            clone() {
                const m = new Microbe(this.species);
                m.abundance = this.abundance + (Math.random() - 0.5) * 0.2;
                m.abundance = Math.max(0.1, Math.min(1, m.abundance));
                m.benefitToHost = this.benefitToHost + (Math.random() - 0.5) * 0.1;
                m.benefitToHost = Math.max(0, Math.min(1, m.benefitToHost));
                return m;
            }
        }

        class Holobiont {
            constructor() {
                this.x = Math.random();
                this.y = Math.random();

                // Host genome
                this.hostGenome = {
                    digestiveEfficiency: Math.random(),
                    immuneTolerance: Math.random(),
                    metabolicRate: Math.random()
                };

                // Microbiome
                this.microbiome = [];
                for (let i = 0; i < microbiomeDiversity; i++) {
                    if (Math.random() < 0.7) {
                        this.microbiome.push(new Microbe(i));
                    }
                }

                this.fitness = 0;
            }

            get richness() {
                return this.microbiome.length;
            }

            getMicrobiomeProfile() {
                // Create abundance profile for comparison
                const profile = new Array(microbiomeDiversity).fill(0);
                for (const m of this.microbiome) {
                    profile[m.species] = m.abundance;
                }
                return profile;
            }

            calculateFitness() {
                let fit = 1;

                // Host contributions
                fit += this.hostGenome.digestiveEfficiency * 0.3;
                fit += this.hostGenome.metabolicRate * 0.2;

                // Microbiome contributions
                for (const microbe of this.microbiome) {
                    const benefit = microbe.benefitToHost * microbe.abundance * hostMicrobeCoupling;

                    switch (microbe.function) {
                        case 'digestion':
                            fit += benefit * 0.3;
                            break;
                        case 'immunity':
                            fit += benefit * 0.2 * (1 + environmentalPressure);
                            break;
                        case 'metabolism':
                            fit += benefit * 0.2;
                            break;
                        case 'development':
                            fit += benefit * 0.15;
                            break;
                        case 'behavior':
                            fit += benefit * 0.15;
                            break;
                    }
                }

                // Diversity bonus (functional redundancy)
                fit += Math.log(1 + this.richness) * 0.1;

                // Environmental challenge
                fit -= environmentalPressure * 0.3;

                // Host immune tolerance matters for microbiome benefits
                fit *= 0.7 + this.hostGenome.immuneTolerance * 0.3;

                this.fitness = Math.max(0.1, fit);
                return this.fitness;
            }

            reproduce() {
                const offspring = new Holobiont();
                offspring.x = this.x + (Math.random() - 0.5) * 0.15;
                offspring.y = this.y + (Math.random() - 0.5) * 0.15;

                // Inherit host genome with mutation
                offspring.hostGenome = {
                    digestiveEfficiency: Math.max(0, Math.min(1,
                        this.hostGenome.digestiveEfficiency + (Math.random() - 0.5) * 0.1)),
                    immuneTolerance: Math.max(0, Math.min(1,
                        this.hostGenome.immuneTolerance + (Math.random() - 0.5) * 0.1)),
                    metabolicRate: Math.max(0, Math.min(1,
                        this.hostGenome.metabolicRate + (Math.random() - 0.5) * 0.1))
                };

                // Vertical transmission of microbiome
                offspring.microbiome = [];
                for (const microbe of this.microbiome) {
                    if (Math.random() < verticalTransmission) {
                        offspring.microbiome.push(microbe.clone());
                    }
                }

                // Horizontal acquisition from environment
                for (let i = 0; i < microbiomeDiversity; i++) {
                    const hasSpecies = offspring.microbiome.some(m => m.species === i);
                    if (!hasSpecies && Math.random() < (1 - verticalTransmission) * 0.3) {
                        offspring.microbiome.push(new Microbe(i));
                    }
                }

                return offspring;
            }
        }

        function initPopulation() {
            holobionts = [];
            fitnessHistory = [];
            heritabilityHistory = [];

            for (let i = 0; i < 50; i++) {
                holobionts.push(new Holobiont());
            }
        }

        function calculateMicrobiomeHeritability() {
            // Compare parent-offspring microbiome similarity
            // Approximate by comparing individuals with similar fitness (proxy for relatedness)
            if (holobionts.length < 10) return 0;

            let totalSimilarity = 0;
            let comparisons = 0;

            for (let i = 0; i < holobionts.length; i++) {
                for (let j = i + 1; j < holobionts.length; j++) {
                    const profile1 = holobionts[i].getMicrobiomeProfile();
                    const profile2 = holobionts[j].getMicrobiomeProfile();

                    // Cosine similarity
                    let dot = 0, norm1 = 0, norm2 = 0;
                    for (let k = 0; k < microbiomeDiversity; k++) {
                        dot += profile1[k] * profile2[k];
                        norm1 += profile1[k] ** 2;
                        norm2 += profile2[k] ** 2;
                    }

                    if (norm1 > 0 && norm2 > 0) {
                        totalSimilarity += dot / (Math.sqrt(norm1) * Math.sqrt(norm2));
                        comparisons++;
                    }
                }
            }

            return comparisons > 0 ? totalSimilarity / comparisons : 0;
        }

        function update() {
            if (!running) return;

            generation++;

            // Calculate fitness
            holobionts.forEach(h => h.calculateFitness());

            // Selection
            const totalFit = holobionts.reduce((s, h) => s + h.fitness, 0);

            const select = () => {
                let r = Math.random() * totalFit;
                for (const h of holobionts) {
                    r -= h.fitness;
                    if (r <= 0) return h;
                }
                return holobionts[holobionts.length - 1];
            };

            const newHolobionts = [];
            for (let i = 0; i < 50; i++) {
                newHolobionts.push(select().reproduce());
            }
            holobionts = newHolobionts;

            // Statistics
            const avgFit = holobionts.reduce((s, h) => s + h.fitness, 0) / holobionts.length;
            const heritability = calculateMicrobiomeHeritability();

            fitnessHistory.push(avgFit);
            heritabilityHistory.push(heritability);

            if (fitnessHistory.length > 200) {
                fitnessHistory.shift();
                heritabilityHistory.shift();
            }

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = (canvas.height - padding * 3) / 2 - 20;

            // Population view
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Holobiont Population (host + microbiome)', padding, 25);

            const microbeColors = [
                '#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#8b5cf6',
                '#ec4899', '#14b8a6', '#f97316', '#84cc16', '#06b6d4'
            ];

            for (const holo of holobionts) {
                const x = padding + holo.x * width;
                const y = padding + holo.y * height;

                // Host body
                ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.beginPath();
                ctx.ellipse(x, y, 15, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Microbiome visualization (pie-chart style)
                const totalAbundance = holo.microbiome.reduce((s, m) => s + m.abundance, 0);
                let startAngle = 0;

                for (const microbe of holo.microbiome) {
                    const sliceAngle = (microbe.abundance / totalAbundance) * Math.PI * 2;
                    ctx.fillStyle = microbeColors[microbe.species % microbeColors.length];
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, 10, startAngle, startAngle + sliceAngle);
                    ctx.closePath();
                    ctx.fill();
                    startAngle += sliceAngle;
                }

                // Fitness indicator (ring)
                ctx.strokeStyle = `rgba(236, 72, 153, ${Math.min(1, holo.fitness / 2)})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 17, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Microbe legend
            ctx.fillStyle = '#888';
            ctx.fillText('Microbe Species:', padding + width - 180, padding + 10);
            for (let i = 0; i < Math.min(5, microbiomeDiversity); i++) {
                ctx.fillStyle = microbeColors[i];
                ctx.fillRect(padding + width - 180 + i * 25, padding + 20, 20, 10);
            }

            // Evolution chart
            const chartY = padding * 2 + height + 20;
            ctx.fillStyle = '#888';
            ctx.fillText('Hologenome Fitness & Microbiome Heritability', padding, chartY - 10);

            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(padding, chartY);
            ctx.lineTo(padding, chartY + height);
            ctx.lineTo(padding + width, chartY + height);
            ctx.stroke();

            if (fitnessHistory.length > 1) {
                const maxFit = Math.max(2, ...fitnessHistory);

                // Fitness
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < fitnessHistory.length; i++) {
                    const x = padding + (i / fitnessHistory.length) * width;
                    const y = chartY + height - (fitnessHistory[i] / maxFit) * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Heritability
                ctx.strokeStyle = '#8b5cf6';
                ctx.beginPath();
                for (let i = 0; i < heritabilityHistory.length; i++) {
                    const x = padding + (i / heritabilityHistory.length) * width;
                    const y = chartY + height - heritabilityHistory[i] * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Legend
            ctx.fillStyle = '#ec4899';
            ctx.fillRect(padding + 10, chartY + 10, 15, 3);
            ctx.fillStyle = '#888';
            ctx.fillText('Hologenome Fitness', padding + 30, chartY + 14);

            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(padding + 160, chartY + 10, 15, 3);
            ctx.fillText('Microbiome Heritability', padding + 180, chartY + 14);
        }

        function updateStats() {
            const avgRichness = holobionts.reduce((s, h) => s + h.richness, 0) / holobionts.length;
            const avgFit = holobionts.reduce((s, h) => s + h.fitness, 0) / holobionts.length;
            const heritability = calculateMicrobiomeHeritability();

            // Host-microbe correlation (proxy)
            const correlation = holobionts.reduce((s, h) => {
                const microbiomeEffect = h.microbiome.reduce((ms, m) => ms + m.benefitToHost * m.abundance, 0);
                return s + h.hostGenome.immuneTolerance * microbiomeEffect;
            }, 0) / holobionts.length;

            document.getElementById('generation').textContent = generation;
            document.getElementById('holobionts').textContent = holobionts.length;
            document.getElementById('heritability').textContent = heritability.toFixed(2);
            document.getElementById('richness').textContent = avgRichness.toFixed(1);
            document.getElementById('holoFit').textContent = avgFit.toFixed(2);
            document.getElementById('correlation').textContent = correlation.toFixed(2);
        }

        document.getElementById('vertSlider').addEventListener('input', (e) => {
            verticalTransmission = parseFloat(e.target.value);
            document.getElementById('vertValue').textContent = verticalTransmission.toFixed(1);
        });

        document.getElementById('divSlider').addEventListener('input', (e) => {
            microbiomeDiversity = parseInt(e.target.value);
            document.getElementById('divValue').textContent = microbiomeDiversity;
        });

        document.getElementById('coupSlider').addEventListener('input', (e) => {
            hostMicrobeCoupling = parseFloat(e.target.value);
            document.getElementById('coupValue').textContent = hostMicrobeCoupling.toFixed(1);
        });

        document.getElementById('envSlider').addEventListener('input', (e) => {
            environmentalPressure = parseFloat(e.target.value);
            document.getElementById('envValue').textContent = environmentalPressure.toFixed(1);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initPopulation();
            render();
            updateStats();
        });

        initPopulation();
        render();
        updateStats();
    </script>
</body>
</html>
