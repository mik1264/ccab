<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Dots</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #ce93d8; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #ce93d8; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #ce93d8; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        select { width: 100%; padding: 5px; margin-top: 5px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Quantum Dots</h1>
            <p class="description">Quantum dots are semiconductor nanocrystals (2-10 nm) with size-tunable optical properties due to quantum confinement. Smaller dots emit blue light, larger dots emit red.</p>

            <div class="control-group">
                <label>Target Size (nm): <span id="sizeVal">4</span></label>
                <input type="range" id="targetSize" min="2" max="8" step="0.5" value="4">
            </div>

            <div class="control-group">
                <label>Nucleation Rate: <span id="nucVal">0.5</span></label>
                <input type="range" id="nucleation" min="0.1" max="2.0" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Growth Rate: <span id="growthVal">0.5</span></label>
                <input type="range" id="growthRate" min="0.1" max="2.0" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Material:</label>
                <select id="material">
                    <option value="CdSe">CdSe</option>
                    <option value="CdTe">CdTe</option>
                    <option value="InP">InP</option>
                    <option value="PbS">PbS</option>
                </select>
            </div>

            <button id="synthesize">Start Synthesis</button>
            <button id="uv">Toggle UV Excitation</button>
            <button id="reset">Reset</button>

            <div class="stats">
                <div>Quantum Dots: <span id="qdCount">0</span></div>
                <div>Avg Size: <span id="avgSize">0</span> nm</div>
                <div>Size Std Dev: <span id="sizeStd">0</span> nm</div>
                <div>Emission λ: <span id="emission">0</span> nm</div>
                <div>Band Gap: <span id="bandGap">0</span> eV</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let running = false;
        let uvOn = false;
        let time = 0;

        let targetSize = 4;
        let nucleationRate = 0.5;
        let growthRateParam = 0.5;
        let material = 'CdSe';

        let quantumDots = [];
        let monomers = [];

        // Material properties (bulk band gap in eV)
        const materials = {
            'CdSe': { Eg: 1.74, me: 0.13, mh: 0.45, color: [255, 69, 0] },
            'CdTe': { Eg: 1.50, me: 0.11, mh: 0.35, color: [255, 0, 0] },
            'InP': { Eg: 1.35, me: 0.08, mh: 0.60, color: [0, 255, 0] },
            'PbS': { Eg: 0.41, me: 0.09, mh: 0.09, color: [139, 69, 19] }
        };

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            time = 0;
            running = false;
            quantumDots = [];
            monomers = [];
            updateStats();
        }

        function calculateBandGap(size) {
            // Effective mass approximation for quantum confinement
            // E = Eg_bulk + h²/(8r²) * (1/me + 1/mh) - 1.8e²/(εr)
            const mat = materials[material];
            const r = size / 2 * 1e-9; // nm to meters
            const h = 6.626e-34; // Planck constant
            const e = 1.602e-19; // electron charge
            const epsilon = 10 * 8.854e-12; // permittivity (approximate)
            const m0 = 9.109e-31; // electron mass

            const confinement = (h * h) / (8 * r * r * m0) * (1/mat.me + 1/mat.mh) / e;
            const coulomb = 1.8 * e / (4 * Math.PI * epsilon * r) / e;

            return mat.Eg + confinement - coulomb;
        }

        function bandGapToWavelength(Eg) {
            // E = hc/λ
            const hc = 1240; // eV·nm
            return hc / Eg;
        }

        function wavelengthToColor(wavelength) {
            // Convert wavelength to RGB
            let r, g, b;

            if (wavelength >= 380 && wavelength < 440) {
                r = -(wavelength - 440) / (440 - 380);
                g = 0;
                b = 1;
            } else if (wavelength >= 440 && wavelength < 490) {
                r = 0;
                g = (wavelength - 440) / (490 - 440);
                b = 1;
            } else if (wavelength >= 490 && wavelength < 510) {
                r = 0;
                g = 1;
                b = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                r = (wavelength - 510) / (580 - 510);
                g = 1;
                b = 0;
            } else if (wavelength >= 580 && wavelength < 645) {
                r = 1;
                g = -(wavelength - 645) / (645 - 580);
                b = 0;
            } else if (wavelength >= 645 && wavelength <= 780) {
                r = 1;
                g = 0;
                b = 0;
            } else {
                r = 0; g = 0; b = 0;
            }

            return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
        }

        function step() {
            time += 0.01;

            // Generate monomers (precursor molecules)
            if (running && Math.random() < 0.2) {
                monomers.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4
                });
            }

            // Limit monomers
            if (monomers.length > 500) {
                monomers.shift();
            }

            // Move monomers (Brownian motion)
            for (const m of monomers) {
                m.vx += (Math.random() - 0.5) * 0.5;
                m.vy += (Math.random() - 0.5) * 0.5;
                m.vx *= 0.98;
                m.vy *= 0.98;
                m.x += m.vx;
                m.y += m.vy;

                // Wrap around
                if (m.x < 0) m.x += width;
                if (m.x > width) m.x -= width;
                if (m.y < 0) m.y += height;
                if (m.y > height) m.y -= height;
            }

            // Nucleation (new QD formation)
            if (running && monomers.length > 50 && Math.random() < nucleationRate * 0.02) {
                const idx = Math.floor(Math.random() * monomers.length);
                const m = monomers[idx];

                quantumDots.push({
                    x: m.x,
                    y: m.y,
                    size: 1.5, // Initial nucleus size in nm
                    growing: true
                });

                // Remove used monomers
                monomers.splice(idx, 1);
            }

            // QD growth (Ostwald ripening)
            for (const qd of quantumDots) {
                if (!qd.growing) continue;

                // Find nearby monomers
                for (let i = monomers.length - 1; i >= 0; i--) {
                    const m = monomers[i];
                    const dx = m.x - qd.x;
                    const dy = m.y - qd.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const captureRadius = qd.size * 5; // Capture radius scales with size

                    if (dist < captureRadius && Math.random() < growthRateParam * 0.1) {
                        qd.size += 0.02; // Grow
                        monomers.splice(i, 1);
                    }
                }

                // Size focusing or defocusing
                if (qd.size > targetSize * 1.2) {
                    qd.growing = false; // Stop growth
                }

                // Ostwald ripening: small dots shrink
                if (qd.size < 2 && Math.random() < 0.01) {
                    qd.size -= 0.01;
                }
            }

            // Remove very small dots
            quantumDots = quantumDots.filter(qd => qd.size > 0.5);

            updateStats();
        }

        function draw() {
            // Background
            if (uvOn) {
                ctx.fillStyle = '#0a0a1a'; // Darker for UV
            } else {
                ctx.fillStyle = '#1a1a2e';
            }
            ctx.fillRect(0, 0, width, height);

            // UV light effect
            if (uvOn) {
                ctx.fillStyle = 'rgba(100, 0, 255, 0.05)';
                ctx.fillRect(0, 0, width, height);
            }

            // Draw monomers
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            for (const m of monomers) {
                ctx.beginPath();
                ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw quantum dots
            for (const qd of quantumDots) {
                const bandGap = calculateBandGap(qd.size);
                const wavelength = bandGapToWavelength(bandGap);
                const color = wavelengthToColor(wavelength);

                const displayRadius = qd.size * 4; // Scale for visibility

                if (uvOn) {
                    // Emission glow
                    const gradient = ctx.createRadialGradient(
                        qd.x, qd.y, 0,
                        qd.x, qd.y, displayRadius * 3
                    );
                    gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 1)`);
                    gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`);
                    gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(qd.x, qd.y, displayRadius * 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // QD core
                ctx.fillStyle = uvOn ?
                    `rgb(${color.r}, ${color.g}, ${color.b})` :
                    `rgba(${color.r}, ${color.g}, ${color.b}, 0.7)`;

                ctx.beginPath();
                ctx.arc(qd.x, qd.y, displayRadius, 0, Math.PI * 2);
                ctx.fill();

                // Size label
                if (!uvOn) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(qd.size.toFixed(1), qd.x, qd.y + displayRadius + 12);
                }
            }

            // Size-color legend
            drawLegend();

            // Status
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Material: ${material}`, 10, height - 40);
            ctx.fillText(running ? 'Synthesizing...' : 'Paused', 10, height - 20);
        }

        function drawLegend() {
            const x = width - 200;
            const y = 30;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(x - 10, y - 20, 190, 130);

            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.fillText('Size → Emission', x, y);

            // Draw size-color gradient
            for (let size = 2; size <= 8; size += 0.5) {
                const bandGap = calculateBandGap(size);
                const wavelength = bandGapToWavelength(bandGap);
                const color = wavelengthToColor(wavelength);

                const px = x + (size - 2) * 25;

                ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                ctx.beginPath();
                ctx.arc(px, y + 30, 8, 0, Math.PI * 2);
                ctx.fill();

                if (size % 2 === 0) {
                    ctx.fillStyle = '#aaa';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${size}nm`, px, y + 50);
                    ctx.fillText(`${Math.round(wavelength)}nm`, px, y + 62);
                }
            }

            ctx.textAlign = 'left';
            ctx.fillStyle = '#aaa';
            ctx.font = '10px sans-serif';
            ctx.fillText('← Blue (smaller)', x, y + 80);
            ctx.fillText('Red (larger) →', x + 80, y + 80);
            ctx.fillText('Quantum Confinement Effect', x, y + 100);
        }

        function updateStats() {
            if (quantumDots.length === 0) {
                document.getElementById('qdCount').textContent = '0';
                document.getElementById('avgSize').textContent = '0';
                document.getElementById('sizeStd').textContent = '0';
                document.getElementById('emission').textContent = '0';
                document.getElementById('bandGap').textContent = '0';
                return;
            }

            const sizes = quantumDots.map(qd => qd.size);
            const avgSize = sizes.reduce((a, b) => a + b, 0) / sizes.length;
            const variance = sizes.reduce((sum, s) => sum + Math.pow(s - avgSize, 2), 0) / sizes.length;
            const stdDev = Math.sqrt(variance);

            const avgBandGap = calculateBandGap(avgSize);
            const avgEmission = bandGapToWavelength(avgBandGap);

            document.getElementById('qdCount').textContent = quantumDots.length;
            document.getElementById('avgSize').textContent = avgSize.toFixed(2);
            document.getElementById('sizeStd').textContent = stdDev.toFixed(2);
            document.getElementById('emission').textContent = avgEmission.toFixed(0);
            document.getElementById('bandGap').textContent = avgBandGap.toFixed(2);
        }

        function animate() {
            if (running) {
                for (let i = 0; i < 3; i++) step();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('targetSize').addEventListener('input', e => {
            targetSize = parseFloat(e.target.value);
            document.getElementById('sizeVal').textContent = targetSize;
        });

        document.getElementById('nucleation').addEventListener('input', e => {
            nucleationRate = parseFloat(e.target.value);
            document.getElementById('nucVal').textContent = nucleationRate;
        });

        document.getElementById('growthRate').addEventListener('input', e => {
            growthRateParam = parseFloat(e.target.value);
            document.getElementById('growthVal').textContent = growthRateParam;
        });

        document.getElementById('material').addEventListener('change', e => {
            material = e.target.value;
        });

        document.getElementById('synthesize').addEventListener('click', () => {
            running = !running;
            document.getElementById('synthesize').textContent = running ? 'Stop Synthesis' : 'Start Synthesis';
        });

        document.getElementById('uv').addEventListener('click', () => {
            uvOn = !uvOn;
            document.getElementById('uv').textContent = uvOn ? 'UV Off' : 'Toggle UV Excitation';
        });

        document.getElementById('reset').addEventListener('click', init);

        window.addEventListener('resize', init);

        init();
        animate();
    </script>
</body>
</html>
