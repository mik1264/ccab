<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copolymerization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #3f51b5; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #3f51b5; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #3f51b5; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Copolymerization</h1>
            <p class="description">Copolymerization combines two monomers (A, B). Reactivity ratios r₁ and r₂ determine sequence distribution: random, alternating, or blocky. Mayo-Lewis equation predicts composition.</p>

            <div class="control-group">
                <label>r₁ (A reactivity): <span id="r1Val">1.0</span></label>
                <input type="range" id="r1" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>r₂ (B reactivity): <span id="r2Val">1.0</span></label>
                <input type="range" id="r2" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Feed Ratio [A]/([A]+[B]): <span id="feedVal">0.5</span></label>
                <input type="range" id="feed" min="0.1" max="0.9" step="0.05" value="0.5">
            </div>

            <div class="control-group">
                <label>Temperature: <span id="tempVal">80</span> °C</label>
                <input type="range" id="temperature" min="40" max="150" value="80">
            </div>

            <button id="reset">Reset</button>
            <button id="toggleRun">Run/Pause</button>

            <div class="stats">
                <div>Monomer A left: <span id="monoA">0</span></div>
                <div>Monomer B left: <span id="monoB">0</span></div>
                <div>Copolymer A%: <span id="copoA">0</span>%</div>
                <div>Alternation: <span id="alternation">0</span>%</div>
                <div>Block Length: <span id="blockLen">0</span></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let running = false;
        let time = 0;

        let r1 = 1.0;  // Reactivity ratio for monomer A
        let r2 = 1.0;  // Reactivity ratio for monomer B
        let feedRatio = 0.5;
        let temperature = 80;

        let monomersA = [];
        let monomersB = [];
        let chains = [];
        let initialA, initialB;

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            time = 0;

            monomersA = [];
            monomersB = [];
            chains = [];

            const totalMonomers = 100;
            initialA = Math.floor(totalMonomers * feedRatio);
            initialB = totalMonomers - initialA;

            // Create A monomers
            for (let i = 0; i < initialA; i++) {
                monomersA.push({
                    x: 100 + Math.random() * (width - 500),
                    y: 100 + Math.random() * (height - 200),
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }

            // Create B monomers
            for (let i = 0; i < initialB; i++) {
                monomersB.push({
                    x: 100 + Math.random() * (width - 500),
                    y: 100 + Math.random() * (height - 200),
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }

            // Start with one chain
            chains.push({
                x: (width - 320) / 2,
                y: height / 2,
                vx: 0,
                vy: 0,
                sequence: ['A'], // Start with A
                lastMonomer: 'A',
                active: true
            });

            updateStats();
        }

        function step() {
            time += 0.02;
            const tempFactor = Math.sqrt(temperature / 80);

            // Move monomers
            const allMonomers = [...monomersA, ...monomersB];
            for (const m of allMonomers) {
                m.vx += (Math.random() - 0.5) * 0.3 * tempFactor;
                m.vy += (Math.random() - 0.5) * 0.3 * tempFactor;
                m.vx *= 0.98;
                m.vy *= 0.98;
                m.x += m.vx;
                m.y += m.vy;

                if (m.x < 80) { m.x = 80; m.vx *= -1; }
                if (m.x > width - 380) { m.x = width - 380; m.vx *= -1; }
                if (m.y < 80) { m.y = 80; m.vy *= -1; }
                if (m.y > height - 80) { m.y = height - 80; m.vy *= -1; }
            }

            // Move chains
            for (const c of chains) {
                c.x += c.vx;
                c.y += c.vy;
                c.vx *= 0.99;
                c.vy *= 0.99;

                if (c.x < 80) { c.x = 80; c.vx *= -1; }
                if (c.x > width - 380) { c.x = width - 380; c.vx *= -1; }
                if (c.y < 80) { c.y = 80; c.vy *= -1; }
                if (c.y > height - 80) { c.y = height - 80; c.vy *= -1; }
            }

            // Copolymerization kinetics
            for (const chain of chains) {
                if (!chain.active) continue;

                // Check for A monomer addition
                for (let i = monomersA.length - 1; i >= 0; i--) {
                    const m = monomersA[i];
                    const dx = chain.x - m.x;
                    const dy = chain.y - m.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Probability based on reactivity ratios
                    let prob;
                    if (chain.lastMonomer === 'A') {
                        prob = r1 * 0.1; // A adding to A end
                    } else {
                        prob = 0.1; // A adding to B end
                    }

                    if (dist < 20 && Math.random() < prob * tempFactor) {
                        chain.sequence.push('A');
                        chain.lastMonomer = 'A';
                        chain.x = m.x;
                        chain.y = m.y;
                        monomersA.splice(i, 1);
                        break;
                    }
                }

                // Check for B monomer addition
                for (let i = monomersB.length - 1; i >= 0; i--) {
                    const m = monomersB[i];
                    const dx = chain.x - m.x;
                    const dy = chain.y - m.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Probability based on reactivity ratios
                    let prob;
                    if (chain.lastMonomer === 'B') {
                        prob = r2 * 0.1; // B adding to B end
                    } else {
                        prob = 0.1; // B adding to A end
                    }

                    if (dist < 20 && Math.random() < prob * tempFactor) {
                        chain.sequence.push('B');
                        chain.lastMonomer = 'B';
                        chain.x = m.x;
                        chain.y = m.y;
                        monomersB.splice(i, 1);
                        break;
                    }
                }
            }

            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw reaction vessel
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.strokeRect(70, 70, width - 450, height - 140);

            ctx.fillStyle = 'rgba(40, 40, 50, 0.5)';
            ctx.fillRect(70, 70, width - 450, height - 140);

            // Draw A monomers (blue)
            ctx.fillStyle = '#2196f3';
            for (const m of monomersA) {
                ctx.beginPath();
                ctx.arc(m.x, m.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw B monomers (orange)
            ctx.fillStyle = '#ff9800';
            for (const m of monomersB) {
                ctx.beginPath();
                ctx.arc(m.x, m.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw copolymer chains
            for (const chain of chains) {
                if (chain.sequence.length < 2) continue;

                // Calculate positions along a meandering path
                const unitSpacing = 8;
                let positions = [];
                let angle = 0;
                let x = chain.x - chain.sequence.length * unitSpacing / 2;
                let y = chain.y;

                for (let i = 0; i < chain.sequence.length; i++) {
                    positions.push({ x, y, type: chain.sequence[i] });
                    angle += (Math.random() - 0.5) * 0.5;
                    x += unitSpacing * Math.cos(angle);
                    y += unitSpacing * Math.sin(angle);
                }

                // Draw backbone
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(positions[0].x, positions[0].y);
                for (let i = 1; i < positions.length; i++) {
                    ctx.lineTo(positions[i].x, positions[i].y);
                }
                ctx.stroke();

                // Draw monomer units
                for (const p of positions) {
                    ctx.fillStyle = p.type === 'A' ? '#2196f3' : '#ff9800';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Active end indicator
                if (chain.active) {
                    const lastPos = positions[positions.length - 1];
                    ctx.fillStyle = '#f44336';
                    ctx.beginPath();
                    ctx.arc(lastPos.x, lastPos.y, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Legend
            ctx.fillStyle = '#2196f3';
            ctx.beginPath();
            ctx.arc(100, height - 50, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.fillText('Monomer A', 112, height - 46);

            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.arc(200, height - 50, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillText('Monomer B', 212, height - 46);

            // Copolymer type indicator
            ctx.fillStyle = '#3f51b5';
            ctx.font = '13px sans-serif';
            let copoType = getCopoType();
            ctx.fillText('Type: ' + copoType, 100, 50);

            // Mayo-Lewis equation
            ctx.fillStyle = '#aaa';
            ctx.font = '11px sans-serif';
            ctx.fillText('r₁r₂ = ' + (r1 * r2).toFixed(2), 300, 50);
            if (r1 * r2 < 1) {
                ctx.fillText('→ Alternating tendency', 380, 50);
            } else if (r1 * r2 > 1) {
                ctx.fillText('→ Block tendency', 380, 50);
            } else {
                ctx.fillText('→ Random', 380, 50);
            }

            // Composition diagram
            drawCompositionDiagram();
        }

        function getCopoType() {
            const product = r1 * r2;
            if (product < 0.3) return 'Alternating';
            if (product > 3) return 'Block';
            if (r1 > 2 && r2 < 0.5) return 'Gradient (A-rich)';
            if (r2 > 2 && r1 < 0.5) return 'Gradient (B-rich)';
            return 'Random';
        }

        function drawCompositionDiagram() {
            const diagX = width - 280;
            const diagY = 100;
            const diagW = 200;
            const diagH = 150;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(diagX - 10, diagY - 20, diagW + 20, diagH + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.fillText('Sequence Distribution', diagX, diagY - 5);

            // Show sequence of last 30 units
            for (const chain of chains) {
                const seq = chain.sequence.slice(-30);
                const unitW = diagW / 30;

                for (let i = 0; i < seq.length; i++) {
                    ctx.fillStyle = seq[i] === 'A' ? '#2196f3' : '#ff9800';
                    ctx.fillRect(diagX + i * unitW, diagY + 10, unitW - 1, 20);
                }
            }

            // Composition over time plot placeholder
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(diagX, diagY + 50, diagW, diagH - 50);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Copolymer Composition', diagX + 40, diagY + diagH + 15);
        }

        function updateStats() {
            const totalInChain = chains.reduce((sum, c) => sum + c.sequence.length, 0);
            const aInChain = chains.reduce((sum, c) => sum + c.sequence.filter(m => m === 'A').length, 0);
            const bInChain = totalInChain - aInChain;

            const aPercent = totalInChain > 0 ? (aInChain / totalInChain * 100).toFixed(1) : 0;

            // Calculate alternation percentage
            let alternations = 0;
            for (const chain of chains) {
                for (let i = 1; i < chain.sequence.length; i++) {
                    if (chain.sequence[i] !== chain.sequence[i - 1]) {
                        alternations++;
                    }
                }
            }
            const altPercent = totalInChain > 1 ? (alternations / (totalInChain - 1) * 100).toFixed(1) : 0;

            // Calculate average block length
            let blockLengths = [];
            for (const chain of chains) {
                let currentBlock = 1;
                for (let i = 1; i < chain.sequence.length; i++) {
                    if (chain.sequence[i] === chain.sequence[i - 1]) {
                        currentBlock++;
                    } else {
                        blockLengths.push(currentBlock);
                        currentBlock = 1;
                    }
                }
                if (currentBlock > 0) blockLengths.push(currentBlock);
            }
            const avgBlock = blockLengths.length > 0 ?
                (blockLengths.reduce((a, b) => a + b, 0) / blockLengths.length).toFixed(1) : 1;

            document.getElementById('monoA').textContent = monomersA.length;
            document.getElementById('monoB').textContent = monomersB.length;
            document.getElementById('copoA').textContent = aPercent;
            document.getElementById('alternation').textContent = altPercent;
            document.getElementById('blockLen').textContent = avgBlock;
        }

        function animate() {
            if (running) {
                step();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('r1').addEventListener('input', e => {
            r1 = parseFloat(e.target.value);
            document.getElementById('r1Val').textContent = r1;
        });

        document.getElementById('r2').addEventListener('input', e => {
            r2 = parseFloat(e.target.value);
            document.getElementById('r2Val').textContent = r2;
        });

        document.getElementById('feed').addEventListener('input', e => {
            feedRatio = parseFloat(e.target.value);
            document.getElementById('feedVal').textContent = feedRatio;
        });

        document.getElementById('temperature').addEventListener('input', e => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('toggleRun').addEventListener('click', () => {
            running = !running;
            document.getElementById('toggleRun').textContent = running ? 'Pause' : 'Run';
        });

        window.addEventListener('resize', init);

        init();
        animate();
    </script>
</body>
</html>
