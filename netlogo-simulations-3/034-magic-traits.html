<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Traits - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #f472b6; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #f472b6; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #f472b6; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #ec4899; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #f472b6; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f472b6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(244,114,182,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #f472b6; }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            padding: 20px;
            overflow-y: auto;
        }
        .modal-overlay.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            border-radius: 20px;
            padding: 35px;
            max-width: 750px;
            width: 100%;
            margin: 40px auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .modal-close:hover {
            color: #fff;
            background: rgba(255,255,255,0.2);
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 25px;
            font-size: 1.6rem;
            padding-right: 50px;
            line-height: 1.3;
        }
        .modal-body {
            color: #d1d5db;
            line-height: 1.9;
            font-size: 1rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 28px 0 14px 0;
            font-size: 1.15rem;
            font-weight: 600;
        }
        .modal-body p {
            margin-bottom: 16px;
        }
        .modal-body ul {
            margin: 12px 0 18px 24px;
        }
        .modal-body li {
            margin-bottom: 10px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: italic;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: #fbbf24;
            font-size: 0.9em;
        }
        .modal-category {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">‚Üê Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>‚ú® Magic Traits</h1>
            <p class="description">
                "Magic traits" are pleiotropic: the same gene affects both ecological
                adaptation AND mate choice. This creates automatic reproductive isolation
                as a byproduct of ecological divergence.
            </p>

            <div class="control-group">
                <label>Population Size: <span class="value-display" id="popValue">150</span></label>
                <input type="range" id="popSlider" min="50" max="300" value="150">
            </div>

            <div class="control-group">
                <label>Ecological Selection: <span class="value-display" id="ecoValue">0.5</span></label>
                <input type="range" id="ecoSlider" min="0" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Pleiotropy Strength: <span class="value-display" id="pleioValue">0.8</span></label>
                <input type="range" id="pleioSlider" min="0" max="1" step="0.1" value="0.8">
                <div style="font-size: 0.65rem; color: #666;">0 = no link, 1 = perfect pleiotropy</div>
            </div>

            <div class="control-group">
                <label>Niche Divergence: <span class="value-display" id="nicheValue">0.6</span></label>
                <input type="range" id="nicheSlider" min="0.2" max="1" step="0.1" value="0.6">
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>
                <button id="explainBtn" class="explain-btn">üìö Explain This Simulation</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Ecological Divergence: <span id="ecoDivergence">0.00</span></div>
                <div>Mating Assortment: <span id="assortment">0.00</span></div>
                <div>Reproductive Isolation: <span id="isolation">0.00</span></div>
                <div>Niche 1 Pop: <span id="niche1">0</span></div>
                <div>Niche 2 Pop: <span id="niche2">0</span></div>
            </div>

            <div class="theory">
                <strong>Magic Traits:</strong> Examples include body size in sticklebacks
                (affects diet AND mate preference), wing patterns in Heliconius (mimicry AND
                mate recognition), and MHC genes (immunity AND mate choice). Speciation
                becomes "automatic" through ecological adaptation.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;
        let population = [];
        let divergenceHistory = [];
        let isolationHistory = [];

        let popSize = 150;
        let ecoSelection = 0.5;
        let pleiotropy = 0.8;
        let nicheDivergence = 0.6;

        class Individual {
            constructor(magicTrait = null, niche = null) {
                // Magic trait affects both ecology AND mate preference
                this.magicTrait = magicTrait !== null ? magicTrait : Math.random();
                // Niche: 1 (low trait optimal) or 2 (high trait optimal)
                this.niche = niche !== null ? niche : (Math.random() < 0.5 ? 1 : 2);
            }

            get optimalTrait() {
                return this.niche === 1 ? (0.5 - nicheDivergence / 2) : (0.5 + nicheDivergence / 2);
            }

            get fitness() {
                const diff = Math.abs(this.magicTrait - this.optimalTrait);
                return Math.exp(-diff * diff * ecoSelection * 10);
            }

            get matePreference() {
                // With pleiotropy, preference matches own trait
                // Without, preference is random
                return pleiotropy * this.magicTrait + (1 - pleiotropy) * 0.5;
            }

            acceptsMate(other) {
                // Accept mates with similar magic trait (due to pleiotropy)
                const prefDiff = Math.abs(other.magicTrait - this.matePreference);
                const threshold = (1 - pleiotropy) * 0.5 + 0.1;
                return prefDiff < threshold;
            }

            reproduce(mate) {
                // Offspring trait is blend with mutation
                let newTrait = (this.magicTrait + mate.magicTrait) / 2;
                newTrait += (Math.random() - 0.5) * 0.1;
                newTrait = Math.max(0, Math.min(1, newTrait));

                // Offspring in parent's niche with some dispersal
                const niche = Math.random() < 0.9 ? this.niche : (this.niche === 1 ? 2 : 1);

                return new Individual(newTrait, niche);
            }
        }

        function initPopulation() {
            population = [];
            divergenceHistory = [];
            isolationHistory = [];

            for (let i = 0; i < popSize; i++) {
                population.push(new Individual());
            }
        }

        function calculateIsolation() {
            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            if (niche1.length === 0 || niche2.length === 0) return 0;

            let crossAcceptance = 0;
            let withinAcceptance = 0;
            const samples = 30;

            for (let i = 0; i < samples; i++) {
                const ind1 = niche1[Math.floor(Math.random() * niche1.length)];
                const ind2 = niche2[Math.floor(Math.random() * niche2.length)];
                const same = niche1[Math.floor(Math.random() * niche1.length)];

                if (ind1.acceptsMate(ind2)) crossAcceptance++;
                if (ind1.acceptsMate(same)) withinAcceptance++;
            }

            return 1 - (crossAcceptance / Math.max(1, withinAcceptance));
        }

        function reproduce() {
            const newPop = [];

            // Separate by niche
            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            const reproduceInNiche = (nichePopulation, targetSize) => {
                const offspring = [];
                if (nichePopulation.length < 2) return offspring;

                const fitnesses = nichePopulation.map(ind => ind.fitness);
                const totalFit = fitnesses.reduce((a, b) => a + b, 0);

                const selectParent = () => {
                    let r = Math.random() * totalFit;
                    for (let i = 0; i < nichePopulation.length; i++) {
                        r -= fitnesses[i];
                        if (r <= 0) return nichePopulation[i];
                    }
                    return nichePopulation[nichePopulation.length - 1];
                };

                while (offspring.length < targetSize) {
                    const mother = selectParent();

                    let mate = null;
                    let attempts = 0;
                    while (!mate && attempts < 15) {
                        const candidate = selectParent();
                        if (candidate !== mother && mother.acceptsMate(candidate)) {
                            mate = candidate;
                        }
                        attempts++;
                    }

                    if (mate) {
                        offspring.push(mother.reproduce(mate));
                    } else {
                        // If no acceptable mate, random mating
                        const randomMate = nichePopulation[Math.floor(Math.random() * nichePopulation.length)];
                        offspring.push(mother.reproduce(randomMate));
                    }
                }

                return offspring;
            };

            const target1 = Math.round(popSize * (niche1.length / population.length || 0.5));
            const target2 = popSize - target1;

            const offspring1 = reproduceInNiche(niche1, target1);
            const offspring2 = reproduceInNiche(niche2, target2);

            population = [...offspring1, ...offspring2];
        }

        function update() {
            if (!running) return;

            generation++;
            reproduce();

            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            const mean1 = niche1.length > 0 ? niche1.reduce((s, i) => s + i.magicTrait, 0) / niche1.length : 0.5;
            const mean2 = niche2.length > 0 ? niche2.reduce((s, i) => s + i.magicTrait, 0) / niche2.length : 0.5;

            const divergence = Math.abs(mean1 - mean2);
            const isolation = calculateIsolation();

            divergenceHistory.push(divergence);
            isolationHistory.push(isolation);

            if (divergenceHistory.length > 400) {
                divergenceHistory.shift();
                isolationHistory.shift();
            }

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = (canvas.height - padding * 3) / 2;

            // Magic trait distribution by niche
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Magic Trait Distribution by Niche', padding, 25);

            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            // Draw fitness curves for each niche
            const opt1 = 0.5 - nicheDivergence / 2;
            const opt2 = 0.5 + nicheDivergence / 2;

            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const x = padding + t * width;
                const fit = Math.exp(-Math.pow(t - opt1, 2) * ecoSelection * 10);
                const y = padding + height - 20 - fit * (height - 40);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const x = padding + t * width;
                const fit = Math.exp(-Math.pow(t - opt2, 2) * ecoSelection * 10);
                const y = padding + height - 20 - fit * (height - 40);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Plot individuals
            for (const ind of niche1) {
                const x = padding + ind.magicTrait * width;
                const y = padding + height - 30;
                ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            for (const ind of niche2) {
                const x = padding + ind.magicTrait * width;
                const y = padding + height - 45;
                ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Legend
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(padding + width - 100, padding + 10, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Niche 1', padding + width - 80, padding + 18);
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(padding + width - 100, padding + 25, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Niche 2', padding + width - 80, padding + 33);

            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(padding, padding + height - 20);
            ctx.lineTo(padding + width, padding + height - 20);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.fillText('Magic Trait Value', padding + width / 2 - 50, padding + height);

            // Divergence and isolation over time
            const chartY = padding * 2 + height;
            ctx.fillText('Ecological Divergence & Reproductive Isolation', padding, chartY - 10);

            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(padding, chartY);
            ctx.lineTo(padding, chartY + height);
            ctx.lineTo(padding + width, chartY + height);
            ctx.stroke();

            if (divergenceHistory.length > 1) {
                // Divergence
                ctx.strokeStyle = '#f472b6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < divergenceHistory.length; i++) {
                    const x = padding + (i / divergenceHistory.length) * width;
                    const y = chartY + height - divergenceHistory[i] * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Isolation
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < isolationHistory.length; i++) {
                    const x = padding + (i / isolationHistory.length) * width;
                    const val = Math.max(0, Math.min(1, isolationHistory[i]));
                    const y = chartY + height - val * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Legend
            ctx.fillStyle = '#f472b6';
            ctx.fillRect(padding + width - 130, chartY + 10, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Divergence', padding + width - 110, chartY + 18);
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(padding + width - 130, chartY + 25, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Isolation', padding + width - 110, chartY + 33);
        }

        function updateStats() {
            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            const mean1 = niche1.length > 0 ? niche1.reduce((s, i) => s + i.magicTrait, 0) / niche1.length : 0.5;
            const mean2 = niche2.length > 0 ? niche2.reduce((s, i) => s + i.magicTrait, 0) / niche2.length : 0.5;

            document.getElementById('generation').textContent = generation;
            document.getElementById('ecoDivergence').textContent = Math.abs(mean1 - mean2).toFixed(3);
            document.getElementById('assortment').textContent = pleiotropy.toFixed(2);
            document.getElementById('isolation').textContent = Math.max(0, calculateIsolation()).toFixed(3);
            document.getElementById('niche1').textContent = niche1.length;
            document.getElementById('niche2').textContent = niche2.length;
        }

        document.getElementById('popSlider').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
        });

        document.getElementById('ecoSlider').addEventListener('input', (e) => {
            ecoSelection = parseFloat(e.target.value);
            document.getElementById('ecoValue').textContent = ecoSelection.toFixed(1);
        });

        document.getElementById('pleioSlider').addEventListener('input', (e) => {
            pleiotropy = parseFloat(e.target.value);
            document.getElementById('pleioValue').textContent = pleiotropy.toFixed(1);
        });

        document.getElementById('nicheSlider').addEventListener('input', (e) => {
            nicheDivergence = parseFloat(e.target.value);
            document.getElementById('nicheValue').textContent = nicheDivergence.toFixed(1);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initPopulation();
            render();
            updateStats();
        });

        initPopulation();
        render();
        updateStats();
    </script>


    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Magic Traits</h2>
            <div class="modal-body">
                <p>Evolution occurs through changes in allele frequencies over generations. This simulation demonstrates key evolutionary mechanisms including natural selection, genetic drift, and mutation.</p>

                <h3>About This Simulation</h3>
                <p>Build a model where ecological adaptation and mate choice are pleiotropically linked.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Fitness Landscapes:</strong> Populations navigate through "fitness landscapes" - conceptual maps where height represents reproductive success. Rugged landscapes have multiple peaks separated by valleys of lower fitness.</li>
                    <li><strong>Genetic Drift:</strong> Random changes in allele frequencies, especially important in small populations. Can cause alleles to become fixed or lost regardless of their fitness effects.</li>
                    <li><strong>Natural Selection:</strong> Differential survival and reproduction based on heritable traits. Drives adaptation but can be overwhelmed by drift in small populations.</li>
                    <li><strong>Epistasis:</strong> Gene interactions where the effect of one gene depends on others. Creates rugged fitness landscapes with multiple local optima.</li>
                </ul>

                <h3>Why It Matters</h3>
                <p>Understanding evolutionary dynamics is crucial for conservation biology, disease evolution, antibiotic resistance, and breeding programs.</p>

                <h3>How to Explore</h3>
                <ul>
                    <li>Adjust the sliders to modify simulation parameters and observe how the system responds</li>
                    <li>Look for emergent patterns that arise from agent interactions</li>
                    <li>Try extreme parameter values to find phase transitions and tipping points</li>
                    <li>Compare the simulation behavior to real-world phenomena</li>
                </ul>

                <p class="modal-category"><em>Category: Evolutionary Dynamics ‚Äî Exploring evolutionary biology and population genetics</em></p>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('explainModal');
        const explainBtn = document.getElementById('explainBtn');
        if (modal && explainBtn) {
            explainBtn.addEventListener('click', function() {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
            modal.querySelector('.modal-close').addEventListener('click', function() {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            });
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
        }
    });
    </script>

</body>
</html>
