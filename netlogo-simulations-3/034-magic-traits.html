<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Traits - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #f472b6; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #f472b6; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #f472b6; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #ec4899; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #f472b6; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f472b6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(244,114,182,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #f472b6; }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">← Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>✨ Magic Traits</h1>
            <p class="description">
                "Magic traits" are pleiotropic: the same gene affects both ecological
                adaptation AND mate choice. This creates automatic reproductive isolation
                as a byproduct of ecological divergence.
            </p>

            <div class="control-group">
                <label>Population Size: <span class="value-display" id="popValue">150</span></label>
                <input type="range" id="popSlider" min="50" max="300" value="150">
            </div>

            <div class="control-group">
                <label>Ecological Selection: <span class="value-display" id="ecoValue">0.5</span></label>
                <input type="range" id="ecoSlider" min="0" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Pleiotropy Strength: <span class="value-display" id="pleioValue">0.8</span></label>
                <input type="range" id="pleioSlider" min="0" max="1" step="0.1" value="0.8">
                <div style="font-size: 0.65rem; color: #666;">0 = no link, 1 = perfect pleiotropy</div>
            </div>

            <div class="control-group">
                <label>Niche Divergence: <span class="value-display" id="nicheValue">0.6</span></label>
                <input type="range" id="nicheSlider" min="0.2" max="1" step="0.1" value="0.6">
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Ecological Divergence: <span id="ecoDivergence">0.00</span></div>
                <div>Mating Assortment: <span id="assortment">0.00</span></div>
                <div>Reproductive Isolation: <span id="isolation">0.00</span></div>
                <div>Niche 1 Pop: <span id="niche1">0</span></div>
                <div>Niche 2 Pop: <span id="niche2">0</span></div>
            </div>

            <div class="theory">
                <strong>Magic Traits:</strong> Examples include body size in sticklebacks
                (affects diet AND mate preference), wing patterns in Heliconius (mimicry AND
                mate recognition), and MHC genes (immunity AND mate choice). Speciation
                becomes "automatic" through ecological adaptation.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;
        let population = [];
        let divergenceHistory = [];
        let isolationHistory = [];

        let popSize = 150;
        let ecoSelection = 0.5;
        let pleiotropy = 0.8;
        let nicheDivergence = 0.6;

        class Individual {
            constructor(magicTrait = null, niche = null) {
                // Magic trait affects both ecology AND mate preference
                this.magicTrait = magicTrait !== null ? magicTrait : Math.random();
                // Niche: 1 (low trait optimal) or 2 (high trait optimal)
                this.niche = niche !== null ? niche : (Math.random() < 0.5 ? 1 : 2);
            }

            get optimalTrait() {
                return this.niche === 1 ? (0.5 - nicheDivergence / 2) : (0.5 + nicheDivergence / 2);
            }

            get fitness() {
                const diff = Math.abs(this.magicTrait - this.optimalTrait);
                return Math.exp(-diff * diff * ecoSelection * 10);
            }

            get matePreference() {
                // With pleiotropy, preference matches own trait
                // Without, preference is random
                return pleiotropy * this.magicTrait + (1 - pleiotropy) * 0.5;
            }

            acceptsMate(other) {
                // Accept mates with similar magic trait (due to pleiotropy)
                const prefDiff = Math.abs(other.magicTrait - this.matePreference);
                const threshold = (1 - pleiotropy) * 0.5 + 0.1;
                return prefDiff < threshold;
            }

            reproduce(mate) {
                // Offspring trait is blend with mutation
                let newTrait = (this.magicTrait + mate.magicTrait) / 2;
                newTrait += (Math.random() - 0.5) * 0.1;
                newTrait = Math.max(0, Math.min(1, newTrait));

                // Offspring in parent's niche with some dispersal
                const niche = Math.random() < 0.9 ? this.niche : (this.niche === 1 ? 2 : 1);

                return new Individual(newTrait, niche);
            }
        }

        function initPopulation() {
            population = [];
            divergenceHistory = [];
            isolationHistory = [];

            for (let i = 0; i < popSize; i++) {
                population.push(new Individual());
            }
        }

        function calculateIsolation() {
            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            if (niche1.length === 0 || niche2.length === 0) return 0;

            let crossAcceptance = 0;
            let withinAcceptance = 0;
            const samples = 30;

            for (let i = 0; i < samples; i++) {
                const ind1 = niche1[Math.floor(Math.random() * niche1.length)];
                const ind2 = niche2[Math.floor(Math.random() * niche2.length)];
                const same = niche1[Math.floor(Math.random() * niche1.length)];

                if (ind1.acceptsMate(ind2)) crossAcceptance++;
                if (ind1.acceptsMate(same)) withinAcceptance++;
            }

            return 1 - (crossAcceptance / Math.max(1, withinAcceptance));
        }

        function reproduce() {
            const newPop = [];

            // Separate by niche
            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            const reproduceInNiche = (nichePopulation, targetSize) => {
                const offspring = [];
                if (nichePopulation.length < 2) return offspring;

                const fitnesses = nichePopulation.map(ind => ind.fitness);
                const totalFit = fitnesses.reduce((a, b) => a + b, 0);

                const selectParent = () => {
                    let r = Math.random() * totalFit;
                    for (let i = 0; i < nichePopulation.length; i++) {
                        r -= fitnesses[i];
                        if (r <= 0) return nichePopulation[i];
                    }
                    return nichePopulation[nichePopulation.length - 1];
                };

                while (offspring.length < targetSize) {
                    const mother = selectParent();

                    let mate = null;
                    let attempts = 0;
                    while (!mate && attempts < 15) {
                        const candidate = selectParent();
                        if (candidate !== mother && mother.acceptsMate(candidate)) {
                            mate = candidate;
                        }
                        attempts++;
                    }

                    if (mate) {
                        offspring.push(mother.reproduce(mate));
                    } else {
                        // If no acceptable mate, random mating
                        const randomMate = nichePopulation[Math.floor(Math.random() * nichePopulation.length)];
                        offspring.push(mother.reproduce(randomMate));
                    }
                }

                return offspring;
            };

            const target1 = Math.round(popSize * (niche1.length / population.length || 0.5));
            const target2 = popSize - target1;

            const offspring1 = reproduceInNiche(niche1, target1);
            const offspring2 = reproduceInNiche(niche2, target2);

            population = [...offspring1, ...offspring2];
        }

        function update() {
            if (!running) return;

            generation++;
            reproduce();

            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            const mean1 = niche1.length > 0 ? niche1.reduce((s, i) => s + i.magicTrait, 0) / niche1.length : 0.5;
            const mean2 = niche2.length > 0 ? niche2.reduce((s, i) => s + i.magicTrait, 0) / niche2.length : 0.5;

            const divergence = Math.abs(mean1 - mean2);
            const isolation = calculateIsolation();

            divergenceHistory.push(divergence);
            isolationHistory.push(isolation);

            if (divergenceHistory.length > 400) {
                divergenceHistory.shift();
                isolationHistory.shift();
            }

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = (canvas.height - padding * 3) / 2;

            // Magic trait distribution by niche
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Magic Trait Distribution by Niche', padding, 25);

            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            // Draw fitness curves for each niche
            const opt1 = 0.5 - nicheDivergence / 2;
            const opt2 = 0.5 + nicheDivergence / 2;

            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const x = padding + t * width;
                const fit = Math.exp(-Math.pow(t - opt1, 2) * ecoSelection * 10);
                const y = padding + height - 20 - fit * (height - 40);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const x = padding + t * width;
                const fit = Math.exp(-Math.pow(t - opt2, 2) * ecoSelection * 10);
                const y = padding + height - 20 - fit * (height - 40);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Plot individuals
            for (const ind of niche1) {
                const x = padding + ind.magicTrait * width;
                const y = padding + height - 30;
                ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            for (const ind of niche2) {
                const x = padding + ind.magicTrait * width;
                const y = padding + height - 45;
                ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Legend
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(padding + width - 100, padding + 10, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Niche 1', padding + width - 80, padding + 18);
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(padding + width - 100, padding + 25, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Niche 2', padding + width - 80, padding + 33);

            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(padding, padding + height - 20);
            ctx.lineTo(padding + width, padding + height - 20);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.fillText('Magic Trait Value', padding + width / 2 - 50, padding + height);

            // Divergence and isolation over time
            const chartY = padding * 2 + height;
            ctx.fillText('Ecological Divergence & Reproductive Isolation', padding, chartY - 10);

            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(padding, chartY);
            ctx.lineTo(padding, chartY + height);
            ctx.lineTo(padding + width, chartY + height);
            ctx.stroke();

            if (divergenceHistory.length > 1) {
                // Divergence
                ctx.strokeStyle = '#f472b6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < divergenceHistory.length; i++) {
                    const x = padding + (i / divergenceHistory.length) * width;
                    const y = chartY + height - divergenceHistory[i] * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Isolation
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < isolationHistory.length; i++) {
                    const x = padding + (i / isolationHistory.length) * width;
                    const val = Math.max(0, Math.min(1, isolationHistory[i]));
                    const y = chartY + height - val * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Legend
            ctx.fillStyle = '#f472b6';
            ctx.fillRect(padding + width - 130, chartY + 10, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Divergence', padding + width - 110, chartY + 18);
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(padding + width - 130, chartY + 25, 15, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Isolation', padding + width - 110, chartY + 33);
        }

        function updateStats() {
            const niche1 = population.filter(ind => ind.niche === 1);
            const niche2 = population.filter(ind => ind.niche === 2);

            const mean1 = niche1.length > 0 ? niche1.reduce((s, i) => s + i.magicTrait, 0) / niche1.length : 0.5;
            const mean2 = niche2.length > 0 ? niche2.reduce((s, i) => s + i.magicTrait, 0) / niche2.length : 0.5;

            document.getElementById('generation').textContent = generation;
            document.getElementById('ecoDivergence').textContent = Math.abs(mean1 - mean2).toFixed(3);
            document.getElementById('assortment').textContent = pleiotropy.toFixed(2);
            document.getElementById('isolation').textContent = Math.max(0, calculateIsolation()).toFixed(3);
            document.getElementById('niche1').textContent = niche1.length;
            document.getElementById('niche2').textContent = niche2.length;
        }

        document.getElementById('popSlider').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
        });

        document.getElementById('ecoSlider').addEventListener('input', (e) => {
            ecoSelection = parseFloat(e.target.value);
            document.getElementById('ecoValue').textContent = ecoSelection.toFixed(1);
        });

        document.getElementById('pleioSlider').addEventListener('input', (e) => {
            pleiotropy = parseFloat(e.target.value);
            document.getElementById('pleioValue').textContent = pleiotropy.toFixed(1);
        });

        document.getElementById('nicheSlider').addEventListener('input', (e) => {
            nicheDivergence = parseFloat(e.target.value);
            document.getElementById('nicheValue').textContent = nicheDivergence.toFixed(1);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initPopulation();
            render();
            updateStats();
        });

        initPopulation();
        render();
        updateStats();
    </script>
</body>
</html>
