<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fitness Landscape Navigation - Agent-Based Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 1.8em;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .description {
            color: #888;
            font-size: 0.95em;
            max-width: 800px;
            margin: 0 auto;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
        }
        .controls {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            color: #00d9ff;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            color: #666;
            font-size: 0.85em;
            margin-top: 4px;
        }
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        .btn-primary {
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            color: #000;
            font-weight: bold;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,217,255,0.3);
        }
        .stats {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .stat-label { color: #888; }
        .stat-value { color: #00ff88; font-weight: bold; }
        .legend {
            margin-top: 20px;
            font-size: 0.85em;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 10px;
        }
        .back-link {
            display: inline-block;
            color: #00d9ff;
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.9em;
        }
        .back-link:hover { text-decoration: underline; }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 40px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #fbbf24;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Simulations</a>
        <header>
            <h1>Fitness Landscape Navigation</h1>
            <p class="description">
                Agents traverse rugged NK-model fitness landscapes with multiple peaks.
                Watch adaptive walks, valley crossing via genetic drift, and evolutionary dead ends.
                Based on Sewall Wright's fitness landscape concept (1932).
            </p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Landscape Ruggedness (K)</label>
                    <input type="range" id="ruggedness" min="0" max="10" value="4" step="1">
                    <div class="value-display">K = <span id="ruggedVal">4</span></div>
                </div>

                <div class="control-group">
                    <label>Population Size</label>
                    <input type="range" id="popSize" min="5" max="100" value="30" step="5">
                    <div class="value-display"><span id="popVal">30</span> agents</div>
                </div>

                <div class="control-group">
                    <label>Mutation Rate</label>
                    <input type="range" id="mutRate" min="0.01" max="0.3" value="0.1" step="0.01">
                    <div class="value-display"><span id="mutVal">0.10</span></div>
                </div>

                <div class="control-group">
                    <label>Drift Strength</label>
                    <input type="range" id="drift" min="0" max="1" value="0.2" step="0.05">
                    <div class="value-display"><span id="driftVal">0.20</span></div>
                </div>

                <button class="btn-primary" id="startBtn">Start Simulation</button>
                <button class="btn-secondary" id="resetBtn">Reset Landscape</button>
                <button class="btn-secondary" id="newLandscape">New Random Landscape</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Generation</span>
                        <span class="stat-value" id="genStat">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Best Fitness</span>
                        <span class="stat-value" id="bestStat">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg Fitness</span>
                        <span class="stat-value" id="avgStat">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Local Peaks Found</span>
                        <span class="stat-value" id="peaksStat">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Valley Crossings</span>
                        <span class="stat-value" id="valleyStat">0</span>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff3366;"></div>
                        <span>High Fitness Peak</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3366ff;"></div>
                        <span>Low Fitness Valley</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff88;"></div>
                        <span>Population Agents</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffff00;"></div>
                        <span>Best Individual</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Responsive canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth - 30, 800);
            canvas.width = size;
            canvas.height = size;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation parameters
        let gridSize = 100;
        let ruggedness = 4;
        let populationSize = 30;
        let mutationRate = 0.1;
        let driftStrength = 0.2;

        // Simulation state
        let landscape = [];
        let population = [];
        let generation = 0;
        let running = false;
        let animationId = null;
        let peaksFound = new Set();
        let valleyCrossings = 0;

        // NK Model landscape generation
        function generateNKLandscape() {
            landscape = [];
            const N = gridSize;
            const K = ruggedness;

            // Create random epistatic contributions
            const contributions = [];
            for (let i = 0; i < N; i++) {
                contributions[i] = [];
                for (let j = 0; j < N; j++) {
                    contributions[i][j] = Math.random();
                }
            }

            // Generate landscape using NK model principles
            for (let x = 0; x < gridSize; x++) {
                landscape[x] = [];
                for (let y = 0; y < gridSize; y++) {
                    let fitness = 0;

                    // Base contribution from position
                    const baseX = contributions[x % N][0];
                    const baseY = contributions[0][y % N];

                    // Epistatic interactions based on K
                    for (let k = 0; k <= K; k++) {
                        const interactX = (x + k * 7) % N;
                        const interactY = (y + k * 11) % N;
                        fitness += contributions[interactX][interactY] * (1 / (k + 1));
                    }

                    // Add some smooth peaks
                    const peakCount = 3 + Math.floor(K / 2);
                    for (let p = 0; p < peakCount; p++) {
                        const peakX = (contributions[p][0] * gridSize) | 0;
                        const peakY = (contributions[0][p] * gridSize) | 0;
                        const dist = Math.sqrt((x - peakX) ** 2 + (y - peakY) ** 2);
                        const peakHeight = contributions[p][p];
                        fitness += peakHeight * Math.exp(-dist * dist / (500 / (K + 1)));
                    }

                    // Normalize
                    landscape[x][y] = fitness / (K + 2 + peakCount);
                }
            }

            // Normalize to 0-1 range
            let min = Infinity, max = -Infinity;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    min = Math.min(min, landscape[x][y]);
                    max = Math.max(max, landscape[x][y]);
                }
            }
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    landscape[x][y] = (landscape[x][y] - min) / (max - min);
                }
            }
        }

        // Initialize population
        function initPopulation() {
            population = [];
            for (let i = 0; i < populationSize; i++) {
                population.push({
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize),
                    prevFitness: 0
                });
            }
            population.forEach(p => {
                p.prevFitness = getFitness(p.x, p.y);
            });
        }

        // Get fitness at position
        function getFitness(x, y) {
            x = Math.max(0, Math.min(gridSize - 1, Math.floor(x)));
            y = Math.max(0, Math.min(gridSize - 1, Math.floor(y)));
            return landscape[x][y];
        }

        // Check if position is local peak
        function isLocalPeak(x, y) {
            const fitness = getFitness(x, y);
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        if (getFitness(nx, ny) > fitness) return false;
                    }
                }
            }
            return true;
        }

        // Adaptive walk step
        function adaptiveWalk(agent) {
            const currentFitness = getFitness(agent.x, agent.y);

            // Find neighbors with higher fitness
            const betterNeighbors = [];
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = agent.x + dx;
                    const ny = agent.y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        const nFitness = getFitness(nx, ny);
                        if (nFitness > currentFitness) {
                            betterNeighbors.push({ x: nx, y: ny, fitness: nFitness });
                        }
                    }
                }
            }

            // Apply mutation
            if (Math.random() < mutationRate) {
                const dx = Math.floor(Math.random() * 5) - 2;
                const dy = Math.floor(Math.random() * 5) - 2;
                const nx = Math.max(0, Math.min(gridSize - 1, agent.x + dx));
                const ny = Math.max(0, Math.min(gridSize - 1, agent.y + dy));
                const newFitness = getFitness(nx, ny);

                // Track valley crossing
                if (newFitness < currentFitness && Math.random() < driftStrength) {
                    if (newFitness < agent.prevFitness * 0.8) {
                        valleyCrossings++;
                    }
                    agent.x = nx;
                    agent.y = ny;
                    agent.prevFitness = newFitness;
                    return;
                }
            }

            // Adaptive walk: move to better neighbor
            if (betterNeighbors.length > 0) {
                // Sort by fitness and pick one of the best
                betterNeighbors.sort((a, b) => b.fitness - a.fitness);
                const chosen = betterNeighbors[0];
                agent.x = chosen.x;
                agent.y = chosen.y;
                agent.prevFitness = chosen.fitness;
            } else if (Math.random() < driftStrength) {
                // At local peak or no improvement - drift randomly
                const dx = Math.floor(Math.random() * 3) - 1;
                const dy = Math.floor(Math.random() * 3) - 1;
                agent.x = Math.max(0, Math.min(gridSize - 1, agent.x + dx));
                agent.y = Math.max(0, Math.min(gridSize - 1, agent.y + dy));
                const newFitness = getFitness(agent.x, agent.y);
                if (newFitness < agent.prevFitness * 0.8) {
                    valleyCrossings++;
                }
                agent.prevFitness = newFitness;
            }

            // Track peaks found
            if (isLocalPeak(agent.x, agent.y)) {
                peaksFound.add(`${agent.x},${agent.y}`);
            }
        }

        // Selection step
        function selection() {
            // Sort by fitness
            population.sort((a, b) => getFitness(b.x, b.y) - getFitness(a.x, a.y));

            // Keep top half, replace bottom half with offspring
            const survivors = population.slice(0, Math.ceil(populationSize / 2));
            const newPop = [...survivors];

            while (newPop.length < populationSize) {
                const parent = survivors[Math.floor(Math.random() * survivors.length)];
                newPop.push({
                    x: parent.x,
                    y: parent.y,
                    prevFitness: getFitness(parent.x, parent.y)
                });
            }

            population = newPop;
        }

        // Draw landscape
        function drawLandscape() {
            const cellSize = canvas.width / gridSize;
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const fitness = landscape[x][y];

                    // Color gradient from blue (low) to red (high)
                    const r = Math.floor(fitness * 255);
                    const g = Math.floor(fitness * 100);
                    const b = Math.floor((1 - fitness) * 255);

                    // Fill pixels
                    const startX = Math.floor(x * cellSize);
                    const startY = Math.floor(y * cellSize);
                    const endX = Math.floor((x + 1) * cellSize);
                    const endY = Math.floor((y + 1) * cellSize);

                    for (let px = startX; px < endX; px++) {
                        for (let py = startY; py < endY; py++) {
                            const idx = (py * canvas.width + px) * 4;
                            imageData.data[idx] = r;
                            imageData.data[idx + 1] = g;
                            imageData.data[idx + 2] = b;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Draw population
        function drawPopulation() {
            const cellSize = canvas.width / gridSize;

            // Find best individual
            let best = population[0];
            let bestFitness = getFitness(best.x, best.y);
            population.forEach(p => {
                const f = getFitness(p.x, p.y);
                if (f > bestFitness) {
                    bestFitness = f;
                    best = p;
                }
            });

            // Draw all agents
            population.forEach(agent => {
                const px = agent.x * cellSize + cellSize / 2;
                const py = agent.y * cellSize + cellSize / 2;

                ctx.beginPath();
                ctx.arc(px, py, Math.max(3, cellSize / 2), 0, Math.PI * 2);

                if (agent === best) {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 5;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        // Update stats display
        function updateStats() {
            const fitnesses = population.map(p => getFitness(p.x, p.y));
            const best = Math.max(...fitnesses);
            const avg = fitnesses.reduce((a, b) => a + b, 0) / fitnesses.length;

            document.getElementById('genStat').textContent = generation;
            document.getElementById('bestStat').textContent = best.toFixed(3);
            document.getElementById('avgStat').textContent = avg.toFixed(3);
            document.getElementById('peaksStat').textContent = peaksFound.size;
            document.getElementById('valleyStat').textContent = valleyCrossings;
        }

        // Main simulation loop
        function simulate() {
            if (!running) return;

            // Adaptive walks for all agents
            population.forEach(agent => adaptiveWalk(agent));

            // Selection every 10 generations
            if (generation % 10 === 0) {
                selection();
            }

            generation++;

            // Draw
            drawLandscape();
            drawPopulation();
            updateStats();

            animationId = requestAnimationFrame(simulate);
        }

        // Control handlers
        document.getElementById('ruggedness').addEventListener('input', (e) => {
            ruggedness = parseInt(e.target.value);
            document.getElementById('ruggedVal').textContent = ruggedness;
        });

        document.getElementById('popSize').addEventListener('input', (e) => {
            populationSize = parseInt(e.target.value);
            document.getElementById('popVal').textContent = populationSize;
        });

        document.getElementById('mutRate').addEventListener('input', (e) => {
            mutationRate = parseFloat(e.target.value);
            document.getElementById('mutVal').textContent = mutationRate.toFixed(2);
        });

        document.getElementById('drift').addEventListener('input', (e) => {
            driftStrength = parseFloat(e.target.value);
            document.getElementById('driftVal').textContent = driftStrength.toFixed(2);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Resume';
            if (running) simulate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            if (animationId) cancelAnimationFrame(animationId);
            generation = 0;
            peaksFound.clear();
            valleyCrossings = 0;
            initPopulation();
            drawLandscape();
            drawPopulation();
            updateStats();
            document.getElementById('startBtn').textContent = 'Start Simulation';
        });

        document.getElementById('newLandscape').addEventListener('click', () => {
            running = false;
            if (animationId) cancelAnimationFrame(animationId);
            generation = 0;
            peaksFound.clear();
            valleyCrossings = 0;
            generateNKLandscape();
            initPopulation();
            drawLandscape();
            drawPopulation();
            updateStats();
            document.getElementById('startBtn').textContent = 'Start Simulation';
        });

        // Initialize
        generateNKLandscape();
        initPopulation();
        drawLandscape();
        drawPopulation();
        updateStats();
    

    // Modal functionality
    const modal = document.getElementById('explainModal');
    if (modal) {
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                modal.classList.remove('active');
            }
        });
    }

    </script>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Fitness Landscape Navigation</h2>
            <div class="modal-body">
                <p>This agent-based simulation explores concepts from <strong>evolutionary biology and population genetics</strong>.</p>

                <h3>What This Simulation Models</h3>
                <p>Implement agents traversing rugged fitness landscapes with multiple peaks. Model adaptive walks, valley crossing via drift, and evolutionary dead ends.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Agent-Based Modeling:</strong> Individual agents follow simple rules, producing complex emergent behaviors</li>
                    <li><strong>Emergent Properties:</strong> System-level patterns arise from local interactions</li>
                    <li><strong>Parameter Exploration:</strong> Adjust controls to explore different scenarios and outcomes</li>
                </ul>

                <h3>How to Explore</h3>
                <ul>
                    <li>Use the sliders to modify simulation parameters</li>
                    <li>Observe how changes affect the overall system behavior</li>
                    <li>Look for phase transitions and tipping points</li>
                    <li>Consider what real-world phenomena this model might represent</li>
                </ul>

                <h3>Category: Evolutionary Dynamics</h3>
                <p>This simulation is part of the <em>Evolutionary Dynamics</em> collection, which explores various aspects of evolutionary biology and population genetics.</p>
            </div>
        </div>
    </div>

</body>
</html>
