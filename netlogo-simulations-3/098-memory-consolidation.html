<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Consolidation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #818cf8; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #818cf8; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #818cf8; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #6366f1; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #818cf8; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #818cf8; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(129,140,248,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #818cf8; }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">‚Üê Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>üåô Memory Consolidation</h1>
            <p class="description">
                During sleep, memories transfer from hippocampus to cortex through
                replay. Sharp-wave ripples in hippocampus trigger cortical slow waves,
                gradually strengthening distributed memory traces.
            </p>

            <div class="control-group">
                <label>Replay Rate: <span class="value-display" id="replayValue">0.1</span></label>
                <input type="range" id="replaySlider" min="0.01" max="0.3" step="0.01" value="0.1">
            </div>

            <div class="control-group">
                <label>Transfer Rate: <span class="value-display" id="transferValue">0.05</span></label>
                <input type="range" id="transferSlider" min="0.01" max="0.2" step="0.01" value="0.05">
            </div>

            <div class="control-group">
                <label>Sleep State: <span class="value-display" id="stateValue">Awake</span></label>
                <input type="range" id="stateSlider" min="0" max="3" step="1" value="0">
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>
            <button id="learnBtn">Learn New Memory</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Hippocampal: <span id="hippoStrength">0</span>%</div>
                <div>Cortical: <span id="cortexStrength">0</span>%</div>
                <div>Consolidation: <span id="consolidated">0</span>%</div>
            </div>

            <div class="theory">
                <strong>Two-Stage Memory:</strong><br>
                ‚Ä¢ Hippocampus: Fast learning<br>
                ‚Ä¢ Cortex: Slow integration<br>
                ‚Ä¢ Sleep replay: Transfer mechanism<br>
                ‚Ä¢ SWS + REM cycles
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;

        let replayRate = 0.1;
        let transferRate = 0.05;
        let sleepState = 0; // 0=awake, 1=light, 2=SWS, 3=REM

        const SLEEP_STATES = ['Awake', 'Light Sleep', 'SWS', 'REM'];
        const N_HIPPO = 20;
        const N_CORTEX = 40;

        let hippoNeurons = [];
        let cortexNeurons = [];
        let memories = [];
        let hippoToCortex = [];
        let replayEvents = [];
        let sleepCycle = 0;
        let oscillations = { swr: 0, slowWave: 0, theta: 0 };

        class Memory {
            constructor(id) {
                this.id = id;
                this.hippoPattern = [];
                this.cortexPattern = [];
                this.hippoStrength = 1.0;
                this.cortexStrength = 0;
                this.age = 0;

                // Random patterns
                for (let i = 0; i < N_HIPPO; i++) {
                    this.hippoPattern.push(Math.random() > 0.7 ? 1 : 0);
                }
                for (let i = 0; i < N_CORTEX; i++) {
                    this.cortexPattern.push(Math.random() > 0.8 ? 1 : 0);
                }
            }
        }

        function initSimulation() {
            hippoNeurons = [];
            cortexNeurons = [];
            memories = [];
            hippoToCortex = [];
            replayEvents = [];

            for (let i = 0; i < N_HIPPO; i++) {
                hippoNeurons.push({ id: i, activation: 0 });
            }

            for (let i = 0; i < N_CORTEX; i++) {
                cortexNeurons.push({ id: i, activation: 0 });
            }

            // Initialize connection weights
            for (let i = 0; i < N_HIPPO; i++) {
                hippoToCortex[i] = [];
                for (let j = 0; j < N_CORTEX; j++) {
                    hippoToCortex[i][j] = Math.random() * 0.1;
                }
            }

            // Create initial memory
            memories.push(new Memory(0));
        }

        function update() {
            if (!running) return;

            generation++;

            // Update sleep cycle
            if (sleepState > 0) {
                sleepCycle += 0.01;

                // Automatic cycling through sleep stages
                if (sleepState === 2) { // SWS
                    oscillations.slowWave = 0.5 + 0.5 * Math.sin(sleepCycle * 0.5);
                    oscillations.swr = Math.random() > 0.95 ? 1 : oscillations.swr * 0.9;
                } else if (sleepState === 3) { // REM
                    oscillations.theta = 0.5 + 0.5 * Math.sin(sleepCycle * 2);
                    oscillations.swr = 0;
                }
            } else {
                oscillations.slowWave = 0;
                oscillations.swr = 0;
                oscillations.theta = 0;
            }

            // Memory replay during sleep
            if (sleepState >= 2 && Math.random() < replayRate) {
                replayMemory();
            }

            // Decay hippocampal activations
            hippoNeurons.forEach(n => {
                n.activation *= 0.9;
            });

            // Decay cortical activations
            cortexNeurons.forEach(n => {
                n.activation *= 0.95;
            });

            // Update memory consolidation
            memories.forEach(mem => {
                mem.age++;

                // During SWS, transfer from hippocampus to cortex
                if (sleepState === 2 && oscillations.swr > 0.5) {
                    const transfer = transferRate * oscillations.slowWave;
                    mem.cortexStrength += transfer * mem.hippoStrength;
                    mem.hippoStrength -= transfer * 0.1;

                    mem.cortexStrength = Math.min(1, mem.cortexStrength);
                    mem.hippoStrength = Math.max(0.1, mem.hippoStrength);
                }
            });

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function replayMemory() {
            if (memories.length === 0) return;

            const mem = memories[Math.floor(Math.random() * memories.length)];

            // Activate hippocampal pattern
            mem.hippoPattern.forEach((active, i) => {
                if (active) {
                    hippoNeurons[i].activation = 1;
                }
            });

            // Propagate to cortex
            for (let j = 0; j < N_CORTEX; j++) {
                let input = 0;
                for (let i = 0; i < N_HIPPO; i++) {
                    input += hippoNeurons[i].activation * hippoToCortex[i][j];
                }
                cortexNeurons[j].activation = Math.min(1, cortexNeurons[j].activation + input * 0.5);
            }

            // Strengthen connections
            for (let i = 0; i < N_HIPPO; i++) {
                for (let j = 0; j < N_CORTEX; j++) {
                    const delta = hippoNeurons[i].activation * cortexNeurons[j].activation * transferRate;
                    hippoToCortex[i][j] = Math.min(1, hippoToCortex[i][j] + delta);
                }
            }

            replayEvents.push({ time: generation, memory: mem.id });
            if (replayEvents.length > 50) replayEvents.shift();
        }

        function learnNewMemory() {
            const mem = new Memory(memories.length);
            memories.push(mem);

            // Activate pattern
            mem.hippoPattern.forEach((active, i) => {
                if (active) {
                    hippoNeurons[i].activation = 1;
                }
            });

            render();
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Memory Consolidation: Hippocampal-Cortical Transfer', 20, 25);

            // Sleep state indicator
            const stateColors = ['#4ade80', '#60a5fa', '#818cf8', '#f472b6'];
            ctx.fillStyle = stateColors[sleepState];
            ctx.font = '14px sans-serif';
            ctx.fillText(`State: ${SLEEP_STATES[sleepState]}`, 20, 50);

            drawBrainRegions();
            drawConnections();
            drawOscillations();
            drawMemoryTimeline();
        }

        function drawBrainRegions() {
            const hippoX = 100;
            const hippoY = 150;
            const cortexX = canvas.width * 0.5;
            const cortexY = 120;

            // Hippocampus label
            ctx.fillStyle = '#f59e0b';
            ctx.font = '12px sans-serif';
            ctx.fillText('Hippocampus', hippoX, hippoY - 50);
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('(Fast learning, temporary storage)', hippoX, hippoY - 35);

            // Draw hippocampal neurons
            const hippoRows = 4;
            const hippoCols = 5;
            for (let i = 0; i < N_HIPPO; i++) {
                const row = Math.floor(i / hippoCols);
                const col = i % hippoCols;
                const x = hippoX + col * 30;
                const y = hippoY + row * 30;

                const act = hippoNeurons[i].activation;
                ctx.fillStyle = `rgba(245, 158, 11, ${0.3 + act * 0.7})`;
                ctx.beginPath();
                ctx.arc(x, y, 10 + act * 5, 0, Math.PI * 2);
                ctx.fill();

                if (act > 0.5) {
                    ctx.fillStyle = `rgba(245, 158, 11, ${act * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Cortex label
            ctx.fillStyle = '#818cf8';
            ctx.font = '12px sans-serif';
            ctx.fillText('Neocortex', cortexX, cortexY - 50);
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('(Slow integration, permanent storage)', cortexX, cortexY - 35);

            // Draw cortical neurons
            const cortexRows = 5;
            const cortexCols = 8;
            for (let i = 0; i < N_CORTEX; i++) {
                const row = Math.floor(i / cortexCols);
                const col = i % cortexCols;
                const x = cortexX + col * 28;
                const y = cortexY + row * 28;

                const act = cortexNeurons[i].activation;
                ctx.fillStyle = `rgba(129, 140, 248, ${0.3 + act * 0.7})`;
                ctx.beginPath();
                ctx.arc(x, y, 8 + act * 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawConnections() {
            const hippoX = 100;
            const hippoY = 150;
            const cortexX = canvas.width * 0.5;
            const cortexY = 120;

            // Draw strongest connections during replay
            if (sleepState >= 2) {
                for (let i = 0; i < N_HIPPO; i++) {
                    for (let j = 0; j < N_CORTEX; j++) {
                        const w = hippoToCortex[i][j];
                        if (w > 0.3 && hippoNeurons[i].activation > 0.3) {
                            const hi = Math.floor(i / 5);
                            const hj = i % 5;
                            const ci = Math.floor(j / 8);
                            const cj = j % 8;

                            const x1 = hippoX + hj * 30;
                            const y1 = hippoY + hi * 30;
                            const x2 = cortexX + cj * 28;
                            const y2 = cortexY + ci * 28;

                            ctx.strokeStyle = `rgba(168, 85, 247, ${w * hippoNeurons[i].activation})`;
                            ctx.lineWidth = w * 2;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        function drawOscillations() {
            const oscX = 100;
            const oscY = canvas.height - 150;
            const oscW = canvas.width - 200;
            const oscH = 100;

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Neural Oscillations', oscX, oscY - 10);

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(oscX, oscY, oscW, oscH);

            const t = generation * 0.05;

            // Slow wave
            ctx.strokeStyle = '#818cf8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < oscW; x++) {
                const phase = (x / oscW) * 4 * Math.PI + t * 0.5;
                const y = oscY + 25 + Math.sin(phase) * 15 * oscillations.slowWave;
                if (x === 0) ctx.moveTo(oscX + x, y);
                else ctx.lineTo(oscX + x, y);
            }
            ctx.stroke();

            // Sharp-wave ripple
            ctx.strokeStyle = '#f59e0b';
            ctx.beginPath();
            for (let x = 0; x < oscW; x++) {
                const phase = (x / oscW) * 40 * Math.PI + t * 5;
                const y = oscY + 50 + Math.sin(phase) * 10 * oscillations.swr;
                if (x === 0) ctx.moveTo(oscX + x, y);
                else ctx.lineTo(oscX + x, y);
            }
            ctx.stroke();

            // Theta
            ctx.strokeStyle = '#34d399';
            ctx.beginPath();
            for (let x = 0; x < oscW; x++) {
                const phase = (x / oscW) * 8 * Math.PI + t * 2;
                const y = oscY + 75 + Math.sin(phase) * 12 * oscillations.theta;
                if (x === 0) ctx.moveTo(oscX + x, y);
                else ctx.lineTo(oscX + x, y);
            }
            ctx.stroke();

            // Labels
            ctx.font = '9px sans-serif';
            ctx.fillStyle = '#818cf8';
            ctx.fillText('Slow Wave (0.5-4Hz)', oscX + oscW + 10, oscY + 28);
            ctx.fillStyle = '#f59e0b';
            ctx.fillText('Sharp-Wave Ripple (150Hz)', oscX + oscW + 10, oscY + 53);
            ctx.fillStyle = '#34d399';
            ctx.fillText('Theta (4-8Hz)', oscX + oscW + 10, oscY + 78);
        }

        function drawMemoryTimeline() {
            const timeX = 100;
            const timeY = 320;
            const timeW = 300;

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Memory Traces', timeX, timeY - 10);

            memories.forEach((mem, i) => {
                const y = timeY + i * 40;

                // Background bar
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(timeX, y, timeW, 30);

                // Hippocampal strength
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(timeX, y, timeW * mem.hippoStrength * 0.5, 12);

                // Cortical strength
                ctx.fillStyle = '#818cf8';
                ctx.fillRect(timeX, y + 15, timeW * mem.cortexStrength * 0.5, 12);

                // Labels
                ctx.fillStyle = '#fff';
                ctx.font = '9px sans-serif';
                ctx.fillText(`Memory ${mem.id}`, timeX + timeW + 10, y + 20);
            });

            // Legend
            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(timeX, timeY + memories.length * 40 + 10, 10, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Hippocampal', timeX + 15, timeY + memories.length * 40 + 18);

            ctx.fillStyle = '#818cf8';
            ctx.fillRect(timeX + 100, timeY + memories.length * 40 + 10, 10, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Cortical', timeX + 115, timeY + memories.length * 40 + 18);
        }

        function updateStats() {
            const avgHippo = memories.reduce((s, m) => s + m.hippoStrength, 0) / memories.length;
            const avgCortex = memories.reduce((s, m) => s + m.cortexStrength, 0) / memories.length;
            const consolidated = memories.filter(m => m.cortexStrength > 0.5).length / memories.length;

            document.getElementById('generation').textContent = generation;
            document.getElementById('hippoStrength').textContent = (avgHippo * 100).toFixed(0);
            document.getElementById('cortexStrength').textContent = (avgCortex * 100).toFixed(0);
            document.getElementById('consolidated').textContent = (consolidated * 100).toFixed(0);
        }

        document.getElementById('replaySlider').addEventListener('input', (e) => {
            replayRate = parseFloat(e.target.value);
            document.getElementById('replayValue').textContent = replayRate.toFixed(2);
        });

        document.getElementById('transferSlider').addEventListener('input', (e) => {
            transferRate = parseFloat(e.target.value);
            document.getElementById('transferValue').textContent = transferRate.toFixed(2);
        });

        document.getElementById('stateSlider').addEventListener('input', (e) => {
            sleepState = parseInt(e.target.value);
            document.getElementById('stateValue').textContent = SLEEP_STATES[sleepState];
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initSimulation();
            render();
            updateStats();
        });

        document.getElementById('learnBtn').addEventListener('click', () => {
            learnNewMemory();
        });

        initSimulation();
        render();
        updateStats();
    </script>
</body>
</html>
