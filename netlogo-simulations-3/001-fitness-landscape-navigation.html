<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fitness Landscape Navigation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            display: block;
        }
        #controls {
            width: 300px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            overflow-y: auto;
        }
        h1 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #10b981;
        }
        .description {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            font-size: 0.8rem;
            margin-bottom: 5px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            font-size: 0.75rem;
            color: #10b981;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #10b981;
            color: #1a1a2e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #059669;
        }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-top: 15px;
        }
        .stats div {
            margin-bottom: 5px;
        }
        .stats span {
            color: #10b981;
        }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            color: #10b981;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover {
            background: rgba(16,185,129,0.2);
        }
        .legend {
            margin-top: 15px;
            font-size: 0.75rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }
        .theory {
            background: rgba(16,185,129,0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.7rem;
            margin-top: 15px;
            border-left: 3px solid #10b981;
        }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 40px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #fbbf24;
        }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">‚Üê Back to Simulations</a>

    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>üèîÔ∏è Fitness Landscape Navigation</h1>
            <p class="description">
                Agents traverse rugged NK fitness landscapes, performing adaptive walks
                toward local fitness peaks. Watch how landscape ruggedness (K) affects
                evolutionary outcomes.
            </p>

            <div class="control-group">
                <label>Landscape Ruggedness (K): <span class="value-display" id="kValue">3</span></label>
                <input type="range" id="kSlider" min="0" max="8" value="3">
                <div style="font-size: 0.65rem; color: #666;">K=0: Smooth (single peak) | K=8: Maximum ruggedness</div>
            </div>

            <div class="control-group">
                <label>Population Size: <span class="value-display" id="popValue">20</span></label>
                <input type="range" id="popSlider" min="5" max="100" value="20">
            </div>

            <div class="control-group">
                <label>Mutation Rate: <span class="value-display" id="mutValue">0.1</span></label>
                <input type="range" id="mutSlider" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>

            <div class="control-group">
                <label>Drift Probability: <span class="value-display" id="driftValue">0.05</span></label>
                <input type="range" id="driftSlider" min="0" max="0.3" step="0.01" value="0.05">
                <div style="font-size: 0.65rem; color: #666;">Allows escape from local peaks</div>
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>
            <button id="newLandscape">New Landscape</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Avg Fitness: <span id="avgFitness">0.00</span></div>
                <div>Max Fitness: <span id="maxFitness">0.00</span></div>
                <div>Global Peak: <span id="globalPeak">0.00</span></div>
                <div>At Local Peaks: <span id="atPeaks">0</span></div>
                <div>Valley Crossings: <span id="valleyCrossings">0</span></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #10b981;"></div>
                    <span>Agents (circles)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fbbf24;"></div>
                    <span>Local Peaks</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Global Maximum</span>
                </div>
            </div>

            <div class="theory">
                <strong>NK Model:</strong> N=genome length, K=epistatic interactions per gene.
                Higher K creates more local peaks, making it harder for adaptive walks to
                reach the global optimum. Drift allows populations to escape local peaks
                by accepting temporarily lower fitness.
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Size constants
        const GRID_SIZE = 64; // NK landscape resolution
        const CELL_SIZE = 8;

        canvas.width = GRID_SIZE * CELL_SIZE;
        canvas.height = GRID_SIZE * CELL_SIZE;

        // Simulation state
        let running = false;
        let generation = 0;
        let valleyCrossings = 0;
        let landscape = [];
        let agents = [];
        let localPeaks = [];
        let globalPeak = { x: 0, y: 0, fitness: 0 };

        // Parameters
        let K = 3;
        let popSize = 20;
        let mutRate = 0.1;
        let driftProb = 0.05;

        // Color palette for fitness landscape
        function fitnessToColor(fitness) {
            // Deep blue (low) to green to yellow to red (high)
            const h = (1 - fitness) * 240; // 240 (blue) to 0 (red)
            const s = 70 + fitness * 30;
            const l = 20 + fitness * 40;
            return `hsl(${h}, ${s}%, ${l}%)`;
        }

        // Generate NK-style fitness landscape
        function generateLandscape() {
            landscape = [];
            localPeaks = [];
            globalPeak = { x: 0, y: 0, fitness: 0 };

            // Generate base noise at multiple scales for NK-like ruggedness
            const noiseScale = Math.pow(2, K / 2);

            for (let y = 0; y < GRID_SIZE; y++) {
                landscape[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    let fitness = 0;
                    let amplitude = 1;
                    let totalAmplitude = 0;

                    // Multiple octaves of noise for ruggedness
                    for (let octave = 0; octave <= K; octave++) {
                        const freq = Math.pow(2, octave) * 0.1;
                        const nx = x * freq / GRID_SIZE;
                        const ny = y * freq / GRID_SIZE;
                        fitness += amplitude * pseudoNoise(nx, ny, octave);
                        totalAmplitude += amplitude;
                        amplitude *= 0.5;
                    }

                    fitness = (fitness / totalAmplitude + 1) / 2;
                    fitness = Math.pow(fitness, 0.8); // Adjust distribution
                    landscape[y][x] = Math.max(0, Math.min(1, fitness));

                    if (landscape[y][x] > globalPeak.fitness) {
                        globalPeak = { x, y, fitness: landscape[y][x] };
                    }
                }
            }

            // Find local peaks
            findLocalPeaks();
        }

        // Simple pseudo-noise function
        function pseudoNoise(x, y, seed) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed * 43758.5453) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }

        // Find all local peaks in landscape
        function findLocalPeaks() {
            localPeaks = [];
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    const val = landscape[y][x];
                    let isPeak = true;

                    // Check all 8 neighbors
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            if (landscape[y + dy][x + dx] >= val) {
                                isPeak = false;
                                break;
                            }
                        }
                        if (!isPeak) break;
                    }

                    if (isPeak) {
                        localPeaks.push({ x, y, fitness: val });
                    }
                }
            }
        }

        // Initialize agents
        function initAgents() {
            agents = [];
            for (let i = 0; i < popSize; i++) {
                agents.push({
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE),
                    trail: [],
                    atPeak: false
                });
            }
        }

        // Get fitness at position
        function getFitness(x, y) {
            x = Math.max(0, Math.min(GRID_SIZE - 1, Math.floor(x)));
            y = Math.max(0, Math.min(GRID_SIZE - 1, Math.floor(y)));
            return landscape[y][x];
        }

        // Check if position is a local peak
        function isLocalPeak(x, y) {
            const val = getFitness(x, y);
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        if (getFitness(nx, ny) > val) return false;
                    }
                }
            }
            return true;
        }

        // Perform one step of adaptive walk for an agent
        function stepAgent(agent) {
            const currentFitness = getFitness(agent.x, agent.y);
            agent.atPeak = isLocalPeak(agent.x, agent.y);

            // Store trail
            if (agent.trail.length > 50) agent.trail.shift();
            agent.trail.push({ x: agent.x, y: agent.y });

            // Decide whether to mutate
            if (Math.random() > mutRate) return;

            // Find best neighboring position (greedy adaptive walk)
            let bestX = agent.x;
            let bestY = agent.y;
            let bestFitness = currentFitness;

            // Try random mutation directions
            const dx = Math.floor(Math.random() * 3) - 1;
            const dy = Math.floor(Math.random() * 3) - 1;
            const nx = Math.max(0, Math.min(GRID_SIZE - 1, agent.x + dx));
            const ny = Math.max(0, Math.min(GRID_SIZE - 1, agent.y + dy));
            const newFitness = getFitness(nx, ny);

            // Accept if better, or with drift probability if worse
            if (newFitness > currentFitness) {
                agent.x = nx;
                agent.y = ny;
            } else if (Math.random() < driftProb) {
                // Drift: accept worse fitness (valley crossing)
                agent.x = nx;
                agent.y = ny;
                if (newFitness < currentFitness) {
                    valleyCrossings++;
                }
            }
        }

        // Update simulation
        function update() {
            if (!running) return;

            generation++;

            for (const agent of agents) {
                stepAgent(agent);
            }

            render();
            updateStats();

            requestAnimationFrame(update);
        }

        // Render landscape and agents
        function render() {
            // Draw fitness landscape
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctx.fillStyle = fitnessToColor(landscape[y][x]);
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // Draw local peaks
            ctx.fillStyle = '#fbbf24';
            for (const peak of localPeaks) {
                ctx.beginPath();
                ctx.arc(
                    peak.x * CELL_SIZE + CELL_SIZE / 2,
                    peak.y * CELL_SIZE + CELL_SIZE / 2,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            }

            // Draw global peak
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(
                globalPeak.x * CELL_SIZE + CELL_SIZE / 2,
                globalPeak.y * CELL_SIZE + CELL_SIZE / 2,
                6, 0, Math.PI * 2
            );
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw agent trails
            for (const agent of agents) {
                if (agent.trail.length > 1) {
                    ctx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(
                        agent.trail[0].x * CELL_SIZE + CELL_SIZE / 2,
                        agent.trail[0].y * CELL_SIZE + CELL_SIZE / 2
                    );
                    for (let i = 1; i < agent.trail.length; i++) {
                        ctx.lineTo(
                            agent.trail[i].x * CELL_SIZE + CELL_SIZE / 2,
                            agent.trail[i].y * CELL_SIZE + CELL_SIZE / 2
                        );
                    }
                    ctx.stroke();
                }
            }

            // Draw agents
            for (const agent of agents) {
                ctx.fillStyle = agent.atPeak ? '#fff' : '#10b981';
                ctx.strokeStyle = agent.atPeak ? '#fbbf24' : '#064e3b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(
                    agent.x * CELL_SIZE + CELL_SIZE / 2,
                    agent.y * CELL_SIZE + CELL_SIZE / 2,
                    5, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.stroke();
            }
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('generation').textContent = generation;

            const fitnesses = agents.map(a => getFitness(a.x, a.y));
            const avgFit = fitnesses.reduce((a, b) => a + b, 0) / fitnesses.length;
            const maxFit = Math.max(...fitnesses);
            const atPeaksCount = agents.filter(a => a.atPeak).length;

            document.getElementById('avgFitness').textContent = avgFit.toFixed(3);
            document.getElementById('maxFitness').textContent = maxFit.toFixed(3);
            document.getElementById('globalPeak').textContent = globalPeak.fitness.toFixed(3);
            document.getElementById('atPeaks').textContent = atPeaksCount;
            document.getElementById('valleyCrossings').textContent = valleyCrossings;
        }

        // Event listeners
        document.getElementById('kSlider').addEventListener('input', (e) => {
            K = parseInt(e.target.value);
            document.getElementById('kValue').textContent = K;
        });

        document.getElementById('popSlider').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
        });

        document.getElementById('mutSlider').addEventListener('input', (e) => {
            mutRate = parseFloat(e.target.value);
            document.getElementById('mutValue').textContent = mutRate.toFixed(2);
        });

        document.getElementById('driftSlider').addEventListener('input', (e) => {
            driftProb = parseFloat(e.target.value);
            document.getElementById('driftValue').textContent = driftProb.toFixed(2);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            valleyCrossings = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initAgents();
            render();
            updateStats();
        });

        document.getElementById('newLandscape').addEventListener('click', () => {
            running = false;
            generation = 0;
            valleyCrossings = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            generateLandscape();
            initAgents();
            render();
            updateStats();
        });

        // Initialize
        generateLandscape();
        initAgents();
        render();
        updateStats();
    

    // Modal functionality
    const modal = document.getElementById('explainModal');
    if (modal) {
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                modal.classList.remove('active');
            }
        });
    }

    </script>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Fitness Landscape Navigation</h2>
            <div class="modal-body">
                <p>This agent-based simulation explores concepts from <strong>evolutionary biology and population genetics</strong>.</p>

                <h3>What This Simulation Models</h3>
                <p>Implement agents traversing rugged fitness landscapes with multiple peaks. Model adaptive walks, valley crossing via drift, and evolutionary dead ends.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Agent-Based Modeling:</strong> Individual agents follow simple rules, producing complex emergent behaviors</li>
                    <li><strong>Emergent Properties:</strong> System-level patterns arise from local interactions</li>
                    <li><strong>Parameter Exploration:</strong> Adjust controls to explore different scenarios and outcomes</li>
                </ul>

                <h3>How to Explore</h3>
                <ul>
                    <li>Use the sliders to modify simulation parameters</li>
                    <li>Observe how changes affect the overall system behavior</li>
                    <li>Look for phase transitions and tipping points</li>
                    <li>Consider what real-world phenomena this model might represent</li>
                </ul>

                <h3>Category: Evolutionary Dynamics</h3>
                <p>This simulation is part of the <em>Evolutionary Dynamics</em> collection, which explores various aspects of evolutionary biology and population genetics.</p>
            </div>
        </div>
    </div>

</body>
</html>
