<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Making - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #a78bfa; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #a78bfa; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #a78bfa; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #8b5cf6; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #a78bfa; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #a78bfa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(167,139,250,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #a78bfa; }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">← Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>⚖️ Decision Making</h1>
            <p class="description">
                The drift-diffusion model explains perceptual decisions as noisy
                evidence accumulation toward a threshold. Watch how evidence
                builds over time until a decision boundary is reached.
            </p>

            <div class="control-group">
                <label>Drift Rate (evidence strength): <span class="value-display" id="driftValue">0.5</span></label>
                <input type="range" id="driftSlider" min="-1" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Noise (σ): <span class="value-display" id="noiseValue">0.3</span></label>
                <input type="range" id="noiseSlider" min="0.1" max="1.0" step="0.05" value="0.3">
            </div>

            <div class="control-group">
                <label>Threshold: <span class="value-display" id="thresholdValue">1.0</span></label>
                <input type="range" id="thresholdSlider" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>
            <button id="trialBtn">New Trial</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Current Evidence: <span id="evidence">0.00</span></div>
                <div>Decision: <span id="decision">Undecided</span></div>
                <div>Mean RT: <span id="meanRT">-</span> steps</div>
            </div>

            <div class="theory">
                <strong>Drift-Diffusion Model:</strong><br>
                • dx = v·dt + σ·dW<br>
                • v = drift rate (signal)<br>
                • σ = noise (diffusion)<br>
                • Speed-accuracy tradeoff
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;

        let driftRate = 0.5;
        let noise = 0.3;
        let threshold = 1.0;

        let evidence = 0;
        let evidenceHistory = [];
        let trialHistory = [];
        let currentDecision = null;
        let reactionTime = 0;

        function initSimulation() {
            evidence = 0;
            evidenceHistory = [];
            trialHistory = [];
            currentDecision = null;
            reactionTime = 0;
        }

        function newTrial() {
            evidence = 0;
            evidenceHistory = [{ time: 0, value: 0 }];
            currentDecision = null;
            reactionTime = 0;
        }

        function update() {
            if (!running) return;

            generation++;

            if (currentDecision === null) {
                // Accumulate evidence (drift-diffusion)
                const drift = driftRate * 0.02;
                const diffusion = noise * (Math.random() - 0.5) * 0.2;

                evidence += drift + diffusion;

                evidenceHistory.push({ time: generation, value: evidence });
                if (evidenceHistory.length > 500) {
                    evidenceHistory = evidenceHistory.slice(-500);
                }

                // Check thresholds
                if (evidence >= threshold) {
                    currentDecision = 'A';
                    reactionTime = generation;
                    trialHistory.push({
                        decision: 'A',
                        rt: reactionTime,
                        correct: driftRate >= 0
                    });
                } else if (evidence <= -threshold) {
                    currentDecision = 'B';
                    reactionTime = generation;
                    trialHistory.push({
                        decision: 'B',
                        rt: reactionTime,
                        correct: driftRate < 0
                    });
                }
            }

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Drift-Diffusion Model: Perceptual Decision Making', 20, 25);

            drawEvidenceAccumulation();
            drawRTDistribution();
            drawSpeedAccuracyTradeoff();
            drawTrialIndicator();
        }

        function drawEvidenceAccumulation() {
            const graphX = 50;
            const graphY = 80;
            const graphW = canvas.width * 0.5;
            const graphH = canvas.height * 0.4;

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(graphX, graphY, graphW, graphH);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Evidence Accumulation Over Time', graphX + 5, graphY - 5);

            const centerY = graphY + graphH / 2;

            // Draw threshold lines
            const upperThreshY = centerY - (threshold / 2) * graphH;
            const lowerThreshY = centerY + (threshold / 2) * graphH;

            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(graphX, upperThreshY);
            ctx.lineTo(graphX + graphW, upperThreshY);
            ctx.stroke();

            ctx.strokeStyle = '#f87171';
            ctx.beginPath();
            ctx.moveTo(graphX, lowerThreshY);
            ctx.lineTo(graphX + graphW, lowerThreshY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#4ade80';
            ctx.fillText('Choice A threshold', graphX + graphW - 100, upperThreshY - 5);
            ctx.fillStyle = '#f87171';
            ctx.fillText('Choice B threshold', graphX + graphW - 100, lowerThreshY + 12);

            // Zero line
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(graphX, centerY);
            ctx.lineTo(graphX + graphW, centerY);
            ctx.stroke();

            // Draw evidence trajectory
            if (evidenceHistory.length > 1) {
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 2;
                ctx.beginPath();

                const minTime = evidenceHistory[0].time;
                const maxTime = evidenceHistory[evidenceHistory.length - 1].time;
                const timeRange = Math.max(maxTime - minTime, 100);

                evidenceHistory.forEach((point, i) => {
                    const x = graphX + ((point.time - minTime) / timeRange) * graphW;
                    const y = centerY - (point.value / 2) * graphH;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Current position marker
                const lastPoint = evidenceHistory[evidenceHistory.length - 1];
                const lastX = graphX + ((lastPoint.time - minTime) / timeRange) * graphW;
                const lastY = centerY - (lastPoint.value / 2) * graphH;

                ctx.fillStyle = currentDecision ? (currentDecision === 'A' ? '#4ade80' : '#f87171') : '#a78bfa';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Y-axis labels
            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.fillText('+' + threshold.toFixed(1), graphX - 25, upperThreshY + 3);
            ctx.fillText('0', graphX - 15, centerY + 3);
            ctx.fillText('-' + threshold.toFixed(1), graphX - 25, lowerThreshY + 3);
        }

        function drawRTDistribution() {
            const graphX = canvas.width * 0.55;
            const graphY = 80;
            const graphW = canvas.width * 0.4;
            const graphH = canvas.height * 0.25;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(graphX, graphY, graphW, graphH);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Reaction Time Distribution', graphX + 5, graphY - 5);

            if (trialHistory.length < 3) {
                ctx.fillStyle = '#666';
                ctx.fillText('Run more trials...', graphX + graphW / 2 - 40, graphY + graphH / 2);
                return;
            }

            // Create histogram
            const rts = trialHistory.map(t => t.rt);
            const minRT = Math.min(...rts);
            const maxRT = Math.max(...rts);
            const binCount = 15;
            const binWidth = (maxRT - minRT) / binCount || 1;

            const bins = new Array(binCount).fill(0);
            rts.forEach(rt => {
                const binIdx = Math.min(Math.floor((rt - minRT) / binWidth), binCount - 1);
                bins[binIdx]++;
            });

            const maxCount = Math.max(...bins, 1);
            const barWidth = graphW / binCount;

            bins.forEach((count, i) => {
                const barHeight = (count / maxCount) * (graphH - 30);
                const x = graphX + i * barWidth;
                const y = graphY + graphH - barHeight - 10;

                ctx.fillStyle = '#a78bfa';
                ctx.fillRect(x + 1, y, barWidth - 2, barHeight);
            });

            // X-axis label
            ctx.fillStyle = '#888';
            ctx.fillText('Fast', graphX + 5, graphY + graphH + 12);
            ctx.fillText('Slow', graphX + graphW - 25, graphY + graphH + 12);
        }

        function drawSpeedAccuracyTradeoff() {
            const graphX = canvas.width * 0.55;
            const graphY = canvas.height * 0.45;
            const graphW = canvas.width * 0.4;
            const graphH = canvas.height * 0.25;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(graphX, graphY, graphW, graphH);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Speed-Accuracy Tradeoff', graphX + 5, graphY - 5);

            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(graphX + 30, graphY + graphH - 20);
            ctx.lineTo(graphX + graphW - 10, graphY + graphH - 20);
            ctx.moveTo(graphX + 30, graphY + graphH - 20);
            ctx.lineTo(graphX + 30, graphY + 20);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.fillText('Mean RT', graphX + graphW / 2, graphY + graphH - 3);
            ctx.save();
            ctx.translate(graphX + 12, graphY + graphH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Accuracy', 0, 0);
            ctx.restore();

            // Draw theoretical curve
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            for (let x = 0; x < graphW - 40; x++) {
                const rt = x / (graphW - 40);
                const acc = 0.5 + 0.5 * (1 - Math.exp(-rt * 3));
                const plotX = graphX + 30 + x;
                const plotY = graphY + graphH - 20 - acc * (graphH - 40);
                if (x === 0) ctx.moveTo(plotX, plotY);
                else ctx.lineTo(plotX, plotY);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Plot data points
            if (trialHistory.length >= 5) {
                const rts = trialHistory.map(t => t.rt);
                const meanRT = rts.reduce((a, b) => a + b, 0) / rts.length;
                const maxRT = Math.max(...rts);
                const accuracy = trialHistory.filter(t => t.correct).length / trialHistory.length;

                const plotX = graphX + 30 + (meanRT / maxRT) * (graphW - 40);
                const plotY = graphY + graphH - 20 - accuracy * (graphH - 40);

                ctx.fillStyle = '#a78bfa';
                ctx.beginPath();
                ctx.arc(plotX, plotY, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '9px sans-serif';
                ctx.fillText(`${(accuracy * 100).toFixed(0)}% acc`, plotX + 12, plotY + 4);
            }
        }

        function drawTrialIndicator() {
            const x = 50;
            const y = canvas.height * 0.75;

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Current Trial', x, y - 10);

            // Stimulus representation
            const stimX = x;
            const stimY = y + 20;
            const stimW = 200;

            // Background bar
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(stimX, stimY, stimW, 30);

            // Drift direction indicator
            const driftIndicator = stimX + stimW / 2 + (driftRate / 2) * stimW / 2;
            ctx.fillStyle = '#a78bfa';
            ctx.beginPath();
            ctx.moveTo(driftIndicator, stimY - 5);
            ctx.lineTo(driftIndicator - 8, stimY - 15);
            ctx.lineTo(driftIndicator + 8, stimY - 15);
            ctx.fill();

            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.fillText('B ←', stimX + 5, stimY + 20);
            ctx.fillText('→ A', stimX + stimW - 25, stimY + 20);
            ctx.fillStyle = '#a78bfa';
            ctx.fillText(`drift = ${driftRate.toFixed(1)}`, stimX + stimW / 2 - 25, stimY + 50);

            // Decision result
            if (currentDecision) {
                const decX = x + 250;
                ctx.fillStyle = currentDecision === 'A' ? '#4ade80' : '#f87171';
                ctx.font = 'bold 24px sans-serif';
                ctx.fillText(`Choice ${currentDecision}`, decX, stimY + 25);

                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#888';
                ctx.fillText(`RT: ${reactionTime} steps`, decX, stimY + 45);
            }

            // Trial summary
            const summX = x;
            const summY = canvas.height - 60;

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText(`Trials: ${trialHistory.length}`, summX, summY);

            if (trialHistory.length > 0) {
                const aChoices = trialHistory.filter(t => t.decision === 'A').length;
                const correct = trialHistory.filter(t => t.correct).length;

                ctx.fillText(`A choices: ${aChoices} (${(aChoices / trialHistory.length * 100).toFixed(0)}%)`, summX + 80, summY);
                ctx.fillText(`Correct: ${correct} (${(correct / trialHistory.length * 100).toFixed(0)}%)`, summX + 200, summY);
            }
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('evidence').textContent = evidence.toFixed(2);
            document.getElementById('decision').textContent = currentDecision || 'Accumulating...';

            if (trialHistory.length > 0) {
                const meanRT = trialHistory.reduce((s, t) => s + t.rt, 0) / trialHistory.length;
                document.getElementById('meanRT').textContent = meanRT.toFixed(0);
            }
        }

        document.getElementById('driftSlider').addEventListener('input', (e) => {
            driftRate = parseFloat(e.target.value);
            document.getElementById('driftValue').textContent = driftRate.toFixed(1);
        });

        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            noise = parseFloat(e.target.value);
            document.getElementById('noiseValue').textContent = noise.toFixed(2);
        });

        document.getElementById('thresholdSlider').addEventListener('input', (e) => {
            threshold = parseFloat(e.target.value);
            document.getElementById('thresholdValue').textContent = threshold.toFixed(1);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initSimulation();
            render();
            updateStats();
        });

        document.getElementById('trialBtn').addEventListener('click', () => {
            newTrial();
            render();
        });

        initSimulation();
        newTrial();
        render();
        updateStats();
    </script>
</body>
</html>
