<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ion Channel Dynamics - NetLogo Simulations III</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            background: rgba(0,0,0,0.3);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        h1 { color: #00d9ff; font-size: 1.5rem; }
        .back-link {
            color: #888;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .back-link:hover { color: #00d9ff; }
        .main-container {
            display: flex;
            flex: 1;
            gap: 1rem;
            padding: 1rem;
            overflow: hidden;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        #simCanvas {
            flex: 1;
            background: #0a0a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .controls-panel {
            width: 320px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .control-group { margin-bottom: 0.5rem; }
        .control-group label {
            display: block;
            margin-bottom: 0.3rem;
            color: #aaa;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #00d9ff;
        }
        .control-group .value {
            float: right;
            color: #00d9ff;
            font-weight: bold;
        }
        .btn {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #00d9ff;
            color: #000;
        }
        .btn-primary:hover { background: #00b8d9; }
        .btn-secondary {
            background: #444;
            color: #fff;
        }
        .btn-secondary:hover { background: #555; }
        .btn-depolarize {
            background: #ff4444;
            color: #fff;
        }
        .btn-depolarize:hover { background: #ff6666; }
        .btn-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .stats-panel {
            background: rgba(0,100,150,0.2);
            border: 1px solid #00d9ff44;
            border-radius: 5px;
            padding: 0.8rem;
        }
        .stats-panel h3 {
            color: #00d9ff;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin: 0.2rem 0;
        }
        .stat-value { color: #00d9ff; font-weight: bold; }
        .stat-value.na { color: #ff6644; }
        .stat-value.k { color: #44aaff; }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.75rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: #1a1a2e;
            padding: 2rem;
            border-radius: 10px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #00d9ff44;
        }
        .modal-content h2 {
            color: #00d9ff;
            margin-bottom: 1rem;
        }
        .modal-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .modal-content ul {
            margin: 1rem 0 1rem 1.5rem;
        }
        .modal-content li { margin: 0.5rem 0; }
        .close-modal {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .close-modal:hover { color: #fff; }
        .section-title {
            color: #00d9ff;
            font-size: 0.9rem;
            margin-top: 1rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid #333;
        }
        .chart-container {
            height: 80px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .chart-container canvas {
            width: 100%;
            height: 100%;
        }
        .gate-bar {
            height: 12px;
            background: #222;
            border-radius: 3px;
            margin: 3px 0;
            overflow: hidden;
        }
        .gate-fill {
            height: 100%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <header>
        <div>
            <a href="index.html" class="back-link">← Back to Gallery</a>
            <h1>201. Ion Channel Dynamics</h1>
        </div>
        <div class="btn-row">
            <button class="btn btn-secondary" onclick="showExplanation()">Explain</button>
        </div>
    </header>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>

        <div class="controls-panel">
            <div class="btn-row">
                <button class="btn btn-primary" id="playPauseBtn" onclick="toggleSimulation()">Pause</button>
                <button class="btn btn-secondary" onclick="resetSimulation()">Reset</button>
                <button class="btn btn-depolarize" onclick="applyVoltageStep()">Depolarize</button>
            </div>

            <div class="control-group">
                <label>Holding Potential <span class="value" id="holdingVal">-70 mV</span></label>
                <input type="range" id="holdingPotential" min="-90" max="-50" value="-70">
            </div>
            <div class="control-group">
                <label>Step Potential <span class="value" id="stepVal">+30 mV</span></label>
                <input type="range" id="stepPotential" min="-40" max="60" value="30">
            </div>
            <div class="control-group">
                <label>Temperature <span class="value" id="tempVal">22°C</span></label>
                <input type="range" id="temperature" min="10" max="37" value="22">
            </div>
            <div class="control-group">
                <label>Na⁺ Conductance <span class="value" id="gNaVal">100%</span></label>
                <input type="range" id="gNaMax" min="0" max="100" value="100">
            </div>
            <div class="control-group">
                <label>K⁺ Conductance <span class="value" id="gKVal">100%</span></label>
                <input type="range" id="gKMax" min="0" max="100" value="100">
            </div>

            <div class="section-title">Membrane Potential</div>
            <div class="chart-container">
                <canvas id="voltageChart"></canvas>
            </div>

            <div class="section-title">Na⁺ Channel (m³h)</div>
            <div class="stats-panel">
                <div class="stat-row">
                    <span>m (activation)</span>
                    <span class="stat-value na" id="mVal">0.00</span>
                </div>
                <div class="gate-bar"><div class="gate-fill" id="mBar" style="width: 0%; background: #ff6644;"></div></div>
                <div class="stat-row">
                    <span>h (inactivation)</span>
                    <span class="stat-value na" id="hVal">1.00</span>
                </div>
                <div class="gate-bar"><div class="gate-fill" id="hBar" style="width: 100%; background: #ff9966;"></div></div>
                <div class="stat-row">
                    <span>I_Na</span>
                    <span class="stat-value na" id="iNaVal">0 µA</span>
                </div>
            </div>

            <div class="section-title">K⁺ Channel (n⁴)</div>
            <div class="stats-panel">
                <div class="stat-row">
                    <span>n (activation)</span>
                    <span class="stat-value k" id="nVal">0.00</span>
                </div>
                <div class="gate-bar"><div class="gate-fill" id="nBar" style="width: 0%; background: #44aaff;"></div></div>
                <div class="stat-row">
                    <span>I_K</span>
                    <span class="stat-value k" id="iKVal">0 µA</span>
                </div>
            </div>

            <div class="stats-panel">
                <h3>Channel States</h3>
                <div class="stat-row">
                    <span>Na⁺ Open</span>
                    <span class="stat-value" id="naOpenCount">0</span>
                </div>
                <div class="stat-row">
                    <span>K⁺ Open</span>
                    <span class="stat-value" id="kOpenCount">0</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #ff6644;"></div> Na⁺ Channel</div>
                <div class="legend-item"><div class="legend-color" style="background: #44aaff;"></div> K⁺ Channel</div>
                <div class="legend-item"><div class="legend-color" style="background: #ffff00;"></div> Na⁺ Ion</div>
                <div class="legend-item"><div class="legend-color" style="background: #00ffff;"></div> K⁺ Ion</div>
                <div class="legend-item"><div class="legend-color" style="background: #00ff88;"></div> S4 Sensor</div>
            </div>
        </div>
    </div>

    <div class="modal" id="explanationModal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeExplanation()">&times;</span>
            <h2>Ion Channel Dynamics</h2>
            <p>
                This simulation models voltage-gated ion channels using the Hodgkin-Huxley formalism,
                demonstrating how activation and inactivation gates control ion flow in response to
                changes in membrane potential.
            </p>

            <h3>Hodgkin-Huxley Model</h3>
            <ul>
                <li><strong>Na⁺ Channels (m³h):</strong> Three rapid activation gates (m) and one slower inactivation gate (h)</li>
                <li><strong>K⁺ Channels (n⁴):</strong> Four identical activation gates (n), no inactivation</li>
                <li><strong>Gate Variables:</strong> Dimensionless probabilities (0-1) representing gate open probability</li>
            </ul>

            <h3>Activation vs Inactivation</h3>
            <ul>
                <li><strong>Activation Gates:</strong> Open probability increases with depolarization (fast)</li>
                <li><strong>Inactivation Gates:</strong> Open probability decreases with depolarization (slower)</li>
                <li><strong>Result:</strong> Na⁺ current is transient - channels activate then inactivate</li>
            </ul>

            <h3>Voltage Sensors (S4 Segments)</h3>
            <p>
                Each channel contains four voltage-sensing S4 segments, which are α-helices with
                positively charged residues. Upon depolarization, these segments move outward,
                triggering conformational changes that open the channel pore.
            </p>

            <h3>Gating Currents</h3>
            <p>
                The movement of S4 voltage sensors constitutes a small "gating current" that can be
                measured experimentally. This current precedes ion flow and reflects the charge
                movement within the membrane during gate transitions.
            </p>

            <h3>Rate Constants</h3>
            <p>
                The transition rates α (opening) and β (closing) are voltage-dependent functions
                that determine how quickly gates respond to voltage changes. Temperature affects
                these rates through Q₁₀ factors.
            </p>

            <h3>Channel States</h3>
            <ul>
                <li><strong>Closed:</strong> Activation gates closed, inactivation gate open (resting)</li>
                <li><strong>Open:</strong> All gates open (activated)</li>
                <li><strong>Inactivated:</strong> Inactivation gate closed (refractory)</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const voltageChart = document.getElementById('voltageChart');
        const chartCtx = voltageChart.getContext('2d');

        let running = true;
        let animationId = null;

        // Hodgkin-Huxley state variables
        let V = -70; // Membrane potential
        let m = 0.05; // Na activation
        let h = 0.6; // Na inactivation
        let n = 0.32; // K activation

        // Simulation parameters
        const E_Na = 55; // Sodium reversal potential
        const E_K = -77; // Potassium reversal potential
        const E_L = -54.4; // Leak reversal potential
        const g_Na_max = 120; // Max Na conductance
        const g_K_max = 36; // Max K conductance
        const g_L = 0.3; // Leak conductance
        const C_m = 1.0; // Membrane capacitance

        // Visual entities
        let naChannels = [];
        let kChannels = [];
        let ions = [];
        let voltageHistory = [];
        const maxHistory = 200;

        // Voltage step
        let voltageStepActive = false;
        let stepTimer = 0;

        function getParams() {
            return {
                holdingPotential: parseInt(document.getElementById('holdingPotential').value),
                stepPotential: parseInt(document.getElementById('stepPotential').value),
                temperature: parseInt(document.getElementById('temperature').value),
                gNaScale: parseInt(document.getElementById('gNaMax').value) / 100,
                gKScale: parseInt(document.getElementById('gKMax').value) / 100
            };
        }

        function updateSliderDisplay() {
            document.getElementById('holdingVal').textContent = document.getElementById('holdingPotential').value + ' mV';
            document.getElementById('stepVal').textContent = '+' + document.getElementById('stepPotential').value + ' mV';
            document.getElementById('tempVal').textContent = document.getElementById('temperature').value + '°C';
            document.getElementById('gNaVal').textContent = document.getElementById('gNaMax').value + '%';
            document.getElementById('gKVal').textContent = document.getElementById('gKMax').value + '%';
        }

        document.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', updateSliderDisplay);
        });

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            voltageChart.width = voltageChart.parentElement.clientWidth;
            voltageChart.height = voltageChart.parentElement.clientHeight;
        }

        // Hodgkin-Huxley rate functions
        function alpha_m(V) {
            return 0.1 * (V + 40) / (1 - Math.exp(-(V + 40) / 10));
        }

        function beta_m(V) {
            return 4 * Math.exp(-(V + 65) / 18);
        }

        function alpha_h(V) {
            return 0.07 * Math.exp(-(V + 65) / 20);
        }

        function beta_h(V) {
            return 1 / (1 + Math.exp(-(V + 35) / 10));
        }

        function alpha_n(V) {
            return 0.01 * (V + 55) / (1 - Math.exp(-(V + 55) / 10));
        }

        function beta_n(V) {
            return 0.125 * Math.exp(-(V + 65) / 80);
        }

        class IonChannel {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'Na' or 'K'
                this.gates = type === 'Na' ? [0, 0, 0, 1] : [0, 0, 0, 0]; // m1, m2, m3, h for Na; n1-n4 for K
                this.isOpen = false;
                this.s4Position = 0; // Voltage sensor position (0-1)
                this.poreRadius = 0;
            }

            update(V, params) {
                const tempFactor = Math.pow(3, (params.temperature - 22) / 10);

                if (this.type === 'Na') {
                    // Update m gates
                    for (let i = 0; i < 3; i++) {
                        const am = alpha_m(V) * tempFactor;
                        const bm = beta_m(V) * tempFactor;
                        if (Math.random() < am * 0.01) this.gates[i] = 1;
                        if (Math.random() < bm * 0.01) this.gates[i] = 0;
                    }
                    // Update h gate
                    const ah = alpha_h(V) * tempFactor;
                    const bh = beta_h(V) * tempFactor;
                    if (Math.random() < ah * 0.01) this.gates[3] = 1;
                    if (Math.random() < bh * 0.01) this.gates[3] = 0;

                    this.isOpen = this.gates[0] && this.gates[1] && this.gates[2] && this.gates[3];
                } else {
                    // Update n gates
                    for (let i = 0; i < 4; i++) {
                        const an = alpha_n(V) * tempFactor;
                        const bn = beta_n(V) * tempFactor;
                        if (Math.random() < an * 0.01) this.gates[i] = 1;
                        if (Math.random() < bn * 0.01) this.gates[i] = 0;
                    }

                    this.isOpen = this.gates[0] && this.gates[1] && this.gates[2] && this.gates[3];
                }

                // Update S4 voltage sensor position
                const targetS4 = (V + 70) / 100; // Normalize voltage to 0-1 range
                this.s4Position += (Math.max(0, Math.min(1, targetS4)) - this.s4Position) * 0.1;

                // Update pore radius
                this.poreRadius = this.isOpen ? 8 : 2;
            }
        }

        class Ion {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'Na' or 'K'
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 200;
            }
        }

        function initSimulation() {
            resizeCanvas();
            const params = getParams();
            V = params.holdingPotential;
            m = 0.05;
            h = 0.6;
            n = 0.32;
            voltageStepActive = false;
            stepTimer = 0;
            voltageHistory = [];

            naChannels = [];
            kChannels = [];
            ions = [];

            // Create Na channels
            const membraneY = canvas.height * 0.5;
            for (let i = 0; i < 8; i++) {
                const x = canvas.width * 0.15 + i * (canvas.width * 0.1);
                naChannels.push(new IonChannel(x, membraneY, 'Na'));
            }

            // Create K channels (interleaved)
            for (let i = 0; i < 7; i++) {
                const x = canvas.width * 0.2 + i * (canvas.width * 0.1);
                kChannels.push(new IonChannel(x, membraneY, 'K'));
            }

            // Create extracellular Na ions (above membrane)
            for (let i = 0; i < 40; i++) {
                ions.push(new Ion(
                    Math.random() * canvas.width,
                    Math.random() * (membraneY - 50),
                    'Na'
                ));
            }

            // Create intracellular K ions (below membrane)
            for (let i = 0; i < 40; i++) {
                ions.push(new Ion(
                    Math.random() * canvas.width,
                    membraneY + 50 + Math.random() * (canvas.height - membraneY - 100),
                    'K'
                ));
            }
        }

        function applyVoltageStep() {
            voltageStepActive = true;
            stepTimer = 300;
        }

        function update() {
            const params = getParams();
            const dt = 0.05;
            const tempFactor = Math.pow(3, (params.temperature - 22) / 10);

            // Determine target voltage
            let targetV = voltageStepActive ? params.stepPotential : params.holdingPotential;

            if (voltageStepActive) {
                stepTimer--;
                if (stepTimer <= 0) {
                    voltageStepActive = false;
                }
            }

            // Update HH gating variables
            const dm = (alpha_m(V) * (1 - m) - beta_m(V) * m) * dt * tempFactor;
            const dh = (alpha_h(V) * (1 - h) - beta_h(V) * h) * dt * tempFactor;
            const dn = (alpha_n(V) * (1 - n) - beta_n(V) * n) * dt * tempFactor;

            m = Math.max(0, Math.min(1, m + dm));
            h = Math.max(0, Math.min(1, h + dh));
            n = Math.max(0, Math.min(1, n + dn));

            // Calculate currents
            const g_Na = g_Na_max * Math.pow(m, 3) * h * params.gNaScale;
            const g_K = g_K_max * Math.pow(n, 4) * params.gKScale;

            const I_Na = g_Na * (V - E_Na);
            const I_K = g_K * (V - E_K);
            const I_L = g_L * (V - E_L);

            // Update voltage (with voltage clamp influence)
            const I_total = -(I_Na + I_K + I_L);
            const dV = I_total / C_m * dt;
            V = V * 0.95 + targetV * 0.05 + dV * 0.5;

            // Update channels
            for (const ch of naChannels) {
                ch.update(V, params);
            }
            for (const ch of kChannels) {
                ch.update(V, params);
            }

            // Update ions
            const membraneY = canvas.height * 0.5;
            for (let i = ions.length - 1; i >= 0; i--) {
                const ion = ions[i];

                // Random motion
                ion.vx += (Math.random() - 0.5) * 0.5;
                ion.vy += (Math.random() - 0.5) * 0.5;
                ion.vx *= 0.95;
                ion.vy *= 0.95;
                ion.x += ion.vx;
                ion.y += ion.vy;

                // Check for passage through channels
                if (ion.type === 'Na') {
                    for (const ch of naChannels) {
                        if (ch.isOpen && Math.abs(ion.x - ch.x) < 15 && Math.abs(ion.y - membraneY) < 30) {
                            // Na flows inward (down the gradient)
                            if (ion.y < membraneY) {
                                ion.vy += 2;
                            }
                        }
                    }
                } else {
                    for (const ch of kChannels) {
                        if (ch.isOpen && Math.abs(ion.x - ch.x) < 15 && Math.abs(ion.y - membraneY) < 30) {
                            // K flows outward
                            if (ion.y > membraneY) {
                                ion.vy -= 2;
                            }
                        }
                    }
                }

                // Boundary conditions
                if (ion.x < 10) ion.x = 10;
                if (ion.x > canvas.width - 10) ion.x = canvas.width - 10;
                if (ion.y < 10) ion.y = 10;
                if (ion.y > canvas.height - 10) ion.y = canvas.height - 10;

                ion.life--;
                if (ion.life <= 0) {
                    // Respawn
                    if (ion.type === 'Na') {
                        ion.y = Math.random() * (membraneY - 50);
                    } else {
                        ion.y = membraneY + 50 + Math.random() * (canvas.height - membraneY - 100);
                    }
                    ion.x = Math.random() * canvas.width;
                    ion.life = 200;
                }
            }

            // Store voltage history
            voltageHistory.push(V);
            if (voltageHistory.length > maxHistory) {
                voltageHistory.shift();
            }

            updateStats(I_Na, I_K);
        }

        function updateStats(I_Na, I_K) {
            document.getElementById('mVal').textContent = m.toFixed(3);
            document.getElementById('hVal').textContent = h.toFixed(3);
            document.getElementById('nVal').textContent = n.toFixed(3);

            document.getElementById('mBar').style.width = (m * 100) + '%';
            document.getElementById('hBar').style.width = (h * 100) + '%';
            document.getElementById('nBar').style.width = (n * 100) + '%';

            document.getElementById('iNaVal').textContent = I_Na.toFixed(1) + ' µA';
            document.getElementById('iKVal').textContent = I_K.toFixed(1) + ' µA';

            const naOpen = naChannels.filter(ch => ch.isOpen).length;
            const kOpen = kChannels.filter(ch => ch.isOpen).length;
            document.getElementById('naOpenCount').textContent = naOpen + '/' + naChannels.length;
            document.getElementById('kOpenCount').textContent = kOpen + '/' + kChannels.length;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const membraneY = canvas.height * 0.5;

            // Draw extracellular space
            const extraGrad = ctx.createLinearGradient(0, 0, 0, membraneY - 20);
            extraGrad.addColorStop(0, '#1a2a3a');
            extraGrad.addColorStop(1, '#2a3a4a');
            ctx.fillStyle = extraGrad;
            ctx.fillRect(0, 0, canvas.width, membraneY - 20);

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Extracellular [High Na⁺]', 10, 25);

            // Draw membrane
            ctx.fillStyle = '#554433';
            ctx.fillRect(0, membraneY - 20, canvas.width, 40);

            // Draw lipid bilayer
            ctx.strokeStyle = '#aa8866';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 6) {
                ctx.beginPath();
                ctx.arc(x, membraneY - 15, 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(x, membraneY + 15, 2, Math.PI, Math.PI * 2);
                ctx.stroke();
            }

            // Draw intracellular space
            const intraGrad = ctx.createLinearGradient(0, membraneY + 20, 0, canvas.height);
            intraGrad.addColorStop(0, '#2a3a4a');
            intraGrad.addColorStop(1, '#1a2a3a');
            ctx.fillStyle = intraGrad;
            ctx.fillRect(0, membraneY + 20, canvas.width, canvas.height - membraneY - 20);

            ctx.fillStyle = '#888';
            ctx.fillText('Intracellular [High K⁺]', 10, canvas.height - 15);

            // Draw channels
            for (const ch of naChannels) {
                drawChannel(ch, membraneY, '#ff6644', '#ff9966');
            }
            for (const ch of kChannels) {
                drawChannel(ch, membraneY, '#44aaff', '#88ccff');
            }

            // Draw ions
            for (const ion of ions) {
                ctx.beginPath();
                ctx.arc(ion.x, ion.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = ion.type === 'Na' ? '#ffff00' : '#00ffff';
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 6px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ion.type === 'Na' ? '+' : '+', ion.x, ion.y);
            }

            // Draw voltage indicator
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(`V = ${V.toFixed(1)} mV`, canvas.width - 15, 30);

            if (voltageStepActive) {
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText('DEPOLARIZING', canvas.width - 15, 50);
            }

            // Draw voltage chart
            drawVoltageChart();
        }

        function drawChannel(ch, membraneY, colorClosed, colorOpen) {
            ctx.save();
            ctx.translate(ch.x, membraneY);

            // Channel body (6 transmembrane segments simplified)
            const color = ch.isOpen ? colorOpen : colorClosed;

            // Draw S4 voltage sensors (green helices)
            for (let i = -1; i <= 1; i += 2) {
                const sensorY = -15 + ch.s4Position * 10;
                ctx.beginPath();
                ctx.rect(i * 12 - 3, sensorY, 6, 12);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                ctx.strokeStyle = '#ffffff44';
                ctx.stroke();

                // Draw + charges on S4
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('+', i * 12, sensorY + 6);
            }

            // Draw channel pore
            ctx.beginPath();
            ctx.moveTo(-10, -20);
            ctx.lineTo(-ch.poreRadius, -5);
            ctx.lineTo(-ch.poreRadius, 5);
            ctx.lineTo(-10, 20);
            ctx.lineTo(10, 20);
            ctx.lineTo(ch.poreRadius, 5);
            ctx.lineTo(ch.poreRadius, -5);
            ctx.lineTo(10, -20);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#ffffff44';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw gate indicators for Na channel
            if (ch.type === 'Na') {
                // m gates (activation)
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(-8 + i * 8, -25, 3, 0, Math.PI * 2);
                    ctx.fillStyle = ch.gates[i] ? '#ff6644' : '#444';
                    ctx.fill();
                }
                // h gate (inactivation)
                ctx.beginPath();
                ctx.arc(0, 25, 4, 0, Math.PI * 2);
                ctx.fillStyle = ch.gates[3] ? '#ff9966' : '#444';
                ctx.fill();
            } else {
                // n gates for K channel
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(-12 + i * 8, -25, 3, 0, Math.PI * 2);
                    ctx.fillStyle = ch.gates[i] ? '#44aaff' : '#444';
                    ctx.fill();
                }
            }

            // Channel label
            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(ch.type === 'Na' ? 'Na⁺' : 'K⁺', 0, 0);

            ctx.restore();
        }

        function drawVoltageChart() {
            chartCtx.clearRect(0, 0, voltageChart.width, voltageChart.height);

            if (voltageHistory.length < 2) return;

            const h = voltageChart.height;
            const w = voltageChart.width;
            const padding = 5;

            // Draw baseline (0 mV)
            const zeroY = h * 0.3;
            chartCtx.strokeStyle = '#444';
            chartCtx.lineWidth = 1;
            chartCtx.setLineDash([3, 3]);
            chartCtx.beginPath();
            chartCtx.moveTo(padding, zeroY);
            chartCtx.lineTo(w - padding, zeroY);
            chartCtx.stroke();
            chartCtx.setLineDash([]);

            // Draw voltage trace
            chartCtx.beginPath();
            chartCtx.strokeStyle = '#00ff88';
            chartCtx.lineWidth = 2;

            for (let i = 0; i < voltageHistory.length; i++) {
                const x = padding + (i / maxHistory) * (w - padding * 2);
                // Map voltage (-90 to +60) to canvas height
                const y = h - padding - ((voltageHistory[i] + 90) / 150) * (h - padding * 2);

                if (i === 0) chartCtx.moveTo(x, y);
                else chartCtx.lineTo(x, y);
            }
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#888';
            chartCtx.font = '9px sans-serif';
            chartCtx.textAlign = 'left';
            chartCtx.fillText('+60', 2, 12);
            chartCtx.fillText('-90', 2, h - 3);
        }

        function animate() {
            if (running) {
                update();
            }
            draw();
            animationId = requestAnimationFrame(animate);
        }

        function toggleSimulation() {
            running = !running;
            document.getElementById('playPauseBtn').textContent = running ? 'Pause' : 'Play';
        }

        function resetSimulation() {
            initSimulation();
        }

        function showExplanation() {
            document.getElementById('explanationModal').classList.add('active');
        }

        function closeExplanation() {
            document.getElementById('explanationModal').classList.remove('active');
        }

        window.addEventListener('resize', resizeCanvas);
        document.getElementById('explanationModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('explanationModal')) {
                closeExplanation();
            }
        });

        initSimulation();
        animate();
    </script>
</body>
</html>
