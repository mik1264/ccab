<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Episodic Memory - NetLogo Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #e67e22;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .simulation-area {
            background: #1e1e2e;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            background: #0a0a15;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .controls {
            background: #1e1e2e;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #e67e22;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e67e22;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            text-align: right;
            color: #e67e22;
            font-weight: bold;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        #startBtn {
            background: linear-gradient(135deg, #e67e22, #f39c12);
            color: white;
        }

        #resetBtn {
            background: linear-gradient(135deg, #444, #555);
            color: white;
        }

        #encodeBtn {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        #retrieveBtn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .stats {
            background: #252535;
            border-radius: 10px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #e67e22;
            font-weight: bold;
        }

        .memory-list {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
        }

        .memory-item {
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(230, 126, 34, 0.2);
            border-radius: 5px;
            font-size: 0.85em;
            border-left: 3px solid #e67e22;
        }

        .memory-item.fading {
            opacity: 0.5;
            border-left-color: #666;
        }

        .memory-item .time {
            color: #888;
            font-size: 0.8em;
        }

        .theory-box {
            background: linear-gradient(135deg, #252535, #2a2a3a);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #e67e22;
        }

        .theory-box h4 {
            color: #e67e22;
            margin-bottom: 10px;
        }

        .theory-box p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìî Episodic Memory</h1>
        <p class="subtitle">Event Encoding, Consolidation, and Retrieval</p>

        <div class="main-content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="simCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>üìù Memory Operations</h3>
                    <div class="button-group">
                        <button id="encodeBtn">Encode Event</button>
                        <button id="retrieveBtn">Retrieve Memory</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>‚öôÔ∏è Parameters</h3>
                    <div class="control-group">
                        <label>Encoding Strength</label>
                        <input type="range" id="encodingStrength" min="0.3" max="1" step="0.1" value="0.7">
                        <div class="value"><span id="encodingStrengthVal">0.7</span></div>
                    </div>
                    <div class="control-group">
                        <label>Decay Rate</label>
                        <input type="range" id="decayRate" min="0.001" max="0.01" step="0.001" value="0.003">
                        <div class="value"><span id="decayRateVal">0.003</span></div>
                    </div>
                    <div class="control-group">
                        <label>Consolidation Rate</label>
                        <input type="range" id="consolidationRate" min="0.01" max="0.1" step="0.01" value="0.05">
                        <div class="value"><span id="consolidationRateVal">0.05</span></div>
                    </div>
                    <div class="control-group">
                        <label>Interference</label>
                        <input type="range" id="interference" min="0" max="0.5" step="0.05" value="0.2">
                        <div class="value"><span id="interferenceVal">0.2</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üéÆ Controls</h3>
                    <div class="button-group">
                        <button id="startBtn">Start</button>
                        <button id="resetBtn">Reset</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìä Statistics</h3>
                    <div class="stats">
                        <div class="stat-row">
                            <span class="stat-label">Generation:</span>
                            <span class="stat-value" id="generation">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Memories Stored:</span>
                            <span class="stat-value" id="memoriesStored">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Consolidated:</span>
                            <span class="stat-value" id="consolidated">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Forgotten:</span>
                            <span class="stat-value" id="forgotten">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Retrievals:</span>
                            <span class="stat-value" id="retrievals">0</span>
                        </div>
                    </div>
                    <div class="memory-list" id="memoryList"></div>
                </div>

                <div class="theory-box">
                    <h4>üìö Tulving's Model</h4>
                    <p>
                        Episodic memory stores autobiographical events with
                        temporal-spatial context ("what-where-when"). Encoding
                        in hippocampus creates traces that consolidate to neocortex
                        during sleep. Retrieval cues reactivate stored patterns.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let running = false;
        let generation = 0;
        let simulatedTime = 0;

        // Memory system
        let memories = [];
        let forgottenCount = 0;
        let retrievalCount = 0;

        // Event types for generating random events
        const eventTypes = [
            { type: 'social', icon: 'üë•', examples: ['meeting friend', 'family dinner', 'party', 'conversation'] },
            { type: 'travel', icon: '‚úàÔ∏è', examples: ['beach trip', 'mountain hike', 'city visit', 'road trip'] },
            { type: 'achievement', icon: 'üèÜ', examples: ['graduation', 'promotion', 'winning game', 'completing project'] },
            { type: 'learning', icon: 'üìö', examples: ['new skill', 'reading book', 'workshop', 'lecture'] },
            { type: 'emotional', icon: '‚ù§Ô∏è', examples: ['first date', 'wedding', 'birth', 'reunion'] }
        ];

        const locations = ['home', 'park', 'office', 'restaurant', 'beach', 'school', 'city center'];

        // Brain regions for visualization
        const brainRegions = {
            hippocampus: { x: 0.5, y: 0.55, radius: 0.08, label: 'Hippocampus', color: '#e74c3c' },
            prefrontal: { x: 0.25, y: 0.3, radius: 0.1, label: 'Prefrontal Cortex', color: '#3498db' },
            temporal: { x: 0.7, y: 0.45, radius: 0.09, label: 'Temporal Lobe', color: '#27ae60' },
            parietal: { x: 0.5, y: 0.25, radius: 0.08, label: 'Parietal Cortex', color: '#9b59b6' },
            amygdala: { x: 0.45, y: 0.65, radius: 0.05, label: 'Amygdala', color: '#f39c12' }
        };

        // Parameters
        function getParams() {
            return {
                encodingStrength: parseFloat(document.getElementById('encodingStrength').value),
                decayRate: parseFloat(document.getElementById('decayRate').value),
                consolidationRate: parseFloat(document.getElementById('consolidationRate').value),
                interference: parseFloat(document.getElementById('interference').value)
            };
        }

        // Update parameter displays
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', (e) => {
                const valSpan = document.getElementById(e.target.id + 'Val');
                if (valSpan) {
                    valSpan.textContent = e.target.value;
                }
            });
        });

        // Generate random event
        function generateEvent() {
            const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
            const example = eventType.examples[Math.floor(Math.random() * eventType.examples.length)];
            const location = locations[Math.floor(Math.random() * locations.length)];

            return {
                type: eventType.type,
                icon: eventType.icon,
                description: example,
                location: location,
                timestamp: simulatedTime
            };
        }

        // Encode new memory
        document.getElementById('encodeBtn').addEventListener('click', () => {
            encodeMemory();
        });

        function encodeMemory() {
            const params = getParams();
            const event = generateEvent();

            const memory = {
                id: Date.now() + Math.random(),
                event: event,
                strength: params.encodingStrength,
                consolidation: 0, // 0 = hippocampal, 1 = neocortical
                emotionalSalience: Math.random() * 0.5 + 0.3,
                encodingTime: simulatedTime,
                lastRetrieval: simulatedTime,
                retrievalCount: 0,
                position: {
                    x: brainRegions.hippocampus.x + (Math.random() - 0.5) * 0.15,
                    y: brainRegions.hippocampus.y + (Math.random() - 0.5) * 0.1
                },
                particles: []
            };

            // Create encoding particles
            for (let i = 0; i < 10; i++) {
                memory.particles.push({
                    x: memory.position.x,
                    y: memory.position.y,
                    vx: (Math.random() - 0.5) * 0.01,
                    vy: (Math.random() - 0.5) * 0.01,
                    life: 1
                });
            }

            memories.push(memory);
        }

        // Retrieve memory
        document.getElementById('retrieveBtn').addEventListener('click', () => {
            if (memories.length > 0) {
                // Retrieve a random memory (weighted by strength)
                const totalStrength = memories.reduce((sum, m) => sum + m.strength, 0);
                let r = Math.random() * totalStrength;
                let selectedMemory = null;

                for (let memory of memories) {
                    r -= memory.strength;
                    if (r <= 0) {
                        selectedMemory = memory;
                        break;
                    }
                }

                if (selectedMemory) {
                    retrieveMemory(selectedMemory);
                }
            }
        });

        function retrieveMemory(memory) {
            memory.lastRetrieval = simulatedTime;
            memory.retrievalCount++;
            memory.strength = Math.min(1, memory.strength + 0.1); // Reconsolidation boost
            retrievalCount++;

            // Create retrieval particles
            for (let i = 0; i < 15; i++) {
                memory.particles.push({
                    x: memory.position.x,
                    y: memory.position.y,
                    vx: (Math.random() - 0.5) * 0.02,
                    vy: (Math.random() - 0.5) * 0.02,
                    life: 1,
                    retrieval: true
                });
            }
        }

        function update() {
            if (!running) return;

            generation++;
            simulatedTime += 100; // 100ms per frame in simulated time
            const params = getParams();

            // Update memories
            for (let i = memories.length - 1; i >= 0; i--) {
                const memory = memories[i];

                // Decay based on time since last retrieval
                const timeSinceRetrieval = simulatedTime - memory.lastRetrieval;
                const decayFactor = 1 - params.decayRate * (1 - memory.consolidation * 0.5);
                memory.strength *= decayFactor;

                // Consolidation (gradual transfer to neocortex)
                if (memory.consolidation < 1) {
                    memory.consolidation += params.consolidationRate * memory.strength * 0.01;
                    memory.consolidation = Math.min(1, memory.consolidation);

                    // Move position towards neocortical areas
                    if (memory.consolidation > 0.3) {
                        const targetX = 0.3 + Math.random() * 0.4;
                        const targetY = 0.3 + Math.random() * 0.15;
                        memory.position.x += (targetX - memory.position.x) * 0.001;
                        memory.position.y += (targetY - memory.position.y) * 0.001;
                    }
                }

                // Interference from new memories
                if (i > 0 && params.interference > 0) {
                    const newerMemories = memories.slice(i + 1);
                    for (let newer of newerMemories) {
                        if (newer.event.type === memory.event.type) {
                            memory.strength -= params.interference * 0.001;
                        }
                    }
                }

                // Update particles
                for (let j = memory.particles.length - 1; j >= 0; j--) {
                    const p = memory.particles[j];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.life -= 0.02;
                    if (p.life <= 0) {
                        memory.particles.splice(j, 1);
                    }
                }

                // Forget very weak memories
                if (memory.strength < 0.05) {
                    memories.splice(i, 1);
                    forgottenCount++;
                }
            }

            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, w, h);

            // Draw brain outline
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(w * 0.5, h * 0.45, w * 0.4, h * 0.35, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Draw brain regions
            for (let name in brainRegions) {
                const region = brainRegions[name];
                const x = w * region.x;
                const y = h * region.y;
                const r = w * region.radius;

                // Region area
                ctx.fillStyle = region.color + '20';
                ctx.beginPath();
                ctx.ellipse(x, y, r, r * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = region.color + '60';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = region.color;
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(region.label, x, y - r * 0.7 - 5);
            }

            // Draw memory connections (consolidation pathways)
            for (let memory of memories) {
                if (memory.consolidation > 0.1) {
                    const hippX = w * brainRegions.hippocampus.x;
                    const hippY = h * brainRegions.hippocampus.y;

                    ctx.strokeStyle = `rgba(230, 126, 34, ${memory.consolidation * 0.3})`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(hippX, hippY);
                    ctx.lineTo(w * memory.position.x, h * memory.position.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw memories
            for (let memory of memories) {
                const x = w * memory.position.x;
                const y = h * memory.position.y;

                // Memory glow based on strength
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 30 * memory.strength);
                gradient.addColorStop(0, `rgba(230, 126, 34, ${memory.strength * 0.5})`);
                gradient.addColorStop(1, 'rgba(230, 126, 34, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 30 * memory.strength, 0, Math.PI * 2);
                ctx.fill();

                // Memory node
                const size = 8 + memory.strength * 12;
                ctx.fillStyle = `rgba(230, 126, 34, ${0.3 + memory.strength * 0.7})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                // Consolidation ring
                if (memory.consolidation > 0) {
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, size + 5, 0, Math.PI * 2 * memory.consolidation);
                    ctx.stroke();
                }

                // Icon
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(memory.event.icon, x, y);

                // Draw particles
                for (let p of memory.particles) {
                    ctx.fillStyle = p.retrieval ?
                        `rgba(52, 152, 219, ${p.life})` :
                        `rgba(230, 126, 34, ${p.life})`;
                    ctx.beginPath();
                    ctx.arc(w * p.x, h * p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw timeline at bottom
            ctx.fillStyle = '#252535';
            ctx.fillRect(0, h - 50, w, 50);

            ctx.fillStyle = '#e67e22';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Memory Timeline', 10, h - 35);

            // Draw recent memories on timeline
            const timelineStart = Math.max(0, simulatedTime - 50000);
            const timelineWidth = w - 20;

            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(10, h - 15);
            ctx.lineTo(w - 10, h - 15);
            ctx.stroke();

            for (let memory of memories) {
                const relTime = memory.encodingTime - timelineStart;
                if (relTime >= 0) {
                    const x = 10 + (relTime / 50000) * timelineWidth;
                    ctx.fillStyle = `rgba(230, 126, 34, ${memory.strength})`;
                    ctx.beginPath();
                    ctx.arc(x, h - 15, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Stats panel
            ctx.fillStyle = 'rgba(30, 30, 50, 0.9)';
            ctx.beginPath();
            ctx.roundRect(w - 150, 10, 140, 100, 10);
            ctx.fill();

            ctx.fillStyle = '#e67e22';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Memory Stats', w - 140, 30);

            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText(`Active: ${memories.length}`, w - 140, 50);
            ctx.fillText(`Consolidated: ${memories.filter(m => m.consolidation > 0.8).length}`, w - 140, 65);
            ctx.fillText(`Avg Strength: ${memories.length > 0 ?
                (memories.reduce((s, m) => s + m.strength, 0) / memories.length).toFixed(2) : 0}`, w - 140, 80);
            ctx.fillText(`Time: ${(simulatedTime / 1000).toFixed(0)}s`, w - 140, 95);
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('memoriesStored').textContent = memories.length;
            document.getElementById('consolidated').textContent = memories.filter(m => m.consolidation > 0.8).length;
            document.getElementById('forgotten').textContent = forgottenCount;
            document.getElementById('retrievals').textContent = retrievalCount;

            // Update memory list
            const listEl = document.getElementById('memoryList');
            const sortedMemories = [...memories].sort((a, b) => b.strength - a.strength);
            listEl.innerHTML = sortedMemories.slice(0, 5).map(m => `
                <div class="memory-item ${m.strength < 0.3 ? 'fading' : ''}">
                    <div>${m.event.icon} ${m.event.description} @ ${m.event.location}</div>
                    <div class="time">Strength: ${(m.strength * 100).toFixed(0)}% | Cons: ${(m.consolidation * 100).toFixed(0)}%</div>
                </div>
            `).join('');
        }

        function reset() {
            running = false;
            generation = 0;
            simulatedTime = 0;
            memories = [];
            forgottenCount = 0;
            retrievalCount = 0;
            updateStats();
            draw();
            document.getElementById('startBtn').textContent = 'Start';
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        draw();
    </script>
</body>
</html>
