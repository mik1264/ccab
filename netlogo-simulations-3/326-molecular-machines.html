<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molecular Machines</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #673ab7; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 5px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #673ab7; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #673ab7; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Molecular Machines</h1>
            <p class="description">Molecular motors convert chemical energy (ATP) or light into directed mechanical motion. Examples include rotaxanes, catenanes, and natural motors like kinesin.</p>

            <div class="control-group">
                <label>Machine Type:</label>
                <select id="machineType">
                    <option value="rotor">Molecular Rotor</option>
                    <option value="walker">Molecular Walker</option>
                    <option value="shuttle">Molecular Shuttle</option>
                </select>
            </div>

            <div class="control-group">
                <label>Energy Input (ATP): <span id="atpVal">1.0</span></label>
                <input type="range" id="atp" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Load Force: <span id="loadVal">0.2</span></label>
                <input type="range" id="load" min="0" max="1.0" step="0.05" value="0.2">
            </div>

            <div class="control-group">
                <label>Temperature: <span id="tempVal">300</span> K</label>
                <input type="range" id="temperature" min="250" max="350" value="300">
            </div>

            <button id="reset">Reset</button>
            <button id="toggleRun">Run/Pause</button>

            <div class="stats">
                <div>Rotations/Steps: <span id="cycles">0</span></div>
                <div>Speed: <span id="speed">0</span> /s</div>
                <div>Work Done: <span id="work">0</span> pN·nm</div>
                <div>Efficiency: <span id="efficiency">0</span>%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let running = false;
        let time = 0;

        let machineType = 'rotor';
        let atpLevel = 1.0;
        let loadForce = 0.2;
        let temperature = 300;

        let machine = null;
        let totalCycles = 0;
        let totalWork = 0;

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            time = 0;
            totalCycles = 0;
            totalWork = 0;

            const centerX = (width - 320) / 2;
            const centerY = height / 2;

            if (machineType === 'rotor') {
                machine = {
                    x: centerX,
                    y: centerY,
                    angle: 0,
                    angularVelocity: 0,
                    state: 'waiting', // waiting, rotating
                    stateTime: 0
                };
            } else if (machineType === 'walker') {
                machine = {
                    x: 150,
                    y: centerY,
                    leftFoot: { x: 150, y: centerY + 40, attached: true },
                    rightFoot: { x: 180, y: centerY + 40, attached: false },
                    state: 'leftDown',
                    stepPhase: 0
                };
            } else if (machineType === 'shuttle') {
                machine = {
                    trackStart: 150,
                    trackEnd: width - 500,
                    ringX: 200,
                    ringVx: 0,
                    state: 'left'
                };
            }

            updateStats();
        }

        function step() {
            time += 0.02;
            const kT = 0.0257 * (temperature / 300); // Thermal energy

            if (machineType === 'rotor') {
                stepRotor(kT);
            } else if (machineType === 'walker') {
                stepWalker(kT);
            } else if (machineType === 'shuttle') {
                stepShuttle(kT);
            }

            updateStats();
        }

        function stepRotor(kT) {
            // F1-ATPase-like rotary motor
            machine.stateTime += 0.02;

            // ATP binding and hydrolysis drives rotation
            if (machine.state === 'waiting') {
                if (Math.random() < atpLevel * 0.05) {
                    machine.state = 'rotating';
                    machine.stateTime = 0;
                    // Power stroke
                    machine.angularVelocity = atpLevel * 2 - loadForce;
                }
            } else if (machine.state === 'rotating') {
                // Complete 120° rotation (3 strokes per full rotation)
                machine.angle += machine.angularVelocity * 0.1;

                // Thermal fluctuations
                machine.angularVelocity += (Math.random() - 0.5) * kT * 0.5;

                // Load-dependent slowdown
                machine.angularVelocity -= loadForce * 0.1;
                machine.angularVelocity *= 0.98;

                if (machine.stateTime > 0.5) {
                    machine.state = 'waiting';
                    totalCycles += 1/3; // 3 strokes per full rotation
                    totalWork += loadForce * 2 * Math.PI / 3 * 10; // Work in pN·nm
                }
            }
        }

        function stepWalker(kT) {
            // Kinesin-like walking motor
            const stepSize = 8; // nm
            const trackY = machine.y + 40;

            machine.stepPhase += atpLevel * 0.1;

            if (machine.stepPhase >= 1) {
                machine.stepPhase = 0;

                if (machine.state === 'leftDown') {
                    // Lift right foot and step forward
                    machine.rightFoot.attached = false;
                    machine.rightFoot.x = machine.leftFoot.x + stepSize * 2;
                    machine.state = 'rightSwing';
                } else if (machine.state === 'rightSwing') {
                    machine.rightFoot.attached = true;
                    machine.state = 'rightDown';
                    totalCycles++;
                    totalWork += loadForce * stepSize;
                } else if (machine.state === 'rightDown') {
                    machine.leftFoot.attached = false;
                    machine.leftFoot.x = machine.rightFoot.x + stepSize * 2;
                    machine.state = 'leftSwing';
                } else if (machine.state === 'leftSwing') {
                    machine.leftFoot.attached = true;
                    machine.state = 'leftDown';
                    totalCycles++;
                    totalWork += loadForce * stepSize;
                }
            }

            // Update walker position
            machine.x = (machine.leftFoot.x + machine.rightFoot.x) / 2;

            // Thermal wobble
            machine.y += (Math.random() - 0.5) * kT * 2;

            // Reset if at end
            if (machine.x > width - 500) {
                machine.x = 150;
                machine.leftFoot.x = 150;
                machine.rightFoot.x = 180;
            }
        }

        function stepShuttle(kT) {
            // Rotaxane molecular shuttle
            const midpoint = (machine.trackStart + machine.trackEnd) / 2;

            // Brownian motion
            machine.ringVx += (Math.random() - 0.5) * kT * 0.5;

            // Directed motion from chemical potential
            if (machine.state === 'left' && Math.random() < atpLevel * 0.01) {
                machine.state = 'right';
                machine.ringVx += 5;
            } else if (machine.state === 'right' && Math.random() < 0.005) {
                machine.state = 'left';
                machine.ringVx -= 5;
            }

            // Load resistance
            machine.ringVx -= loadForce * 0.1 * Math.sign(machine.ringVx);

            machine.ringVx *= 0.95;
            machine.ringX += machine.ringVx;

            // Boundaries (stoppers)
            if (machine.ringX < machine.trackStart + 30) {
                machine.ringX = machine.trackStart + 30;
                machine.ringVx *= -0.5;
            }
            if (machine.ringX > machine.trackEnd - 30) {
                machine.ringX = machine.trackEnd - 30;
                machine.ringVx *= -0.5;

                if (machine.state === 'right') {
                    totalCycles++;
                    totalWork += loadForce * (machine.trackEnd - machine.trackStart);
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            if (machineType === 'rotor') {
                drawRotor();
            } else if (machineType === 'walker') {
                drawWalker();
            } else if (machineType === 'shuttle') {
                drawShuttle();
            }

            // Legend and title
            ctx.fillStyle = '#673ab7';
            ctx.font = '14px sans-serif';
            ctx.fillText('Molecular Motor: ' + getMachineTitle(), 100, 50);

            ctx.fillStyle = '#aaa';
            ctx.font = '11px sans-serif';
            ctx.fillText('ATP → ADP + Pi + Work', 100, height - 20);
        }

        function getMachineTitle() {
            switch (machineType) {
                case 'rotor': return 'F1-ATPase Rotary Motor';
                case 'walker': return 'Kinesin Molecular Walker';
                case 'shuttle': return 'Rotaxane Shuttle';
            }
        }

        function drawRotor() {
            const cx = machine.x;
            const cy = machine.y;

            // Stator (fixed base)
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.arc(cx, cy, 80, 0, Math.PI * 2);
            ctx.fill();

            // Stator subunits (alpha/beta)
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                const color = i % 2 === 0 ? '#2196f3' : '#4caf50';
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(
                    cx + Math.cos(angle) * 55,
                    cy + Math.sin(angle) * 55,
                    20, 0, Math.PI * 2
                );
                ctx.fill();
            }

            // Central rotor (gamma subunit)
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(machine.angle);

            ctx.fillStyle = '#673ab7';
            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.lineTo(-15, 60);
            ctx.lineTo(15, 60);
            ctx.closePath();
            ctx.fill();

            // Asymmetric cam
            ctx.fillStyle = '#9c27b0';
            ctx.beginPath();
            ctx.arc(10, -30, 12, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // ATP indicator
            if (machine.state === 'rotating') {
                ctx.fillStyle = '#ffeb3b';
                ctx.font = '12px sans-serif';
                ctx.fillText('ATP → ADP', cx - 30, cy + 100);
            }

            // Direction arrow
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, 100, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(cx + 95, cy + 30);
            ctx.lineTo(cx + 105, cy);
            ctx.lineTo(cx + 95, cy - 10);
            ctx.fill();
        }

        function drawWalker() {
            const trackY = machine.y + 40;

            // Draw microtubule track
            ctx.fillStyle = '#444';
            ctx.fillRect(100, trackY - 5, width - 440, 10);

            // Track binding sites
            for (let x = 120; x < width - 420; x += 30) {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(x, trackY, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw kinesin
            // Body (cargo binding domain)
            ctx.fillStyle = '#673ab7';
            ctx.beginPath();
            ctx.arc(machine.x, machine.y - 30, 25, 0, Math.PI * 2);
            ctx.fill();

            // Neck linker
            ctx.strokeStyle = '#9c27b0';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(machine.x - 10, machine.y - 5);
            ctx.lineTo(machine.leftFoot.x, machine.leftFoot.y - 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(machine.x + 10, machine.y - 5);
            ctx.lineTo(machine.rightFoot.x, machine.rightFoot.y - 15);
            ctx.stroke();

            // Left foot (motor domain)
            ctx.fillStyle = machine.leftFoot.attached ? '#4caf50' : '#aaa';
            ctx.beginPath();
            ctx.arc(machine.leftFoot.x, machine.leftFoot.y, 12, 0, Math.PI * 2);
            ctx.fill();

            // Right foot
            ctx.fillStyle = machine.rightFoot.attached ? '#4caf50' : '#aaa';
            ctx.beginPath();
            ctx.arc(machine.rightFoot.x, machine.rightFoot.y, 12, 0, Math.PI * 2);
            ctx.fill();

            // Cargo
            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.arc(machine.x, machine.y - 70, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.fillText('Cargo', machine.x - 18, machine.y - 67);

            // Direction arrow
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(machine.x + 50, machine.y);
            ctx.lineTo(machine.x + 70, machine.y - 10);
            ctx.lineTo(machine.x + 70, machine.y + 10);
            ctx.fill();
        }

        function drawShuttle() {
            const cy = height / 2;

            // Draw track (molecular thread)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(machine.trackStart, cy);
            ctx.lineTo(machine.trackEnd, cy);
            ctx.stroke();

            // Stoppers at ends
            ctx.fillStyle = '#f44336';
            ctx.beginPath();
            ctx.arc(machine.trackStart, cy, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(machine.trackEnd, cy, 20, 0, Math.PI * 2);
            ctx.fill();

            // Binding stations
            const station1 = machine.trackStart + 50;
            const station2 = machine.trackEnd - 50;

            ctx.fillStyle = machine.state === 'left' ? '#4caf50' : '#666';
            ctx.beginPath();
            ctx.arc(station1, cy, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = machine.state === 'right' ? '#4caf50' : '#666';
            ctx.beginPath();
            ctx.arc(station2, cy, 15, 0, Math.PI * 2);
            ctx.fill();

            // Macrocyclic ring
            ctx.strokeStyle = '#673ab7';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.ellipse(machine.ringX, cy, 30, 40, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = 'rgba(103, 58, 183, 0.3)';
            ctx.beginPath();
            ctx.ellipse(machine.ringX, cy, 30, 40, 0, 0, Math.PI * 2);
            ctx.fill();

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.fillText('Stopper', machine.trackStart - 20, cy + 35);
            ctx.fillText('Stopper', machine.trackEnd - 20, cy + 35);
            ctx.fillText('Station 1', station1 - 25, cy - 25);
            ctx.fillText('Station 2', station2 - 25, cy - 25);
            ctx.fillText('Ring', machine.ringX - 10, cy);
        }

        function updateStats() {
            const speed = totalCycles / Math.max(0.1, time);
            const inputEnergy = atpLevel * time * 20; // Arbitrary units
            const efficiency = inputEnergy > 0 ? (totalWork / inputEnergy * 100) : 0;

            document.getElementById('cycles').textContent = Math.floor(totalCycles);
            document.getElementById('speed').textContent = speed.toFixed(2);
            document.getElementById('work').textContent = totalWork.toFixed(1);
            document.getElementById('efficiency').textContent = Math.min(100, efficiency).toFixed(1);
        }

        function animate() {
            if (running) {
                step();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('machineType').addEventListener('change', e => {
            machineType = e.target.value;
            init();
        });

        document.getElementById('atp').addEventListener('input', e => {
            atpLevel = parseFloat(e.target.value);
            document.getElementById('atpVal').textContent = atpLevel;
        });

        document.getElementById('load').addEventListener('input', e => {
            loadForce = parseFloat(e.target.value);
            document.getElementById('loadVal').textContent = loadForce;
        });

        document.getElementById('temperature').addEventListener('input', e => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('toggleRun').addEventListener('click', () => {
            running = !running;
            document.getElementById('toggleRun').textContent = running ? 'Pause' : 'Run';
        });

        window.addEventListener('resize', init);

        init();
        animate();
    </script>
</body>
</html>
