<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collision Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #ff5722; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #ff5722; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #ff5722; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Collision Theory</h1>
            <p class="description">Reactions occur when molecules collide with sufficient energy (> Ea) and proper orientation. The steric factor p accounts for orientation requirements. Rate ∝ collision frequency × exp(-Ea/RT) × p</p>

            <div class="control-group">
                <label>Temperature: <span id="tempVal">300</span> K</label>
                <input type="range" id="temperature" min="200" max="600" value="300">
            </div>

            <div class="control-group">
                <label>Activation Energy: <span id="eaVal">20</span> kJ/mol</label>
                <input type="range" id="activationE" min="5" max="100" value="20">
            </div>

            <div class="control-group">
                <label>Steric Factor: <span id="stericVal">0.5</span></label>
                <input type="range" id="stericFactor" min="0.01" max="1.0" step="0.01" value="0.5">
            </div>

            <div class="control-group">
                <label>Concentration: <span id="concVal">50</span></label>
                <input type="range" id="concentration" min="10" max="100" value="50">
            </div>

            <button id="reset">Reset</button>
            <button id="toggleRun">Run/Pause</button>

            <div class="stats">
                <div>Collisions: <span id="collisions">0</span></div>
                <div>Successful: <span id="successful">0</span></div>
                <div>Success Rate: <span id="successRate">0</span>%</div>
                <div>Products: <span id="products">0</span></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let running = false;

        let temperature = 300;
        let activationEnergy = 20;
        let stericFactor = 0.5;
        let concentration = 50;

        let moleculesA = [];
        let moleculesB = [];
        let products = [];
        let collisionEffects = [];

        let totalCollisions = 0;
        let successfulCollisions = 0;

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            moleculesA = [];
            moleculesB = [];
            products = [];
            collisionEffects = [];
            totalCollisions = 0;
            successfulCollisions = 0;

            const vesselLeft = 80;
            const vesselRight = width - 280;
            const vesselTop = 80;
            const vesselBottom = height - 80;

            // Create A molecules (red)
            for (let i = 0; i < concentration; i++) {
                moleculesA.push(createMolecule(vesselLeft, vesselRight, vesselTop, vesselBottom, 'A'));
            }

            // Create B molecules (blue)
            for (let i = 0; i < concentration; i++) {
                moleculesB.push(createMolecule(vesselLeft, vesselRight, vesselTop, vesselBottom, 'B'));
            }

            updateStats();
        }

        function createMolecule(left, right, top, bottom, type) {
            const speedFactor = Math.sqrt(temperature / 300);
            return {
                x: left + 20 + Math.random() * (right - left - 40),
                y: top + 20 + Math.random() * (bottom - top - 40),
                vx: (Math.random() - 0.5) * 4 * speedFactor,
                vy: (Math.random() - 0.5) * 4 * speedFactor,
                angle: Math.random() * Math.PI * 2, // Orientation
                type: type,
                radius: 10
            };
        }

        function getCollisionEnergy(m1, m2) {
            // Relative kinetic energy
            const dvx = m1.vx - m2.vx;
            const dvy = m1.vy - m2.vy;
            const relSpeed = Math.sqrt(dvx * dvx + dvy * dvy);
            // Simplified: energy proportional to speed squared
            return relSpeed * relSpeed * 0.5;
        }

        function getOrientationFactor(m1, m2) {
            // Check if reactive sites are aligned
            const dx = m2.x - m1.x;
            const dy = m2.y - m1.y;
            const collisionAngle = Math.atan2(dy, dx);

            // Both molecules must have correct orientation
            const align1 = Math.abs(Math.cos(m1.angle - collisionAngle));
            const align2 = Math.abs(Math.cos(m2.angle - collisionAngle));

            return align1 * align2;
        }

        function step() {
            const vesselLeft = 80;
            const vesselRight = width - 280;
            const vesselTop = 80;
            const vesselBottom = height - 80;
            const speedFactor = Math.sqrt(temperature / 300);

            // Move A molecules
            for (const m of moleculesA) {
                m.x += m.vx;
                m.y += m.vy;
                m.angle += (Math.random() - 0.5) * 0.2; // Random rotation

                // Walls
                if (m.x < vesselLeft + m.radius) { m.x = vesselLeft + m.radius; m.vx *= -1; }
                if (m.x > vesselRight - m.radius) { m.x = vesselRight - m.radius; m.vx *= -1; }
                if (m.y < vesselTop + m.radius) { m.y = vesselTop + m.radius; m.vy *= -1; }
                if (m.y > vesselBottom - m.radius) { m.y = vesselBottom - m.radius; m.vy *= -1; }
            }

            // Move B molecules
            for (const m of moleculesB) {
                m.x += m.vx;
                m.y += m.vy;
                m.angle += (Math.random() - 0.5) * 0.2;

                if (m.x < vesselLeft + m.radius) { m.x = vesselLeft + m.radius; m.vx *= -1; }
                if (m.x > vesselRight - m.radius) { m.x = vesselRight - m.radius; m.vx *= -1; }
                if (m.y < vesselTop + m.radius) { m.y = vesselTop + m.radius; m.vy *= -1; }
                if (m.y > vesselBottom - m.radius) { m.y = vesselBottom - m.radius; m.vy *= -1; }
            }

            // Check collisions between A and B
            for (let i = moleculesA.length - 1; i >= 0; i--) {
                for (let j = moleculesB.length - 1; j >= 0; j--) {
                    const mA = moleculesA[i];
                    const mB = moleculesB[j];

                    const dx = mB.x - mA.x;
                    const dy = mB.y - mA.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < mA.radius + mB.radius) {
                        totalCollisions++;

                        // Check if collision is successful
                        const collisionE = getCollisionEnergy(mA, mB);
                        const orientFactor = getOrientationFactor(mA, mB);

                        // Boltzmann probability: exp(-Ea/RT)
                        const R = 8.314e-3; // kJ/mol/K
                        const energyProb = Math.exp(-activationEnergy / (R * temperature));
                        const effectiveEnergy = collisionE / 10 * speedFactor;

                        const reactionProb = energyProb * stericFactor * orientFactor * effectiveEnergy;

                        // Add collision effect
                        collisionEffects.push({
                            x: (mA.x + mB.x) / 2,
                            y: (mA.y + mB.y) / 2,
                            life: 20,
                            success: Math.random() < reactionProb
                        });

                        if (Math.random() < reactionProb) {
                            // Successful reaction
                            successfulCollisions++;
                            products.push({
                                x: (mA.x + mB.x) / 2,
                                y: (mA.y + mB.y) / 2,
                                vx: (mA.vx + mB.vx) / 2,
                                vy: (mA.vy + mB.vy) / 2,
                                radius: 12
                            });

                            moleculesA.splice(i, 1);
                            moleculesB.splice(j, 1);
                            break;
                        } else {
                            // Elastic collision
                            const nx = dx / dist;
                            const ny = dy / dist;
                            const dvx = mB.vx - mA.vx;
                            const dvy = mB.vy - mA.vy;
                            const dvn = dvx * nx + dvy * ny;

                            mA.vx += dvn * nx;
                            mA.vy += dvn * ny;
                            mB.vx -= dvn * nx;
                            mB.vy -= dvn * ny;

                            // Separate overlapping
                            const overlap = mA.radius + mB.radius - dist;
                            mA.x -= overlap * nx / 2;
                            mA.y -= overlap * ny / 2;
                            mB.x += overlap * nx / 2;
                            mB.y += overlap * ny / 2;
                        }
                    }
                }
            }

            // Move products
            for (const p of products) {
                p.x += p.vx;
                p.y += p.vy;

                if (p.x < vesselLeft + p.radius) { p.x = vesselLeft + p.radius; p.vx *= -1; }
                if (p.x > vesselRight - p.radius) { p.x = vesselRight - p.radius; p.vx *= -1; }
                if (p.y < vesselTop + p.radius) { p.y = vesselTop + p.radius; p.vy *= -1; }
                if (p.y > vesselBottom - p.radius) { p.y = vesselBottom - p.radius; p.vy *= -1; }
            }

            // Update collision effects
            for (let i = collisionEffects.length - 1; i >= 0; i--) {
                collisionEffects[i].life--;
                if (collisionEffects[i].life <= 0) {
                    collisionEffects.splice(i, 1);
                }
            }

            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            const vesselLeft = 80;
            const vesselRight = width - 280;
            const vesselTop = 80;
            const vesselBottom = height - 80;

            // Reaction vessel
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.strokeRect(vesselLeft, vesselTop, vesselRight - vesselLeft, vesselBottom - vesselTop);

            // Collision effects
            for (const e of collisionEffects) {
                const alpha = e.life / 20;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 20 - e.life, 0, Math.PI * 2);
                if (e.success) {
                    ctx.strokeStyle = `rgba(76, 175, 80, ${alpha})`;
                    ctx.fillStyle = `rgba(76, 175, 80, ${alpha * 0.3})`;
                } else {
                    ctx.strokeStyle = `rgba(255, 152, 0, ${alpha})`;
                    ctx.fillStyle = `rgba(255, 152, 0, ${alpha * 0.3})`;
                }
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fill();
            }

            // Draw A molecules (red with orientation indicator)
            for (const m of moleculesA) {
                ctx.fillStyle = '#f44336';
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();

                // Reactive site indicator
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(m.x, m.y);
                ctx.lineTo(m.x + Math.cos(m.angle) * m.radius, m.y + Math.sin(m.angle) * m.radius);
                ctx.stroke();
            }

            // Draw B molecules (blue)
            for (const m of moleculesB) {
                ctx.fillStyle = '#2196f3';
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(m.x, m.y);
                ctx.lineTo(m.x + Math.cos(m.angle) * m.radius, m.y + Math.sin(m.angle) * m.radius);
                ctx.stroke();
            }

            // Draw products (green)
            for (const p of products) {
                ctx.fillStyle = '#4caf50';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('AB', p.x, p.y + 3);
            }

            // Legend
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#f44336';
            ctx.fillText('● A (reactant)', vesselLeft, vesselTop - 30);
            ctx.fillStyle = '#2196f3';
            ctx.fillText('● B (reactant)', vesselLeft + 100, vesselTop - 30);
            ctx.fillStyle = '#4caf50';
            ctx.fillText('● AB (product)', vesselLeft + 200, vesselTop - 30);

            // Energy diagram
            drawEnergyDiagram();

            // Formula
            ctx.fillStyle = '#ff5722';
            ctx.font = '14px sans-serif';
            ctx.fillText('A + B → AB', vesselLeft, vesselBottom + 30);
            ctx.fillStyle = '#aaa';
            ctx.font = '11px sans-serif';
            ctx.fillText('Reaction requires: Energy > Ea AND proper orientation', vesselLeft, vesselBottom + 50);
        }

        function drawEnergyDiagram() {
            const diagX = width - 250;
            const diagY = 50;
            const diagW = 200;
            const diagH = 150;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(diagX, diagY, diagW, diagH);

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;

            // Axes
            ctx.beginPath();
            ctx.moveTo(diagX + 20, diagY + 20);
            ctx.lineTo(diagX + 20, diagY + diagH - 20);
            ctx.lineTo(diagX + diagW - 20, diagY + diagH - 20);
            ctx.stroke();

            ctx.fillStyle = '#aaa';
            ctx.font = '10px sans-serif';
            ctx.fillText('E', diagX + 5, diagY + 30);
            ctx.fillText('Reaction Coordinate', diagX + 60, diagY + diagH - 5);

            // Energy profile
            const baseline = diagY + diagH - 40;
            const reactantE = baseline - 30;
            const productE = baseline - 50;
            const tsE = reactantE - activationEnergy;

            ctx.strokeStyle = '#ff5722';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(diagX + 30, reactantE);
            ctx.lineTo(diagX + 60, reactantE);
            ctx.quadraticCurveTo(diagX + 100, tsE - 20, diagX + 100, tsE);
            ctx.quadraticCurveTo(diagX + 100, productE + 20, diagX + 140, productE);
            ctx.lineTo(diagX + 170, productE);
            ctx.stroke();

            // Ea arrow
            ctx.strokeStyle = '#ffeb3b';
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(diagX + 100, reactantE);
            ctx.lineTo(diagX + 100, tsE);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#ffeb3b';
            ctx.fillText(`Ea = ${activationEnergy} kJ/mol`, diagX + 110, (reactantE + tsE) / 2);

            // Labels
            ctx.fillStyle = '#f44336';
            ctx.fillText('A+B', diagX + 35, reactantE + 15);
            ctx.fillStyle = '#4caf50';
            ctx.fillText('AB', diagX + 145, productE + 15);
        }

        function updateStats() {
            const successRate = totalCollisions > 0 ? (successfulCollisions / totalCollisions * 100) : 0;

            document.getElementById('collisions').textContent = totalCollisions;
            document.getElementById('successful').textContent = successfulCollisions;
            document.getElementById('successRate').textContent = successRate.toFixed(2);
            document.getElementById('products').textContent = products.length;
        }

        function animate() {
            if (running) {
                step();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('temperature').addEventListener('input', e => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
        });

        document.getElementById('activationE').addEventListener('input', e => {
            activationEnergy = parseInt(e.target.value);
            document.getElementById('eaVal').textContent = activationEnergy;
        });

        document.getElementById('stericFactor').addEventListener('input', e => {
            stericFactor = parseFloat(e.target.value);
            document.getElementById('stericVal').textContent = stericFactor;
        });

        document.getElementById('concentration').addEventListener('input', e => {
            concentration = parseInt(e.target.value);
            document.getElementById('concVal').textContent = concentration;
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('toggleRun').addEventListener('click', () => {
            running = !running;
            document.getElementById('toggleRun').textContent = running ? 'Pause' : 'Run';
        });

        window.addEventListener('resize', init);

        init();
        animate();
    </script>
</body>
</html>
