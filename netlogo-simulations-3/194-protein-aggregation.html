<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein Aggregation - NetLogo Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
        }
        .header {
            padding: 15px 20px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .header h1 { font-size: 1.4rem; color: #64ffda; }
        .back-link {
            color: #64ffda;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .back-link:hover { text-decoration: underline; }
        .main-container {
            display: flex;
            flex: 1;
            gap: 15px;
            padding: 15px;
        }
        .canvas-container {
            flex: 1;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        canvas { display: block; flex: 1; }
        .chart-container {
            height: 120px;
            background: rgba(0,0,0,0.5);
            border-top: 1px solid rgba(100,255,218,0.2);
        }
        .controls {
            width: 320px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        .control-group { margin-bottom: 8px; }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #8892b0;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group .value {
            text-align: right;
            color: #64ffda;
            font-size: 0.8rem;
        }
        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        .btn-primary { background: #64ffda; color: #1a1a2e; }
        .btn-primary:hover { background: #4dd4b4; }
        .btn-secondary { background: #2a3f5f; color: #fff; }
        .btn-secondary:hover { background: #3a5f8f; }
        .btn-danger { background: #ff6b6b; color: #fff; }
        .stats {
            background: rgba(100,255,218,0.1);
            border-radius: 8px;
            padding: 12px;
        }
        .stats h3 { color: #64ffda; margin-bottom: 8px; font-size: 0.95rem; }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85rem;
        }
        .stat-label { color: #8892b0; }
        .stat-value { color: #fff; font-weight: bold; }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.75rem;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .button-row {
            display: flex;
            gap: 8px;
        }
        .button-row .btn { flex: 1; }
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 25px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #64ffda;
        }
        .modal-content h2 { color: #64ffda; margin-bottom: 15px; }
        .modal-content p { color: #ccc; line-height: 1.6; margin-bottom: 12px; }
        .modal-content ul { color: #ccc; margin-left: 20px; margin-bottom: 12px; }
        .modal-content li { margin-bottom: 6px; }
        .close-modal {
            float: right;
            background: none;
            border: none;
            color: #64ffda;
            font-size: 1.5rem;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">← Back to Gallery</a>
        <h1>194. Protein Aggregation</h1>
        <button class="btn btn-secondary" onclick="showExplain()">Explain</button>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
            <div class="chart-container">
                <canvas id="chartCanvas"></canvas>
            </div>
        </div>

        <div class="controls">
            <div class="stats">
                <h3>Kinetics</h3>
                <div class="stat-row">
                    <span class="stat-label">Monomers:</span>
                    <span class="stat-value" id="monomerCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Oligomers:</span>
                    <span class="stat-value" id="oligomerCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Fibrils:</span>
                    <span class="stat-value" id="fibrilCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Fibril Mass:</span>
                    <span class="stat-value" id="fibrilMass">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ThT Signal (a.u.):</span>
                    <span class="stat-value" id="thtSignal">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Phase:</span>
                    <span class="stat-value" id="phaseLabel">Lag</span>
                </div>
            </div>

            <div class="control-group">
                <label>Protein Concentration: <span class="value" id="concVal">100</span></label>
                <input type="range" id="concentration" min="20" max="200" value="100">
            </div>

            <div class="control-group">
                <label>Primary Nucleation: <span class="value" id="primNucVal">0.001</span></label>
                <input type="range" id="primaryNuc" min="1" max="100" value="10">
            </div>

            <div class="control-group">
                <label>Secondary Nucleation: <span class="value" id="secNucVal">0.01</span></label>
                <input type="range" id="secondaryNuc" min="0" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Elongation Rate: <span class="value" id="elongVal">0.05</span></label>
                <input type="range" id="elongation" min="1" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Fragmentation: <span class="value" id="fragVal">0.001</span></label>
                <input type="range" id="fragmentation" min="0" max="50" value="5">
            </div>

            <div class="button-row">
                <button class="btn btn-primary" id="startBtn" onclick="toggleSimulation()">Start</button>
                <button class="btn btn-secondary" onclick="resetSimulation()">Reset</button>
            </div>

            <div class="button-row">
                <button class="btn btn-danger" onclick="addSeeds()">Add Seeds</button>
                <button class="btn btn-secondary" onclick="addInhibitor()">Add Inhibitor</button>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#64ffda"></div>Monomer</div>
                <div class="legend-item"><div class="legend-color" style="background:#ffd93d"></div>Oligomer</div>
                <div class="legend-item"><div class="legend-color" style="background:#9b59b6"></div>Nucleus</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff6b6b"></div>Fibril</div>
            </div>
        </div>
    </div>

    <div class="modal" id="explainModal">
        <div class="modal-content">
            <button class="close-modal" onclick="hideExplain()">&times;</button>
            <h2>Amyloid Protein Aggregation</h2>
            <p><strong>Amyloid fibrils</strong> are ordered protein aggregates with a characteristic cross-β structure. Their formation underlies diseases like Alzheimer's (Aβ), Parkinson's (α-synuclein), and Huntington's.</p>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Nucleation-Polymerization Mechanism</h3>
            <ul>
                <li><strong>Primary Nucleation:</strong> Rare, rate-limiting formation of initial seeds from monomers</li>
                <li><strong>Secondary Nucleation:</strong> New nuclei form on fibril surfaces (catalytic autocatalysis)</li>
                <li><strong>Elongation:</strong> Monomers add to fibril ends via induced fit</li>
                <li><strong>Fragmentation:</strong> Fibrils break, creating more growth-competent ends</li>
            </ul>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Kinetic Phases</h3>
            <ul>
                <li><strong>Lag Phase:</strong> Few aggregates; primary nucleation dominant</li>
                <li><strong>Growth Phase:</strong> Exponential increase; secondary nucleation drives rapid fibril multiplication</li>
                <li><strong>Plateau Phase:</strong> Monomer depletion; equilibrium reached</li>
            </ul>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">ThT Fluorescence</h3>
            <p>Thioflavin T (ThT) is a dye that fluoresces when bound to cross-β structure. The sigmoidal ThT curve is a hallmark of amyloid kinetics.</p>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Toxic Oligomers</h3>
            <p>Small oligomeric intermediates are often more toxic than mature fibrils. They can disrupt membranes and interfere with cellular processes. Secondary nucleation is a major source of these toxic species.</p>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Simulation Controls</h3>
            <ul>
                <li><strong>Concentration:</strong> Initial monomer count</li>
                <li><strong>Primary Nucleation:</strong> Rate of de novo seed formation</li>
                <li><strong>Secondary Nucleation:</strong> Rate of surface-catalyzed nucleation</li>
                <li><strong>Elongation:</strong> Monomer addition rate to fibril ends</li>
                <li><strong>Fragmentation:</strong> Fibril breakage rate</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        let running = false;
        let animationId = null;
        let inhibitorActive = false;

        let params = {
            concentration: 100,
            primaryNuc: 0.001,
            secondaryNuc: 0.01,
            elongation: 0.05,
            fragmentation: 0.001
        };

        let monomers = [];
        let oligomers = [];
        let fibrils = [];
        let time = 0;
        let thtHistory = [];

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight - 120;
            chartCanvas.width = container.clientWidth;
            chartCanvas.height = 120;
        }

        function initSimulation() {
            resizeCanvas();
            monomers = [];
            oligomers = [];
            fibrils = [];
            time = 0;
            thtHistory = [];
            inhibitorActive = false;

            // Create monomers
            for (let i = 0; i < params.concentration; i++) {
                monomers.push(createMonomer());
            }
        }

        function createMonomer() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                radius: 5
            };
        }

        function createOligomer(x, y, size) {
            return {
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 1.5,
                vy: (Math.random() - 0.5) * 1.5,
                size: size, // Number of monomers
                isNucleus: size >= 4
            };
        }

        function createFibril(x, y, angle) {
            return {
                x: x,
                y: y,
                angle: angle || Math.random() * Math.PI * 2,
                length: 20,
                monomers: 4, // Initial size
                growing: true
            };
        }

        function updateSimulation() {
            time++;
            const inhib = inhibitorActive ? 0.1 : 1;

            // Update monomers
            for (const m of monomers) {
                m.x += m.vx;
                m.y += m.vy;
                if (m.x < m.radius || m.x > canvas.width - m.radius) m.vx *= -1;
                if (m.y < m.radius || m.y > canvas.height - m.radius) m.vy *= -1;
                m.x = Math.max(m.radius, Math.min(canvas.width - m.radius, m.x));
                m.y = Math.max(m.radius, Math.min(canvas.height - m.radius, m.y));
            }

            // Primary nucleation - monomers collide to form oligomers
            if (monomers.length >= 2 && Math.random() < params.primaryNuc * monomers.length * inhib) {
                // Find two nearby monomers
                for (let i = 0; i < monomers.length - 1; i++) {
                    for (let j = i + 1; j < monomers.length; j++) {
                        const dx = monomers[i].x - monomers[j].x;
                        const dy = monomers[i].y - monomers[j].y;
                        if (Math.sqrt(dx*dx + dy*dy) < 20) {
                            // Form oligomer
                            oligomers.push(createOligomer(
                                (monomers[i].x + monomers[j].x) / 2,
                                (monomers[i].y + monomers[j].y) / 2,
                                2
                            ));
                            monomers.splice(j, 1);
                            monomers.splice(i, 1);
                            break;
                        }
                    }
                    if (monomers.length < 2) break;
                }
            }

            // Oligomer growth
            for (let i = oligomers.length - 1; i >= 0; i--) {
                const oligo = oligomers[i];
                oligo.x += oligo.vx;
                oligo.y += oligo.vy;
                if (oligo.x < 20 || oligo.x > canvas.width - 20) oligo.vx *= -1;
                if (oligo.y < 20 || oligo.y > canvas.height - 20) oligo.vy *= -1;

                // Oligomers capture monomers
                for (let j = monomers.length - 1; j >= 0; j--) {
                    const dx = oligo.x - monomers[j].x;
                    const dy = oligo.y - monomers[j].y;
                    if (Math.sqrt(dx*dx + dy*dy) < 15 + oligo.size * 2) {
                        if (Math.random() < 0.3 * inhib) {
                            oligo.size++;
                            monomers.splice(j, 1);

                            // Nucleated conformational conversion
                            if (oligo.size >= 4) {
                                oligo.isNucleus = true;
                            }
                            if (oligo.size >= 6) {
                                // Convert to fibril
                                fibrils.push(createFibril(oligo.x, oligo.y));
                                fibrils[fibrils.length - 1].monomers = oligo.size;
                                oligomers.splice(i, 1);
                            }
                            break;
                        }
                    }
                }
            }

            // Fibril dynamics
            for (let i = fibrils.length - 1; i >= 0; i--) {
                const fib = fibrils[i];

                // Elongation - capture monomers at ends
                const endX1 = fib.x + Math.cos(fib.angle) * fib.length / 2;
                const endY1 = fib.y + Math.sin(fib.angle) * fib.length / 2;
                const endX2 = fib.x - Math.cos(fib.angle) * fib.length / 2;
                const endY2 = fib.y - Math.sin(fib.angle) * fib.length / 2;

                for (let j = monomers.length - 1; j >= 0; j--) {
                    const m = monomers[j];
                    const d1 = Math.sqrt((m.x - endX1)**2 + (m.y - endY1)**2);
                    const d2 = Math.sqrt((m.x - endX2)**2 + (m.y - endY2)**2);

                    if ((d1 < 15 || d2 < 15) && Math.random() < params.elongation * inhib) {
                        fib.monomers++;
                        fib.length += 3;
                        monomers.splice(j, 1);
                    }
                }

                // Secondary nucleation - new oligomers form on fibril surface
                if (monomers.length > 0 && Math.random() < params.secondaryNuc * fib.length / 50 * inhib) {
                    // Find monomer near fibril
                    for (let j = 0; j < monomers.length; j++) {
                        const m = monomers[j];
                        // Check distance to fibril line
                        const dist = pointToLineDistance(m.x, m.y, endX1, endY1, endX2, endY2);
                        if (dist < 20) {
                            oligomers.push(createOligomer(m.x, m.y, 2));
                            oligomers[oligomers.length - 1].isNucleus = true; // Surface-nucleated
                            monomers.splice(j, 1);
                            break;
                        }
                    }
                }

                // Fragmentation
                if (fib.length > 40 && Math.random() < params.fragmentation) {
                    const fragPoint = 0.3 + Math.random() * 0.4;
                    const newLength1 = fib.length * fragPoint;
                    const newLength2 = fib.length * (1 - fragPoint);
                    const newMon1 = Math.floor(fib.monomers * fragPoint);
                    const newMon2 = fib.monomers - newMon1;

                    // Create new fibril
                    const offsetX = Math.cos(fib.angle) * (newLength1 / 2 + 5);
                    const offsetY = Math.sin(fib.angle) * (newLength1 / 2 + 5);
                    fibrils.push({
                        x: fib.x + offsetX,
                        y: fib.y + offsetY,
                        angle: fib.angle,
                        length: newLength2,
                        monomers: newMon2,
                        growing: true
                    });

                    fib.x -= offsetX / 2;
                    fib.y -= offsetY / 2;
                    fib.length = newLength1;
                    fib.monomers = newMon1;
                }

                // Slow drift
                fib.x += (Math.random() - 0.5) * 0.2;
                fib.y += (Math.random() - 0.5) * 0.2;
                fib.x = Math.max(fib.length/2, Math.min(canvas.width - fib.length/2, fib.x));
                fib.y = Math.max(fib.length/2, Math.min(canvas.height - fib.length/2, fib.y));
            }

            // Calculate ThT signal (proportional to fibril mass)
            const fibrilMass = fibrils.reduce((sum, f) => sum + f.monomers, 0);
            thtHistory.push(fibrilMass);
            if (thtHistory.length > 300) thtHistory.shift();

            updateStats();
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }

            return Math.sqrt((px - xx)**2 + (py - yy)**2);
        }

        function updateStats() {
            const fibrilMass = fibrils.reduce((sum, f) => sum + f.monomers, 0);
            const totalProt = monomers.length + oligomers.reduce((s, o) => s + o.size, 0) + fibrilMass;
            const maxMass = params.concentration;

            document.getElementById('monomerCount').textContent = monomers.length;
            document.getElementById('oligomerCount').textContent = oligomers.length;
            document.getElementById('fibrilCount').textContent = fibrils.length;
            document.getElementById('fibrilMass').textContent = fibrilMass;
            document.getElementById('thtSignal').textContent = fibrilMass;

            // Determine phase
            const ratio = fibrilMass / maxMass;
            let phase = 'Lag';
            if (ratio > 0.1 && ratio < 0.8) phase = 'Growth';
            else if (ratio >= 0.8) phase = 'Plateau';
            document.getElementById('phaseLabel').textContent = phase;
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw monomers
            ctx.fillStyle = '#64ffda';
            for (const m of monomers) {
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw oligomers
            for (const oligo of oligomers) {
                ctx.fillStyle = oligo.isNucleus ? '#9b59b6' : '#ffd93d';
                const r = 6 + oligo.size * 2;
                ctx.beginPath();
                // Draw as irregular cluster
                for (let i = 0; i < oligo.size; i++) {
                    const angle = (i / oligo.size) * Math.PI * 2;
                    const offset = r * 0.3;
                    ctx.moveTo(oligo.x + Math.cos(angle) * offset + 4, oligo.y + Math.sin(angle) * offset);
                    ctx.arc(
                        oligo.x + Math.cos(angle) * offset,
                        oligo.y + Math.sin(angle) * offset,
                        4, 0, Math.PI * 2
                    );
                }
                ctx.fill();

                // Toxic halo for oligomers
                if (oligo.size >= 3 && oligo.size < 6) {
                    ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(oligo.x, oligo.y, r + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Draw fibrils
            for (const fib of fibrils) {
                const endX1 = fib.x + Math.cos(fib.angle) * fib.length / 2;
                const endY1 = fib.y + Math.sin(fib.angle) * fib.length / 2;
                const endX2 = fib.x - Math.cos(fib.angle) * fib.length / 2;
                const endY2 = fib.y - Math.sin(fib.angle) * fib.length / 2;

                // Fibril body - multiple strands for cross-β
                const perpX = Math.cos(fib.angle + Math.PI/2) * 3;
                const perpY = Math.sin(fib.angle + Math.PI/2) * 3;

                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(endX1, endY1);
                ctx.lineTo(endX2, endY2);
                ctx.stroke();

                // Second strand
                ctx.strokeStyle = '#cc5555';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(endX1 + perpX, endY1 + perpY);
                ctx.lineTo(endX2 + perpX, endY2 + perpY);
                ctx.stroke();

                // Growth-competent ends
                ctx.fillStyle = '#ff9999';
                ctx.beginPath();
                ctx.arc(endX1, endY1, 5, 0, Math.PI * 2);
                ctx.arc(endX2, endY2, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ThT chart
            drawChart();
        }

        function drawChart() {
            chartCtx.fillStyle = 'rgba(0,0,0,0.8)';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (thtHistory.length < 2) return;

            const maxVal = Math.max(...thtHistory, params.concentration);
            const padding = 30;

            // Axes
            chartCtx.strokeStyle = 'rgba(100, 255, 218, 0.3)';
            chartCtx.lineWidth = 1;
            chartCtx.beginPath();
            chartCtx.moveTo(padding, 10);
            chartCtx.lineTo(padding, chartCanvas.height - 20);
            chartCtx.lineTo(chartCanvas.width - 10, chartCanvas.height - 20);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#64ffda';
            chartCtx.font = '10px Arial';
            chartCtx.fillText('ThT', 5, 15);
            chartCtx.fillText('Time', chartCanvas.width - 30, chartCanvas.height - 5);

            // Plot ThT curve
            chartCtx.strokeStyle = '#ffd93d';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            for (let i = 0; i < thtHistory.length; i++) {
                const x = padding + (i / 300) * (chartCanvas.width - padding - 10);
                const y = chartCanvas.height - 25 - (thtHistory[i] / maxVal) * (chartCanvas.height - 40);
                if (i === 0) chartCtx.moveTo(x, y);
                else chartCtx.lineTo(x, y);
            }
            chartCtx.stroke();

            // Phase indicators
            const ratio = thtHistory[thtHistory.length - 1] / params.concentration;
            chartCtx.fillStyle = 'rgba(100, 255, 218, 0.1)';
            if (ratio < 0.1) {
                chartCtx.fillRect(padding, 10, (chartCanvas.width - padding - 10) * 0.3, chartCanvas.height - 35);
            } else if (ratio < 0.8) {
                chartCtx.fillRect(padding + (chartCanvas.width - padding - 10) * 0.3, 10,
                    (chartCanvas.width - padding - 10) * 0.5, chartCanvas.height - 35);
            }
        }

        function animate() {
            if (running) {
                updateSimulation();
            }
            draw();
            animationId = requestAnimationFrame(animate);
        }

        function toggleSimulation() {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        }

        function resetSimulation() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        }

        function addSeeds() {
            // Add pre-formed fibril seeds
            for (let i = 0; i < 3; i++) {
                fibrils.push(createFibril(
                    100 + Math.random() * (canvas.width - 200),
                    100 + Math.random() * (canvas.height - 200)
                ));
                fibrils[fibrils.length - 1].length = 40;
                fibrils[fibrils.length - 1].monomers = 8;
            }
        }

        function addInhibitor() {
            inhibitorActive = !inhibitorActive;
            document.querySelector('.btn-secondary:last-child').textContent =
                inhibitorActive ? 'Remove Inhibitor' : 'Add Inhibitor';
        }

        function showExplain() {
            document.getElementById('explainModal').classList.add('active');
        }

        function hideExplain() {
            document.getElementById('explainModal').classList.remove('active');
        }

        // Event listeners
        document.getElementById('concentration').addEventListener('input', (e) => {
            params.concentration = parseInt(e.target.value);
            document.getElementById('concVal').textContent = params.concentration;
        });

        document.getElementById('primaryNuc').addEventListener('input', (e) => {
            params.primaryNuc = parseInt(e.target.value) / 10000;
            document.getElementById('primNucVal').textContent = params.primaryNuc.toFixed(4);
        });

        document.getElementById('secondaryNuc').addEventListener('input', (e) => {
            params.secondaryNuc = parseInt(e.target.value) / 1000;
            document.getElementById('secNucVal').textContent = params.secondaryNuc.toFixed(3);
        });

        document.getElementById('elongation').addEventListener('input', (e) => {
            params.elongation = parseInt(e.target.value) / 1000;
            document.getElementById('elongVal').textContent = params.elongation.toFixed(3);
        });

        document.getElementById('fragmentation').addEventListener('input', (e) => {
            params.fragmentation = parseInt(e.target.value) / 10000;
            document.getElementById('fragVal').textContent = params.fragmentation.toFixed(4);
        });

        window.addEventListener('resize', resizeCanvas);
        initSimulation();
        animate();
    </script>
</body>
</html>
