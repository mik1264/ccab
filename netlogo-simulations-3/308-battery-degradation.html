<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battery Degradation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #4caf50; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #4caf50; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #4caf50; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Battery Degradation</h1>
            <p class="description">Li-ion battery aging: SEI (Solid Electrolyte Interphase) growth consumes lithium, capacity fade. Calendar aging + cycle aging. High temperature and high SOC accelerate degradation.</p>

            <div class="control-group">
                <label>Temperature: <span id="tempVal">25</span>°C</label>
                <input type="range" id="temperature" min="0" max="60" value="25">
            </div>

            <div class="control-group">
                <label>C-Rate: <span id="crateVal">1</span>C</label>
                <input type="range" id="crate" min="0.2" max="3" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>SOC Range: <span id="socVal">80</span>%</label>
                <input type="range" id="socRange" min="20" max="100" step="10" value="80">
            </div>

            <button id="cycle">Run Charge Cycle</button>
            <button id="reset">Reset</button>
            <button id="toggleRun">Auto Cycle</button>

            <div class="stats">
                <div>Cycles: <span id="cycles">0</span></div>
                <div>Capacity: <span id="capacity">100</span>%</div>
                <div>SEI Thickness: <span id="seiThickness">0</span> nm</div>
                <div>Li Loss: <span id="liLoss">0</span>%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let running = false;
        let autoCycling = false;

        let temperature = 25;
        let cRate = 1;
        let socRange = 80;

        let cycles = 0;
        let capacity = 100;
        let seiThickness = 1; // nm
        let lithiumLoss = 0;
        let soc = 50;
        let charging = true;

        let capacityHistory = [];
        let lithiumIons = [];
        let seiParticles = [];

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            cycles = 0;
            capacity = 100;
            seiThickness = 1;
            lithiumLoss = 0;
            soc = 50;
            charging = true;
            capacityHistory = [{ cycle: 0, capacity: 100 }];
            lithiumIons = [];
            seiParticles = [];

            // Initialize lithium ions
            for (let i = 0; i < 100; i++) {
                lithiumIons.push({
                    x: 100 + Math.random() * 200,
                    y: 100 + Math.random() * (height - 250),
                    active: true
                });
            }

            updateStats();
        }

        function getDegradationRate() {
            // Arrhenius temperature dependence
            const Ea = 0.4; // eV
            const kB = 8.617e-5;
            const T = temperature + 273;
            const tempFactor = Math.exp(-Ea / (kB * T)) / Math.exp(-Ea / (kB * 298));

            // C-rate effect
            const cRateFactor = 1 + (cRate - 1) * 0.2;

            // SOC range effect (deep cycling is worse)
            const socFactor = 1 + (socRange - 50) / 100;

            return tempFactor * cRateFactor * socFactor;
        }

        function runCycle() {
            cycles++;

            const degradationRate = getDegradationRate();

            // SEI growth (sqrt of time/cycles - parabolic law)
            const seiGrowth = 0.5 * degradationRate / Math.sqrt(cycles);
            seiThickness += seiGrowth;

            // Lithium loss from SEI formation
            const liLossRate = 0.05 * degradationRate;
            lithiumLoss += liLossRate;

            // Capacity fade
            capacity = 100 - lithiumLoss - seiThickness * 0.1;
            capacity = Math.max(0, capacity);

            // Track history
            capacityHistory.push({ cycle: cycles, capacity: capacity });
            if (capacityHistory.length > 500) {
                capacityHistory.shift();
            }

            // Deactivate some lithium ions
            const toDeactivate = Math.floor(liLossRate * lithiumIons.filter(li => li.active).length / 100);
            let deactivated = 0;
            for (const li of lithiumIons) {
                if (li.active && deactivated < toDeactivate) {
                    li.active = false;
                    // Add to SEI
                    seiParticles.push({
                        x: width / 2 - 100 + Math.random() * 50,
                        y: li.y
                    });
                    deactivated++;
                }
            }

            updateStats();
        }

        function animateCharging() {
            // Move lithium ions during charge/discharge
            const direction = charging ? 1 : -1;
            const cathodeX = 150;
            const anodeX = width - 200;

            for (const li of lithiumIons) {
                if (!li.active) continue;

                if (charging) {
                    li.x += 2;
                    if (li.x > anodeX) {
                        li.x = anodeX;
                    }
                } else {
                    li.x -= 2;
                    if (li.x < cathodeX) {
                        li.x = cathodeX;
                    }
                }

                // Random vertical movement
                li.y += (Math.random() - 0.5) * 2;
                li.y = Math.max(100, Math.min(height - 150, li.y));
            }

            // Update SOC
            if (charging) {
                soc += cRate * 0.5;
                if (soc >= 50 + socRange / 2) {
                    charging = false;
                }
            } else {
                soc -= cRate * 0.5;
                if (soc <= 50 - socRange / 2) {
                    charging = true;
                    if (autoCycling) {
                        runCycle();
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            const cellWidth = width - 300;
            const cellHeight = height - 200;
            const cellX = 100;
            const cellY = 80;

            // Battery cell container
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.strokeRect(cellX, cellY, cellWidth, cellHeight);

            // Cathode (left)
            const cathodeWidth = 60;
            ctx.fillStyle = '#3949ab';
            ctx.fillRect(cellX, cellY, cathodeWidth, cellHeight);
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(cellX + cathodeWidth / 2, cellY + cellHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Cathode (LiCoO₂)', 0, 5);
            ctx.restore();

            // Anode (right)
            const anodeWidth = 60;
            const anodeX = cellX + cellWidth - anodeWidth;
            ctx.fillStyle = '#424242';
            ctx.fillRect(anodeX, cellY, anodeWidth, cellHeight);
            ctx.fillStyle = '#fff';
            ctx.save();
            ctx.translate(anodeX + anodeWidth / 2, cellY + cellHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Anode (Graphite)', 0, 5);
            ctx.restore();

            // SEI layer on anode
            const seiWidth = Math.min(seiThickness / 2, 30);
            ctx.fillStyle = 'rgba(139, 195, 74, 0.6)';
            ctx.fillRect(anodeX - seiWidth, cellY, seiWidth, cellHeight);

            // SEI particles
            ctx.fillStyle = '#8bc34a';
            for (const p of seiParticles) {
                ctx.beginPath();
                ctx.arc(anodeX - seiWidth / 2, p.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Electrolyte
            ctx.fillStyle = 'rgba(255, 235, 59, 0.1)';
            ctx.fillRect(cellX + cathodeWidth, cellY, cellWidth - cathodeWidth - anodeWidth, cellHeight);

            // Separator
            const sepX = cellX + cellWidth / 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(sepX, cellY);
            ctx.lineTo(sepX, cellY + cellHeight);
            ctx.stroke();
            ctx.setLineDash([]);

            // Lithium ions
            for (const li of lithiumIons) {
                if (li.active) {
                    ctx.fillStyle = '#ffeb3b';
                } else {
                    ctx.fillStyle = 'rgba(255, 235, 59, 0.3)';
                }
                ctx.beginPath();
                ctx.arc(li.x, li.y, 4, 0, Math.PI * 2);
                ctx.fill();
                if (li.active) {
                    ctx.fillStyle = '#000';
                    ctx.font = '6px sans-serif';
                    ctx.fillText('+', li.x - 2, li.y + 2);
                }
            }

            // Current direction
            ctx.strokeStyle = charging ? '#4caf50' : '#f44336';
            ctx.lineWidth = 2;
            const arrowY = cellY - 30;
            if (charging) {
                drawArrow(cellX + cathodeWidth + 50, arrowY, anodeX - 50, arrowY);
                ctx.fillStyle = '#4caf50';
                ctx.fillText('Charging', cellX + cellWidth / 2, arrowY - 10);
            } else {
                drawArrow(anodeX - 50, arrowY, cellX + cathodeWidth + 50, arrowY);
                ctx.fillStyle = '#f44336';
                ctx.fillText('Discharging', cellX + cellWidth / 2, arrowY - 10);
            }

            // SOC indicator
            drawSOCGauge();

            // Capacity fade plot
            drawCapacityPlot();

            // Labels
            ctx.fillStyle = '#4caf50';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`T = ${temperature}°C`, 10, 25);
            ctx.fillText(`SEI Layer`, anodeX - seiWidth - 5, cellY + cellHeight + 20);

            // Degradation info
            ctx.fillStyle = '#aaa';
            ctx.fillText('Li⁺ → e⁻ + Li (SEI)', anodeX - 80, cellY + cellHeight + 40);
        }

        function drawArrow(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.moveTo(x2 - 10, y2 - 5);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x2 - 10, y2 + 5);
            ctx.stroke();
        }

        function drawSOCGauge() {
            const gaugeX = 20;
            const gaugeY = 80;
            const gaugeW = 30;
            const gaugeH = 150;

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(gaugeX, gaugeY, gaugeW, gaugeH);

            // Fill based on SOC
            const fillH = (soc / 100) * gaugeH;
            const gradient = ctx.createLinearGradient(gaugeX, gaugeY + gaugeH - fillH, gaugeX, gaugeY + gaugeH);
            gradient.addColorStop(0, '#4caf50');
            gradient.addColorStop(1, '#8bc34a');
            ctx.fillStyle = gradient;
            ctx.fillRect(gaugeX, gaugeY + gaugeH - fillH, gaugeW, fillH);

            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('SOC', gaugeX + gaugeW / 2, gaugeY - 5);
            ctx.fillText(`${soc.toFixed(0)}%`, gaugeX + gaugeW / 2, gaugeY + gaugeH + 15);
        }

        function drawCapacityPlot() {
            const plotX = width - 220;
            const plotY = height - 160;
            const plotW = 200;
            const plotH = 140;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(plotX, plotY, plotW, plotH);

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(plotX, plotY, plotW, plotH);

            ctx.fillStyle = '#aaa';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Capacity vs Cycles', plotX + 5, plotY + 15);

            if (capacityHistory.length < 2) return;

            const maxCycles = Math.max(...capacityHistory.map(p => p.cycle)) || 1;

            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < capacityHistory.length; i++) {
                const p = capacityHistory[i];
                const x = plotX + 20 + (p.cycle / maxCycles) * (plotW - 30);
                const y = plotY + plotH - 20 - (p.capacity / 100) * (plotH - 40);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // 80% threshold line
            ctx.strokeStyle = '#f44336';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const threshY = plotY + plotH - 20 - 0.8 * (plotH - 40);
            ctx.beginPath();
            ctx.moveTo(plotX + 20, threshY);
            ctx.lineTo(plotX + plotW - 10, threshY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#f44336';
            ctx.font = '9px sans-serif';
            ctx.fillText('80% EOL', plotX + plotW - 50, threshY - 3);

            // Axes labels
            ctx.fillStyle = '#888';
            ctx.fillText('Cycles', plotX + plotW / 2, plotY + plotH - 3);
            ctx.fillText('%', plotX + 5, plotY + 30);
        }

        function updateStats() {
            document.getElementById('cycles').textContent = cycles;
            document.getElementById('capacity').textContent = capacity.toFixed(1);
            document.getElementById('seiThickness').textContent = seiThickness.toFixed(1);
            document.getElementById('liLoss').textContent = lithiumLoss.toFixed(2);
        }

        function animate() {
            if (running || autoCycling) {
                animateCharging();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('temperature').addEventListener('input', e => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
        });

        document.getElementById('crate').addEventListener('input', e => {
            cRate = parseFloat(e.target.value);
            document.getElementById('crateVal').textContent = cRate;
        });

        document.getElementById('socRange').addEventListener('input', e => {
            socRange = parseInt(e.target.value);
            document.getElementById('socVal').textContent = socRange;
        });

        document.getElementById('cycle').addEventListener('click', () => {
            runCycle();
        });

        document.getElementById('reset').addEventListener('click', init);

        document.getElementById('toggleRun').addEventListener('click', () => {
            autoCycling = !autoCycling;
            running = autoCycling;
            document.getElementById('toggleRun').textContent = autoCycling ? 'Stop' : 'Auto Cycle';
        });

        window.addEventListener('resize', init);

        init();
        animate();
    </script>
</body>
</html>
