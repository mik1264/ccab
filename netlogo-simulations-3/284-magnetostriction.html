<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetostriction</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #90caf9; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; background: #2a2a3e; color: #e8e6e1; border: 1px solid #444; border-radius: 4px; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #90caf9; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #90caf9; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Magnetostriction</h1>
            <p class="description">Magnetostriction is the change in shape when a material is magnetized. Magnetic domains rotate and walls move under applied field, causing dimensional changes (λ ~ 10⁻⁶ to 10⁻³).</p>

            <div class="control-group">
                <label>Material:</label>
                <select id="material">
                    <option value="iron">Iron (λ ~ 10⁻⁵)</option>
                    <option value="nickel">Nickel (λ ~ -30×10⁻⁶)</option>
                    <option value="terfenol">Terfenol-D (λ ~ 2×10⁻³)</option>
                    <option value="galfenol">Galfenol (λ ~ 350×10⁻⁶)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Applied Field H: <span id="fieldVal">0</span> kA/m</label>
                <input type="range" id="field" min="-100" max="100" value="0">
            </div>

            <div class="control-group">
                <label>Field Angle: <span id="angleVal">0</span>°</label>
                <input type="range" id="angle" min="0" max="180" value="0">
            </div>

            <button id="oscillate">Oscillate Field</button>
            <button id="reset">Reset</button>

            <div class="stats">
                <div>Magnetization M/Ms: <span id="magnetization">0</span></div>
                <div>Strain λ: <span id="strain">0</span> × 10⁻⁶</div>
                <div>ΔL/L: <span id="deltaL">0</span>%</div>
                <div>Domains Aligned: <span id="aligned">0</span>%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let oscillating = false;
        let time = 0;

        let material = 'iron';
        let appliedField = 0;
        let fieldAngle = 0;

        let domains = [];

        const materials = {
            iron: { lambdaS: 10, color: '#90caf9' },
            nickel: { lambdaS: -30, color: '#a5d6a7' },
            terfenol: { lambdaS: 2000, color: '#ffcc80' },
            galfenol: { lambdaS: 350, color: '#ce93d8' }
        };

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            domains = [];

            // Create magnetic domains
            const gridSize = 40;
            const cols = Math.floor((width - 200) / gridSize);
            const rows = Math.floor((height - 200) / gridSize);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    // Initial random domain orientations (easy axes)
                    const easyAxes = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                    domains.push({
                        x: 100 + x * gridSize + gridSize/2,
                        y: 100 + y * gridSize + gridSize/2,
                        angle: easyAxes[Math.floor(Math.random() * 4)],
                        size: gridSize * 0.8
                    });
                }
            }

            updateDomains();
        }

        function updateDomains() {
            const H = appliedField;
            const fieldDir = fieldAngle * Math.PI / 180;
            const mat = materials[material];

            for (const d of domains) {
                // Domain rotation under applied field
                // Zeeman energy: E = -M·H
                const torque = H * Math.sin(fieldDir - d.angle) * 0.05;
                d.angle += torque;

                // Snap to easy axis if field is weak
                if (Math.abs(H) < 10) {
                    const easyAxes = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                    let minDist = Infinity;
                    let nearest = 0;
                    for (const ea of easyAxes) {
                        const dist = Math.abs(d.angle - ea);
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = ea;
                        }
                    }
                    d.angle += (nearest - d.angle) * 0.1;
                }
            }

            updateStats();
        }

        function calculateMagnetization() {
            const fieldDir = fieldAngle * Math.PI / 180;
            let sumCos = 0;

            for (const d of domains) {
                sumCos += Math.cos(d.angle - fieldDir);
            }

            return sumCos / domains.length;
        }

        function calculateStrain() {
            const mat = materials[material];
            const M = calculateMagnetization();
            const fieldDir = fieldAngle * Math.PI / 180;

            // Magnetostriction: λ = (3/2)λs(cos²θ - 1/3)
            // For aligned domains along field direction
            let sumStrain = 0;
            for (const d of domains) {
                const cosTheta = Math.cos(d.angle - fieldDir);
                sumStrain += (3/2) * mat.lambdaS * (cosTheta * cosTheta - 1/3);
            }

            return sumStrain / domains.length;
        }

        function step() {
            time += 0.05;
            if (oscillating) {
                appliedField = 80 * Math.sin(time * 2);
                document.getElementById('field').value = appliedField;
                document.getElementById('fieldVal').textContent = appliedField.toFixed(0);
            }
            updateDomains();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            const cx = width / 2;
            const cy = height / 2;
            const mat = materials[material];

            // Calculate specimen deformation
            const strain = calculateStrain();
            const strainScale = 50;  // Visual amplification

            // Draw specimen with strain
            const specW = 400;
            const specH = 200;
            const deltaW = specW * strain / 1e6 * strainScale;
            const deltaH = -specH * strain / 1e6 * strainScale * 0.5;  // Poisson effect

            ctx.fillStyle = '#3a3a4e';
            ctx.fillRect(cx - specW/2 - deltaW/2, cy - specH/2 - deltaH/2,
                        specW + deltaW, specH + deltaH);

            // Draw domains
            for (const d of domains) {
                const dx = (d.x - cx) * (1 + strain / 1e6 * strainScale / specW);
                const dy = (d.y - cy) * (1 - strain / 1e6 * strainScale / specH * 0.5);

                ctx.save();
                ctx.translate(cx + dx, cy + dy);
                ctx.rotate(d.angle);

                // Domain color based on alignment
                const fieldDir = fieldAngle * Math.PI / 180;
                const alignment = Math.cos(d.angle - fieldDir);
                const intensity = Math.abs(alignment);

                ctx.fillStyle = alignment > 0 ?
                    `rgba(144, 202, 249, ${intensity})` :
                    `rgba(239, 83, 80, ${intensity})`;

                // Draw arrow
                ctx.beginPath();
                ctx.moveTo(-d.size/2, 0);
                ctx.lineTo(d.size/2, 0);
                ctx.lineTo(d.size/2 - 8, -5);
                ctx.moveTo(d.size/2, 0);
                ctx.lineTo(d.size/2 - 8, 5);
                ctx.strokeStyle = mat.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // Draw applied field
            const fieldDir = fieldAngle * Math.PI / 180;
            const fieldStrength = Math.abs(appliedField);

            if (fieldStrength > 5) {
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);

                const arrowLen = 50 + fieldStrength;
                const sign = appliedField > 0 ? 1 : -1;

                ctx.beginPath();
                ctx.moveTo(cx - sign * arrowLen * Math.cos(fieldDir),
                          cy - sign * arrowLen * Math.sin(fieldDir));
                ctx.lineTo(cx + sign * arrowLen * Math.cos(fieldDir),
                          cy + sign * arrowLen * Math.sin(fieldDir));
                ctx.stroke();

                // Arrow head
                ctx.setLineDash([]);
                const tipX = cx + sign * arrowLen * Math.cos(fieldDir);
                const tipY = cy + sign * arrowLen * Math.sin(fieldDir);
                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(tipX - 15 * Math.cos(fieldDir - 0.3),
                          tipY - 15 * Math.sin(fieldDir - 0.3));
                ctx.lineTo(tipX - 15 * Math.cos(fieldDir + 0.3),
                          tipY - 15 * Math.sin(fieldDir + 0.3));
                ctx.closePath();
                ctx.fillStyle = '#ffeb3b';
                ctx.fill();

                ctx.fillStyle = '#ffeb3b';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('H', tipX + 20 * Math.cos(fieldDir), tipY + 20 * Math.sin(fieldDir));
            }

            // Draw strain indicator
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Strain: ${strain.toFixed(1)} × 10⁻⁶`, 20, 30);

            // Draw length change arrows if significant
            if (Math.abs(strain) > 0.1) {
                ctx.strokeStyle = strain > 0 ? '#4caf50' : '#f44336';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);

                // Left
                ctx.beginPath();
                ctx.moveTo(cx - specW/2 - 30, cy);
                ctx.lineTo(cx - specW/2 - deltaW/2 - 10, cy);
                ctx.stroke();

                // Right
                ctx.beginPath();
                ctx.moveTo(cx + specW/2 + 30, cy);
                ctx.lineTo(cx + specW/2 + deltaW/2 + 10, cy);
                ctx.stroke();

                ctx.setLineDash([]);
            }
        }

        function updateStats() {
            const M = calculateMagnetization();
            const strain = calculateStrain();
            const deltaL = strain / 10;  // Percentage

            const fieldDir = fieldAngle * Math.PI / 180;
            let alignedCount = 0;
            for (const d of domains) {
                if (Math.abs(Math.cos(d.angle - fieldDir)) > 0.9) alignedCount++;
            }
            const alignedPercent = (alignedCount / domains.length * 100);

            document.getElementById('magnetization').textContent = M.toFixed(3);
            document.getElementById('strain').textContent = strain.toFixed(1);
            document.getElementById('deltaL').textContent = deltaL.toFixed(4);
            document.getElementById('aligned').textContent = alignedPercent.toFixed(0);
        }

        function animate() {
            step();
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('material').addEventListener('change', e => {
            material = e.target.value;
            init();
        });

        document.getElementById('field').addEventListener('input', e => {
            appliedField = parseInt(e.target.value);
            document.getElementById('fieldVal').textContent = appliedField;
            oscillating = false;
        });

        document.getElementById('angle').addEventListener('input', e => {
            fieldAngle = parseInt(e.target.value);
            document.getElementById('angleVal').textContent = fieldAngle;
        });

        document.getElementById('oscillate').addEventListener('click', () => {
            oscillating = !oscillating;
            document.getElementById('oscillate').textContent = oscillating ? 'Stop' : 'Oscillate Field';
        });

        document.getElementById('reset').addEventListener('click', () => {
            oscillating = false;
            appliedField = 0;
            document.getElementById('field').value = 0;
            document.getElementById('fieldVal').textContent = 0;
            init();
        });

        window.addEventListener('resize', () => { resize(); init(); });

        init();
        animate();
    </script>
</body>
</html>
