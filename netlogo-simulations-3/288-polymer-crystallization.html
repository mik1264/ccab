<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymer Crystallization - Spherulites</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #a5d6a7; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #a5d6a7; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-top: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #a5d6a7; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Polymer Crystallization</h1>
            <p class="description">Spherulite growth in semi-crystalline polymers. Crystalline lamellae grow radially from nuclei, with chain folding. Growth rate depends on undercooling below melt temperature.</p>

            <div class="control-group">
                <label>Temperature: <span id="tempVal">130</span>°C</label>
                <input type="range" id="temperature" min="100" max="160" value="130">
            </div>

            <div class="control-group">
                <label>Nucleation Density: <span id="nucVal">5</span></label>
                <input type="range" id="nucleation" min="1" max="20" value="5">
            </div>

            <div class="control-group">
                <label>Branching Rate: <span id="branchVal">0.1</span></label>
                <input type="range" id="branching" min="0.01" max="0.3" step="0.01" value="0.1">
            </div>

            <button id="addNucleus">Add Nucleus</button>
            <button id="reset">Reset</button>
            <button id="toggleRun">Run/Pause</button>

            <div class="stats">
                <div>Crystallinity: <span id="crystallinity">0</span>%</div>
                <div>Spherulites: <span id="spheruliteCount">0</span></div>
                <div>Avg Radius: <span id="avgRadius">0</span> μm</div>
                <div>Growth Rate: <span id="growthRate">0</span> μm/s</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let running = false;
        let time = 0;

        let temperature = 130;
        const Tm = 165;  // Melt temperature °C
        let nucleationDensity = 5;
        let branchingRate = 0.1;

        let spherulites = [];
        let crystallized = [];
        const CELL_SIZE = 2;
        let cols, rows;

        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            cols = Math.floor(width / CELL_SIZE);
            rows = Math.floor(height / CELL_SIZE);
        }

        function init() {
            resize();
            time = 0;
            spherulites = [];
            crystallized = new Array(cols * rows).fill(false);

            // Create initial nuclei
            for (let i = 0; i < nucleationDensity; i++) {
                addSpherulite(
                    Math.random() * cols,
                    Math.random() * rows
                );
            }

            updateStats();
        }

        function addSpherulite(cx, cy) {
            const numBranches = 12 + Math.floor(Math.random() * 12);
            const branches = [];

            for (let i = 0; i < numBranches; i++) {
                branches.push({
                    angle: (i / numBranches) * Math.PI * 2 + Math.random() * 0.2,
                    length: 1,
                    active: true
                });
            }

            spherulites.push({
                cx, cy,
                branches,
                radius: 1,
                color: `hsl(${100 + Math.random() * 40}, 50%, 50%)`
            });
        }

        function growthRate() {
            // Hoffman-Lauritzen: G ∝ exp(-U*/R(T-T∞)) × exp(-Kg/(TΔTf))
            // Simplified: peak at intermediate undercooling
            const undercooling = Tm - temperature;
            if (undercooling <= 0) return 0;

            const maxRate = 2;
            const optimalUndercooling = 25;
            const rate = maxRate * Math.exp(-Math.pow(undercooling - optimalUndercooling, 2) / 500);

            return rate;
        }

        function step() {
            time += 0.1;
            const rate = growthRate();

            for (const s of spherulites) {
                // Grow each branch
                for (const b of s.branches) {
                    if (!b.active) continue;

                    const growth = rate * (0.8 + Math.random() * 0.4);
                    b.length += growth;

                    // Calculate tip position
                    const tipX = Math.floor(s.cx + b.length * Math.cos(b.angle));
                    const tipY = Math.floor(s.cy + b.length * Math.sin(b.angle));

                    // Check if hitting boundary or crystallized region
                    if (tipX < 0 || tipX >= cols || tipY < 0 || tipY >= rows) {
                        b.active = false;
                        continue;
                    }

                    const idx = tipY * cols + tipX;
                    if (crystallized[idx]) {
                        b.active = false;
                        continue;
                    }

                    // Crystallize cells along branch
                    const steps = Math.ceil(growth);
                    for (let i = 0; i < steps; i++) {
                        const t = (b.length - growth + i) / b.length;
                        const px = Math.floor(s.cx + (b.length - growth + i) * Math.cos(b.angle));
                        const py = Math.floor(s.cy + (b.length - growth + i) * Math.sin(b.angle));
                        if (px >= 0 && px < cols && py >= 0 && py < rows) {
                            crystallized[py * cols + px] = true;
                        }
                    }

                    // Branching
                    if (Math.random() < branchingRate && b.length > 10) {
                        const branchAngle = b.angle + (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.3);
                        s.branches.push({
                            angle: branchAngle,
                            length: b.length,
                            active: true,
                            isBranch: true
                        });
                    }
                }

                // Update radius
                s.radius = Math.max(...s.branches.map(b => b.length));
            }

            // Sporadic nucleation
            if (Math.random() < 0.001 * (Tm - temperature) / 30) {
                const x = Math.floor(Math.random() * cols);
                const y = Math.floor(Math.random() * rows);
                if (!crystallized[y * cols + x]) {
                    addSpherulite(x, y);
                }
            }

            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw crystallized regions
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (crystallized[y * cols + x]) {
                        ctx.fillStyle = 'rgba(165, 214, 167, 0.3)';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw spherulites with radial pattern
            for (const s of spherulites) {
                const cx = s.cx * CELL_SIZE;
                const cy = s.cy * CELL_SIZE;

                // Draw branches (lamellae)
                ctx.strokeStyle = s.color;
                ctx.lineWidth = 1;

                for (const b of s.branches) {
                    ctx.globalAlpha = b.active ? 1 : 0.5;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(
                        cx + b.length * CELL_SIZE * Math.cos(b.angle),
                        cy + b.length * CELL_SIZE * Math.sin(b.angle)
                    );
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Draw nucleus
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();

                // Maltese cross pattern (polarized light simulation)
                if (s.radius > 20) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 2;
                    const r = s.radius * CELL_SIZE;

                    // Draw extinction lines at 45°
                    for (let i = 0; i < 4; i++) {
                        const angle = i * Math.PI / 2 + Math.PI / 4;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + r * Math.cos(angle), cy + r * Math.sin(angle));
                        ctx.stroke();
                    }
                }
            }

            // Draw growth front indicators
            for (const s of spherulites) {
                const activeBranches = s.branches.filter(b => b.active);
                if (activeBranches.length === 0) continue;

                ctx.strokeStyle = 'rgba(255, 235, 59, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(s.cx * CELL_SIZE, s.cy * CELL_SIZE, s.radius * CELL_SIZE, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Temperature indicator
            ctx.fillStyle = '#a5d6a7';
            ctx.font = '12px sans-serif';
            ctx.fillText(`Undercooling: ${Tm - temperature}°C`, 10, height - 10);
        }

        function updateStats() {
            const crystallinity = crystallized.filter(c => c).length / (cols * rows) * 100;
            const avgRadius = spherulites.length > 0 ?
                spherulites.reduce((sum, s) => sum + s.radius, 0) / spherulites.length : 0;

            document.getElementById('crystallinity').textContent = crystallinity.toFixed(1);
            document.getElementById('spheruliteCount').textContent = spherulites.length;
            document.getElementById('avgRadius').textContent = avgRadius.toFixed(1);
            document.getElementById('growthRate').textContent = growthRate().toFixed(2);
        }

        function animate() {
            if (running) {
                for (let i = 0; i < 3; i++) step();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('temperature').addEventListener('input', e => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
        });

        document.getElementById('nucleation').addEventListener('input', e => {
            nucleationDensity = parseInt(e.target.value);
            document.getElementById('nucVal').textContent = nucleationDensity;
        });

        document.getElementById('branching').addEventListener('input', e => {
            branchingRate = parseFloat(e.target.value);
            document.getElementById('branchVal').textContent = branchingRate;
        });

        document.getElementById('addNucleus').addEventListener('click', () => {
            addSpherulite(Math.random() * cols, Math.random() * rows);
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('toggleRun').addEventListener('click', () => {
            running = !running;
            document.getElementById('toggleRun').textContent = running ? 'Pause' : 'Run';
        });

        window.addEventListener('resize', () => { resize(); init(); });

        init();
        animate();
    </script>
</body>
</html>
