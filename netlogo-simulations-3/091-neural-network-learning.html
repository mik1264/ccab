<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Learning - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #818cf8; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #818cf8; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #818cf8; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #6366f1; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #818cf8; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #818cf8; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(129,140,248,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #818cf8; }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">‚Üê Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>üß† Neural Network Learning</h1>
            <p class="description">
                Simple neural network learning with backpropagation. Models how
                connection weights adjust through experience to solve classification
                problems like XOR or pattern recognition.
            </p>

            <div class="control-group">
                <label>Learning Rate: <span class="value-display" id="lrValue">0.5</span></label>
                <input type="range" id="lrSlider" min="0.1" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Hidden Neurons: <span class="value-display" id="hiddenValue">4</span></label>
                <input type="range" id="hiddenSlider" min="2" max="8" step="1" value="4">
            </div>

            <div class="control-group">
                <label>Noise Level: <span class="value-display" id="noiseValue">0.1</span></label>
                <input type="range" id="noiseSlider" min="0" max="0.3" step="0.05" value="0.1">
            </div>

            <button id="startBtn">Start Training</button>
            <button id="resetBtn">Reset Network</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Error: <span id="error">1.000</span></div>
                <div>Accuracy: <span id="accuracy">0%</span></div>
                <div>Epochs: <span id="epochs">0</span></div>
            </div>

            <div class="theory">
                <strong>Neural Learning:</strong><br>
                ‚Ä¢ <b>Forward pass:</b> Input ‚Üí Hidden ‚Üí Output<br>
                ‚Ä¢ <b>Backprop:</b> Error signal propagates back<br>
                ‚Ä¢ <b>Weight update:</b> Œîw = Œ∑ √ó error √ó input<br>
                ‚Ä¢ <b>Activation:</b> Sigmoid œÉ(x) = 1/(1+e‚ÅªÀ£)
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;
        let epochs = 0;

        let learningRate = 0.5;
        let hiddenNeurons = 4;
        let noiseLevel = 0.1;

        // XOR training data
        const trainingData = [
            { input: [0, 0], target: [0] },
            { input: [0, 1], target: [1] },
            { input: [1, 0], target: [1] },
            { input: [1, 1], target: [0] }
        ];

        let network = null;
        let errorHistory = [];
        let currentSample = 0;

        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        function sigmoidDerivative(x) {
            return x * (1 - x);
        }

        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;

                // Initialize weights randomly
                this.weightsIH = [];
                for (let i = 0; i < hiddenSize; i++) {
                    this.weightsIH[i] = [];
                    for (let j = 0; j < inputSize; j++) {
                        this.weightsIH[i][j] = (Math.random() - 0.5) * 2;
                    }
                }

                this.weightsHO = [];
                for (let i = 0; i < outputSize; i++) {
                    this.weightsHO[i] = [];
                    for (let j = 0; j < hiddenSize; j++) {
                        this.weightsHO[i][j] = (Math.random() - 0.5) * 2;
                    }
                }

                this.biasH = Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 2);
                this.biasO = Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 2);

                this.hidden = Array(hiddenSize).fill(0);
                this.output = Array(outputSize).fill(0);
            }

            forward(input) {
                // Hidden layer
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.biasH[i];
                    for (let j = 0; j < this.inputSize; j++) {
                        sum += input[j] * this.weightsIH[i][j];
                    }
                    this.hidden[i] = sigmoid(sum);
                }

                // Output layer
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.biasO[i];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += this.hidden[j] * this.weightsHO[i][j];
                    }
                    this.output[i] = sigmoid(sum);
                }

                return this.output;
            }

            train(input, target) {
                this.forward(input);

                // Output layer errors
                const outputErrors = [];
                for (let i = 0; i < this.outputSize; i++) {
                    outputErrors[i] = (target[i] - this.output[i]) * sigmoidDerivative(this.output[i]);
                }

                // Hidden layer errors
                const hiddenErrors = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let error = 0;
                    for (let j = 0; j < this.outputSize; j++) {
                        error += outputErrors[j] * this.weightsHO[j][i];
                    }
                    hiddenErrors[i] = error * sigmoidDerivative(this.hidden[i]);
                }

                // Update weights HO
                for (let i = 0; i < this.outputSize; i++) {
                    for (let j = 0; j < this.hiddenSize; j++) {
                        this.weightsHO[i][j] += learningRate * outputErrors[i] * this.hidden[j];
                    }
                    this.biasO[i] += learningRate * outputErrors[i];
                }

                // Update weights IH
                for (let i = 0; i < this.hiddenSize; i++) {
                    for (let j = 0; j < this.inputSize; j++) {
                        this.weightsIH[i][j] += learningRate * hiddenErrors[i] * input[j];
                    }
                    this.biasH[i] += learningRate * hiddenErrors[i];
                }

                return Math.abs(target[0] - this.output[0]);
            }
        }

        function initNetwork() {
            network = new NeuralNetwork(2, hiddenNeurons, 1);
            errorHistory = [];
            epochs = 0;
            currentSample = 0;
        }

        function update() {
            if (!running) return;

            generation++;

            // Train on current sample with noise
            const sample = trainingData[currentSample];
            const noisyInput = sample.input.map(i => i + (Math.random() - 0.5) * noiseLevel);
            const error = network.train(noisyInput, sample.target);

            currentSample = (currentSample + 1) % trainingData.length;
            if (currentSample === 0) epochs++;

            // Track error
            if (generation % 4 === 0) {
                let totalError = 0;
                let correct = 0;
                trainingData.forEach(sample => {
                    const output = network.forward(sample.input);
                    totalError += Math.abs(sample.target[0] - output[0]);
                    if (Math.round(output[0]) === sample.target[0]) correct++;
                });
                errorHistory.push({
                    time: generation,
                    error: totalError / trainingData.length,
                    accuracy: correct / trainingData.length
                });
                if (errorHistory.length > 200) errorHistory.shift();
            }

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Neural Network Learning: XOR Problem', 20, 25);

            drawNetwork();
            drawErrorGraph();
            drawDecisionBoundary();
        }

        function drawNetwork() {
            const netX = 50;
            const netY = 70;
            const netW = canvas.width * 0.4;
            const netH = canvas.height * 0.5;

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(netX, netY, netW, netH);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Network Architecture', netX + 5, netY + 15);

            const layerX = [netX + 50, netX + netW/2, netX + netW - 50];
            const inputY = [netY + netH * 0.35, netY + netH * 0.65];
            const hiddenY = [];
            for (let i = 0; i < hiddenNeurons; i++) {
                hiddenY.push(netY + 40 + (netH - 60) * (i + 0.5) / hiddenNeurons);
            }
            const outputY = [netY + netH/2];

            // Draw connections
            // Input to hidden
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < hiddenNeurons; j++) {
                    const weight = network.weightsIH[j][i];
                    ctx.strokeStyle = weight > 0 ? `rgba(34, 197, 94, ${Math.abs(weight) * 0.5})`
                                                 : `rgba(239, 68, 68, ${Math.abs(weight) * 0.5})`;
                    ctx.lineWidth = Math.abs(weight) * 2 + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(layerX[0], inputY[i]);
                    ctx.lineTo(layerX[1], hiddenY[j]);
                    ctx.stroke();
                }
            }

            // Hidden to output
            for (let i = 0; i < hiddenNeurons; i++) {
                const weight = network.weightsHO[0][i];
                ctx.strokeStyle = weight > 0 ? `rgba(34, 197, 94, ${Math.abs(weight) * 0.5})`
                                             : `rgba(239, 68, 68, ${Math.abs(weight) * 0.5})`;
                ctx.lineWidth = Math.abs(weight) * 2 + 0.5;
                ctx.beginPath();
                ctx.moveTo(layerX[1], hiddenY[i]);
                ctx.lineTo(layerX[2], outputY[0]);
                ctx.stroke();
            }

            // Draw neurons
            // Input
            inputY.forEach((y, i) => {
                const sample = trainingData[currentSample];
                ctx.fillStyle = sample.input[i] > 0.5 ? '#818cf8' : '#3b3b5c';
                ctx.beginPath();
                ctx.arc(layerX[0], y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(sample.input[i].toString(), layerX[0], y + 4);
            });

            // Hidden
            hiddenY.forEach((y, i) => {
                const activation = network.hidden[i];
                ctx.fillStyle = `hsl(238, ${activation * 60 + 20}%, ${30 + activation * 40}%)`;
                ctx.beginPath();
                ctx.arc(layerX[1], y, 12, 0, Math.PI * 2);
                ctx.fill();
            });

            // Output
            const output = network.output[0];
            ctx.fillStyle = `hsl(${output * 120}, 70%, 50%)`;
            ctx.beginPath();
            ctx.arc(layerX[2], outputY[0], 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px sans-serif';
            ctx.fillText(output.toFixed(2), layerX[2], outputY[0] + 4);

            ctx.textAlign = 'left';

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '9px sans-serif';
            ctx.fillText('Input', layerX[0] - 15, netY + netH - 10);
            ctx.fillText('Hidden', layerX[1] - 18, netY + netH - 10);
            ctx.fillText('Output', layerX[2] - 18, netY + netH - 10);
        }

        function drawErrorGraph() {
            const graphX = canvas.width * 0.5;
            const graphY = 50;
            const graphW = canvas.width * 0.46;
            const graphH = 120;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(graphX, graphY, graphW, graphH);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Training Error & Accuracy', graphX + 5, graphY + 15);

            if (errorHistory.length > 1) {
                // Error
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                errorHistory.forEach((record, i) => {
                    const x = graphX + (i / 200) * graphW;
                    const y = graphY + graphH - record.error * (graphH - 30) - 10;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Accuracy
                ctx.strokeStyle = '#22c55e';
                ctx.beginPath();
                errorHistory.forEach((record, i) => {
                    const x = graphX + (i / 200) * graphW;
                    const y = graphY + graphH - record.accuracy * (graphH - 30) - 10;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            // Legend
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(graphX + graphW - 80, graphY + 5, 10, 10);
            ctx.fillStyle = '#888';
            ctx.fillText('Error', graphX + graphW - 65, graphY + 14);

            ctx.fillStyle = '#22c55e';
            ctx.fillRect(graphX + graphW - 80, graphY + 20, 10, 10);
            ctx.fillText('Acc', graphX + graphW - 65, graphY + 29);
        }

        function drawDecisionBoundary() {
            const boundX = canvas.width * 0.5;
            const boundY = canvas.height * 0.35;
            const boundW = canvas.width * 0.46;
            const boundH = canvas.height * 0.5;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(boundX, boundY, boundW, boundH);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Decision Boundary (XOR)', boundX + 5, boundY + 15);

            // Draw decision surface
            const resolution = 20;
            const cellW = (boundW - 40) / resolution;
            const cellH = (boundH - 50) / resolution;

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x = i / resolution;
                    const y = j / resolution;
                    const output = network.forward([x, y])[0];

                    ctx.fillStyle = `hsl(${output * 120}, 50%, ${30 + output * 30}%)`;
                    ctx.fillRect(
                        boundX + 20 + i * cellW,
                        boundY + boundH - 30 - (j + 1) * cellH,
                        cellW + 1,
                        cellH + 1
                    );
                }
            }

            // Draw training points
            trainingData.forEach(sample => {
                const px = boundX + 20 + sample.input[0] * (boundW - 40);
                const py = boundY + boundH - 30 - sample.input[1] * (boundH - 50);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(px, py, 8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = sample.target[0] > 0.5 ? '#22c55e' : '#ef4444';
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fill();
            });

            // Axes
            ctx.fillStyle = '#666';
            ctx.font = '9px sans-serif';
            ctx.fillText('Input 1', boundX + boundW/2 - 20, boundY + boundH - 10);
            ctx.save();
            ctx.translate(boundX + 10, boundY + boundH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Input 2', -20, 0);
            ctx.restore();
        }

        function updateStats() {
            let totalError = 0;
            let correct = 0;
            trainingData.forEach(sample => {
                const output = network.forward(sample.input);
                totalError += Math.abs(sample.target[0] - output[0]);
                if (Math.round(output[0]) === sample.target[0]) correct++;
            });

            document.getElementById('generation').textContent = generation;
            document.getElementById('error').textContent = (totalError / trainingData.length).toFixed(3);
            document.getElementById('accuracy').textContent = Math.round(correct / trainingData.length * 100) + '%';
            document.getElementById('epochs').textContent = epochs;
        }

        document.getElementById('lrSlider').addEventListener('input', (e) => {
            learningRate = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = learningRate.toFixed(1);
        });

        document.getElementById('hiddenSlider').addEventListener('input', (e) => {
            hiddenNeurons = parseInt(e.target.value);
            document.getElementById('hiddenValue').textContent = hiddenNeurons;
        });

        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            noiseLevel = parseFloat(e.target.value);
            document.getElementById('noiseValue').textContent = noiseLevel.toFixed(2);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Training';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Training';
            initNetwork();
            render();
            updateStats();
        });

        initNetwork();
        render();
        updateStats();
    </script>
</body>
</html>
