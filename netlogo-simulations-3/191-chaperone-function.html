<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaperone Function - NetLogo Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
        }
        .header {
            padding: 15px 20px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .header h1 { font-size: 1.4rem; color: #64ffda; }
        .back-link {
            color: #64ffda;
            text-decoration: none;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .back-link:hover { text-decoration: underline; }
        .main-container {
            display: flex;
            flex: 1;
            gap: 15px;
            padding: 15px;
        }
        .canvas-container {
            flex: 1;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        canvas { display: block; width: 100%; height: 100%; }
        .controls {
            width: 320px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        .control-group { margin-bottom: 8px; }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #8892b0;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group .value {
            text-align: right;
            color: #64ffda;
            font-size: 0.8rem;
        }
        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        .btn-primary { background: #64ffda; color: #1a1a2e; }
        .btn-primary:hover { background: #4dd4b4; }
        .btn-secondary { background: #2a3f5f; color: #fff; }
        .btn-secondary:hover { background: #3a5f8f; }
        .btn-danger { background: #ff6b6b; color: #fff; }
        .btn-danger:hover { background: #ee5a5a; }
        .stats {
            background: rgba(100,255,218,0.1);
            border-radius: 8px;
            padding: 12px;
        }
        .stats h3 { color: #64ffda; margin-bottom: 8px; font-size: 0.95rem; }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85rem;
        }
        .stat-label { color: #8892b0; }
        .stat-value { color: #fff; font-weight: bold; }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.75rem;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .button-row {
            display: flex;
            gap: 8px;
        }
        .button-row .btn { flex: 1; }
        .modal.active { display: flex; }
        .modal-content {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 25px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #64ffda;
        }
        .modal-content h2 { color: #64ffda; margin-bottom: 15px; }
        .modal-content p { color: #ccc; line-height: 1.6; margin-bottom: 12px; }
        .modal-content ul { color: #ccc; margin-left: 20px; margin-bottom: 12px; }
        .modal-content li { margin-bottom: 6px; }
        .close-modal {
            float: right;
            background: none;
            border: none;
            color: #64ffda;
            font-size: 1.5rem;
            cursor: pointer;
        }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            padding: 20px;
            overflow-y: auto;
        }
        .modal-overlay.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            border-radius: 20px;
            padding: 35px;
            max-width: 750px;
            width: 100%;
            margin: 40px auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .modal-close:hover {
            color: #fff;
            background: rgba(255,255,255,0.2);
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 25px;
            font-size: 1.6rem;
            padding-right: 50px;
            line-height: 1.3;
        }
        .modal-body {
            color: #d1d5db;
            line-height: 1.9;
            font-size: 1rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 28px 0 14px 0;
            font-size: 1.15rem;
            font-weight: 600;
        }
        .modal-body p {
            margin-bottom: 16px;
        }
        .modal-body ul {
            margin: 12px 0 18px 24px;
        }
        .modal-body li {
            margin-bottom: 10px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: italic;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: #fbbf24;
            font-size: 0.9em;
        }
        .modal-category {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
        <h1>191. Chaperone Function</h1>
        <button class="btn btn-secondary" onclick="showExplain()">Explain</button>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>

        <div class="controls">
            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Native Proteins:</span>
                    <span class="stat-value" id="nativeCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Misfolded:</span>
                    <span class="stat-value" id="misfoldedCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Aggregated:</span>
                    <span class="stat-value" id="aggregatedCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Chaperone-Bound:</span>
                    <span class="stat-value" id="boundCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Folding Rate:</span>
                    <span class="stat-value" id="foldingRate">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ATP Used:</span>
                    <span class="stat-value" id="atpUsed">0</span>
                </div>
            </div>

            <div class="control-group">
                <label>HSP70 Count: <span class="value" id="hsp70Val">20</span></label>
                <input type="range" id="hsp70Count" min="0" max="50" value="20">
            </div>

            <div class="control-group">
                <label>Protein Synthesis Rate: <span class="value" id="synthVal">0.3</span></label>
                <input type="range" id="synthesisRate" min="0" max="100" value="30">
            </div>

            <div class="control-group">
                <label>Stress Level (Heat): <span class="value" id="stressVal">0.1</span></label>
                <input type="range" id="stressLevel" min="0" max="100" value="10">
            </div>

            <div class="control-group">
                <label>J-Domain Protein Activity: <span class="value" id="jdpVal">0.5</span></label>
                <input type="range" id="jdpActivity" min="0" max="100" value="50">
            </div>

            <div class="control-group">
                <label>ATP Availability: <span class="value" id="atpVal">1.0</span></label>
                <input type="range" id="atpLevel" min="10" max="100" value="100">
            </div>

            <div class="button-row">
                <button class="btn btn-primary" id="startBtn" onclick="toggleSimulation()">Start</button>
                <button class="btn btn-secondary" onclick="resetSimulation()">Reset</button>
                <button id="explainBtn" class="explain-btn">üìö Explain This Simulation</button>
            </div>

            <div class="button-row">
                <button class="btn btn-danger" onclick="induceThermalStress()">Heat Shock</button>
                <button class="btn btn-secondary" onclick="toggleChaperones()">Toggle HSP70</button>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#00ff88"></div>Native</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff6b6b"></div>Misfolded</div>
                <div class="legend-item"><div class="legend-color" style="background:#8b0000"></div>Aggregated</div>
                <div class="legend-item"><div class="legend-color" style="background:#64ffda"></div>HSP70 (ATP)</div>
                <div class="legend-item"><div class="legend-color" style="background:#ffd93d"></div>HSP70 (ADP)</div>
                <div class="legend-item"><div class="legend-color" style="background:#9b59b6"></div>JDP</div>
            </div>
        </div>
    </div>

    <div class="modal" id="explainModal">
        <div class="modal-content">
            <button class="close-modal" onclick="hideExplain()">&times;</button>
            <h2>Molecular Chaperone Function</h2>
            <p><strong>HSP70 (Heat Shock Protein 70)</strong> is a highly conserved molecular chaperone that assists protein folding and prevents aggregation of misfolded proteins.</p>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">ATP-Dependent Cycle</h3>
            <p>HSP70 operates through an ATP-dependent binding/release cycle:</p>
            <ul>
                <li><strong>ATP-bound state:</strong> Low substrate affinity, rapid binding/release</li>
                <li><strong>ADP-bound state:</strong> High substrate affinity, holds substrate tightly</li>
                <li><strong>J-Domain Proteins (JDPs):</strong> Target HSP70 to misfolded substrates and stimulate ATP hydrolysis</li>
                <li><strong>Nucleotide Exchange Factors:</strong> Replace ADP with ATP, triggering substrate release</li>
            </ul>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Three Key Activities</h3>
            <ul>
                <li><strong>Holder:</strong> Binds hydrophobic patches to prevent aggregation</li>
                <li><strong>Foldase:</strong> Remodels energy landscape to promote correct folding</li>
                <li><strong>Disaggregase:</strong> (With HSP100) Solubilizes protein aggregates</li>
            </ul>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Heat Shock Response</h3>
            <p>Under thermal stress, protein misfolding increases dramatically. Cells respond by upregulating HSP70 expression. Without adequate chaperone capacity, proteins form toxic aggregates implicated in neurodegenerative diseases like Alzheimer's and Parkinson's.</p>

            <h3 style="color:#64ffda; margin: 15px 0 10px;">Simulation Controls</h3>
            <ul>
                <li><strong>HSP70 Count:</strong> Number of chaperone molecules</li>
                <li><strong>Protein Synthesis:</strong> Rate of new protein production</li>
                <li><strong>Stress Level:</strong> Background misfolding probability</li>
                <li><strong>JDP Activity:</strong> Efficiency of substrate targeting</li>
                <li><strong>ATP Availability:</strong> Energy for chaperone cycling</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        let running = false;
        let animationId = null;
        let chaperonesEnabled = true;

        // Simulation parameters
        let params = {
            hsp70Count: 20,
            synthesisRate: 0.3,
            stressLevel: 0.1,
            jdpActivity: 0.5,
            atpLevel: 1.0
        };

        // Entity arrays
        let proteins = [];
        let chaperones = [];
        let jdps = [];
        let aggregates = [];

        // Stats
        let stats = {
            native: 0,
            misfolded: 0,
            aggregated: 0,
            bound: 0,
            atpUsed: 0,
            totalFolded: 0,
            totalProduced: 0
        };

        // Protein states
        const PROTEIN_STATE = {
            NASCENT: 0,
            NATIVE: 1,
            MISFOLDED: 2,
            CHAPERONE_BOUND: 3,
            AGGREGATED: 4
        };

        // HSP70 states
        const HSP70_STATE = {
            ATP_BOUND: 0,    // Low affinity, searching
            ADP_BOUND: 1,    // High affinity, holding substrate
            RELEASING: 2     // Nucleotide exchange
        };

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function initSimulation() {
            resizeCanvas();
            proteins = [];
            chaperones = [];
            jdps = [];
            aggregates = [];
            stats = { native: 0, misfolded: 0, aggregated: 0, bound: 0, atpUsed: 0, totalFolded: 0, totalProduced: 0 };

            // Create HSP70 chaperones
            for (let i = 0; i < params.hsp70Count; i++) {
                chaperones.push(createChaperone());
            }

            // Create J-domain proteins
            for (let i = 0; i < 15; i++) {
                jdps.push(createJDP());
            }

            // Create initial proteins
            for (let i = 0; i < 30; i++) {
                proteins.push(createProtein(true));
            }
        }

        function createProtein(startNative = false) {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                radius: 8,
                state: startNative ? PROTEIN_STATE.NATIVE : PROTEIN_STATE.NASCENT,
                foldingProgress: startNative ? 1 : 0,
                misfoldTime: 0,
                boundChaperone: null,
                hydrophobicExposure: startNative ? 0 : Math.random()
            };
        }

        function createChaperone() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                radius: 14,
                state: HSP70_STATE.ATP_BOUND,
                boundSubstrate: null,
                cycleTime: 0,
                lidOpen: true
            };
        }

        function createJDP() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                radius: 6,
                active: true
            };
        }

        function updateSimulation() {
            // Protein synthesis
            if (Math.random() < params.synthesisRate * 0.1) {
                proteins.push(createProtein(false));
                stats.totalProduced++;
            }

            // Update proteins
            for (let i = proteins.length - 1; i >= 0; i--) {
                const p = proteins[i];

                if (p.state === PROTEIN_STATE.AGGREGATED) continue;

                if (p.state !== PROTEIN_STATE.CHAPERONE_BOUND) {
                    // Movement
                    p.x += p.vx;
                    p.y += p.vy;

                    // Boundary bounce
                    if (p.x < p.radius || p.x > canvas.width - p.radius) p.vx *= -1;
                    if (p.y < p.radius || p.y > canvas.height - p.radius) p.vy *= -1;
                    p.x = Math.max(p.radius, Math.min(canvas.width - p.radius, p.x));
                    p.y = Math.max(p.radius, Math.min(canvas.height - p.radius, p.y));
                }

                // State transitions
                if (p.state === PROTEIN_STATE.NASCENT) {
                    // Natural folding attempt (slow)
                    if (Math.random() < 0.02) {
                        if (Math.random() < 0.3 + params.stressLevel) {
                            p.state = PROTEIN_STATE.MISFOLDED;
                            p.hydrophobicExposure = 0.5 + Math.random() * 0.5;
                        } else {
                            p.state = PROTEIN_STATE.NATIVE;
                            p.hydrophobicExposure = 0;
                            stats.totalFolded++;
                        }
                    }
                } else if (p.state === PROTEIN_STATE.NATIVE) {
                    // Stress-induced misfolding
                    if (Math.random() < params.stressLevel * 0.05) {
                        p.state = PROTEIN_STATE.MISFOLDED;
                        p.hydrophobicExposure = 0.3 + Math.random() * 0.7;
                    }
                } else if (p.state === PROTEIN_STATE.MISFOLDED) {
                    p.misfoldTime++;
                    // Aggregation tendency increases over time
                    if (p.misfoldTime > 100 && Math.random() < 0.01 * p.hydrophobicExposure) {
                        // Check for nearby misfolded proteins
                        for (let j = 0; j < proteins.length; j++) {
                            if (i !== j && proteins[j].state === PROTEIN_STATE.MISFOLDED) {
                                const dx = p.x - proteins[j].x;
                                const dy = p.y - proteins[j].y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist < 30) {
                                    // Form aggregate
                                    aggregates.push({
                                        x: (p.x + proteins[j].x) / 2,
                                        y: (p.y + proteins[j].y) / 2,
                                        size: 2,
                                        proteins: [p, proteins[j]]
                                    });
                                    p.state = PROTEIN_STATE.AGGREGATED;
                                    proteins[j].state = PROTEIN_STATE.AGGREGATED;
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // Update chaperones
            if (chaperonesEnabled) {
                for (const c of chaperones) {
                    c.cycleTime++;

                    // Movement
                    c.x += c.vx;
                    c.y += c.vy;
                    if (c.x < c.radius || c.x > canvas.width - c.radius) c.vx *= -1;
                    if (c.y < c.radius || c.y > canvas.height - c.radius) c.vy *= -1;
                    c.x = Math.max(c.radius, Math.min(canvas.width - c.radius, c.x));
                    c.y = Math.max(c.radius, Math.min(canvas.height - c.radius, c.y));

                    if (c.state === HSP70_STATE.ATP_BOUND && !c.boundSubstrate) {
                        // Search for misfolded proteins (JDP-assisted targeting)
                        for (const p of proteins) {
                            if (p.state === PROTEIN_STATE.MISFOLDED || p.state === PROTEIN_STATE.NASCENT) {
                                const dx = c.x - p.x;
                                const dy = c.y - p.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);

                                // JDP proximity increases binding
                                let jdpBoost = 1;
                                for (const jdp of jdps) {
                                    const jdx = jdp.x - p.x;
                                    const jdy = jdp.y - p.y;
                                    if (Math.sqrt(jdx*jdx + jdy*jdy) < 40) {
                                        jdpBoost = 1 + params.jdpActivity * 2;
                                        break;
                                    }
                                }

                                if (dist < 25 && Math.random() < 0.3 * p.hydrophobicExposure * jdpBoost * params.atpLevel) {
                                    // Bind substrate
                                    c.boundSubstrate = p;
                                    p.boundChaperone = c;
                                    p.state = PROTEIN_STATE.CHAPERONE_BOUND;
                                    c.state = HSP70_STATE.ADP_BOUND;
                                    c.lidOpen = false;
                                    c.cycleTime = 0;
                                    stats.atpUsed++;
                                    break;
                                }
                            }
                        }
                    } else if (c.state === HSP70_STATE.ADP_BOUND && c.boundSubstrate) {
                        // Holding substrate - move together
                        c.boundSubstrate.x = c.x;
                        c.boundSubstrate.y = c.y;

                        // Folding assistance (remodel energy landscape)
                        c.boundSubstrate.hydrophobicExposure *= 0.98;

                        // Nucleotide exchange (release) - timing depends on ATP availability
                        if (c.cycleTime > 50 / params.atpLevel && Math.random() < 0.05 * params.atpLevel) {
                            c.state = HSP70_STATE.RELEASING;
                        }
                    } else if (c.state === HSP70_STATE.RELEASING) {
                        c.lidOpen = true;
                        if (c.boundSubstrate) {
                            // Release and check folding
                            const p = c.boundSubstrate;
                            if (p.hydrophobicExposure < 0.2) {
                                p.state = PROTEIN_STATE.NATIVE;
                                p.hydrophobicExposure = 0;
                                stats.totalFolded++;
                            } else {
                                p.state = PROTEIN_STATE.MISFOLDED;
                                p.misfoldTime = 0; // Reset aggregation timer
                            }
                            p.boundChaperone = null;
                            c.boundSubstrate = null;
                        }
                        c.state = HSP70_STATE.ATP_BOUND;
                        c.cycleTime = 0;
                    }
                }
            }

            // Update JDPs
            for (const jdp of jdps) {
                jdp.x += jdp.vx;
                jdp.y += jdp.vy;
                if (jdp.x < jdp.radius || jdp.x > canvas.width - jdp.radius) jdp.vx *= -1;
                if (jdp.y < jdp.radius || jdp.y > canvas.height - jdp.radius) jdp.vy *= -1;
                jdp.x = Math.max(jdp.radius, Math.min(canvas.width - jdp.radius, jdp.x));
                jdp.y = Math.max(jdp.radius, Math.min(canvas.height - jdp.radius, jdp.y));
            }

            // Aggregate growth
            for (const agg of aggregates) {
                for (let i = proteins.length - 1; i >= 0; i--) {
                    const p = proteins[i];
                    if (p.state === PROTEIN_STATE.MISFOLDED) {
                        const dx = agg.x - p.x;
                        const dy = agg.y - p.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < agg.size * 8 + 20 && Math.random() < 0.02 * p.hydrophobicExposure) {
                            agg.size++;
                            agg.proteins.push(p);
                            p.state = PROTEIN_STATE.AGGREGATED;
                        }
                    }
                }
            }

            updateStats();
        }

        function updateStats() {
            stats.native = proteins.filter(p => p.state === PROTEIN_STATE.NATIVE).length;
            stats.misfolded = proteins.filter(p => p.state === PROTEIN_STATE.MISFOLDED || p.state === PROTEIN_STATE.NASCENT).length;
            stats.aggregated = proteins.filter(p => p.state === PROTEIN_STATE.AGGREGATED).length;
            stats.bound = proteins.filter(p => p.state === PROTEIN_STATE.CHAPERONE_BOUND).length;

            document.getElementById('nativeCount').textContent = stats.native;
            document.getElementById('misfoldedCount').textContent = stats.misfolded;
            document.getElementById('aggregatedCount').textContent = stats.aggregated;
            document.getElementById('boundCount').textContent = stats.bound;
            document.getElementById('atpUsed').textContent = stats.atpUsed;

            const rate = stats.totalProduced > 0 ? Math.round(stats.totalFolded / stats.totalProduced * 100) : 0;
            document.getElementById('foldingRate').textContent = rate + '%';
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(100, 255, 218, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw aggregates
            for (const agg of aggregates) {
                const gradient = ctx.createRadialGradient(agg.x, agg.y, 0, agg.x, agg.y, agg.size * 10);
                gradient.addColorStop(0, 'rgba(139, 0, 0, 0.9)');
                gradient.addColorStop(0.5, 'rgba(139, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(139, 0, 0, 0.2)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(agg.x, agg.y, agg.size * 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(agg.size, agg.x, agg.y + 3);
            }

            // Draw JDPs
            for (const jdp of jdps) {
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                // Triangle shape for JDP
                ctx.moveTo(jdp.x, jdp.y - jdp.radius);
                ctx.lineTo(jdp.x - jdp.radius, jdp.y + jdp.radius);
                ctx.lineTo(jdp.x + jdp.radius, jdp.y + jdp.radius);
                ctx.closePath();
                ctx.fill();
            }

            // Draw proteins
            for (const p of proteins) {
                if (p.state === PROTEIN_STATE.AGGREGATED) continue;

                let color;
                switch (p.state) {
                    case PROTEIN_STATE.NATIVE:
                        color = '#00ff88';
                        break;
                    case PROTEIN_STATE.MISFOLDED:
                        color = '#ff6b6b';
                        break;
                    case PROTEIN_STATE.NASCENT:
                        color = '#ffd93d';
                        break;
                    case PROTEIN_STATE.CHAPERONE_BOUND:
                        color = '#64ffda';
                        break;
                }

                ctx.fillStyle = color;
                ctx.beginPath();

                if (p.state === PROTEIN_STATE.NATIVE) {
                    // Compact, folded shape
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                } else if (p.state === PROTEIN_STATE.MISFOLDED) {
                    // Irregular, unfolded shape
                    ctx.moveTo(p.x + p.radius, p.y);
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const r = p.radius * (0.7 + Math.sin(i * 2.5) * 0.5);
                        ctx.lineTo(p.x + Math.cos(angle) * r, p.y + Math.sin(angle) * r);
                    }
                    ctx.closePath();
                } else {
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                }
                ctx.fill();

                // Draw hydrophobic patches (exposed regions)
                if (p.hydrophobicExposure > 0.3 && p.state !== PROTEIN_STATE.CHAPERONE_BOUND) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
                    const patchSize = p.radius * p.hydrophobicExposure * 0.5;
                    ctx.beginPath();
                    ctx.arc(p.x + p.radius * 0.5, p.y, patchSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw chaperones
            if (chaperonesEnabled) {
                for (const c of chaperones) {
                    // HSP70 body
                    const color = c.state === HSP70_STATE.ATP_BOUND ? '#64ffda' : '#ffd93d';
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Substrate binding domain (lid)
                    ctx.strokeStyle = c.state === HSP70_STATE.ATP_BOUND ? '#4dd4b4' : '#ccaa00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    if (c.lidOpen) {
                        ctx.arc(c.x, c.y, c.radius + 4, -0.5, 0.5);
                    } else {
                        ctx.arc(c.x, c.y, c.radius + 4, 0, Math.PI * 2);
                    }
                    ctx.stroke();

                    // Draw bound substrate inside
                    if (c.boundSubstrate) {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(c.x, c.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('70', c.x, c.y + 3);
                }
            }
        }

        function animate() {
            if (running) {
                updateSimulation();
            }
            draw();
            animationId = requestAnimationFrame(animate);
        }

        function toggleSimulation() {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        }

        function resetSimulation() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        }

        function induceThermalStress() {
            // Temporarily increase stress dramatically
            const originalStress = params.stressLevel;
            params.stressLevel = 0.8;

            // Misfold many native proteins
            for (const p of proteins) {
                if (p.state === PROTEIN_STATE.NATIVE && Math.random() < 0.5) {
                    p.state = PROTEIN_STATE.MISFOLDED;
                    p.hydrophobicExposure = 0.5 + Math.random() * 0.5;
                    p.misfoldTime = 0;
                }
            }

            setTimeout(() => {
                params.stressLevel = originalStress;
            }, 3000);
        }

        function toggleChaperones() {
            chaperonesEnabled = !chaperonesEnabled;
            if (!chaperonesEnabled) {
                // Release all bound proteins
                for (const c of chaperones) {
                    if (c.boundSubstrate) {
                        c.boundSubstrate.state = PROTEIN_STATE.MISFOLDED;
                        c.boundSubstrate.boundChaperone = null;
                        c.boundSubstrate = null;
                    }
                    c.state = HSP70_STATE.ATP_BOUND;
                }
            }
        }

        function showExplain() {
            document.getElementById('explainModal').classList.add('active');
        }

        function hideExplain() {
            document.getElementById('explainModal').classList.remove('active');
        }

        // Event listeners for controls
        document.getElementById('hsp70Count').addEventListener('input', (e) => {
            params.hsp70Count = parseInt(e.target.value);
            document.getElementById('hsp70Val').textContent = params.hsp70Count;

            // Adjust chaperone count
            while (chaperones.length < params.hsp70Count) {
                chaperones.push(createChaperone());
            }
            while (chaperones.length > params.hsp70Count) {
                const c = chaperones.pop();
                if (c.boundSubstrate) {
                    c.boundSubstrate.state = PROTEIN_STATE.MISFOLDED;
                    c.boundSubstrate.boundChaperone = null;
                }
            }
        });

        document.getElementById('synthesisRate').addEventListener('input', (e) => {
            params.synthesisRate = parseInt(e.target.value) / 100;
            document.getElementById('synthVal').textContent = params.synthesisRate.toFixed(2);
        });

        document.getElementById('stressLevel').addEventListener('input', (e) => {
            params.stressLevel = parseInt(e.target.value) / 100;
            document.getElementById('stressVal').textContent = params.stressLevel.toFixed(2);
        });

        document.getElementById('jdpActivity').addEventListener('input', (e) => {
            params.jdpActivity = parseInt(e.target.value) / 100;
            document.getElementById('jdpVal').textContent = params.jdpActivity.toFixed(2);
        });

        document.getElementById('atpLevel').addEventListener('input', (e) => {
            params.atpLevel = parseInt(e.target.value) / 100;
            document.getElementById('atpVal').textContent = params.atpLevel.toFixed(2);
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        initSimulation();
        animate();
    </script>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Chaperone Function</h2>
            <div class="modal-body">
                <p>Life operates through precise molecular machinery. This simulation models biochemical reactions and molecular interactions at the cellular level.</p>

                <h3>About This Simulation</h3>
                <p>Create a molecular chaperone model with folding assistance and aggregation prevention.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Enzyme Kinetics:</strong> Enzymes catalyze reactions following Michaelis-Menten kinetics, with rates determined by substrate concentration and enzyme affinity (Km).</li>
                    <li><strong>Lock and Key vs Induced Fit:</strong> Enzymes recognize substrates either through rigid complementarity (lock-key) or conformational changes upon binding (induced fit).</li>
                    <li><strong>Allosteric Regulation:</strong> Enzyme activity modulated by molecules binding at sites other than the active site, enabling sophisticated metabolic control.</li>
                    <li><strong>Signal Transduction:</strong> Cascades of molecular interactions that amplify and transmit signals from cell surface to nucleus.</li>
                </ul>

                <h3>Why It Matters</h3>
                <p>Molecular understanding enables drug design, metabolic engineering, and synthetic biology.</p>

                <h3>How to Explore</h3>
                <ul>
                    <li>Adjust the sliders to modify simulation parameters and observe how the system responds</li>
                    <li>Look for emergent patterns that arise from agent interactions</li>
                    <li>Try extreme parameter values to find phase transitions and tipping points</li>
                    <li>Compare the simulation behavior to real-world phenomena</li>
                </ul>

                <p class="modal-category"><em>Category: Biochemistry & Molecular Biology ‚Äî Exploring molecular mechanisms and biochemical pathways</em></p>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('explainModal');
        const explainBtn = document.getElementById('explainBtn');
        if (modal && explainBtn) {
            explainBtn.addEventListener('click', function() {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
            modal.querySelector('.modal-close').addEventListener('click', function() {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            });
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
        }
    });
    </script>

</body>
</html>
