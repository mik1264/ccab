<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attention Networks | NetLogo-Style Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: #e0e0e0;
        }
        h1 { font-size: 1.6rem; margin-bottom: 10px; color: #ffaa44; text-shadow: 0 0 15px rgba(255, 170, 68, 0.5); }
        .simulation-container { display: flex; gap: 20px; max-width: 1200px; width: 100%; flex-wrap: wrap; justify-content: center; }
        .canvas-panel { background: rgba(20, 20, 40, 0.9); border-radius: 15px; padding: 15px; }
        canvas { border-radius: 10px; display: block; background: #000; }
        .control-panel { background: rgba(20, 20, 40, 0.95); border-radius: 15px; padding: 20px; min-width: 280px; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; margin-bottom: 6px; color: #ffaa44; font-weight: 500; font-size: 0.9rem; }
        .slider-container { display: flex; align-items: center; gap: 10px; }
        input[type="range"] { flex: 1; height: 6px; border-radius: 3px; background: linear-gradient(to right, #ffaa44, #dd8822); outline: none; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #ffaa44; cursor: pointer; }
        .button-group { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        button { flex: 1; padding: 10px 15px; border: none; border-radius: 8px; font-size: 0.9rem; font-weight: 600; cursor: pointer; min-width: 80px; }
        .start-btn { background: linear-gradient(135deg, #ffaa44 0%, #dd8822 100%); color: #000; }
        .reset-btn { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%); color: white; }
        .stats-panel { background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; margin-top: 15px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; }
        .stat-label { color: #aaa; }
        .stat-value { color: #ffaa44; font-weight: bold; }
        .theory-box { background: rgba(255, 170, 68, 0.1); border-left: 3px solid #ffaa44; padding: 12px; margin-top: 15px; border-radius: 0 8px 8px 0; font-size: 0.8rem; line-height: 1.5; }
        .back-link { position: fixed; top: 15px; left: 15px; color: #ffaa44; text-decoration: none; font-size: 0.9rem; opacity: 0.8; }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            padding: 20px;
            overflow-y: auto;
        }
        .modal-overlay.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            border-radius: 20px;
            padding: 35px;
            max-width: 750px;
            width: 100%;
            margin: 40px auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .modal-close:hover {
            color: #fff;
            background: rgba(255,255,255,0.2);
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 25px;
            font-size: 1.6rem;
            padding-right: 50px;
            line-height: 1.3;
        }
        .modal-body {
            color: #d1d5db;
            line-height: 1.9;
            font-size: 1rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 28px 0 14px 0;
            font-size: 1.15rem;
            font-weight: 600;
        }
        .modal-body p {
            margin-bottom: 16px;
        }
        .modal-body ul {
            margin: 12px 0 18px 24px;
        }
        .modal-body li {
            margin-bottom: 10px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: italic;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: #fbbf24;
            font-size: 0.9em;
        }
        .modal-category {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>üéØ Attention Networks Simulation</h1>

    <div class="simulation-container">
        <div class="canvas-panel">
            <canvas id="simCanvas" width="550" height="550"></canvas>
        </div>

        <div class="control-panel">
            <div class="button-group">
                <button class="start-btn" id="startBtn">Start</button>
                <button class="reset-btn" id="resetBtn">Reset</button>
                <button id="explainBtn" class="explain-btn">üìö Explain This Simulation</button>
            </div>

            <div class="control-group">
                <label>Target Salience: <span id="salienceVal">1.0</span></label>
                <div class="slider-container">
                    <input type="range" id="salience" min="20" max="200" value="100">
                </div>
            </div>

            <div class="control-group">
                <label>Distractor Count: <span id="distractorVal">5</span></label>
                <div class="slider-container">
                    <input type="range" id="distractor" min="0" max="15" value="5">
                </div>
            </div>

            <div class="control-group">
                <label>Top-Down Bias: <span id="biasVal">1.0</span></label>
                <div class="slider-container">
                    <input type="range" id="bias" min="0" max="200" value="100">
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Cycle:</span>
                    <span class="stat-value" id="generation">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Focus Location:</span>
                    <span class="stat-value" id="focusLoc">Center</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Target Detected:</span>
                    <span class="stat-value" id="detected">No</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Reaction Time:</span>
                    <span class="stat-value" id="reactionTime">- ms</span>
                </div>
            </div>

            <div class="theory-box">
                <strong>Attention Networks:</strong><br>
                Alerting (arousal/vigilance), Orienting (spatial selection), Executive (conflict resolution).
                Bottom-up salience map + top-down goals compete for attentional focus.
                FEF and parietal cortex guide spatial attention; PFC mediates executive control.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        let running = false;
        let generation = 0;
        let animationId = null;

        let params = {
            salience: 1.0,
            distractorCount: 5,
            topDownBias: 1.0
        };

        // Visual field
        const FIELD_SIZE = 10;
        let visualField = [];
        let salienceMap = [];
        let priorityMap = [];

        // Target and distractors
        let target = null;
        let distractors = [];

        // Attention spotlight
        let attention = { x: FIELD_SIZE/2, y: FIELD_SIZE/2, radius: 2 };
        let targetDetected = false;
        let detectionTime = 0;
        let searchStartTime = 0;

        // Brain network activity
        let networks = {
            fef: 0,        // Frontal Eye Fields
            ppc: 0,        // Posterior Parietal Cortex
            acc: 0,        // Anterior Cingulate
            dlpfc: 0,      // Dorsolateral PFC
            v4: 0,         // Visual area V4
            pulvinar: 0    // Thalamic pulvinar
        };

        function init() {
            generation = 0;
            targetDetected = false;
            detectionTime = 0;

            // Reset attention to center
            attention = { x: FIELD_SIZE/2, y: FIELD_SIZE/2, radius: 2 };

            // Create visual field
            visualField = [];
            for (let y = 0; y < FIELD_SIZE; y++) {
                for (let x = 0; x < FIELD_SIZE; x++) {
                    visualField.push({ x, y, content: 'empty', activity: 0 });
                }
            }

            // Place target
            target = {
                x: Math.floor(Math.random() * FIELD_SIZE),
                y: Math.floor(Math.random() * FIELD_SIZE),
                type: 'target'
            };
            getCell(target.x, target.y).content = 'target';

            // Place distractors
            distractors = [];
            for (let i = 0; i < params.distractorCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * FIELD_SIZE);
                    y = Math.floor(Math.random() * FIELD_SIZE);
                } while (getCell(x, y).content !== 'empty');

                distractors.push({ x, y, type: 'distractor' });
                getCell(x, y).content = 'distractor';
            }

            // Initialize maps
            salienceMap = new Array(FIELD_SIZE * FIELD_SIZE).fill(0);
            priorityMap = new Array(FIELD_SIZE * FIELD_SIZE).fill(0);

            // Reset networks
            for (const key in networks) networks[key] = 0;

            searchStartTime = generation;
            updateUI();
            draw();
        }

        function getCell(x, y) {
            return visualField[y * FIELD_SIZE + x];
        }

        function update() {
            generation++;

            // Update salience map (bottom-up)
            updateSalienceMap();

            // Update priority map (salience + top-down)
            updatePriorityMap();

            // Update attention position
            updateAttention();

            // Check for target detection
            checkDetection();

            // Update brain networks
            updateNetworks();

            updateUI();
        }

        function updateSalienceMap() {
            for (let i = 0; i < visualField.length; i++) {
                const cell = visualField[i];
                let salience = 0;

                if (cell.content === 'target') {
                    salience = params.salience * 1.5;
                } else if (cell.content === 'distractor') {
                    salience = 0.8;
                }

                // Feature contrast (pop-out)
                if (cell.content === 'target') {
                    salience *= 1 + (1 / (1 + params.distractorCount * 0.2));
                }

                salienceMap[i] = salience;
            }
        }

        function updatePriorityMap() {
            for (let i = 0; i < visualField.length; i++) {
                const cell = visualField[i];

                // Combine bottom-up salience with top-down bias
                let priority = salienceMap[i];

                // Top-down bias towards target features
                if (cell.content === 'target') {
                    priority += params.topDownBias * 0.5;
                }

                // Attentional boost at current focus
                const dx = cell.x - attention.x;
                const dy = cell.y - attention.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < attention.radius) {
                    priority *= 1.5;
                    cell.activity = Math.min(1, priority);
                } else {
                    cell.activity *= 0.8;
                }

                priorityMap[i] = priority;
            }
        }

        function updateAttention() {
            if (targetDetected) return;

            // Find highest priority location
            let maxPriority = 0;
            let maxX = attention.x;
            let maxY = attention.y;

            for (let i = 0; i < visualField.length; i++) {
                const cell = visualField[i];
                if (priorityMap[i] > maxPriority) {
                    maxPriority = priorityMap[i];
                    maxX = cell.x;
                    maxY = cell.y;
                }
            }

            // Smooth movement towards highest priority
            attention.x += (maxX - attention.x) * 0.15;
            attention.y += (maxY - attention.y) * 0.15;

            // Some randomness (saccade variability)
            attention.x += (Math.random() - 0.5) * 0.3;
            attention.y += (Math.random() - 0.5) * 0.3;

            // Clamp
            attention.x = Math.max(0, Math.min(FIELD_SIZE - 1, attention.x));
            attention.y = Math.max(0, Math.min(FIELD_SIZE - 1, attention.y));
        }

        function checkDetection() {
            if (targetDetected) return;

            const dx = target.x - attention.x;
            const dy = target.y - attention.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < attention.radius) {
                targetDetected = true;
                detectionTime = generation - searchStartTime;
            }
        }

        function updateNetworks() {
            // FEF - saccade planning based on priority map
            let fefInput = 0;
            for (const p of priorityMap) fefInput += p;
            fefInput /= priorityMap.length;
            networks.fef += (fefInput - networks.fef) * 0.2;

            // PPC - spatial attention based on salience
            let ppcInput = 0;
            for (const s of salienceMap) ppcInput += s;
            ppcInput /= salienceMap.length;
            networks.ppc += (ppcInput * params.salience - networks.ppc) * 0.15;

            // ACC - conflict monitoring (more distractors = more conflict)
            networks.acc += ((params.distractorCount / 15) - networks.acc) * 0.1;

            // DLPFC - top-down control
            networks.dlpfc += (params.topDownBias * 0.5 - networks.dlpfc) * 0.12;

            // V4 - enhanced visual processing at attended location
            let v4Input = 0;
            for (const cell of visualField) {
                if (cell.activity > 0.5) v4Input += cell.activity;
            }
            networks.v4 += (v4Input * 0.2 - networks.v4) * 0.15;

            // Pulvinar - thalamic gating
            networks.pulvinar += ((networks.fef + networks.ppc) * 0.3 - networks.pulvinar) * 0.1;
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawVisualField();
            drawAttentionSpotlight();
            drawMaps();
            drawBrainNetworks();
        }

        function drawVisualField() {
            const offsetX = 50, offsetY = 50;
            const cellSize = 30;

            for (const cell of visualField) {
                const x = offsetX + cell.x * cellSize;
                const y = offsetY + cell.y * cellSize;

                // Background based on activity
                ctx.fillStyle = `rgba(50, 50, 80, ${0.3 + cell.activity * 0.5})`;
                ctx.fillRect(x, y, cellSize - 2, cellSize - 2);

                // Content
                if (cell.content === 'target') {
                    ctx.fillStyle = '#ffaa44';
                    ctx.beginPath();
                    ctx.arc(x + cellSize/2, y + cellSize/2, 10, 0, Math.PI * 2);
                    ctx.fill();
                } else if (cell.content === 'distractor') {
                    ctx.fillStyle = '#6688aa';
                    ctx.fillRect(x + 5, y + 5, cellSize - 12, cellSize - 12);
                }
            }

            ctx.fillStyle = '#888';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Visual Field', offsetX + FIELD_SIZE * cellSize / 2, offsetY + FIELD_SIZE * cellSize + 20);
        }

        function drawAttentionSpotlight() {
            const offsetX = 50, offsetY = 50;
            const cellSize = 30;

            const ax = offsetX + attention.x * cellSize + cellSize/2;
            const ay = offsetY + attention.y * cellSize + cellSize/2;
            const ar = attention.radius * cellSize;

            // Spotlight gradient
            const gradient = ctx.createRadialGradient(ax, ay, 0, ax, ay, ar);
            gradient.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
            gradient.addColorStop(0.7, 'rgba(255, 200, 100, 0.1)');
            gradient.addColorStop(1, 'transparent');

            ctx.beginPath();
            ctx.arc(ax, ay, ar, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Focus point
            ctx.beginPath();
            ctx.arc(ax, ay, 5, 0, Math.PI * 2);
            ctx.fillStyle = targetDetected ? '#88ff88' : '#ff8844';
            ctx.fill();
        }

        function drawMaps() {
            const baseX = 380, baseY = 50;
            const mapSize = 8;
            const cellSize = 15;

            // Salience Map
            ctx.fillStyle = '#888';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Salience Map', baseX + mapSize * cellSize / 2, baseY - 5);

            for (let y = 0; y < FIELD_SIZE; y++) {
                for (let x = 0; x < FIELD_SIZE; x++) {
                    const val = salienceMap[y * FIELD_SIZE + x];
                    const px = baseX + (x / FIELD_SIZE) * mapSize * cellSize;
                    const py = baseY + (y / FIELD_SIZE) * mapSize * cellSize;
                    ctx.fillStyle = `rgba(255, 100, 100, ${Math.min(1, val)})`;
                    ctx.fillRect(px, py, cellSize * FIELD_SIZE / mapSize - 1, cellSize * FIELD_SIZE / mapSize - 1);
                }
            }

            // Priority Map
            const priorY = baseY + mapSize * cellSize + 30;
            ctx.fillStyle = '#888';
            ctx.fillText('Priority Map', baseX + mapSize * cellSize / 2, priorY - 5);

            for (let y = 0; y < FIELD_SIZE; y++) {
                for (let x = 0; x < FIELD_SIZE; x++) {
                    const val = priorityMap[y * FIELD_SIZE + x];
                    const px = baseX + (x / FIELD_SIZE) * mapSize * cellSize;
                    const py = priorY + (y / FIELD_SIZE) * mapSize * cellSize;
                    ctx.fillStyle = `rgba(255, 200, 100, ${Math.min(1, val)})`;
                    ctx.fillRect(px, py, cellSize * FIELD_SIZE / mapSize - 1, cellSize * FIELD_SIZE / mapSize - 1);
                }
            }
        }

        function drawBrainNetworks() {
            const regions = [
                { name: 'FEF', x: 150, y: 420, key: 'fef' },
                { name: 'PPC', x: 250, y: 420, key: 'ppc' },
                { name: 'ACC', x: 350, y: 420, key: 'acc' },
                { name: 'DLPFC', x: 150, y: 490, key: 'dlpfc' },
                { name: 'V4', x: 250, y: 490, key: 'v4' },
                { name: 'Pulvinar', x: 350, y: 490, key: 'pulvinar' }
            ];

            ctx.fillStyle = '#888';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Attention Network Activity', 250, 395);

            for (const region of regions) {
                const activity = networks[region.key];
                const size = 25 + activity * 15;

                ctx.beginPath();
                ctx.arc(region.x, region.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 170, 68, ${0.3 + activity * 0.7})`;
                ctx.fill();
                ctx.strokeStyle = '#dd8822';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = '9px Arial';
                ctx.fillText(region.name, region.x, region.y + 4);
            }
        }

        function updateUI() {
            document.getElementById('generation').textContent = generation;

            const locX = attention.x < FIELD_SIZE/3 ? 'Left' :
                        attention.x > 2*FIELD_SIZE/3 ? 'Right' : 'Center';
            const locY = attention.y < FIELD_SIZE/3 ? 'Top' :
                        attention.y > 2*FIELD_SIZE/3 ? 'Bottom' : 'Middle';
            document.getElementById('focusLoc').textContent = `${locY}-${locX}`;

            document.getElementById('detected').textContent = targetDetected ? 'Yes ‚úì' : 'No';
            document.getElementById('reactionTime').textContent =
                targetDetected ? (detectionTime * 16.67).toFixed(0) + ' ms' : '- ms';
        }

        function animate() {
            if (!running) return;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) animate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);
            init();
        });

        document.getElementById('salience').addEventListener('input', (e) => {
            params.salience = parseInt(e.target.value) / 100;
            document.getElementById('salienceVal').textContent = params.salience.toFixed(1);
        });

        document.getElementById('distractor').addEventListener('input', (e) => {
            params.distractorCount = parseInt(e.target.value);
            document.getElementById('distractorVal').textContent = params.distractorCount;
        });

        document.getElementById('bias').addEventListener('input', (e) => {
            params.topDownBias = parseInt(e.target.value) / 100;
            document.getElementById('biasVal').textContent = params.topDownBias.toFixed(1);
        });

        init();
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                modal.classList.remove('active');
            }
        });
    }

    </script>


    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Social Bonding</h2>
            <div class="modal-body">
                <p>The brain processes information through networks of neurons that fire in coordinated patterns. This simulation explores neural computation and emergent behavior.</p>

                <h3>About This Simulation</h3>
                <p>Implement an attachment formation model with oxytocin and dopamine interactions.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Neural Networks:</strong> Interconnected neurons that process information through synaptic connections, forming the basis of learning and memory.</li>
                    <li><strong>Hebbian Learning:</strong> "Neurons that fire together, wire together" - synaptic connections strengthen when pre and post-synaptic neurons are active simultaneously.</li>
                    <li><strong>Emergent Behavior:</strong> Complex behaviors arising from simple rules followed by many interacting agents or neurons.</li>
                    <li><strong>Oscillations & Rhythms:</strong> Coordinated neural activity patterns that underlie various brain states and cognitive functions.</li>
                </ul>

                <h3>Why It Matters</h3>
                <p>Neural modeling advances AI, brain-computer interfaces, and treatments for neurological disorders.</p>

                <h3>How to Explore</h3>
                <ul>
                    <li>Adjust the sliders to modify simulation parameters and observe how the system responds</li>
                    <li>Look for emergent patterns that arise from agent interactions</li>
                    <li>Try extreme parameter values to find phase transitions and tipping points</li>
                    <li>Compare the simulation behavior to real-world phenomena</li>
                </ul>

                <p class="modal-category"><em>Category: Neuroscience & Behavior ‚Äî Exploring neural systems and behavioral patterns</em></p>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('explainModal');
        const explainBtn = document.getElementById('explainBtn');
        if (modal && explainBtn) {
            explainBtn.addEventListener('click', function() {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
            modal.querySelector('.modal-close').addEventListener('click', function() {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            });
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
        }
    });
    </script>

</body>
</html>
