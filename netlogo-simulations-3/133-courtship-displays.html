<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Courtship Displays - NetLogo Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #e91e63;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .simulation-area {
            background: #1e1e2e;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            background: #0a0a15;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .controls {
            background: #1e1e2e;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #e91e63;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e91e63;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            text-align: right;
            color: #e91e63;
            font-weight: bold;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        #startBtn {
            background: linear-gradient(135deg, #e91e63, #c2185b);
            color: white;
        }

        #resetBtn {
            background: linear-gradient(135deg, #444, #555);
            color: white;
        }

        .stats {
            background: #252535;
            border-radius: 10px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #e91e63;
            font-weight: bold;
        }

        .theory-box {
            background: linear-gradient(135deg, #252535, #2a2a3a);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #e91e63;
        }

        .theory-box h4 {
            color: #e91e63;
            margin-bottom: 10px;
        }

        .theory-box p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .pairing-list {
            max-height: 100px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .pairing-item {
            padding: 5px 10px;
            margin: 3px 0;
            background: rgba(233, 30, 99, 0.2);
            border-radius: 5px;
            font-size: 0.8em;
        }
    
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            padding: 20px;
            overflow-y: auto;
        }
        .modal-overlay.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            border-radius: 20px;
            padding: 35px;
            max-width: 750px;
            width: 100%;
            margin: 40px auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .modal-close:hover {
            color: #fff;
            background: rgba(255,255,255,0.2);
        }
        .modal h2 {
            color: #00d9ff;
            margin-bottom: 25px;
            font-size: 1.6rem;
            padding-right: 50px;
            line-height: 1.3;
        }
        .modal-body {
            color: #d1d5db;
            line-height: 1.9;
            font-size: 1rem;
        }
        .modal-body h3 {
            color: #00ff88;
            margin: 28px 0 14px 0;
            font-size: 1.15rem;
            font-weight: 600;
        }
        .modal-body p {
            margin-bottom: 16px;
        }
        .modal-body ul {
            margin: 12px 0 18px 24px;
        }
        .modal-body li {
            margin-bottom: 10px;
        }
        .modal-body strong {
            color: #00d9ff;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: italic;
        }
        .modal-body code {
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: #fbbf24;
            font-size: 0.9em;
        }
        .modal-category {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíÉ Courtship Displays</h1>
        <p class="subtitle">Sexual Selection, Display Quality, and Mate Choice</p>

        <div class="main-content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="simCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>‚öôÔ∏è Parameters</h3>
                    <div class="control-group">
                        <label>Population Size</label>
                        <input type="range" id="popSize" min="10" max="40" step="2" value="20">
                        <div class="value"><span id="popSizeVal">20</span></div>
                    </div>
                    <div class="control-group">
                        <label>Display Effort</label>
                        <input type="range" id="displayEffort" min="0.2" max="1" step="0.1" value="0.6">
                        <div class="value"><span id="displayEffortVal">0.6</span></div>
                    </div>
                    <div class="control-group">
                        <label>Female Choosiness</label>
                        <input type="range" id="choosiness" min="0.1" max="1" step="0.1" value="0.5">
                        <div class="value"><span id="choosinessVal">0.5</span></div>
                    </div>
                    <div class="control-group">
                        <label>Display Cost</label>
                        <input type="range" id="displayCost" min="0" max="0.5" step="0.05" value="0.1">
                        <div class="value"><span id="displayCostVal">0.1</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üéÆ Controls</h3>
                    <div class="button-group">
                        <button id="startBtn">Start</button>
                        <button id="resetBtn">Reset</button>
                <button id="explainBtn" class="explain-btn">üìö Explain This Simulation</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìä Statistics</h3>
                    <div class="stats">
                        <div class="stat-row">
                            <span class="stat-label">Generation:</span>
                            <span class="stat-value" id="generation">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Displaying Males:</span>
                            <span class="stat-value" id="displayingMales">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Successful Pairings:</span>
                            <span class="stat-value" id="pairings">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Avg Display Quality:</span>
                            <span class="stat-value" id="avgQuality">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Rejected Males:</span>
                            <span class="stat-value" id="rejections">0</span>
                        </div>
                    </div>
                    <div class="pairing-list" id="pairingList"></div>
                </div>

                <div class="theory-box">
                    <h4>üìö Sexual Selection Theory</h4>
                    <p>
                        Males compete through elaborate displays (plumage, dance,
                        song) that honestly signal genetic quality. The handicap
                        principle suggests costly displays are reliable fitness
                        indicators. Females choose males with the best displays,
                        driving trait evolution.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let running = false;
        let generation = 0;

        // Agents
        let males = [];
        let females = [];
        let pairings = 0;
        let rejections = 0;
        let recentPairings = [];

        // Parameters
        function getParams() {
            return {
                popSize: parseInt(document.getElementById('popSize').value),
                displayEffort: parseFloat(document.getElementById('displayEffort').value),
                choosiness: parseFloat(document.getElementById('choosiness').value),
                displayCost: parseFloat(document.getElementById('displayCost').value)
            };
        }

        // Update parameter displays
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', (e) => {
                const valSpan = document.getElementById(e.target.id + 'Val');
                if (valSpan) {
                    valSpan.textContent = e.target.value;
                }
            });
        });

        function initAgents() {
            males = [];
            females = [];
            const params = getParams();
            const halfPop = Math.floor(params.popSize / 2);

            // Create males with varying quality
            for (let i = 0; i < halfPop; i++) {
                males.push({
                    id: i,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0,
                    quality: 0.3 + Math.random() * 0.7,
                    displayIntensity: 0,
                    energy: 1,
                    displaying: false,
                    paired: false,
                    displayPhase: Math.random() * Math.PI * 2,
                    tailLength: 20 + Math.random() * 30,
                    plumageHue: Math.random() * 60 + 330 // Red-magenta range
                });
            }

            // Create females
            for (let i = 0; i < halfPop; i++) {
                females.push({
                    id: i,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0,
                    threshold: 0.3 + Math.random() * 0.5,
                    paired: false,
                    evaluating: null,
                    evaluationTime: 0,
                    impressed: 0
                });
            }
        }

        function update() {
            if (!running) return;

            generation++;
            const params = getParams();

            // Update males
            for (let male of males) {
                if (male.paired) continue;

                // Find nearby unpaired females
                let nearestFemale = null;
                let nearestDist = Infinity;

                for (let female of females) {
                    if (female.paired) continue;

                    const dx = female.x - male.x;
                    const dy = female.y - male.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestFemale = female;
                    }
                }

                if (nearestFemale && nearestDist < 150) {
                    // Start displaying
                    male.displaying = true;
                    male.displayIntensity = Math.min(1,
                        male.quality * params.displayEffort * male.energy);
                    male.displayPhase += 0.1;

                    // Move toward female (but not too close)
                    if (nearestDist > 50) {
                        const dx = nearestFemale.x - male.x;
                        const dy = nearestFemale.y - male.y;
                        male.vx += (dx / nearestDist) * 0.1;
                        male.vy += (dy / nearestDist) * 0.1;
                    }

                    // Display is costly
                    male.energy -= params.displayCost * male.displayIntensity * 0.01;
                } else {
                    male.displaying = false;
                    male.displayIntensity *= 0.9;

                    // Random movement
                    male.vx += (Math.random() - 0.5) * 0.3;
                    male.vy += (Math.random() - 0.5) * 0.3;

                    // Recover energy
                    male.energy = Math.min(1, male.energy + 0.005);
                }

                // Speed limit
                const speed = Math.sqrt(male.vx * male.vx + male.vy * male.vy);
                if (speed > 2) {
                    male.vx = (male.vx / speed) * 2;
                    male.vy = (male.vy / speed) * 2;
                }

                male.x += male.vx;
                male.y += male.vy;

                // Boundaries
                if (male.x < 30) male.x = 30;
                if (male.x > canvas.width - 30) male.x = canvas.width - 30;
                if (male.y < 30) male.y = 30;
                if (male.y > canvas.height - 30) male.y = canvas.height - 30;

                male.vx *= 0.95;
                male.vy *= 0.95;
            }

            // Update females
            for (let female of females) {
                if (female.paired) continue;

                // Find displaying males nearby
                let bestMale = null;
                let bestDisplay = 0;

                for (let male of males) {
                    if (male.paired || !male.displaying) continue;

                    const dx = male.x - female.x;
                    const dy = male.y - female.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 80) {
                        // Evaluate display
                        const perceivedQuality = male.displayIntensity * (1 - dist / 100);
                        if (perceivedQuality > bestDisplay) {
                            bestDisplay = perceivedQuality;
                            bestMale = male;
                        }
                    }
                }

                if (bestMale) {
                    if (female.evaluating !== bestMale) {
                        female.evaluating = bestMale;
                        female.evaluationTime = 0;
                        female.impressed = 0;
                    }

                    female.evaluationTime++;
                    female.impressed += bestDisplay * 0.02;

                    // Decision time
                    if (female.evaluationTime > 60) {
                        const threshold = female.threshold * params.choosiness;

                        if (female.impressed > threshold && bestMale.displayIntensity > 0.3) {
                            // Accept!
                            female.paired = true;
                            bestMale.paired = true;
                            pairings++;
                            recentPairings.push({
                                male: bestMale.id,
                                quality: bestMale.quality.toFixed(2),
                                time: generation
                            });
                            if (recentPairings.length > 5) recentPairings.shift();
                        } else {
                            // Reject
                            rejections++;
                            female.evaluating = null;
                            female.evaluationTime = 0;
                            female.impressed = 0;
                        }
                    }
                } else {
                    female.evaluating = null;
                    female.evaluationTime = 0;

                    // Random movement
                    female.vx += (Math.random() - 0.5) * 0.2;
                    female.vy += (Math.random() - 0.5) * 0.2;
                }

                // Speed limit
                const speed = Math.sqrt(female.vx * female.vx + female.vy * female.vy);
                if (speed > 1.5) {
                    female.vx = (female.vx / speed) * 1.5;
                    female.vy = (female.vy / speed) * 1.5;
                }

                female.x += female.vx;
                female.y += female.vy;

                // Boundaries
                if (female.x < 30) female.x = 30;
                if (female.x > canvas.width - 30) female.x = canvas.width - 30;
                if (female.y < 30) female.y = 30;
                if (female.y > canvas.height - 30) female.y = canvas.height - 30;

                female.vx *= 0.95;
                female.vy *= 0.95;
            }

            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            const w = canvas.width;
            const h = canvas.height;

            // Background - forest floor
            ctx.fillStyle = '#1a2a1a';
            ctx.fillRect(0, 0, w, h);

            // Draw some foliage
            ctx.fillStyle = '#2a3a2a';
            for (let i = 0; i < 20; i++) {
                const x = (i * 137) % w;
                const y = (i * 89) % h;
                ctx.beginPath();
                ctx.ellipse(x, y, 30, 15, (i * 0.5), 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw evaluation lines
            for (let female of females) {
                if (female.evaluating && !female.paired) {
                    ctx.strokeStyle = `rgba(233, 30, 99, ${female.impressed})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(female.x, female.y);
                    ctx.lineTo(female.evaluating.x, female.evaluating.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Heart indicator
                    if (female.impressed > 0.5) {
                        const mx = (female.x + female.evaluating.x) / 2;
                        const my = (female.y + female.evaluating.y) / 2;
                        ctx.fillStyle = '#e91e63';
                        ctx.font = `${12 + female.impressed * 10}px Arial`;
                        ctx.fillText('‚ù§Ô∏è', mx - 8, my);
                    }
                }
            }

            // Draw males
            for (let male of males) {
                const x = male.x;
                const y = male.y;

                if (male.paired) {
                    // Paired male - simplified
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    continue;
                }

                // Display intensity affects visual
                const intensity = male.displayIntensity;

                // Tail feathers (peacock-like)
                if (male.displaying) {
                    const numFeathers = 7;
                    const spreadAngle = Math.PI * 0.7;
                    const baseAngle = -Math.PI / 2;

                    for (let i = 0; i < numFeathers; i++) {
                        const angle = baseAngle - spreadAngle / 2 + (i / (numFeathers - 1)) * spreadAngle;
                        const featherLength = male.tailLength * (0.8 + intensity * 0.4);
                        const wave = Math.sin(male.displayPhase + i * 0.5) * 5 * intensity;

                        const endX = x + Math.cos(angle) * featherLength + wave;
                        const endY = y + Math.sin(angle) * featherLength;

                        // Feather shaft
                        ctx.strokeStyle = `hsl(${male.plumageHue}, 70%, ${30 + intensity * 30}%)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Eye spot
                        const eyeSize = 8 * male.quality * intensity;
                        ctx.fillStyle = `hsl(${male.plumageHue}, 80%, ${40 + intensity * 30}%)`;
                        ctx.beginPath();
                        ctx.arc(endX, endY, eyeSize, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(endX, endY, eyeSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(endX - eyeSize * 0.15, endY - eyeSize * 0.15, eyeSize * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Body
                ctx.fillStyle = `hsl(${male.plumageHue}, 60%, ${25 + male.quality * 25}%)`;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = `hsl(${male.plumageHue + 20}, 70%, ${35 + male.quality * 25}%)`;
                ctx.beginPath();
                ctx.arc(x, y - 8, 6, 0, Math.PI * 2);
                ctx.fill();

                // Crest
                ctx.strokeStyle = `hsl(${male.plumageHue}, 80%, 50%)`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const angle = -Math.PI / 2 + (i - 1) * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(x, y - 12);
                    ctx.lineTo(x + Math.cos(angle) * 8, y - 12 + Math.sin(angle) * 8 - 5);
                    ctx.stroke();
                }

                // Quality indicator
                if (male.displaying) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Q:${(male.quality * 100).toFixed(0)}`, x, y + 25);
                }
            }

            // Draw females
            for (let female of females) {
                const x = female.x;
                const y = female.y;

                if (female.paired) {
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#e91e63';
                    ctx.font = '12px Arial';
                    ctx.fillText('üíï', x - 8, y - 15);
                    continue;
                }

                // Body (more muted colors)
                ctx.fillStyle = '#8b7355';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#9b8365';
                ctx.beginPath();
                ctx.arc(x, y - 6, 5, 0, Math.PI * 2);
                ctx.fill();

                // Evaluation state
                if (female.evaluating) {
                    ctx.fillStyle = `rgba(233, 30, 99, ${0.3 + female.impressed * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 15 + female.impressed * 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Info panel
            ctx.fillStyle = 'rgba(30, 30, 50, 0.9)';
            ctx.beginPath();
            ctx.roundRect(10, 10, 180, 60, 10);
            ctx.fill();

            ctx.fillStyle = '#e91e63';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Courtship Display', 20, 28);

            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText(`Unpaired: ‚ôÇ${males.filter(m => !m.paired).length} ‚ôÄ${females.filter(f => !f.paired).length}`, 20, 48);
            ctx.fillText(`Paired: ${pairings}`, 20, 62);
        }

        function updateStats() {
            const displayingMales = males.filter(m => m.displaying && !m.paired).length;
            const avgQuality = males.length > 0 ?
                males.reduce((sum, m) => sum + m.quality, 0) / males.length : 0;

            document.getElementById('generation').textContent = generation;
            document.getElementById('displayingMales').textContent = displayingMales;
            document.getElementById('pairings').textContent = pairings;
            document.getElementById('avgQuality').textContent = avgQuality.toFixed(2);
            document.getElementById('rejections').textContent = rejections;

            // Update pairing list
            const listEl = document.getElementById('pairingList');
            listEl.innerHTML = recentPairings.map(p => `
                <div class="pairing-item">
                    Male #${p.male} (Q:${p.quality}) @ Gen ${p.time}
                </div>
            `).join('');
        }

        function reset() {
            running = false;
            generation = 0;
            pairings = 0;
            rejections = 0;
            recentPairings = [];
            initAgents();
            updateStats();
            draw();
            document.getElementById('startBtn').textContent = 'Start';
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        initAgents();
        draw();
    </script>


    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìä Courtship Displays</h2>
            <div class="modal-body">
                <p>The brain processes information through networks of neurons that fire in coordinated patterns. This simulation explores neural computation and emergent behavior.</p>

                <h3>About This Simulation</h3>
                <p>Implement a courtship behavior model with signal production and receiver assessment.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Neural Networks:</strong> Interconnected neurons that process information through synaptic connections, forming the basis of learning and memory.</li>
                    <li><strong>Hebbian Learning:</strong> "Neurons that fire together, wire together" - synaptic connections strengthen when pre and post-synaptic neurons are active simultaneously.</li>
                    <li><strong>Emergent Behavior:</strong> Complex behaviors arising from simple rules followed by many interacting agents or neurons.</li>
                    <li><strong>Oscillations & Rhythms:</strong> Coordinated neural activity patterns that underlie various brain states and cognitive functions.</li>
                </ul>

                <h3>Why It Matters</h3>
                <p>Neural modeling advances AI, brain-computer interfaces, and treatments for neurological disorders.</p>

                <h3>How to Explore</h3>
                <ul>
                    <li>Adjust the sliders to modify simulation parameters and observe how the system responds</li>
                    <li>Look for emergent patterns that arise from agent interactions</li>
                    <li>Try extreme parameter values to find phase transitions and tipping points</li>
                    <li>Compare the simulation behavior to real-world phenomena</li>
                </ul>

                <p class="modal-category"><em>Category: Neuroscience & Behavior ‚Äî Exploring neural systems and behavioral patterns</em></p>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('explainModal');
        const explainBtn = document.getElementById('explainBtn');
        if (modal && explainBtn) {
            explainBtn.addEventListener('click', function() {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
            modal.querySelector('.modal-close').addEventListener('click', function() {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            });
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
        }
    });
    </script>

    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
