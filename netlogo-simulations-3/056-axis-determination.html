<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axis Determination - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; }
        canvas { background: rgba(0,0,0,0.3); border-radius: 8px; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #06b6d4; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        .value-display { font-size: 0.75rem; color: #06b6d4; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #06b6d4; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #0891b2; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-top: 15px; }
        .stats div { margin-bottom: 5px; }
        .stats span { color: #06b6d4; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #06b6d4; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .theory { background: rgba(6,182,212,0.1); padding: 10px; border-radius: 5px; font-size: 0.7rem; margin-top: 15px; border-left: 3px solid #06b6d4; }
    </style>
</head>
<body>
    <a href="../netlogo-simulations/index.html" class="back-link">‚Üê Back to Simulations</a>

    <div id="container">
        <div id="main-area">
            <canvas id="canvas"></canvas>
        </div>

        <div id="controls">
            <h1>üß≠ Axis Determination</h1>
            <p class="description">
                Embryonic axes (anterior-posterior, dorsal-ventral) arise from maternal
                gradients and symmetry-breaking events. In Drosophila, bicoid mRNA
                localizes anteriorly; nanos posteriorly.
            </p>

            <div class="control-group">
                <label>Bicoid Gradient: <span class="value-display" id="bicoidValue">1.0</span></label>
                <input type="range" id="bicoidSlider" min="0" max="2" step="0.1" value="1.0">
                <div style="font-size: 0.65rem; color: #666;">Anterior determinant</div>
            </div>

            <div class="control-group">
                <label>Nanos Gradient: <span class="value-display" id="nanosValue">1.0</span></label>
                <input type="range" id="nanosSlider" min="0" max="2" step="0.1" value="1.0">
                <div style="font-size: 0.65rem; color: #666;">Posterior determinant</div>
            </div>

            <div class="control-group">
                <label>Diffusion Rate: <span class="value-display" id="diffValue">0.1</span></label>
                <input type="range" id="diffSlider" min="0.01" max="0.3" step="0.01" value="0.1">
            </div>

            <div class="control-group">
                <label>Noise Level: <span class="value-display" id="noiseValue">0.05</span></label>
                <input type="range" id="noiseSlider" min="0" max="0.2" step="0.01" value="0.05">
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>AP Polarity: <span id="apPolarity">Symmetric</span></div>
                <div>Head Region: <span id="headRegion">0%</span></div>
                <div>Trunk Region: <span id="trunkRegion">0%</span></div>
                <div>Tail Region: <span id="tailRegion">0%</span></div>
            </div>

            <div class="theory">
                <strong>Drosophila AP Axis:</strong><br>
                ‚Ä¢ <b>Bicoid:</b> Anterior morphogen ‚Üí head structures<br>
                ‚Ä¢ <b>Nanos:</b> Posterior, represses hunchback ‚Üí abdomen<br>
                ‚Ä¢ <b>Gap genes:</b> Hunchback, Kr√ºppel, Giant, Knirps<br>
                Maternal-effect genes establish initial polarity
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 15;
            canvas.height = canvas.parentElement.clientHeight - 15;
        }
        resize();
        window.addEventListener('resize', resize);

        let running = false;
        let generation = 0;
        let cells = [];
        const NUM_CELLS = 80;

        let bicoidLevel = 1.0;
        let nanosLevel = 1.0;
        let diffusionRate = 0.1;
        let noiseLevel = 0.05;

        class Cell {
            constructor(position) {
                this.position = position;
                this.bicoid = 0;
                this.nanos = 0;
                this.hunchback = 0;
                this.kruppel = 0;
                this.giant = 0;
                this.knirps = 0;
                this.fate = 'undetermined';
            }

            get normalizedPos() {
                return this.position / NUM_CELLS;
            }

            calculateGapGenes() {
                // Hunchback - high bicoid, repressed by nanos
                this.hunchback = Math.max(0, this.bicoid * 2 - this.nanos * 1.5);

                // Kr√ºppel - medium bicoid levels
                const kActivation = this.bicoid > 0.3 && this.bicoid < 0.7;
                this.kruppel = kActivation ? 1 - Math.abs(this.bicoid - 0.5) * 2 : 0;

                // Giant - bimodal, anterior and posterior
                this.giant = (this.bicoid > 0.4 && this.bicoid < 0.6) ||
                            (this.nanos > 0.5) ? 0.8 : 0;

                // Knirps - posterior region
                this.knirps = this.nanos > 0.4 && this.bicoid < 0.4 ? this.nanos : 0;
            }

            determineFate() {
                // Determine cell fate based on gene expression
                if (this.hunchback > 0.8 && this.bicoid > 0.6) {
                    this.fate = 'head';
                } else if (this.hunchback > 0.4 && this.kruppel > 0.3) {
                    this.fate = 'thorax';
                } else if (this.kruppel > 0.5 || this.giant > 0.5) {
                    this.fate = 'abdomen';
                } else if (this.knirps > 0.4 || this.nanos > 0.5) {
                    this.fate = 'tail';
                } else {
                    this.fate = 'trunk';
                }
            }
        }

        function initCells() {
            cells = [];
            for (let i = 0; i < NUM_CELLS; i++) {
                cells.push(new Cell(i));
            }
            establishMaternalGradients();
        }

        function establishMaternalGradients() {
            for (const cell of cells) {
                const pos = cell.normalizedPos;

                // Bicoid gradient from anterior (left)
                cell.bicoid = bicoidLevel * Math.exp(-pos * 3);

                // Nanos gradient from posterior (right)
                cell.nanos = nanosLevel * Math.exp(-(1 - pos) * 3);

                // Add noise
                cell.bicoid += (Math.random() - 0.5) * noiseLevel;
                cell.nanos += (Math.random() - 0.5) * noiseLevel;

                cell.bicoid = Math.max(0, cell.bicoid);
                cell.nanos = Math.max(0, cell.nanos);
            }
        }

        function diffuseGradients() {
            const newBicoid = cells.map(c => c.bicoid);
            const newNanos = cells.map(c => c.nanos);

            for (let i = 1; i < cells.length - 1; i++) {
                const diffB = diffusionRate * (
                    (cells[i-1].bicoid + cells[i+1].bicoid) / 2 - cells[i].bicoid
                );
                const diffN = diffusionRate * (
                    (cells[i-1].nanos + cells[i+1].nanos) / 2 - cells[i].nanos
                );

                newBicoid[i] = cells[i].bicoid + diffB;
                newNanos[i] = cells[i].nanos + diffN;
            }

            // Maintain source concentrations
            newBicoid[0] = bicoidLevel;
            newNanos[NUM_CELLS - 1] = nanosLevel;

            for (let i = 0; i < cells.length; i++) {
                cells[i].bicoid = Math.max(0, newBicoid[i]);
                cells[i].nanos = Math.max(0, newNanos[i]);
            }
        }

        function update() {
            if (!running) return;

            generation++;

            diffuseGradients();

            // Calculate gap gene expression
            cells.forEach(c => c.calculateGapGenes());

            // Determine cell fates
            cells.forEach(c => c.determineFate());

            render();
            updateStats();
            requestAnimationFrame(update);
        }

        function render() {
            ctx.fillStyle = 'rgba(26, 26, 46, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = (canvas.height - padding * 4) / 3;

            // Embryo with cell fates
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Drosophila Embryo - Body Segments', padding, 25);

            const cellWidth = width / NUM_CELLS;
            const fateColors = {
                head: '#3b82f6',
                thorax: '#10b981',
                trunk: '#22c55e',
                abdomen: '#f59e0b',
                tail: '#ef4444',
                undetermined: '#6b7280'
            };

            // Draw embryo outline
            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.beginPath();
            ctx.ellipse(padding + width / 2, padding + 50, width / 2, 40, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw cells
            for (const cell of cells) {
                const x = padding + cell.position * cellWidth;
                ctx.fillStyle = fateColors[cell.fate];
                ctx.fillRect(x, padding + 20, cellWidth - 1, 60);
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.fillText('Anterior', padding, padding + 95);
            ctx.fillText('Posterior', padding + width - 50, padding + 95);

            // Morphogen gradients
            const gradientY = padding * 2 + height;
            ctx.fillText('Maternal Morphogen Gradients', padding, gradientY - 10);

            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(padding, gradientY + height / 2);
            ctx.lineTo(padding + width, gradientY + height / 2);
            ctx.stroke();

            // Bicoid gradient
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < cells.length; i++) {
                const x = padding + i * cellWidth;
                const y = gradientY + height / 2 - cells[i].bicoid * (height / 2 - 10);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Nanos gradient
            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            for (let i = 0; i < cells.length; i++) {
                const x = padding + i * cellWidth;
                const y = gradientY + height / 2 - cells[i].nanos * (height / 2 - 10);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Gap genes
            const gapY = padding * 3 + height * 2;
            ctx.fillStyle = '#888';
            ctx.fillText('Gap Gene Expression Domains', padding, gapY - 10);

            // Hunchback
            ctx.strokeStyle = '#a855f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < cells.length; i++) {
                const x = padding + i * cellWidth;
                const y = gapY + height / 2 - cells[i].hunchback * (height / 2 - 10) * 0.5;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Kr√ºppel
            ctx.strokeStyle = '#22c55e';
            ctx.beginPath();
            for (let i = 0; i < cells.length; i++) {
                const x = padding + i * cellWidth;
                const y = gapY + height / 2 - cells[i].kruppel * (height / 2 - 10);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Legends
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(padding + 10, gradientY + 10, 15, 3);
            ctx.fillStyle = '#888';
            ctx.fillText('Bicoid', padding + 30, gradientY + 14);

            ctx.fillStyle = '#ef4444';
            ctx.fillRect(padding + 90, gradientY + 10, 15, 3);
            ctx.fillText('Nanos', padding + 110, gradientY + 14);

            ctx.fillStyle = '#a855f7';
            ctx.fillRect(padding + 10, gapY + 10, 15, 3);
            ctx.fillStyle = '#888';
            ctx.fillText('Hunchback', padding + 30, gapY + 14);

            ctx.fillStyle = '#22c55e';
            ctx.fillRect(padding + 110, gapY + 10, 15, 3);
            ctx.fillText('Kr√ºppel', padding + 130, gapY + 14);
        }

        function updateStats() {
            const fates = cells.map(c => c.fate);
            const head = fates.filter(f => f === 'head').length / NUM_CELLS * 100;
            const trunk = fates.filter(f => f === 'thorax' || f === 'trunk' || f === 'abdomen').length / NUM_CELLS * 100;
            const tail = fates.filter(f => f === 'tail').length / NUM_CELLS * 100;

            const hasPolarity = cells[0].bicoid > cells[NUM_CELLS - 1].bicoid;

            document.getElementById('generation').textContent = generation;
            document.getElementById('apPolarity').textContent = hasPolarity ? 'Established' : 'Symmetric';
            document.getElementById('headRegion').textContent = head.toFixed(1) + '%';
            document.getElementById('trunkRegion').textContent = trunk.toFixed(1) + '%';
            document.getElementById('tailRegion').textContent = tail.toFixed(1) + '%';
        }

        document.getElementById('bicoidSlider').addEventListener('input', (e) => {
            bicoidLevel = parseFloat(e.target.value);
            document.getElementById('bicoidValue').textContent = bicoidLevel.toFixed(1);
        });

        document.getElementById('nanosSlider').addEventListener('input', (e) => {
            nanosLevel = parseFloat(e.target.value);
            document.getElementById('nanosValue').textContent = nanosLevel.toFixed(1);
        });

        document.getElementById('diffSlider').addEventListener('input', (e) => {
            diffusionRate = parseFloat(e.target.value);
            document.getElementById('diffValue').textContent = diffusionRate.toFixed(2);
        });

        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            noiseLevel = parseFloat(e.target.value);
            document.getElementById('noiseValue').textContent = noiseLevel.toFixed(2);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Simulation';
            if (running) update();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            generation = 0;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            initCells();
            render();
            updateStats();
        });

        initCells();
        render();
        updateStats();
    </script>
</body>
</html>
