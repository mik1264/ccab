<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B-Tree Splitting Visualizer - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #f8fafc;
            color: #1e293b;
            font-family: system-ui, sans-serif;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; text-align: center; }
        .controls { 
            margin: 20px 0; 
            padding: 15px; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 60px; }
        button { padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #2563eb; }
        button.reset { background: #ef4444; }
        button.reset:hover { background: #dc2626; }
        
        #tree-container {
            min-height: 500px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            overflow: auto;
            display: flex;
            justify-content: center;
            padding-top: 40px;
        }
        
        .node {
            display: flex;
            background: #fff;
            border: 2px solid #334155;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: absolute;
            transition: all 0.5s ease-in-out;
            height: 40px;
            align-items: center;
            z-index: 2;
        }
        
        .key {
            padding: 0 10px;
            border-right: 1px solid #cbd5e1;
            font-weight: bold;
            display: flex;
            align-items: center;
            height: 100%;
        }
        .key:last-child { border-right: none; }
        .key.new { background: #fcd34d; animation: flash 1s; }
        
        @keyframes flash {
            0% { background: #fcd34d; }
            100% { background: transparent; }
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        line {
            stroke: #94a3b8;
            stroke-width: 2;
            transition: all 0.5s ease-in-out;
        }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>B-Tree Visualization</h1>
    <p>Order 4 B-Tree (Max 3 keys per node). Watch nodes split when they overflow.</p>
    
    <div class="controls">
        <input type="number" id="key-input" placeholder="#" onkeydown="if(event.key==='Enter') insertKey()">
        <button onclick="insertKey()">Insert</button>
        <button onclick="insertRandom()">Insert Random</button>
        <button onclick="resetTree()" class="reset">Reset</button>
    </div>

    <div id="tree-container">
        <svg id="lines"></svg>
        <!-- Nodes injected here -->
    </div>
</div>

<script>
    // B-Tree Logic (Order 4: Max 3 keys, Min 1 key)
    const ORDER = 4;
    const MAX_KEYS = ORDER - 1;
    
    class BTreeNode {
        constructor(isLeaf = true) {
            this.keys = [];
            this.children = [];
            this.isLeaf = isLeaf;
            this.id = Math.random().toString(36).substr(2, 9);
            this.x = 0;
            this.y = 0;
        }
    }

    class BTree {
        constructor() {
            this.root = new BTreeNode();
        }

        insert(k) {
            const root = this.root;
            if (root.keys.length === MAX_KEYS) {
                const newRoot = new BTreeNode(false);
                this.root = newRoot;
                newRoot.children.push(root);
                this.splitChild(newRoot, 0);
                this.insertNonFull(newRoot, k);
            } else {
                this.insertNonFull(root, k);
            }
        }

        insertNonFull(x, k) {
            let i = x.keys.length - 1;
            if (x.isLeaf) {
                while (i >= 0 && k < x.keys[i]) {
                    i--;
                }
                x.keys.splice(i + 1, 0, k);
            } else {
                while (i >= 0 && k < x.keys[i]) {
                    i--;
                }
                i++;
                if (x.children[i].keys.length === MAX_KEYS) {
                    this.splitChild(x, i);
                    if (k > x.keys[i]) {
                        i++;
                    }
                }
                this.insertNonFull(x.children[i], k);
            }
        }

        splitChild(x, i) {
            const y = x.children[i];
            const z = new BTreeNode(y.isLeaf);
            const t = Math.ceil(ORDER / 2) - 1; // Middle index for split

            // New node z takes keys after median
            z.keys = y.keys.splice(t + 1);
            
            if (!y.isLeaf) {
                z.children = y.children.splice(t + 1);
            }

            // Move median key up to x
            const medianKey = y.keys.pop(); // Remove median from y
            x.keys.splice(i, 0, medianKey);
            x.children.splice(i + 1, 0, z);
        }
    }

    const tree = new BTree();
    
    // Visualization Logic
    const container = document.getElementById('tree-container');
    const svgLines = document.getElementById('lines');
    
    function insertKey() {
        const input = document.getElementById('key-input');
        const val = parseInt(input.value);
        if (isNaN(val)) return;
        
        tree.insert(val);
        input.value = '';
        input.focus();
        renderTree();
    }

    function insertRandom() {
        tree.insert(Math.floor(Math.random() * 100));
        renderTree();
    }
    
    function resetTree() {
        tree.root = new BTreeNode();
        renderTree();
    }

    // Basic Reingold-Tilford inspired layout
    function renderTree() {
        // Clear previous
        const existingNodes = document.querySelectorAll('.node');
        const nodeMap = new Map();
        existingNodes.forEach(n => nodeMap.set(n.dataset.id, n));
        
        // Calculate positions
        const levels = [];
        traverse(tree.root, 0, levels);
        
        // Assign X coordinates
        // Simple strategy: Put leaves in a row, then center parents
        // Actually, let's do a recursive width calculation
        calculatePositions(tree.root, 0, 0); // Modifies x, y of nodes
        
        // Center the root
        const treeWidth = getTreeWidth(tree.root);
        const startX = (container.offsetWidth / 2);
        
        // Render
        svgLines.innerHTML = '';
        
        // Use a recursive render to handle lines and DOM nodes
        renderNode(tree.root, startX, 50, nodeMap);
    }

    function getTreeWidth(node) {
        if (node.isLeaf) return (node.keys.length * 40) + 40; // Approx width
        let w = 0;
        node.children.forEach(c => w += getTreeWidth(c));
        return w;
    }

    // Simplified layout algorithm
    // 1. Traverse to calculate widths of subtrees
    // 2. Position children relative to parent? No, position children side-by-side then parent in middle.
    
    function calculateLayout(node) {
        if (node.isLeaf) {
            node.width = Math.max(80, node.keys.length * 30 + 20);
            return;
        }
        
        let totalWidth = 0;
        node.children.forEach(child => {
            calculateLayout(child);
            totalWidth += child.width + 20; // 20px gap
        });
        
        node.width = Math.max(totalWidth, node.keys.length * 30 + 20);
    }

    function setCoordinates(node, x, y) {
        node.x = x;
        node.y = y;
        
        if (!node.isLeaf) {
            let currentX = x - (node.width / 2);
            // Center children block
            // Sum of children widths
            let childrenTotalWidth = 0;
            node.children.forEach(c => childrenTotalWidth += c.width + 20);
            childrenTotalWidth -= 20; // remove last gap
            
            let startX = x - (childrenTotalWidth / 2);
            
            node.children.forEach(child => {
                setCoordinates(child, startX + (child.width / 2), y + 80);
                startX += child.width + 20;
            });
        }
    }

    function renderNode(node, x, y, oldNodes) {
        calculateLayout(tree.root);
        setCoordinates(tree.root, container.offsetWidth / 2, 50);
        
        // Now actually Create DOM for ALL nodes
        // Use a flat list traversal
        const queue = [tree.root];
        const newIds = new Set();

        svgLines.innerHTML = ''; // Clear lines

        while(queue.length > 0) {
            const n = queue.shift();
            newIds.add(n.id);
            
            let el = document.getElementById(n.id);
            if (!el) {
                el = document.createElement('div');
                el.className = 'node';
                el.id = n.id;
                container.appendChild(el);
            }
            
            // Update Content
            el.innerHTML = n.keys.map(k => `<div class="key">${k}</div>`).join('');
            
            // Update Position
            el.style.left = (n.x - (el.offsetWidth/2)) + 'px'; // Center align
            el.style.top = n.y + 'px';
            
            // Draw lines to children
            if (!n.isLeaf) {
                n.children.forEach(child => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', n.x);
                    line.setAttribute('y1', n.y + 40); // Bottom of node
                    line.setAttribute('x2', child.x);
                    line.setAttribute('y2', child.y);
                    svgLines.appendChild(line);
                    queue.push(child);
                });
            }
        }
        
        // Remove stale nodes
        const allNodes = document.querySelectorAll('.node');
        allNodes.forEach(node => {
            if (!newIds.has(node.id)) {
                node.remove();
            }
        });
    }

    // Hacky Override renderTree to use the new logic
    renderTree = function() {
        calculateLayout(tree.root);
        setCoordinates(tree.root, Math.max(container.offsetWidth / 2, tree.root.width/2 + 20), 50);
        
        const queue = [tree.root];
        const newIds = new Set();
        svgLines.innerHTML = '';

        while(queue.length > 0) {
            const n = queue.shift();
            newIds.add(n.id);
            
            let el = document.getElementById(n.id);
            if (!el) {
                el = document.createElement('div');
                el.className = 'node';
                el.id = n.id;
                // Init position at parent? For animation? Skip for now.
                container.appendChild(el);
            }
            
            // Update Content - check if changed to avoid DOM thrashing
            const html = n.keys.map(k => `<div class="key">${k}</div>`).join('');
            if (el.innerHTML !== html) el.innerHTML = html;
            
            // Wait for render to get width
            const w = n.keys.length * 30 + 10; // Approx
            
            el.style.left = (n.x - (w/2)) + 'px';
            el.style.top = n.y + 'px';
            
            if (!n.isLeaf) {
                n.children.forEach(child => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', n.x);
                    line.setAttribute('y1', n.y + 35); 
                    line.setAttribute('x2', child.x);
                    line.setAttribute('y2', child.y);
                    svgLines.appendChild(line);
                    queue.push(child);
                });
            }
        }
        
        document.querySelectorAll('.node').forEach(node => {
            if (!newIds.has(node.id)) node.remove();
        });
    }

    function traverse(node, depth, levels) {
        if (!levels[depth]) levels[depth] = [];
        levels[depth].push(node);
        node.children.forEach(c => traverse(c, depth + 1, levels));
    }
    
    function calculatePositions(node, x, y) {
        // Placeholder
    }

    // Init with some data
    [10, 20, 5, 6, 12, 30, 7, 17].forEach(k => tree.insert(k));
    setTimeout(renderTree, 100); // Wait for DOM layout
    
    window.addEventListener('resize', renderTree);

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
