<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Optimization Playground</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px 0;
        }
        h1 { color: #00d4ff; font-size: 2em; margin-bottom: 5px; }
        .subtitle { color: #888; font-size: 1em; }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-top: 20px;
        }
        .canvas-area { position: relative; }
        canvas {
            background: #0d1b2a;
            border-radius: 12px;
            display: block;
            width: 100%;
        }
        .controls {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .control-group:last-child { border-bottom: none; }
        .control-group h3 {
            font-size: 0.9em;
            color: #00d4ff;
            margin-bottom: 10px;
        }
        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #aaa;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
            margin-bottom: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }
        select, button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            margin-bottom: 8px;
        }
        select {
            background: #2a2a4a;
            color: #fff;
        }
        button {
            background: #00d4ff;
            color: #000;
            font-weight: 600;
        }
        button:hover { background: #00b8e6; }
        button.secondary {
            background: #444;
            color: #fff;
        }
        button.secondary:hover { background: #555; }
        .legend {
            font-size: 0.8em;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }
        .stats {
            background: rgba(0,100,150,0.2);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85em;
        }
        .stats div { margin-bottom: 3px; }
        .stats .value { color: #00d4ff; font-weight: 600; }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #00d4ff;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #00d4ff; margin-bottom: 8px; }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>

    <div class="container">
        <header>
            <h1>Bayesian Optimization Playground</h1>
            <p class="subtitle">Gaussian Process Surrogate with Acquisition Functions</p>
        </header>

        <div class="main-content">
            <div class="canvas-area">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>Target Function</h3>
                    <select id="functionSelect">
                        <option value="multimodal">Multimodal (hard)</option>
                        <option value="ackley">Ackley Function</option>
                        <option value="rastrigin">Rastrigin</option>
                        <option value="easom">Easom (single peak)</option>
                        <option value="sinc">Sinc Function</option>
                    </select>
                    <label>Noise Level <span id="noiseVal">0.05</span></label>
                    <input type="range" id="noise" min="0" max="0.3" step="0.01" value="0.05">
                </div>

                <div class="control-group">
                    <h3>Acquisition Function</h3>
                    <select id="acquisitionSelect">
                        <option value="ei">Expected Improvement (EI)</option>
                        <option value="ucb">Upper Confidence Bound (UCB)</option>
                        <option value="pi">Probability of Improvement (PI)</option>
                    </select>
                    <label>κ (exploration) <span id="kappaVal">2.0</span></label>
                    <input type="range" id="kappa" min="0.1" max="5" step="0.1" value="2.0">
                    <label>ξ (improvement threshold) <span id="xiVal">0.01</span></label>
                    <input type="range" id="xi" min="0" max="0.5" step="0.01" value="0.01">
                </div>

                <div class="control-group">
                    <h3>GP Kernel</h3>
                    <label>Length Scale <span id="lengthVal">0.15</span></label>
                    <input type="range" id="lengthScale" min="0.05" max="0.5" step="0.01" value="0.15">
                    <label>Signal Variance <span id="sigmaVal">1.0</span></label>
                    <input type="range" id="sigma" min="0.1" max="3" step="0.1" value="1.0">
                </div>

                <div class="control-group">
                    <button id="stepBtn">Step (Add Sample)</button>
                    <button id="autoBtn">Auto-Run (10 steps)</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>

                <div class="stats">
                    <div>Samples: <span class="value" id="numSamples">0</span></div>
                    <div>Best Found: <span class="value" id="bestY">-</span></div>
                    <div>Best X: <span class="value" id="bestX">-</span></div>
                    <div>True Max: <span class="value" id="trueMax">-</span></div>
                    <div>Regret: <span class="value" id="regret">-</span></div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>True function</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00d4ff;"></div>
                        <span>GP mean</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(0,212,255,0.2); height: 12px;"></div>
                        <span>GP uncertainty (±2σ)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffd93d;"></div>
                        <span>Acquisition function</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="info">
        <h3>Bayesian Optimization</h3>
        <p>Uses a Gaussian Process surrogate to model an unknown expensive function.
        The acquisition function balances exploration (high uncertainty) vs exploitation
        (high predicted value). Click "Step" to add samples at the acquisition maximum.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        const padding = { top: 60, right: 40, bottom: 100, left: 60 };
        let plotWidth, plotHeight;

        // Data
        let samplesX = [];
        let samplesY = [];
        let noisyY = [];

        // Parameters
        let targetFunc = 'multimodal';
        let acquisition = 'ei';
        let noise = 0.05;
        let kappa = 2.0;
        let xi = 0.01;
        let lengthScale = 0.15;
        let sigma = 1.0;

        // Target functions
        const functions = {
            multimodal: x => Math.sin(10 * x) * Math.cos(3 * x) + 0.5 * Math.sin(5 * x),
            ackley: x => -Math.exp(-0.2 * Math.abs(x - 0.5) * 5) - Math.exp(Math.cos(2 * Math.PI * x * 5)) + Math.E + 1,
            rastrigin: x => -((x - 0.5) * 10) ** 2 + 10 * Math.cos(2 * Math.PI * (x - 0.5) * 5),
            easom: x => Math.cos((x - 0.5) * 4 * Math.PI) * Math.exp(-((x - 0.5) * 4) ** 2),
            sinc: x => {
                const t = (x - 0.5) * 10;
                return t === 0 ? 1 : Math.sin(t) / t;
            }
        };

        function targetFunction(x) {
            return functions[targetFunc](x);
        }

        function resize() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 500;
            width = canvas.width;
            height = canvas.height;
            plotWidth = width - padding.left - padding.right;
            plotHeight = (height - padding.top - padding.bottom) / 2 - 20;
            draw();
        }

        function reset() {
            samplesX = [];
            samplesY = [];
            noisyY = [];
            // Start with 2 random samples
            for (let i = 0; i < 2; i++) {
                const x = Math.random();
                samplesX.push(x);
                const y = targetFunction(x);
                samplesY.push(y);
                noisyY.push(y + (Math.random() - 0.5) * 2 * noise);
            }
            updateStats();
            draw();
        }

        // RBF Kernel
        function kernel(x1, x2) {
            const diff = x1 - x2;
            return sigma * sigma * Math.exp(-diff * diff / (2 * lengthScale * lengthScale));
        }

        // Compute GP posterior at query points
        function gpPredict(queryX) {
            const n = samplesX.length;
            if (n === 0) {
                return queryX.map(x => ({ mean: 0, variance: sigma * sigma }));
            }

            // Build K matrix (n x n)
            const K = [];
            for (let i = 0; i < n; i++) {
                K[i] = [];
                for (let j = 0; j < n; j++) {
                    K[i][j] = kernel(samplesX[i], samplesX[j]);
                    if (i === j) K[i][j] += noise * noise; // Noise term
                }
            }

            // Cholesky decomposition (simplified for small matrices)
            const L = choleskyDecomposition(K);
            if (!L) {
                // Fallback if decomposition fails
                return queryX.map(x => ({ mean: 0, variance: sigma * sigma }));
            }

            // Solve L * alpha_temp = y
            const y = noisyY;
            const alpha_temp = forwardSubstitution(L, y);
            const alpha = backwardSubstitution(transpose(L), alpha_temp);

            // Predict for each query point
            return queryX.map(x => {
                // k_star: covariance between x and training points
                const k_star = samplesX.map(xi => kernel(x, xi));

                // Mean: k_star^T * alpha
                let mean = 0;
                for (let i = 0; i < n; i++) {
                    mean += k_star[i] * alpha[i];
                }

                // Variance: k(x,x) - k_star^T * K^{-1} * k_star
                const v = forwardSubstitution(L, k_star);
                let variance = kernel(x, x);
                for (let i = 0; i < n; i++) {
                    variance -= v[i] * v[i];
                }
                variance = Math.max(0.001, variance);

                return { mean, variance };
            });
        }

        function choleskyDecomposition(A) {
            const n = A.length;
            const L = Array(n).fill(null).map(() => Array(n).fill(0));

            for (let i = 0; i < n; i++) {
                for (let j = 0; j <= i; j++) {
                    let sum = 0;
                    for (let k = 0; k < j; k++) {
                        sum += L[i][k] * L[j][k];
                    }
                    if (i === j) {
                        const val = A[i][i] - sum;
                        if (val <= 0) return null; // Not positive definite
                        L[i][j] = Math.sqrt(val);
                    } else {
                        L[i][j] = (A[i][j] - sum) / L[j][j];
                    }
                }
            }
            return L;
        }

        function forwardSubstitution(L, b) {
            const n = L.length;
            const x = Array(n).fill(0);
            for (let i = 0; i < n; i++) {
                let sum = b[i];
                for (let j = 0; j < i; j++) {
                    sum -= L[i][j] * x[j];
                }
                x[i] = sum / L[i][i];
            }
            return x;
        }

        function backwardSubstitution(U, b) {
            const n = U.length;
            const x = Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = b[i];
                for (let j = i + 1; j < n; j++) {
                    sum -= U[i][j] * x[j];
                }
                x[i] = sum / U[i][i];
            }
            return x;
        }

        function transpose(M) {
            const n = M.length;
            const T = Array(n).fill(null).map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    T[i][j] = M[j][i];
                }
            }
            return T;
        }

        // Standard normal CDF (approximation)
        function normalCDF(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;

            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);

            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

            return 0.5 * (1.0 + sign * y);
        }

        // Standard normal PDF
        function normalPDF(x) {
            return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
        }

        // Acquisition functions
        function acquisitionEI(mean, std, bestY) {
            if (std < 1e-10) return 0;
            const z = (mean - bestY - xi) / std;
            return (mean - bestY - xi) * normalCDF(z) + std * normalPDF(z);
        }

        function acquisitionUCB(mean, std) {
            return mean + kappa * std;
        }

        function acquisitionPI(mean, std, bestY) {
            if (std < 1e-10) return 0;
            const z = (mean - bestY - xi) / std;
            return normalCDF(z);
        }

        function computeAcquisition(mean, std, bestY) {
            switch (acquisition) {
                case 'ei': return acquisitionEI(mean, std, bestY);
                case 'ucb': return acquisitionUCB(mean, std);
                case 'pi': return acquisitionPI(mean, std, bestY);
            }
        }

        function step() {
            // Compute GP predictions
            const resolution = 200;
            const queryX = Array.from({ length: resolution }, (_, i) => i / (resolution - 1));
            const predictions = gpPredict(queryX);

            const bestY = Math.max(...noisyY);

            // Find max acquisition
            let maxAcq = -Infinity;
            let maxX = 0.5;

            queryX.forEach((x, i) => {
                const std = Math.sqrt(predictions[i].variance);
                const acq = computeAcquisition(predictions[i].mean, std, bestY);
                if (acq > maxAcq) {
                    maxAcq = acq;
                    maxX = x;
                }
            });

            // Sample at max acquisition
            const newY = targetFunction(maxX);
            const noisyNewY = newY + (Math.random() - 0.5) * 2 * noise;

            samplesX.push(maxX);
            samplesY.push(newY);
            noisyY.push(noisyNewY);

            updateStats();
            draw();
        }

        function updateStats() {
            document.getElementById('numSamples').textContent = samplesX.length;

            if (samplesX.length > 0) {
                const bestIdx = noisyY.indexOf(Math.max(...noisyY));
                document.getElementById('bestY').textContent = samplesY[bestIdx].toFixed(4);
                document.getElementById('bestX').textContent = samplesX[bestIdx].toFixed(4);

                // Find true max
                let trueMax = -Infinity;
                for (let x = 0; x <= 1; x += 0.001) {
                    trueMax = Math.max(trueMax, targetFunction(x));
                }
                document.getElementById('trueMax').textContent = trueMax.toFixed(4);

                const regret = trueMax - samplesY[bestIdx];
                document.getElementById('regret').textContent = regret.toFixed(4);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            const resolution = 200;
            const queryX = Array.from({ length: resolution }, (_, i) => i / (resolution - 1));
            const predictions = gpPredict(queryX);

            const bestY = noisyY.length > 0 ? Math.max(...noisyY) : 0;

            // Compute acquisition values
            const acqValues = queryX.map((x, i) => {
                const std = Math.sqrt(predictions[i].variance);
                return computeAcquisition(predictions[i].mean, std, bestY);
            });

            // Draw function plot (top)
            drawFunctionPlot(queryX, predictions, padding.top);

            // Draw acquisition plot (bottom)
            drawAcquisitionPlot(queryX, acqValues, padding.top + plotHeight + 60);
        }

        function drawFunctionPlot(queryX, predictions, yOffset) {
            const toCanvasX = x => padding.left + x * plotWidth;

            // Find y range
            let minY = Infinity, maxY = -Infinity;

            queryX.forEach((x, i) => {
                const trueY = targetFunction(x);
                const mean = predictions[i].mean;
                const std = Math.sqrt(predictions[i].variance);

                minY = Math.min(minY, trueY, mean - 2 * std);
                maxY = Math.max(maxY, trueY, mean + 2 * std);
            });

            noisyY.forEach(y => {
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });

            const range = maxY - minY || 1;
            minY -= range * 0.1;
            maxY += range * 0.1;

            const toCanvasY = y => yOffset + plotHeight - ((y - minY) / (maxY - minY)) * plotHeight;

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOffset);
            ctx.lineTo(padding.left, yOffset + plotHeight);
            ctx.lineTo(padding.left + plotWidth, yOffset + plotHeight);
            ctx.stroke();

            // Draw y-axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = minY + (maxY - minY) * i / 4;
                const cy = toCanvasY(y);
                ctx.fillText(y.toFixed(2), padding.left - 5, cy + 3);
            }

            // Title
            ctx.fillStyle = '#00d4ff';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GP Surrogate + True Function', padding.left + plotWidth / 2, yOffset - 10);

            // Draw GP uncertainty band
            ctx.fillStyle = 'rgba(0, 212, 255, 0.15)';
            ctx.beginPath();
            queryX.forEach((x, i) => {
                const mean = predictions[i].mean;
                const std = Math.sqrt(predictions[i].variance);
                const cx = toCanvasX(x);
                const cy = toCanvasY(mean + 2 * std);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            for (let i = queryX.length - 1; i >= 0; i--) {
                const mean = predictions[i].mean;
                const std = Math.sqrt(predictions[i].variance);
                const cx = toCanvasX(queryX[i]);
                const cy = toCanvasY(mean - 2 * std);
                ctx.lineTo(cx, cy);
            }
            ctx.closePath();
            ctx.fill();

            // Draw true function
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            queryX.forEach((x, i) => {
                const y = targetFunction(x);
                const cx = toCanvasX(x);
                const cy = toCanvasY(y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            // Draw GP mean
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            queryX.forEach((x, i) => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(predictions[i].mean);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            // Draw samples
            ctx.fillStyle = '#fff';
            samplesX.forEach((x, i) => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(noisyY[i]);
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Number
                ctx.fillStyle = '#000';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(i + 1, cx, cy + 3);
                ctx.fillStyle = '#fff';
            });
        }

        function drawAcquisitionPlot(queryX, acqValues, yOffset) {
            const toCanvasX = x => padding.left + x * plotWidth;

            // Find y range
            let minAcq = Math.min(...acqValues);
            let maxAcq = Math.max(...acqValues);
            const range = maxAcq - minAcq || 1;
            minAcq -= range * 0.1;
            maxAcq += range * 0.1;

            const toCanvasY = y => yOffset + plotHeight - ((y - minAcq) / (maxAcq - minAcq)) * plotHeight;

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOffset);
            ctx.lineTo(padding.left, yOffset + plotHeight);
            ctx.lineTo(padding.left + plotWidth, yOffset + plotHeight);
            ctx.stroke();

            // Title
            ctx.fillStyle = '#ffd93d';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            const acqNames = { ei: 'Expected Improvement', ucb: 'Upper Confidence Bound', pi: 'Probability of Improvement' };
            ctx.fillText(`Acquisition: ${acqNames[acquisition]}`, padding.left + plotWidth / 2, yOffset - 10);

            // Draw acquisition function
            ctx.strokeStyle = '#ffd93d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            queryX.forEach((x, i) => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(acqValues[i]);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            // Fill under curve
            ctx.fillStyle = 'rgba(255, 217, 61, 0.2)';
            ctx.beginPath();
            ctx.moveTo(toCanvasX(0), toCanvasY(minAcq));
            queryX.forEach((x, i) => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(acqValues[i]);
                ctx.lineTo(cx, cy);
            });
            ctx.lineTo(toCanvasX(1), toCanvasY(minAcq));
            ctx.closePath();
            ctx.fill();

            // Mark next sample point (max acquisition)
            let maxIdx = 0;
            acqValues.forEach((v, i) => {
                if (v > acqValues[maxIdx]) maxIdx = i;
            });

            ctx.fillStyle = '#ffd93d';
            ctx.beginPath();
            ctx.arc(toCanvasX(queryX[maxIdx]), toCanvasY(acqValues[maxIdx]), 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#ffd93d';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(toCanvasX(queryX[maxIdx]), toCanvasY(acqValues[maxIdx]));
            ctx.lineTo(toCanvasX(queryX[maxIdx]), yOffset + plotHeight);
            ctx.stroke();
            ctx.setLineDash([]);

            // X-axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const x = i / 5;
                ctx.fillText(x.toFixed(1), toCanvasX(x), yOffset + plotHeight + 15);
            }
            ctx.fillText('x', toCanvasX(0.5), yOffset + plotHeight + 30);
        }

        // Event handlers
        document.getElementById('functionSelect').addEventListener('change', e => {
            targetFunc = e.target.value;
            reset();
        });

        document.getElementById('acquisitionSelect').addEventListener('change', e => {
            acquisition = e.target.value;
            draw();
        });

        document.getElementById('noise').addEventListener('input', e => {
            noise = parseFloat(e.target.value);
            document.getElementById('noiseVal').textContent = noise.toFixed(2);
        });

        document.getElementById('kappa').addEventListener('input', e => {
            kappa = parseFloat(e.target.value);
            document.getElementById('kappaVal').textContent = kappa.toFixed(1);
            draw();
        });

        document.getElementById('xi').addEventListener('input', e => {
            xi = parseFloat(e.target.value);
            document.getElementById('xiVal').textContent = xi.toFixed(2);
            draw();
        });

        document.getElementById('lengthScale').addEventListener('input', e => {
            lengthScale = parseFloat(e.target.value);
            document.getElementById('lengthVal').textContent = lengthScale.toFixed(2);
            draw();
        });

        document.getElementById('sigma').addEventListener('input', e => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigmaVal').textContent = sigma.toFixed(1);
            draw();
        });

        document.getElementById('stepBtn').addEventListener('click', step);

        document.getElementById('autoBtn').addEventListener('click', () => {
            let steps = 0;
            const interval = setInterval(() => {
                step();
                steps++;
                if (steps >= 10) clearInterval(interval);
            }, 300);
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        window.addEventListener('resize', resize);

        resize();
        reset();
    </script>
</body>
</html>
