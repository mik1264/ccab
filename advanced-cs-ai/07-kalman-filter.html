<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalman Filter Navigator - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #0f172a;
            color: #e2e8f0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            position: relative;
            background: #1e293b;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        canvas {
            background: #000;
            border-radius: 8px;
            cursor: crosshair;
        }
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
        }
        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            background: #334155;
            padding: 1rem;
            border-radius: 8px;
        }
        label { font-size: 0.9rem; }
        input[type=range] { vertical-align: middle; }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.85rem;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
    </style>
</head>
<body>

<a href="../index.html" class="gallery-back" style="align-self: flex-start; margin-left: max(2rem, calc(50% - 400px));">‚Üê Back to Gallery</a>

<div class="container">
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="hud" id="hud">
        State: Tracking<br>
        Error Covariance: 0.0
    </div>

    <div class="legend">
        <span><div class="dot" style="background:#fff"></div> True Position (Mouse)</span>
        <span><div class="dot" style="background:#ef4444"></div> Noisy Measurement</span>
        <span><div class="dot" style="background:#10b981"></div> Kalman Estimate</span>
        <span><div class="dot" style="border:1px solid #10b981; background:transparent"></div> Uncertainty (Covariance)</span>
    </div>
</div>

<div class="controls">
    <div>
        <label>Measurement Noise (R):</label>
        <input type="range" id="noiseR" min="1" max="100" value="30">
    </div>
    <div>
        <label>Process Noise (Q):</label>
        <input type="range" id="noiseQ" min="0.1" max="10" step="0.1" value="1">
    </div>
    <button onclick="reset()">Reset Path</button>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    
    // Mouse state (True Position)
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    // Kalman Filter State (2D: x, y, vx, vy)
    // Simplified 1D implementations for X and Y independently
    
    class KalmanFilter1D {
        constructor(initialValue, processNoise, measurementNoise) {
            this.x = initialValue; // Estimate
            this.P = 1.0;          // Error Covariance
            this.Q = processNoise; // Process Noise
            this.R = measurementNoise; // Measurement Noise
            this.K = 0.0;          // Kalman Gain
        }

        predict() {
            // Predict next state (assume constant velocity model or simple random walk)
            // Here: Simple random walk model for cursor (x_k = x_{k-1})
            // P = P + Q
            this.P = this.P + this.Q;
        }

        update(measurement) {
            // K = P / (P + R)
            this.K = this.P / (this.P + this.R);
            // x = x + K(z - x)
            this.x = this.x + this.K * (measurement - this.x);
            // P = (1 - K)P
            this.P = (1 - this.K) * this.P;
        }
    }

    let kfX, kfY;
    let pathTrue = [];
    let pathMeas = [];
    let pathEst = [];
    let historyLen = 200;

    function init() {
        reset();
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        requestAnimationFrame(loop);
    }

    function reset() {
        const r = parseFloat(document.getElementById('noiseR').value);
        const q = parseFloat(document.getElementById('noiseQ').value);
        
        kfX = new KalmanFilter1D(mouseX, q, r);
        kfY = new KalmanFilter1D(mouseY, q, r);
        
        pathTrue = [];
        pathMeas = [];
        pathEst = [];
    }

    function loop() {
        // Update params
        kfX.R = parseFloat(document.getElementById('noiseR').value) * 10; // Scale up
        kfY.R = kfX.R;
        kfX.Q = parseFloat(document.getElementById('noiseQ').value);
        kfY.Q = kfX.Q;

        // 1. Generate Noisy Measurement
        const noiseX = (Math.random() - 0.5) * kfX.R * 2; // Rough approximation
        const noiseY = (Math.random() - 0.5) * kfY.R * 2;
        
        // Actually gaussian noise is better
        const gaussian = () => {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        }
        
        const measX = mouseX + gaussian() * Math.sqrt(kfX.R);
        const measY = mouseY + gaussian() * Math.sqrt(kfY.R);

        // 2. Predict
        kfX.predict();
        kfY.predict();

        // 3. Update
        kfX.update(measX);
        kfY.update(measY);

        // History
        pathTrue.push({x: mouseX, y: mouseY});
        pathMeas.push({x: measX, y: measY});
        pathEst.push({x: kfX.x, y: kfY.x, p: kfX.P}); // Using P from X as approx

        if (pathTrue.length > historyLen) {
            pathTrue.shift();
            pathMeas.shift();
            pathEst.shift();
        }

        draw();
        hud.innerHTML = `Meas Noise (R): ${kfX.R.toFixed(1)}<br>Est Uncertainty (P): ${kfX.P.toFixed(1)}`;
        
        requestAnimationFrame(loop);
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Grid
        ctx.strokeStyle = '#111';
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
        for(let i=0; i<canvas.height; i+=50) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
        ctx.stroke();

        // Draw Measurements (Red dots)
        ctx.fillStyle = '#ef4444';
        pathMeas.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
            ctx.fill();
        });

        // Draw True Path (White line)
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        pathTrue.forEach((p, i) => {
            if (i===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();

        // Draw Estimate Path (Green line)
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 3;
        ctx.beginPath();
        pathEst.forEach((p, i) => {
            if (i===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();

        // Current Estimate Covariance Ellipse
        const lastEst = pathEst[pathEst.length-1];
        if (lastEst) {
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Radius approx proportional to sqrt(P)
            ctx.arc(lastEst.x, lastEst.y, Math.sqrt(lastEst.p) * 5, 0, Math.PI*2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
            ctx.fill();
            
            // Current Crosshair
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(lastEst.x - 10, lastEst.y);
            ctx.lineTo(lastEst.x + 10, lastEst.y);
            ctx.moveTo(lastEst.x, lastEst.y - 10);
            ctx.lineTo(lastEst.x, lastEst.y + 10);
            ctx.stroke();
        }
    }

    init();
</script>
</body>
</html>
