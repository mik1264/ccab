<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Gate Sandbox - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #f0f2f5;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container { max-width: 1200px; width: 100%; display: flex; gap: 20px; }
        
        .sidebar {
            width: 200px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .component {
            padding: 10px;
            margin-bottom: 10px;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: grab;
            text-align: center;
            font-weight: bold;
        }
        .component:hover { background: #e0e0e0; }
        
        #canvas-container {
            flex-grow: 1;
            height: 600px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
        
        .header { margin-bottom: 20px; text-align: center; }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 20px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
    </style>
</head>
<body>

<div class="header">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Logic Gate Sandbox</h1>
    <p>Drag components to canvas. Drag from output nodes to input nodes to wire.</p>
</div>

<div class="container">
    <div class="sidebar">
        <h3>Components</h3>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="SWITCH">Switch</div>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="LED">LED Bulb</div>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="AND">AND Gate</div>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="OR">OR Gate</div>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="NOT">NOT Gate</div>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="XOR">XOR Gate</div>
        <div class="component" draggable="true" ondragstart="drag(event)" data-type="CLOCK">Clock (1Hz)</div>
        
        <button onclick="clearCanvas()">Clear All</button>
    </div>
    
    <div id="canvas-container" ondrop="drop(event)" ondragover="allowDrop(event)">
        <canvas id="canvas"></canvas>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let components = [];
    let wires = []; // { from: {comp, pin}, to: {comp, pin} }
    
    let isDraggingComp = null;
    let dragOffset = {x:0, y:0};
    
    let wiringStart = null; // {comp, pinIndex, type}
    
    // Config
    const COMP_W = 60;
    const COMP_H = 40;
    
    function resize() {
        const rect = document.getElementById('canvas-container').getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
    }
    window.addEventListener('resize', resize);
    resize();
    
    // Classes
    class Component {
        constructor(type, x, y) {
            this.id = Math.random().toString(36).substr(2,9);
            this.type = type;
            this.x = x;
            this.y = y;
            this.w = COMP_W;
            this.h = COMP_H;
            
            this.inputs = [];
            this.outputs = [];
            this.state = false;
            
            // Config pins based on type
            if(type === 'AND' || type === 'OR' || type === 'XOR') {
                this.inputs = [false, false];
                this.outputs = [false];
            } else if(type === 'NOT') {
                this.inputs = [false];
                this.outputs = [false];
            } else if(type === 'SWITCH') {
                this.inputs = [];
                this.outputs = [false];
                this.w = 40; this.h = 40;
            } else if(type === 'LED') {
                this.inputs = [false];
                this.outputs = [];
                this.w = 40; this.h = 40;
            } else if (type === 'CLOCK') {
                this.inputs = [];
                this.outputs = [false];
                setInterval(() => { this.state = !this.state; }, 500); // 1 Hz toggle
            }
        }
        
        update() {
            if (this.type === 'AND') this.outputs[0] = this.inputs[0] && this.inputs[1];
            else if (this.type === 'OR') this.outputs[0] = this.inputs[0] || this.inputs[1];
            else if (this.type === 'XOR') this.outputs[0] = (this.inputs[0] ? !this.inputs[1] : this.inputs[1]);
            else if (this.type === 'NOT') this.outputs[0] = !this.inputs[0];
            else if (this.type === 'SWITCH' || this.type === 'CLOCK') this.outputs[0] = this.state;
            else if (this.type === 'LED') this.state = this.inputs[0];
        }
        
        draw() {
            // Body
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.strokeRect(this.x, this.y, this.w, this.h);
            
            // Label
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let label = this.type;
            if (this.type === 'SWITCH') label = this.state ? 'ON' : 'OFF';
            if (this.type === 'LED') label = 'LED';
            ctx.fillText(label, this.x + this.w/2, this.y + this.h/2);
            
            if (this.type === 'LED') {
                ctx.fillStyle = this.state ? '#10b981' : '#333';
                ctx.beginPath(); ctx.arc(this.x + this.w/2, this.y + this.h/2, 10, 0, Math.PI*2); ctx.fill();
            }
            
            // Pins
            // Inputs (Left)
            this.inputs.forEach((val, i) => {
                const py = this.y + (i+1) * (this.h / (this.inputs.length+1));
                this.drawPin(this.x, py, val, true);
            });
            // Outputs (Right)
            this.outputs.forEach((val, i) => {
                const py = this.y + (i+1) * (this.h / (this.outputs.length+1));
                this.drawPin(this.x + this.w, py, val, false);
            });
        }
        
        drawPin(x, y, val, isInput) {
            ctx.fillStyle = val ? '#10b981' : '#ef4444';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
        }
        
        getPinAt(x, y) {
            // Check Inputs
            for(let i=0; i<this.inputs.length; i++) {
                const py = this.y + (i+1) * (this.h / (this.inputs.length+1));
                if (Math.hypot(x - this.x, y - py) < 8) return { index: i, type: 'input' };
            }
            // Check Outputs
            for(let i=0; i<this.outputs.length; i++) {
                const py = this.y + (i+1) * (this.h / (this.outputs.length+1));
                if (Math.hypot(x - (this.x + this.w), y - py) < 8) return { index: i, type: 'output' };
            }
            return null;
        }
    }
    
    // Drag Drop
    function allowDrop(ev) { ev.preventDefault(); }
    function drag(ev) { ev.dataTransfer.setData("type", ev.target.dataset.type); }
    function drop(ev) {
        ev.preventDefault();
        const type = ev.dataTransfer.getData("type");
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left - COMP_W/2;
        const y = ev.clientY - rect.top - COMP_H/2;
        components.push(new Component(type, x, y));
    }
    
    // Interaction
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check Pins
        for (let c of components) {
            const pin = c.getPinAt(x, y);
            if (pin) {
                if (wiringStart) {
                    // Try to connect
                    if (wiringStart.comp !== c && wiringStart.type !== pin.type) {
                        // Connect Output to Input
                        let src, dst;
                        if (wiringStart.type === 'output') { src = wiringStart; dst = {comp: c, index: pin.index}; }
                        else { src = {comp: c, index: pin.index}; dst = wiringStart; }
                        
                        wires.push({src, dst});
                    }
                    wiringStart = null;
                } else {
                    wiringStart = { comp: c, index: pin.index, type: pin.type };
                }
                return;
            }
        }
        
        // Check Body
        for (let i = components.length-1; i>=0; i--) {
            const c = components[i];
            if (x > c.x && x < c.x + c.w && y > c.y && y < c.y + c.h) {
                if (c.type === 'SWITCH') {
                    c.state = !c.state; // Toggle
                } else {
                    isDraggingComp = c;
                    dragOffset = { x: x - c.x, y: y - c.y };
                }
                return;
            }
        }
        
        // Click elsewhere cancels wiring
        wiringStart = null;
    });
    
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (isDraggingComp) {
            isDraggingComp.x = x - dragOffset.x;
            isDraggingComp.y = y - dragOffset.y;
        }
        
        // Mouse visual for wiring
        window.mouseX = x;
        window.mouseY = y;
    });
    
    window.addEventListener('mouseup', () => isDraggingComp = null);
    
    function loop() {
        // Logic Sim
        // Reset Inputs (default false)
        components.forEach(c => {
            for(let i=0; i<c.inputs.length; i++) c.inputs[i] = false;
        });
        
        // Propagate signals
        wires.forEach(w => {
            const val = w.src.comp.outputs[w.src.index];
            w.dst.comp.inputs[w.dst.index] = val;
        });
        
        // Update components
        components.forEach(c => c.update());
        
        // Draw
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Wires
        ctx.lineWidth = 3;
        wires.forEach(w => {
            const c1 = w.src.comp;
            const c2 = w.dst.comp;
            const y1 = c1.y + (w.src.index+1) * (c1.h / (c1.outputs.length+1));
            const y2 = c2.y + (w.dst.index+1) * (c2.h / (c2.inputs.length+1));
            const x1 = c1.x + c1.w;
            const x2 = c2.x;
            
            const val = c1.outputs[w.src.index];
            ctx.strokeStyle = val ? '#10b981' : '#ef4444';
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            // Bezier
            ctx.bezierCurveTo(x1 + 50, y1, x2 - 50, y2, x2, y2);
            ctx.stroke();
        });
        
        // Wiring Line
        if (wiringStart) {
            const c = wiringStart.comp;
            let startX, startY;
            if (wiringStart.type === 'input') {
                startX = c.x;
                startY = c.y + (wiringStart.index+1) * (c.h / (c.inputs.length+1));
            } else {
                startX = c.x + c.w;
                startY = c.y + (wiringStart.index+1) * (c.h / (c.outputs.length+1));
            }
            
            ctx.strokeStyle = '#999';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(window.mouseX, window.mouseY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        components.forEach(c => c.draw());
        
        requestAnimationFrame(loop);
    }
    
    function clearCanvas() {
        components = [];
        wires = [];
    }
    
    requestAnimationFrame(loop);

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
