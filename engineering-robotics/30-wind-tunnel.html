<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aerofoil Wind Tunnel - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #e0f2fe;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .controls {
            margin: 20px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            display: inline-flex;
            gap: 20px;
            align-items: center;
        }
        
        input[type=range] { width: 200px; }
        .val { font-weight: bold; width: 60px; display: inline-block; }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">← Back to Gallery</a>
    <h1>Aerofoil Wind Tunnel</h1>
    <p>Simulating potential flow around a Joukowski aerofoil.</p>
    
    <canvas id="canvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <label>Angle of Attack (α)</label>
        <input type="range" id="alpha" min="-20" max="20" value="5">
        <span id="alpha-val" class="val">5°</span>
        
        <label>Airspeed</label>
        <input type="range" id="speed" min="0" max="20" value="10">
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let alpha = 5 * Math.PI / 180;
    let speed = 10;
    let particles = [];
    
    // Joukowski Transform
    // Map circle (zeta plane) to aerofoil (z plane)
    // z = zeta + 1/zeta
    // Circle center: mu = -0.1 + 0.1i (camber + thickness)
    // Radius R = |1 - mu| + epsilon
    
    const cx = -0.1;
    const cy = 0.1;
    const a = 1.0; // scale
    const R = Math.hypot(1 - cx, cy) + 0.05; // slightly larger than 1 to close trailing edge
    
    function init() {
        for(let i=0; i<500; i++) {
            resetParticle(i, true);
        }
        requestAnimationFrame(loop);
    }
    
    function resetParticle(i, randomX = false) {
        particles[i] = {
            x: randomX ? Math.random() * 800 : 0,
            y: Math.random() * 400,
            vx: speed,
            vy: 0,
            life: Math.random() * 100
        };
    }
    
    document.getElementById('alpha').addEventListener('input', e => {
        alpha = parseInt(e.target.value) * Math.PI / 180;
        document.getElementById('alpha-val').textContent = e.target.value + "°";
    });
    
    document.getElementById('speed').addEventListener('input', e => {
        speed = parseInt(e.target.value);
    });
    
    function loop() {
        // Clear (with trail effect)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw Aerofoil
        ctx.fillStyle = '#94a3b8';
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Generate aerofoil shape points
        const steps = 100;
        const scale = 100;
        const offsetX = 400;
        const offsetY = 200;
        
        // Rotate the whole simulation by -alpha? 
        // Or rotate object by alpha.
        // Standard: Flow is horizontal, object is rotated.
        
        for (let i=0; i<=steps; i++) {
            const t = (i/steps) * Math.PI * 2;
            // Circle in zeta plane
            let zx = cx + R * Math.cos(t);
            let zy = cy + R * Math.sin(t);
            
            // Joukowski transform: z = zeta + 1/zeta
            // Complex division: 1/(x+iy) = (x-iy)/(x^2+y^2)
            const mag = zx*zx + zy*zy;
            let wx = zx + (zx / mag);
            let wy = zy - (zy / mag); // -zy because 1/zeta conj
            
            // Rotate by -alpha (Angle of Attack)
            // Effectively rotating the foil UP
            const rotX = wx * Math.cos(-alpha) - wy * Math.sin(-alpha);
            const rotY = wx * Math.sin(-alpha) + wy * Math.cos(-alpha);
            
            const sx = offsetX + rotX * scale;
            const sy = offsetY + rotY * scale; // Canvas Y is down
            
            if (i===0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Update Particles (Streamlines)
        // Hard to compute potential flow velocity field for rotated Joukowski in real time JS efficiently without complex math library.
        // Trick: Simple deflection based on proximity to foil bbox.
        // Particles move left to right.
        // If they hit foil, they slide along it.
        // Lift effect: Downwash behind foil.
        
        ctx.fillStyle = '#0ea5e9';
        
        particles.forEach((p, i) => {
            p.x += speed;
            
            // Interaction logic (fake physics)
            // Aerofoil center approx (400, 200)
            const dx = p.x - 400;
            const dy = p.y - 200;
            
            // Simple foil collision box (rotated ellipse approx)
            // Check if inside ellipse
            // Rotate p to foil frame
            const rx = dx * Math.cos(alpha) - dy * Math.sin(alpha);
            const ry = dx * Math.sin(alpha) + dy * Math.cos(alpha);
            
            // Ellipse x radius ~ 200, y radius ~ 30
            if ((rx*rx)/(200*200) + (ry*ry)/(30*30) < 1.2) {
                // Near foil
                // Push out in y
                const push = (ry > 0) ? 1 : -1;
                p.y += push * 2;
                
                // Acceleration (Bernoulli) - faster over top
                if (ry < 0) p.x += speed * 0.2; 
            }
            
            // Downwash behind
            if (dx > 150) {
                p.y += speed * Math.sin(alpha) * 0.1;
            }
            
            // Reset
            if (p.x > canvas.width) resetParticle(i);
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2);
            ctx.fill();
        });
        
        // Draw Lift Vector
        const liftMag = speed * Math.sin(alpha) * 100;
        if (Math.abs(liftMag) > 5) {
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(400, 200);
            ctx.lineTo(400, 200 - liftMag);
            ctx.stroke();
            // Arrowhead
            ctx.beginPath();
            ctx.moveTo(400, 200 - liftMag);
            ctx.lineTo(390, 200 - liftMag + 10 * Math.sign(liftMag));
            ctx.lineTo(410, 200 - liftMag + 10 * Math.sign(liftMag));
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            
            ctx.fillStyle = '#ef4444';
            ctx.fillText("Lift", 420, 200 - liftMag/2);
        }
        
        requestAnimationFrame(loop);
    }
    
    init();

</script>
</body>
</html>
