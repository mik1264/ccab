<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inverse Kinematics Solver - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #f3f4f6;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: crosshair;
        }
        
        .controls {
            margin-top: 20px;
            display: inline-flex;
            gap: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            backdrop-filter: blur(10px);
        }
        
        button {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #2563eb; }
        
        label { font-weight: bold; }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Inverse Kinematics (IK) Solver</h1>
    <p>Solving joint angles to reach a target point using CCD (Cyclic Coordinate Descent).</p>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <label><input type="checkbox" id="reach-constraint" checked> Constrain Joints</label>
        <button onclick="addSegment()">Add Segment</button>
        <button onclick="removeSegment()">Remove Segment</button>
        <button onclick="reset()">Reset</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Arm Configuration
    const ROOT_X = 400;
    const ROOT_Y = 300;
    const SEGMENT_LENGTH = 80;
    
    let segments = []; // { angle: 0, length: 80 }
    let target = { x: 0, y: 0 };
    
    function init() {
        reset();
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            target.x = e.clientX - rect.left;
            target.y = e.clientY - rect.top;
        });
        
        requestAnimationFrame(loop);
    }
    
    function reset() {
        segments = [];
        for (let i = 0; i < 3; i++) {
            segments.push({ angle: 0, length: SEGMENT_LENGTH });
        }
    }
    
    function addSegment() {
        segments.push({ angle: 0, length: SEGMENT_LENGTH });
    }
    
    function removeSegment() {
        if (segments.length > 1) segments.pop();
    }
    
    // CCD Algorithm
    function solveIK() {
        const constraint = document.getElementById('reach-constraint').checked;
        const maxIter = 10;
        const tolerance = 1;
        
        // Loop CCD iterations
        for (let iter = 0; iter < maxIter; iter++) {
            // Check distance
            let endEffector = calculateEndEffector();
            if (Math.hypot(endEffector.x - target.x, endEffector.y - target.y) < tolerance) break;
            
            // Iterate from end effector to root
            for (let i = segments.length - 1; i >= 0; i--) {
                // Calculate current end effector position
                endEffector = calculateEndEffector();
                
                // Calculate pivot position (start of segment i)
                const pivot = calculateJointPosition(i);
                
                // Vector from pivot to end effector
                const v1 = { x: endEffector.x - pivot.x, y: endEffector.y - pivot.y };
                // Vector from pivot to target
                const v2 = { x: target.x - pivot.x, y: target.y - pivot.y };
                
                // Angle between v1 and v2
                const a1 = Math.atan2(v1.y, v1.x);
                const a2 = Math.atan2(v2.y, v2.x);
                let angleDiff = a2 - a1;
                
                // Normalize angle
                while (angleDiff <= -Math.PI) angleDiff += Math.PI*2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI*2;
                
                // Apply rotation
                segments[i].angle += angleDiff;
                
                // Constraints (optional: e.g., max 90 degrees relative to parent)
                // Simplified relative constraint
                if (constraint && i > 0) {
                    const parentAngle = segments[i-1].angle;
                    let relAngle = segments[i].angle - parentAngle;
                    // Normalize
                    while (relAngle <= -Math.PI) relAngle += Math.PI*2;
                    while (relAngle > Math.PI) relAngle -= Math.PI*2;
                    
                    const limit = Math.PI / 2; // 90 deg
                    if (relAngle > limit) segments[i].angle = parentAngle + limit;
                    if (relAngle < -limit) segments[i].angle = parentAngle - limit;
                }
            }
        }
    }
    
    function calculateJointPosition(index) {
        let x = ROOT_X;
        let y = ROOT_Y;
        for (let i = 0; i < index; i++) {
            x += Math.cos(segments[i].angle) * segments[i].length;
            y += Math.sin(segments[i].angle) * segments[i].length;
        }
        return { x, y };
    }
    
    function calculateEndEffector() {
        return calculateJointPosition(segments.length);
    }
    
    function loop() {
        solveIK();
        draw();
        requestAnimationFrame(loop);
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw Target
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(target.x - 10, target.y); ctx.lineTo(target.x + 10, target.y);
        ctx.moveTo(target.x, target.y - 10); ctx.lineTo(target.x, target.y + 10);
        ctx.stroke();
        
        // Draw Segments
        let x = ROOT_X;
        let y = ROOT_Y;
        
        // Base
        ctx.fillStyle = '#333';
        ctx.fillRect(x - 20, y, 40, 10);
        
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        segments.forEach((seg, i) => {
            const nextX = x + Math.cos(seg.angle) * seg.length;
            const nextY = y + Math.sin(seg.angle) * seg.length;
            
            // Bone
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 15;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(nextX, nextY);
            ctx.stroke();
            
            // Inner bone
            ctx.strokeStyle = '#93c5fd';
            ctx.lineWidth = 5;
            ctx.stroke();
            
            // Joint
            ctx.fillStyle = '#1e40af';
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI*2);
            ctx.fill();
            
            x = nextX;
            y = nextY;
        });
        
        // End Effector
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI*2);
        ctx.fill();
    }
    
    // Expose functions for enhance.js keyboard shortcuts
    window.reset = init;
    window.init = init;

    init();

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
