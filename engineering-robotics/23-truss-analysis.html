<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truss Stress Analysis - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #fff;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .controls {
            margin: 20px;
            display: inline-flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #2563eb; }
        button.active { background: #1e40af; }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        .leg-box { width: 15px; height: 15px; display: inline-block; vertical-align: middle; margin-right: 5px; }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Truss Bridge Analysis</h1>
    <p>Click nodes to add load. Color indicates stress.</p>
    
    <div class="legend">
        <span><div class="leg-box" style="background:#ef4444"></div> Compression</span>
        <span><div class="leg-box" style="background:#3b82f6"></div> Tension</span>
        <span><div class="leg-box" style="background:#9ca3af"></div> Neutral</span>
    </div>
    
    <canvas id="canvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <button onclick="reset()">Reset</button>
        <button onclick="toggleMode('load')" id="btn-load" class="active">Mode: Add Load</button>
        <!-- <button onclick="toggleMode('build')">Mode: Build</button> -->
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let nodes = [];
    let members = [];
    let loads = []; // { nodeIndex: 0, mag: 10 }
    
    // Setup standard bridge
    function reset() {
        nodes = [];
        members = [];
        loads = [];
        
        // Bottom Chord
        for (let i=0; i<=4; i++) {
            nodes.push({ x: 100 + i*150, y: 300, fixed: (i===0 || i===4) });
        }
        // Top Chord
        for (let i=0; i<4; i++) {
            nodes.push({ x: 175 + i*150, y: 150, fixed: false });
        }
        
        // Members
        // Bottom
        for (let i=0; i<4; i++) addMember(i, i+1);
        // Top
        for (let i=0; i<3; i++) addMember(5+i, 5+i+1);
        // Diagonals / Verticals
        // Zig-zag pattern
        addMember(0, 5);
        addMember(1, 5);
        addMember(1, 6);
        addMember(2, 6);
        addMember(2, 7);
        addMember(3, 7);
        addMember(3, 8);
        addMember(4, 8);
        
        solve();
        draw();
    }
    
    function addMember(n1, n2) {
        members.push({ n1, n2, force: 0 }); // Force: + Tension, - Compression
    }
    
    // Very simplified "Direct Stiffness Method" or just iterative relaxation for demo visuals
    // Real FEM is matrix math. 
    // Let's use a spring-mass relaxation which is easier to code ad-hoc visually.
    
    function solve() {
        // Reset forces
        members.forEach(m => m.force = 0);
        
        // Iterative Solver
        // Assume rigid members (high stiffness)
        // We actually want internal forces.
        
        // Simple trick for visualization:
        // Treat as spring system with gravity loads.
        // Relax to equilibrium position.
        // Calculate stress from spring displacement.
        
        // Backup original positions
        const originalNodes = JSON.parse(JSON.stringify(nodes));
        
        // Apply Loads
        for(let iter=0; iter<100; iter++) {
            nodes.forEach((n, i) => {
                if (n.fixed) return;
                
                let fx = 0;
                let fy = 0;
                
                // Load
                const load = loads.find(l => l.nodeIndex === i);
                if (load) fy += load.mag;
                
                // Spring forces from members
                members.forEach(m => {
                    let other = null;
                    if (m.n1 === i) other = nodes[m.n2];
                    else if (m.n2 === i) other = nodes[m.n1];
                    
                    if (other) {
                        const dx = other.x - n.x;
                        const dy = other.y - n.y;
                        const dist = Math.hypot(dx, dy);
                        // Original length? 
                        // Find original length from backup
                        // Hack: assume start config is stress free length
                        // We need original index? Not stored in members.
                        // Assume member array corresponds.
                        // Let's store restLength in member.
                    }
                });
            });
        }
        
        // Wait, proper FEM is better even if simple.
        // 2D Truss Analysis (Method of Joints or Stiffness Matrix)
        // Hard to implement full matrix inversion in vanilla JS quickly without math lib.
        
        // Let's implement a heuristic visualizer:
        // Loads cause bending moment? No, trusses only axial.
        // Load at center bottom (Node 2)
        // Distributes to neighbors.
        // Just hardcode the logic for "Load propagation" or use relaxation.
        
        // Relaxation:
        // 1. Members are springs with k=100.
        // 2. Nodes have mass.
        // 3. Apply load forces.
        // 4. Let settle.
        // 5. Force = k * (currentLen - restLen)
        
        // Init rest lengths
        if (!members[0].restLen) {
            members.forEach(m => {
                const n1 = nodes[m.n1];
                const n2 = nodes[m.n2];
                m.restLen = Math.hypot(n2.x - n1.x, n2.y - n1.y);
            });
        }
        
        // Relax
        const k = 0.5;
        const damping = 0.8;
        
        // Reset velocities
        nodes.forEach(n => { n.vx = 0; n.vy = 0; });
        
        for(let step=0; step<200; step++) {
            // Forces
            nodes.forEach(n => { n.fx = 0; n.fy = 0; });
            
            // Loads
            loads.forEach(l => {
                nodes[l.nodeIndex].fy += l.mag * 0.1; // Scale load
            });
            
            // Gravity/Self-weight (small)
            nodes.forEach(n => n.fy += 0.05);
            
            // Springs
            members.forEach(m => {
                const n1 = nodes[m.n1];
                const n2 = nodes[m.n2];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const len = Math.hypot(dx, dy);
                const diff = len - m.restLen;
                
                const force = k * diff; // Hooke's law
                m.force = force * 100; // Store for display (scaled)
                
                const fx = (dx / len) * force;
                const fy = (dy / len) * force;
                
                if (!n1.fixed) { n1.fx += fx; n1.fy += fy; }
                if (!n2.fixed) { n2.fx -= fx; n2.fy -= fy; }
            });
            
            // Integrate
            nodes.forEach(n => {
                if (n.fixed) return;
                n.vx = (n.vx + n.fx) * damping;
                n.vy = (n.vy + n.fy) * damping;
                n.x += n.vx;
                n.y += n.vy;
            });
        }
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw Members
        ctx.lineWidth = 4;
        members.forEach(m => {
            const n1 = nodes[m.n1];
            const n2 = nodes[m.n2];
            
            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            
            // Color based on force
            // Tension (+, Blue) | Compression (-, Red)
            const stress = m.force;
            if (stress > 0.5) ctx.strokeStyle = `rgba(59, 130, 246, ${Math.min(1, stress/5)})`;
            else if (stress < -0.5) ctx.strokeStyle = `rgba(239, 68, 68, ${Math.min(1, -stress/5)})`;
            else ctx.strokeStyle = '#9ca3af';
            
            ctx.stroke();
        });
        
        // Draw Nodes
        nodes.forEach((n, i) => {
            ctx.fillStyle = n.fixed ? '#000' : '#666';
            ctx.beginPath();
            ctx.arc(n.x, n.y, 6, 0, Math.PI*2);
            ctx.fill();
            
            // Draw Load Arrow
            const load = loads.find(l => l.nodeIndex === i);
            if (load) {
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(n.x, n.y);
                ctx.lineTo(n.x, n.y + 30);
                ctx.lineTo(n.x - 5, n.y + 25);
                ctx.moveTo(n.x, n.y + 30);
                ctx.lineTo(n.x + 5, n.y + 25);
                ctx.stroke();
            }
        });
    }
    
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find node
        let clickedNode = -1;
        nodes.forEach((n, i) => {
            if (Math.hypot(n.x - x, n.y - y) < 15) clickedNode = i;
        });
        
        if (clickedNode !== -1) {
            // Toggle load
            const idx = loads.findIndex(l => l.nodeIndex === clickedNode);
            if (idx !== -1) loads.splice(idx, 1);
            else loads.push({ nodeIndex: clickedNode, mag: 20 });
            
            solve();
            draw();
        }
    });
    
    reset();

</script>
</body>
</html>
