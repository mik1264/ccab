<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apollonian Gasket - Circle Packing Fractal - CCAB</title>
    <meta name="description" content="Beautiful recursive circle packing using Descartes' Circle Theorem. Watch the Apollonian Gasket fractal emerge as circles fill every gap.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a1a;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #9c27b0;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(156, 39, 176, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(156, 39, 176, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            color: #9c27b0;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(156, 39, 176, 0.2);
            z-index: 1000;
            max-width: 300px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #aaa;
            font-size: 11px;
        }

        #info .stat-value {
            color: #9c27b0;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #info .formula {
            background: rgba(156, 39, 176, 0.1);
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 12px;
            color: #ce93d8;
        }

        #presets {
            position: fixed;
            top: 320px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(156, 39, 176, 0.15);
            border: 1px solid rgba(156, 39, 176, 0.4);
            color: #9c27b0;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(156, 39, 176, 0.3);
        }

        button.active {
            background: rgba(156, 39, 176, 0.4);
            border-color: #9c27b0;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(156, 39, 176, 0.2);
        }

        .control-group label {
            color: #9c27b0;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #9c27b0;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #9c27b0;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Apollonian Gasket</h3>
        <div class="stat">
            <span class="stat-label">Circles</span>
            <span class="stat-value" id="circle-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Depth</span>
            <span class="stat-value" id="depth">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Min Radius</span>
            <span class="stat-value" id="min-radius">1px</span>
        </div>
        <p>Recursive circle packing using Descartes' Circle Theorem. Each gap between three tangent circles is filled with a new tangent circle.</p>
        <div class="formula">
            (k₁ + k₂ + k₃ + k₄)² = 2(k₁² + k₂² + k₃² + k₄²)
        </div>
    </div>

    <div id="presets">
        <button class="active" data-preset="standard">Standard Gasket</button>
        <button data-preset="symmetric">Symmetric Start</button>
        <button data-preset="arbelos">Arbelos</button>
        <button data-preset="random">Random Config</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Min Radius: <span id="minr-val">1</span>px</label>
            <input type="range" id="minr" min="0.5" max="5" step="0.5" value="1">
        </div>
        <div class="control-group">
            <label>Color Mode: <span id="color-val">Depth</span></label>
            <input type="range" id="color-mode" min="0" max="2" step="1" value="0">
        </div>
        <div class="control-group">
            <label>Animation: <span id="anim-val">On</span></label>
            <input type="range" id="anim" min="0" max="1" step="1" value="1">
        </div>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', () => {
            resize();
            generateGasket();
        });

        // DOM elements
        const circleCountDisplay = document.getElementById('circle-count');
        const depthDisplay = document.getElementById('depth');
        const minRadiusDisplay = document.getElementById('min-radius');
        const fpsDisplay = document.getElementById('fps');
        const minrSlider = document.getElementById('minr');
        const minrVal = document.getElementById('minr-val');
        const colorModeSlider = document.getElementById('color-mode');
        const colorVal = document.getElementById('color-val');
        const animSlider = document.getElementById('anim');
        const animVal = document.getElementById('anim-val');

        // Configuration
        let config = {
            minRadius: 1,
            colorMode: 0,
            animate: true,
            preset: 'standard'
        };

        // Circle class with curvature
        class Circle {
            constructor(x, y, r, depth = 0) {
                this.x = x;
                this.y = y;
                this.r = Math.abs(r);
                this.k = 1 / r; // Curvature (can be negative for outer circle)
                this.depth = depth;
            }
        }

        // State
        let circles = [];
        let queue = [];
        let maxDepth = 0;
        let animationIndex = 0;

        // Descartes' Circle Theorem
        // Given three mutually tangent circles with curvatures k1, k2, k3,
        // find the fourth tangent circle's curvature
        function descartesK(k1, k2, k3) {
            // k4 = k1 + k2 + k3 ± 2*sqrt(k1*k2 + k2*k3 + k1*k3)
            const sum = k1 + k2 + k3;
            const sqrtPart = 2 * Math.sqrt(k1 * k2 + k2 * k3 + k1 * k3);
            return [sum + sqrtPart, sum - sqrtPart];
        }

        // Find center of fourth tangent circle using complex Descartes theorem
        function descartesCenter(c1, c2, c3, k4) {
            // Complex form: (k1*z1 + k2*z2 + k3*z3 + k4*z4)² = 2(k1²z1² + k2²z2² + k3²z3² + k4²z4²)
            // Simplified for finding z4 given k4

            const k1 = c1.k, k2 = c2.k, k3 = c3.k;
            const z1 = { re: c1.x, im: c1.y };
            const z2 = { re: c2.x, im: c2.y };
            const z3 = { re: c3.x, im: c3.y };

            // Calculate z1*k1 + z2*k2 + z3*k3
            const sumZ = {
                re: z1.re * k1 + z2.re * k2 + z3.re * k3,
                im: z1.im * k1 + z2.im * k2 + z3.im * k3
            };

            // Calculate sqrt term: 2*sqrt(k1*k2*z1*z2 + k2*k3*z2*z3 + k1*k3*z1*z3)
            const prod12 = complexMul(z1, z2);
            const prod23 = complexMul(z2, z3);
            const prod13 = complexMul(z1, z3);

            const innerSum = {
                re: k1 * k2 * prod12.re + k2 * k3 * prod23.re + k1 * k3 * prod13.re,
                im: k1 * k2 * prod12.im + k2 * k3 * prod23.im + k1 * k3 * prod13.im
            };

            const sqrtTerm = complexSqrt(innerSum);

            // Two possible centers (+ and -)
            const centers = [
                {
                    re: (sumZ.re + 2 * sqrtTerm.re) / k4,
                    im: (sumZ.im + 2 * sqrtTerm.im) / k4
                },
                {
                    re: (sumZ.re - 2 * sqrtTerm.re) / k4,
                    im: (sumZ.im - 2 * sqrtTerm.im) / k4
                }
            ];

            return centers;
        }

        // Complex multiplication
        function complexMul(a, b) {
            return {
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            };
        }

        // Complex square root
        function complexSqrt(z) {
            const r = Math.sqrt(z.re * z.re + z.im * z.im);
            const theta = Math.atan2(z.im, z.re);
            const sqrtR = Math.sqrt(r);
            return {
                re: sqrtR * Math.cos(theta / 2),
                im: sqrtR * Math.sin(theta / 2)
            };
        }

        // Check if circle is valid (inside outer, not overlapping)
        function isValidCircle(c, circles, outer) {
            // Radius must be positive
            if (c.r <= 0) return false;

            // Center must be finite
            if (!isFinite(c.x) || !isFinite(c.y)) return false;

            // Must be inside outer circle (with tolerance for tangency)
            const distToOuter = Math.sqrt((c.x - outer.x) ** 2 + (c.y - outer.y) ** 2);
            if (distToOuter + c.r > outer.r + 1) return false;

            // Must not overlap significantly with existing circles
            // (allow some tolerance since tangent circles will be very close)
            for (const existing of circles) {
                if (existing === outer) continue; // Skip outer circle in overlap check
                const dist = Math.sqrt((c.x - existing.x) ** 2 + (c.y - existing.y) ** 2);
                const minDist = c.r + existing.r;
                // If circles significantly overlap (not just tangent), reject
                if (dist < minDist * 0.9) return false;
            }

            return true;
        }

        // Check tangency between two circles
        function getTangencyError(c1, c2) {
            const dist = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
            // If one circle has negative curvature (outer), it's internal tangency
            if (c1.k < 0 || c2.k < 0) {
                // Internal tangency: dist = |r1 - r2|
                return Math.abs(dist - Math.abs(c1.r - c2.r));
            }
            // External tangency: dist = r1 + r2
            return Math.abs(dist - (c1.r + c2.r));
        }

        // Find new circle tangent to three given circles
        function findFourthCircle(c1, c2, c3, outer, existingCircles, depth) {
            const [k4_plus, k4_minus] = descartesK(c1.k, c2.k, c3.k);

            const results = [];

            for (const k4 of [k4_plus, k4_minus]) {
                if (k4 <= 0) continue; // Skip negative/zero curvature (we only want inner circles)
                const r4 = 1 / k4;
                if (r4 < config.minRadius) continue;
                if (r4 > outer.r) continue; // Can't be bigger than outer circle

                const centers = descartesCenter(c1, c2, c3, k4);

                for (const center of centers) {
                    if (isNaN(center.re) || isNaN(center.im)) continue;

                    const newCircle = new Circle(center.re, center.im, r4, depth);
                    newCircle.k = k4; // Ensure positive curvature

                    // Check validity (inside outer, no overlaps)
                    if (!isValidCircle(newCircle, existingCircles, outer)) continue;

                    // Check tangency errors with all three parent circles
                    const err1 = getTangencyError(newCircle, c1);
                    const err2 = getTangencyError(newCircle, c2);
                    const err3 = getTangencyError(newCircle, c3);

                    // Allow reasonable tolerance for tangency
                    const tolerance = Math.max(2, r4 * 0.1);
                    if (err1 < tolerance && err2 < tolerance && err3 < tolerance) {
                        results.push(newCircle);
                    }
                }
            }

            return results;
        }

        // Initialize gasket based on preset
        function initGasket(preset) {
            circles = [];
            queue = [];
            maxDepth = 0;
            animationIndex = 0;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const outerR = Math.min(canvas.width, canvas.height) * 0.4;

            // Outer circle (negative curvature)
            const outer = new Circle(cx, cy, outerR, 0);
            outer.k = -1 / outerR; // Negative for outer circle
            circles.push(outer);

            let c1, c2, c3;

            switch (preset) {
                case 'standard':
                    // Three equal circles inside
                    const innerR = outerR / (1 + 2 / Math.sqrt(3));
                    const offset = outerR - innerR;
                    c1 = new Circle(cx, cy - offset + innerR, innerR, 0);
                    c2 = new Circle(cx - offset * Math.cos(Math.PI / 6), cy + offset * Math.sin(Math.PI / 6), innerR, 0);
                    c3 = new Circle(cx + offset * Math.cos(Math.PI / 6), cy + offset * Math.sin(Math.PI / 6), innerR, 0);
                    break;

                case 'symmetric':
                    // Two equal circles and one different
                    const r1 = outerR * 0.45;
                    c1 = new Circle(cx - outerR + r1, cy, r1, 0);
                    c2 = new Circle(cx + outerR - r1, cy, r1, 0);
                    const r3 = outerR - r1; // Calculated to fit
                    c3 = new Circle(cx, cy, r3 * 0.5, 0);
                    break;

                case 'arbelos':
                    // Arbelos configuration (semicircles)
                    const arR1 = outerR * 0.6;
                    const arR2 = outerR - arR1;
                    c1 = new Circle(cx - outerR + arR1, cy, arR1, 0);
                    c2 = new Circle(cx + outerR - arR2, cy, arR2, 0);
                    // Small circle at top
                    const arR3 = (arR1 * arR2) / outerR;
                    c3 = new Circle(cx, cy - Math.sqrt(arR1 * arR2), arR3, 0);
                    break;

                case 'random':
                    // Random configuration
                    const randR1 = outerR * (0.3 + Math.random() * 0.3);
                    c1 = new Circle(cx - outerR + randR1 + 10, cy + (Math.random() - 0.5) * outerR * 0.3, randR1, 0);
                    const randR2 = outerR * (0.2 + Math.random() * 0.25);
                    c2 = new Circle(cx + outerR - randR2 - 10, cy + (Math.random() - 0.5) * outerR * 0.3, randR2, 0);
                    const randR3 = outerR * (0.15 + Math.random() * 0.2);
                    c3 = new Circle(cx + (Math.random() - 0.5) * outerR * 0.5, cy - outerR * 0.3, randR3, 0);
                    break;
            }

            circles.push(c1, c2, c3);

            // Add initial triplets to queue
            queue.push([outer, c1, c2]);
            queue.push([outer, c1, c3]);
            queue.push([outer, c2, c3]);
            queue.push([c1, c2, c3]);
        }

        // Process queue to generate more circles
        function processQueue(steps = 100) {
            let processed = 0;
            const outer = circles[0];

            while (queue.length > 0 && processed < steps) {
                const [a, b, c] = queue.shift();
                const depth = Math.max(a.depth, b.depth, c.depth) + 1;

                const newCircles = findFourthCircle(a, b, c, outer, circles, depth);

                for (const newC of newCircles) {
                    // Check if we already have a circle at this position
                    let duplicate = false;
                    for (const existing of circles) {
                        const dist = Math.sqrt((newC.x - existing.x) ** 2 + (newC.y - existing.y) ** 2);
                        if (dist < 1 && Math.abs(newC.r - existing.r) < 1) {
                            duplicate = true;
                            break;
                        }
                    }

                    if (!duplicate) {
                        circles.push(newC);
                        maxDepth = Math.max(maxDepth, newC.depth);

                        // Add new triplets
                        queue.push([a, b, newC]);
                        queue.push([a, c, newC]);
                        queue.push([b, c, newC]);
                    }
                }

                processed++;
            }
        }

        // Generate full gasket
        function generateGasket() {
            initGasket(config.preset);
            while (queue.length > 0) {
                processQueue(1000);
            }
        }

        // Get color for circle
        function getColor(circle, index) {
            if (index === 0) return 'rgba(156, 39, 176, 0.1)'; // Outer circle

            switch (config.colorMode) {
                case 0: // Depth-based
                    const hue = (circle.depth * 30 + 280) % 360;
                    const lightness = 50 + Math.min(circle.depth * 3, 30);
                    return `hsl(${hue}, 70%, ${lightness}%)`;

                case 1: // Size-based
                    const sizeFactor = Math.min(circle.r / 50, 1);
                    return `hsl(${280 + sizeFactor * 60}, 70%, ${40 + sizeFactor * 30}%)`;

                case 2: // Rainbow
                    return `hsl(${(index * 7) % 360}, 70%, 55%)`;

                default:
                    return '#9c27b0';
            }
        }

        // Draw function
        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const numToDraw = config.animate ? Math.min(animationIndex, circles.length) : circles.length;

            for (let i = 0; i < numToDraw; i++) {
                const c = circles[i];
                const color = getColor(c, i);

                // Fill
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                ctx.fill();

                // Stroke
                ctx.strokeStyle = i === 0 ? '#9c27b0' : 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = i === 0 ? 2 : 0.5;
                ctx.stroke();
            }

            // Update stats
            circleCountDisplay.textContent = numToDraw;
            depthDisplay.textContent = maxDepth;
            minRadiusDisplay.textContent = `${config.minRadius}px`;
        }

        // Animation loop
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            // Animation
            if (config.animate && animationIndex < circles.length) {
                animationIndex += 3;
            }

            draw();
        }

        // Event listeners
        minrSlider.addEventListener('input', (e) => {
            config.minRadius = parseFloat(e.target.value);
            minrVal.textContent = config.minRadius;
            generateGasket();
            animationIndex = config.animate ? 0 : circles.length;
        });

        const colorModes = ['Depth', 'Size', 'Rainbow'];
        colorModeSlider.addEventListener('input', (e) => {
            config.colorMode = parseInt(e.target.value);
            colorVal.textContent = colorModes[config.colorMode];
        });

        animSlider.addEventListener('input', (e) => {
            config.animate = parseInt(e.target.value) === 1;
            animVal.textContent = config.animate ? 'On' : 'Off';
            if (!config.animate) animationIndex = circles.length;
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                config.preset = btn.dataset.preset;
                generateGasket();
                animationIndex = config.animate ? 0 : circles.length;
            });
        });

        // Initialize
        generateGasket();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
