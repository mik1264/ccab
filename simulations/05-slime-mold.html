<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Mold (Physarum) Growth Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            max-width: 1400px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.6;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        canvas {
            border: 2px solid #ffd700;
            border-radius: 10px;
            background: #000000;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            cursor: crosshair;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 350px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ffd700;
            font-weight: 600;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #fff;
            font-weight: bold;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #daa520 100%);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stats-label {
            color: #aaa;
        }

        .stats-value {
            color: #ffd700;
            font-weight: bold;
        }

        .info-box {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .info-box h3 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Slime Mold (Physarum) Growth</h1>
        <p class="description">
            Witness the remarkable problem-solving abilities of Physarum polycephalum, a single-celled organism that can
            find optimal paths between food sources. Thousands of agents deposit chemical trails as they move, sense
            concentrations ahead with three sensors (left, forward, right), and turn toward the highest concentration.
            This simple algorithm produces stunning organic networks that remarkably resemble neural networks, fungal
            mycelium, and even modern transportation systems. Click to add food sources and watch the slime mold find
            efficient connections!
        </p>

        <div class="content">
            <canvas id="canvas"></canvas>

            <div class="controls">
                <div class="control-group">
                    <label>
                        Agent Count: <span class="value-display" id="agentCountValue">5000</span>
                    </label>
                    <input type="range" id="agentCount" min="1000" max="15000" value="5000" step="500">
                </div>

                <div class="control-group">
                    <label>
                        Move Speed: <span class="value-display" id="speedValue">1.0</span>
                    </label>
                    <input type="range" id="speed" min="0.3" max="2.0" value="1.0" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Sensor Angle: <span class="value-display" id="sensorAngleValue">45째</span>
                    </label>
                    <input type="range" id="sensorAngle" min="15" max="90" value="45" step="5">
                </div>

                <div class="control-group">
                    <label>
                        Sensor Distance: <span class="value-display" id="sensorDistValue">9</span>
                    </label>
                    <input type="range" id="sensorDist" min="5" max="30" value="9" step="1">
                </div>

                <div class="control-group">
                    <label>
                        Turn Speed: <span class="value-display" id="turnSpeedValue">45째</span>
                    </label>
                    <input type="range" id="turnSpeed" min="15" max="90" value="45" step="5">
                </div>

                <div class="control-group">
                    <label>
                        Decay Rate: <span class="value-display" id="decayValue">0.95</span>
                    </label>
                    <input type="range" id="decay" min="0.85" max="0.99" value="0.95" step="0.01">
                </div>

                <div class="control-group">
                    <label>
                        Deposit Amount: <span class="value-display" id="depositValue">5</span>
                    </label>
                    <input type="range" id="deposit" min="1" max="15" value="5" step="1">
                </div>

                <div class="button-grid">
                    <button class="btn-secondary" id="addFoodBtn">Add Food</button>
                    <button class="btn-secondary" id="clearFoodBtn">Clear Food</button>
                </div>

                <button class="btn-primary" id="pauseBtn">Pause</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>

                <div class="stats">
                    <div class="stats-row">
                        <span class="stats-label">FPS:</span>
                        <span class="stats-value" id="fps">60</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Active Agents:</span>
                        <span class="stats-value" id="activeAgents">5000</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Food Sources:</span>
                        <span class="stats-value" id="foodCount">4</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Trail Density:</span>
                        <span class="stats-value" id="density">0%</span>
                    </div>
                </div>

                <div class="info-box">
                    <h3>Bio-Inspired Optimization</h3>
                    <p><strong>Collective Sensing:</strong> Each agent samples its environment</p>
                    <p><strong>Positive Feedback:</strong> Trails attract more agents</p>
                    <p><strong>Emergent Networks:</strong> Optimal paths form naturally</p>
                    <p style="margin-top: 10px; font-style: italic;">
                        Real Physarum solved the Tokyo rail system!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const WIDTH = 900;
        const HEIGHT = 900;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // Create trail map with Float32Array for performance
        let trailMap = new Float32Array(WIDTH * HEIGHT);
        let tempTrailMap = new Float32Array(WIDTH * HEIGHT);

        let params = {
            agentCount: 5000,
            speed: 1.0,
            sensorAngleRad: 45 * Math.PI / 180,
            sensorDist: 9,
            turnSpeed: 45 * Math.PI / 180,
            decay: 0.95,
            deposit: 5
        };

        let paused = false;
        let foodSources = [];

        class Agent {
            constructor(x, y) {
                this.x = x || WIDTH / 2;
                this.y = y || HEIGHT / 2;
                this.angle = Math.random() * Math.PI * 2;
            }

            sense(offsetAngle) {
                const sensorAngle = this.angle + offsetAngle;
                const sensorX = Math.floor(this.x + Math.cos(sensorAngle) * params.sensorDist);
                const sensorY = Math.floor(this.y + Math.sin(sensorAngle) * params.sensorDist);

                if (sensorX >= 0 && sensorX < WIDTH && sensorY >= 0 && sensorY < HEIGHT) {
                    return trailMap[sensorY * WIDTH + sensorX];
                }
                return 0;
            }

            update() {
                // Sense in three directions
                const forward = this.sense(0);
                const left = this.sense(params.sensorAngleRad);
                const right = this.sense(-params.sensorAngleRad);

                // Steer based on concentrations
                if (forward > left && forward > right) {
                    // Continue forward
                } else if (forward < left && forward < right) {
                    // Random turn
                    this.angle += (Math.random() - 0.5) * params.turnSpeed * 2;
                } else if (left > right) {
                    this.angle += params.turnSpeed;
                } else if (right > left) {
                    this.angle -= params.turnSpeed;
                }

                // Move forward
                const newX = this.x + Math.cos(this.angle) * params.speed;
                const newY = this.y + Math.sin(this.angle) * params.speed;

                // Boundary conditions - bounce
                if (newX < 0 || newX >= WIDTH) {
                    this.angle = Math.PI - this.angle;
                    this.x = Math.max(0, Math.min(WIDTH - 1, this.x));
                } else {
                    this.x = newX;
                }

                if (newY < 0 || newY >= HEIGHT) {
                    this.angle = -this.angle;
                    this.y = Math.max(0, Math.min(HEIGHT - 1, this.y));
                } else {
                    this.y = newY;
                }

                // Deposit trail
                const ix = Math.floor(this.x);
                const iy = Math.floor(this.y);
                if (ix >= 0 && ix < WIDTH && iy >= 0 && iy < HEIGHT) {
                    const index = iy * WIDTH + ix;
                    trailMap[index] = Math.min(trailMap[index] + params.deposit, 255);
                }
            }
        }

        let agents = [];

        function initSimulation() {
            agents = [];
            trailMap.fill(0);

            // Create default food sources in corners
            foodSources = [
                { x: 200, y: 200, radius: 30 },
                { x: WIDTH - 200, y: 200, radius: 30 },
                { x: 200, y: HEIGHT - 200, radius: 30 },
                { x: WIDTH - 200, y: HEIGHT - 200, radius: 30 }
            ];

            // Spawn agents near food sources
            for (let i = 0; i < params.agentCount; i++) {
                const food = foodSources[i % foodSources.length];
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * food.radius;
                const x = food.x + Math.cos(angle) * dist;
                const y = food.y + Math.sin(angle) * dist;
                agents.push(new Agent(x, y));
            }

            updateStats();
        }

        initSimulation();

        let lastTime = performance.now();
        let fps = 60;

        function updateFPS() {
            const now = performance.now();
            const delta = now - lastTime;
            fps = Math.round(1000 / delta);
            lastTime = now;
            document.getElementById('fps').textContent = fps;
        }

        function updateStats() {
            document.getElementById('activeAgents').textContent = agents.length;
            document.getElementById('foodCount').textContent = foodSources.length;
        }

        function diffuseAndDecay() {
            // Simple box blur + decay
            tempTrailMap.fill(0);

            for (let y = 1; y < HEIGHT - 1; y++) {
                for (let x = 1; x < WIDTH - 1; x++) {
                    const index = y * WIDTH + x;

                    // 3x3 box blur
                    let sum = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            sum += trailMap[(y + dy) * WIDTH + (x + dx)];
                        }
                    }

                    tempTrailMap[index] = (sum / 9) * params.decay;
                }
            }

            // Swap buffers
            [trailMap, tempTrailMap] = [tempTrailMap, trailMap];
        }

        function calculateDensity() {
            let count = 0;
            for (let i = 0; i < trailMap.length; i++) {
                if (trailMap[i] > 5) count++;
            }
            return ((count / trailMap.length) * 100).toFixed(1);
        }

        function drawTrails() {
            const imageData = ctx.createImageData(WIDTH, HEIGHT);
            const data = imageData.data;

            for (let i = 0; i < trailMap.length; i++) {
                const value = trailMap[i];
                const dataIndex = i * 4;

                if (value > 0) {
                    // Yellow-gold gradient
                    const intensity = Math.min(value / 100, 1);
                    data[dataIndex] = Math.floor(255 * intensity);     // R
                    data[dataIndex + 1] = Math.floor(215 * intensity); // G
                    data[dataIndex + 2] = 0;                           // B
                    data[dataIndex + 3] = Math.floor(255 * intensity); // A
                } else {
                    data[dataIndex + 3] = 0; // Transparent
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            if (!paused) {
                // Update agents
                agents.forEach(agent => agent.update());

                // Diffuse and decay trails
                diffuseAndDecay();

                // Clear and draw
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Draw trails
                drawTrails();

                // Draw food sources
                foodSources.forEach(food => {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                    ctx.strokeStyle = '#ff6464';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });

                // Update density
                document.getElementById('density').textContent = calculateDensity() + '%';

                updateFPS();
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('agentCount').addEventListener('input', (e) => {
            params.agentCount = parseInt(e.target.value);
            document.getElementById('agentCountValue').textContent = params.agentCount;

            // Adjust agent count
            while (agents.length < params.agentCount) {
                const food = foodSources[Math.floor(Math.random() * foodSources.length)];
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * food.radius;
                agents.push(new Agent(
                    food.x + Math.cos(angle) * dist,
                    food.y + Math.sin(angle) * dist
                ));
            }
            while (agents.length > params.agentCount) {
                agents.pop();
            }
            updateStats();
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = params.speed.toFixed(1);
        });

        document.getElementById('sensorAngle').addEventListener('input', (e) => {
            const degrees = parseInt(e.target.value);
            params.sensorAngleRad = degrees * Math.PI / 180;
            document.getElementById('sensorAngleValue').textContent = degrees + '째';
        });

        document.getElementById('sensorDist').addEventListener('input', (e) => {
            params.sensorDist = parseInt(e.target.value);
            document.getElementById('sensorDistValue').textContent = params.sensorDist;
        });

        document.getElementById('turnSpeed').addEventListener('input', (e) => {
            const degrees = parseInt(e.target.value);
            params.turnSpeed = degrees * Math.PI / 180;
            document.getElementById('turnSpeedValue').textContent = degrees + '째';
        });

        document.getElementById('decay').addEventListener('input', (e) => {
            params.decay = parseFloat(e.target.value);
            document.getElementById('decayValue').textContent = params.decay.toFixed(2);
        });

        document.getElementById('deposit').addEventListener('input', (e) => {
            params.deposit = parseInt(e.target.value);
            document.getElementById('depositValue').textContent = params.deposit;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initSimulation();
        });

        document.getElementById('addFoodBtn').addEventListener('click', () => {
            foodSources.push({
                x: Math.random() * (WIDTH - 100) + 50,
                y: Math.random() * (HEIGHT - 100) + 50,
                radius: 30
            });

            // Add some agents near new food
            const food = foodSources[foodSources.length - 1];
            for (let i = 0; i < 200; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * food.radius;
                agents.push(new Agent(
                    food.x + Math.cos(angle) * dist,
                    food.y + Math.sin(angle) * dist
                ));
            }

            updateStats();
        });

        document.getElementById('clearFoodBtn').addEventListener('click', () => {
            foodSources = [];
            updateStats();
        });

        // Click to add food
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            foodSources.push({ x, y, radius: 30 });

            // Add agents near clicked location
            for (let i = 0; i < 200; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 30;
                agents.push(new Agent(
                    x + Math.cos(angle) * dist,
                    y + Math.sin(angle) * dist
                ));
            }

            updateStats();
        });

        animate();
    </script>
</body>
</html>
