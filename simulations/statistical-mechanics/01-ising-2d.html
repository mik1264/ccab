<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Ising Model - Statistical Mechanics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            text-align: center;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: #000;
            max-width: 100%;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #ffd700;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffd700;
            font-family: 'Courier New', monospace;
        }

        .graph-container {
            margin-top: 20px;
        }

        .critical-temp-indicator {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 215, 0, 0.2);
            border-left: 4px solid #ffd700;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>2D Ising Model</h1>
            <p class="subtitle">Ferromagnetic Phase Transition Simulation</p>
        </header>

        <div class="info-box">
            <h3>Physical Model</h3>
            <p>The Ising model describes ferromagnetism in statistical mechanics. Each spin on a lattice can be in one of two states (‚Üë or ‚Üì), representing microscopic magnetic moments.</p>
            <div class="equation">
                H = -J Œ£ s<sub>i</sub>¬∑s<sub>j</sub> - h Œ£ s<sub>i</sub>
            </div>
            <p><strong>Metropolis Algorithm:</strong> Accept spin flip if ŒîE &lt; 0, or with probability exp(-ŒîE/(k<sub>B</sub>T))</p>
            <p><strong>Critical Temperature:</strong> T<sub>c</sub> ‚âà 2.27 J/k<sub>B</sub> (exact: 2/(ln(1+‚àö2)) ‚âà 2.269)</p>
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <h3>Spin Lattice</h3>
                <canvas id="latticeCanvas" width="500" height="500"></canvas>
                <p style="margin-top: 10px; font-size: 0.9rem;">White = Spin Up (+1) | Black = Spin Down (-1)</p>
            </div>

            <div class="canvas-container">
                <h3>Magnetization vs Time</h3>
                <canvas id="graphCanvas" width="500" height="500"></canvas>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    Temperature (T): <span class="value-display" id="tempValue">2.27</span> J/k<sub>B</sub>
                </label>
                <input type="range" id="temperature" min="0.1" max="5.0" step="0.01" value="2.27">
                <div class="critical-temp-indicator" id="criticalIndicator">
                    ‚ö†Ô∏è Near Critical Temperature
                </div>
            </div>

            <div class="control-group">
                <label>
                    External Field (h): <span class="value-display" id="fieldValue">0.00</span> J
                </label>
                <input type="range" id="externalField" min="-1.0" max="1.0" step="0.01" value="0">
            </div>

            <div class="control-group">
                <label>
                    Lattice Size: <span class="value-display" id="sizeValue">100</span> √ó <span id="sizeValue2">100</span>
                </label>
                <input type="range" id="latticeSize" min="50" max="200" step="10" value="100">
            </div>

            <div class="control-group">
                <label>
                    Simulation Speed: <span class="value-display" id="speedValue">10</span> steps/frame
                </label>
                <input type="range" id="speed" min="1" max="100" step="1" value="10">
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Magnetization</div>
                    <div class="stat-value" id="magnetization">0.00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Energy/Spin</div>
                    <div class="stat-value" id="energy">0.00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Steps</div>
                    <div class="stat-value" id="steps">0</div>
                </div>
            </div>

            <div class="button-group">
                <button class="primary" id="playPause">Pause</button>
                <button class="secondary" id="reset">Reset</button>
                <button class="primary" id="randomize">Randomize</button>
                <button class="secondary" id="allUp">All Spins Up</button>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const latticeCanvas = document.getElementById('latticeCanvas');
        const latticeCtx = latticeCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        // Simulation parameters
        let N = 100; // Lattice size
        let T = 2.27; // Temperature
        let h = 0.0; // External field
        let J = 1.0; // Coupling constant
        let kB = 1.0; // Boltzmann constant

        // Simulation state
        let lattice = [];
        let magnetizationHistory = [];
        let steps = 0;
        let running = true;
        let stepsPerFrame = 10;

        // Initialize lattice
        function initializeLattice(random = true) {
            lattice = [];
            for (let i = 0; i < N; i++) {
                lattice[i] = [];
                for (let j = 0; j < N; j++) {
                    if (random) {
                        lattice[i][j] = Math.random() < 0.5 ? 1 : -1;
                    } else {
                        lattice[i][j] = 1;
                    }
                }
            }
            magnetizationHistory = [];
            steps = 0;
        }

        // Calculate energy change for flipping spin at (i, j)
        function deltaEnergy(i, j) {
            const s = lattice[i][j];
            const iUp = (i - 1 + N) % N;
            const iDown = (i + 1) % N;
            const jLeft = (j - 1 + N) % N;
            const jRight = (j + 1) % N;

            const neighbors = lattice[iUp][j] + lattice[iDown][j] +
                            lattice[i][jLeft] + lattice[i][jRight];

            // Energy change from flipping spin
            return 2 * s * (J * neighbors + h);
        }

        // Metropolis algorithm step
        function metropolisStep() {
            // Random spin selection
            const i = Math.floor(Math.random() * N);
            const j = Math.floor(Math.random() * N);

            const dE = deltaEnergy(i, j);

            // Accept or reject flip
            if (dE <= 0 || Math.random() < Math.exp(-dE / (kB * T))) {
                lattice[i][j] *= -1;
            }
        }

        // Calculate magnetization
        function calculateMagnetization() {
            let sum = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    sum += lattice[i][j];
                }
            }
            return sum / (N * N);
        }

        // Calculate energy per spin
        function calculateEnergy() {
            let energy = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const iDown = (i + 1) % N;
                    const jRight = (j + 1) % N;

                    // Count each bond once
                    energy -= J * lattice[i][j] * (lattice[iDown][j] + lattice[i][jRight]);
                    energy -= h * lattice[i][j];
                }
            }
            return energy / (N * N);
        }

        // Draw lattice
        function drawLattice() {
            const cellSize = latticeCanvas.width / N;

            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    if (lattice[i][j] === 1) {
                        latticeCtx.fillStyle = '#ffffff';
                    } else {
                        latticeCtx.fillStyle = '#000000';
                    }
                    latticeCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
        }

        // Draw graph
        function drawGraph() {
            const width = graphCanvas.width;
            const height = graphCanvas.height;
            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Clear canvas
            graphCtx.fillStyle = '#000';
            graphCtx.fillRect(0, 0, width, height);

            // Draw axes
            graphCtx.strokeStyle = '#fff';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, height - padding);
            graphCtx.lineTo(width - padding, height - padding);
            graphCtx.stroke();

            // Draw labels
            graphCtx.fillStyle = '#fff';
            graphCtx.font = '14px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('Time Steps', width / 2, height - 10);

            graphCtx.save();
            graphCtx.translate(15, height / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('Magnetization', 0, 0);
            graphCtx.restore();

            // Draw grid lines
            graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            graphCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (graphHeight * i) / 4;
                graphCtx.beginPath();
                graphCtx.moveTo(padding, y);
                graphCtx.lineTo(width - padding, y);
                graphCtx.stroke();

                // Y-axis labels
                const value = (1 - 0.5 * i).toFixed(1);
                graphCtx.fillStyle = '#fff';
                graphCtx.textAlign = 'right';
                graphCtx.fillText(value, padding - 10, y + 5);
            }

            // Draw magnetization history
            if (magnetizationHistory.length > 1) {
                const maxPoints = 500;
                const startIdx = Math.max(0, magnetizationHistory.length - maxPoints);
                const dataPoints = magnetizationHistory.slice(startIdx);

                graphCtx.strokeStyle = '#ffd700';
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();

                for (let i = 0; i < dataPoints.length; i++) {
                    const x = padding + (graphWidth * i) / Math.max(dataPoints.length - 1, 1);
                    const m = dataPoints[i];
                    const y = padding + graphHeight * (1 - m) / 2;

                    if (i === 0) {
                        graphCtx.moveTo(x, y);
                    } else {
                        graphCtx.lineTo(x, y);
                    }
                }
                graphCtx.stroke();
            }

            // Draw zero line
            graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            graphCtx.lineWidth = 1;
            graphCtx.setLineDash([5, 5]);
            graphCtx.beginPath();
            graphCtx.moveTo(padding, height / 2);
            graphCtx.lineTo(width - padding, height / 2);
            graphCtx.stroke();
            graphCtx.setLineDash([]);
        }

        // Update statistics display
        function updateStats() {
            const m = calculateMagnetization();
            const e = calculateEnergy();

            document.getElementById('magnetization').textContent = m.toFixed(3);
            document.getElementById('energy').textContent = e.toFixed(3);
            document.getElementById('steps').textContent = steps;

            // Update critical temperature indicator
            const criticalTemp = 2.269;
            const indicator = document.getElementById('criticalIndicator');
            if (Math.abs(T - criticalTemp) < 0.2) {
                indicator.style.display = 'block';
                indicator.innerHTML = '‚ö†Ô∏è Near Critical Temperature (T<sub>c</sub> ‚âà 2.27 J/k<sub>B</sub>)';
            } else if (T < criticalTemp) {
                indicator.style.display = 'block';
                indicator.style.background = 'rgba(100, 150, 255, 0.2)';
                indicator.style.borderColor = '#6496ff';
                indicator.innerHTML = '‚ùÑÔ∏è Ferromagnetic Phase (T &lt; T<sub>c</sub>)';
            } else {
                indicator.style.display = 'block';
                indicator.style.background = 'rgba(255, 100, 100, 0.2)';
                indicator.style.borderColor = '#ff6464';
                indicator.innerHTML = 'üî• Paramagnetic Phase (T &gt; T<sub>c</sub>)';
            }
        }

        // Animation loop
        function animate() {
            if (running) {
                for (let i = 0; i < stepsPerFrame; i++) {
                    metropolisStep();
                    steps++;
                }

                // Record magnetization every 10 steps
                if (steps % 10 === 0) {
                    magnetizationHistory.push(calculateMagnetization());
                    if (magnetizationHistory.length > 500) {
                        magnetizationHistory.shift();
                    }
                }
            }

            drawLattice();
            drawGraph();
            updateStats();

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('temperature').addEventListener('input', (e) => {
            T = parseFloat(e.target.value);
            document.getElementById('tempValue').textContent = T.toFixed(2);
        });

        document.getElementById('externalField').addEventListener('input', (e) => {
            h = parseFloat(e.target.value);
            document.getElementById('fieldValue').textContent = h.toFixed(2);
        });

        document.getElementById('latticeSize').addEventListener('input', (e) => {
            N = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = N;
            document.getElementById('sizeValue2').textContent = N;
            initializeLattice(true);
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            stepsPerFrame = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = stepsPerFrame;
        });

        document.getElementById('playPause').addEventListener('click', () => {
            running = !running;
            document.getElementById('playPause').textContent = running ? 'Pause' : 'Play';
        });

        document.getElementById('reset').addEventListener('click', () => {
            initializeLattice(true);
        });

        document.getElementById('randomize').addEventListener('click', () => {
            initializeLattice(true);
        });

        document.getElementById('allUp').addEventListener('click', () => {
            initializeLattice(false);
        });

        // Initialize and start
        initializeLattice(true);
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
