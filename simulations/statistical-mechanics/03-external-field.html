<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ising Model with External Field - Statistical Mechanics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
            color: #fff;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #a8edea;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 8px 0;
            text-align: center;
            font-size: 0.95rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 600px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
        }

        .canvas-container h3 {
            margin-bottom: 15px;
            color: #a8edea;
            text-align: center;
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: #000;
            display: block;
            margin: 0 auto;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #a8edea;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a8edea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a8edea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
            width: 100%;
            margin-bottom: 10px;
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        button.sweep {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        button.reset {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #a8edea;
            font-family: 'Courier New', monospace;
        }

        .hysteresis-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .hysteresis-info h4 {
            color: #a8edea;
            margin-bottom: 10px;
        }

        .hysteresis-info p {
            font-size: 0.9rem;
            margin: 5px 0;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ising Model with External Magnetic Field</h1>
            <p class="subtitle">Hysteresis Loop and Magnetic Properties</p>
        </header>

        <div class="info-box">
            <h3>Magnetic Hysteresis</h3>
            <p>When an external magnetic field is applied to a ferromagnetic material, the magnetization follows different paths during field increase and decrease, creating a hysteresis loop. This demonstrates magnetic memory and energy dissipation.</p>
            <div class="equation">
                H = -J Σ s<sub>i</sub>·s<sub>j</sub> - h Σ s<sub>i</sub>
            </div>
            <p><strong>Key Properties:</strong> Coercivity (field to demagnetize), Remanence (residual magnetization), Saturation (maximum magnetization)</p>
        </div>

        <div class="main-grid">
            <div class="canvas-container">
                <h3>Magnetization-Field Hysteresis Loop</h3>
                <canvas id="hysteresisCanvas" width="550" height="550"></canvas>
                <p style="text-align: center; margin-top: 10px; font-size: 0.9rem;">M-H Curve showing hysteresis behavior</p>
            </div>

            <div>
                <div class="canvas-container" style="margin-bottom: 20px;">
                    <h3>Spin Lattice (100×100)</h3>
                    <canvas id="latticeCanvas" width="400" height="400"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Magnetization vs Time</h3>
                    <canvas id="timeCanvas" width="400" height="250"></canvas>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    Temperature (T): <span class="value-display" id="tempValue">1.50</span> J/k<sub>B</sub>
                </label>
                <input type="range" id="temperature" min="0.5" max="3.0" step="0.1" value="1.5">
            </div>

            <div class="control-group">
                <label>
                    External Field (h): <span class="value-display" id="fieldValue">0.00</span> J
                </label>
                <input type="range" id="externalField" min="-2.0" max="2.0" step="0.05" value="0">
            </div>

            <div class="control-group">
                <label>
                    Field Sweep Rate: <span class="value-display" id="sweepRateValue">0.02</span> J/step
                </label>
                <input type="range" id="sweepRate" min="0.005" max="0.1" step="0.005" value="0.02">
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Magnetization</div>
                    <div class="stat-value" id="magnetization">0.00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Energy/Spin</div>
                    <div class="stat-value" id="energy">0.00</div>
                </div>
            </div>

            <button class="primary" id="playPause">Pause</button>
            <button class="sweep" id="startSweep">Start Hysteresis Sweep</button>
            <button class="reset" id="reset">Reset Lattice</button>
            <button class="primary" id="clearLoop">Clear Hysteresis Loop</button>

            <div class="hysteresis-info">
                <h4>Hysteresis Properties</h4>
                <p><strong>Coercivity (H<sub>c</sub>):</strong> <span id="coercivity">—</span></p>
                <p><strong>Remanence (M<sub>r</sub>):</strong> <span id="remanence">—</span></p>
                <p><strong>Saturation (M<sub>s</sub>):</strong> <span id="saturation">—</span></p>
                <p><strong>Loop Area:</strong> <span id="loopArea">—</span> (energy dissipation)</p>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const hysteresisCanvas = document.getElementById('hysteresisCanvas');
        const hystCtx = hysteresisCanvas.getContext('2d');
        const latticeCanvas = document.getElementById('latticeCanvas');
        const latticeCtx = latticeCanvas.getContext('2d');
        const timeCanvas = document.getElementById('timeCanvas');
        const timeCtx = timeCanvas.getContext('2d');

        // Parameters
        const N = 100;
        let T = 1.5;
        let h = 0.0;
        let J = 1.0;
        let kB = 1.0;
        let sweepRate = 0.02;

        // State
        let lattice = [];
        let running = true;
        let isSweeping = false;
        let sweepDirection = 1;
        let hysteresisData = [];
        let magnetizationHistory = [];
        let steps = 0;

        // Hysteresis properties
        let coercivity = null;
        let remanence = null;
        let saturation = null;

        // Initialize
        function initializeLattice() {
            lattice = [];
            for (let i = 0; i < N; i++) {
                lattice[i] = [];
                for (let j = 0; j < N; j++) {
                    lattice[i][j] = 1; // Start with all spins up
                }
            }
            magnetizationHistory = [];
            steps = 0;
        }

        // Energy change
        function deltaEnergy(i, j) {
            const s = lattice[i][j];
            const iUp = (i - 1 + N) % N;
            const iDown = (i + 1) % N;
            const jLeft = (j - 1 + N) % N;
            const jRight = (j + 1) % N;

            const neighbors = lattice[iUp][j] + lattice[iDown][j] +
                            lattice[i][jLeft] + lattice[i][jRight];

            return 2 * s * (J * neighbors + h);
        }

        // Metropolis step
        function metropolisStep() {
            for (let k = 0; k < N * N / 10; k++) {
                const i = Math.floor(Math.random() * N);
                const j = Math.floor(Math.random() * N);
                const dE = deltaEnergy(i, j);

                if (dE <= 0 || Math.random() < Math.exp(-dE / (kB * T))) {
                    lattice[i][j] *= -1;
                }
            }
        }

        // Calculate magnetization
        function calculateMagnetization() {
            let sum = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    sum += lattice[i][j];
                }
            }
            return sum / (N * N);
        }

        // Calculate energy
        function calculateEnergy() {
            let energy = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const iDown = (i + 1) % N;
                    const jRight = (j + 1) % N;
                    energy -= J * lattice[i][j] * (lattice[iDown][j] + lattice[i][jRight]);
                    energy -= h * lattice[i][j];
                }
            }
            return energy / (N * N);
        }

        // Draw lattice
        function drawLattice() {
            const cellSize = latticeCanvas.width / N;

            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const value = (lattice[i][j] + 1) / 2;
                    const r = Math.floor(255 * (1 - value));
                    const b = Math.floor(255 * value);
                    latticeCtx.fillStyle = `rgb(${r}, 0, ${b})`;
                    latticeCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
        }

        // Draw hysteresis loop
        function drawHysteresis() {
            const width = hysteresisCanvas.width;
            const height = hysteresisCanvas.height;
            const padding = 60;

            hystCtx.fillStyle = '#000';
            hystCtx.fillRect(0, 0, width, height);

            // Axes
            hystCtx.strokeStyle = '#fff';
            hystCtx.lineWidth = 2;
            hystCtx.beginPath();
            hystCtx.moveTo(padding, height / 2);
            hystCtx.lineTo(width - padding, height / 2);
            hystCtx.moveTo(width / 2, padding);
            hystCtx.lineTo(width / 2, height - padding);
            hystCtx.stroke();

            // Labels
            hystCtx.fillStyle = '#fff';
            hystCtx.font = '14px Arial';
            hystCtx.textAlign = 'center';
            hystCtx.fillText('External Field (h)', width / 2, height - 20);

            hystCtx.save();
            hystCtx.translate(20, height / 2);
            hystCtx.rotate(-Math.PI / 2);
            hystCtx.fillText('Magnetization (M)', 0, 0);
            hystCtx.restore();

            // Grid
            hystCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            hystCtx.lineWidth = 1;
            for (let i = -1; i <= 1; i += 0.5) {
                if (i === 0) continue;
                const x = width / 2 + i * (width - 2 * padding) / 4;
                hystCtx.beginPath();
                hystCtx.moveTo(x, padding);
                hystCtx.lineTo(x, height - padding);
                hystCtx.stroke();

                const y = height / 2 - i * (height - 2 * padding) / 4;
                hystCtx.beginPath();
                hystCtx.moveTo(padding, y);
                hystCtx.lineTo(width - padding, y);
                hystCtx.stroke();
            }

            // Scale labels
            hystCtx.fillStyle = '#fff';
            hystCtx.font = '11px Arial';
            hystCtx.textAlign = 'center';
            [-2, -1, 1, 2].forEach(val => {
                const x = width / 2 + val * (width - 2 * padding) / 4;
                hystCtx.fillText(val.toString(), x, height / 2 + 20);
            });

            hystCtx.textAlign = 'right';
            [-1, -0.5, 0.5, 1].forEach(val => {
                const y = height / 2 - val * (height - 2 * padding) / 2;
                hystCtx.fillText(val.toFixed(1), padding - 10, y + 5);
            });

            // Draw hysteresis data
            if (hysteresisData.length > 1) {
                hystCtx.strokeStyle = '#a8edea';
                hystCtx.lineWidth = 3;
                hystCtx.beginPath();

                hysteresisData.forEach((point, i) => {
                    const x = width / 2 + point.h * (width - 2 * padding) / 4;
                    const y = height / 2 - point.m * (height - 2 * padding) / 2;

                    if (i === 0) hystCtx.moveTo(x, y);
                    else hystCtx.lineTo(x, y);
                });

                hystCtx.stroke();

                // Current point
                const last = hysteresisData[hysteresisData.length - 1];
                const x = width / 2 + last.h * (width - 2 * padding) / 4;
                const y = height / 2 - last.m * (height - 2 * padding) / 2;

                hystCtx.fillStyle = '#fee140';
                hystCtx.beginPath();
                hystCtx.arc(x, y, 6, 0, Math.PI * 2);
                hystCtx.fill();
            }
        }

        // Draw time series
        function drawTimeSeries() {
            const width = timeCanvas.width;
            const height = timeCanvas.height;
            const padding = 40;

            timeCtx.fillStyle = '#000';
            timeCtx.fillRect(0, 0, width, height);

            // Axes
            timeCtx.strokeStyle = '#fff';
            timeCtx.lineWidth = 2;
            timeCtx.beginPath();
            timeCtx.moveTo(padding, padding);
            timeCtx.lineTo(padding, height - padding);
            timeCtx.lineTo(width - padding, height - padding);
            timeCtx.stroke();

            if (magnetizationHistory.length < 2) return;

            const maxPoints = 300;
            const data = magnetizationHistory.slice(-maxPoints);

            timeCtx.strokeStyle = '#a8edea';
            timeCtx.lineWidth = 2;
            timeCtx.beginPath();

            data.forEach((m, i) => {
                const x = padding + (i / (data.length - 1)) * (width - 2 * padding);
                const y = height / 2 - m * (height - 2 * padding) / 2;

                if (i === 0) timeCtx.moveTo(x, y);
                else timeCtx.lineTo(x, y);
            });

            timeCtx.stroke();

            // Zero line
            timeCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            timeCtx.setLineDash([5, 5]);
            timeCtx.beginPath();
            timeCtx.moveTo(padding, height / 2);
            timeCtx.lineTo(width - padding, height / 2);
            timeCtx.stroke();
            timeCtx.setLineDash([]);
        }

        // Analyze hysteresis
        function analyzeHysteresis() {
            if (hysteresisData.length < 10) return;

            // Find saturation (max |M|)
            saturation = Math.max(...hysteresisData.map(p => Math.abs(p.m)));

            // Find remanence (M when h ≈ 0)
            const zeroField = hysteresisData.filter(p => Math.abs(p.h) < 0.1);
            if (zeroField.length > 0) {
                remanence = Math.abs(zeroField[0].m);
            }

            // Find coercivity (h when M ≈ 0)
            const zeroMag = hysteresisData.filter(p => Math.abs(p.m) < 0.1);
            if (zeroMag.length > 0) {
                coercivity = Math.abs(zeroMag[0].h);
            }

            // Calculate loop area (energy dissipation)
            let area = 0;
            for (let i = 1; i < hysteresisData.length; i++) {
                const dh = hysteresisData[i].h - hysteresisData[i - 1].h;
                const avgM = (hysteresisData[i].m + hysteresisData[i - 1].m) / 2;
                area += Math.abs(avgM * dh);
            }

            document.getElementById('coercivity').textContent = coercivity ? coercivity.toFixed(3) : '—';
            document.getElementById('remanence').textContent = remanence ? remanence.toFixed(3) : '—';
            document.getElementById('saturation').textContent = saturation ? saturation.toFixed(3) : '—';
            document.getElementById('loopArea').textContent = area > 0 ? area.toFixed(3) : '—';
        }

        // Field sweep
        function performSweep() {
            if (!isSweeping) return;

            h += sweepDirection * sweepRate;

            if (h >= 2.0) {
                h = 2.0;
                sweepDirection = -1;
            } else if (h <= -2.0) {
                h = -2.0;
                sweepDirection = 1;
            }

            document.getElementById('externalField').value = h;
            document.getElementById('fieldValue').textContent = h.toFixed(2);

            // Record point
            const m = calculateMagnetization();
            hysteresisData.push({ h: h, m: m });

            // Stop after full loop
            if (hysteresisData.length > 2 && Math.abs(h - hysteresisData[0].h) < 0.1 && sweepDirection === 1) {
                isSweeping = false;
                document.getElementById('startSweep').textContent = 'Start Hysteresis Sweep';
                document.getElementById('startSweep').disabled = false;
            }
        }

        // Update stats
        function updateStats() {
            const m = calculateMagnetization();
            const e = calculateEnergy();

            document.getElementById('magnetization').textContent = m.toFixed(3);
            document.getElementById('energy').textContent = e.toFixed(3);
        }

        // Animation loop
        function animate() {
            if (running) {
                metropolisStep();
                steps++;

                if (steps % 5 === 0) {
                    const m = calculateMagnetization();
                    magnetizationHistory.push(m);
                    if (magnetizationHistory.length > 300) {
                        magnetizationHistory.shift();
                    }
                }

                if (isSweeping && steps % 20 === 0) {
                    performSweep();
                    analyzeHysteresis();
                }
            }

            drawLattice();
            drawHysteresis();
            drawTimeSeries();
            updateStats();

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('temperature').addEventListener('input', (e) => {
            T = parseFloat(e.target.value);
            document.getElementById('tempValue').textContent = T.toFixed(2);
        });

        document.getElementById('externalField').addEventListener('input', (e) => {
            if (!isSweeping) {
                h = parseFloat(e.target.value);
                document.getElementById('fieldValue').textContent = h.toFixed(2);
            }
        });

        document.getElementById('sweepRate').addEventListener('input', (e) => {
            sweepRate = parseFloat(e.target.value);
            document.getElementById('sweepRateValue').textContent = sweepRate.toFixed(3);
        });

        document.getElementById('playPause').addEventListener('click', () => {
            running = !running;
            document.getElementById('playPause').textContent = running ? 'Pause' : 'Play';
        });

        document.getElementById('startSweep').addEventListener('click', () => {
            if (!isSweeping) {
                isSweeping = true;
                sweepDirection = 1;
                h = -2.0;
                hysteresisData = [];
                document.getElementById('startSweep').textContent = 'Sweeping...';
                document.getElementById('startSweep').disabled = true;
            }
        });

        document.getElementById('reset').addEventListener('click', () => {
            initializeLattice();
        });

        document.getElementById('clearLoop').addEventListener('click', () => {
            hysteresisData = [];
            coercivity = null;
            remanence = null;
            saturation = null;
            document.getElementById('coercivity').textContent = '—';
            document.getElementById('remanence').textContent = '—';
            document.getElementById('saturation').textContent = '—';
            document.getElementById('loopArea').textContent = '—';
        });

        // Initialize
        initializeLattice();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
