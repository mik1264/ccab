<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ising Model Phase Transition - Statistical Mechanics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #fff;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .graphs-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-container h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: #000;
            max-width: 100%;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4ecdc4;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
        }

        button.primary {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button.sweep {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            grid-column: span 2;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
        }

        .phase-indicator {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .ferromagnetic {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .paramagnetic {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .critical {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .graphs-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ising Model Phase Transition Explorer</h1>
            <p class="subtitle">Critical Phenomena and Order-Disorder Transition</p>
        </header>

        <div class="info-box">
            <h3>Phase Transition at Critical Temperature</h3>
            <p>At T<sub>c</sub> ‚âà 2.269 J/k<sub>B</sub>, the 2D Ising model undergoes a continuous phase transition from ferromagnetic order to paramagnetic disorder. Near T<sub>c</sub>, the system exhibits critical behavior with diverging correlation length and susceptibility.</p>
            <p><strong>Wolff Algorithm:</strong> Cluster update method for faster equilibration near critical point.</p>
        </div>

        <div class="main-grid">
            <div class="canvas-container">
                <h3>Spin Lattice Configuration</h3>
                <canvas id="latticeCanvas" width="500" height="500"></canvas>
                <div class="phase-indicator" id="phaseIndicator">Initializing...</div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>
                        Temperature (T): <span class="value-display" id="tempValue">1.00</span> J/k<sub>B</sub>
                    </label>
                    <input type="range" id="temperature" min="0.5" max="4.0" step="0.05" value="1.0">
                </div>

                <div class="control-group">
                    <label>
                        Lattice Size: <span class="value-display" id="sizeValue">100</span> √ó 100
                    </label>
                    <input type="range" id="latticeSize" min="50" max="150" step="10" value="100">
                </div>

                <div class="control-group">
                    <label>
                        Update Algorithm:
                    </label>
                    <select id="algorithm" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(0,0,0,0.3); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                        <option value="metropolis">Metropolis (Single Spin)</option>
                        <option value="wolff" selected>Wolff (Cluster Update)</option>
                    </select>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Magnetization</div>
                        <div class="stat-value" id="magnetization">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Susceptibility</div>
                        <div class="stat-value" id="susceptibility">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Heat Capacity</div>
                        <div class="stat-value" id="heatCapacity">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Steps</div>
                        <div class="stat-value" id="steps">0</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="primary" id="playPause">Pause</button>
                    <button class="secondary" id="reset">Reset</button>
                    <button class="sweep" id="tempSweep">Start Temperature Sweep</button>
                </div>
            </div>
        </div>

        <div class="graphs-grid">
            <div class="canvas-container">
                <h3>Magnetization vs Temperature</h3>
                <canvas id="magGraph" width="400" height="300"></canvas>
            </div>

            <div class="canvas-container">
                <h3>Susceptibility vs Temperature</h3>
                <canvas id="chiGraph" width="400" height="300"></canvas>
            </div>

            <div class="canvas-container">
                <h3>Heat Capacity vs Temperature</h3>
                <canvas id="cvGraph" width="400" height="300"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const latticeCanvas = document.getElementById('latticeCanvas');
        const latticeCtx = latticeCanvas.getContext('2d');
        const magGraph = document.getElementById('magGraph');
        const magCtx = magGraph.getContext('2d');
        const chiGraph = document.getElementById('chiGraph');
        const chiCtx = chiGraph.getContext('2d');
        const cvGraph = document.getElementById('cvGraph');
        const cvCtx = cvGraph.getContext('2d');

        // Simulation parameters
        let N = 100;
        let T = 1.0;
        let J = 1.0;
        let kB = 1.0;
        const Tc = 2.269;

        // Simulation state
        let lattice = [];
        let running = true;
        let steps = 0;
        let algorithm = 'wolff';

        // Statistical data
        let magnetizationData = [];
        let energyData = [];
        let tempSweepData = [];
        let isSweeping = false;
        let sweepDirection = 1;

        // Initialize lattice
        function initializeLattice() {
            lattice = [];
            for (let i = 0; i < N; i++) {
                lattice[i] = [];
                for (let j = 0; j < N; j++) {
                    lattice[i][j] = Math.random() < 0.5 ? 1 : -1;
                }
            }
            steps = 0;
            magnetizationData = [];
            energyData = [];
        }

        // Calculate energy change (Metropolis)
        function deltaEnergy(i, j) {
            const s = lattice[i][j];
            const iUp = (i - 1 + N) % N;
            const iDown = (i + 1) % N;
            const jLeft = (j - 1 + N) % N;
            const jRight = (j + 1) % N;

            const neighbors = lattice[iUp][j] + lattice[iDown][j] +
                            lattice[i][jLeft] + lattice[i][jRight];

            return 2 * s * J * neighbors;
        }

        // Metropolis algorithm
        function metropolisStep() {
            for (let k = 0; k < N * N; k++) {
                const i = Math.floor(Math.random() * N);
                const j = Math.floor(Math.random() * N);
                const dE = deltaEnergy(i, j);

                if (dE <= 0 || Math.random() < Math.exp(-dE / (kB * T))) {
                    lattice[i][j] *= -1;
                }
            }
        }

        // Wolff cluster algorithm
        function wolffStep() {
            const P_add = 1 - Math.exp(-2 * J / (kB * T));

            // Random starting spin
            const i0 = Math.floor(Math.random() * N);
            const j0 = Math.floor(Math.random() * N);
            const s0 = lattice[i0][j0];

            // Build cluster using BFS
            const cluster = [[i0, j0]];
            const inCluster = Array(N).fill(0).map(() => Array(N).fill(false));
            inCluster[i0][j0] = true;

            let ptr = 0;
            while (ptr < cluster.length) {
                const [i, j] = cluster[ptr++];

                // Check neighbors
                const neighbors = [
                    [(i - 1 + N) % N, j],
                    [(i + 1) % N, j],
                    [i, (j - 1 + N) % N],
                    [i, (j + 1) % N]
                ];

                for (const [ni, nj] of neighbors) {
                    if (!inCluster[ni][nj] && lattice[ni][nj] === s0) {
                        if (Math.random() < P_add) {
                            cluster.push([ni, nj]);
                            inCluster[ni][nj] = true;
                        }
                    }
                }
            }

            // Flip cluster
            for (const [i, j] of cluster) {
                lattice[i][j] *= -1;
            }
        }

        // Calculate magnetization
        function calculateMagnetization() {
            let sum = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    sum += lattice[i][j];
                }
            }
            return Math.abs(sum) / (N * N);
        }

        // Calculate energy
        function calculateEnergy() {
            let energy = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const iDown = (i + 1) % N;
                    const jRight = (j + 1) % N;
                    energy -= J * lattice[i][j] * (lattice[iDown][j] + lattice[i][jRight]);
                }
            }
            return energy / (N * N);
        }

        // Calculate susceptibility
        function calculateSusceptibility() {
            if (magnetizationData.length < 2) return 0;
            const recentData = magnetizationData.slice(-100);
            const mean = recentData.reduce((a, b) => a + b, 0) / recentData.length;
            const variance = recentData.reduce((sum, m) => sum + (m - mean) ** 2, 0) / recentData.length;
            return (N * N) * variance / (kB * T);
        }

        // Calculate heat capacity
        function calculateHeatCapacity() {
            if (energyData.length < 2) return 0;
            const recentData = energyData.slice(-100);
            const mean = recentData.reduce((a, b) => a + b, 0) / recentData.length;
            const variance = recentData.reduce((sum, e) => sum + (e - mean) ** 2, 0) / recentData.length;
            return (N * N) * variance / (kB * T * T);
        }

        // Draw lattice
        function drawLattice() {
            const cellSize = latticeCanvas.width / N;

            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const spin = lattice[i][j];
                    if (spin === 1) {
                        latticeCtx.fillStyle = '#ffffff';
                    } else {
                        latticeCtx.fillStyle = '#000000';
                    }
                    latticeCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
        }

        // Draw graph
        function drawGraph(canvas, ctx, data, yLabel, color, yMax = null) {
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;

            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Axes
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Temperature (T/J)', width / 2, height - 15);

            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();

            if (data.length < 2) return;

            // Find max value
            const maxY = yMax || Math.max(...data.map(d => d.value));
            const minT = Math.min(...data.map(d => d.temp));
            const maxT = Math.max(...data.map(d => d.temp));

            // Draw data
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            data.forEach((point, i) => {
                const x = padding + ((point.temp - minT) / (maxT - minT || 1)) * (width - 2 * padding);
                const y = height - padding - (point.value / maxY) * (height - 2 * padding);

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });

            ctx.stroke();

            // Draw critical temperature line
            if (minT <= Tc && maxT >= Tc) {
                const x = padding + ((Tc - minT) / (maxT - minT)) * (width - 2 * padding);
                ctx.strokeStyle = '#fee140';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#fee140';
                ctx.font = '11px Arial';
                ctx.fillText('T_c', x, padding - 10);
            }
        }

        // Update displays
        function updateStats() {
            const m = calculateMagnetization();
            const chi = calculateSusceptibility();
            const cv = calculateHeatCapacity();

            document.getElementById('magnetization').textContent = m.toFixed(3);
            document.getElementById('susceptibility').textContent = chi.toFixed(2);
            document.getElementById('heatCapacity').textContent = cv.toFixed(2);
            document.getElementById('steps').textContent = steps;

            // Update phase indicator
            const indicator = document.getElementById('phaseIndicator');
            if (Math.abs(T - Tc) < 0.2) {
                indicator.className = 'phase-indicator critical';
                indicator.innerHTML = '‚ö° Critical Region (T ‚âà T<sub>c</sub>)';
            } else if (T < Tc) {
                indicator.className = 'phase-indicator ferromagnetic';
                indicator.innerHTML = 'üß≤ Ferromagnetic Phase (T &lt; T<sub>c</sub>)';
            } else {
                indicator.className = 'phase-indicator paramagnetic';
                indicator.innerHTML = 'üå°Ô∏è Paramagnetic Phase (T &gt; T<sub>c</sub>)';
            }
        }

        // Temperature sweep
        function temperatureSweep() {
            if (!isSweeping) return;

            T += sweepDirection * 0.02;

            if (T >= 4.0) {
                sweepDirection = -1;
                T = 4.0;
            } else if (T <= 0.5) {
                isSweeping = false;
                document.getElementById('tempSweep').textContent = 'Start Temperature Sweep';
                document.getElementById('tempSweep').disabled = false;
                return;
            }

            document.getElementById('temperature').value = T;
            document.getElementById('tempValue').textContent = T.toFixed(2);

            // Record data
            if (steps > 100 && steps % 50 === 0) {
                const m = calculateMagnetization();
                const chi = calculateSusceptibility();
                const cv = calculateHeatCapacity();

                tempSweepData.push({
                    temp: T,
                    mag: m,
                    chi: chi,
                    cv: cv
                });
            }
        }

        // Animation loop
        function animate() {
            if (running) {
                if (algorithm === 'metropolis') {
                    metropolisStep();
                } else {
                    wolffStep();
                }
                steps++;

                // Record statistics
                if (steps % 10 === 0) {
                    const m = calculateMagnetization();
                    const e = calculateEnergy();
                    magnetizationData.push(m);
                    energyData.push(e);

                    if (magnetizationData.length > 200) {
                        magnetizationData.shift();
                        energyData.shift();
                    }
                }

                if (isSweeping && steps % 20 === 0) {
                    temperatureSweep();
                }
            }

            drawLattice();
            updateStats();

            // Draw graphs
            if (tempSweepData.length > 0) {
                const magData = tempSweepData.map(d => ({ temp: d.temp, value: d.mag }));
                const chiData = tempSweepData.map(d => ({ temp: d.temp, value: d.chi }));
                const cvData = tempSweepData.map(d => ({ temp: d.temp, value: d.cv }));

                drawGraph(magGraph, magCtx, magData, 'Magnetization', '#4ecdc4', 1.0);
                drawGraph(chiGraph, chiCtx, chiData, 'Susceptibility', '#f5576c');
                drawGraph(cvGraph, cvCtx, cvData, 'Heat Capacity', '#fee140');
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('temperature').addEventListener('input', (e) => {
            T = parseFloat(e.target.value);
            document.getElementById('tempValue').textContent = T.toFixed(2);
        });

        document.getElementById('latticeSize').addEventListener('input', (e) => {
            N = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = N;
            initializeLattice();
        });

        document.getElementById('algorithm').addEventListener('change', (e) => {
            algorithm = e.target.value;
        });

        document.getElementById('playPause').addEventListener('click', () => {
            running = !running;
            document.getElementById('playPause').textContent = running ? 'Pause' : 'Play';
        });

        document.getElementById('reset').addEventListener('click', () => {
            initializeLattice();
            tempSweepData = [];
        });

        document.getElementById('tempSweep').addEventListener('click', () => {
            if (!isSweeping) {
                isSweeping = true;
                sweepDirection = 1;
                T = 0.5;
                tempSweepData = [];
                initializeLattice();
                document.getElementById('tempSweep').textContent = 'Sweeping...';
                document.getElementById('tempSweep').disabled = true;
            }
        });

        // Initialize
        initializeLattice();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
