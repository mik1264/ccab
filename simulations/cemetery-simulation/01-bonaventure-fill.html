<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonaventure Cemetery Fill Simulation - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(180deg, #1a1f2e 0%, #0d1117 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header */
        .header {
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(138, 154, 91, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .back-link {
            color: #8A9A5B;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #DDA15E;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 400;
            color: #DDA15E;
            letter-spacing: 0.05em;
        }

        .subtitle {
            font-size: 0.85rem;
            color: #8A9A5B;
            font-style: italic;
        }

        /* Main content */
        .main-content {
            display: flex;
            flex: 1;
            gap: 1rem;
            padding: 1rem;
        }

        /* Canvas container */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0e14;
            border-radius: 8px;
            overflow: hidden;
            min-height: 500px;
        }

        #cemetery-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Timeline overlay */
        .timeline-overlay {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 0.75rem 2rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(138, 154, 91, 0.4);
        }

        .current-year {
            font-size: 2.5rem;
            font-weight: 700;
            color: #DDA15E;
            font-family: 'Georgia', serif;
        }

        .era-label {
            font-size: 0.85rem;
            color: #8A9A5B;
            margin-top: 0.25rem;
        }

        /* Event notification */
        .event-notification {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(188, 108, 37, 0.9);
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            max-width: 80%;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .event-notification.show {
            opacity: 1;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: rgba(20, 25, 35, 0.9);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid rgba(138, 154, 91, 0.2);
        }

        .panel h3 {
            color: #DDA15E;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Statistics */
        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 4px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #8A9A5B;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 1.1rem;
            color: #e8e6e1;
            font-weight: 600;
        }

        .stat-wide {
            grid-column: 1 / -1;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-row label {
            font-size: 0.8rem;
            color: #8A9A5B;
            min-width: 80px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            background: rgba(138, 154, 91, 0.3);
            border-radius: 2px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #DDA15E;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        button {
            flex: 1;
            padding: 0.6rem;
            border: none;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #8A9A5B;
            color: white;
        }

        .btn-primary:hover {
            background: #606C38;
        }

        .btn-secondary {
            background: rgba(138, 154, 91, 0.2);
            color: #8A9A5B;
            border: 1px solid rgba(138, 154, 91, 0.4);
        }

        .btn-secondary:hover {
            background: rgba(138, 154, 91, 0.3);
        }

        /* Demographics chart */
        .demo-chart {
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        /* Section legend */
        .section-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.4rem;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* History log */
        .history-log {
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.75rem;
        }

        .history-entry {
            padding: 0.4rem 0;
            border-bottom: 1px solid rgba(138, 154, 91, 0.1);
            display: flex;
            gap: 0.5rem;
        }

        .history-year {
            color: #DDA15E;
            font-weight: 600;
            min-width: 40px;
        }

        .history-text {
            color: #b0a090;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .panel {
                flex: 1;
                min-width: 280px;
            }
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #8A9A5B;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(138, 154, 91, 0.2);
            border-top-color: #8A9A5B;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <a href="../index.html" class="back-link">← Back to Simulations</a>
            <div>
                <h1>Bonaventure Cemetery</h1>
                <p class="subtitle">Historic Fill Simulation • Savannah, Georgia • Est. 1846</p>
            </div>
            <div></div>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <div id="loading">
                    <div class="spinner"></div>
                    <p>Preparing simulation...</p>
                </div>
                <canvas id="cemetery-canvas"></canvas>
                <div class="timeline-overlay">
                    <div class="current-year" id="year-display">1850</div>
                    <div class="era-label" id="era-label">Antebellum Period</div>
                </div>
                <div class="event-notification" id="event-notification"></div>
            </div>

            <aside class="sidebar">
                <div class="panel">
                    <h3>Cemetery Statistics</h3>
                    <div class="stat-grid">
                        <div class="stat">
                            <div class="stat-label">Total Burials</div>
                            <div class="stat-value" id="stat-total">0</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Capacity Used</div>
                            <div class="stat-value" id="stat-capacity">0%</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Burials/Year</div>
                            <div class="stat-value" id="stat-rate">0</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Avg Age at Death</div>
                            <div class="stat-value" id="stat-age">--</div>
                        </div>
                        <div class="stat stat-wide">
                            <div class="stat-label">Active Sections</div>
                            <div class="stat-value" id="stat-sections">A</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Simulation Controls</h3>
                    <div class="controls">
                        <div class="control-row">
                            <label>Speed</label>
                            <input type="range" id="speed-slider" min="1" max="20" value="5">
                        </div>
                        <div class="control-row">
                            <label>Year</label>
                            <input type="range" id="year-slider" min="1850" max="2025" value="1850">
                        </div>
                        <div class="btn-row">
                            <button class="btn-primary" id="btn-play">Play</button>
                            <button class="btn-secondary" id="btn-reset">Reset</button>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Cemetery Sections</h3>
                    <div class="section-legend" id="section-legend"></div>
                </div>

                <div class="panel">
                    <h3>Age Demographics</h3>
                    <canvas id="demo-chart" class="demo-chart"></canvas>
                </div>

                <div class="panel">
                    <h3>Historical Events</h3>
                    <div class="history-log" id="history-log"></div>
                </div>
            </aside>
        </div>
    </div>

    <script>
        // ============================================
        // BONAVENTURE CEMETERY FILL SIMULATION
        // Based on historical research of the actual cemetery
        // ============================================

        // Historical constants based on research
        const CEMETERY_DATA = {
            established: 1846,
            firstBurials: 1850,
            becamePublic: 1907,
            greenwichAdded: 1933,
            jewishSectionAdded: 1909,
            totalAcres: 160,
            originalAcres: 70,
            estimatedCapacity: 40000,
            currentBurials: 30000
        };

        // Cemetery sections with historical accuracy
        const SECTIONS = [
            { id: 'A', name: 'Section A (Original)', color: '#6B5B4F', year: 1850, capacity: 2000 },
            { id: 'B', name: 'Section B', color: '#7D6B5D', year: 1855, capacity: 2000 },
            { id: 'C', name: 'Section C', color: '#8F7B6A', year: 1858, capacity: 2200 },
            { id: 'D', name: 'Section D (Hodgson)', color: '#5A6B5A', year: 1862, capacity: 1800 },
            { id: 'E', name: 'Section E (Little Gracie)', color: '#4A5B4A', year: 1870, capacity: 2500 },
            { id: 'F', name: 'Section F', color: '#6A7B6A', year: 1875, capacity: 2000 },
            { id: 'G', name: 'Section G', color: '#5D6D7D', year: 1880, capacity: 2200 },
            { id: 'H', name: 'Section H', color: '#4D5D6D', year: 1885, capacity: 2000 },
            { id: 'J', name: 'Jewish Section', color: '#7B6B5B', year: 1909, capacity: 3000 },
            { id: 'K', name: 'Section K (Veterans)', color: '#5B5B6B', year: 1898, capacity: 1500 },
            { id: 'L', name: 'Section L', color: '#6B6B7B', year: 1915, capacity: 2500 },
            { id: 'M', name: 'Section M', color: '#5B6B6B', year: 1920, capacity: 3000 },
            { id: 'N', name: 'Section N', color: '#6B7B6B', year: 1935, capacity: 3500 },
            { id: 'O', name: 'Section O (Am. Legion)', color: '#4B5B5B', year: 1945, capacity: 2800 },
            { id: 'P', name: 'Section P', color: '#5B6B5B', year: 1960, capacity: 3000 },
            { id: 'Q', name: 'Section Q', color: '#6B6B6B', year: 1980, capacity: 3500 },
            { id: 'R', name: 'Section R (Modern)', color: '#5B5B5B', year: 2000, capacity: 2500 }
        ];

        // Historical events affecting burial rates
        const HISTORICAL_EVENTS = [
            { year: 1854, event: 'Yellow Fever epidemic strikes Savannah', multiplier: 2.5, duration: 1 },
            { year: 1861, event: 'Civil War begins - Confederate section established', multiplier: 1.5, duration: 4 },
            { year: 1876, event: 'Yellow Fever returns to Savannah', multiplier: 2.0, duration: 1 },
            { year: 1893, event: 'Hurricane devastates coastal Georgia', multiplier: 1.8, duration: 1 },
            { year: 1907, event: 'Cemetery becomes public, expansion begins', multiplier: 1.2, duration: 5 },
            { year: 1918, event: 'Spanish Flu pandemic', multiplier: 2.8, duration: 2 },
            { year: 1933, event: 'Greenwich Cemetery merged', multiplier: 1.3, duration: 2 },
            { year: 1940, event: 'Pre-WWII Savannah growth', multiplier: 1.1, duration: 5 },
            { year: 1945, event: 'WWII veterans return, some casualties buried', multiplier: 1.4, duration: 2 },
            { year: 1994, event: '"Midnight in the Garden" published - tourism increases', multiplier: 1.0, duration: 1 },
            { year: 2020, event: 'COVID-19 pandemic', multiplier: 1.6, duration: 2 }
        ];

        // Savannah population data (historical)
        const POPULATION_DATA = {
            1850: 15312,
            1860: 22292,
            1870: 28235,
            1880: 30709,
            1890: 43189,
            1900: 54244,
            1910: 65064,
            1920: 83252,
            1930: 85024,
            1940: 95996,
            1950: 119638,
            1960: 149245,
            1970: 118349,
            1980: 141634,
            1990: 137560,
            2000: 131510,
            2010: 136286,
            2020: 147780
        };

        // Era definitions
        const ERAS = [
            { start: 1850, end: 1860, name: 'Antebellum Period' },
            { start: 1861, end: 1865, name: 'Civil War Era' },
            { start: 1866, end: 1877, name: 'Reconstruction' },
            { start: 1878, end: 1899, name: 'Gilded Age' },
            { start: 1900, end: 1913, name: 'Progressive Era' },
            { start: 1914, end: 1918, name: 'World War I' },
            { start: 1919, end: 1928, name: 'Roaring Twenties' },
            { start: 1929, end: 1939, name: 'Great Depression' },
            { start: 1940, end: 1945, name: 'World War II' },
            { start: 1946, end: 1963, name: 'Post-War Era' },
            { start: 1964, end: 1979, name: 'Civil Rights Era' },
            { start: 1980, end: 1999, name: 'Late 20th Century' },
            { start: 2000, end: 2025, name: 'Modern Era' }
        ];

        // 19th century mortality by age group (historical patterns)
        const MORTALITY_PATTERNS = {
            1850: { infant: 0.30, child: 0.15, young: 0.10, middle: 0.20, elderly: 0.25 },
            1900: { infant: 0.22, child: 0.10, young: 0.12, middle: 0.24, elderly: 0.32 },
            1950: { infant: 0.08, child: 0.04, young: 0.08, middle: 0.25, elderly: 0.55 },
            2000: { infant: 0.02, child: 0.01, young: 0.05, middle: 0.22, elderly: 0.70 }
        };

        // Monument types based on era
        const MONUMENT_TYPES = [
            { name: 'Victorian Gothic', minYear: 1850, maxYear: 1890, style: 'gothic' },
            { name: 'Classical Roman', minYear: 1850, maxYear: 1920, style: 'classical' },
            { name: 'Egyptian Revival', minYear: 1860, maxYear: 1900, style: 'egyptian' },
            { name: 'Art Nouveau', minYear: 1890, maxYear: 1920, style: 'nouveau' },
            { name: 'Art Deco', minYear: 1920, maxYear: 1945, style: 'deco' },
            { name: 'Simple Headstone', minYear: 1850, maxYear: 2025, style: 'simple' },
            { name: 'Modern Flat Marker', minYear: 1960, maxYear: 2025, style: 'flat' }
        ];

        // ============================================
        // SIMULATION STATE
        // ============================================

        let state = {
            year: 1850,
            totalBurials: 0,
            burialsBySection: {},
            burialsByYear: [],
            ageDistribution: { infant: 0, child: 0, young: 0, middle: 0, elderly: 0 },
            graves: [],
            trees: [],
            paths: [],
            isPlaying: false,
            speed: 5,
            eventLog: [],
            currentEvent: null,
            eventEndYear: 0
        };

        // Canvas elements
        let mainCanvas, mainCtx;
        let demoCanvas, demoCtx;
        let dpr = window.devicePixelRatio || 1;

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            // Initialize canvases
            mainCanvas = document.getElementById('cemetery-canvas');
            mainCtx = mainCanvas.getContext('2d');
            demoCanvas = document.getElementById('demo-chart');
            demoCtx = demoCanvas.getContext('2d');

            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);

            // Initialize section burials
            SECTIONS.forEach(s => {
                state.burialsBySection[s.id] = 0;
            });

            // Generate cemetery layout
            generateTrees();
            generatePaths();

            // Setup controls
            setupControls();
            renderSectionLegend();

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Initial render
            render();
            updateStats();
        }

        function resizeCanvases() {
            const container = mainCanvas.parentElement;
            const rect = container.getBoundingClientRect();

            mainCanvas.width = rect.width * dpr;
            mainCanvas.height = rect.height * dpr;
            mainCanvas.style.width = rect.width + 'px';
            mainCanvas.style.height = rect.height + 'px';
            mainCtx.scale(dpr, dpr);

            // Demo chart
            const demoRect = demoCanvas.getBoundingClientRect();
            demoCanvas.width = demoRect.width * dpr;
            demoCanvas.height = demoRect.height * dpr;
            demoCtx.scale(dpr, dpr);

            if (state.graves.length > 0) {
                render();
            }
        }

        function generateTrees() {
            // Live oaks with Spanish moss - iconic Bonaventure feature
            const numTrees = 80;
            for (let i = 0; i < numTrees; i++) {
                state.trees.push({
                    x: Math.random(),
                    y: Math.random(),
                    size: 20 + Math.random() * 40,
                    mossLength: 10 + Math.random() * 25,
                    mossStrands: 3 + Math.floor(Math.random() * 5)
                });
            }
        }

        function generatePaths() {
            // Victorian curving pathways
            const mainPaths = [
                { type: 'main', points: [[0.1, 0.5], [0.3, 0.45], [0.5, 0.5], [0.7, 0.55], [0.9, 0.5]] },
                { type: 'main', points: [[0.5, 0.1], [0.45, 0.3], [0.5, 0.5], [0.55, 0.7], [0.5, 0.9]] },
                { type: 'secondary', points: [[0.2, 0.2], [0.35, 0.35], [0.5, 0.5]] },
                { type: 'secondary', points: [[0.8, 0.2], [0.65, 0.35], [0.5, 0.5]] },
                { type: 'secondary', points: [[0.2, 0.8], [0.35, 0.65], [0.5, 0.5]] },
                { type: 'secondary', points: [[0.8, 0.8], [0.65, 0.65], [0.5, 0.5]] }
            ];
            state.paths = mainPaths;
        }

        function setupControls() {
            const playBtn = document.getElementById('btn-play');
            const resetBtn = document.getElementById('btn-reset');
            const speedSlider = document.getElementById('speed-slider');
            const yearSlider = document.getElementById('year-slider');

            playBtn.addEventListener('click', togglePlay);
            resetBtn.addEventListener('click', resetSimulation);

            speedSlider.addEventListener('input', (e) => {
                state.speed = parseInt(e.target.value);
            });

            yearSlider.addEventListener('input', (e) => {
                const newYear = parseInt(e.target.value);
                jumpToYear(newYear);
            });
        }

        function renderSectionLegend() {
            const container = document.getElementById('section-legend');
            container.innerHTML = SECTIONS.slice(0, 10).map(s => `
                <div class="legend-item">
                    <div class="legend-color" style="background: ${s.color}"></div>
                    <span>${s.id}</span>
                </div>
            `).join('');
        }

        // ============================================
        // SIMULATION LOGIC
        // ============================================

        function getPopulation(year) {
            const years = Object.keys(POPULATION_DATA).map(Number).sort((a, b) => a - b);
            let lower = years[0], upper = years[years.length - 1];

            for (let i = 0; i < years.length - 1; i++) {
                if (year >= years[i] && year < years[i + 1]) {
                    lower = years[i];
                    upper = years[i + 1];
                    break;
                }
            }

            if (year <= lower) return POPULATION_DATA[lower];
            if (year >= upper) return POPULATION_DATA[upper];

            const t = (year - lower) / (upper - lower);
            return Math.round(POPULATION_DATA[lower] + t * (POPULATION_DATA[upper] - POPULATION_DATA[lower]));
        }

        function getMortalityPattern(year) {
            if (year <= 1850) return MORTALITY_PATTERNS[1850];
            if (year >= 2000) return MORTALITY_PATTERNS[2000];

            const years = [1850, 1900, 1950, 2000];
            let lower = 1850, upper = 1900;

            for (let i = 0; i < years.length - 1; i++) {
                if (year >= years[i] && year < years[i + 1]) {
                    lower = years[i];
                    upper = years[i + 1];
                    break;
                }
            }

            const t = (year - lower) / (upper - lower);
            const lowerPattern = MORTALITY_PATTERNS[lower];
            const upperPattern = MORTALITY_PATTERNS[upper];

            return {
                infant: lowerPattern.infant + t * (upperPattern.infant - lowerPattern.infant),
                child: lowerPattern.child + t * (upperPattern.child - lowerPattern.child),
                young: lowerPattern.young + t * (upperPattern.young - lowerPattern.young),
                middle: lowerPattern.middle + t * (upperPattern.middle - lowerPattern.middle),
                elderly: lowerPattern.elderly + t * (upperPattern.elderly - lowerPattern.elderly)
            };
        }

        function getAgeFromCategory(category) {
            switch (category) {
                case 'infant': return Math.random() * 2;
                case 'child': return 2 + Math.random() * 13;
                case 'young': return 15 + Math.random() * 25;
                case 'middle': return 40 + Math.random() * 25;
                case 'elderly': return 65 + Math.random() * 30;
                default: return 50;
            }
        }

        function getActiveSection(year) {
            const available = SECTIONS.filter(s => s.year <= year);
            if (available.length === 0) return SECTIONS[0];

            // Find section with capacity
            for (const section of available.reverse()) {
                if (state.burialsBySection[section.id] < section.capacity) {
                    return section;
                }
            }

            // All full, use latest
            return available[0];
        }

        function getMonumentStyle(year) {
            const available = MONUMENT_TYPES.filter(m => year >= m.minYear && year <= m.maxYear);
            if (available.length === 0) return MONUMENT_TYPES[5]; // Simple headstone
            return available[Math.floor(Math.random() * available.length)];
        }

        function getEra(year) {
            for (const era of ERAS) {
                if (year >= era.start && year <= era.end) {
                    return era.name;
                }
            }
            return 'Modern Era';
        }

        function checkHistoricalEvents(year) {
            for (const event of HISTORICAL_EVENTS) {
                if (year === event.year) {
                    state.currentEvent = event;
                    state.eventEndYear = year + event.duration;
                    addToEventLog(year, event.event);
                    showEventNotification(event.event);
                    return event.multiplier;
                }
            }

            if (state.currentEvent && year <= state.eventEndYear) {
                return state.currentEvent.multiplier;
            }

            state.currentEvent = null;
            return 1.0;
        }

        function addToEventLog(year, text) {
            state.eventLog.unshift({ year, text });
            if (state.eventLog.length > 20) state.eventLog.pop();
            renderEventLog();
        }

        function renderEventLog() {
            const container = document.getElementById('history-log');
            container.innerHTML = state.eventLog.map(e => `
                <div class="history-entry">
                    <span class="history-year">${e.year}</span>
                    <span class="history-text">${e.text}</span>
                </div>
            `).join('');
        }

        function showEventNotification(text) {
            const el = document.getElementById('event-notification');
            el.textContent = text;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 4000);
        }

        function simulateYear() {
            if (state.year > 2025) {
                state.isPlaying = false;
                updatePlayButton();
                return;
            }

            const population = getPopulation(state.year);
            const mortalityPattern = getMortalityPattern(state.year);
            const eventMultiplier = checkHistoricalEvents(state.year);

            // Base death rate (deaths per 1000 population)
            // Historically ~20-25 in 1850s, down to ~8-10 in modern era
            let deathRate;
            if (state.year < 1900) {
                deathRate = 22 - (state.year - 1850) * 0.04;
            } else if (state.year < 1950) {
                deathRate = 18 - (state.year - 1900) * 0.08;
            } else {
                deathRate = 10 - (state.year - 1950) * 0.02;
            }
            deathRate = Math.max(deathRate, 7);

            // Calculate deaths
            let deaths = Math.round((population * deathRate / 1000) * eventMultiplier);

            // Only a fraction are buried in Bonaventure (city's main cemetery but not only one)
            const bonaventureFraction = state.year < 1907 ? 0.35 : 0.25;
            deaths = Math.round(deaths * bonaventureFraction);

            // Ensure at least some burials
            deaths = Math.max(deaths, 5);

            // Create graves for this year
            for (let i = 0; i < deaths; i++) {
                const section = getActiveSection(state.year);
                const monument = getMonumentStyle(state.year);

                // Determine age category based on mortality pattern
                const rand = Math.random();
                let cumulative = 0;
                let ageCategory = 'elderly';
                for (const [cat, prob] of Object.entries(mortalityPattern)) {
                    cumulative += prob;
                    if (rand <= cumulative) {
                        ageCategory = cat;
                        break;
                    }
                }

                const age = getAgeFromCategory(ageCategory);

                // Position within section
                const sectionIndex = SECTIONS.findIndex(s => s.id === section.id);
                const sectionAngle = (sectionIndex / SECTIONS.length) * Math.PI * 2;
                const sectionRadius = 0.15 + (sectionIndex / SECTIONS.length) * 0.25;

                const grave = {
                    x: 0.5 + Math.cos(sectionAngle) * sectionRadius + (Math.random() - 0.5) * 0.15,
                    y: 0.5 + Math.sin(sectionAngle) * sectionRadius + (Math.random() - 0.5) * 0.15,
                    year: state.year,
                    section: section.id,
                    sectionColor: section.color,
                    age: age,
                    ageCategory: ageCategory,
                    monument: monument.style,
                    size: 2 + Math.random() * 4
                };

                // Keep within bounds
                grave.x = Math.max(0.05, Math.min(0.95, grave.x));
                grave.y = Math.max(0.05, Math.min(0.95, grave.y));

                state.graves.push(grave);
                state.burialsBySection[section.id]++;
                state.ageDistribution[ageCategory]++;
            }

            state.totalBurials += deaths;
            state.burialsByYear.push({ year: state.year, count: deaths });

            state.year++;
            document.getElementById('year-slider').value = state.year;
        }

        function jumpToYear(targetYear) {
            if (targetYear < 1850) targetYear = 1850;
            if (targetYear > 2025) targetYear = 2025;

            if (targetYear < state.year) {
                // Reset and simulate up to target
                resetSimulation(false);
            }

            const wasPlaying = state.isPlaying;
            state.isPlaying = false;

            while (state.year < targetYear) {
                simulateYear();
            }

            updateStats();
            render();

            if (wasPlaying) {
                state.isPlaying = true;
            }
        }

        // ============================================
        // RENDERING
        // ============================================

        function render() {
            const width = mainCanvas.width / dpr;
            const height = mainCanvas.height / dpr;

            // Clear with night/dusk background
            const gradient = mainCtx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#1a2333');
            gradient.addColorStop(0.4, '#141a24');
            gradient.addColorStop(1, '#0a0e14');
            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(0, 0, width, height);

            // Draw ground texture
            drawGround(width, height);

            // Draw paths
            drawPaths(width, height);

            // Draw graves
            drawGraves(width, height);

            // Draw trees with Spanish moss
            drawTrees(width, height);

            // Draw Wilmington River on the right edge
            drawRiver(width, height);

            // Draw section labels
            drawSectionLabels(width, height);

            // Update UI
            document.getElementById('year-display').textContent = state.year;
            document.getElementById('era-label').textContent = getEra(state.year);

            // Draw demographics chart
            drawDemographicsChart();
        }

        function drawGround(width, height) {
            // Subtle grass texture
            mainCtx.fillStyle = 'rgba(40, 55, 40, 0.3)';
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                mainCtx.fillRect(x, y, 1, 2);
            }
        }

        function drawPaths(width, height) {
            state.paths.forEach(path => {
                mainCtx.strokeStyle = path.type === 'main' ? 'rgba(120, 100, 80, 0.5)' : 'rgba(100, 85, 70, 0.3)';
                mainCtx.lineWidth = path.type === 'main' ? 12 : 6;
                mainCtx.lineCap = 'round';
                mainCtx.lineJoin = 'round';

                mainCtx.beginPath();
                const pts = path.points;
                mainCtx.moveTo(pts[0][0] * width, pts[0][1] * height);

                for (let i = 1; i < pts.length; i++) {
                    mainCtx.lineTo(pts[i][0] * width, pts[i][1] * height);
                }
                mainCtx.stroke();
            });
        }

        function drawGraves(width, height) {
            state.graves.forEach(grave => {
                const x = grave.x * width;
                const y = grave.y * height;
                const size = grave.size;

                // Age-based color tinting
                const yearAge = state.year - grave.year;
                const weathering = Math.min(yearAge / 150, 0.5);

                mainCtx.save();

                // Draw based on monument style
                switch (grave.monument) {
                    case 'gothic':
                        drawGothicMonument(x, y, size, grave.sectionColor, weathering);
                        break;
                    case 'classical':
                        drawClassicalMonument(x, y, size, grave.sectionColor, weathering);
                        break;
                    case 'egyptian':
                        drawEgyptianMonument(x, y, size, grave.sectionColor, weathering);
                        break;
                    case 'deco':
                        drawDecoMonument(x, y, size, grave.sectionColor, weathering);
                        break;
                    case 'flat':
                        drawFlatMarker(x, y, size, grave.sectionColor, weathering);
                        break;
                    default:
                        drawSimpleHeadstone(x, y, size, grave.sectionColor, weathering);
                }

                mainCtx.restore();
            });
        }

        function drawGothicMonument(x, y, size, color, weathering) {
            const s = size * 1.5;
            mainCtx.fillStyle = applyWeathering(color, weathering);

            mainCtx.beginPath();
            mainCtx.moveTo(x - s, y);
            mainCtx.lineTo(x - s, y - s * 2);
            mainCtx.lineTo(x - s/2, y - s * 2.5);
            mainCtx.lineTo(x, y - s * 3);
            mainCtx.lineTo(x + s/2, y - s * 2.5);
            mainCtx.lineTo(x + s, y - s * 2);
            mainCtx.lineTo(x + s, y);
            mainCtx.closePath();
            mainCtx.fill();
        }

        function drawClassicalMonument(x, y, size, color, weathering) {
            const s = size * 1.3;
            mainCtx.fillStyle = applyWeathering(color, weathering);

            // Column base
            mainCtx.fillRect(x - s * 1.2, y - s * 0.5, s * 2.4, s * 0.5);
            // Column
            mainCtx.fillRect(x - s * 0.8, y - s * 2.5, s * 1.6, s * 2);
            // Capital
            mainCtx.fillRect(x - s, y - s * 3, s * 2, s * 0.5);
        }

        function drawEgyptianMonument(x, y, size, color, weathering) {
            const s = size * 1.4;
            mainCtx.fillStyle = applyWeathering(color, weathering);

            // Obelisk shape
            mainCtx.beginPath();
            mainCtx.moveTo(x - s, y);
            mainCtx.lineTo(x - s * 0.7, y - s * 3);
            mainCtx.lineTo(x, y - s * 3.5);
            mainCtx.lineTo(x + s * 0.7, y - s * 3);
            mainCtx.lineTo(x + s, y);
            mainCtx.closePath();
            mainCtx.fill();
        }

        function drawDecoMonument(x, y, size, color, weathering) {
            const s = size * 1.2;
            mainCtx.fillStyle = applyWeathering(color, weathering);

            // Art deco geometric
            mainCtx.fillRect(x - s, y - s * 2, s * 2, s * 2);
            mainCtx.fillRect(x - s * 0.6, y - s * 2.8, s * 1.2, s * 0.8);
            mainCtx.fillRect(x - s * 0.3, y - s * 3.2, s * 0.6, s * 0.4);
        }

        function drawSimpleHeadstone(x, y, size, color, weathering) {
            const s = size;
            mainCtx.fillStyle = applyWeathering(color, weathering);

            mainCtx.beginPath();
            mainCtx.moveTo(x - s, y);
            mainCtx.lineTo(x - s, y - s * 1.5);
            mainCtx.arc(x, y - s * 1.5, s, Math.PI, 0);
            mainCtx.lineTo(x + s, y);
            mainCtx.closePath();
            mainCtx.fill();
        }

        function drawFlatMarker(x, y, size, color, weathering) {
            const s = size * 1.5;
            mainCtx.fillStyle = applyWeathering(color, weathering);
            mainCtx.fillRect(x - s, y - s * 0.3, s * 2, s * 0.6);
        }

        function applyWeathering(color, weathering) {
            // Parse color and lighten based on weathering (simulating moss/lichen)
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);

            const newR = Math.min(255, r + weathering * 60);
            const newG = Math.min(255, g + weathering * 80);
            const newB = Math.min(255, b + weathering * 40);

            return `rgb(${Math.round(newR)}, ${Math.round(newG)}, ${Math.round(newB)})`;
        }

        function drawTrees(width, height) {
            state.trees.forEach(tree => {
                const x = tree.x * width;
                const y = tree.y * height;
                const size = tree.size;

                // Tree trunk
                mainCtx.fillStyle = '#3d2b1f';
                mainCtx.fillRect(x - 3, y - size * 0.3, 6, size * 0.5);

                // Live oak canopy (broad and spreading)
                mainCtx.fillStyle = 'rgba(45, 65, 45, 0.9)';
                mainCtx.beginPath();
                mainCtx.ellipse(x, y - size * 0.5, size * 1.2, size * 0.6, 0, 0, Math.PI * 2);
                mainCtx.fill();

                // Spanish moss hanging down
                mainCtx.strokeStyle = 'rgba(140, 150, 130, 0.6)';
                mainCtx.lineWidth = 1;
                for (let i = 0; i < tree.mossStrands; i++) {
                    const offsetX = (i - tree.mossStrands / 2) * 8;
                    const startY = y - size * 0.3;
                    const endY = startY + tree.mossLength;

                    mainCtx.beginPath();
                    mainCtx.moveTo(x + offsetX, startY);
                    mainCtx.quadraticCurveTo(
                        x + offsetX + Math.sin(i) * 5,
                        startY + tree.mossLength * 0.5,
                        x + offsetX + Math.sin(i * 2) * 3,
                        endY
                    );
                    mainCtx.stroke();
                }
            });
        }

        function drawRiver(width, height) {
            // Wilmington River on the eastern edge
            const gradient = mainCtx.createLinearGradient(width * 0.9, 0, width, 0);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.3, 'rgba(60, 80, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(40, 60, 80, 0.5)');

            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(width * 0.9, 0, width * 0.1, height);

            // River label
            mainCtx.save();
            mainCtx.fillStyle = 'rgba(100, 120, 140, 0.5)';
            mainCtx.font = '10px Georgia';
            mainCtx.translate(width - 10, height / 2);
            mainCtx.rotate(-Math.PI / 2);
            mainCtx.fillText('Wilmington River', 0, 0);
            mainCtx.restore();
        }

        function drawSectionLabels(width, height) {
            mainCtx.font = '10px Georgia';
            mainCtx.fillStyle = 'rgba(200, 190, 170, 0.4)';
            mainCtx.textAlign = 'center';

            SECTIONS.forEach((section, i) => {
                if (section.year <= state.year) {
                    const angle = (i / SECTIONS.length) * Math.PI * 2;
                    const radius = 0.15 + (i / SECTIONS.length) * 0.25;
                    const x = (0.5 + Math.cos(angle) * radius) * width;
                    const y = (0.5 + Math.sin(angle) * radius) * height;
                    mainCtx.fillText(section.id, x, y);
                }
            });
        }

        function drawDemographicsChart() {
            const width = demoCanvas.width / dpr;
            const height = demoCanvas.height / dpr;

            demoCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            demoCtx.fillRect(0, 0, width, height);

            const total = Object.values(state.ageDistribution).reduce((a, b) => a + b, 0);
            if (total === 0) return;

            const categories = [
                { key: 'infant', label: '0-2', color: '#e8a598' },
                { key: 'child', label: '2-15', color: '#d4a574' },
                { key: 'young', label: '15-40', color: '#8A9A5B' },
                { key: 'middle', label: '40-65', color: '#606C38' },
                { key: 'elderly', label: '65+', color: '#4a5a3a' }
            ];

            const barWidth = width / categories.length - 4;
            const maxBarHeight = height - 20;

            categories.forEach((cat, i) => {
                const count = state.ageDistribution[cat.key];
                const barHeight = (count / total) * maxBarHeight;
                const x = i * (barWidth + 4) + 2;
                const y = height - barHeight - 15;

                demoCtx.fillStyle = cat.color;
                demoCtx.fillRect(x, y, barWidth, barHeight);

                // Label
                demoCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                demoCtx.font = '8px sans-serif';
                demoCtx.textAlign = 'center';
                demoCtx.fillText(cat.label, x + barWidth / 2, height - 3);
            });
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateStats() {
            document.getElementById('stat-total').textContent = state.totalBurials.toLocaleString();

            const capacity = (state.totalBurials / CEMETERY_DATA.estimatedCapacity * 100).toFixed(1);
            document.getElementById('stat-capacity').textContent = capacity + '%';

            const recentBurials = state.burialsByYear.slice(-5);
            const avgRate = recentBurials.length > 0
                ? Math.round(recentBurials.reduce((a, b) => a + b.count, 0) / recentBurials.length)
                : 0;
            document.getElementById('stat-rate').textContent = avgRate;

            // Calculate average age at death
            if (state.graves.length > 0) {
                const avgAge = state.graves.reduce((a, g) => a + g.age, 0) / state.graves.length;
                document.getElementById('stat-age').textContent = avgAge.toFixed(1);
            }

            // Active sections
            const activeSections = SECTIONS.filter(s => s.year <= state.year).map(s => s.id).join(', ');
            document.getElementById('stat-sections').textContent = activeSections || 'A';
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            updatePlayButton();

            if (state.isPlaying) {
                gameLoop();
            }
        }

        function updatePlayButton() {
            document.getElementById('btn-play').textContent = state.isPlaying ? 'Pause' : 'Play';
        }

        function resetSimulation(doRender = true) {
            state.year = 1850;
            state.totalBurials = 0;
            state.graves = [];
            state.burialsByYear = [];
            state.eventLog = [];
            state.currentEvent = null;

            SECTIONS.forEach(s => {
                state.burialsBySection[s.id] = 0;
            });

            state.ageDistribution = { infant: 0, child: 0, young: 0, middle: 0, elderly: 0 };

            document.getElementById('year-slider').value = 1850;
            renderEventLog();

            if (doRender) {
                updateStats();
                render();
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================

        let lastFrameTime = 0;
        let accumulator = 0;

        function gameLoop(timestamp = 0) {
            if (!state.isPlaying) return;

            const delta = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            accumulator += delta;

            // Speed: 1 = 1 year per 2 seconds, 20 = 20 years per second
            const msPerYear = 2000 / state.speed;

            while (accumulator >= msPerYear) {
                simulateYear();
                accumulator -= msPerYear;
            }

            updateStats();
            render();

            if (state.year <= 2025) {
                requestAnimationFrame(gameLoop);
            } else {
                state.isPlaying = false;
                updatePlayButton();
            }
        }

        // ============================================
        // START
        // ============================================

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
