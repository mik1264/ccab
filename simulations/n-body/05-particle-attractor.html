<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Attractor - Accretion Disk Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(to bottom, #000000, #1a0a2e);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
            text-align: center;
            background: linear-gradient(45deg, #e94560, #f39c12, #8e44ad);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            color: #cccccc;
            line-height: 1.6;
        }

        .container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(233, 69, 96, 0.3);
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #1a0a2e, #000000);
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(233, 69, 96, 0.2) inset;
            cursor: crosshair;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-width: 900px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #e94560;
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        input[type="checkbox"] {
            margin-right: 8px;
        }

        button {
            background: linear-gradient(45deg, #e94560, #c2185b);
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s;
            margin: 5px;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button.preset {
            background: linear-gradient(45deg, #8e44ad, #3498db);
            width: 100%;
            margin: 3px 0;
            padding: 8px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: rgba(233, 69, 96, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3em;
            color: #e94560;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.85em;
            color: #cccccc;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-gradient {
            width: 80px;
            height: 12px;
            border-radius: 3px;
        }

        .info-text {
            text-align: center;
            margin-top: 10px;
            color: #aaa;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>ðŸŒ€ Particle Attractor - Accretion Disk</h1>
    <div class="description">
        <p>
            <strong>Black Hole / Neutron Star Accretion Simulation</strong> - Watch particles orbit and spiral into a massive
            central attractor. Particles are color-coded by velocity: <span style="color: #0080ff">blue (fast)</span> in outer
            orbits, <span style="color: #ffd700">yellow (medium)</span> in middle regions, and <span style="color: #ff0000">red (slow)</span>
            near the center. Demonstrates angular momentum conservation, accretion disk formation, and Kepler's laws. Click to add particles!
        </p>
    </div>

    <div class="container">
        <canvas id="canvas" width="900" height="900"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Particle Count: <span id="particleCountValue">500</span></label>
                <input type="range" id="particleCount" min="100" max="2000" step="100" value="500">

                <label>Attractor Mass: <span id="attractorMassValue">500</span></label>
                <input type="range" id="attractorMass" min="100" max="2000" step="100" value="500">

                <label>Time Scale: <span id="timeScaleValue">1.0</span>x</label>
                <input type="range" id="timeScale" min="0.1" max="5" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>Initial Distribution:</label>
                <button class="preset" id="diskInit">Thin Disk</button>
                <button class="preset" id="sphereInit">Spherical Cloud</button>
                <button class="preset" id="ringInit">Ring</button>
                <button class="preset" id="randomInit">Random</button>
            </div>

            <div class="control-group">
                <label><input type="checkbox" id="showTrails" checked> Particle Trails</label>
                <label><input type="checkbox" id="showVelocity"> Velocity Vectors</label>
                <label><input type="checkbox" id="showOrbits"> Orbital Paths</label>
                <label><input type="checkbox" id="accretion" checked> Accretion (particles disappear)</label>

                <button id="pauseBtn">Pause</button>
                <button id="clearBtn">Clear Particles</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="fps">60</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="activeParticles">0</div>
                <div class="stat-label">Active Particles</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="avgVelocity">0</div>
                <div class="stat-label">Avg Velocity</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="angularMomentum">0</div>
                <div class="stat-label">Angular Momentum</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="accreted">0</div>
                <div class="stat-label">Accreted</div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <span>Velocity:</span>
                <div class="legend-gradient" style="background: linear-gradient(to right, #ff0000, #ffd700, #0080ff);"></div>
                <span>(Slow â†’ Fast)</span>
            </div>
        </div>

        <div class="info-text">
            ðŸ’¡ Click anywhere to add particles â€¢ Watch accretion disk form naturally from conservation of angular momentum
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Physics constants
        const G = 300;
        const SOFTENING = 5;
        const DT = 0.005;
        const ACCRETION_RADIUS = 15;
        const EVENT_HORIZON_RADIUS = 10;

        // Simulation state
        let particles = [];
        let attractor = { x: 0, y: 0, mass: 500 };
        let paused = false;
        let timeScale = 1.0;
        let particleCount = 500;
        let showTrails = true;
        let showVelocity = false;
        let showOrbits = false;
        let accretionEnabled = true;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let fps = 60;
        let accretedCount = 0;

        class Particle {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.trail = [];
                this.alive = true;
            }

            get velocity() {
                return Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }

            get color() {
                const v = this.velocity;
                const maxV = 3;

                // Color based on velocity: red (slow) -> yellow -> blue (fast)
                if (v < maxV * 0.33) {
                    // Red to yellow
                    const t = v / (maxV * 0.33);
                    const r = 255;
                    const g = Math.floor(215 * t);
                    const b = 0;
                    return `rgb(${r}, ${g}, ${b})`;
                } else if (v < maxV * 0.67) {
                    // Yellow to green
                    const t = (v - maxV * 0.33) / (maxV * 0.33);
                    const r = Math.floor(255 - 127 * t);
                    const g = 215;
                    const b = Math.floor(128 * t);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Green to blue
                    const t = (v - maxV * 0.67) / (maxV * 0.33);
                    const r = Math.floor(128 - 128 * t);
                    const g = Math.floor(215 - 87 * t);
                    const b = Math.floor(128 + 127 * t);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }

            addTrailPoint() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 30) {
                    this.trail.shift();
                }
            }

            update(dt) {
                if (!this.alive) return;

                // Gravitational acceleration
                const dx = attractor.x - this.x;
                const dy = attractor.y - this.y;
                const r2 = dx * dx + dy * dy + SOFTENING * SOFTENING;
                const r = Math.sqrt(r2);

                // Check accretion
                if (r < ACCRETION_RADIUS && accretionEnabled) {
                    this.alive = false;
                    accretedCount++;
                    return;
                }

                const a = G * attractor.mass / r2;
                const ax = a * dx / r;
                const ay = a * dy / r;

                // Velocity Verlet integration
                const vx_half = this.vx + ax * dt / 2;
                const vy_half = this.vy + ay * dt / 2;

                this.x += vx_half * dt;
                this.y += vy_half * dt;

                // Recompute acceleration (for Verlet, but we'll use same for simplicity)
                this.vx = vx_half + ax * dt / 2;
                this.vy = vy_half + ay * dt / 2;
            }

            draw() {
                if (!this.alive) return;

                const screenX = canvas.width / 2 + this.x;
                const screenY = canvas.height / 2 + this.y;

                // Draw trail
                if (showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;

                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length;
                        ctx.globalAlpha = alpha * 0.5;

                        ctx.beginPath();
                        ctx.moveTo(
                            canvas.width / 2 + this.trail[i - 1].x,
                            canvas.height / 2 + this.trail[i - 1].y
                        );
                        ctx.lineTo(
                            canvas.width / 2 + this.trail[i].x,
                            canvas.height / 2 + this.trail[i].y
                        );
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }

                // Draw orbital path (ellipse approximation)
                if (showOrbits) {
                    const r = Math.sqrt(this.x * this.x + this.y * this.y);
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.1;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, r, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Draw velocity vector
                if (showVelocity) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(screenX + this.vx * 20, screenY + this.vy * 20);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Draw particle
                const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, 3);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.7, this.color + '88');
                gradient.addColorStop(1, this.color + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createDiskDistribution() {
            particles = [];
            accretedCount = 0;

            for (let i = 0; i < particleCount; i++) {
                const r = 100 + Math.random() * 300;
                const theta = Math.random() * Math.PI * 2;

                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);

                // Circular orbit velocity
                const v = Math.sqrt(G * attractor.mass / r) * (0.8 + Math.random() * 0.4);
                const vx = -Math.sin(theta) * v;
                const vy = Math.cos(theta) * v;

                particles.push(new Particle(x, y, vx, vy));
            }
        }

        function createSphereDistribution() {
            particles = [];
            accretedCount = 0;

            for (let i = 0; i < particleCount; i++) {
                const r = 100 + Math.random() * 300;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);

                // Random orbital velocity with some angular momentum
                const speed = Math.sqrt(G * attractor.mass / r) * (0.3 + Math.random() * 0.5);
                const angle = Math.random() * Math.PI * 2;
                const vx = speed * Math.cos(angle);
                const vy = speed * Math.sin(angle);

                particles.push(new Particle(x, y, vx, vy));
            }
        }

        function createRingDistribution() {
            particles = [];
            accretedCount = 0;

            const ringRadius = 250;

            for (let i = 0; i < particleCount; i++) {
                const theta = (i / particleCount) * Math.PI * 2;
                const r = ringRadius + (Math.random() - 0.5) * 20;

                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);

                // Circular orbit velocity
                const v = Math.sqrt(G * attractor.mass / r);
                const vx = -Math.sin(theta) * v;
                const vy = Math.cos(theta) * v;

                particles.push(new Particle(x, y, vx, vy));
            }
        }

        function createRandomDistribution() {
            particles = [];
            accretedCount = 0;

            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 100 + Math.random() * 350;

                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);

                const speed = Math.random() * 2;
                const velAngle = Math.random() * Math.PI * 2;
                const vx = speed * Math.cos(velAngle);
                const vy = speed * Math.sin(velAngle);

                particles.push(new Particle(x, y, vx, vy));
            }
        }

        function addParticleAtMouse(mouseX, mouseY) {
            const x = mouseX - canvas.width / 2;
            const y = mouseY - canvas.height / 2;
            const r = Math.sqrt(x * x + y * y);

            if (r < 20) return; // Don't add too close to center

            // Circular orbit velocity
            const v = Math.sqrt(G * attractor.mass / r) * (0.8 + Math.random() * 0.4);
            const angle = Math.atan2(y, x);
            const vx = -Math.sin(angle) * v;
            const vy = Math.cos(angle) * v;

            particles.push(new Particle(x, y, vx, vy));
        }

        function drawAttractor() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Accretion radius
            if (accretionEnabled) {
                ctx.strokeStyle = 'rgba(233, 69, 96, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, ACCRETION_RADIUS, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Event horizon glow
            for (let i = 5; i > 0; i--) {
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, EVENT_HORIZON_RADIUS * i);
                gradient.addColorStop(0, '#e94560');
                gradient.addColorStop(0.5, '#e94560' + '44');
                gradient.addColorStop(1, '#e94560' + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, EVENT_HORIZON_RADIUS * i, 0, Math.PI * 2);
                ctx.fill();
            }

            // Black hole
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(centerX, centerY, EVENT_HORIZON_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            // White ring
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, EVENT_HORIZON_RADIUS, 0, Math.PI * 2);
            ctx.stroke();
        }

        function computeStats() {
            const aliveParticles = particles.filter(p => p.alive);

            if (aliveParticles.length === 0) return { avgVel: 0, angMom: 0 };

            let totalVel = 0;
            let totalAngMom = 0;

            for (let p of aliveParticles) {
                totalVel += p.velocity;
                // Angular momentum: L = r Ã— v
                const angMom = p.x * p.vy - p.y * p.vx;
                totalAngMom += angMom;
            }

            return {
                avgVel: totalVel / aliveParticles.length,
                angMom: totalAngMom / aliveParticles.length
            };
        }

        function update() {
            if (paused) return;

            const dt = DT * timeScale;

            for (let particle of particles) {
                particle.update(dt);

                if (particle.alive && frameCount % 2 === 0) {
                    particle.addTrailPoint();
                }
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawAttractor();

            for (let particle of particles) {
                particle.draw();
            }

            frameCount++;
            if (frameCount % 30 === 0) {
                const now = Date.now();
                fps = Math.round(30000 / (now - lastFpsUpdate));
                lastFpsUpdate = now;

                const stats = computeStats();
                const aliveCount = particles.filter(p => p.alive).length;

                document.getElementById('fps').textContent = fps;
                document.getElementById('activeParticles').textContent = aliveCount;
                document.getElementById('avgVelocity').textContent = stats.avgVel.toFixed(2);
                document.getElementById('angularMomentum').textContent = stats.angMom.toFixed(0);
                document.getElementById('accreted').textContent = accretedCount;
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addParticleAtMouse(x, y);
        });

        document.getElementById('particleCount').addEventListener('input', (e) => {
            particleCount = parseInt(e.target.value);
            document.getElementById('particleCountValue').textContent = particleCount;
        });

        document.getElementById('attractorMass').addEventListener('input', (e) => {
            attractor.mass = parseInt(e.target.value);
            document.getElementById('attractorMassValue').textContent = attractor.mass;
        });

        document.getElementById('timeScale').addEventListener('input', (e) => {
            timeScale = parseFloat(e.target.value);
            document.getElementById('timeScaleValue').textContent = timeScale.toFixed(1);
        });

        document.getElementById('showTrails').addEventListener('change', (e) => {
            showTrails = e.target.checked;
        });

        document.getElementById('showVelocity').addEventListener('change', (e) => {
            showVelocity = e.target.checked;
        });

        document.getElementById('showOrbits').addEventListener('change', (e) => {
            showOrbits = e.target.checked;
        });

        document.getElementById('accretion').addEventListener('change', (e) => {
            accretionEnabled = e.target.checked;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            particles = [];
            accretedCount = 0;
        });

        // Preset buttons
        document.getElementById('diskInit').addEventListener('click', createDiskDistribution);
        document.getElementById('sphereInit').addEventListener('click', createSphereDistribution);
        document.getElementById('ringInit').addEventListener('click', createRingDistribution);
        document.getElementById('randomInit').addEventListener('click', createRandomDistribution);

        // Initialize
        createDiskDistribution();
        animate();
    </script>
</body>
</html>
