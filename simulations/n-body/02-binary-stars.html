<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Star System - N-Body Gravity</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(to bottom, #000814, #001d3d);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
            text-align: center;
            background: linear-gradient(45deg, #00d4ff, #ffd700, #ff6b9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            color: #cccccc;
            line-height: 1.6;
        }

        .container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.3);
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #001d3d, #000000);
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.2) inset;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-width: 900px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #00d4ff;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        input[type="checkbox"] {
            margin-right: 8px;
        }

        button {
            background: linear-gradient(45deg, #00d4ff, #0080ff);
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s;
            margin: 5px;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button.preset {
            background: linear-gradient(45deg, #ff6b9d, #ffd700);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: rgba(0, 212, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            color: #00d4ff;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.9em;
            color: #cccccc;
        }

        .orbital-elements {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .element-row {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .presets {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>â˜… Binary Star System</h1>
    <div class="description">
        <p>
            <strong>Binary Star N-Body Simulation</strong> - Watch two stars orbit their common center of mass (barycenter).
            Adjust mass ratios to see different orbital dynamics: equal masses create circular orbits, while unequal masses
            show the heavier star barely moving as the lighter one swings around. Add a third body to explore unstable
            Lagrange points and chaotic orbital perturbations. Demonstrates Kepler's laws and the Roche limit.
        </p>
    </div>

    <div class="container">
        <canvas id="canvas" width="900" height="900"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Mass Ratio (Star2/Star1): <span id="massRatioValue">1.0</span></label>
                <input type="range" id="massRatio" min="0.1" max="5" step="0.1" value="1">

                <label>Separation: <span id="separationValue">200</span></label>
                <input type="range" id="separation" min="100" max="400" step="10" value="200">

                <label>Time Scale: <span id="timeScaleValue">1.0</span>x</label>
                <input type="range" id="timeScale" min="0.1" max="5" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>Trail Length: <span id="trailLengthValue">200</span></label>
                <input type="range" id="trailLength" min="50" max="500" step="10" value="200">

                <label><input type="checkbox" id="showTrails" checked> Show Trails</label>
                <label><input type="checkbox" id="showCenterMass" checked> Show Center of Mass</label>
                <label><input type="checkbox" id="showRocheLimit"> Show Roche Limit</label>
                <label><input type="checkbox" id="showThirdBody"> Add Third Body</label>
            </div>

            <div class="control-group">
                <button id="pauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>

                <div class="presets">
                    <button class="preset" id="preset1">Equal Stars</button>
                    <button class="preset" id="preset2">2:1 Ratio</button>
                    <button class="preset" id="preset3">5:1 Ratio</button>
                    <button class="preset" id="preset4">Planet Orbit</button>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="fps">60</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="orbitalPeriod">0</div>
                <div class="stat-label">Orbital Period</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="eccentricity">0.0</div>
                <div class="stat-label">Eccentricity</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="energy">0</div>
                <div class="stat-label">Total Energy</div>
            </div>
        </div>

        <div class="orbital-elements" id="orbitalElements"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Physics constants
        const G = 150;
        const SOFTENING = 1.0;
        const DT = 0.001;

        // Star configurations
        const starColors = [
            { color: '#4da6ff', name: 'Blue Giant', temp: 'Hot' },
            { color: '#ffd700', name: 'Yellow Star', temp: 'Medium' },
            { color: '#ff6b6b', name: 'Red Giant', temp: 'Cool' }
        ];

        // Simulation state
        let bodies = [];
        let paused = false;
        let timeScale = 1.0;
        let trailLength = 200;
        let showTrails = true;
        let showCenterMass = true;
        let showRocheLimit = false;
        let showThirdBody = false;
        let massRatio = 1.0;
        let separation = 200;
        let simTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let fps = 60;
        let orbitalPeriod = 0;
        let lastAngle = 0;
        let crossings = 0;

        class Body {
            constructor(name, mass, radius, color, x, y, vx, vy) {
                this.name = name;
                this.mass = mass;
                this.radius = radius;
                this.color = color;
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.ax = 0;
                this.ay = 0;
                this.trail = [];
            }

            addTrailPoint() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > trailLength) {
                    this.trail.shift();
                }
            }

            draw() {
                const screenX = canvas.width / 2 + this.x;
                const screenY = canvas.height / 2 + this.y;

                // Draw trail
                if (showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;

                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length;
                        ctx.globalAlpha = alpha * 0.6;

                        ctx.beginPath();
                        ctx.moveTo(
                            canvas.width / 2 + this.trail[i - 1].x,
                            canvas.height / 2 + this.trail[i - 1].y
                        );
                        ctx.lineTo(
                            canvas.width / 2 + this.trail[i].x,
                            canvas.height / 2 + this.trail[i].y
                        );
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }

                // Draw outer glow
                const glowRadius = this.radius;
                for (let i = 3; i > 0; i--) {
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowRadius * i);
                    gradient.addColorStop(0, this.color + 'ff');
                    gradient.addColorStop(0.5, this.color + '44');
                    gradient.addColorStop(1, this.color + '00');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, glowRadius * i, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(screenX, screenY, glowRadius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw name
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 5;
                ctx.fillText(this.name, screenX, screenY - glowRadius - 10);
                ctx.shadowBlur = 0;
            }

            computeAcceleration(bodies) {
                this.ax = 0;
                this.ay = 0;

                for (let other of bodies) {
                    if (other === this) continue;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const r2 = dx * dx + dy * dy + SOFTENING * SOFTENING;
                    const r = Math.sqrt(r2);
                    const f = G * other.mass / r2;

                    this.ax += f * dx / r;
                    this.ay += f * dy / r;
                }
            }

            updateVelocityVerlet(dt, bodies) {
                const vx_half = this.vx + this.ax * dt / 2;
                const vy_half = this.vy + this.ay * dt / 2;

                this.x += vx_half * dt;
                this.y += vy_half * dt;

                this.computeAcceleration(bodies);

                this.vx = vx_half + this.ax * dt / 2;
                this.vy = vy_half + this.ay * dt / 2;
            }
        }

        function initBodies() {
            bodies = [];
            simTime = 0;
            crossings = 0;
            lastAngle = 0;

            // Calculate center of mass velocities
            const mass1 = 100;
            const mass2 = 100 * massRatio;
            const totalMass = mass1 + mass2;

            // Position stars on opposite sides of center
            const r1 = separation * mass2 / totalMass;
            const r2 = separation * mass1 / totalMass;

            // Circular orbit velocities
            const v1 = Math.sqrt(G * mass2 * mass2 / (separation * totalMass));
            const v2 = Math.sqrt(G * mass1 * mass1 / (separation * totalMass));

            // Star 1 (Blue)
            bodies.push(new Body(
                starColors[0].name,
                mass1,
                20,
                starColors[0].color,
                -r1, 0,
                0, v1
            ));

            // Star 2 (Yellow or Red depending on mass)
            const star2Color = massRatio > 2 ? starColors[2] : starColors[1];
            bodies.push(new Body(
                star2Color.name,
                mass2,
                15 + Math.min(massRatio * 3, 15),
                star2Color.color,
                r2, 0,
                0, -v2
            ));

            // Optional third body (planet or small star)
            if (showThirdBody) {
                const distance = separation * 1.5;
                const angle = Math.PI / 3;
                const orbitalSpeed = Math.sqrt(G * totalMass / distance) * 0.9;

                bodies.push(new Body(
                    'Planet',
                    0.5,
                    8,
                    '#4CAF50',
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance,
                    -Math.sin(angle) * orbitalSpeed,
                    Math.cos(angle) * orbitalSpeed
                ));
            }
        }

        function drawCenterOfMass() {
            if (!showCenterMass) return;

            // Calculate center of mass
            let cmx = 0, cmy = 0, totalMass = 0;
            for (let body of bodies) {
                cmx += body.x * body.mass;
                cmy += body.y * body.mass;
                totalMass += body.mass;
            }
            cmx /= totalMass;
            cmy /= totalMass;

            const screenX = canvas.width / 2 + cmx;
            const screenY = canvas.height / 2 + cmy;

            // Draw crosshair
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7;

            ctx.beginPath();
            ctx.moveTo(screenX - 15, screenY);
            ctx.lineTo(screenX + 15, screenY);
            ctx.moveTo(screenX, screenY - 15);
            ctx.lineTo(screenX, screenY + 15);
            ctx.stroke();

            // Draw circle
            ctx.beginPath();
            ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = '#ff00ff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Barycenter', screenX, screenY - 20);

            ctx.globalAlpha = 1.0;
        }

        function drawRocheLimit() {
            if (!showRocheLimit || bodies.length < 2) return;

            const star1 = bodies[0];
            const star2 = bodies[1];

            // Simplified Roche limit: d = 2.46 * R * (M/m)^(1/3)
            const rocheLimit1 = 2.46 * star1.radius * Math.pow(star1.mass / star2.mass, 1/3);
            const rocheLimit2 = 2.46 * star2.radius * Math.pow(star2.mass / star1.mass, 1/3);

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            ctx.setLineDash([5, 5]);

            // Roche limit for star 1
            ctx.beginPath();
            ctx.arc(canvas.width / 2 + star1.x, canvas.height / 2 + star1.y, rocheLimit1, 0, Math.PI * 2);
            ctx.stroke();

            // Roche limit for star 2
            ctx.beginPath();
            ctx.arc(canvas.width / 2 + star2.x, canvas.height / 2 + star2.y, rocheLimit2, 0, Math.PI * 2);
            ctx.stroke();

            ctx.setLineDash([]);
            ctx.globalAlpha = 1.0;
        }

        function computeEnergy() {
            let totalEnergy = 0;

            // Kinetic energy
            for (let body of bodies) {
                const v2 = body.vx * body.vx + body.vy * body.vy;
                totalEnergy += 0.5 * body.mass * v2;
            }

            // Potential energy
            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const r = Math.sqrt(dx * dx + dy * dy + SOFTENING * SOFTENING);
                    totalEnergy -= G * bodies[i].mass * bodies[j].mass / r;
                }
            }

            return totalEnergy;
        }

        function computeOrbitalElements() {
            if (bodies.length < 2) return { eccentricity: 0, period: 0 };

            const star1 = bodies[0];
            const star2 = bodies[1];

            // Distance between stars
            const dx = star2.x - star1.x;
            const dy = star2.y - star1.y;
            const r = Math.sqrt(dx * dx + dy * dy);

            // Relative velocity
            const dvx = star2.vx - star1.vx;
            const dvy = star2.vy - star1.vy;
            const v = Math.sqrt(dvx * dvx + dvy * dvy);

            // Semi-major axis (from energy)
            const mu = G * (star1.mass + star2.mass);
            const E = 0.5 * v * v - mu / r;
            const a = -mu / (2 * E);

            // Eccentricity (simplified)
            const h = dx * dvy - dy * dvx; // Angular momentum
            const ecc = Math.sqrt(1 + 2 * E * h * h / (mu * mu));

            // Orbital period
            const period = 2 * Math.PI * Math.sqrt(a * a * a / mu);

            // Track angle for period measurement
            const angle = Math.atan2(dy, dx);
            if (lastAngle < 0 && angle > 0) {
                crossings++;
            }
            lastAngle = angle;

            return { eccentricity: Math.abs(ecc), period: period };
        }

        function updateOrbitalElements() {
            const elements = computeOrbitalElements();

            const elementsDiv = document.getElementById('orbitalElements');
            elementsDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 10px;">Orbital Elements:</div>
                <div class="element-row">
                    <span>Semi-major axis:</span>
                    <span>${(separation).toFixed(1)} units</span>
                </div>
                <div class="element-row">
                    <span>Eccentricity:</span>
                    <span>${elements.eccentricity.toFixed(3)}</span>
                </div>
                <div class="element-row">
                    <span>Expected Period:</span>
                    <span>${elements.period.toFixed(2)} time units</span>
                </div>
                <div class="element-row">
                    <span>Mass Ratio:</span>
                    <span>${massRatio.toFixed(2)} : 1</span>
                </div>
                <div class="element-row">
                    <span>Orbit Type:</span>
                    <span>${elements.eccentricity < 0.1 ? 'Circular' : elements.eccentricity < 0.5 ? 'Elliptical' : 'Highly Elliptical'}</span>
                </div>
            `;
        }

        function update() {
            if (paused) return;

            const dt = DT * timeScale;

            for (let body of bodies) {
                body.computeAcceleration(bodies);
            }

            for (let body of bodies) {
                body.updateVelocityVerlet(dt, bodies);

                if (frameCount % 2 === 0) {
                    body.addTrailPoint();
                }
            }

            simTime += dt;
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 8, 20, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawCenterOfMass();
            drawRocheLimit();

            for (let body of bodies) {
                body.draw();
            }

            frameCount++;
            if (frameCount % 30 === 0) {
                const now = Date.now();
                fps = Math.round(30000 / (now - lastFpsUpdate));
                lastFpsUpdate = now;

                const elements = computeOrbitalElements();

                document.getElementById('fps').textContent = fps;
                document.getElementById('orbitalPeriod').textContent = elements.period.toFixed(1);
                document.getElementById('eccentricity').textContent = elements.eccentricity.toFixed(3);
                document.getElementById('energy').textContent = computeEnergy().toFixed(0);

                updateOrbitalElements();
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('massRatio').addEventListener('input', (e) => {
            massRatio = parseFloat(e.target.value);
            document.getElementById('massRatioValue').textContent = massRatio.toFixed(1);
            initBodies();
        });

        document.getElementById('separation').addEventListener('input', (e) => {
            separation = parseFloat(e.target.value);
            document.getElementById('separationValue').textContent = separation;
            initBodies();
        });

        document.getElementById('timeScale').addEventListener('input', (e) => {
            timeScale = parseFloat(e.target.value);
            document.getElementById('timeScaleValue').textContent = timeScale.toFixed(1);
        });

        document.getElementById('trailLength').addEventListener('input', (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailLengthValue').textContent = trailLength;
        });

        document.getElementById('showTrails').addEventListener('change', (e) => {
            showTrails = e.target.checked;
        });

        document.getElementById('showCenterMass').addEventListener('change', (e) => {
            showCenterMass = e.target.checked;
        });

        document.getElementById('showRocheLimit').addEventListener('change', (e) => {
            showRocheLimit = e.target.checked;
        });

        document.getElementById('showThirdBody').addEventListener('change', (e) => {
            showThirdBody = e.target.checked;
            initBodies();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initBodies();
        });

        // Presets
        document.getElementById('preset1').addEventListener('click', () => {
            massRatio = 1.0;
            separation = 200;
            document.getElementById('massRatio').value = massRatio;
            document.getElementById('separation').value = separation;
            document.getElementById('massRatioValue').textContent = massRatio.toFixed(1);
            document.getElementById('separationValue').textContent = separation;
            initBodies();
        });

        document.getElementById('preset2').addEventListener('click', () => {
            massRatio = 2.0;
            separation = 200;
            document.getElementById('massRatio').value = massRatio;
            document.getElementById('separation').value = separation;
            document.getElementById('massRatioValue').textContent = massRatio.toFixed(1);
            document.getElementById('separationValue').textContent = separation;
            initBodies();
        });

        document.getElementById('preset3').addEventListener('click', () => {
            massRatio = 5.0;
            separation = 250;
            document.getElementById('massRatio').value = massRatio;
            document.getElementById('separation').value = separation;
            document.getElementById('massRatioValue').textContent = massRatio.toFixed(1);
            document.getElementById('separationValue').textContent = separation;
            initBodies();
        });

        document.getElementById('preset4').addEventListener('click', () => {
            massRatio = 0.001;
            separation = 150;
            showThirdBody = false;
            document.getElementById('showThirdBody').checked = false;
            document.getElementById('massRatio').value = massRatio;
            document.getElementById('separation').value = separation;
            document.getElementById('massRatioValue').textContent = massRatio.toFixed(3);
            document.getElementById('separationValue').textContent = separation;
            initBodies();
        });

        // Initialize
        initBodies();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
