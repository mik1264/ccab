<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vortex Shedding - Karman Vortex Street</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #05051a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 1px solid #333;
            cursor: crosshair;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            max-width: 220px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
            color: #6495ed;
        }
        .controls label {
            display: block;
            margin: 8px 0;
            font-size: 12px;
        }
        .controls input[type="range"] {
            width: 140px;
            vertical-align: middle;
        }
        .controls button {
            margin: 5px 5px 5px 0;
            padding: 6px 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #444;
            color: #fff;
            font-size: 11px;
        }
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px;
            border-radius: 5px;
            color: #888;
            font-size: 12px;
            max-width: 280px;
        }
        .reynolds {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            color: #6495ed;
            font-size: 14px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Vortex Shedding</h3>
        <label>
            Flow Speed: <span id="speedValue">1.0</span>
            <input type="range" id="flowSpeed" min="0.1" max="3.0" step="0.1" value="1.0">
        </label>
        <label>
            Viscosity: <span id="viscValue">0.01</span>
            <input type="range" id="viscosity" min="0.001" max="0.05" step="0.001" value="0.01">
        </label>
        <button onclick="toggleViz()">Toggle Viz</button>
        <button onclick="reset()">Reset</button>
    </div>
    <div class="reynolds">
        Reynolds: <span id="reynoldsNum">100</span>
    </div>
    <div class="info">
        Karman vortex street forms behind cylinder<br>
        Increase flow speed to see vortex separation<br>
        Lower viscosity = stronger vortices
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid resolution
        const N = 120;
        const SCALE = 5;
        canvas.width = N * SCALE;
        canvas.height = (N * 0.6) * SCALE;
        const NY = Math.floor(N * 0.6);

        // Flow parameters
        let flowSpeed = 1.0;
        let viscosity = 0.01;
        const dt = 0.05;

        // Visualization mode: 'vorticity' or 'velocity'
        let vizMode = 'vorticity';

        // Cylinder obstacle
        const cylinderX = Math.floor(N * 0.25);
        const cylinderY = Math.floor(NY / 2);
        const cylinderRadius = 8;

        // Fluid grids
        let vx = new Float32Array(N * NY);
        let vy = new Float32Array(N * NY);
        let vx0 = new Float32Array(N * NY);
        let vy0 = new Float32Array(N * NY);
        let obstacles = new Uint8Array(N * NY);

        // Controls
        document.getElementById('flowSpeed').addEventListener('input', (e) => {
            flowSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = flowSpeed.toFixed(1);
            updateReynolds();
        });

        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscValue').textContent = viscosity.toFixed(3);
            updateReynolds();
        });

        function toggleViz() {
            vizMode = vizMode === 'vorticity' ? 'velocity' : 'vorticity';
        }

        function updateReynolds() {
            const Re = Math.floor((flowSpeed * cylinderRadius * 2) / viscosity);
            document.getElementById('reynoldsNum').textContent = Re;
        }

        function reset() {
            vx.fill(0);
            vy.fill(0);
            vx0.fill(0);
            vy0.fill(0);
            initializeFlow();
        }

        function IX(x, y) {
            x = Math.max(0, Math.min(N - 1, x));
            y = Math.max(0, Math.min(NY - 1, y));
            return x + y * N;
        }

        // Initialize cylinder obstacle
        function initObstacles() {
            obstacles.fill(0);
            for (let j = 0; j < NY; j++) {
                for (let i = 0; i < N; i++) {
                    const dx = i - cylinderX;
                    const dy = j - cylinderY;
                    if (dx * dx + dy * dy < cylinderRadius * cylinderRadius) {
                        obstacles[IX(i, j)] = 1;
                    }
                }
            }
        }

        // Initialize uniform flow
        function initializeFlow() {
            for (let j = 0; j < NY; j++) {
                for (let i = 0; i < N; i++) {
                    if (!obstacles[IX(i, j)]) {
                        vx[IX(i, j)] = flowSpeed;
                        vy[IX(i, j)] = 0;
                    }
                }
            }
        }

        function setBoundary(b, x) {
            // Left boundary - inflow
            for (let j = 0; j < NY; j++) {
                x[IX(0, j)] = b === 1 ? flowSpeed : 0;
            }

            // Right boundary - outflow
            for (let j = 0; j < NY; j++) {
                x[IX(N - 1, j)] = x[IX(N - 2, j)];
            }

            // Top and bottom - slip
            for (let i = 0; i < N; i++) {
                x[IX(i, 0)] = x[IX(i, 1)];
                x[IX(i, NY - 1)] = x[IX(i, NY - 2)];
            }

            // Cylinder boundaries
            for (let j = 1; j < NY - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    if (obstacles[IX(i, j)]) {
                        // No-slip boundary condition
                        x[IX(i, j)] = 0;
                    }
                }
            }
        }

        function linearSolve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < 15; k++) {
                for (let j = 1; j < NY - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        if (!obstacles[IX(i, j)]) {
                            x[IX(i, j)] = (x0[IX(i, j)] + a * (
                                x[IX(i + 1, j)] + x[IX(i - 1, j)] +
                                x[IX(i, j + 1)] + x[IX(i, j - 1)]
                            )) * cRecip;
                        }
                    }
                }
                setBoundary(b, x);
            }
        }

        function diffuse(b, x, x0, diff) {
            const a = dt * diff * (N - 2) * (NY - 2);
            linearSolve(b, x, x0, a, 1 + 4 * a);
        }

        function advect(b, d, d0, velocX, velocY) {
            const dt0 = dt * N;
            for (let j = 1; j < NY - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    if (!obstacles[IX(i, j)]) {
                        let x = i - dt0 * velocX[IX(i, j)];
                        let y = j - dt0 * velocY[IX(i, j)];

                        x = Math.max(0.5, Math.min(N - 1.5, x));
                        y = Math.max(0.5, Math.min(NY - 1.5, y));

                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;

                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;

                        d[IX(i, j)] =
                            s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                            s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                    }
                }
            }
            setBoundary(b, d);
        }

        function project(velocX, velocY, p, div) {
            for (let j = 1; j < NY - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    if (!obstacles[IX(i, j)]) {
                        div[IX(i, j)] = -0.5 * (
                            velocX[IX(i + 1, j)] - velocX[IX(i - 1, j)] +
                            velocY[IX(i, j + 1)] - velocY[IX(i, j - 1)]
                        ) / N;
                        p[IX(i, j)] = 0;
                    }
                }
            }
            setBoundary(0, div);
            setBoundary(0, p);
            linearSolve(0, p, div, 1, 4);

            for (let j = 1; j < NY - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    if (!obstacles[IX(i, j)]) {
                        velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                        velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                    }
                }
            }
            setBoundary(1, velocX);
            setBoundary(2, velocY);
        }

        function velocityStep() {
            // Maintain inflow
            for (let j = 0; j < NY; j++) {
                vx[IX(0, j)] = flowSpeed;
                vy[IX(0, j)] = 0;
            }

            diffuse(1, vx0, vx, viscosity);
            diffuse(2, vy0, vy, viscosity);

            project(vx0, vy0, vx, vy);

            advect(1, vx, vx0, vx0, vy0);
            advect(2, vy, vy0, vx0, vy0);

            project(vx, vy, vx0, vy0);
        }

        function calculateVorticity() {
            const vorticity = new Float32Array(N * NY);
            for (let j = 1; j < NY - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const dvx_dy = (vx[IX(i, j + 1)] - vx[IX(i, j - 1)]) * 0.5;
                    const dvy_dx = (vy[IX(i + 1, j)] - vy[IX(i - 1, j)]) * 0.5;
                    vorticity[IX(i, j)] = dvy_dx - dvx_dy;
                }
            }
            return vorticity;
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            let displayData;
            if (vizMode === 'vorticity') {
                displayData = calculateVorticity();
            } else {
                displayData = vx;
            }

            for (let j = 0; j < NY; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = IX(i, j);
                    let r, g, b;

                    if (obstacles[idx]) {
                        // Dark gray cylinder
                        r = g = b = 40;
                    } else {
                        if (vizMode === 'vorticity') {
                            const vort = displayData[idx];
                            if (vort > 0) {
                                // Positive vorticity (red)
                                const val = Math.min(255, Math.abs(vort) * 50);
                                r = val;
                                g = 0;
                                b = 100;
                            } else {
                                // Negative vorticity (blue)
                                const val = Math.min(255, Math.abs(vort) * 50);
                                r = 100;
                                g = 0;
                                b = val;
                            }
                        } else {
                            // Velocity magnitude
                            const speed = Math.sqrt(vx[idx] * vx[idx] + vy[idx] * vy[idx]);
                            const normalized = Math.min(255, speed * 80);
                            r = normalized;
                            g = normalized * 0.7;
                            b = 255 - normalized * 0.5;
                        }
                    }

                    // Fill SCALE x SCALE pixel block
                    for (let py = 0; py < SCALE; py++) {
                        for (let px = 0; px < SCALE; px++) {
                            const index = ((j * SCALE + py) * canvas.width + (i * SCALE + px)) * 4;
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            velocityStep();
            render();
            requestAnimationFrame(animate);
        }

        // Initialize
        initObstacles();
        initializeFlow();
        updateReynolds();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
