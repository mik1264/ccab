<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turbulence Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 1px solid #333;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            max-width: 220px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
            background: linear-gradient(90deg, #ff6ec4, #7873f5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .controls label {
            display: block;
            margin: 8px 0;
            font-size: 12px;
        }
        .controls input[type="range"] {
            width: 140px;
            vertical-align: middle;
        }
        .controls button {
            margin: 5px 5px 5px 0;
            padding: 6px 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #444;
            color: #fff;
            font-size: 11px;
        }
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: #888;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Turbulence</h3>
        <label>
            Energy: <span id="energyValue">5</span>
            <input type="range" id="energy" min="1" max="20" step="1" value="5">
        </label>
        <label>
            Viscosity: <span id="viscValue">0.001</span>
            <input type="range" id="viscosity" min="0.0001" max="0.005" step="0.0001" value="0.001">
        </label>
        <label>
            Vortices: <span id="vortexValue">8</span>
            <input type="range" id="vortexCount" min="2" max="20" step="1" value="8">
        </label>
        <button onclick="addRandomVortex()">Add Vortex</button>
        <button onclick="reset()">Reset</button>
    </div>
    <div class="info">
        Chaotic fluid motion with multiple interacting vortices
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid resolution
        const N = 128;
        const SCALE = 4;
        canvas.width = N * SCALE;
        canvas.height = N * SCALE;

        // Turbulence parameters
        let energyInput = 5;
        let viscosity = 0.001;
        let vortexCount = 8;
        const dt = 0.08;

        // Fluid grids
        let vx = new Float32Array(N * N);
        let vy = new Float32Array(N * N);
        let vx0 = new Float32Array(N * N);
        let vy0 = new Float32Array(N * N);
        let density = new Float32Array(N * N);
        let densityPrev = new Float32Array(N * N);

        // Vortex generators
        let vortices = [];

        // Controls
        document.getElementById('energy').addEventListener('input', (e) => {
            energyInput = parseFloat(e.target.value);
            document.getElementById('energyValue').textContent = energyInput;
        });

        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscValue').textContent = viscosity.toFixed(4);
        });

        document.getElementById('vortexCount').addEventListener('input', (e) => {
            vortexCount = parseInt(e.target.value);
            document.getElementById('vortexValue').textContent = vortexCount;
        });

        function addRandomVortex() {
            vortices.push({
                x: Math.random() * N,
                y: Math.random() * N,
                strength: (Math.random() - 0.5) * energyInput * 2,
                radius: 5 + Math.random() * 10,
                vx: (Math.random() - 0.5) * 0.3,
                vy: (Math.random() - 0.5) * 0.3
            });
        }

        function initializeVortices() {
            vortices = [];
            for (let i = 0; i < vortexCount; i++) {
                vortices.push({
                    x: Math.random() * N,
                    y: Math.random() * N,
                    strength: (Math.random() - 0.5) * energyInput * 2,
                    radius: 5 + Math.random() * 10,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3
                });
            }
        }

        function reset() {
            vx.fill(0);
            vy.fill(0);
            vx0.fill(0);
            vy0.fill(0);
            density.fill(0);
            densityPrev.fill(0);
            initializeVortices();
        }

        function IX(x, y) {
            x = Math.max(0, Math.min(N - 1, x));
            y = Math.max(0, Math.min(N - 1, y));
            return x + y * N;
        }

        // Add turbulent forcing from vortices
        function addTurbulence() {
            // Update vortex positions
            vortices.forEach(v => {
                v.x += v.vx;
                v.y += v.vy;

                // Wrap around
                if (v.x < 0) v.x += N;
                if (v.x >= N) v.x -= N;
                if (v.y < 0) v.y += N;
                if (v.y >= N) v.y -= N;

                // Add velocity field from vortex
                const radius = v.radius;
                const ix = Math.floor(v.x);
                const iy = Math.floor(v.y);

                for (let j = -radius * 2; j <= radius * 2; j++) {
                    for (let i = -radius * 2; i <= radius * 2; i++) {
                        const x = ix + i;
                        const y = iy + j;

                        if (x >= 0 && x < N && y >= 0 && y < N) {
                            const dx = x - v.x;
                            const dy = y - v.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < radius && dist > 0.1) {
                                const factor = v.strength * (1 - dist / radius) / dist;
                                // Tangential velocity (vortex)
                                vx[IX(x, y)] += -dy * factor;
                                vy[IX(x, y)] += dx * factor;

                                // Add density
                                density[IX(x, y)] += Math.abs(v.strength) * (1 - dist / radius) * 10;
                            }
                        }
                    }
                }

                // Random walk
                v.vx += (Math.random() - 0.5) * 0.1;
                v.vy += (Math.random() - 0.5) * 0.1;

                // Damping
                v.vx *= 0.98;
                v.vy *= 0.98;
            });
        }

        function setBoundary(b, x) {
            for (let i = 1; i < N - 1; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N - 1, i)] = b === 1 ? -x[IX(N - 2, i)] : x[IX(N - 2, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N - 1)] = b === 2 ? -x[IX(i, N - 2)] : x[IX(i, N - 2)];
            }
            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N - 1)] = 0.5 * (x[IX(1, N - 1)] + x[IX(0, N - 2)]);
            x[IX(N - 1, 0)] = 0.5 * (x[IX(N - 2, 0)] + x[IX(N - 1, 1)]);
            x[IX(N - 1, N - 1)] = 0.5 * (x[IX(N - 2, N - 1)] + x[IX(N - 1, N - 2)]);
        }

        function linearSolve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < 20; k++) {
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (
                            x[IX(i + 1, j)] + x[IX(i - 1, j)] +
                            x[IX(i, j + 1)] + x[IX(i, j - 1)]
                        )) * cRecip;
                    }
                }
                setBoundary(b, x);
            }
        }

        function diffuse(b, x, x0, diff) {
            const a = dt * diff * (N - 2) * (N - 2);
            linearSolve(b, x, x0, a, 1 + 4 * a);
        }

        function advect(b, d, d0, velocX, velocY) {
            const dt0 = dt * (N - 2);
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    let x = i - dt0 * velocX[IX(i, j)];
                    let y = j - dt0 * velocY[IX(i, j)];

                    x = Math.max(0.5, Math.min(N - 1.5, x));
                    y = Math.max(0.5, Math.min(N - 1.5, y));

                    const i0 = Math.floor(x);
                    const i1 = i0 + 1;
                    const j0 = Math.floor(y);
                    const j1 = j0 + 1;

                    const s1 = x - i0;
                    const s0 = 1 - s1;
                    const t1 = y - j0;
                    const t0 = 1 - t1;

                    d[IX(i, j)] =
                        s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                        s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            setBoundary(b, d);
        }

        function project(velocX, velocY, p, div) {
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    div[IX(i, j)] = -0.5 * (
                        velocX[IX(i + 1, j)] - velocX[IX(i - 1, j)] +
                        velocY[IX(i, j + 1)] - velocY[IX(i, j - 1)]
                    ) / N;
                    p[IX(i, j)] = 0;
                }
            }
            setBoundary(0, div);
            setBoundary(0, p);
            linearSolve(0, p, div, 1, 4);

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                    velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                }
            }
            setBoundary(1, velocX);
            setBoundary(2, velocY);
        }

        function velocityStep() {
            diffuse(1, vx0, vx, viscosity);
            diffuse(2, vy0, vy, viscosity);

            project(vx0, vy0, vx, vy);

            advect(1, vx, vx0, vx0, vy0);
            advect(2, vy, vy0, vx0, vy0);

            project(vx, vy, vx0, vy0);
        }

        function densityStep() {
            diffuse(0, densityPrev, density, 0.00001);
            advect(0, density, densityPrev, vx, vy);

            // Fade density
            for (let i = 0; i < N * N; i++) {
                density[i] *= 0.99;
            }
        }

        function calculateVorticity() {
            const vorticity = new Float32Array(N * N);
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const dvx_dy = (vx[IX(i, j + 1)] - vx[IX(i, j - 1)]) * 0.5;
                    const dvy_dx = (vy[IX(i + 1, j)] - vy[IX(i - 1, j)]) * 0.5;
                    vorticity[IX(i, j)] = dvy_dx - dvx_dy;
                }
            }
            return vorticity;
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            const vorticity = calculateVorticity();

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = IX(i, j);
                    const vort = vorticity[idx];
                    const dens = Math.min(255, density[idx]);

                    let r, g, b;
                    if (vort > 0) {
                        // Clockwise vorticity - red/orange
                        const val = Math.min(1, Math.abs(vort) * 20);
                        r = 255 * val + dens * 0.3;
                        g = 100 * val + dens * 0.2;
                        b = dens * 0.4;
                    } else {
                        // Counter-clockwise - blue/cyan
                        const val = Math.min(1, Math.abs(vort) * 20);
                        r = dens * 0.4;
                        g = 100 * val + dens * 0.2;
                        b = 255 * val + dens * 0.3;
                    }

                    r = Math.min(255, r);
                    g = Math.min(255, g);
                    b = Math.min(255, b);

                    // Fill SCALE x SCALE pixel block
                    for (let py = 0; py < SCALE; py++) {
                        for (let px = 0; px < SCALE; px++) {
                            const index = ((j * SCALE + py) * canvas.width + (i * SCALE + px)) * 4;
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            addTurbulence();
            velocityStep();
            densityStep();
            render();
            requestAnimationFrame(animate);
        }

        // Initialize
        initializeVortices();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
