<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colored Dye Fluid Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 1px solid #222;
            cursor: crosshair;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .color-picker {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 10px currentColor;
        }
        .controls button {
            margin: 5px 5px 5px 0;
            padding: 8px 12px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #444;
            color: #fff;
            font-size: 12px;
        }
        .controls button:hover {
            background: #555;
        }
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            color: #aaa;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Colored Dye Simulation</h3>
        <p style="margin-bottom: 10px; font-size: 12px; color: #aaa;">Select Color:</p>
        <div class="color-picker" id="colorPicker"></div>
        <button onclick="reset()">Clear Canvas</button>
        <button onclick="randomInjection()">Random Burst</button>
    </div>
    <div class="info">
        Click and drag to inject colored dye â€¢ Watch colors mix and swirl
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid resolution
        const N = 128;
        const SCALE = 4;
        canvas.width = N * SCALE;
        canvas.height = N * SCALE;

        // Color palette
        const colors = [
            { r: 255, g: 50, b: 50, name: 'Red' },
            { r: 50, g: 150, b: 255, name: 'Blue' },
            { r: 50, g: 255, b: 100, name: 'Green' },
            { r: 255, g: 200, b: 50, name: 'Yellow' },
            { r: 255, g: 50, b: 200, name: 'Magenta' },
            { r: 50, g: 255, b: 255, name: 'Cyan' },
            { r: 255, g: 150, b: 50, name: 'Orange' },
            { r: 150, g: 50, b: 255, name: 'Purple' },
        ];

        let selectedColor = colors[0];

        // Create color picker buttons
        const colorPicker = document.getElementById('colorPicker');
        colors.forEach((color, index) => {
            const btn = document.createElement('div');
            btn.className = 'color-btn' + (index === 0 ? ' active' : '');
            btn.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
            btn.title = color.name;
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedColor = color;
            });
            colorPicker.appendChild(btn);
        });

        // Fluid simulation parameters
        const viscosity = 0.0001;
        const diffusion = 0.00001;
        const dt = 0.1;
        const fadeRate = 0.995;

        // Fluid grids - separate for R, G, B
        let densityR = new Float32Array(N * N);
        let densityG = new Float32Array(N * N);
        let densityB = new Float32Array(N * N);
        let densityPrevR = new Float32Array(N * N);
        let densityPrevG = new Float32Array(N * N);
        let densityPrevB = new Float32Array(N * N);

        let vx = new Float32Array(N * N);
        let vy = new Float32Array(N * N);
        let vx0 = new Float32Array(N * N);
        let vy0 = new Float32Array(N * N);

        // Mouse interaction
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let pmouseX = 0, pmouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            mouseX = Math.floor((e.clientX - rect.left) / SCALE);
            mouseY = Math.floor((e.clientY - rect.top) / SCALE);
            pmouseX = mouseX;
            pmouseY = mouseY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            pmouseX = mouseX;
            pmouseY = mouseY;
            mouseX = Math.floor((e.clientX - rect.left) / SCALE);
            mouseY = Math.floor((e.clientY - rect.top) / SCALE);
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = Math.floor((touch.clientX - rect.left) / SCALE);
            mouseY = Math.floor((touch.clientY - rect.top) / SCALE);
            pmouseX = mouseX;
            pmouseY = mouseY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            pmouseX = mouseX;
            pmouseY = mouseY;
            mouseX = Math.floor((touch.clientX - rect.left) / SCALE);
            mouseY = Math.floor((touch.clientY - rect.top) / SCALE);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            mouseDown = false;
        });

        function reset() {
            densityR.fill(0);
            densityG.fill(0);
            densityB.fill(0);
            densityPrevR.fill(0);
            densityPrevG.fill(0);
            densityPrevB.fill(0);
            vx.fill(0);
            vy.fill(0);
            vx0.fill(0);
            vy0.fill(0);
        }

        function randomInjection() {
            const cx = Math.floor(Math.random() * (N - 20)) + 10;
            const cy = Math.floor(Math.random() * (N - 20)) + 10;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const amount = 150;
            const radius = 8;

            for (let i = -radius; i <= radius; i++) {
                for (let j = -radius; j <= radius; j++) {
                    const x = cx + i;
                    const y = cy + j;
                    if (x >= 0 && x < N && y >= 0 && y < N) {
                        const d = Math.sqrt(i * i + j * j);
                        if (d < radius) {
                            const factor = 1 - d / radius;
                            const idx = IX(x, y);
                            densityR[idx] += color.r * factor * amount / 255;
                            densityG[idx] += color.g * factor * amount / 255;
                            densityB[idx] += color.b * factor * amount / 255;

                            // Add radial velocity
                            const angle = Math.random() * Math.PI * 2;
                            vx[idx] += Math.cos(angle) * 2;
                            vy[idx] += Math.sin(angle) * 2;
                        }
                    }
                }
            }
        }

        function IX(x, y) {
            x = Math.max(0, Math.min(N - 1, x));
            y = Math.max(0, Math.min(N - 1, y));
            return x + y * N;
        }

        function addSource() {
            if (mouseDown && mouseX >= 0 && mouseX < N && mouseY >= 0 && mouseY < N) {
                const amount = 120;
                const radius = 4;

                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        const x = mouseX + i;
                        const y = mouseY + j;
                        if (x >= 0 && x < N && y >= 0 && y < N) {
                            const d = Math.sqrt(i * i + j * j);
                            if (d < radius) {
                                const factor = 1 - d / radius;
                                const idx = IX(x, y);
                                densityR[idx] += selectedColor.r * factor * amount / 255;
                                densityG[idx] += selectedColor.g * factor * amount / 255;
                                densityB[idx] += selectedColor.b * factor * amount / 255;
                            }
                        }
                    }
                }

                // Add velocity
                const dx = mouseX - pmouseX;
                const dy = mouseY - pmouseY;
                if (dx !== 0 || dy !== 0) {
                    for (let i = -radius; i <= radius; i++) {
                        for (let j = -radius; j <= radius; j++) {
                            const x = mouseX + i;
                            const y = mouseY + j;
                            if (x >= 0 && x < N && y >= 0 && y < N) {
                                const d = Math.sqrt(i * i + j * j);
                                if (d < radius) {
                                    const factor = 1 - d / radius;
                                    const idx = IX(x, y);
                                    vx[idx] += dx * factor * 4;
                                    vy[idx] += dy * factor * 4;
                                }
                            }
                        }
                    }
                }
            }
        }

        function setBoundary(b, x) {
            for (let i = 1; i < N - 1; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N - 1, i)] = b === 1 ? -x[IX(N - 2, i)] : x[IX(N - 2, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N - 1)] = b === 2 ? -x[IX(i, N - 2)] : x[IX(i, N - 2)];
            }
            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N - 1)] = 0.5 * (x[IX(1, N - 1)] + x[IX(0, N - 2)]);
            x[IX(N - 1, 0)] = 0.5 * (x[IX(N - 2, 0)] + x[IX(N - 1, 1)]);
            x[IX(N - 1, N - 1)] = 0.5 * (x[IX(N - 2, N - 1)] + x[IX(N - 1, N - 2)]);
        }

        function linearSolve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < 20; k++) {
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (
                            x[IX(i + 1, j)] + x[IX(i - 1, j)] +
                            x[IX(i, j + 1)] + x[IX(i, j - 1)]
                        )) * cRecip;
                    }
                }
                setBoundary(b, x);
            }
        }

        function diffuse(b, x, x0, diff) {
            const a = dt * diff * (N - 2) * (N - 2);
            linearSolve(b, x, x0, a, 1 + 4 * a);
        }

        function advect(b, d, d0, velocX, velocY) {
            const dt0 = dt * (N - 2);
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    let x = i - dt0 * velocX[IX(i, j)];
                    let y = j - dt0 * velocY[IX(i, j)];

                    x = Math.max(0.5, Math.min(N - 1.5, x));
                    y = Math.max(0.5, Math.min(N - 1.5, y));

                    const i0 = Math.floor(x);
                    const i1 = i0 + 1;
                    const j0 = Math.floor(y);
                    const j1 = j0 + 1;

                    const s1 = x - i0;
                    const s0 = 1 - s1;
                    const t1 = y - j0;
                    const t0 = 1 - t1;

                    d[IX(i, j)] =
                        s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                        s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            setBoundary(b, d);
        }

        function project(velocX, velocY, p, div) {
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    div[IX(i, j)] = -0.5 * (
                        velocX[IX(i + 1, j)] - velocX[IX(i - 1, j)] +
                        velocY[IX(i, j + 1)] - velocY[IX(i, j - 1)]
                    ) / N;
                    p[IX(i, j)] = 0;
                }
            }
            setBoundary(0, div);
            setBoundary(0, p);
            linearSolve(0, p, div, 1, 4);

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                    velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                }
            }
            setBoundary(1, velocX);
            setBoundary(2, velocY);
        }

        function velocityStep() {
            diffuse(1, vx0, vx, viscosity);
            diffuse(2, vy0, vy, viscosity);

            project(vx0, vy0, vx, vy);

            advect(1, vx, vx0, vx0, vy0);
            advect(2, vy, vy0, vx0, vy0);

            project(vx, vy, vx0, vy0);
        }

        function densityStep() {
            // Process each color channel
            diffuse(0, densityPrevR, densityR, diffusion);
            diffuse(0, densityPrevG, densityG, diffusion);
            diffuse(0, densityPrevB, densityB, diffusion);

            advect(0, densityR, densityPrevR, vx, vy);
            advect(0, densityG, densityPrevG, vx, vy);
            advect(0, densityB, densityPrevB, vx, vy);

            // Fade density
            for (let i = 0; i < N * N; i++) {
                densityR[i] *= fadeRate;
                densityG[i] *= fadeRate;
                densityB[i] *= fadeRate;
            }
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = IX(i, j);
                    const r = Math.min(255, Math.max(0, densityR[idx]));
                    const g = Math.min(255, Math.max(0, densityG[idx]));
                    const b = Math.min(255, Math.max(0, densityB[idx]));

                    // Fill SCALE x SCALE pixel block
                    for (let py = 0; py < SCALE; py++) {
                        for (let px = 0; px < SCALE; px++) {
                            const index = ((j * SCALE + py) * canvas.width + (i * SCALE + px)) * 4;
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            addSource();
            velocityStep();
            densityStep();
            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
