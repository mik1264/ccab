<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jos Stam Fluid - Smoke Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 1px solid #333;
            cursor: crosshair;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
        }
        .controls label {
            display: block;
            margin: 8px 0;
        }
        .controls input[type="range"] {
            width: 150px;
            vertical-align: middle;
        }
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: #888;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Jos Stam Fluid Solver</h3>
        <label>
            Viscosity: <span id="viscosityValue">0.0001</span>
            <input type="range" id="viscosity" min="0" max="0.001" step="0.00001" value="0.0001">
        </label>
        <label>
            Diffusion: <span id="diffusionValue">0.0</span>
            <input type="range" id="diffusion" min="0" max="0.001" step="0.00001" value="0.0">
        </label>
        <label>
            Fade: <span id="fadeValue">0.99</span>
            <input type="range" id="fade" min="0.90" max="1.0" step="0.01" value="0.99">
        </label>
        <button onclick="reset()" style="margin-top: 10px; padding: 5px 15px; cursor: pointer;">Reset</button>
    </div>
    <div class="info">
        Click and drag to add smoke â€¢ Based on Jos Stam's "Real-Time Fluid Dynamics for Games"
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid resolution
        const N = 128;
        const SCALE = 4;
        canvas.width = N * SCALE;
        canvas.height = N * SCALE;

        // Fluid simulation parameters
        let viscosity = 0.0001;
        let diffusion = 0.0;
        let dt = 0.1;
        let fadeRate = 0.99;

        // Fluid grids
        let density = new Float32Array(N * N);
        let densityPrev = new Float32Array(N * N);
        let vx = new Float32Array(N * N);
        let vy = new Float32Array(N * N);
        let vx0 = new Float32Array(N * N);
        let vy0 = new Float32Array(N * N);

        // Mouse interaction
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let pmouseX = 0, pmouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            mouseX = Math.floor((e.clientX - rect.left) / SCALE);
            mouseY = Math.floor((e.clientY - rect.top) / SCALE);
            pmouseX = mouseX;
            pmouseY = mouseY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            pmouseX = mouseX;
            pmouseY = mouseY;
            mouseX = Math.floor((e.clientX - rect.left) / SCALE);
            mouseY = Math.floor((e.clientY - rect.top) / SCALE);
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = Math.floor((touch.clientX - rect.left) / SCALE);
            mouseY = Math.floor((touch.clientY - rect.top) / SCALE);
            pmouseX = mouseX;
            pmouseY = mouseY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            pmouseX = mouseX;
            pmouseY = mouseY;
            mouseX = Math.floor((touch.clientX - rect.left) / SCALE);
            mouseY = Math.floor((touch.clientY - rect.top) / SCALE);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            mouseDown = false;
        });

        // Controls
        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscosityValue').textContent = viscosity.toFixed(5);
        });

        document.getElementById('diffusion').addEventListener('input', (e) => {
            diffusion = parseFloat(e.target.value);
            document.getElementById('diffusionValue').textContent = diffusion.toFixed(5);
        });

        document.getElementById('fade').addEventListener('input', (e) => {
            fadeRate = parseFloat(e.target.value);
            document.getElementById('fadeValue').textContent = fadeRate.toFixed(2);
        });

        function reset() {
            density.fill(0);
            densityPrev.fill(0);
            vx.fill(0);
            vy.fill(0);
            vx0.fill(0);
            vy0.fill(0);
        }

        function IX(x, y) {
            x = Math.max(0, Math.min(N - 1, x));
            y = Math.max(0, Math.min(N - 1, y));
            return x + y * N;
        }

        // Add density and velocity from mouse
        function addSource() {
            if (mouseDown && mouseX >= 0 && mouseX < N && mouseY >= 0 && mouseY < N) {
                const amount = 100;
                const radius = 3;

                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        const x = mouseX + i;
                        const y = mouseY + j;
                        if (x >= 0 && x < N && y >= 0 && y < N) {
                            const d = Math.sqrt(i * i + j * j);
                            if (d < radius) {
                                const factor = 1 - d / radius;
                                density[IX(x, y)] += amount * factor;
                            }
                        }
                    }
                }

                // Add velocity
                const dx = mouseX - pmouseX;
                const dy = mouseY - pmouseY;
                if (dx !== 0 || dy !== 0) {
                    for (let i = -radius; i <= radius; i++) {
                        for (let j = -radius; j <= radius; j++) {
                            const x = mouseX + i;
                            const y = mouseY + j;
                            if (x >= 0 && x < N && y >= 0 && y < N) {
                                const d = Math.sqrt(i * i + j * j);
                                if (d < radius) {
                                    const factor = 1 - d / radius;
                                    vx[IX(x, y)] += dx * factor * 5;
                                    vy[IX(x, y)] += dy * factor * 5;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Set boundary conditions
        function setBoundary(b, x) {
            for (let i = 1; i < N - 1; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N - 1, i)] = b === 1 ? -x[IX(N - 2, i)] : x[IX(N - 2, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N - 1)] = b === 2 ? -x[IX(i, N - 2)] : x[IX(i, N - 2)];
            }
            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N - 1)] = 0.5 * (x[IX(1, N - 1)] + x[IX(0, N - 2)]);
            x[IX(N - 1, 0)] = 0.5 * (x[IX(N - 2, 0)] + x[IX(N - 1, 1)]);
            x[IX(N - 1, N - 1)] = 0.5 * (x[IX(N - 2, N - 1)] + x[IX(N - 1, N - 2)]);
        }

        // Linear solver for diffusion
        function linearSolve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < 20; k++) {
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (
                            x[IX(i + 1, j)] +
                            x[IX(i - 1, j)] +
                            x[IX(i, j + 1)] +
                            x[IX(i, j - 1)]
                        )) * cRecip;
                    }
                }
                setBoundary(b, x);
            }
        }

        // Diffusion step
        function diffuse(b, x, x0, diff) {
            const a = dt * diff * (N - 2) * (N - 2);
            linearSolve(b, x, x0, a, 1 + 4 * a);
        }

        // Advection step
        function advect(b, d, d0, velocX, velocY) {
            const dt0 = dt * (N - 2);
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    let x = i - dt0 * velocX[IX(i, j)];
                    let y = j - dt0 * velocY[IX(i, j)];

                    x = Math.max(0.5, Math.min(N - 1.5, x));
                    y = Math.max(0.5, Math.min(N - 1.5, y));

                    const i0 = Math.floor(x);
                    const i1 = i0 + 1;
                    const j0 = Math.floor(y);
                    const j1 = j0 + 1;

                    const s1 = x - i0;
                    const s0 = 1 - s1;
                    const t1 = y - j0;
                    const t0 = 1 - t1;

                    d[IX(i, j)] =
                        s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                        s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            setBoundary(b, d);
        }

        // Project for velocity field (mass conservation)
        function project(velocX, velocY, p, div) {
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    div[IX(i, j)] = -0.5 * (
                        velocX[IX(i + 1, j)] -
                        velocX[IX(i - 1, j)] +
                        velocY[IX(i, j + 1)] -
                        velocY[IX(i, j - 1)]
                    ) / N;
                    p[IX(i, j)] = 0;
                }
            }
            setBoundary(0, div);
            setBoundary(0, p);
            linearSolve(0, p, div, 1, 4);

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                    velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                }
            }
            setBoundary(1, velocX);
            setBoundary(2, velocY);
        }

        // Velocity step
        function velocityStep() {
            diffuse(1, vx0, vx, viscosity);
            diffuse(2, vy0, vy, viscosity);

            project(vx0, vy0, vx, vy);

            advect(1, vx, vx0, vx0, vy0);
            advect(2, vy, vy0, vx0, vy0);

            project(vx, vy, vx0, vy0);
        }

        // Density step
        function densityStep() {
            diffuse(0, densityPrev, density, diffusion);
            advect(0, density, densityPrev, vx, vy);

            // Fade density
            for (let i = 0; i < N * N; i++) {
                density[i] *= fadeRate;
            }
        }

        // Render
        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const d = Math.min(255, Math.max(0, density[IX(i, j)]));

                    // Fill SCALE x SCALE pixel block
                    for (let py = 0; py < SCALE; py++) {
                        for (let px = 0; px < SCALE; px++) {
                            const index = ((j * SCALE + py) * canvas.width + (i * SCALE + px)) * 4;
                            data[index] = d;     // R
                            data[index + 1] = d; // G
                            data[index + 2] = d; // B
                            data[index + 3] = 255; // A
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Animation loop
        function animate() {
            addSource();
            velocityStep();
            densityStep();
            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
