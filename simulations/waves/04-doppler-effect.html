<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doppler Effect Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            max-width: 1200px;
            width: 100%;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .description {
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.9;
        }
        .canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        canvas {
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #001a1a;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .control-group .value {
            text-align: right;
            opacity: 0.8;
            font-size: 0.9em;
        }
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        .stats {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            line-height: 1.6;
        }
        .info h3 {
            margin-bottom: 10px;
        }
        .warning {
            background: rgba(255, 100, 100, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 4px solid #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Doppler Effect Visualization</h1>
        <p class="description">
            Watch how wave frequency changes when a source moves relative to an observer.
            Wavefronts compress ahead of motion (higher frequency) and stretch behind (lower frequency).
        </p>

        <div class="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Source Velocity: <span class="value" id="velocityValue">0.0 c</span></label>
                <input type="range" id="velocity" min="-1.5" max="1.5" step="0.05" value="0.5">
            </div>

            <div class="control-group">
                <label>Wave Frequency (f₀): <span class="value" id="freqValue">2.0 Hz</span></label>
                <input type="range" id="frequency" min="0.5" max="5" step="0.1" value="2.0">
            </div>

            <div class="control-group">
                <label>Wave Speed (c): <span class="value" id="speedValue">100</span></label>
                <input type="range" id="waveSpeed" min="50" max="200" step="10" value="100">
            </div>

            <div class="control-group">
                <label>Emission Rate: <span class="value" id="rateValue">Normal</span></label>
                <input type="range" id="emissionRate" min="0.5" max="2" step="0.1" value="1.0">
            </div>
        </div>

        <div class="button-group">
            <button id="presetStill">Stationary</button>
            <button id="presetSubsonic">Subsonic (0.5c)</button>
            <button id="presetNearSonic">Near Sonic (0.9c)</button>
            <button id="presetSonic">Sonic (1.0c)</button>
            <button id="presetSupersonic">Supersonic (1.3c)</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Source Velocity (v)</div>
                <div class="stat-value" id="statVelocity">0.0 c</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Observed Frequency (Ahead)</div>
                <div class="stat-value" id="statFreqAhead">2.0 Hz</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Observed Frequency (Behind)</div>
                <div class="stat-value" id="statFreqBehind">2.0 Hz</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Mach Number</div>
                <div class="stat-value" id="statMach">0.00</div>
            </div>
        </div>

        <div class="info">
            <h3>Doppler Effect Theory</h3>
            <p>
                The Doppler effect describes the change in observed wave frequency due to relative motion between source and observer.
            </p>
            <p style="margin-top: 10px;">
                <strong>Frequency Shift:</strong><br>
                • Observer ahead of source: f' = f₀ · c/(c - v) (higher frequency)<br>
                • Observer behind source: f' = f₀ · c/(c + v) (lower frequency)<br>
                Where f₀ is emitted frequency, v is source velocity, c is wave speed
            </p>
            <p style="margin-top: 10px;">
                <strong>Mach Number:</strong> M = v/c<br>
                • M < 1: Subsonic (wavefronts ahead are compressed)<br>
                • M = 1: Sonic (wavefronts pile up, forming shock wave)<br>
                • M > 1: Supersonic (Mach cone forms with angle α = arcsin(1/M))
            </p>
            <div class="warning" id="sonicWarning" style="display: none;">
                <strong>⚠ Sonic Boom!</strong> When the source moves at or faster than wave speed, wavefronts pile up creating a shock wave (sonic boom). The cone angle is the Mach cone.
            </div>
            <p style="margin-top: 10px;">
                <strong>Applications:</strong> Radar speed detection, astronomy (redshift/blueshift), medical ultrasound, weather forecasting (Doppler radar).
            </p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        const width = Math.min(900, window.innerWidth - 80);
        const height = Math.min(600, window.innerHeight - 500);
        canvas.width = width;
        canvas.height = height;

        // Wave source
        let source = {
            x: width / 2,
            y: height / 2,
            vx: 0,
            vy: 0
        };

        // Wavefronts
        let wavefronts = [];
        let time = 0;
        let lastEmission = 0;

        // Parameters
        let params = {
            velocity: 0.5,
            frequency: 2.0,
            waveSpeed: 100,
            emissionRate: 1.0
        };

        // Calculate Doppler shift
        function calculateDoppler(angle) {
            const c = params.waveSpeed;
            const v = Math.sqrt(source.vx * source.vx + source.vy * source.vy);
            const f0 = params.frequency;

            // Component of velocity in direction of observer
            const vRadial = v * Math.cos(angle);

            // Doppler formula
            if (Math.abs(c - vRadial) < 0.01) return Infinity; // Sonic boom
            const fObserved = f0 * c / (c - vRadial);

            return fObserved;
        }

        // Update simulation
        function update(dt) {
            // Move source
            source.x += source.vx * dt;
            source.y += source.vy * dt;

            // Wrap around boundaries
            if (source.x < 0) source.x = width;
            if (source.x > width) source.x = 0;
            if (source.y < 0) source.y = height;
            if (source.y > height) source.y = 0;

            // Emit new wavefront
            const emissionInterval = 1.0 / (params.frequency * params.emissionRate);
            if (time - lastEmission >= emissionInterval) {
                wavefronts.push({
                    x: source.x,
                    y: source.y,
                    radius: 0,
                    age: 0
                });
                lastEmission = time;
            }

            // Update wavefronts
            for (let wf of wavefronts) {
                wf.radius += params.waveSpeed * dt;
                wf.age += dt;
            }

            // Remove old wavefronts
            wavefronts = wavefronts.filter(wf => {
                const maxDist = Math.sqrt(width * width + height * height);
                return wf.radius < maxDist;
            });

            time += dt;
        }

        // Render
        function render() {
            // Clear
            ctx.fillStyle = '#001a1a';
            ctx.fillRect(0, 0, width, height);

            // Draw wavefronts
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            ctx.lineWidth = 2;

            for (let wf of wavefronts) {
                const alpha = Math.max(0, 1 - wf.age / 3);
                ctx.strokeStyle = `rgba(100, 200, 255, ${alpha * 0.6})`;

                ctx.beginPath();
                ctx.arc(wf.x, wf.y, wf.radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw Mach cone if supersonic
            const v = Math.sqrt(source.vx * source.vx + source.vy * source.vy);
            const machNumber = v / params.waveSpeed;

            if (machNumber > 1) {
                const machAngle = Math.asin(1 / machNumber);
                const velocityAngle = Math.atan2(source.vy, source.vx);

                ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);

                const coneLength = 300;
                const x1 = source.x + coneLength * Math.cos(velocityAngle + machAngle);
                const y1 = source.y + coneLength * Math.sin(velocityAngle + machAngle);
                const x2 = source.x + coneLength * Math.cos(velocityAngle - machAngle);
                const y2 = source.y + coneLength * Math.sin(velocityAngle - machAngle);

                ctx.lineTo(x1, y1);
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Label
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.font = '14px sans-serif';
                ctx.fillText('Mach Cone', source.x + 10, source.y - 20);
            }

            // Draw velocity vector
            if (v > 0.1) {
                const scale = 50;
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(source.x + source.vx * scale, source.y + source.vy * scale);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(source.vy, source.vx);
                const arrowSize = 10;
                ctx.beginPath();
                ctx.moveTo(
                    source.x + source.vx * scale,
                    source.y + source.vy * scale
                );
                ctx.lineTo(
                    source.x + source.vx * scale - arrowSize * Math.cos(angle - Math.PI / 6),
                    source.y + source.vy * scale - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    source.x + source.vx * scale - arrowSize * Math.cos(angle + Math.PI / 6),
                    source.y + source.vy * scale - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
                ctx.fill();
            }

            // Draw source
            ctx.fillStyle = '#ff5722';
            ctx.beginPath();
            ctx.arc(source.x, source.y, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw observers
            const observerRadius = 5;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';

            // Observer ahead
            const aheadAngle = Math.atan2(source.vy, source.vx);
            const aheadDist = 150;
            const aheadX = source.x + aheadDist * Math.cos(aheadAngle);
            const aheadY = source.y + aheadDist * Math.sin(aheadAngle);
            ctx.beginPath();
            ctx.arc(aheadX, aheadY, observerRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillText('Observer (ahead)', aheadX + 10, aheadY - 10);

            // Observer behind
            const behindX = source.x - aheadDist * Math.cos(aheadAngle);
            const behindY = source.y - aheadDist * Math.sin(aheadAngle);
            ctx.beginPath();
            ctx.arc(behindX, behindY, observerRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillText('Observer (behind)', behindX + 10, behindY + 20);
        }

        // Update statistics
        function updateStats() {
            const v = Math.sqrt(source.vx * source.vx + source.vy * source.vy);
            const machNumber = v / params.waveSpeed;
            const c = params.waveSpeed;
            const f0 = params.frequency;

            document.getElementById('statVelocity').textContent = (v / c).toFixed(2) + ' c';
            document.getElementById('statMach').textContent = machNumber.toFixed(2);

            // Frequency ahead
            const fAhead = Math.abs(c - v) < 0.01 ? Infinity : f0 * c / (c - v);
            document.getElementById('statFreqAhead').textContent =
                fAhead === Infinity ? '∞' : fAhead.toFixed(2) + ' Hz';

            // Frequency behind
            const fBehind = f0 * c / (c + v);
            document.getElementById('statFreqBehind').textContent = fBehind.toFixed(2) + ' Hz';

            // Show sonic boom warning
            const warning = document.getElementById('sonicWarning');
            warning.style.display = machNumber >= 1.0 ? 'block' : 'none';
        }

        // Animation loop
        function animate() {
            const dt = 0.016; // ~60 FPS
            update(dt);
            render();
            updateStats();
            requestAnimationFrame(animate);
        }

        // Set velocity
        function setVelocity(fraction) {
            const speed = fraction * params.waveSpeed;
            source.vx = speed;
            source.vy = 0;
            params.velocity = fraction;
            document.getElementById('velocity').value = fraction;
            document.getElementById('velocityValue').textContent = fraction.toFixed(2) + ' c';
        }

        // Event listeners
        document.getElementById('velocity').addEventListener('input', (e) => {
            setVelocity(parseFloat(e.target.value));
        });

        document.getElementById('frequency').addEventListener('input', (e) => {
            params.frequency = parseFloat(e.target.value);
            document.getElementById('freqValue').textContent = params.frequency.toFixed(1) + ' Hz';
        });

        document.getElementById('waveSpeed').addEventListener('input', (e) => {
            params.waveSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = params.waveSpeed;
        });

        document.getElementById('emissionRate').addEventListener('input', (e) => {
            params.emissionRate = parseFloat(e.target.value);
            const rateText = params.emissionRate === 1.0 ? 'Normal' :
                params.emissionRate < 1.0 ? 'Slow' : 'Fast';
            document.getElementById('rateValue').textContent = rateText;
        });

        // Preset buttons
        document.getElementById('presetStill').addEventListener('click', () => setVelocity(0));
        document.getElementById('presetSubsonic').addEventListener('click', () => setVelocity(0.5));
        document.getElementById('presetNearSonic').addEventListener('click', () => setVelocity(0.9));
        document.getElementById('presetSonic').addEventListener('click', () => setVelocity(1.0));
        document.getElementById('presetSupersonic').addEventListener('click', () => setVelocity(1.3));

        // Initialize
        setVelocity(0.5);
        animate();
    </script>
</body>
</html>
