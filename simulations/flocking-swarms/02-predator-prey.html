<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predator-Prey Boids Dynamics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 1400px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.6;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        canvas {
            border: 2px solid #38ef7d;
            border-radius: 10px;
            background: #0a0a0a;
            box-shadow: 0 0 30px rgba(56, 239, 125, 0.3);
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 350px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #38ef7d;
            font-weight: 600;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #38ef7d;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(56, 239, 125, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #38ef7d;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #fff;
            font-weight: bold;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(56, 239, 125, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stats-label {
            color: #aaa;
        }

        .stats-value {
            color: #38ef7d;
            font-weight: bold;
        }

        .stats-value.prey {
            color: #4ade80;
        }

        .stats-value.predator {
            color: #ef4444;
        }

        .info-box {
            background: rgba(56, 239, 125, 0.1);
            border-left: 4px solid #38ef7d;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .info-box h3 {
            color: #38ef7d;
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .prey-color {
            background: #4ade80;
        }

        .predator-color {
            background: #ef4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Predator-Prey Dynamics</h1>
        <p class="description">
            Explore the fascinating interplay between hunters and hunted in this extension of the classic Boids algorithm.
            Green prey agents flock together for safety while red predators hunt them down. Watch as natural selection
            plays out: predators must catch prey to survive, while prey must evade and reproduce. Energy dynamics
            create realistic population oscillations reminiscent of Lotka-Volterra equations.
        </p>

        <div class="content">
            <canvas id="canvas"></canvas>

            <div class="controls">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color prey-color"></div>
                        <span>Prey</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color predator-color"></div>
                        <span>Predator</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>
                        Initial Prey: <span class="value-display" id="preyCountValue">150</span>
                    </label>
                    <input type="range" id="preyCount" min="50" max="300" value="150" step="10">
                </div>

                <div class="control-group">
                    <label>
                        Predator Count: <span class="value-display" id="predatorCountValue">15</span>
                    </label>
                    <input type="range" id="predatorCount" min="5" max="40" value="15" step="1">
                </div>

                <div class="control-group">
                    <label>
                        Predator Speed: <span class="value-display" id="predatorSpeedValue">2.5</span>
                    </label>
                    <input type="range" id="predatorSpeed" min="1.5" max="4.0" value="2.5" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Flee Strength: <span class="value-display" id="fleeStrengthValue">2.0</span>
                    </label>
                    <input type="range" id="fleeStrength" min="0.5" max="4.0" value="2.0" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Predator Vision: <span class="value-display" id="predatorVisionValue">80</span>
                    </label>
                    <input type="range" id="predatorVision" min="50" max="150" value="80" step="5">
                </div>

                <div class="control-group">
                    <label>
                        Prey Vision: <span class="value-display" id="preyVisionValue">60</span>
                    </label>
                    <input type="range" id="preyVision" min="40" max="120" value="60" step="5">
                </div>

                <button class="btn-primary" id="pauseBtn">Pause</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>

                <div class="stats">
                    <div class="stats-row">
                        <span class="stats-label">FPS:</span>
                        <span class="stats-value" id="fps">60</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Prey Population:</span>
                        <span class="stats-value prey" id="preyPop">150</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Predator Population:</span>
                        <span class="stats-value predator" id="predatorPop">15</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Total Captures:</span>
                        <span class="stats-value" id="captures">0</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Prey Spawned:</span>
                        <span class="stats-value" id="spawned">0</span>
                    </div>
                </div>

                <div class="info-box">
                    <h3>Ecosystem Dynamics</h3>
                    <p><strong>Prey:</strong> Flock for safety, flee from predators, reproduce when safe</p>
                    <p><strong>Predators:</strong> Hunt nearest prey, need energy from captures to survive</p>
                    <p style="margin-top: 10px; font-style: italic;">
                        Watch population cycles emerge from simple rules!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const WIDTH = 900;
        const HEIGHT = 900;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        let params = {
            initialPreyCount: 150,
            predatorCount: 15,
            preySpeed: 2.0,
            predatorSpeed: 2.5,
            fleeStrength: 2.0,
            predatorVision: 80,
            preyVision: 60,
            captureDistance: 15,
            maxPreyPopulation: 300
        };

        let paused = false;
        let totalCaptures = 0;
        let totalSpawned = 0;

        const GRID_SIZE = 50;
        const COLS = Math.ceil(WIDTH / GRID_SIZE);
        const ROWS = Math.ceil(HEIGHT / GRID_SIZE);

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }

            mult(n) {
                this.x *= n;
                this.y *= n;
                return this;
            }

            div(n) {
                if (n !== 0) {
                    this.x /= n;
                    this.y /= n;
                }
                return this;
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }

            limit(max) {
                const m = this.mag();
                if (m > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }

            setMag(n) {
                this.normalize();
                this.mult(n);
                return this;
            }

            dist(v) {
                const dx = this.x - v.x;
                const dy = this.y - v.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            copy() {
                return new Vector(this.x, this.y);
            }

            static sub(v1, v2) {
                return new Vector(v1.x - v2.x, v1.y - v2.y);
            }

            static dist(v1, v2) {
                return v1.dist(v2);
            }
        }

        class Boid {
            constructor(isPredator = false) {
                this.position = new Vector(
                    Math.random() * WIDTH,
                    Math.random() * HEIGHT
                );
                const angle = Math.random() * Math.PI * 2;
                const speed = isPredator ? params.predatorSpeed : params.preySpeed;
                this.velocity = new Vector(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
                this.acceleration = new Vector(0, 0);
                this.isPredator = isPredator;
                this.size = isPredator ? 10 : 7;
                this.maxSpeed = isPredator ? params.predatorSpeed : params.preySpeed;
                this.maxForce = 0.05;
                this.energy = isPredator ? 100 : 50;
                this.dead = false;
            }

            update() {
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.mult(0);

                // Wrap around edges
                if (this.position.x < 0) this.position.x = WIDTH;
                if (this.position.x > WIDTH) this.position.x = 0;
                if (this.position.y < 0) this.position.y = HEIGHT;
                if (this.position.y > HEIGHT) this.position.y = 0;

                // Energy consumption
                if (this.isPredator) {
                    this.energy -= 0.05;
                    if (this.energy <= 0) this.dead = true;
                }
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            seek(target) {
                const desired = Vector.sub(target, this.position);
                desired.normalize();
                desired.mult(this.maxSpeed);
                const steer = Vector.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }

            flee(target) {
                const desired = Vector.sub(this.position, target);
                desired.normalize();
                desired.mult(this.maxSpeed);
                const steer = Vector.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }

            draw(ctx) {
                if (this.dead) return;

                const angle = Math.atan2(this.velocity.y, this.velocity.x);

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);

                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size, this.size / 2);
                ctx.lineTo(-this.size, -this.size / 2);
                ctx.closePath();

                if (this.isPredator) {
                    ctx.fillStyle = '#ef4444';
                    ctx.strokeStyle = '#991b1b';
                } else {
                    ctx.fillStyle = '#4ade80';
                    ctx.strokeStyle = '#166534';
                }

                ctx.fill();
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();

                // Draw vision cone for predators
                if (this.isPredator) {
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, params.predatorVision, angle - 0.5, angle + 0.5);
                    ctx.lineTo(this.position.x, this.position.y);
                    ctx.closePath();
                    ctx.stroke();
                }
            }
        }

        class SpatialGrid {
            constructor() {
                this.grid = Array(ROWS).fill(null).map(() =>
                    Array(COLS).fill(null).map(() => [])
                );
            }

            clear() {
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        this.grid[i][j] = [];
                    }
                }
            }

            insert(boid, index) {
                const col = Math.floor(boid.position.x / GRID_SIZE);
                const row = Math.floor(boid.position.y / GRID_SIZE);

                if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                    this.grid[row][col].push({ boid, index });
                }
            }

            getNearby(position, radius) {
                const nearby = [];
                const col = Math.floor(position.x / GRID_SIZE);
                const row = Math.floor(position.y / GRID_SIZE);
                const cellRadius = Math.ceil(radius / GRID_SIZE);

                for (let i = row - cellRadius; i <= row + cellRadius; i++) {
                    for (let j = col - cellRadius; j <= col + cellRadius; j++) {
                        if (i >= 0 && i < ROWS && j >= 0 && j < COLS) {
                            nearby.push(...this.grid[i][j]);
                        }
                    }
                }

                return nearby;
            }
        }

        let prey = [];
        let predators = [];
        let spatialGrid = new SpatialGrid();

        function initSimulation() {
            prey = [];
            predators = [];
            totalCaptures = 0;
            totalSpawned = 0;

            for (let i = 0; i < params.initialPreyCount; i++) {
                prey.push(new Boid(false));
            }

            for (let i = 0; i < params.predatorCount; i++) {
                predators.push(new Boid(true));
            }

            updateStats();
        }

        initSimulation();

        let lastTime = performance.now();
        let fps = 60;
        let frameCount = 0;

        function updateFPS() {
            const now = performance.now();
            const delta = now - lastTime;
            fps = Math.round(1000 / delta);
            lastTime = now;
            document.getElementById('fps').textContent = fps;
        }

        function updateStats() {
            document.getElementById('preyPop').textContent = prey.filter(p => !p.dead).length;
            document.getElementById('predatorPop').textContent = predators.filter(p => !p.dead).length;
            document.getElementById('captures').textContent = totalCaptures;
            document.getElementById('spawned').textContent = totalSpawned;
        }

        function flockBehavior(boid, neighbors) {
            const separation = new Vector(0, 0);
            const alignment = new Vector(0, 0);
            const cohesion = new Vector(0, 0);
            let count = 0;

            for (const other of neighbors) {
                if (other.isPredator === boid.isPredator) {
                    const d = Vector.dist(boid.position, other.position);

                    if (d < 25) {
                        const diff = Vector.sub(boid.position, other.position);
                        diff.normalize();
                        diff.div(d);
                        separation.add(diff);
                    }

                    alignment.add(other.velocity);
                    cohesion.add(other.position);
                    count++;
                }
            }

            if (count > 0) {
                separation.mult(1.5);

                alignment.div(count);
                alignment.normalize();
                alignment.mult(boid.maxSpeed);
                alignment.sub(boid.velocity);
                alignment.limit(boid.maxForce);

                cohesion.div(count);
                const cohesionForce = boid.seek(cohesion);

                boid.applyForce(separation);
                boid.applyForce(alignment);
                boid.applyForce(cohesionForce);
            }
        }

        function animate() {
            if (!paused) {
                ctx.fillStyle = 'rgba(10, 10, 10, 0.15)';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Update spatial grid
                spatialGrid.clear();
                prey.forEach((p, i) => !p.dead && spatialGrid.insert(p, i));
                predators.forEach((p, i) => !p.dead && spatialGrid.insert(p, i + 10000));

                // Update prey
                prey.forEach(p => {
                    if (p.dead) return;

                    const nearby = spatialGrid.getNearby(p.position, params.preyVision);
                    const neighbors = nearby
                        .map(item => item.boid)
                        .filter(other => other !== p && !other.dead);

                    // Check for nearby predators
                    const nearbyPredators = neighbors.filter(n => n.isPredator);

                    if (nearbyPredators.length > 0) {
                        // Flee from nearest predator
                        let closest = nearbyPredators[0];
                        let closestDist = Vector.dist(p.position, closest.position);

                        for (const pred of nearbyPredators) {
                            const d = Vector.dist(p.position, pred.position);
                            if (d < closestDist) {
                                closestDist = d;
                                closest = pred;
                            }
                        }

                        const fleeForce = p.flee(closest.position);
                        fleeForce.mult(params.fleeStrength);
                        p.applyForce(fleeForce);
                    } else {
                        // Normal flocking
                        flockBehavior(p, neighbors.filter(n => !n.isPredator));
                    }

                    p.update();
                });

                // Update predators
                predators.forEach(pred => {
                    if (pred.dead) return;

                    const nearby = spatialGrid.getNearby(pred.position, params.predatorVision);
                    const neighbors = nearby
                        .map(item => item.boid)
                        .filter(other => other !== pred && !other.dead);

                    // Find nearest prey
                    const nearbyPrey = neighbors.filter(n => !n.isPredator);

                    if (nearbyPrey.length > 0) {
                        let closest = nearbyPrey[0];
                        let closestDist = Vector.dist(pred.position, closest.position);

                        for (const p of nearbyPrey) {
                            const d = Vector.dist(pred.position, p.position);
                            if (d < closestDist) {
                                closestDist = d;
                                closest = p;
                            }
                        }

                        // Chase prey
                        const chaseForce = pred.seek(closest.position);
                        chaseForce.mult(2.0);
                        pred.applyForce(chaseForce);

                        // Check for capture
                        if (closestDist < params.captureDistance) {
                            closest.dead = true;
                            pred.energy = Math.min(pred.energy + 50, 200);
                            totalCaptures++;
                        }
                    } else {
                        // Wander
                        flockBehavior(pred, neighbors.filter(n => n.isPredator));
                    }

                    pred.update();
                });

                // Remove dead prey and predators
                prey = prey.filter(p => !p.dead);
                predators = predators.filter(p => !p.dead);

                // Spawn new prey occasionally
                frameCount++;
                if (frameCount % 120 === 0 && prey.length < params.maxPreyPopulation) {
                    prey.push(new Boid(false));
                    totalSpawned++;
                }

                // Draw all
                prey.forEach(p => p.draw(ctx));
                predators.forEach(p => p.draw(ctx));

                updateFPS();
                updateStats();
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('preyCount').addEventListener('input', (e) => {
            params.initialPreyCount = parseInt(e.target.value);
            document.getElementById('preyCountValue').textContent = params.initialPreyCount;
        });

        document.getElementById('predatorCount').addEventListener('input', (e) => {
            params.predatorCount = parseInt(e.target.value);
            document.getElementById('predatorCountValue').textContent = params.predatorCount;
        });

        document.getElementById('predatorSpeed').addEventListener('input', (e) => {
            params.predatorSpeed = parseFloat(e.target.value);
            document.getElementById('predatorSpeedValue').textContent = params.predatorSpeed.toFixed(1);
            predators.forEach(p => p.maxSpeed = params.predatorSpeed);
        });

        document.getElementById('fleeStrength').addEventListener('input', (e) => {
            params.fleeStrength = parseFloat(e.target.value);
            document.getElementById('fleeStrengthValue').textContent = params.fleeStrength.toFixed(1);
        });

        document.getElementById('predatorVision').addEventListener('input', (e) => {
            params.predatorVision = parseInt(e.target.value);
            document.getElementById('predatorVisionValue').textContent = params.predatorVision;
        });

        document.getElementById('preyVision').addEventListener('input', (e) => {
            params.preyVision = parseInt(e.target.value);
            document.getElementById('preyVisionValue').textContent = params.preyVision;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initSimulation();
        });

        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
