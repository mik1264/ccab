<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Boids with Isometric Projection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 1400px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.6;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        canvas {
            border: 2px solid #667eea;
            border-radius: 10px;
            background: #0a0a0a;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 350px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #667eea;
            font-weight: 600;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #fff;
            font-weight: bold;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stats-label {
            color: #aaa;
        }

        .stats-value {
            color: #667eea;
            font-weight: bold;
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .info-box h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .rotation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3D Boids with Isometric Projection</h1>
        <p class="description">
            Experience flocking behavior in three dimensions! This simulation extends Reynolds' Boids algorithm into 3D space
            with isometric projection for visualization. Boids navigate through all three axes, creating mesmerizing depth
            and movement. Adjust rotation angles to view the flock from different perspectives, and watch shadows on the
            ground plane provide spatial context. Color gradients indicate height—blue for low, red for high.
        </p>

        <div class="content">
            <canvas id="canvas"></canvas>

            <div class="controls">
                <div class="control-group">
                    <label>
                        Boid Count: <span class="value-display" id="countValue">150</span>
                    </label>
                    <input type="range" id="boidCount" min="50" max="300" value="150" step="10">
                </div>

                <div class="control-group">
                    <label>
                        Max Speed: <span class="value-display" id="speedValue">2.0</span>
                    </label>
                    <input type="range" id="maxSpeed" min="0.5" max="4.0" value="2.0" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Perception Radius: <span class="value-display" id="radiusValue">50</span>
                    </label>
                    <input type="range" id="perceptionRadius" min="30" max="100" value="50" step="5">
                </div>

                <h3 style="color: #667eea; margin: 20px 0 10px 0;">Camera Rotation</h3>

                <div class="control-group">
                    <label>
                        Rotate X: <span class="value-display" id="rotXValue">0.6</span>
                    </label>
                    <input type="range" id="rotX" min="-3.14" max="3.14" value="0.6" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Rotate Y: <span class="value-display" id="rotYValue">0.8</span>
                    </label>
                    <input type="range" id="rotY" min="-3.14" max="3.14" value="0.8" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Rotate Z: <span class="value-display" id="rotZValue">0.0</span>
                    </label>
                    <input type="range" id="rotZ" min="-3.14" max="3.14" value="0.0" step="0.1">
                </div>

                <div class="rotation-grid">
                    <button class="btn-secondary" id="viewTop">Top View</button>
                    <button class="btn-secondary" id="viewFront">Front View</button>
                    <button class="btn-secondary" id="viewSide">Side View</button>
                    <button class="btn-secondary" id="viewIso">Isometric</button>
                </div>

                <button class="btn-primary" id="pauseBtn">Pause</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>

                <div class="stats">
                    <div class="stats-row">
                        <span class="stats-label">FPS:</span>
                        <span class="stats-value" id="fps">60</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Active Boids:</span>
                        <span class="stats-value" id="activeBoids">150</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Avg Height:</span>
                        <span class="stats-value" id="avgHeight">0</span>
                    </div>
                </div>

                <div class="info-box">
                    <h3>3D Flocking</h3>
                    <p><strong>Full 3D movement:</strong> Boids navigate in all three dimensions</p>
                    <p><strong>Isometric projection:</strong> 3D space rendered in 2D</p>
                    <p><strong>Color by height:</strong> Blue (low) → Red (high)</p>
                    <p style="margin-top: 10px; font-style: italic;">
                        Rotate the view to see depth and dimension!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const WIDTH = 900;
        const HEIGHT = 900;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        const WORLD_SIZE = 400;
        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        let params = {
            boidCount: 150,
            maxSpeed: 2.0,
            maxForce: 0.05,
            perceptionRadius: 50,
            rotX: 0.6,
            rotY: 0.8,
            rotZ: 0.0
        };

        let paused = false;
        let autoRotate = false;

        class Vector3D {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                return this;
            }

            mult(n) {
                this.x *= n;
                this.y *= n;
                this.z *= n;
                return this;
            }

            div(n) {
                if (n !== 0) {
                    this.x /= n;
                    this.y /= n;
                    this.z /= n;
                }
                return this;
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }

            limit(max) {
                const m = this.mag();
                if (m > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }

            copy() {
                return new Vector3D(this.x, this.y, this.z);
            }

            static sub(v1, v2) {
                return new Vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
            }

            static dist(v1, v2) {
                const dx = v1.x - v2.x;
                const dy = v1.y - v2.y;
                const dz = v1.z - v2.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
        }

        function rotateX(point, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return new Vector3D(
                point.x,
                point.y * cos - point.z * sin,
                point.y * sin + point.z * cos
            );
        }

        function rotateY(point, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return new Vector3D(
                point.x * cos + point.z * sin,
                point.y,
                -point.x * sin + point.z * cos
            );
        }

        function rotateZ(point, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return new Vector3D(
                point.x * cos - point.y * sin,
                point.x * sin + point.y * cos,
                point.z
            );
        }

        function project3DTo2D(point) {
            // Apply rotations
            let p = rotateX(point, params.rotX);
            p = rotateY(p, params.rotY);
            p = rotateZ(p, params.rotZ);

            // Isometric projection
            const scale = 1.5;
            const x = centerX + p.x * scale - p.z * scale * 0.5;
            const y = centerY + p.y * scale - p.z * scale * 0.5;

            return { x, y, z: p.z };
        }

        class Boid3D {
            constructor() {
                this.position = new Vector3D(
                    (Math.random() - 0.5) * WORLD_SIZE,
                    (Math.random() - 0.5) * WORLD_SIZE,
                    (Math.random() - 0.5) * WORLD_SIZE
                );
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                this.velocity = new Vector3D(
                    Math.sin(phi) * Math.cos(theta) * params.maxSpeed,
                    Math.sin(phi) * Math.sin(theta) * params.maxSpeed,
                    Math.cos(phi) * params.maxSpeed
                );
                this.acceleration = new Vector3D(0, 0, 0);
                this.size = 8;
            }

            update() {
                this.velocity.add(this.acceleration);
                this.velocity.limit(params.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.mult(0);

                // Boundary wrapping
                const half = WORLD_SIZE / 2;
                if (this.position.x < -half) this.position.x = half;
                if (this.position.x > half) this.position.x = -half;
                if (this.position.y < -half) this.position.y = half;
                if (this.position.y > half) this.position.y = -half;
                if (this.position.z < -half) this.position.z = half;
                if (this.position.z > half) this.position.z = -half;
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            flock(boids) {
                const separation = this.separate(boids);
                const alignment = this.align(boids);
                const cohesion = this.cohere(boids);

                separation.mult(1.5);
                alignment.mult(1.0);
                cohesion.mult(1.0);

                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }

            separate(neighbors) {
                const steer = new Vector3D(0, 0, 0);
                let count = 0;

                for (const other of neighbors) {
                    const d = Vector3D.dist(this.position, other.position);
                    if (d > 0 && d < 25) {
                        const diff = Vector3D.sub(this.position, other.position);
                        diff.normalize();
                        diff.div(d);
                        steer.add(diff);
                        count++;
                    }
                }

                if (count > 0) {
                    steer.div(count);
                    steer.normalize();
                    steer.mult(params.maxSpeed);
                    steer.sub(this.velocity);
                    steer.limit(params.maxForce);
                }

                return steer;
            }

            align(neighbors) {
                const sum = new Vector3D(0, 0, 0);
                let count = 0;

                for (const other of neighbors) {
                    sum.add(other.velocity);
                    count++;
                }

                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(params.maxSpeed);
                    const steer = Vector3D.sub(sum, this.velocity);
                    steer.limit(params.maxForce);
                    return steer;
                }

                return new Vector3D(0, 0, 0);
            }

            cohere(neighbors) {
                const sum = new Vector3D(0, 0, 0);
                let count = 0;

                for (const other of neighbors) {
                    sum.add(other.position);
                    count++;
                }

                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum);
                }

                return new Vector3D(0, 0, 0);
            }

            seek(target) {
                const desired = Vector3D.sub(target, this.position);
                desired.normalize();
                desired.mult(params.maxSpeed);
                const steer = Vector3D.sub(desired, this.velocity);
                steer.limit(params.maxForce);
                return steer;
            }

            getNeighbors(boids) {
                const neighbors = [];
                for (const other of boids) {
                    if (other !== this) {
                        const d = Vector3D.dist(this.position, other.position);
                        if (d < params.perceptionRadius) {
                            neighbors.push(other);
                        }
                    }
                }
                return neighbors;
            }

            draw(ctx) {
                const projected = project3DTo2D(this.position);

                // Color based on height (z-position)
                const heightRatio = (this.position.z + WORLD_SIZE / 2) / WORLD_SIZE;
                const r = Math.floor(heightRatio * 255);
                const b = Math.floor((1 - heightRatio) * 255);

                // Size based on depth (simple perspective)
                const scale = 1 + projected.z / 400;
                const size = this.size * Math.max(0.3, Math.min(1.5, scale));

                // Draw shadow on ground
                const shadowProj = project3DTo2D(new Vector3D(this.position.x, this.position.y, -WORLD_SIZE / 2));
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(shadowProj.x, shadowProj.y, size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw boid
                ctx.fillStyle = `rgb(${r}, 100, ${b})`;
                ctx.strokeStyle = `rgb(${r * 0.7}, 70, ${b * 0.7})`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.arc(projected.x, projected.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                return projected.z;
            }
        }

        let boids = [];

        function initBoids() {
            boids = [];
            for (let i = 0; i < params.boidCount; i++) {
                boids.push(new Boid3D());
            }
        }

        initBoids();

        let lastTime = performance.now();
        let fps = 60;

        function updateFPS() {
            const now = performance.now();
            const delta = now - lastTime;
            fps = Math.round(1000 / delta);
            lastTime = now;
            document.getElementById('fps').textContent = fps;
        }

        function animate() {
            if (!paused) {
                ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Update boids
                boids.forEach(boid => {
                    const neighbors = boid.getNeighbors(boids);
                    boid.flock(neighbors);
                    boid.update();
                });

                // Sort by z-depth for proper rendering
                const boidsWithZ = boids.map(boid => ({
                    boid,
                    z: project3DTo2D(boid.position).z
                }));
                boidsWithZ.sort((a, b) => a.z - b.z);

                // Draw boids
                boidsWithZ.forEach(item => item.boid.draw(ctx));

                // Calculate average height
                const avgZ = boids.reduce((sum, b) => sum + b.position.z, 0) / boids.length;
                document.getElementById('avgHeight').textContent = avgZ.toFixed(1);

                updateFPS();
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('boidCount').addEventListener('input', (e) => {
            params.boidCount = parseInt(e.target.value);
            document.getElementById('countValue').textContent = params.boidCount;
            document.getElementById('activeBoids').textContent = params.boidCount;

            while (boids.length < params.boidCount) {
                boids.push(new Boid3D());
            }
            while (boids.length > params.boidCount) {
                boids.pop();
            }
        });

        document.getElementById('maxSpeed').addEventListener('input', (e) => {
            params.maxSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = params.maxSpeed.toFixed(1);
        });

        document.getElementById('perceptionRadius').addEventListener('input', (e) => {
            params.perceptionRadius = parseInt(e.target.value);
            document.getElementById('radiusValue').textContent = params.perceptionRadius;
        });

        document.getElementById('rotX').addEventListener('input', (e) => {
            params.rotX = parseFloat(e.target.value);
            document.getElementById('rotXValue').textContent = params.rotX.toFixed(1);
        });

        document.getElementById('rotY').addEventListener('input', (e) => {
            params.rotY = parseFloat(e.target.value);
            document.getElementById('rotYValue').textContent = params.rotY.toFixed(1);
        });

        document.getElementById('rotZ').addEventListener('input', (e) => {
            params.rotZ = parseFloat(e.target.value);
            document.getElementById('rotZValue').textContent = params.rotZ.toFixed(1);
        });

        document.getElementById('viewTop').addEventListener('click', () => {
            params.rotX = 0;
            params.rotY = 0;
            params.rotZ = 0;
            updateRotationSliders();
        });

        document.getElementById('viewFront').addEventListener('click', () => {
            params.rotX = 1.57;
            params.rotY = 0;
            params.rotZ = 0;
            updateRotationSliders();
        });

        document.getElementById('viewSide').addEventListener('click', () => {
            params.rotX = 0;
            params.rotY = 1.57;
            params.rotZ = 0;
            updateRotationSliders();
        });

        document.getElementById('viewIso').addEventListener('click', () => {
            params.rotX = 0.6;
            params.rotY = 0.8;
            params.rotZ = 0;
            updateRotationSliders();
        });

        function updateRotationSliders() {
            document.getElementById('rotX').value = params.rotX;
            document.getElementById('rotY').value = params.rotY;
            document.getElementById('rotZ').value = params.rotZ;
            document.getElementById('rotXValue').textContent = params.rotX.toFixed(1);
            document.getElementById('rotYValue').textContent = params.rotY.toFixed(1);
            document.getElementById('rotZValue').textContent = params.rotZ.toFixed(1);
        }

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initBoids();
        });

        animate();
    </script>
</body>
</html>
