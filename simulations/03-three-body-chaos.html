<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Body Problem - Chaotic Orbits</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(to bottom, #1a0033, #330066);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
            text-align: center;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            color: #cccccc;
            line-height: 1.6;
        }

        .container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(255, 0, 255, 0.3);
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #330066, #000000);
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.2) inset;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-width: 900px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 0, 255, 0.3);
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #ff00ff;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        input[type="checkbox"] {
            margin-right: 8px;
        }

        button {
            background: linear-gradient(45deg, #ff00ff, #ff00aa);
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s;
            margin: 5px;
            width: calc(50% - 10px);
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button.preset {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            width: 100%;
            margin: 3px 0;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: rgba(255, 0, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3em;
            color: #ff00ff;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.85em;
            color: #cccccc;
        }

        .warning {
            background: rgba(255, 100, 100, 0.2);
            color: #ff6666;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .warning.active {
            display: block;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .presets-grid {
            display: grid;
            gap: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>‚öõÔ∏è Three-Body Chaos</h1>
    <div class="description">
        <p>
            <strong>The Three-Body Problem</strong> - One of physics' most famous unsolved problems. Unlike two-body systems
            which have stable, predictable orbits, three bodies create chaotic dynamics with extreme sensitivity to initial
            conditions. Watch the famous Figure-8 solution, explore Lagrange triangular configurations, or witness
            how tiny perturbations (< 0.001%) lead to completely different outcomes. Demonstrates the butterfly effect in celestial mechanics.
        </p>
    </div>

    <div class="container">
        <canvas id="canvas" width="900" height="900"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Time Scale: <span id="timeScaleValue">1.0</span>x</label>
                <input type="range" id="timeScale" min="0.1" max="5" step="0.1" value="1">

                <label>Trail Length: <span id="trailLengthValue">300</span></label>
                <input type="range" id="trailLength" min="50" max="1000" step="50" value="300">

                <label>Perturbation: <span id="perturbValue">0.00</span>%</label>
                <input type="range" id="perturbation" min="0" max="5" step="0.1" value="0">
            </div>

            <div class="control-group">
                <label><input type="checkbox" id="showTrails" checked> Show Trails</label>
                <label><input type="checkbox" id="showVelocities"> Show Velocities</label>
                <label><input type="checkbox" id="showPoincare"> Poincar√© Section</label>
                <label><input type="checkbox" id="fadeTrails" checked> Fade Trails</label>
            </div>

            <div class="control-group">
                <button id="pauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>

                <div class="presets-grid">
                    <button class="preset" id="figure8">Figure-8 Solution</button>
                    <button class="preset" id="lagrange">Lagrange Triangle</button>
                    <button class="preset" id="butterfly">Butterfly</button>
                    <button class="preset" id="random">Random Chaos</button>
                    <button class="preset" id="pythagorean">Pythagorean</button>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="fps">60</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="simTime">0</div>
                <div class="stat-label">Time</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="energy">0</div>
                <div class="stat-label">Energy</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="energyError">0.0</div>
                <div class="stat-label">Energy Drift %</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="minDistance">‚àû</div>
                <div class="stat-label">Min Distance</div>
            </div>
        </div>

        <div class="warning" id="warning"></div>

        <div class="info-panel" id="infoPanel">
            <strong>Current Configuration:</strong> Select a preset to begin
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Physics constants
        const G = 100;
        const SOFTENING = 0.5;
        const DT = 0.0008;
        const COLLISION_THRESHOLD = 15;
        const ESCAPE_THRESHOLD = 600;

        // Simulation state
        let bodies = [];
        let poincarePoints = [];
        let paused = false;
        let timeScale = 1.0;
        let trailLength = 300;
        let showTrails = true;
        let showVelocities = false;
        let showPoincare = false;
        let fadeTrails = true;
        let perturbation = 0;
        let simTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let fps = 60;
        let initialEnergy = 0;
        let currentConfig = '';
        let escaped = false;
        let collided = false;

        const bodyColors = ['#ff00ff', '#00ffff', '#ffff00'];

        class Body {
            constructor(mass, radius, color, x, y, vx, vy) {
                this.mass = mass;
                this.radius = radius;
                this.color = color;
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.ax = 0;
                this.ay = 0;
                this.trail = [];
            }

            addTrailPoint() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > trailLength) {
                    this.trail.shift();
                }
            }

            draw() {
                const screenX = canvas.width / 2 + this.x;
                const screenY = canvas.height / 2 + this.y;

                // Draw trail
                if (showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;

                    for (let i = 1; i < this.trail.length; i++) {
                        if (fadeTrails) {
                            const alpha = i / this.trail.length;
                            ctx.globalAlpha = alpha * 0.7;
                        }

                        ctx.beginPath();
                        ctx.moveTo(
                            canvas.width / 2 + this.trail[i - 1].x,
                            canvas.height / 2 + this.trail[i - 1].y
                        );
                        ctx.lineTo(
                            canvas.width / 2 + this.trail[i].x,
                            canvas.height / 2 + this.trail[i].y
                        );
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }

                // Draw velocity vector
                if (showVelocities) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(screenX + this.vx * 10, screenY + this.vy * 10);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }

                // Draw glow
                const glowRadius = this.radius;
                for (let i = 2; i >= 0; i--) {
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowRadius * (i + 1));
                    gradient.addColorStop(0, this.color + 'ff');
                    gradient.addColorStop(0.7, this.color + '44');
                    gradient.addColorStop(1, this.color + '00');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, glowRadius * (i + 1), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(screenX, screenY, glowRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }

            computeAcceleration(bodies) {
                this.ax = 0;
                this.ay = 0;

                for (let other of bodies) {
                    if (other === this) continue;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const r2 = dx * dx + dy * dy + SOFTENING * SOFTENING;
                    const r = Math.sqrt(r2);
                    const f = G * other.mass / r2;

                    this.ax += f * dx / r;
                    this.ay += f * dy / r;
                }
            }

            updateVelocityVerlet(dt, bodies) {
                const vx_half = this.vx + this.ax * dt / 2;
                const vy_half = this.vy + this.ay * dt / 2;

                this.x += vx_half * dt;
                this.y += vy_half * dt;

                this.computeAcceleration(bodies);

                this.vx = vx_half + this.ax * dt / 2;
                this.vy = vy_half + this.ay * dt / 2;
            }
        }

        function applyPerturbation(value) {
            return value * (1 + (Math.random() - 0.5) * perturbation / 100);
        }

        function initFigure8() {
            // Famous Figure-8 solution discovered by Cris Moore (1993)
            bodies = [];
            currentConfig = 'Figure-8 Solution';

            const x1 = -0.97000436;
            const y1 = 0.24308753;
            const vx3 = -0.93240737;
            const vy3 = -0.86473146;

            bodies.push(new Body(1, 12, bodyColors[0],
                applyPerturbation(x1 * 100), applyPerturbation(y1 * 100),
                applyPerturbation(vx3 / 2), applyPerturbation(vy3 / 2)
            ));

            bodies.push(new Body(1, 12, bodyColors[1],
                applyPerturbation(-x1 * 100), applyPerturbation(-y1 * 100),
                applyPerturbation(vx3 / 2), applyPerturbation(vy3 / 2)
            ));

            bodies.push(new Body(1, 12, bodyColors[2],
                0, 0,
                applyPerturbation(-vx3), applyPerturbation(-vy3)
            ));
        }

        function initLagrange() {
            // Lagrange equilateral triangle solution
            bodies = [];
            currentConfig = 'Lagrange Triangular Configuration';

            const r = 150;
            const angle = Math.PI * 2 / 3;
            const v = Math.sqrt(G / r);

            for (let i = 0; i < 3; i++) {
                const a = angle * i;
                const x = Math.cos(a) * r;
                const y = Math.sin(a) * r;
                const vx = -Math.sin(a) * v;
                const vy = Math.cos(a) * v;

                bodies.push(new Body(1, 12, bodyColors[i],
                    applyPerturbation(x), applyPerturbation(y),
                    applyPerturbation(vx), applyPerturbation(vy)
                ));
            }
        }

        function initButterfly() {
            // Butterfly I configuration
            bodies = [];
            currentConfig = 'Butterfly Configuration';

            bodies.push(new Body(1, 12, bodyColors[0],
                applyPerturbation(-100), 0,
                applyPerturbation(0.30689), applyPerturbation(0.12551)
            ));

            bodies.push(new Body(1, 12, bodyColors[1],
                applyPerturbation(100), 0,
                applyPerturbation(0.30689), applyPerturbation(0.12551)
            ));

            bodies.push(new Body(1, 12, bodyColors[2],
                0, 0,
                applyPerturbation(-0.61378), applyPerturbation(-0.25102)
            ));
        }

        function initPythagorean() {
            // Pythagorean three-body problem (3-4-5 mass ratio)
            bodies = [];
            currentConfig = 'Pythagorean (3:4:5 masses)';

            bodies.push(new Body(3, 10, bodyColors[0],
                applyPerturbation(100), 0,
                0, applyPerturbation(0.5)
            ));

            bodies.push(new Body(4, 12, bodyColors[1],
                applyPerturbation(-100), 0,
                0, applyPerturbation(-0.3)
            ));

            bodies.push(new Body(5, 14, bodyColors[2],
                0, applyPerturbation(-80),
                applyPerturbation(0.4), 0
            ));
        }

        function initRandom() {
            // Random chaotic configuration
            bodies = [];
            currentConfig = 'Random Chaos';

            for (let i = 0; i < 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 50 + Math.random() * 150;
                const speed = 0.3 + Math.random() * 0.7;

                bodies.push(new Body(
                    0.8 + Math.random() * 0.4,
                    12,
                    bodyColors[i],
                    Math.cos(angle) * r,
                    Math.sin(angle) * r,
                    Math.sin(angle) * speed,
                    -Math.cos(angle) * speed
                ));
            }
        }

        function resetSimulation(initFunc) {
            simTime = 0;
            frameCount = 0;
            poincarePoints = [];
            escaped = false;
            collided = false;
            document.getElementById('warning').classList.remove('active');

            initFunc();

            // Clear trails
            for (let body of bodies) {
                body.trail = [];
            }

            // Compute initial energy
            initialEnergy = computeEnergy();

            // Update info panel
            document.getElementById('infoPanel').innerHTML = `
                <strong>Current Configuration:</strong> ${currentConfig}<br>
                <span style="font-size: 0.9em; color: #aaa;">
                ${perturbation > 0 ? `‚ö†Ô∏è Initial conditions perturbed by ${perturbation}%` : 'Using exact initial conditions'}
                </span>
            `;
        }

        function computeEnergy() {
            let totalEnergy = 0;

            for (let body of bodies) {
                const v2 = body.vx * body.vx + body.vy * body.vy;
                totalEnergy += 0.5 * body.mass * v2;
            }

            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const r = Math.sqrt(dx * dx + dy * dy + SOFTENING * SOFTENING);
                    totalEnergy -= G * bodies[i].mass * bodies[j].mass / r;
                }
            }

            return totalEnergy;
        }

        function checkCollisionAndEscape() {
            let minDist = Infinity;

            // Check collisions
            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    minDist = Math.min(minDist, dist);

                    if (dist < COLLISION_THRESHOLD && !collided) {
                        collided = true;
                        const warning = document.getElementById('warning');
                        warning.textContent = 'üí• COLLISION DETECTED!';
                        warning.classList.add('active');
                    }
                }

                // Check escape
                const r = Math.sqrt(bodies[i].x * bodies[i].x + bodies[i].y * bodies[i].y);
                if (r > ESCAPE_THRESHOLD && !escaped) {
                    escaped = true;
                    const warning = document.getElementById('warning');
                    warning.textContent = 'üöÄ BODY ESCAPED! System unstable.';
                    warning.classList.add('active');
                }
            }

            return minDist;
        }

        function drawPoincare() {
            if (!showPoincare || poincarePoints.length === 0) return;

            ctx.fillStyle = '#ffffff';
            for (let point of poincarePoints) {
                const screenX = canvas.width / 2 + point.x;
                const screenY = canvas.height / 2 + point.y;

                ctx.beginPath();
                ctx.arc(screenX, screenY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function update() {
            if (paused || bodies.length === 0) return;

            const dt = DT * timeScale;

            for (let body of bodies) {
                body.computeAcceleration(bodies);
            }

            for (let body of bodies) {
                body.updateVelocityVerlet(dt, bodies);

                if (frameCount % 2 === 0) {
                    body.addTrailPoint();
                }
            }

            // Poincar√© section (when y crosses zero with positive velocity)
            if (showPoincare && bodies[0].y * (bodies[0].y - bodies[0].vy * dt) < 0 && bodies[0].vy > 0) {
                poincarePoints.push({ x: bodies[0].x, y: bodies[0].vx * 50 });
                if (poincarePoints.length > 1000) poincarePoints.shift();
            }

            simTime += dt;
        }

        function draw() {
            ctx.fillStyle = fadeTrails ? 'rgba(26, 0, 51, 0.15)' : 'rgba(26, 0, 51, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawPoincare();

            for (let body of bodies) {
                body.draw();
            }

            frameCount++;
            if (frameCount % 30 === 0) {
                const now = Date.now();
                fps = Math.round(30000 / (now - lastFpsUpdate));
                lastFpsUpdate = now;

                const energy = computeEnergy();
                const energyDrift = initialEnergy !== 0 ? ((energy - initialEnergy) / initialEnergy * 100) : 0;
                const minDist = checkCollisionAndEscape();

                document.getElementById('fps').textContent = fps;
                document.getElementById('simTime').textContent = simTime.toFixed(1);
                document.getElementById('energy').textContent = energy.toFixed(0);
                document.getElementById('energyError').textContent = Math.abs(energyDrift).toFixed(3);
                document.getElementById('minDistance').textContent = minDist !== Infinity ? minDist.toFixed(1) : '‚àû';
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('timeScale').addEventListener('input', (e) => {
            timeScale = parseFloat(e.target.value);
            document.getElementById('timeScaleValue').textContent = timeScale.toFixed(1);
        });

        document.getElementById('trailLength').addEventListener('input', (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailLengthValue').textContent = trailLength;
        });

        document.getElementById('perturbation').addEventListener('input', (e) => {
            perturbation = parseFloat(e.target.value);
            document.getElementById('perturbValue').textContent = perturbation.toFixed(2);
        });

        document.getElementById('showTrails').addEventListener('change', (e) => {
            showTrails = e.target.checked;
        });

        document.getElementById('showVelocities').addEventListener('change', (e) => {
            showVelocities = e.target.checked;
        });

        document.getElementById('showPoincare').addEventListener('change', (e) => {
            showPoincare = e.target.checked;
            if (showPoincare) poincarePoints = [];
        });

        document.getElementById('fadeTrails').addEventListener('change', (e) => {
            fadeTrails = e.target.checked;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (currentConfig.includes('Figure-8')) resetSimulation(initFigure8);
            else if (currentConfig.includes('Lagrange')) resetSimulation(initLagrange);
            else if (currentConfig.includes('Butterfly')) resetSimulation(initButterfly);
            else if (currentConfig.includes('Pythagorean')) resetSimulation(initPythagorean);
            else resetSimulation(initRandom);
        });

        // Preset buttons
        document.getElementById('figure8').addEventListener('click', () => resetSimulation(initFigure8));
        document.getElementById('lagrange').addEventListener('click', () => resetSimulation(initLagrange));
        document.getElementById('butterfly').addEventListener('click', () => resetSimulation(initButterfly));
        document.getElementById('pythagorean').addEventListener('click', () => resetSimulation(initPythagorean));
        document.getElementById('random').addEventListener('click', () => resetSimulation(initRandom));

        // Start with Figure-8
        resetSimulation(initFigure8);
        animate();
    </script>
</body>
</html>
