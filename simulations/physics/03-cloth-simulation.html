<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloth Simulation - Fabric Physics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .description {
            text-align: center;
            max-width: 800px;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.9;
        }

        .equation {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        canvas {
            background: linear-gradient(180deg, #87ceeb 0%, #f0f8ff 100%);
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            cursor: crosshair;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            max-width: 1200px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            background: #667eea;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .button-group {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1;
            justify-content: center;
            flex-wrap: wrap;
        }

        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            grid-column: 1 / -1;
            text-align: center;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Cloth Simulation - Fabric Physics</h1>

    <div class="description">
        <p>
            <strong>Advanced Constraint-Based Physics:</strong> A grid of masses connected by structural, shear, and bend springs
            creates realistic fabric behavior. Includes wind forces, tearing mechanics, and collision detection.
        </p>
        <div class="equation">
            Structural Springs (±) • Shear Springs (×) • Bend Springs (=) | Tear when tension > threshold
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>Wind Strength: <span id="wind-value">0.5</span></label>
            <input type="range" id="wind" min="0" max="2.0" value="0.5" step="0.1">
        </div>
        <div class="control-group">
            <label>Gravity: <span id="gravity-value">0.8</span> m/s²</label>
            <input type="range" id="gravity" min="0" max="2.0" value="0.8" step="0.1">
        </div>
        <div class="control-group">
            <label>Spring Stiffness: <span id="stiffness-value">0.8</span></label>
            <input type="range" id="stiffness" min="0.1" max="1.5" value="0.8" step="0.1">
        </div>
        <div class="control-group">
            <label>Damping: <span id="damping-value">0.01</span></label>
            <input type="range" id="damping" min="0" max="0.1" value="0.01" step="0.01">
        </div>
        <div class="control-group">
            <label>Tear Threshold: <span id="tear-value">50</span></label>
            <input type="range" id="tear" min="20" max="100" value="50" step="5">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-value">1.0</span>x</label>
            <input type="range" id="speed" min="0.1" max="2.0" value="1.0" step="0.1">
        </div>

        <div class="info">
            <strong>Interaction:</strong> Click to pin/unpin points • Drag to tear cloth • Wind adds dynamic motion
        </div>

        <div class="button-group">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset Cloth</button>
            <button id="windBtn">Toggle Wind</button>
            <button id="sphereBtn">Toggle Sphere</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 700;

        // System parameters
        let windStrength = 0.5;
        let gravity = 0.8;
        let stiffness = 0.8;
        let damping = 0.01;
        let tearThreshold = 50;
        let speed = 1.0;
        let windEnabled = true;
        let sphereEnabled = true;

        // Simulation state
        let paused = false;
        let points = [];
        let constraints = [];
        let time = 0;

        // Cloth dimensions
        const cols = 30;
        const rows = 25;
        const spacing = 20;
        const startX = (canvas.width - (cols - 1) * spacing) / 2;
        const startY = 50;

        // Sphere for collision
        const sphere = {
            x: canvas.width / 2,
            y: canvas.height / 2 + 100,
            radius: 80
        };

        // Point class
        class Point {
            constructor(x, y, pinned = false) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.pinned = pinned;
                this.mass = 1;
            }

            update(dt) {
                if (this.pinned) return;

                // Verlet integration
                const vx = (this.x - this.oldX) * (1 - damping);
                const vy = (this.y - this.oldY) * (1 - damping);

                this.oldX = this.x;
                this.oldY = this.y;

                // Apply gravity
                this.y += gravity * dt * dt;

                // Apply velocity
                this.x += vx;
                this.y += vy;

                // Wind force (turbulent)
                if (windEnabled) {
                    const windNoise = Math.sin(time * 0.01 + this.x * 0.01) * Math.cos(time * 0.015 + this.y * 0.01);
                    this.x += windStrength * windNoise * dt;
                }

                // Floor collision
                if (this.y > canvas.height - 10) {
                    this.y = canvas.height - 10;
                    this.oldY = this.y + vy * 0.5; // Some bounce
                }

                // Wall collision
                if (this.x < 0) {
                    this.x = 0;
                    this.oldX = this.x - vx * 0.5;
                } else if (this.x > canvas.width) {
                    this.x = canvas.width;
                    this.oldX = this.x - vx * 0.5;
                }

                // Sphere collision
                if (sphereEnabled) {
                    const dx = this.x - sphere.x;
                    const dy = this.y - sphere.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < sphere.radius) {
                        const angle = Math.atan2(dy, dx);
                        this.x = sphere.x + Math.cos(angle) * sphere.radius;
                        this.y = sphere.y + Math.sin(angle) * sphere.radius;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.pinned ? '#ff6b6b' : '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.pinned ? 4 : 2, 0, Math.PI * 2);
                ctx.fill();
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < 10;
            }
        }

        // Constraint class
        class Constraint {
            constructor(p1, p2, restLength, strength = 1) {
                this.p1 = p1;
                this.p2 = p2;
                this.restLength = restLength;
                this.strength = strength;
                this.active = true;
            }

            solve() {
                if (!this.active) return;

                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Tear if over threshold
                if (dist > tearThreshold) {
                    this.active = false;
                    return;
                }

                const diff = (this.restLength - dist) / dist;
                const offsetX = dx * diff * 0.5 * this.strength * stiffness;
                const offsetY = dy * diff * 0.5 * this.strength * stiffness;

                if (!this.p1.pinned) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }

            draw() {
                if (!this.active) return;

                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const tension = Math.abs(dist - this.restLength);

                // Color by tension
                const intensity = Math.min(tension / 20, 1);
                const hue = 200 - intensity * 100; // Blue to red
                ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.6)`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
            }
        }

        // Initialize cloth
        function initCloth() {
            points = [];
            constraints = [];
            time = 0;

            // Create points
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const px = startX + x * spacing;
                    const py = startY + y * spacing;
                    const pinned = y === 0 && (x === 0 || x === cols - 1 || x === Math.floor(cols / 2));
                    points.push(new Point(px, py, pinned));
                }
            }

            // Create structural constraints (horizontal and vertical)
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = y * cols + x;

                    // Horizontal
                    if (x < cols - 1) {
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        constraints.push(new Constraint(p1, p2, spacing, 1));
                    }

                    // Vertical
                    if (y < rows - 1) {
                        const p1 = points[i];
                        const p2 = points[i + cols];
                        constraints.push(new Constraint(p1, p2, spacing, 1));
                    }
                }
            }

            // Create shear constraints (diagonal)
            for (let y = 0; y < rows - 1; y++) {
                for (let x = 0; x < cols - 1; x++) {
                    const i = y * cols + x;

                    const p1 = points[i];
                    const p2 = points[i + cols + 1];
                    const p3 = points[i + 1];
                    const p4 = points[i + cols];

                    const diagDist = Math.sqrt(2) * spacing;
                    constraints.push(new Constraint(p1, p2, diagDist, 0.5));
                    constraints.push(new Constraint(p3, p4, diagDist, 0.5));
                }
            }

            // Create bend constraints (skip one)
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols - 2; x++) {
                    const i = y * cols + x;
                    const p1 = points[i];
                    const p2 = points[i + 2];
                    constraints.push(new Constraint(p1, p2, spacing * 2, 0.3));
                }
            }

            for (let y = 0; y < rows - 2; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = y * cols + x;
                    const p1 = points[i];
                    const p2 = points[i + cols * 2];
                    constraints.push(new Constraint(p1, p2, spacing * 2, 0.3));
                }
            }
        }

        // Mouse interaction
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            mouseDown = true;
            lastMouseX = x;
            lastMouseY = y;

            // Toggle pin
            for (const point of points) {
                if (point.contains(x, y)) {
                    point.pinned = !point.pinned;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Tear constraints along drag path
                for (const constraint of constraints) {
                    if (!constraint.active) continue;

                    // Check if drag path intersects constraint
                    const dist = distanceToSegment(
                        x, y, lastMouseX, lastMouseY,
                        constraint.p1.x, constraint.p1.y,
                        constraint.p2.x, constraint.p2.y
                    );

                    if (dist < 15) {
                        constraint.active = false;
                    }
                }

                lastMouseX = x;
                lastMouseY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        // Helper: distance from point to line segment
        function distanceToSegment(px, py, lx1, ly1, lx2, ly2) {
            const midX = (lx1 + lx2) / 2;
            const midY = (ly1 + ly2) / 2;
            const dx = px - midX;
            const dy = py - midY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Animation loop
        function animate() {
            // Sky background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87ceeb');
            gradient.addColorStop(1, '#f0f8ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sphere
            if (sphereEnabled) {
                ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                ctx.beginPath();
                ctx.arc(sphere.x, sphere.y, sphere.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(100, 100, 100, 0.8)';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            if (!paused) {
                const dt = 1.0 * speed;
                time += dt;

                // Update points
                for (const point of points) {
                    point.update(dt);
                }

                // Solve constraints (multiple iterations for stability)
                const iterations = 3;
                for (let i = 0; i < iterations; i++) {
                    for (const constraint of constraints) {
                        constraint.solve();
                    }
                }
            }

            // Draw constraints (cloth fabric)
            for (const constraint of constraints) {
                constraint.draw();
            }

            // Draw points
            for (const point of points) {
                point.draw();
            }

            // Draw wind indicator
            if (windEnabled) {
                const windViz = Math.sin(time * 0.01) * windStrength * 30;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, 30);
                ctx.lineTo(50 + windViz, 30);
                ctx.stroke();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px sans-serif';
                ctx.fillText('Wind →', 60 + windViz, 35);
            }

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('wind').addEventListener('input', (e) => {
            windStrength = parseFloat(e.target.value);
            document.getElementById('wind-value').textContent = windStrength.toFixed(1);
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravity-value').textContent = gravity.toFixed(1);
        });

        document.getElementById('stiffness').addEventListener('input', (e) => {
            stiffness = parseFloat(e.target.value);
            document.getElementById('stiffness-value').textContent = stiffness.toFixed(1);
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            damping = parseFloat(e.target.value);
            document.getElementById('damping-value').textContent = damping.toFixed(2);
        });

        document.getElementById('tear').addEventListener('input', (e) => {
            tearThreshold = parseFloat(e.target.value);
            document.getElementById('tear-value').textContent = tearThreshold;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = speed.toFixed(1);
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initCloth();
        });

        document.getElementById('windBtn').addEventListener('click', () => {
            windEnabled = !windEnabled;
            document.getElementById('windBtn').textContent =
                windEnabled ? 'Disable Wind' : 'Enable Wind';
        });

        document.getElementById('sphereBtn').addEventListener('click', () => {
            sphereEnabled = !sphereEnabled;
            document.getElementById('sphereBtn').textContent =
                sphereEnabled ? 'Hide Sphere' : 'Show Sphere';
        });

        // Initialize and start
        initCloth();
        animate();
    </script>
</body>
</html>