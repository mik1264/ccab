<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Body Physics - Deformable Bodies</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #141E30 0%, #243B55 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .description {
            text-align: center;
            max-width: 800px;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.9;
        }

        .equation {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }

        canvas {
            background: #1a1a2e;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            cursor: crosshair;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            max-width: 1200px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            background: #667eea;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button.active {
            background: #764ba2;
        }

        .button-group {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1;
            justify-content: center;
            flex-wrap: wrap;
        }

        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            grid-column: 1 / -1;
            text-align: center;
            font-size: 14px;
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            opacity: 0.7;
            font-size: 12px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <h1>Soft Body Physics - Deformable Bodies</h1>

    <div class="description">
        <p>
            <strong>Pressure-Based Deformation:</strong> Gas-filled soft bodies using spring constraints and pressure simulation.
            Click to poke and watch them bounce, wobble, and deform realistically. Multiple bodies interact with gravity and collisions.
        </p>
        <div class="equation">
            PV = nRT (Ideal Gas) | F_pressure = (P_target - P_current) × A_surface
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>Pressure: <span id="pressure-value">500</span></label>
            <input type="range" id="pressure" min="100" max="1500" value="500" step="50">
        </div>
        <div class="control-group">
            <label>Spring Stiffness: <span id="stiffness-value">0.5</span></label>
            <input type="range" id="stiffness" min="0.1" max="1.5" value="0.5" step="0.1">
        </div>
        <div class="control-group">
            <label>Friction: <span id="friction-value">0.02</span></label>
            <input type="range" id="friction" min="0" max="0.1" value="0.02" step="0.01">
        </div>
        <div class="control-group">
            <label>Gravity: <span id="gravity-value">0.5</span> m/s²</label>
            <input type="range" id="gravity" min="0" max="2.0" value="0.5" step="0.1">
        </div>
        <div class="control-group">
            <label>Bounciness: <span id="bounce-value">0.7</span></label>
            <input type="range" id="bounce" min="0" max="1.0" value="0.7" step="0.1">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-value">1.0</span>x</label>
            <input type="range" id="speed" min="0.1" max="2.0" value="1.0" step="0.1">
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">Total Energy</span>
                <span class="stat-value" id="energy">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Avg Pressure</span>
                <span class="stat-value" id="avg-pressure">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Collisions</span>
                <span class="stat-value" id="collisions">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Interaction:</strong> Click to poke bodies • Drag to fling • Watch pressure changes with color
        </div>

        <div class="button-group">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
            <button id="addBtn">Add Body</button>
            <button id="removeBtn">Remove Body</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 700;

        // System parameters
        let targetPressure = 500;
        let springStiffness = 0.5;
        let friction = 0.02;
        let gravity = 0.5;
        let bounciness = 0.7;
        let speed = 1.0;

        // Simulation state
        let paused = false;
        let softBodies = [];
        let collisionCount = 0;

        // Ground
        const ground = canvas.height - 50;

        // Soft Body class
        class SoftBody {
            constructor(x, y, radius, segments = 20) {
                this.centerX = x;
                this.centerY = y;
                this.radius = radius;
                this.segments = segments;
                this.points = [];
                this.constraints = [];
                this.targetPressure = targetPressure;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;

                // Create points in circle
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    this.points.push({
                        x: px,
                        y: py,
                        oldX: px,
                        oldY: py,
                        mass: 1
                    });
                }

                // Create constraints (spring structure)
                for (let i = 0; i < segments; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[(i + 1) % segments];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    this.constraints.push({
                        p1: p1,
                        p2: p2,
                        restLength: dist,
                        type: 'edge'
                    });
                }

                // Add cross constraints for structure
                const center = { x: x, y: y, oldX: x, oldY: y, mass: 1 };
                this.points.push(center);

                for (let i = 0; i < segments; i++) {
                    const p = this.points[i];
                    const dx = center.x - p.x;
                    const dy = center.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    this.constraints.push({
                        p1: p,
                        p2: center,
                        restLength: dist,
                        type: 'spoke'
                    });
                }
            }

            update(dt) {
                // Update points with Verlet integration
                for (const point of this.points) {
                    const vx = (point.x - point.oldX) * (1 - friction);
                    const vy = (point.y - point.oldY) * (1 - friction);

                    point.oldX = point.x;
                    point.oldY = point.y;

                    // Gravity
                    point.y += gravity * dt * dt;

                    // Apply velocity
                    point.x += vx;
                    point.y += vy;

                    // Ground collision
                    if (point.y > ground) {
                        point.y = ground;
                        point.oldY = point.y + (point.y - point.oldY) * bounciness;
                        collisionCount++;
                    }

                    // Wall collision
                    if (point.x < 0) {
                        point.x = 0;
                        point.oldX = point.x - (point.x - point.oldX) * bounciness;
                    } else if (point.x > canvas.width) {
                        point.x = canvas.width;
                        point.oldX = point.x - (point.x - point.oldX) * bounciness;
                    }
                }

                // Apply pressure
                this.applyPressure();

                // Solve constraints
                const iterations = 3;
                for (let i = 0; i < iterations; i++) {
                    for (const constraint of this.constraints) {
                        this.solveConstraint(constraint);
                    }
                }
            }

            applyPressure() {
                // Calculate current area (approximate)
                let area = 0;
                const center = this.points[this.points.length - 1];

                for (let i = 0; i < this.segments; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[(i + 1) % this.segments];

                    // Triangle area
                    const triArea = Math.abs(
                        (p1.x * (p2.y - center.y) +
                         p2.x * (center.y - p1.y) +
                         center.x * (p1.y - p2.y)) / 2
                    );
                    area += triArea;
                }

                // Target area based on pressure
                const targetArea = Math.PI * this.radius * this.radius;
                const pressureDiff = (targetArea - area) / targetArea;

                // Apply pressure forces to edge points
                for (let i = 0; i < this.segments; i++) {
                    const point = this.points[i];
                    const dx = point.x - center.x;
                    const dy = point.y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const force = pressureDiff * this.targetPressure * 0.001;
                        point.x += (dx / dist) * force;
                        point.y += (dy / dist) * force;
                    }
                }
            }

            solveConstraint(constraint) {
                const { p1, p2, restLength } = constraint;
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return;

                const diff = (restLength - dist) / dist;
                const strength = constraint.type === 'edge' ? springStiffness : springStiffness * 0.5;
                const offsetX = dx * diff * 0.5 * strength;
                const offsetY = dy * diff * 0.5 * strength;

                p1.x -= offsetX;
                p1.y -= offsetY;
                p2.x += offsetX;
                p2.y += offsetY;
            }

            draw() {
                // Calculate current pressure for color
                let area = 0;
                const center = this.points[this.points.length - 1];

                for (let i = 0; i < this.segments; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[(i + 1) % this.segments];
                    const triArea = Math.abs(
                        (p1.x * (p2.y - center.y) +
                         p2.x * (center.y - p1.y) +
                         center.x * (p1.y - p2.y)) / 2
                    );
                    area += triArea;
                }

                const targetArea = Math.PI * this.radius * this.radius;
                const pressureRatio = area / targetArea;
                const alpha = 0.3 + Math.abs(1 - pressureRatio) * 0.5;

                // Draw filled body
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                ctx.beginPath();
                for (let i = 0; i < this.segments; i++) {
                    const point = this.points[i];
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.closePath();
                ctx.fill();

                // Draw constraints
                ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.lineWidth = 1;

                for (const constraint of this.constraints) {
                    ctx.beginPath();
                    ctx.moveTo(constraint.p1.x, constraint.p1.y);
                    ctx.lineTo(constraint.p2.x, constraint.p2.y);
                    ctx.stroke();
                }

                // Draw edge
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i < this.segments; i++) {
                    const point = this.points[i];
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.closePath();
                ctx.stroke();

                // Draw points
                for (let i = 0; i < this.segments; i++) {
                    const point = this.points[i];
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            poke(x, y, force) {
                const center = this.points[this.points.length - 1];
                const dx = center.x - x;
                const dy = center.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.radius * 1.5) {
                    for (const point of this.points) {
                        const pdx = point.x - x;
                        const pdy = point.y - y;
                        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);

                        if (pdist < this.radius * 1.5) {
                            const strength = (1 - pdist / (this.radius * 1.5)) * force;
                            point.x += (pdx / pdist) * strength;
                            point.y += (pdy / pdist) * strength;
                        }
                    }
                }
            }

            getCurrentPressure() {
                let area = 0;
                const center = this.points[this.points.length - 1];

                for (let i = 0; i < this.segments; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[(i + 1) % this.segments];
                    const triArea = Math.abs(
                        (p1.x * (p2.y - center.y) +
                         p2.x * (center.y - p1.y) +
                         center.x * (p1.y - p2.y)) / 2
                    );
                    area += triArea;
                }

                return area;
            }
        }

        // Initialize bodies
        function initBodies() {
            softBodies = [];
            softBodies.push(new SoftBody(300, 200, 80, 24));
            softBodies.push(new SoftBody(600, 150, 60, 20));
            softBodies.push(new SoftBody(900, 250, 70, 22));
            collisionCount = 0;
        }

        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            mouseDown = true;

            // Poke bodies
            for (const body of softBodies) {
                body.poke(mouseX, mouseY, 20);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (mouseDown) {
                for (const body of softBodies) {
                    body.poke(mouseX, mouseY, 10);
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        // Animation loop
        function animate() {
            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = '#2d3436';
            ctx.fillRect(0, ground, canvas.width, canvas.height - ground);

            if (!paused) {
                const dt = 1.0 * speed;
                collisionCount = 0;

                // Update all bodies
                for (const body of softBodies) {
                    body.targetPressure = targetPressure;
                    body.update(dt);
                }

                // Inter-body collision (simple)
                for (let i = 0; i < softBodies.length; i++) {
                    for (let j = i + 1; j < softBodies.length; j++) {
                        const b1 = softBodies[i];
                        const b2 = softBodies[j];

                        // Check all points
                        for (const p1 of b1.points) {
                            for (const p2 of b2.points) {
                                const dx = p2.x - p1.x;
                                const dy = p2.y - p1.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const minDist = 15;

                                if (dist < minDist && dist > 0) {
                                    const overlap = minDist - dist;
                                    const moveX = (dx / dist) * overlap * 0.5;
                                    const moveY = (dy / dist) * overlap * 0.5;

                                    p1.x -= moveX;
                                    p1.y -= moveY;
                                    p2.x += moveX;
                                    p2.y += moveY;
                                }
                            }
                        }
                    }
                }

                // Calculate stats
                let totalEnergy = 0;
                let avgPressure = 0;

                for (const body of softBodies) {
                    // Kinetic energy (approximate)
                    for (const point of body.points) {
                        const vx = point.x - point.oldX;
                        const vy = point.y - point.oldY;
                        totalEnergy += 0.5 * point.mass * (vx * vx + vy * vy);
                    }

                    avgPressure += body.getCurrentPressure();
                }

                avgPressure /= softBodies.length;

                document.getElementById('energy').textContent = totalEnergy.toFixed(1);
                document.getElementById('avg-pressure').textContent = avgPressure.toFixed(0);
                document.getElementById('collisions').textContent = collisionCount;
            }

            // Draw all bodies
            for (const body of softBodies) {
                body.draw();
            }

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('pressure').addEventListener('input', (e) => {
            targetPressure = parseFloat(e.target.value);
            document.getElementById('pressure-value').textContent = targetPressure;
        });

        document.getElementById('stiffness').addEventListener('input', (e) => {
            springStiffness = parseFloat(e.target.value);
            document.getElementById('stiffness-value').textContent = springStiffness.toFixed(1);
        });

        document.getElementById('friction').addEventListener('input', (e) => {
            friction = parseFloat(e.target.value);
            document.getElementById('friction-value').textContent = friction.toFixed(2);
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravity-value').textContent = gravity.toFixed(1);
        });

        document.getElementById('bounce').addEventListener('input', (e) => {
            bounciness = parseFloat(e.target.value);
            document.getElementById('bounce-value').textContent = bounciness.toFixed(1);
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = speed.toFixed(1);
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initBodies();
        });

        document.getElementById('addBtn').addEventListener('click', () => {
            const x = Math.random() * (canvas.width - 200) + 100;
            const y = Math.random() * 300 + 100;
            const radius = Math.random() * 40 + 50;
            const segments = Math.floor(Math.random() * 10) + 18;
            softBodies.push(new SoftBody(x, y, radius, segments));
        });

        document.getElementById('removeBtn').addEventListener('click', () => {
            if (softBodies.length > 1) {
                softBodies.pop();
            }
        });

        // Initialize and start
        initBodies();
        animate();
    </script>
</body>
</html>