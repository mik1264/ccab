<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verlet Integration Showcase</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #654ea3 0%, #eaafc8 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .description {
            text-align: center;
            max-width: 900px;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.95;
        }

        .equation {
            background: rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        canvas {
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            cursor: pointer;
        }

        .controls {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            max-width: 1200px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            background: #667eea;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button.active {
            background: #764ba2;
        }

        .scene-buttons {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1;
            justify-content: center;
            flex-wrap: wrap;
        }

        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            grid-column: 1 / -1;
            text-align: center;
            font-size: 14px;
        }

        .comparison {
            background: rgba(255, 200, 100, 0.2);
            padding: 15px;
            border-radius: 8px;
            grid-column: 1 / -1;
            text-align: center;
            font-size: 13px;
            border: 2px solid rgba(255, 200, 100, 0.4);
        }
    </style>
</head>
<body>
    <h1>Verlet Integration Showcase</h1>

    <div class="description">
        <p>
            <strong>Elegant Physics Through Simplicity:</strong> Verlet integration provides stable, energy-conserving simulations
            with minimal code. Explore rope bridges, ragdolls, pendulums, and Newton's cradle - all using the same elegant algorithm.
        </p>
        <div class="equation">
            Verlet: x(t+Δt) = 2x(t) - x(t-Δt) + a(t)Δt² | Energy conserving, no velocity storage needed!
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>Gravity: <span id="gravity-value">1.0</span> m/s²</label>
            <input type="range" id="gravity" min="0" max="3.0" value="1.0" step="0.1">
        </div>
        <div class="control-group">
            <label>Constraint Stiffness: <span id="stiffness-value">0.9</span></label>
            <input type="range" id="stiffness" min="0.1" max="1.0" value="0.9" step="0.1">
        </div>
        <div class="control-group">
            <label>Iterations: <span id="iterations-value">5</span></label>
            <input type="range" id="iterations" min="1" max="10" value="5" step="1">
        </div>
        <div class="control-group">
            <label>Friction: <span id="friction-value">0.99</span></label>
            <input type="range" id="friction" min="0.8" max="1.0" value="0.99" step="0.01">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-value">1.0</span>x</label>
            <input type="range" id="speed" min="0.1" max="2.0" value="1.0" step="0.1">
        </div>

        <div class="comparison">
            <strong>Verlet vs Euler Comparison:</strong> Watch energy conservation! Verlet maintains stable energy while Euler drifts.
        </div>

        <div class="info" id="scene-info">
            Click to apply impulses • Drag to interact • Watch stable, energy-conserving behavior
        </div>

        <div class="scene-buttons">
            <button id="scene-bridge" class="active">Rope Bridge</button>
            <button id="scene-ragdoll">Ragdoll</button>
            <button id="scene-chain">Ball Chain</button>
            <button id="scene-cradle">Newton's Cradle</button>
            <button id="scene-comparison">Euler vs Verlet</button>
        </div>

        <div class="button-group">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset Scene</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 650;

        // Physics parameters
        let gravity = 1.0;
        let stiffness = 0.9;
        let iterations = 5;
        let friction = 0.99;
        let speed = 1.0;
        let paused = false;

        let currentScene = 'bridge';
        let points = [];
        let sticks = [];

        // Point class (Verlet particle)
        class Point {
            constructor(x, y, pinned = false, mass = 1) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.pinned = pinned;
                this.mass = mass;
                this.radius = pinned ? 6 : 8;
            }

            update(dt) {
                if (this.pinned) return;

                // Verlet integration
                const vx = (this.x - this.oldX) * friction;
                const vy = (this.y - this.oldY) * friction;

                this.oldX = this.x;
                this.oldY = this.y;

                // Apply gravity
                this.y += gravity * dt * dt;

                // Apply velocity
                this.x += vx;
                this.y += vy;

                // Boundaries
                if (this.y > canvas.height - 20) {
                    this.y = canvas.height - 20;
                    this.oldY = this.y + vy * 0.8; // Some bounce
                }

                if (this.x < 10) {
                    this.x = 10;
                    this.oldX = this.x - vx * 0.8;
                } else if (this.x > canvas.width - 10) {
                    this.x = canvas.width - 10;
                    this.oldX = this.x - vx * 0.8;
                }
            }

            updateEuler(dt) {
                if (this.pinned) return;

                // Euler integration (for comparison)
                const vx = (this.x - this.oldX) * friction;
                const vy = (this.y - this.oldY) * friction;

                // Euler: directly update position with velocity
                this.x += vx + 0.5 * gravity * dt * dt;
                this.y += vy + gravity * dt * dt;

                // Note: Energy drift will be visible!
            }

            draw(color = '#4ecdc4') {
                ctx.fillStyle = this.pinned ? '#ff6b6b' : color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                if (!this.pinned) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            applyForce(fx, fy) {
                if (this.pinned) return;
                this.x += fx;
                this.y += fy;
            }
        }

        // Stick constraint (distance constraint)
        class Stick {
            constructor(p1, p2, length = null) {
                this.p1 = p1;
                this.p2 = p2;
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                this.length = length || Math.sqrt(dx * dx + dy * dy);
            }

            solve() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return;

                const diff = (this.length - dist) / dist;
                const offsetX = dx * diff * 0.5 * stiffness;
                const offsetY = dy * diff * 0.5 * stiffness;

                if (!this.p1.pinned) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }

            draw(color = 'rgba(255, 255, 255, 0.6)') {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
            }
        }

        // Scene: Rope Bridge
        function createBridge() {
            points = [];
            sticks = [];

            const segments = 25;
            const y = 150;
            const spacing = (canvas.width - 200) / segments;

            // Create points
            for (let i = 0; i <= segments; i++) {
                const x = 100 + i * spacing;
                const pinned = i === 0 || i === segments;
                points.push(new Point(x, y, pinned));
            }

            // Create sticks
            for (let i = 0; i < segments; i++) {
                sticks.push(new Stick(points[i], points[i + 1]));
            }

            document.getElementById('scene-info').textContent =
                'Rope Bridge: Click to push • Watch wave propagation through constraints';
        }

        // Scene: Ragdoll
        function createRagdoll() {
            points = [];
            sticks = [];

            const centerX = canvas.width / 2;
            const centerY = 200;

            // Head
            const head = new Point(centerX, centerY);
            points.push(head);

            // Torso
            const torso1 = new Point(centerX, centerY + 40);
            const torso2 = new Point(centerX, centerY + 80);
            points.push(torso1, torso2);

            // Arms
            const leftShoulder = new Point(centerX - 30, centerY + 45);
            const leftElbow = new Point(centerX - 50, centerY + 70);
            const leftHand = new Point(centerX - 60, centerY + 100);

            const rightShoulder = new Point(centerX + 30, centerY + 45);
            const rightElbow = new Point(centerX + 50, centerY + 70);
            const rightHand = new Point(centerX + 60, centerY + 100);

            points.push(leftShoulder, leftElbow, leftHand, rightShoulder, rightElbow, rightHand);

            // Legs
            const leftHip = new Point(centerX - 15, centerY + 90);
            const leftKnee = new Point(centerX - 20, centerY + 130);
            const leftFoot = new Point(centerX - 25, centerY + 170);

            const rightHip = new Point(centerX + 15, centerY + 90);
            const rightKnee = new Point(centerX + 20, centerY + 130);
            const rightFoot = new Point(centerX + 25, centerY + 170);

            points.push(leftHip, leftKnee, leftFoot, rightHip, rightKnee, rightFoot);

            // Connect with sticks
            sticks.push(
                // Spine
                new Stick(head, torso1),
                new Stick(torso1, torso2),

                // Left arm
                new Stick(torso1, leftShoulder),
                new Stick(leftShoulder, leftElbow),
                new Stick(leftElbow, leftHand),

                // Right arm
                new Stick(torso1, rightShoulder),
                new Stick(rightShoulder, rightElbow),
                new Stick(rightElbow, rightHand),

                // Left leg
                new Stick(torso2, leftHip),
                new Stick(leftHip, leftKnee),
                new Stick(leftKnee, leftFoot),

                // Right leg
                new Stick(torso2, rightHip),
                new Stick(rightHip, rightKnee),
                new Stick(rightKnee, rightFoot)
            );

            // Pin head initially
            head.pinned = true;

            document.getElementById('scene-info').textContent =
                'Ragdoll: Click to unpin head • Watch realistic joint behavior';
        }

        // Scene: Bouncing Ball Chain
        function createChain() {
            points = [];
            sticks = [];

            const count = 15;
            const startX = canvas.width / 2 - (count * 30) / 2;
            const startY = 100;

            for (let i = 0; i < count; i++) {
                const x = startX + i * 35;
                const y = startY;
                const pinned = i === 0;
                points.push(new Point(x, y, pinned, 1 + i * 0.2));
            }

            for (let i = 0; i < count - 1; i++) {
                sticks.push(new Stick(points[i], points[i + 1]));
            }

            document.getElementById('scene-info').textContent =
                'Ball Chain: Varying masses create interesting dynamics • Click to add energy';
        }

        // Scene: Newton's Cradle
        function createCradle() {
            points = [];
            sticks = [];

            const count = 7;
            const spacing = 40;
            const length = 200;
            const startX = canvas.width / 2 - (count * spacing) / 2;
            const topY = 100;

            for (let i = 0; i < count; i++) {
                const x = startX + i * spacing;
                const anchor = new Point(x, topY, true);
                const ball = new Point(x, topY + length, false, 2);

                points.push(anchor, ball);
                sticks.push(new Stick(anchor, ball, length));
            }

            // Pull first ball to the side
            points[1].x -= 100;
            points[1].oldX = points[1].x;

            document.getElementById('scene-info').textContent =
                'Newton\'s Cradle: Energy and momentum conservation in action';
        }

        // Scene: Euler vs Verlet Comparison
        function createComparison() {
            points = [];
            sticks = [];

            // Verlet pendulum (left)
            const verletAnchor = new Point(canvas.width / 2 - 150, 150, true);
            const verletBall = new Point(canvas.width / 2 - 150, 350, false, 2);
            verletBall.oldX = verletBall.x - 50; // Initial velocity

            // Euler pendulum (right)
            const eulerAnchor = new Point(canvas.width / 2 + 150, 150, true);
            const eulerBall = new Point(canvas.width / 2 + 150, 350, false, 2);
            eulerBall.oldX = eulerBall.x - 50; // Same initial velocity
            eulerBall.useEuler = true;

            points.push(verletAnchor, verletBall, eulerAnchor, eulerBall);
            sticks.push(
                new Stick(verletAnchor, verletBall, 200),
                new Stick(eulerAnchor, eulerBall, 200)
            );

            document.getElementById('scene-info').textContent =
                'Left: Verlet (stable) | Right: Euler (energy drift) | Watch energy conservation!';
        }

        // Initialize scene
        function initScene(scene) {
            currentScene = scene;
            switch(scene) {
                case 'bridge': createBridge(); break;
                case 'ragdoll': createRagdoll(); break;
                case 'chain': createChain(); break;
                case 'cradle': createCradle(); break;
                case 'comparison': createComparison(); break;
            }
        }

        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        let dragging = null;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            // Find nearest point
            let nearest = null;
            let minDist = 30;

            for (const point of points) {
                const dx = point.x - mouseX;
                const dy = point.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearest = point;
                }
            }

            if (nearest) {
                if (currentScene === 'ragdoll' && nearest === points[0]) {
                    // Toggle head pin
                    nearest.pinned = !nearest.pinned;
                } else {
                    // Apply impulse
                    const dx = mouseX - nearest.x;
                    const dy = mouseY - nearest.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        nearest.applyForce((dx / dist) * 50, (dy / dist) * 50);
                    }
                }
            }
        });

        // Animation loop
        function animate() {
            // Clear canvas
            ctx.fillStyle = 'rgba(30, 30, 30, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = '#2d2d2d';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

            if (!paused) {
                const dt = 1.0 * speed;

                // Update points
                for (const point of points) {
                    if (point.useEuler) {
                        point.updateEuler(dt);
                    } else {
                        point.update(dt);
                    }
                }

                // Solve constraints (multiple iterations for stability)
                for (let i = 0; i < iterations; i++) {
                    for (const stick of sticks) {
                        stick.solve();
                    }
                }
            }

            // Draw sticks
            for (const stick of sticks) {
                stick.draw();
            }

            // Draw points
            for (const point of points) {
                const color = point.useEuler ? '#ff6b9d' : '#4ecdc4';
                point.draw(color);
            }

            // Labels for comparison scene
            if (currentScene === 'comparison') {
                ctx.fillStyle = '#4ecdc4';
                ctx.font = 'bold 18px sans-serif';
                ctx.fillText('VERLET', canvas.width / 2 - 200, 130);

                ctx.fillStyle = '#ff6b9d';
                ctx.fillText('EULER', canvas.width / 2 + 130, 130);
            }

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravity-value').textContent = gravity.toFixed(1);
        });

        document.getElementById('stiffness').addEventListener('input', (e) => {
            stiffness = parseFloat(e.target.value);
            document.getElementById('stiffness-value').textContent = stiffness.toFixed(1);
        });

        document.getElementById('iterations').addEventListener('input', (e) => {
            iterations = parseInt(e.target.value);
            document.getElementById('iterations-value').textContent = iterations;
        });

        document.getElementById('friction').addEventListener('input', (e) => {
            friction = parseFloat(e.target.value);
            document.getElementById('friction-value').textContent = friction.toFixed(2);
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = speed.toFixed(1);
        });

        // Scene buttons
        const sceneButtons = document.querySelectorAll('.scene-buttons button');
        sceneButtons.forEach(button => {
            button.addEventListener('click', () => {
                sceneButtons.forEach(b => b.classList.remove('active'));
                button.classList.add('active');

                const scene = button.id.replace('scene-', '');
                initScene(scene);
            });
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initScene(currentScene);
        });

        // Initialize and start
        initScene('bridge');
        animate();
    </script>
</body>
</html>