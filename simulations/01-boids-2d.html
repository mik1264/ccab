<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic 2D Boids Flocking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 1400px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.6;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        canvas {
            border: 2px solid #667eea;
            border-radius: 10px;
            background: #0a0a0a;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
            cursor: crosshair;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 350px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #667eea;
            font-weight: 600;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #fff;
            font-weight: bold;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stats-label {
            color: #aaa;
        }

        .stats-value {
            color: #667eea;
            font-weight: bold;
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .info-box h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Classic 2D Boids Flocking</h1>
        <p class="description">
            Experience Craig Reynolds' pioneering 1987 Boids algorithm in action. Watch as simple rules create
            complex, lifelike flocking behavior. Three fundamental forces—separation, alignment, and cohesion—
            combine to produce emergent swarm intelligence. Click on any boid to visualize its perception radius
            and neighbor connections.
        </p>

        <div class="content">
            <canvas id="canvas"></canvas>

            <div class="controls">
                <div class="control-group">
                    <label>
                        Boid Count: <span class="value-display" id="countValue">200</span>
                    </label>
                    <input type="range" id="boidCount" min="50" max="500" value="200" step="10">
                </div>

                <div class="control-group">
                    <label>
                        Max Speed: <span class="value-display" id="speedValue">2.0</span>
                    </label>
                    <input type="range" id="maxSpeed" min="0.5" max="5.0" value="2.0" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Perception Radius: <span class="value-display" id="radiusValue">50</span>
                    </label>
                    <input type="range" id="perceptionRadius" min="20" max="100" value="50" step="5">
                </div>

                <div class="control-group">
                    <label>
                        Separation Weight: <span class="value-display" id="separationValue">1.5</span>
                    </label>
                    <input type="range" id="separationWeight" min="0" max="3" value="1.5" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Alignment Weight: <span class="value-display" id="alignmentValue">1.0</span>
                    </label>
                    <input type="range" id="alignmentWeight" min="0" max="3" value="1.0" step="0.1">
                </div>

                <div class="control-group">
                    <label>
                        Cohesion Weight: <span class="value-display" id="cohesionValue">1.0</span>
                    </label>
                    <input type="range" id="cohesionWeight" min="0" max="3" value="1.0" step="0.1">
                </div>

                <button class="btn-primary" id="pauseBtn">Pause</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>

                <div class="stats">
                    <div class="stats-row">
                        <span class="stats-label">FPS:</span>
                        <span class="stats-value" id="fps">60</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Active Boids:</span>
                        <span class="stats-value" id="activeBoids">200</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Selected Boid:</span>
                        <span class="stats-value" id="selectedBoid">None</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Neighbors:</span>
                        <span class="stats-value" id="neighbors">-</span>
                    </div>
                </div>

                <div class="info-box">
                    <h3>Reynolds' Three Rules</h3>
                    <p><strong>Separation:</strong> Avoid crowding nearby boids</p>
                    <p><strong>Alignment:</strong> Match velocity with neighbors</p>
                    <p><strong>Cohesion:</strong> Move toward group center</p>
                    <p style="margin-top: 10px; font-style: italic;">
                        Click any boid to see its perception radius and connections!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas dimensions
        const WIDTH = 900;
        const HEIGHT = 900;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // Parameters
        let params = {
            boidCount: 200,
            maxSpeed: 2.0,
            maxForce: 0.05,
            perceptionRadius: 50,
            separationWeight: 1.5,
            alignmentWeight: 1.0,
            cohesionWeight: 1.0,
            separationRadius: 25
        };

        let paused = false;
        let selectedBoidIndex = null;

        // Spatial grid for optimization
        const GRID_SIZE = 50;
        const COLS = Math.ceil(WIDTH / GRID_SIZE);
        const ROWS = Math.ceil(HEIGHT / GRID_SIZE);

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }

            mult(n) {
                this.x *= n;
                this.y *= n;
                return this;
            }

            div(n) {
                if (n !== 0) {
                    this.x /= n;
                    this.y /= n;
                }
                return this;
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }

            limit(max) {
                const m = this.mag();
                if (m > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }

            setMag(n) {
                this.normalize();
                this.mult(n);
                return this;
            }

            dist(v) {
                const dx = this.x - v.x;
                const dy = this.y - v.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            copy() {
                return new Vector(this.x, this.y);
            }

            static sub(v1, v2) {
                return new Vector(v1.x - v2.x, v1.y - v2.y);
            }

            static dist(v1, v2) {
                return v1.dist(v2);
            }
        }

        class Boid {
            constructor() {
                this.position = new Vector(
                    Math.random() * WIDTH,
                    Math.random() * HEIGHT
                );
                const angle = Math.random() * Math.PI * 2;
                this.velocity = new Vector(
                    Math.cos(angle) * params.maxSpeed,
                    Math.sin(angle) * params.maxSpeed
                );
                this.acceleration = new Vector(0, 0);
                this.size = 8;
            }

            update() {
                this.velocity.add(this.acceleration);
                this.velocity.limit(params.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.mult(0);

                // Wrap around edges
                if (this.position.x < 0) this.position.x = WIDTH;
                if (this.position.x > WIDTH) this.position.x = 0;
                if (this.position.y < 0) this.position.y = HEIGHT;
                if (this.position.y > HEIGHT) this.position.y = 0;
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            flock(boids, neighbors) {
                const separation = this.separate(neighbors);
                const alignment = this.align(neighbors);
                const cohesion = this.cohere(neighbors);

                separation.mult(params.separationWeight);
                alignment.mult(params.alignmentWeight);
                cohesion.mult(params.cohesionWeight);

                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }

            separate(neighbors) {
                const steer = new Vector(0, 0);
                let count = 0;

                for (const other of neighbors) {
                    const d = Vector.dist(this.position, other.position);
                    if (d > 0 && d < params.separationRadius) {
                        const diff = Vector.sub(this.position, other.position);
                        diff.normalize();
                        diff.div(d); // Weight by distance
                        steer.add(diff);
                        count++;
                    }
                }

                if (count > 0) {
                    steer.div(count);
                    steer.normalize();
                    steer.mult(params.maxSpeed);
                    steer.sub(this.velocity);
                    steer.limit(params.maxForce);
                }

                return steer;
            }

            align(neighbors) {
                const sum = new Vector(0, 0);
                let count = 0;

                for (const other of neighbors) {
                    sum.add(other.velocity);
                    count++;
                }

                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(params.maxSpeed);
                    const steer = Vector.sub(sum, this.velocity);
                    steer.limit(params.maxForce);
                    return steer;
                }

                return new Vector(0, 0);
            }

            cohere(neighbors) {
                const sum = new Vector(0, 0);
                let count = 0;

                for (const other of neighbors) {
                    sum.add(other.position);
                    count++;
                }

                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum);
                }

                return new Vector(0, 0);
            }

            seek(target) {
                const desired = Vector.sub(target, this.position);
                desired.normalize();
                desired.mult(params.maxSpeed);
                const steer = Vector.sub(desired, this.velocity);
                steer.limit(params.maxForce);
                return steer;
            }

            draw(ctx, isSelected = false) {
                const angle = Math.atan2(this.velocity.y, this.velocity.x);

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);

                // Draw triangle
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size, this.size / 2);
                ctx.lineTo(-this.size, -this.size / 2);
                ctx.closePath();

                if (isSelected) {
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#00ffff';
                    ctx.strokeStyle = '#008b8b';
                }

                ctx.fill();
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }
        }

        class SpatialGrid {
            constructor() {
                this.grid = Array(ROWS).fill(null).map(() =>
                    Array(COLS).fill(null).map(() => [])
                );
            }

            clear() {
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        this.grid[i][j] = [];
                    }
                }
            }

            insert(boid, index) {
                const col = Math.floor(boid.position.x / GRID_SIZE);
                const row = Math.floor(boid.position.y / GRID_SIZE);

                if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                    this.grid[row][col].push({ boid, index });
                }
            }

            getNearby(position, radius) {
                const nearby = [];
                const col = Math.floor(position.x / GRID_SIZE);
                const row = Math.floor(position.y / GRID_SIZE);
                const cellRadius = Math.ceil(radius / GRID_SIZE);

                for (let i = row - cellRadius; i <= row + cellRadius; i++) {
                    for (let j = col - cellRadius; j <= col + cellRadius; j++) {
                        if (i >= 0 && i < ROWS && j >= 0 && j < COLS) {
                            nearby.push(...this.grid[i][j]);
                        }
                    }
                }

                return nearby;
            }
        }

        // Initialize boids
        let boids = [];
        let spatialGrid = new SpatialGrid();

        function initBoids() {
            boids = [];
            for (let i = 0; i < params.boidCount; i++) {
                boids.push(new Boid());
            }
            selectedBoidIndex = null;
        }

        initBoids();

        // FPS calculation
        let lastTime = performance.now();
        let fps = 60;

        function updateFPS() {
            const now = performance.now();
            const delta = now - lastTime;
            fps = Math.round(1000 / delta);
            lastTime = now;
            document.getElementById('fps').textContent = fps;
        }

        // Animation loop
        function animate() {
            if (!paused) {
                // Clear canvas with trail effect
                ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Update spatial grid
                spatialGrid.clear();
                boids.forEach((boid, index) => {
                    spatialGrid.insert(boid, index);
                });

                // Update and draw boids
                boids.forEach((boid, index) => {
                    // Get nearby boids
                    const nearby = spatialGrid.getNearby(boid.position, params.perceptionRadius);
                    const neighbors = nearby
                        .filter(item => item.index !== index)
                        .map(item => item.boid)
                        .filter(other => Vector.dist(boid.position, other.position) < params.perceptionRadius);

                    boid.flock(boids, neighbors);
                    boid.update();
                    boid.draw(ctx, index === selectedBoidIndex);
                });

                // Draw selected boid info
                if (selectedBoidIndex !== null && selectedBoidIndex < boids.length) {
                    const selectedBoid = boids[selectedBoidIndex];
                    const nearby = spatialGrid.getNearby(selectedBoid.position, params.perceptionRadius);
                    const neighbors = nearby
                        .filter(item => item.index !== selectedBoidIndex)
                        .map(item => item.boid)
                        .filter(other => Vector.dist(selectedBoid.position, other.position) < params.perceptionRadius);

                    // Draw perception radius
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(selectedBoid.position.x, selectedBoid.position.y, params.perceptionRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw connections to neighbors
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.lineWidth = 1;
                    neighbors.forEach(neighbor => {
                        ctx.beginPath();
                        ctx.moveTo(selectedBoid.position.x, selectedBoid.position.y);
                        ctx.lineTo(neighbor.position.x, neighbor.position.y);
                        ctx.stroke();
                    });

                    document.getElementById('neighbors').textContent = neighbors.length;
                } else {
                    document.getElementById('neighbors').textContent = '-';
                }

                updateFPS();
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('boidCount').addEventListener('input', (e) => {
            params.boidCount = parseInt(e.target.value);
            document.getElementById('countValue').textContent = params.boidCount;
            document.getElementById('activeBoids').textContent = params.boidCount;

            // Adjust boid count
            while (boids.length < params.boidCount) {
                boids.push(new Boid());
            }
            while (boids.length > params.boidCount) {
                boids.pop();
            }
        });

        document.getElementById('maxSpeed').addEventListener('input', (e) => {
            params.maxSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = params.maxSpeed.toFixed(1);
        });

        document.getElementById('perceptionRadius').addEventListener('input', (e) => {
            params.perceptionRadius = parseInt(e.target.value);
            document.getElementById('radiusValue').textContent = params.perceptionRadius;
        });

        document.getElementById('separationWeight').addEventListener('input', (e) => {
            params.separationWeight = parseFloat(e.target.value);
            document.getElementById('separationValue').textContent = params.separationWeight.toFixed(1);
        });

        document.getElementById('alignmentWeight').addEventListener('input', (e) => {
            params.alignmentWeight = parseFloat(e.target.value);
            document.getElementById('alignmentValue').textContent = params.alignmentWeight.toFixed(1);
        });

        document.getElementById('cohesionWeight').addEventListener('input', (e) => {
            params.cohesionWeight = parseFloat(e.target.value);
            document.getElementById('cohesionValue').textContent = params.cohesionWeight.toFixed(1);
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initBoids();
        });

        // Click to select boid
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let closestIndex = null;
            let closestDist = Infinity;

            boids.forEach((boid, index) => {
                const d = Math.sqrt((boid.position.x - x) ** 2 + (boid.position.y - y) ** 2);
                if (d < closestDist && d < 20) {
                    closestDist = d;
                    closestIndex = index;
                }
            });

            selectedBoidIndex = closestIndex;
            document.getElementById('selectedBoid').textContent =
                closestIndex !== null ? `#${closestIndex}` : 'None';
        });

        animate();
    </script>
</body>
</html>
