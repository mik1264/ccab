<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bragg Diffraction - Optical Phenomena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none;
            font-size: 14px; z-index: 1000; opacity: 0.8; transition: opacity 0.3s;
        }
        .back-link:hover { opacity: 1; }
        .controls {
            position: fixed; top: 15px; right: 15px; z-index: 1000;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border: 1px solid rgba(100,140,255,0.2); border-radius: 12px;
            padding: 16px; min-width: 250px;
        }
        .controls h3 { color: #8ab4f8; font-size: 14px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; font-size: 12px; color: #aaa; margin-bottom: 4px; }
        .control-group input[type="range"] { width: 100%; accent-color: #8ab4f8; }
        .control-group .value { float: right; color: #8ab4f8; font-size: 12px; font-family: monospace; }
        .info-panel {
            position: fixed; bottom: 15px; left: 15px; z-index: 1000;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border: 1px solid rgba(100,140,255,0.2); border-radius: 12px;
            padding: 16px; max-width: 380px;
        }
        .info-panel h3 { color: #8ab4f8; font-size: 14px; margin-bottom: 8px; }
        .info-panel p { font-size: 12px; color: #bbb; line-height: 1.5; margin-bottom: 6px; }
        .formula { font-family: monospace; color: #f0c060; font-size: 13px; padding: 4px 0; }
        .bragg-status {
            margin-top: 10px; padding: 8px; border-radius: 6px; font-size: 13px;
            font-family: monospace; text-align: center;
        }
        .bragg-met { background: rgba(96,255,96,0.15); color: #60ff60; border: 1px solid rgba(96,255,96,0.3); }
        .bragg-not { background: rgba(255,96,96,0.1); color: #ff8888; border: 1px solid rgba(255,96,96,0.2); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Optical Phenomena</a>

    <div class="controls">
        <h3>Bragg Diffraction</h3>
        <div class="control-group">
            <label>Incidence Angle &theta; <span class="value" id="thetaVal">30.0&deg;</span></label>
            <input type="range" id="theta" min="5" max="85" value="30" step="0.5">
        </div>
        <div class="control-group">
            <label>Lattice Spacing d <span class="value" id="dVal">2.5 &Aring;</span></label>
            <input type="range" id="spacing" min="1" max="5" value="2.5" step="0.1">
        </div>
        <div class="control-group">
            <label>Wavelength &lambda; <span class="value" id="wlVal">1.54 &Aring;</span></label>
            <input type="range" id="wavelength" min="0.5" max="4" value="1.54" step="0.01">
        </div>
        <div class="control-group">
            <label>Crystal Layers <span class="value" id="layerVal">6</span></label>
            <input type="range" id="layers" min="3" max="12" value="6" step="1">
        </div>
        <div class="bragg-status bragg-not" id="braggStatus">Bragg condition NOT met</div>
    </div>

    <div class="info-panel">
        <h3>Bragg's Law</h3>
        <p>X-rays striking a crystal lattice scatter off atoms in different layers. Constructive interference occurs only when the path difference between waves reflected from adjacent layers equals a whole number of wavelengths.</p>
        <div class="formula">2d &middot; sin(&theta;) = n&lambda;</div>
        <p>Where d = layer spacing, &theta; = angle from surface, n = integer order. W.L. Bragg and his father won the 1915 Nobel Prize for this discovery.</p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        let time = 0;
        let animId;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function draw() {
            const thetaDeg = parseFloat(document.getElementById('theta').value);
            const d = parseFloat(document.getElementById('spacing').value);
            const lambda = parseFloat(document.getElementById('wavelength').value);
            const numLayers = parseInt(document.getElementById('layers').value);

            document.getElementById('thetaVal').textContent = thetaDeg.toFixed(1) + '\u00b0';
            document.getElementById('dVal').textContent = d.toFixed(1) + ' \u00c5';
            document.getElementById('wlVal').textContent = lambda.toFixed(2) + ' \u00c5';
            document.getElementById('layerVal').textContent = numLayers;

            const theta = thetaDeg * Math.PI / 180;
            const sinTheta = Math.sin(theta);

            // Check Bragg condition for any order
            let braggMet = false;
            let braggOrder = 0;
            let braggCloseness = Infinity;
            for (let n = 1; n <= 5; n++) {
                const diff = Math.abs(2 * d * sinTheta - n * lambda);
                if (diff < braggCloseness) {
                    braggCloseness = diff;
                    braggOrder = n;
                }
                if (diff < 0.05) {
                    braggMet = true;
                    braggOrder = n;
                    break;
                }
            }

            const statusEl = document.getElementById('braggStatus');
            const braggIntensity = Math.max(0, 1 - braggCloseness / 0.3);
            if (braggMet) {
                statusEl.className = 'bragg-status bragg-met';
                statusEl.textContent = 'BRAGG CONDITION MET (n=' + braggOrder + ')';
            } else {
                statusEl.className = 'bragg-status bragg-not';
                statusEl.textContent = '2d sin\u03b8 = ' + (2*d*sinTheta).toFixed(3) + ' | n\u03bb = ' + (braggOrder*lambda).toFixed(3);
            }

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Crystal area
            const crystalCX = W * 0.45;
            const crystalCY = H * 0.5;
            const layerSpacing = 50;
            const atomSpacing = 50;
            const crystalW = W * 0.5;

            // Draw crystal layers (horizontal rows of atoms)
            for (let layer = 0; layer < numLayers; layer++) {
                const ly = crystalCY + layer * layerSpacing - (numLayers - 1) * layerSpacing / 2;

                // Layer line
                ctx.beginPath();
                ctx.moveTo(crystalCX - crystalW / 2, ly);
                ctx.lineTo(crystalCX + crystalW / 2, ly);
                ctx.strokeStyle = 'rgba(100,140,255,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Atoms
                const numAtoms = Math.floor(crystalW / atomSpacing);
                for (let a = 0; a < numAtoms; a++) {
                    const ax = crystalCX - crystalW / 2 + (a + 0.5) * atomSpacing;
                    const ay = ly;

                    // Atom glow
                    const grad = ctx.createRadialGradient(ax, ay, 0, ax, ay, 12);
                    grad.addColorStop(0, 'rgba(100,180,255,0.4)');
                    grad.addColorStop(0.5, 'rgba(100,180,255,0.1)');
                    grad.addColorStop(1, 'rgba(100,180,255,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // Atom core
                    ctx.beginPath();
                    ctx.arc(ax, ay, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(130,170,255,0.7)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(138,180,248,0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Label layer spacing
                if (layer === 0) {
                    const nextLy = crystalCY + (layer + 1) * layerSpacing - (numLayers - 1) * layerSpacing / 2;
                    ctx.beginPath();
                    ctx.moveTo(crystalCX + crystalW / 2 + 15, ly);
                    ctx.lineTo(crystalCX + crystalW / 2 + 15, nextLy);
                    ctx.strokeStyle = '#f0c060';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    // Arrow heads
                    ctx.beginPath();
                    ctx.moveTo(crystalCX + crystalW / 2 + 10, ly + 5);
                    ctx.lineTo(crystalCX + crystalW / 2 + 15, ly);
                    ctx.lineTo(crystalCX + crystalW / 2 + 20, ly + 5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(crystalCX + crystalW / 2 + 10, nextLy - 5);
                    ctx.lineTo(crystalCX + crystalW / 2 + 15, nextLy);
                    ctx.lineTo(crystalCX + crystalW / 2 + 20, nextLy - 5);
                    ctx.stroke();
                    ctx.fillStyle = '#f0c060';
                    ctx.font = '12px monospace';
                    ctx.fillText('d', crystalCX + crystalW / 2 + 22, (ly + nextLy) / 2 + 4);
                }
            }

            // Draw X-ray beam coming from upper-left
            const topLayer = crystalCY - (numLayers - 1) * layerSpacing / 2;
            const beamAngle = Math.PI - theta; // angle from horizontal, coming from left

            // Incoming beam direction (going right and down toward crystal)
            const dirX = Math.cos(-theta + Math.PI);
            const dirY = -Math.sin(-theta + Math.PI);
            // The beam hits the crystal surface; let's define hit points on each layer
            const hitX0 = crystalCX;

            for (let layer = 0; layer < Math.min(numLayers, 5); layer++) {
                const ly = crystalCY + layer * layerSpacing - (numLayers - 1) * layerSpacing / 2;

                // Calculate hit point (beam enters from upper left)
                const hitX = hitX0 - layer * layerSpacing / Math.tan(theta);
                const hitY = ly;

                // Incoming ray
                const inLen = 200;
                const inX = hitX + Math.cos(theta) * inLen;
                const inY = hitY - Math.sin(theta) * inLen;

                // Animate wave crests along incoming beam
                const waveLen = 25;
                ctx.beginPath();
                ctx.moveTo(inX, inY);
                ctx.lineTo(hitX, hitY);
                const beamColor = layer === 0 ? 'rgba(255,200,80,0.6)' : `rgba(255,200,80,${0.4 - layer * 0.08})`;
                ctx.strokeStyle = beamColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Wave crests on incoming beam
                for (let t = 0; t < inLen; t += waveLen) {
                    const phase = (t + time * 60) % waveLen;
                    const frac = phase / waveLen;
                    const wx = hitX + Math.cos(theta) * (t);
                    const wy = hitY - Math.sin(theta) * (t);

                    const perpX = -Math.sin(theta) * 8;
                    const perpY = -Math.cos(theta) * 8;

                    ctx.beginPath();
                    ctx.moveTo(wx - perpX, wy - perpY);
                    ctx.lineTo(wx + perpX, wy + perpY);
                    ctx.strokeStyle = `rgba(255,220,100,${0.3 * (1 - layer * 0.15)})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                // Reflected ray (same angle on other side of normal)
                const outLen = 200;
                const outX = hitX - Math.cos(theta) * outLen;
                const outY = hitY - Math.sin(theta) * outLen;

                const reflectAlpha = braggMet ? 0.7 : braggIntensity * 0.5;
                const reflColor = braggMet
                    ? `rgba(100,255,100,${0.6 - layer * 0.1})`
                    : `rgba(255,100,100,${reflectAlpha * (0.4 - layer * 0.08)})`;

                ctx.beginPath();
                ctx.moveTo(hitX, hitY);
                ctx.lineTo(outX, outY);
                ctx.strokeStyle = reflColor;
                ctx.lineWidth = braggMet ? 2.5 : 1.5;
                ctx.stroke();

                // Wave crests on reflected beam
                if (braggIntensity > 0.1) {
                    for (let t = 0; t < outLen; t += waveLen) {
                        const wx = hitX - Math.cos(theta) * t;
                        const wy = hitY - Math.sin(theta) * t;

                        const perpX = Math.sin(theta) * 8;
                        const perpY = -Math.cos(theta) * 8;

                        ctx.beginPath();
                        ctx.moveTo(wx - perpX, wy - perpY);
                        ctx.lineTo(wx + perpX, wy + perpY);
                        ctx.strokeStyle = braggMet
                            ? `rgba(100,255,100,${0.3 * (1 - layer * 0.1)})`
                            : `rgba(255,100,100,${braggIntensity * 0.2})`;
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }

                // Hit point scatter marker
                ctx.beginPath();
                ctx.arc(hitX, hitY, braggMet ? 6 : 4, 0, Math.PI * 2);
                ctx.fillStyle = braggMet ? 'rgba(100,255,100,0.5)' : 'rgba(255,200,80,0.3)';
                ctx.fill();

                // Show path difference construction for first two layers
                if (layer === 0) {
                    // Normal line at hit point
                    ctx.beginPath();
                    ctx.moveTo(hitX, hitY - 30);
                    ctx.lineTo(hitX, hitY + 30);
                    ctx.strokeStyle = 'rgba(138,180,248,0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Angle arc
                    ctx.beginPath();
                    ctx.arc(hitX, hitY, 25, -Math.PI / 2, -Math.PI / 2 + (Math.PI / 2 - theta), false);
                    ctx.strokeStyle = '#f0c060';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = '#f0c060';
                    ctx.font = '12px serif';
                    ctx.fillText('\u03b8', hitX + 28, hitY - 18);
                }
            }

            // Draw detector / diffraction spots (right side)
            const detX = W * 0.85;
            const detTop = H * 0.1;
            const detH = H * 0.8;

            ctx.fillStyle = 'rgba(15,18,30,0.8)';
            ctx.fillRect(detX - 3, detTop, 6, detH);
            ctx.strokeStyle = 'rgba(100,140,255,0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(detX - 3, detTop, 6, detH);

            ctx.fillStyle = '#888';
            ctx.font = '11px monospace';
            ctx.fillText('Detector', detX - 20, detTop - 8);

            // Draw spots on detector
            for (let n = -3; n <= 3; n++) {
                const braggAngle = Math.asin(Math.min(1, Math.max(-1, n * lambda / (2 * d))));
                if (isNaN(braggAngle)) continue;

                const spotY = H / 2 - n * 40;
                const closeness = Math.abs(2 * d * Math.sin(theta) - Math.abs(n) * lambda);
                const spotIntensity = Math.max(0, 1 - closeness / 0.15);

                if (spotIntensity > 0.01) {
                    const grad = ctx.createRadialGradient(detX, spotY, 0, detX, spotY, 15);
                    grad.addColorStop(0, `rgba(100,255,100,${spotIntensity * 0.8})`);
                    grad.addColorStop(0.5, `rgba(100,255,100,${spotIntensity * 0.3})`);
                    grad.addColorStop(1, 'rgba(100,255,100,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(detX, spotY, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Label
                ctx.fillStyle = 'rgba(150,150,150,0.5)';
                ctx.font = '10px monospace';
                ctx.fillText('n=' + n, detX + 10, spotY + 4);
            }

            // Show the Bragg equation result
            ctx.fillStyle = '#fff';
            ctx.font = '13px monospace';
            ctx.fillText('2d sin\u03b8 = ' + (2 * d * sinTheta).toFixed(3) + ' \u00c5', 20, H - 70);
            ctx.fillText('n\u03bb = ' + lambda.toFixed(3) + ' \u00c5  (n=1)', 20, H - 50);

            if (braggMet) {
                // Bright flash effect
                const flash = (Math.sin(time * 5) * 0.5 + 0.5) * 0.05;
                ctx.fillStyle = `rgba(100,255,100,${flash})`;
                ctx.fillRect(0, 0, W, H);
            }

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Segoe UI, sans-serif';
            ctx.fillText('Bragg Diffraction', W / 2 - 70, H - 15);

            time += 0.016;
            animId = requestAnimationFrame(draw);
        }

        window.reset = function() {
            time = 0;
            document.getElementById('theta').value = 30;
            document.getElementById('spacing').value = 2.5;
            document.getElementById('wavelength').value = 1.54;
            document.getElementById('layers').value = 6;
        };

        draw();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
