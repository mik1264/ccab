<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Total Internal Reflection</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
canvas { display: block; }
#controls {
    position: fixed; top: 15px; right: 15px; width: 260px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2);
}
#controls h3 { color: #7eb8ff; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
.control-row { margin-bottom: 10px; }
.control-row label { display: block; font-size: 12px; color: #8ab4f8; margin-bottom: 3px; }
.control-row input[type="range"] { width: 100%; accent-color: #5b8def; }
.control-row .value { float: right; color: #ffd475; font-size: 12px; font-weight: bold; }
.view-btn {
    display: inline-block; padding: 5px 10px; margin: 3px; border-radius: 6px; cursor: pointer;
    background: rgba(80,120,200,0.25); border: 1px solid rgba(100,140,255,0.3);
    color: #8ab4f8; font-size: 11px;
}
.view-btn:hover, .view-btn.active { background: rgba(80,120,200,0.5); color: #fff; }
#info {
    position: fixed; bottom: 15px; left: 15px; width: 320px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2); font-size: 13px; line-height: 1.5;
}
#info h3 { color: #7eb8ff; margin-bottom: 8px; font-size: 14px; }
.equation { color: #ffd475; font-family: 'Georgia', serif; font-style: italic; text-align: center; margin: 8px 0; font-size: 15px; }
#readout {
    position: fixed; top: 15px; left: 15px; width: 240px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2); font-size: 13px;
}
#readout h3 { color: #7eb8ff; margin-bottom: 8px; font-size: 14px; }
.readout-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
.readout-label { color: #8ab4f8; }
.readout-value { color: #ffd475; font-weight: bold; }
.bar { height: 6px; border-radius: 3px; margin-top: 4px; }
a.back { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); color: #7eb8ff; text-decoration: none; z-index: 20; font-size: 13px; }
a.back:hover { color: #ffd475; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back to Gallery</a>
<canvas id="c"></canvas>

<div id="readout">
    <h3>Measurements</h3>
    <div class="readout-row"><span class="readout-label">Incident angle:</span><span class="readout-value" id="rAngle">45.0°</span></div>
    <div class="readout-row"><span class="readout-label">Critical angle:</span><span class="readout-value" id="rCritical">41.8°</span></div>
    <div class="readout-row"><span class="readout-label">Reflectance:</span><span class="readout-value" id="rRefl">0.05</span></div>
    <div class="readout-row"><span class="readout-label">Transmittance:</span><span class="readout-value" id="rTrans">0.95</span></div>
    <div style="margin-top:8px;">
        <span style="font-size:11px;color:#8ab4f8;">Reflected</span>
        <div class="bar" id="barRefl" style="background:rgba(100,180,255,0.8);width:5%;"></div>
        <span style="font-size:11px;color:#50ff90;">Transmitted</span>
        <div class="bar" id="barTrans" style="background:rgba(80,255,144,0.8);width:95%;"></div>
    </div>
</div>

<div id="controls">
    <h3>Controls</h3>
    <div class="control-row">
        <label>Refractive Index (n): <span class="value" id="vN">1.50</span></label>
        <input type="range" id="sN" min="1.1" max="2.5" step="0.01" value="1.5">
    </div>
    <div class="control-row">
        <label>Incident Angle: <span class="value" id="vAngle">45</span>°</label>
        <input type="range" id="sAngle" min="0" max="89" step="0.5" value="45">
    </div>
    <div style="margin-top:12px;">
        <span style="font-size:12px;color:#8ab4f8;">View:</span><br>
        <span class="view-btn active" id="btnBoundary" onclick="setView('boundary')">Boundary</span>
        <span class="view-btn" id="btnFiber" onclick="setView('fiber')">Fiber Optic</span>
    </div>
</div>

<div id="info">
    <h3>Total Internal Reflection</h3>
    <div class="equation">θ_c = arcsin(n₂ / n₁)</div>
    <p>When light travels from a denser medium (higher n) to a less dense one, and the angle exceeds the <strong style="color:#ff6b6b;">critical angle</strong>, 100% of light is reflected.</p>
    <p style="margin-top:6px;">Even beyond the boundary, an <strong style="color:#50ff90;">evanescent wave</strong> penetrates a fraction of a wavelength, decaying exponentially.</p>
    <p style="margin-top:6px;">This principle enables <strong style="color:#ffd475;">fiber optic</strong> communication - light bounces inside the glass core.</p>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let n = 1.5;
let incAngleDeg = 45;
let viewMode = 'boundary';
let animTime = 0;
let paused = false;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const sN = document.getElementById('sN');
const sAngle = document.getElementById('sAngle');

sN.addEventListener('input', () => {
    n = parseFloat(sN.value);
    document.getElementById('vN').textContent = n.toFixed(2);
});
sAngle.addEventListener('input', () => {
    incAngleDeg = parseFloat(sAngle.value);
    document.getElementById('vAngle').textContent = incAngleDeg.toFixed(0);
});

function setView(v) {
    viewMode = v;
    document.getElementById('btnBoundary').classList.toggle('active', v === 'boundary');
    document.getElementById('btnFiber').classList.toggle('active', v === 'fiber');
}
window.setView = setView;

function getCriticalAngle() {
    const ratio = 1.0 / n;
    if (ratio >= 1) return 90;
    return Math.asin(ratio) * 180 / Math.PI;
}

function fresnel(thetaDeg) {
    const theta = thetaDeg * Math.PI / 180;
    const sinT = Math.sin(theta);
    const sinR = sinT / 1.0 * n; // going from n to 1.0
    // Actually: light from dense (n) to air (1)
    const sinRefracted = n * sinT; // sin(theta_t) = n * sin(theta_i) / 1
    if (Math.abs(sinRefracted) > 1) return 1.0; // TIR

    const cosI = Math.cos(theta);
    const cosT = Math.sqrt(1 - sinRefracted * sinRefracted);

    const rs = Math.pow((n * cosI - 1.0 * cosT) / (n * cosI + 1.0 * cosT), 2);
    const rp = Math.pow((n * cosT - 1.0 * cosI) / (n * cosT + 1.0 * cosI), 2);
    return (rs + rp) / 2;
}

function drawBoundaryView() {
    const boundaryY = H * 0.45;
    const cx = W * 0.5;

    // Dense medium (bottom)
    const grad2 = ctx.createLinearGradient(0, boundaryY, 0, H);
    const alpha = Math.min(0.35, (n - 1) * 0.2 + 0.05);
    grad2.addColorStop(0, `rgba(60,180,220,${alpha})`);
    grad2.addColorStop(1, `rgba(30,100,140,${alpha * 0.5})`);
    ctx.fillStyle = grad2;
    ctx.fillRect(0, boundaryY, W, H - boundaryY);

    // Air (top) - very subtle
    ctx.fillStyle = 'rgba(40,50,80,0.1)';
    ctx.fillRect(0, 0, W, boundaryY);

    // Boundary line
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, boundaryY);
    ctx.lineTo(W, boundaryY);
    ctx.stroke();

    // Normal
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 6]);
    ctx.beginPath();
    ctx.moveTo(cx, boundaryY - 250);
    ctx.lineTo(cx, boundaryY + 250);
    ctx.stroke();
    ctx.setLineDash([]);

    // Labels
    ctx.fillStyle = 'rgba(60,180,220,0.6)';
    ctx.font = '13px Segoe UI';
    ctx.fillText(`Dense medium (n = ${n.toFixed(2)})`, cx + 60, boundaryY + 30);
    ctx.fillStyle = 'rgba(200,200,220,0.4)';
    ctx.fillText('Air (n = 1.00)', cx + 60, boundaryY - 15);

    const theta = incAngleDeg * Math.PI / 180;
    const rayLen = 300;
    const isTIR = incAngleDeg >= getCriticalAngle();
    const R = fresnel(incAngleDeg);
    const T = 1 - R;

    // Incident ray (from below)
    const ix = cx - rayLen * Math.sin(theta);
    const iy = boundaryY + rayLen * Math.cos(theta);
    drawRayWithGlow(ix, iy, cx, boundaryY, 'rgb(255,220,80)', 0.9, 3);
    drawPhotons(ix, iy, cx, boundaryY, '#ffd850', 0.3);

    // Reflected ray (back down)
    const rx = cx + rayLen * Math.sin(theta);
    const ry = boundaryY + rayLen * Math.cos(theta);
    const reflAlpha = Math.max(0.2, R);
    drawRayWithGlow(cx, boundaryY, rx, ry, 'rgb(100,180,255)', reflAlpha, 2.5);
    drawPhotons(cx, boundaryY, rx, ry, '#64b4ff', 0.25 * reflAlpha);

    // Refracted ray (if not TIR)
    if (!isTIR) {
        const sinRefracted = n * Math.sin(theta);
        const thetaR = Math.asin(sinRefracted);
        const tx = cx + rayLen * Math.sin(thetaR);
        const ty = boundaryY - rayLen * Math.cos(thetaR);
        drawRayWithGlow(cx, boundaryY, tx, ty, 'rgb(80,255,160)', T, 2);
        drawPhotons(cx, boundaryY, tx, ty, '#50ffa0', 0.25 * T);

        // Refracted angle arc
        drawArc(cx, boundaryY, 45, -Math.PI / 2, -Math.PI / 2 + thetaR, 'rgba(80,255,160,0.6)',
            `θ_t=${(thetaR * 180 / Math.PI).toFixed(1)}°`);
    }

    // Evanescent wave (always present but very visible during TIR)
    if (isTIR || incAngleDeg > getCriticalAngle() - 5) {
        const evanAlpha = isTIR ? 0.6 : 0.2;
        const penetration = 40;
        for (let x = cx - 100; x < cx + 100; x += 3) {
            for (let dy = 1; dy < penetration; dy += 3) {
                const decay = Math.exp(-dy * 0.08);
                const wave = Math.sin((x - animTime * 80) * 0.05) * decay;
                const a = evanAlpha * decay * (0.5 + 0.5 * wave);
                ctx.fillStyle = `rgba(80,255,160,${a})`;
                ctx.fillRect(x, boundaryY - dy, 2, 2);
            }
        }
        ctx.fillStyle = `rgba(80,255,160,${evanAlpha * 0.7})`;
        ctx.font = '11px Segoe UI';
        ctx.fillText('Evanescent wave', cx + 110, boundaryY - 20);
    }

    // Incident angle arc
    drawArc(cx, boundaryY, 50, Math.PI / 2, Math.PI / 2 - theta, 'rgba(255,220,80,0.6)',
        `θ_i=${incAngleDeg.toFixed(1)}°`);

    // Critical angle marker
    const critAngle = getCriticalAngle() * Math.PI / 180;
    ctx.strokeStyle = 'rgba(255,100,100,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 5]);
    ctx.beginPath();
    ctx.moveTo(cx, boundaryY);
    ctx.lineTo(cx - 150 * Math.sin(critAngle), boundaryY + 150 * Math.cos(critAngle));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,100,100,0.5)';
    ctx.font = '11px Segoe UI';
    ctx.fillText(`θ_c = ${getCriticalAngle().toFixed(1)}°`, cx - 150 * Math.sin(critAngle) - 10, boundaryY + 150 * Math.cos(critAngle) + 15);

    // Update readouts
    document.getElementById('rAngle').textContent = incAngleDeg.toFixed(1) + '°';
    document.getElementById('rCritical').textContent = getCriticalAngle().toFixed(1) + '°';
    document.getElementById('rRefl').textContent = R.toFixed(3);
    document.getElementById('rTrans').textContent = T.toFixed(3);
    document.getElementById('barRefl').style.width = (R * 100) + '%';
    document.getElementById('barTrans').style.width = (T * 100) + '%';

    if (isTIR) {
        ctx.fillStyle = 'rgba(255,100,100,0.8)';
        ctx.font = 'bold 16px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('TOTAL INTERNAL REFLECTION', cx, boundaryY - 200);
        ctx.textAlign = 'left';
    }
}

function drawFiberView() {
    const fiberY = H * 0.5;
    const fiberH = 80;
    const fiberStartX = W * 0.08;
    const fiberEndX = W * 0.92;
    const coreH = fiberH * 0.6;

    // Cladding
    ctx.fillStyle = 'rgba(40,60,100,0.3)';
    ctx.beginPath();
    ctx.roundRect(fiberStartX, fiberY - fiberH / 2, fiberEndX - fiberStartX, fiberH, 10);
    ctx.fill();
    ctx.strokeStyle = 'rgba(80,120,180,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(fiberStartX, fiberY - fiberH / 2, fiberEndX - fiberStartX, fiberH, 10);
    ctx.stroke();

    // Core
    ctx.fillStyle = 'rgba(60,180,220,0.15)';
    ctx.fillRect(fiberStartX + 5, fiberY - coreH / 2, fiberEndX - fiberStartX - 10, coreH);
    ctx.strokeStyle = 'rgba(80,200,240,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(fiberStartX + 5, fiberY - coreH / 2);
    ctx.lineTo(fiberEndX - 5, fiberY - coreH / 2);
    ctx.moveTo(fiberStartX + 5, fiberY + coreH / 2);
    ctx.lineTo(fiberEndX - 5, fiberY + coreH / 2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Trace bouncing light through fiber
    const bounceAngle = 15 * Math.PI / 180;
    const raySpeed = animTime * 150;
    const segLen = coreH / Math.sin(bounceAngle);
    const colors = ['#ff4444', '#44ff44', '#4488ff'];

    for (let c = 0; c < 3; c++) {
        const offset = c * segLen * 0.33;
        let x = fiberStartX + 20 - ((raySpeed + offset) % (segLen * 2));
        let goingDown = true;

        // Start from the beginning
        x = fiberStartX + 20;
        const startOffset = (raySpeed + offset) % (segLen * 2);
        goingDown = Math.floor(startOffset / segLen) % 2 === 0;

        const points = [];
        let curX = fiberStartX + 20;
        let curY = goingDown ? fiberY - coreH / 2 + 2 : fiberY + coreH / 2 - 2;
        let dir = goingDown ? 1 : -1;
        points.push({ x: curX, y: curY });

        while (curX < fiberEndX - 5) {
            const nextY = dir > 0 ? fiberY + coreH / 2 - 2 : fiberY - coreH / 2 + 2;
            const dx = Math.abs(nextY - curY) / Math.tan(bounceAngle);
            const nextX = curX + dx;
            points.push({ x: Math.min(nextX, fiberEndX - 5), y: nextX < fiberEndX - 5 ? nextY : curY + dir * (fiberEndX - 5 - curX) * Math.tan(bounceAngle) });
            curX = nextX;
            curY = nextY;
            dir *= -1;
        }

        // Draw the path
        ctx.strokeStyle = colors[c];
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();

        // Glow
        ctx.lineWidth = 8;
        ctx.globalAlpha = 0.1;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Photon traveling along path
        let totalLen = 0;
        const segLengths = [];
        for (let i = 1; i < points.length; i++) {
            const dx = points[i].x - points[i - 1].x;
            const dy = points[i].y - points[i - 1].y;
            const sl = Math.sqrt(dx * dx + dy * dy);
            segLengths.push(sl);
            totalLen += sl;
        }

        const photonPos = ((raySpeed * 0.5 + offset * 2) % totalLen);
        let accumulated = 0;
        for (let i = 0; i < segLengths.length; i++) {
            if (accumulated + segLengths[i] > photonPos) {
                const t = (photonPos - accumulated) / segLengths[i];
                const px = points[i].x + (points[i + 1].x - points[i].x) * t;
                const py = points[i].y + (points[i + 1].y - points[i].y) * t;
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, Math.PI * 2);
                ctx.fillStyle = colors[c];
                ctx.globalAlpha = 0.8;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Bright glow
                const grd = ctx.createRadialGradient(px, py, 0, px, py, 15);
                grd.addColorStop(0, colors[c].replace('#', 'rgba(') ? `${colors[c]}40` : 'rgba(255,255,255,0.2)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.beginPath();
                ctx.arc(px, py, 15, 0, Math.PI * 2);
                ctx.fillStyle = grd;
                ctx.fill();
                break;
            }
            accumulated += segLengths[i];
        }

        // Bounce highlight at each reflection point
        for (let i = 1; i < points.length - 1; i++) {
            const bp = points[i];
            const flash = Math.sin(animTime * 3 + i + c) * 0.5 + 0.5;
            ctx.beginPath();
            ctx.arc(bp.x, bp.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,${flash * 0.3})`;
            ctx.fill();
        }
    }

    // Labels
    ctx.fillStyle = 'rgba(60,180,220,0.7)';
    ctx.font = '13px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`Core (n = ${n.toFixed(2)})`, W * 0.5, fiberY + 5);
    ctx.fillStyle = 'rgba(80,120,180,0.6)';
    ctx.fillText('Cladding (n = 1.00)', W * 0.5, fiberY - fiberH / 2 - 10);
    ctx.fillText('Cladding (n = 1.00)', W * 0.5, fiberY + fiberH / 2 + 20);
    ctx.textAlign = 'left';

    ctx.fillStyle = 'rgba(255,200,100,0.6)';
    ctx.font = '14px Segoe UI';
    ctx.fillText('Fiber Optic Cable - Light bounces via TIR', W * 0.1, fiberY - fiberH / 2 - 40);

    ctx.fillStyle = 'rgba(200,200,220,0.4)';
    ctx.font = '12px Segoe UI';
    ctx.fillText(`Critical angle: ${getCriticalAngle().toFixed(1)}°`, W * 0.1, fiberY + fiberH / 2 + 50);
    ctx.fillText('Light entering at angles steeper than the critical angle is totally reflected', W * 0.1, fiberY + fiberH / 2 + 70);

    // Light source on left
    const grd = ctx.createRadialGradient(fiberStartX, fiberY, 0, fiberStartX, fiberY, 30);
    grd.addColorStop(0, 'rgba(255,255,200,0.4)');
    grd.addColorStop(1, 'rgba(255,255,200,0)');
    ctx.beginPath();
    ctx.arc(fiberStartX, fiberY, 30, 0, Math.PI * 2);
    ctx.fillStyle = grd;
    ctx.fill();

    // Detector on right
    ctx.fillStyle = 'rgba(100,255,100,0.3)';
    ctx.fillRect(fiberEndX - 2, fiberY - coreH / 2, 8, coreH);
    ctx.fillStyle = 'rgba(100,255,100,0.5)';
    ctx.font = '11px Segoe UI';
    ctx.fillText('Detector', fiberEndX + 10, fiberY + 4);
}

function drawRayWithGlow(x1, y1, x2, y2, color, alpha, width) {
    ctx.strokeStyle = color;
    ctx.globalAlpha = alpha;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.strokeStyle = color;
    ctx.globalAlpha = alpha * 0.2;
    ctx.lineWidth = width + 8;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.globalAlpha = 1;
}

function drawPhotons(x1, y1, x2, y2, color, speed) {
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const count = Math.max(3, Math.floor(len / 50));
    for (let i = 0; i < count; i++) {
        const t = ((animTime * speed + i / count) % 1);
        const px = x1 + dx * t;
        const py = y1 + dy * t;
        ctx.beginPath();
        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.4 + 0.4 * Math.sin(t * Math.PI);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

function drawArc(cx, cy, r, startAngle, endAngle, color, label) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    if (endAngle < startAngle) {
        ctx.arc(cx, cy, r, endAngle, startAngle);
    } else {
        ctx.arc(cx, cy, r, startAngle, endAngle);
    }
    ctx.stroke();

    const midAngle = (startAngle + endAngle) / 2;
    const lx = cx + (r + 18) * Math.cos(midAngle);
    const ly = cy + (r + 18) * Math.sin(midAngle);
    ctx.fillStyle = color;
    ctx.font = '12px Georgia';
    ctx.fillText(label, lx, ly);
}

function draw() {
    ctx.clearRect(0, 0, W, H);

    if (viewMode === 'boundary') {
        drawBoundaryView();
    } else {
        drawFiberView();
    }

    if (!paused) animTime += 0.016;
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}

window.reset = function() {
    n = 1.5; incAngleDeg = 45; viewMode = 'boundary';
    sN.value = 1.5; document.getElementById('vN').textContent = '1.50';
    sAngle.value = 45; document.getElementById('vAngle').textContent = '45';
    setView('boundary');
    animTime = 0; paused = false;
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
