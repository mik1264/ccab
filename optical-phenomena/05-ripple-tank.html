<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Ripple Tank - Optical Phenomena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; cursor: crosshair; }
        .back-link {
            position: fixed; top: 15px; left: 15px; color: #8af;
            text-decoration: none; font-size: 14px; z-index: 100;
            background: rgba(20,20,40,0.85); padding: 6px 14px;
            border-radius: 8px; backdrop-filter: blur(10px);
        }
        .back-link:hover { color: #bdf; }
        #controls {
            position: fixed; top: 15px; right: 15px;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 16px; z-index: 100;
            width: 260px; border: 1px solid rgba(100,140,255,0.15);
        }
        #controls h3 { color: #8af; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #aaa; }
        .control-group label span { color: #8af; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none;
            background: rgba(100,140,255,0.2); border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 50%; background: #8af; cursor: pointer;
        }
        .tool-row { display: flex; gap: 4px; margin-bottom: 10px; flex-wrap: wrap; }
        .tool-btn {
            flex: 1; min-width: 60px; padding: 6px 4px; border: 1px solid rgba(100,140,255,0.3);
            background: rgba(100,140,255,0.1); color: #8af; border-radius: 6px;
            font-size: 10px; cursor: pointer; transition: 0.2s; text-align: center;
        }
        .tool-btn:hover { background: rgba(100,140,255,0.25); }
        .tool-btn.active { background: rgba(100,140,255,0.35); border-color: #8af; }
        .preset-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 10px; }
        .preset-btn {
            padding: 6px 4px; border: 1px solid rgba(100,140,255,0.3);
            background: rgba(100,140,255,0.08); color: #7af; border-radius: 6px;
            font-size: 10px; cursor: pointer; transition: 0.2s; text-align: center;
        }
        .preset-btn:hover { background: rgba(100,140,255,0.2); }
        .section-label { color: #668; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin: 8px 0 4px; }
        #info {
            position: fixed; bottom: 15px; left: 15px;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 14px 18px; z-index: 100;
            max-width: 380px; border: 1px solid rgba(100,140,255,0.15);
            font-size: 12px; line-height: 1.6;
        }
        #info h4 { color: #8af; margin-bottom: 6px; font-size: 13px; }
        #info p { color: #bbb; }
        .status-bar {
            position: fixed; bottom: 15px; right: 15px;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 8px; padding: 8px 14px; z-index: 100;
            font-size: 11px; color: #888;
            border: 1px solid rgba(100,140,255,0.1);
        }
        .status-bar span { color: #8af; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Gallery</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>Ripple Tank</h3>

        <div class="section-label">Tool</div>
        <div class="tool-row">
            <button class="tool-btn active" data-tool="source">Source</button>
            <button class="tool-btn" data-tool="wall">Wall</button>
            <button class="tool-btn" data-tool="erase">Erase</button>
        </div>

        <div class="control-group">
            <label>Frequency <span id="freqVal">8.0</span></label>
            <input type="range" id="frequency" min="2" max="25" value="8" step="0.5">
        </div>
        <div class="control-group">
            <label>Wave Speed <span id="speedVal">1.0</span></label>
            <input type="range" id="speed" min="0.2" max="2.0" value="1.0" step="0.1">
        </div>
        <div class="control-group">
            <label>Damping <span id="dampVal">0.998</span></label>
            <input type="range" id="damping" min="980" max="1000" value="998" step="1">
        </div>
        <div class="control-group">
            <label>Color Mode <span id="colorVal">Blue-Red</span></label>
            <input type="range" id="colorMode" min="0" max="2" value="0" step="1">
        </div>

        <div class="section-label">Presets</div>
        <div class="preset-row">
            <button class="preset-btn" data-preset="single-slit">Single Slit</button>
            <button class="preset-btn" data-preset="double-slit">Double Slit</button>
            <button class="preset-btn" data-preset="obstacle">Obstacle</button>
            <button class="preset-btn" data-preset="two-source">Two Sources</button>
            <button class="preset-btn" data-preset="lens">Lens</button>
            <button class="preset-btn" data-preset="clear">Clear All</button>
        </div>
    </div>

    <div id="info">
        <h4>2D Ripple Tank</h4>
        <p>Click to place wave sources or draw barriers. Waves propagate using the
        2D wave equation, showing interference, diffraction around obstacles, and
        wave focusing. Try the presets to see classic wave phenomena.</p>
    </div>

    <div class="status-bar">
        Sources: <span id="srcCount">0</span> | Grid: <span id="gridSize">-</span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Simulation grid (lower res than screen for performance)
        const SCALE = 3; // each sim cell = SCALE x SCALE pixels
        let GW, GH;
        let current, previous, walls;
        let sources = [];
        let time = 0;
        let animId;
        let tool = 'source';
        let isDrawing = false;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GW = Math.floor(canvas.width / SCALE);
            GH = Math.floor(canvas.height / SCALE);
            initGrid();
            document.getElementById('gridSize').textContent = GW + 'x' + GH;
        }

        function initGrid() {
            const size = GW * GH;
            current = new Float32Array(size);
            previous = new Float32Array(size);
            walls = new Uint8Array(size);
        }

        resize();
        window.addEventListener('resize', resize);

        // Controls
        const els = {
            frequency: document.getElementById('frequency'),
            speed: document.getElementById('speed'),
            damping: document.getElementById('damping'),
            colorMode: document.getElementById('colorMode'),
            freqVal: document.getElementById('freqVal'),
            speedVal: document.getElementById('speedVal'),
            dampVal: document.getElementById('dampVal'),
            colorVal: document.getElementById('colorVal'),
            srcCount: document.getElementById('srcCount')
        };

        const colorModeNames = ['Blue-Red', 'Grayscale', 'Thermal'];

        function getParams() {
            return {
                freq: +els.frequency.value,
                speed: +els.speed.value,
                damp: +els.damping.value / 1000,
                colorIdx: +els.colorMode.value
            };
        }

        function updateLabels() {
            const p = getParams();
            els.freqVal.textContent = p.freq.toFixed(1);
            els.speedVal.textContent = p.speed.toFixed(1);
            els.dampVal.textContent = p.damp.toFixed(3);
            els.colorVal.textContent = colorModeNames[p.colorIdx];
        }

        [els.frequency, els.speed, els.damping, els.colorMode].forEach(e =>
            e.addEventListener('input', updateLabels));
        updateLabels();

        // Tool selection
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                tool = btn.dataset.tool;
                canvas.style.cursor = tool === 'source' ? 'crosshair' : (tool === 'wall' ? 'cell' : 'not-allowed');
            });
        });

        // Mouse/touch interaction
        function getGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
            return { gx: Math.floor(x / SCALE), gy: Math.floor(y / SCALE) };
        }

        function handleStart(e) {
            e.preventDefault();
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gy < 0 || gx >= GW || gy >= GH) return;

            if (tool === 'source') {
                sources.push({ gx, gy });
                els.srcCount.textContent = sources.length;
            } else if (tool === 'wall' || tool === 'erase') {
                isDrawing = true;
                applyDrawTool(gx, gy);
            }
        }

        function handleMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gy < 0 || gx >= GW || gy >= GH) return;
            applyDrawTool(gx, gy);
        }

        function handleEnd() {
            isDrawing = false;
        }

        function applyDrawTool(gx, gy) {
            const brush = 2; // brush radius
            for (let dy = -brush; dy <= brush; dy++) {
                for (let dx = -brush; dx <= brush; dx++) {
                    const nx = gx + dx;
                    const ny = gy + dy;
                    if (nx >= 0 && ny >= 0 && nx < GW && ny < GH) {
                        if (dx * dx + dy * dy <= brush * brush) {
                            const idx = ny * GW + nx;
                            if (tool === 'wall') {
                                walls[idx] = 1;
                            } else if (tool === 'erase') {
                                walls[idx] = 0;
                                // Also remove sources near this point
                                sources = sources.filter(s => {
                                    const d = Math.abs(s.gx - nx) + Math.abs(s.gy - ny);
                                    return d > 3;
                                });
                                els.srcCount.textContent = sources.length;
                            }
                        }
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);

        // Presets
        function clearAll() {
            sources = [];
            current.fill(0);
            previous.fill(0);
            walls.fill(0);
            els.srcCount.textContent = '0';
            time = 0;
        }

        function drawWallLine(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            for (let i = 0; i <= steps; i++) {
                const t = steps === 0 ? 0 : i / steps;
                const x = Math.round(x1 + dx * t);
                const y = Math.round(y1 + dy * t);
                for (let b = -1; b <= 1; b++) {
                    const nx = x + (Math.abs(dy) > Math.abs(dx) ? b : 0);
                    const ny = y + (Math.abs(dy) > Math.abs(dx) ? 0 : b);
                    if (nx >= 0 && ny >= 0 && nx < GW && ny < GH) {
                        walls[ny * GW + nx] = 1;
                    }
                }
            }
        }

        const presetFns = {
            'single-slit': () => {
                clearAll();
                const wallX = Math.floor(GW * 0.4);
                const slitY = Math.floor(GH * 0.5);
                const slitW = 12;
                drawWallLine(wallX, 0, wallX, slitY - slitW);
                drawWallLine(wallX, slitY + slitW, wallX, GH);
                sources.push({ gx: Math.floor(GW * 0.15), gy: slitY });
                els.srcCount.textContent = sources.length;
            },
            'double-slit': () => {
                clearAll();
                const wallX = Math.floor(GW * 0.4);
                const cy = Math.floor(GH * 0.5);
                const sep = 25;
                const slitW = 8;
                drawWallLine(wallX, 0, wallX, cy - sep - slitW);
                drawWallLine(wallX, cy - sep + slitW, wallX, cy + sep - slitW);
                drawWallLine(wallX, cy + sep + slitW, wallX, GH);
                sources.push({ gx: Math.floor(GW * 0.15), gy: cy });
                els.srcCount.textContent = sources.length;
            },
            'obstacle': () => {
                clearAll();
                const cx = Math.floor(GW * 0.45);
                const cy = Math.floor(GH * 0.5);
                const r = 20;
                for (let y = cy - r; y <= cy + r; y++) {
                    for (let x = cx - r; x <= cx + r; x++) {
                        if ((x - cx) * (x - cx) + (y - cy) * (y - cy) <= r * r) {
                            if (x >= 0 && y >= 0 && x < GW && y < GH) {
                                walls[y * GW + x] = 1;
                            }
                        }
                    }
                }
                sources.push({ gx: Math.floor(GW * 0.15), gy: cy });
                els.srcCount.textContent = sources.length;
            },
            'two-source': () => {
                clearAll();
                const cy = Math.floor(GH * 0.5);
                const sep = Math.floor(GH * 0.15);
                sources.push({ gx: Math.floor(GW * 0.3), gy: cy - sep });
                sources.push({ gx: Math.floor(GW * 0.3), gy: cy + sep });
                els.srcCount.textContent = sources.length;
            },
            'lens': () => {
                clearAll();
                const cx = Math.floor(GW * 0.45);
                const cy = Math.floor(GH * 0.5);
                const lensH = Math.floor(GH * 0.3);
                const curve = 15;
                for (let dy = -lensH; dy <= lensH; dy++) {
                    const t = dy / lensH;
                    const xOff = Math.round(curve * (1 - t * t));
                    for (let dx = -xOff; dx <= xOff; dx++) {
                        const gx = cx + dx;
                        const gy = cy + dy;
                        if (gx >= 0 && gy >= 0 && gx < GW && gy < GH) {
                            walls[gy * GW + gx] = 2; // lens material (slower wave speed)
                        }
                    }
                }
                sources.push({ gx: Math.floor(GW * 0.1), gy: cy });
                els.srcCount.textContent = sources.length;
            },
            'clear': () => { clearAll(); }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const p = btn.dataset.preset;
                if (presetFns[p]) presetFns[p]();
            });
        });

        // Simulation step: 2D wave equation using finite differences
        function simulate() {
            const p = getParams();
            const c2 = p.speed * p.speed * 0.2; // squared wave speed factor
            const damp = p.damp;

            const next = new Float32Array(GW * GH);

            for (let y = 1; y < GH - 1; y++) {
                for (let x = 1; x < GW - 1; x++) {
                    const idx = y * GW + x;
                    if (walls[idx] === 1) {
                        next[idx] = 0;
                        continue;
                    }

                    // Speed factor for lens regions
                    const localC2 = walls[idx] === 2 ? c2 * 0.5 : c2;

                    // Wave equation: u_next = 2*u - u_prev + c^2*(laplacian)
                    const laplacian = current[idx - 1] + current[idx + 1] +
                                     current[idx - GW] + current[idx + GW] -
                                     4 * current[idx];

                    next[idx] = (2 * current[idx] - previous[idx] + localC2 * laplacian) * damp;
                }
            }

            // Apply sources
            for (const s of sources) {
                const idx = s.gy * GW + s.gx;
                if (idx >= 0 && idx < GW * GH) {
                    next[idx] = Math.sin(time * p.freq * 0.1) * 2;
                }
            }

            // Absorbing boundary conditions
            for (let x = 0; x < GW; x++) {
                next[x] *= 0.8;
                next[(GH - 1) * GW + x] *= 0.8;
            }
            for (let y = 0; y < GH; y++) {
                next[y * GW] *= 0.8;
                next[y * GW + GW - 1] *= 0.8;
            }

            previous = current;
            current = next;
            time++;
        }

        function render() {
            const p = getParams();
            const imgData = ctx.createImageData(canvas.width, canvas.height);
            const data = imgData.data;

            for (let gy = 0; gy < GH; gy++) {
                for (let gx = 0; gx < GW; gx++) {
                    const idx = gy * GW + gx;
                    const wallType = walls[idx];
                    let r, g, b;

                    if (wallType === 1) {
                        r = 40; g = 40; b = 60;
                    } else if (wallType === 2) {
                        // Lens material - slightly tinted
                        const v = current[idx];
                        const mapped = v * 80;
                        r = 30 + Math.abs(mapped) * 0.3;
                        g = 40 + Math.abs(mapped) * 0.3;
                        b = 50 + mapped;
                    } else {
                        const v = current[idx];
                        if (p.colorIdx === 0) {
                            // Blue-Red
                            if (v > 0) {
                                r = Math.min(255, v * 120);
                                g = Math.min(255, v * 40);
                                b = 30;
                            } else {
                                r = 10;
                                g = Math.min(255, -v * 40);
                                b = Math.min(255, -v * 120);
                            }
                        } else if (p.colorIdx === 1) {
                            // Grayscale intensity
                            const intensity = Math.min(255, Math.abs(v) * 100);
                            r = intensity;
                            g = intensity;
                            b = intensity;
                        } else {
                            // Thermal
                            const norm = Math.tanh(v * 0.8);
                            if (norm > 0) {
                                r = Math.min(255, norm * 255);
                                g = Math.min(255, norm * 150);
                                b = 20;
                            } else {
                                r = 20;
                                g = Math.min(255, -norm * 100);
                                b = Math.min(255, -norm * 255);
                            }
                        }
                    }

                    // Fill SCALE x SCALE pixels
                    for (let py = 0; py < SCALE; py++) {
                        for (let px = 0; px < SCALE; px++) {
                            const sx = gx * SCALE + px;
                            const sy = gy * SCALE + py;
                            if (sx < canvas.width && sy < canvas.height) {
                                const pi = (sy * canvas.width + sx) * 4;
                                data[pi] = r;
                                data[pi + 1] = g;
                                data[pi + 2] = b;
                                data[pi + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imgData, 0, 0);

            // Draw source indicators on top
            ctx.fillStyle = 'rgba(255,255,100,0.8)';
            for (const s of sources) {
                ctx.beginPath();
                ctx.arc(s.gx * SCALE + SCALE / 2, s.gy * SCALE + SCALE / 2, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function animate() {
            // Multiple sim steps per frame for responsiveness
            for (let i = 0; i < 3; i++) {
                simulate();
            }
            render();
            animId = requestAnimationFrame(animate);
        }

        window.reset = function() {
            clearAll();
            els.frequency.value = 8;
            els.speed.value = 1.0;
            els.damping.value = 998;
            els.colorMode.value = 0;
            updateLabels();
        };

        // Start with double slit preset
        presetFns['double-slit']();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
