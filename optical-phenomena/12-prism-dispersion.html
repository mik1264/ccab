<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prism & Dispersion</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
canvas { display: block; }
#controls {
    position: fixed; top: 15px; right: 15px; width: 260px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2);
}
#controls h3 { color: #7eb8ff; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
.control-row { margin-bottom: 10px; }
.control-row label { display: block; font-size: 12px; color: #8ab4f8; margin-bottom: 3px; }
.control-row input[type="range"] { width: 100%; accent-color: #5b8def; }
.control-row .value { float: right; color: #ffd475; font-size: 12px; font-weight: bold; }
#info {
    position: fixed; bottom: 15px; left: 15px; width: 340px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2); font-size: 13px; line-height: 1.5;
}
#info h3 { color: #7eb8ff; margin-bottom: 8px; font-size: 14px; }
.equation { color: #ffd475; font-family: 'Georgia', serif; font-style: italic; text-align: center; margin: 8px 0; font-size: 15px; }
a.back { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); color: #7eb8ff; text-decoration: none; z-index: 20; font-size: 13px; }
a.back:hover { color: #ffd475; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back to Gallery</a>
<canvas id="c"></canvas>

<div id="controls">
    <h3>Prism Controls</h3>
    <div class="control-row">
        <label>Prism Angle: <span class="value" id="vAngle">60</span>°</label>
        <input type="range" id="sAngle" min="20" max="80" step="1" value="60">
    </div>
    <div class="control-row">
        <label>Base Refractive Index (A): <span class="value" id="vIndex">1.52</span></label>
        <input type="range" id="sIndex" min="1.3" max="2.0" step="0.01" value="1.52">
    </div>
    <div class="control-row">
        <label>Dispersion (B): <span class="value" id="vDisp">0.0045</span></label>
        <input type="range" id="sDisp" min="0.001" max="0.015" step="0.0005" value="0.0045">
    </div>
    <div class="control-row">
        <label>Beam Width: <span class="value" id="vBeam">3</span></label>
        <input type="range" id="sBeam" min="1" max="8" step="1" value="3">
    </div>
</div>

<div id="info">
    <h3>Newton's Prism Experiment (1666)</h3>
    <div class="equation">n(λ) = A + B / λ²</div>
    <p>White light is composed of all visible wavelengths. Each wavelength has a slightly different refractive index in glass (Cauchy's equation above).</p>
    <p style="margin-top:6px;">Shorter wavelengths (violet, ~380nm) bend more than longer wavelengths (red, ~700nm), separating white light into a continuous spectrum.</p>
    <p style="margin-top:6px; color:#8ab4f8;">Red bends least &mdash; Violet bends most</p>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let prismAngleDeg = 60;
let baseIndex = 1.52;
let dispersionB = 0.0045;
let beamWidth = 3;
let animTime = 0;
let paused = false;

const spectralColors = [
    { wl: 700, r: 255, g: 0, b: 0 },
    { wl: 650, r: 255, g: 80, b: 0 },
    { wl: 600, r: 255, g: 165, b: 0 },
    { wl: 570, r: 255, g: 230, b: 0 },
    { wl: 530, r: 80, g: 255, b: 0 },
    { wl: 500, r: 0, g: 220, b: 100 },
    { wl: 480, r: 0, g: 180, b: 255 },
    { wl: 450, r: 60, g: 60, b: 255 },
    { wl: 420, r: 100, g: 0, b: 255 },
    { wl: 390, r: 140, g: 0, b: 220 },
];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const sAngle = document.getElementById('sAngle');
const sIndex = document.getElementById('sIndex');
const sDisp = document.getElementById('sDisp');
const sBeam = document.getElementById('sBeam');

sAngle.addEventListener('input', () => { prismAngleDeg = parseInt(sAngle.value); document.getElementById('vAngle').textContent = prismAngleDeg; });
sIndex.addEventListener('input', () => { baseIndex = parseFloat(sIndex.value); document.getElementById('vIndex').textContent = baseIndex.toFixed(2); });
sDisp.addEventListener('input', () => { dispersionB = parseFloat(sDisp.value); document.getElementById('vDisp').textContent = dispersionB.toFixed(4); });
sBeam.addEventListener('input', () => { beamWidth = parseInt(sBeam.value); document.getElementById('vBeam').textContent = beamWidth; });

function cauchyIndex(wavelengthNm) {
    const wlMicron = wavelengthNm / 1000;
    return baseIndex + dispersionB / (wlMicron * wlMicron);
}

function getPrismVertices() {
    const cx = W * 0.45, cy = H * 0.5;
    const size = Math.min(W, H) * 0.22;
    const angle = prismAngleDeg * Math.PI / 180;
    const halfBase = size * Math.sin(angle / 2);
    const height = size * Math.cos(angle / 2) * 1.2;

    const top = { x: cx, y: cy - height * 0.5 };
    const bl = { x: cx - halfBase, y: cy + height * 0.5 };
    const br = { x: cx + halfBase, y: cy + height * 0.5 };
    return [top, bl, br];
}

function lineIntersect(p1, p2, p3, p4) {
    const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
    if (Math.abs(d) < 1e-10) return null;
    const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
    const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null;
    return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
}

function getSurfaceNormal(p1, p2) {
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    return { x: -dy / len, y: dx / len };
}

function refract(dirX, dirY, nx, ny, n1, n2) {
    const dot = dirX * nx + dirY * ny;
    let normalX = nx, normalY = ny;
    let ratio = n1 / n2;
    let cosI = -dot;
    if (cosI < 0) {
        normalX = -nx; normalY = -ny;
        cosI = -cosI;
        // Don't swap ratio since we handle this by flipping normal
    }
    const sinT2 = ratio * ratio * (1 - cosI * cosI);
    if (sinT2 > 1) return null;
    const cosT = Math.sqrt(1 - sinT2);
    return {
        x: ratio * dirX + (ratio * cosI - cosT) * normalX,
        y: ratio * dirY + (ratio * cosI - cosT) * normalY
    };
}

function drawPrism(verts) {
    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    ctx.lineTo(verts[1].x, verts[1].y);
    ctx.lineTo(verts[2].x, verts[2].y);
    ctx.closePath();

    const grad = ctx.createLinearGradient(verts[0].x, verts[0].y, verts[1].x, verts[1].y);
    grad.addColorStop(0, 'rgba(160,200,255,0.12)');
    grad.addColorStop(0.5, 'rgba(200,220,255,0.18)');
    grad.addColorStop(1, 'rgba(160,200,255,0.08)');
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.strokeStyle = 'rgba(180,210,255,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Glass sheen
    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    ctx.lineTo(verts[1].x, verts[1].y);
    ctx.strokeStyle = 'rgba(200,230,255,0.25)';
    ctx.lineWidth = 3;
    ctx.stroke();
}

function traceRay(entryPoint, dirX, dirY, wavelength, color, verts) {
    const n = cauchyIndex(wavelength);

    // Find entry on left face (top to bottom-left)
    const leftFaceP1 = verts[0], leftFaceP2 = verts[1];
    const farPoint = { x: entryPoint.x + dirX * 2000, y: entryPoint.y + dirY * 2000 };
    const entry = lineIntersect(entryPoint, farPoint, leftFaceP1, leftFaceP2);
    if (!entry) return;

    // Normal of left face (pointing outward - to the left)
    let norm = getSurfaceNormal(leftFaceP1, leftFaceP2);
    // Ensure normal points outward (away from prism center)
    const cx = (verts[0].x + verts[1].x + verts[2].x) / 3;
    const cy = (verts[0].y + verts[1].y + verts[2].y) / 3;
    if (norm.x * (entry.x - cx) + norm.y * (entry.y - cy) < 0) {
        norm.x = -norm.x; norm.y = -norm.y;
    }

    // Refract into prism
    const refDir = refract(dirX, dirY, norm.x, norm.y, 1.0, n);
    if (!refDir) return;

    // Find exit on right face (top to bottom-right)
    const rightFaceP1 = verts[0], rightFaceP2 = verts[2];
    const bottomFace1 = verts[1], bottomFace2 = verts[2];
    const farExit = { x: entry.x + refDir.x * 2000, y: entry.y + refDir.y * 2000 };

    let exit = lineIntersect(entry, farExit, rightFaceP1, rightFaceP2);
    let exitFace1 = rightFaceP1, exitFace2 = rightFaceP2;
    if (!exit) {
        exit = lineIntersect(entry, farExit, bottomFace1, bottomFace2);
        exitFace1 = bottomFace1; exitFace2 = bottomFace2;
    }
    if (!exit) return;

    // Normal of exit face
    let norm2 = getSurfaceNormal(exitFace1, exitFace2);
    if (norm2.x * (exit.x - cx) + norm2.y * (exit.y - cy) < 0) {
        norm2.x = -norm2.x; norm2.y = -norm2.y;
    }

    // Refract out of prism
    const exitDir = refract(refDir.x, refDir.y, -norm2.x, -norm2.y, n, 1.0);
    if (!exitDir) return;

    // Draw incident ray (white)
    ctx.strokeStyle = `rgba(255,255,240,0.25)`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(entryPoint.x, entryPoint.y);
    ctx.lineTo(entry.x, entry.y);
    ctx.stroke();

    // Draw ray inside prism
    ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},0.3)`;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(entry.x, entry.y);
    ctx.lineTo(exit.x, exit.y);
    ctx.stroke();

    // Draw dispersed ray
    const exitLen = 600;
    const ex2 = exit.x + exitDir.x * exitLen;
    const ey2 = exit.y + exitDir.y * exitLen;

    ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},0.8)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(exit.x, exit.y);
    ctx.lineTo(ex2, ey2);
    ctx.stroke();

    // Glow
    ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},0.2)`;
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(exit.x, exit.y);
    ctx.lineTo(ex2, ey2);
    ctx.stroke();

    // Photons
    const pCount = 4;
    for (let i = 0; i < pCount; i++) {
        const t = ((animTime * 0.2 + i / pCount + wavelength * 0.001) % 1);
        const px = exit.x + (ex2 - exit.x) * t;
        const py = exit.y + (ey2 - exit.y) * t;
        ctx.beginPath();
        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${0.3 + 0.4 * Math.sin(t * Math.PI)})`;
        ctx.fill();
    }
}

function draw() {
    ctx.clearRect(0, 0, W, H);

    const verts = getPrismVertices();

    // Draw white beam entering from left
    const beamY = H * 0.48;
    const entryX = W * 0.05;

    // Draw white combined beam
    for (let b = -beamWidth; b <= beamWidth; b++) {
        const yOff = b * 2;
        ctx.strokeStyle = `rgba(255,255,240,${0.4 - Math.abs(b) * 0.05})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(entryX, beamY + yOff);
        ctx.lineTo(verts[0].x - 20, beamY + yOff);
        ctx.stroke();
    }

    // White beam glow
    ctx.strokeStyle = 'rgba(255,255,240,0.15)';
    ctx.lineWidth = beamWidth * 6;
    ctx.beginPath();
    ctx.moveTo(entryX, beamY);
    ctx.lineTo(verts[0].x - 20, beamY);
    ctx.stroke();

    // Beam photons
    for (let i = 0; i < 8; i++) {
        const t = ((animTime * 0.3 + i / 8) % 1);
        const px = entryX + (verts[0].x - 20 - entryX) * t;
        ctx.beginPath();
        ctx.arc(px, beamY, 3, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,220,${0.3 + 0.3 * Math.sin(t * Math.PI)})`;
        ctx.fill();
    }

    // Label
    ctx.fillStyle = 'rgba(255,255,240,0.5)';
    ctx.font = '12px Segoe UI';
    ctx.fillText('White Light', entryX + 20, beamY - 15);

    // Trace each color through prism
    for (let b = -beamWidth; b <= beamWidth; b++) {
        const yOff = b * 2;
        for (const sc of spectralColors) {
            const entry = { x: entryX, y: beamY + yOff };
            traceRay(entry, 1, 0, sc.wl, sc, verts);
        }
    }

    // Draw prism on top
    drawPrism(verts);

    // Wavelength labels on exit side
    const labelX = W * 0.8;
    if (labelX < W - 100) {
        ctx.font = '11px Segoe UI';
        ctx.fillStyle = 'rgba(255,80,80,0.7)';
        ctx.fillText('Red (700nm)', labelX, H * 0.38);
        ctx.fillStyle = 'rgba(140,0,220,0.7)';
        ctx.fillText('Violet (390nm)', labelX, H * 0.58);
    }

    if (!paused) animTime += 0.016;
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}

window.reset = function() {
    prismAngleDeg = 60; baseIndex = 1.52; dispersionB = 0.0045; beamWidth = 3;
    sAngle.value = 60; document.getElementById('vAngle').textContent = '60';
    sIndex.value = 1.52; document.getElementById('vIndex').textContent = '1.52';
    sDisp.value = 0.0045; document.getElementById('vDisp').textContent = '0.0045';
    sBeam.value = 3; document.getElementById('vBeam').textContent = '3';
    animTime = 0; paused = false;
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
