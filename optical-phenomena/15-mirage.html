<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mirage Simulation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
canvas { display: block; }
#controls {
    position: fixed; top: 15px; right: 15px; width: 260px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2);
}
#controls h3 { color: #7eb8ff; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
.control-row { margin-bottom: 10px; }
.control-row label { display: block; font-size: 12px; color: #8ab4f8; margin-bottom: 3px; }
.control-row input[type="range"] { width: 100%; accent-color: #5b8def; }
.control-row .value { float: right; color: #ffd475; font-size: 12px; font-weight: bold; }
.view-btn {
    display: inline-block; padding: 5px 10px; margin: 3px; border-radius: 6px; cursor: pointer;
    background: rgba(80,120,200,0.25); border: 1px solid rgba(100,140,255,0.3);
    color: #8ab4f8; font-size: 11px;
}
.view-btn:hover, .view-btn.active { background: rgba(80,120,200,0.5); color: #fff; }
#info {
    position: fixed; bottom: 15px; left: 15px; width: 340px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2); font-size: 13px; line-height: 1.5;
}
#info h3 { color: #7eb8ff; margin-bottom: 8px; font-size: 14px; }
a.back { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); color: #7eb8ff; text-decoration: none; z-index: 20; font-size: 13px; }
a.back:hover { color: #ffd475; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back to Gallery</a>
<canvas id="c"></canvas>

<div id="controls">
    <h3>Mirage Controls</h3>
    <div class="control-row">
        <label>Temperature Gradient: <span class="value" id="vGrad">0.70</span></label>
        <input type="range" id="sGrad" min="0.1" max="1.5" step="0.05" value="0.7">
    </div>
    <div class="control-row">
        <label>Observer Height: <span class="value" id="vHeight">1.7</span>m</label>
        <input type="range" id="sHeight" min="0.5" max="4.0" step="0.1" value="1.7">
    </div>
    <div class="control-row">
        <label>Object Distance: <span class="value" id="vDist">500</span>m</label>
        <input type="range" id="sDist" min="100" max="2000" step="50" value="500">
    </div>
    <div style="margin-top:12px;">
        <span style="font-size:12px;color:#8ab4f8;">Type:</span><br>
        <span class="view-btn active" id="btnInferior" onclick="setType('inferior')">Inferior</span>
        <span class="view-btn" id="btnSuperior" onclick="setType('superior')">Superior</span>
    </div>
</div>

<div id="info">
    <h3>Mirage Formation</h3>
    <p><strong style="color:#ff8080;">Inferior mirage:</strong> Hot ground heats air near surface, lowering its density and refractive index. Light curves upward, creating an inverted image below the horizon (desert, hot roads).</p>
    <p style="margin-top:6px;"><strong style="color:#8080ff;">Superior mirage (Fata Morgana):</strong> Cold surface (ice, cold water) cools air below, creating an inversion layer. Light curves downward, making distant objects appear elevated or distorted.</p>
    <p style="margin-top:6px;">Both effects arise because <strong style="color:#ffd475;">n decreases as temperature increases</strong>, and light bends toward denser (cooler) air.</p>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let tempGradient = 0.7;
let observerHeight = 1.7;
let objectDistance = 500;
let mirageType = 'inferior';
let animTime = 0;
let paused = false;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const sGrad = document.getElementById('sGrad');
const sHeight = document.getElementById('sHeight');
const sDist = document.getElementById('sDist');

sGrad.addEventListener('input', () => { tempGradient = parseFloat(sGrad.value); document.getElementById('vGrad').textContent = tempGradient.toFixed(2); });
sHeight.addEventListener('input', () => { observerHeight = parseFloat(sHeight.value); document.getElementById('vHeight').textContent = observerHeight.toFixed(1); });
sDist.addEventListener('input', () => { objectDistance = parseInt(sDist.value); document.getElementById('vDist').textContent = objectDistance; });

function setType(t) {
    mirageType = t;
    document.getElementById('btnInferior').classList.toggle('active', t === 'inferior');
    document.getElementById('btnSuperior').classList.toggle('active', t === 'superior');
}
window.setType = setType;

function getRefractiveIndex(height) {
    // n decreases with temperature increase
    // Inferior: hot at ground → n increases with height
    // Superior: cold at ground → n decreases with height (inversion)
    const baseN = 1.000293;
    if (mirageType === 'inferior') {
        // Hot ground: n is lower near ground, higher up
        const h = Math.max(0, height);
        return baseN - tempGradient * 0.0001 * Math.exp(-h * 0.3);
    } else {
        // Cold surface: n is higher near surface, lower above (inversion)
        const h = Math.max(0, height);
        return baseN + tempGradient * 0.00008 * Math.exp(-h * 0.2);
    }
}

function getTemperature(height) {
    const baseTemp = 20;
    if (mirageType === 'inferior') {
        return baseTemp + tempGradient * 40 * Math.exp(-Math.max(0, height) * 0.3);
    } else {
        return baseTemp - tempGradient * 20 * Math.exp(-Math.max(0, height) * 0.2);
    }
}

function traceRay(startX, startY, angleDeg, steps, dt) {
    // Ray tracing through gradient medium using Euler method
    const points = [];
    let x = startX, y = startY;
    let angle = angleDeg * Math.PI / 180;
    let vx = Math.cos(angle);
    let vy = Math.sin(angle);

    for (let i = 0; i < steps; i++) {
        points.push({ x, y });

        // Get n at current height and slightly above/below
        const dy = 0.05;
        const nHere = getRefractiveIndex(y);
        const nAbove = getRefractiveIndex(y + dy);
        const dndy = (nAbove - nHere) / dy;

        // Snell's law in continuous form: ray curves toward higher n
        // d(theta)/ds = -(1/n) * dn/dy * cos(theta)
        const curvature = -(1 / nHere) * dndy;

        // Update direction (the ray curves)
        const dAngle = curvature * dt * Math.abs(vx);
        vy += dAngle * dt * 500;

        // Renormalize
        const mag = Math.sqrt(vx * vx + vy * vy);
        vx /= mag;
        vy /= mag;

        x += vx * dt;
        y += vy * dt;

        if (y < -2 || y > 20 || x > objectDistance * 1.2 || x < -10) break;
    }

    return points;
}

function worldToScreen(wx, wy) {
    const groundY = H * 0.72;
    const scale = W * 0.8 / objectDistance;
    const heightScale = H * 0.08;
    return {
        x: W * 0.1 + wx * scale,
        y: groundY - wy * heightScale
    };
}

function drawScene() {
    const groundY = H * 0.72;

    // Sky
    const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
    if (mirageType === 'inferior') {
        skyGrad.addColorStop(0, '#1a2a4a');
        skyGrad.addColorStop(0.5, '#2a3a5a');
        skyGrad.addColorStop(1, '#4a5a7a');
    } else {
        skyGrad.addColorStop(0, '#0a1a3a');
        skyGrad.addColorStop(0.5, '#1a2a4a');
        skyGrad.addColorStop(1, '#2a3a5a');
    }
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, groundY);

    // Ground
    if (mirageType === 'inferior') {
        const gGrad = ctx.createLinearGradient(0, groundY, 0, H);
        gGrad.addColorStop(0, '#8a7a50');
        gGrad.addColorStop(1, '#5a4a30');
        ctx.fillStyle = gGrad;
    } else {
        const gGrad = ctx.createLinearGradient(0, groundY, 0, H);
        gGrad.addColorStop(0, '#4a5a6a');
        gGrad.addColorStop(1, '#2a3a4a');
        ctx.fillStyle = gGrad;
    }
    ctx.fillRect(0, groundY, W, H - groundY);

    // Heat shimmer (inferior mirage)
    if (mirageType === 'inferior') {
        for (let x = 0; x < W; x += 4) {
            const shimmer = Math.sin(x * 0.02 + animTime * 3) * Math.sin(x * 0.05 + animTime * 2);
            const intensity = shimmer * 0.05 * tempGradient;
            ctx.fillStyle = `rgba(255,240,200,${Math.abs(intensity)})`;
            const sy = groundY - 5 + shimmer * 3;
            ctx.fillRect(x, sy, 3, 8);
        }
    }

    // Temperature gradient visualization (right side)
    const tempBarX = W * 0.94;
    const tempBarW = 15;
    const tempBarTop = groundY - 200;
    const tempBarBot = groundY + 20;

    for (let y = tempBarTop; y < tempBarBot; y++) {
        const worldH = (groundY - y) / (H * 0.08);
        const temp = getTemperature(worldH);
        const t = (temp - 0) / 80;
        const r = Math.floor(t * 255);
        const b = Math.floor((1 - t) * 255);
        ctx.fillStyle = `rgba(${r},80,${b},0.5)`;
        ctx.fillRect(tempBarX, y, tempBarW, 1);
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.strokeRect(tempBarX, tempBarTop, tempBarW, tempBarBot - tempBarTop);
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '10px Segoe UI';
    ctx.fillText('Hot', tempBarX, tempBarBot + 12);
    ctx.fillText('Cool', tempBarX, tempBarTop - 5);
    ctx.fillText('Temp', tempBarX - 2, tempBarTop - 18);

    // Draw distant object (e.g., a tree/building)
    const objScreen = worldToScreen(objectDistance * 0.85, 0);
    const objHeight = 80;

    // Tree trunk
    ctx.fillStyle = 'rgba(80,60,40,0.7)';
    ctx.fillRect(objScreen.x - 4, objScreen.y - objHeight, 8, objHeight);
    // Tree canopy
    ctx.beginPath();
    ctx.arc(objScreen.x, objScreen.y - objHeight - 15, 20, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(40,120,50,0.6)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(objScreen.x - 12, objScreen.y - objHeight, 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(objScreen.x + 12, objScreen.y - objHeight, 15, 0, Math.PI * 2);
    ctx.fill();

    // Second distant object
    const obj2Screen = worldToScreen(objectDistance * 0.65, 0);
    ctx.fillStyle = 'rgba(70,80,100,0.5)';
    ctx.fillRect(obj2Screen.x - 15, obj2Screen.y - 60, 30, 60);
    ctx.fillRect(obj2Screen.x - 20, obj2Screen.y - 65, 40, 8);

    // Observer
    const obsScreen = worldToScreen(0, observerHeight);
    ctx.fillStyle = 'rgba(200,200,220,0.6)';
    ctx.beginPath();
    ctx.arc(obsScreen.x, obsScreen.y - 10, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(obsScreen.x - 2, obsScreen.y - 4, 4, 20);
    const obsGround = worldToScreen(0, 0);
    ctx.fillRect(obsScreen.x - 4, obsGround.y - 2, 8, 4);
    ctx.fillStyle = 'rgba(255,255,200,0.5)';
    ctx.font = '12px Segoe UI';
    ctx.fillText('Observer', obsScreen.x - 20, obsGround.y + 20);
    ctx.fillText(`${observerHeight.toFixed(1)}m`, obsScreen.x + 10, obsScreen.y);

    // Trace rays from object to observer
    const numRays = 12;
    const rayColors = [
        'rgba(255,200,80,', 'rgba(255,160,60,', 'rgba(200,255,80,',
        'rgba(80,200,255,', 'rgba(180,80,255,', 'rgba(255,80,120,'
    ];

    for (let i = 0; i < numRays; i++) {
        const startHeight = 0.5 + (i / numRays) * 6;
        const startX = objectDistance * 0.85;

        // Aim roughly toward observer
        const dx = -startX;
        const dy = observerHeight - startHeight;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI;
        // Add some spread
        angle += (i - numRays / 2) * 0.5;

        const points = traceRay(startX, startHeight, angle, 2000, objectDistance * 0.001);

        if (points.length < 2) continue;

        const colorIdx = i % rayColors.length;
        const color = rayColors[colorIdx];

        // Convert to screen coords and draw
        ctx.beginPath();
        let first = true;
        for (const p of points) {
            const sp = worldToScreen(p.x, p.y);
            if (sp.x < -20 || sp.x > W + 20) continue;
            if (first) { ctx.moveTo(sp.x, sp.y); first = false; }
            else ctx.lineTo(sp.x, sp.y);
        }
        ctx.strokeStyle = color + '0.5)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Glow
        ctx.strokeStyle = color + '0.1)';
        ctx.lineWidth = 6;
        ctx.stroke();

        // Photon along ray
        const pIdx = Math.floor(((animTime * 100 + i * 50) % points.length));
        if (pIdx < points.length) {
            const pp = worldToScreen(points[pIdx].x, points[pIdx].y);
            ctx.beginPath();
            ctx.arc(pp.x, pp.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = color + '0.7)';
            ctx.fill();
        }
    }

    // Draw mirage image
    if (mirageType === 'inferior') {
        // Inverted, shimmering image below ground line
        ctx.globalAlpha = 0.25 + 0.05 * Math.sin(animTime * 2);
        ctx.save();
        ctx.translate(0, groundY * 2);
        ctx.scale(1, -1);

        // Mirrored tree (distorted)
        const shimX = Math.sin(animTime * 3) * 3;
        ctx.fillStyle = 'rgba(80,60,40,0.3)';
        ctx.fillRect(objScreen.x - 4 + shimX, objScreen.y - objHeight, 8, objHeight * 0.7);
        ctx.beginPath();
        ctx.arc(objScreen.x + shimX, objScreen.y - objHeight - 15, 20, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(40,120,50,0.25)';
        ctx.fill();

        // Mirrored building
        const shimX2 = Math.sin(animTime * 2.5 + 1) * 4;
        ctx.fillStyle = 'rgba(70,80,100,0.2)';
        ctx.fillRect(obj2Screen.x - 15 + shimX2, obj2Screen.y - 45, 30, 45);

        ctx.restore();
        ctx.globalAlpha = 1;

        // "Water" shimmer on ground
        for (let x = W * 0.3; x < W * 0.85; x += 2) {
            const shimmer = Math.sin(x * 0.03 + animTime * 4) * Math.cos(x * 0.07 + animTime * 2.5);
            const intensity = 0.03 + shimmer * 0.03;
            ctx.fillStyle = `rgba(140,180,220,${Math.max(0, intensity * tempGradient)})`;
            ctx.fillRect(x, groundY + shimmer * 2, 2, 3);
        }

        ctx.fillStyle = 'rgba(140,180,220,0.4)';
        ctx.font = '12px Segoe UI';
        ctx.fillText('Apparent "water" (inverted image)', W * 0.35, groundY + 30);
    } else {
        // Superior mirage: objects appear elevated and sometimes inverted above
        const elevOffset = tempGradient * 30;
        ctx.globalAlpha = 0.3 + 0.05 * Math.sin(animTime * 1.5);

        // Elevated tree image
        const shimX = Math.sin(animTime * 2) * 2;
        ctx.fillStyle = 'rgba(80,60,40,0.25)';
        ctx.fillRect(objScreen.x - 4 + shimX, objScreen.y - objHeight - elevOffset - 30, 8, 30);
        ctx.beginPath();
        ctx.arc(objScreen.x + shimX, objScreen.y - objHeight - elevOffset - 40, 16, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(40,120,50,0.2)';
        ctx.fill();

        // Inverted copy above that (Fata Morgana layering)
        ctx.save();
        ctx.translate(0, (objScreen.y - objHeight - elevOffset - 60) * 2);
        ctx.scale(1, -1);
        ctx.fillStyle = 'rgba(80,60,40,0.15)';
        ctx.fillRect(objScreen.x - 3, objScreen.y - objHeight - elevOffset - 30, 6, 25);
        ctx.beginPath();
        ctx.arc(objScreen.x, objScreen.y - objHeight - elevOffset - 35, 12, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(40,120,50,0.12)';
        ctx.fill();
        ctx.restore();

        ctx.globalAlpha = 1;

        ctx.fillStyle = 'rgba(150,180,255,0.4)';
        ctx.font = '12px Segoe UI';
        ctx.fillText('Fata Morgana (elevated/inverted)', W * 0.35, groundY - 250);
    }

    // Atmosphere layer visualization
    const layerAlpha = 0.05;
    const numLayers = 8;
    for (let i = 0; i < numLayers; i++) {
        const layerY = groundY - (i + 1) * 20;
        const temp = getTemperature((i + 1) * 0.3);
        const warm = (temp - 10) / 50;
        ctx.fillStyle = `rgba(${Math.floor(warm * 200 + 55)},${Math.floor(100 - warm * 30)},${Math.floor(200 - warm * 150)},${layerAlpha})`;
        ctx.fillRect(W * 0.05, layerY, W * 0.88, 20);
    }
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.font = '10px Segoe UI';
    ctx.fillText('Air layers (color = temperature)', W * 0.05, groundY - numLayers * 20 - 8);

    // Title
    ctx.fillStyle = 'rgba(255,200,100,0.6)';
    ctx.font = '16px Segoe UI';
    const title = mirageType === 'inferior' ? 'Inferior Mirage (Hot Ground)' : 'Superior Mirage / Fata Morgana (Cold Surface)';
    ctx.fillText(title, W * 0.05, 35);
}

function draw() {
    ctx.clearRect(0, 0, W, H);
    drawScene();
    if (!paused) animTime += 0.016;
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}

window.reset = function() {
    tempGradient = 0.7; observerHeight = 1.7; objectDistance = 500; mirageType = 'inferior';
    sGrad.value = 0.7; document.getElementById('vGrad').textContent = '0.70';
    sHeight.value = 1.7; document.getElementById('vHeight').textContent = '1.7';
    sDist.value = 500; document.getElementById('vDist').textContent = '500';
    setType('inferior');
    animTime = 0; paused = false;
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
