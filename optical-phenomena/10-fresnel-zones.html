<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fresnel Zones - Optical Phenomena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none;
            font-size: 14px; z-index: 1000; opacity: 0.8; transition: opacity 0.3s;
        }
        .back-link:hover { opacity: 1; }
        .controls {
            position: fixed; top: 15px; right: 15px; z-index: 1000;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border: 1px solid rgba(100,140,255,0.2); border-radius: 12px;
            padding: 16px; min-width: 260px;
        }
        .controls h3 { color: #8ab4f8; font-size: 14px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; font-size: 12px; color: #aaa; margin-bottom: 4px; }
        .control-group input[type="range"] { width: 100%; accent-color: #8ab4f8; }
        .control-group .value { float: right; color: #8ab4f8; font-size: 12px; font-family: monospace; }
        .toggle-group { margin-bottom: 10px; display: flex; gap: 8px; flex-wrap: wrap; }
        .toggle-btn {
            padding: 4px 10px; border: 1px solid rgba(100,140,255,0.3); border-radius: 6px;
            background: rgba(20,20,40,0.6); color: #aaa; font-size: 11px; cursor: pointer; flex: 1; text-align: center;
        }
        .toggle-btn.active { background: rgba(100,140,255,0.3); color: #8ab4f8; border-color: #8ab4f8; }
        .info-panel {
            position: fixed; bottom: 15px; left: 15px; z-index: 1000;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border: 1px solid rgba(100,140,255,0.2); border-radius: 12px;
            padding: 16px; max-width: 400px;
        }
        .info-panel h3 { color: #8ab4f8; font-size: 14px; margin-bottom: 8px; }
        .info-panel p { font-size: 12px; color: #bbb; line-height: 1.5; margin-bottom: 6px; }
        .formula { font-family: monospace; color: #f0c060; font-size: 13px; padding: 4px 0; }
        .amplitude-display {
            margin-top: 8px; padding: 6px; background: rgba(0,0,0,0.3);
            border-radius: 6px; font-family: monospace; font-size: 12px; color: #8ab4f8;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Optical Phenomena</a>

    <div class="controls">
        <h3>Fresnel Zones</h3>
        <div class="control-group">
            <label>Wavelength <span class="value" id="wlVal">550 nm</span></label>
            <input type="range" id="wavelength" min="380" max="780" value="550" step="5">
        </div>
        <div class="control-group">
            <label>Focal Distance <span class="value" id="fVal">1.0 m</span></label>
            <input type="range" id="focal" min="0.3" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Number of Zones <span class="value" id="nVal">10</span></label>
            <input type="range" id="numZones" min="3" max="30" value="10" step="1">
        </div>
        <div class="toggle-group">
            <div class="toggle-btn active" id="btnOpen" onclick="setPlateMode('open')">All Open</div>
            <div class="toggle-btn" id="btnPlate" onclick="setPlateMode('plate')">Zone Plate</div>
            <div class="toggle-btn" id="btnOdd" onclick="setPlateMode('odd')">Odd Only</div>
        </div>
        <div class="control-group">
            <label>Animation Speed <span class="value" id="spdVal">1.0x</span></label>
            <input type="range" id="speed" min="0.1" max="3" value="1" step="0.1">
        </div>
        <div class="amplitude-display" id="ampDisplay">Total amplitude at focus: --</div>
    </div>

    <div class="info-panel">
        <h3>Fresnel Zone Plate</h3>
        <p>A wavefront can be divided into concentric Fresnel zones. Adjacent zones contribute amplitudes of opposite sign (constructive vs destructive). By blocking alternate zones, you create a zone plate that focuses light -- acting as a lens without any refraction!</p>
        <div class="formula">r&#8345; = &radic;(n&lambda;f)</div>
        <p>Where r_n = radius of nth zone, f = focal distance. Odd zones add constructively at the focal point. Blocking even zones doubles the intensity there.</p>
        <div class="formula">Zone plate focal length: f = r&#8321;&sup2;/&lambda;</div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        let time = 0;
        let animId;
        let plateMode = 'open';

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function setPlateMode(m) {
            plateMode = m;
            document.getElementById('btnOpen').classList.toggle('active', m === 'open');
            document.getElementById('btnPlate').classList.toggle('active', m === 'plate');
            document.getElementById('btnOdd').classList.toggle('active', m === 'odd');
        }

        function wavelengthToRGB(nm) {
            let r = 0, g = 0, b = 0;
            if (nm >= 380 && nm < 440) { r = -(nm - 440) / (440 - 380); b = 1; }
            else if (nm >= 440 && nm < 490) { g = (nm - 440) / (490 - 440); b = 1; }
            else if (nm >= 490 && nm < 510) { g = 1; b = -(nm - 510) / (510 - 490); }
            else if (nm >= 510 && nm < 580) { r = (nm - 510) / (580 - 510); g = 1; }
            else if (nm >= 580 && nm < 645) { r = 1; g = -(nm - 645) / (645 - 580); }
            else if (nm >= 645 && nm <= 780) { r = 1; }
            let factor = 1;
            if (nm >= 380 && nm < 420) factor = 0.3 + 0.7 * (nm - 380) / (420 - 380);
            else if (nm > 700) factor = 0.3 + 0.7 * (780 - nm) / (780 - 700);
            return [r * factor, g * factor, b * factor];
        }

        function draw() {
            const lambda = parseFloat(document.getElementById('wavelength').value);
            const f = parseFloat(document.getElementById('focal').value);
            const N = parseInt(document.getElementById('numZones').value);
            const speed = parseFloat(document.getElementById('speed').value);

            document.getElementById('wlVal').textContent = lambda + ' nm';
            document.getElementById('fVal').textContent = f.toFixed(1) + ' m';
            document.getElementById('nVal').textContent = N;
            document.getElementById('spdVal').textContent = speed.toFixed(1) + 'x';

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            const [cr, cg, cb] = wavelengthToRGB(lambda);

            // Zone plate visualization (left)
            const plateCX = W * 0.22;
            const plateCY = H * 0.45;
            const maxR = Math.min(W * 0.18, H * 0.38);

            // Calculate zone radii: r_n = sqrt(n * lambda_um * f_um)
            // We scale for visual purposes
            const zoneRadii = [];
            for (let n = 1; n <= N; n++) {
                zoneRadii.push(maxR * Math.sqrt(n / N));
            }

            // Draw zones from outside in
            for (let n = N - 1; n >= 0; n--) {
                const r = zoneRadii[n];
                const isOdd = (n % 2 === 0); // zone 1 is odd (n=0 index)
                let blocked = false;

                if (plateMode === 'plate' && !isOdd) blocked = true;
                if (plateMode === 'odd' && !isOdd) blocked = true;

                ctx.beginPath();
                ctx.arc(plateCX, plateCY, r, 0, Math.PI * 2);
                if (blocked) {
                    ctx.fillStyle = 'rgba(20,20,40,0.9)';
                } else {
                    const alpha = isOdd ? 0.3 : 0.15;
                    ctx.fillStyle = isOdd
                        ? `rgba(${Math.round(cr*200)},${Math.round(cg*200)},${Math.round(cb*200)},${alpha})`
                        : `rgba(${Math.round(cr*100)},${Math.round(cg*100)},${Math.round(cb*100)},${alpha})`;
                }
                ctx.fill();

                // Zone boundary
                ctx.beginPath();
                ctx.arc(plateCX, plateCY, r, 0, Math.PI * 2);
                ctx.strokeStyle = isOdd ? `rgba(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)},0.4)` : 'rgba(100,100,150,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Label a few zones
                if (n < 5) {
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px monospace';
                    const labelR = n > 0 ? (zoneRadii[n] + (n > 0 ? zoneRadii[n-1] : 0)) / 2 : zoneRadii[0] / 2;
                    ctx.fillText((n + 1).toString(), plateCX + labelR - 3, plateCY + 4);
                }
            }

            // Zone plate label
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Fresnel Zone Plate', plateCX - 55, plateCY + maxR + 25);
            if (plateMode !== 'open') {
                ctx.fillStyle = '#f0c060';
                ctx.font = '11px monospace';
                ctx.fillText(plateMode === 'plate' ? 'Even zones blocked' : 'Only odd zones', plateCX - 50, plateCY + maxR + 42);
            }

            // Draw sign labels (+/-)
            for (let n = 0; n < Math.min(N, 6); n++) {
                const r = n > 0 ? (zoneRadii[n] + zoneRadii[n-1]) / 2 : zoneRadii[0] / 2;
                const isOdd = (n % 2 === 0);
                const blocked = (plateMode !== 'open') && !isOdd;
                if (!blocked) {
                    ctx.fillStyle = isOdd ? '#60ff60' : '#ff6060';
                    ctx.font = 'bold 14px monospace';
                    ctx.fillText(isOdd ? '+' : '-', plateCX - r - 5, plateCY + 5);
                }
            }

            // Draw focal point and rays
            const focalX = W * 0.65;
            const focalY = plateCY;

            // Draw convergence rays from zone edges to focal point
            for (let n = 0; n < N; n++) {
                const r = zoneRadii[n];
                const isOdd = (n % 2 === 0);
                const blocked = (plateMode !== 'open') && !isOdd;
                if (blocked) continue;

                // Top ray
                ctx.beginPath();
                ctx.moveTo(plateCX, plateCY - r);
                ctx.lineTo(focalX, focalY);
                ctx.strokeStyle = isOdd
                    ? `rgba(${Math.round(cr*200)},${Math.round(cg*200)},${Math.round(cb*200)},${0.08})`
                    : `rgba(${Math.round(cr*100)},${Math.round(cg*100)},${Math.round(cb*100)},${0.04})`;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Bottom ray
                ctx.beginPath();
                ctx.moveTo(plateCX, plateCY + r);
                ctx.lineTo(focalX, focalY);
                ctx.stroke();
            }

            // Animate waves from each zone converging at focal point
            const wavePhase = time * speed * 4;
            let totalAmpReal = 0;
            let totalAmpImag = 0;

            for (let n = 0; n < N; n++) {
                const r = zoneRadii[n];
                const isOdd = (n % 2 === 0);
                const blocked = (plateMode !== 'open') && !isOdd;
                if (blocked) continue;

                // Path length from zone center to focal point (approximate)
                const midR = n > 0 ? (zoneRadii[n] + zoneRadii[n-1]) / 2 : zoneRadii[0] / 2;
                const pathLen = Math.sqrt(midR * midR + (focalX - plateCX) * (focalX - plateCX));
                const pathPhase = pathLen * 0.05;

                // Add contribution to total amplitude
                const phase = pathPhase + wavePhase;
                const amp = 1 / (n + 1); // diminishing contribution
                totalAmpReal += amp * Math.cos(phase);
                totalAmpImag += amp * Math.sin(phase);

                // Draw animated wavelet from zone
                const numWavelets = 3;
                for (let w = 0; w < numWavelets; w++) {
                    const tFrac = ((wavePhase * 0.2 + w / numWavelets) % 1);
                    const wx = plateCX + (focalX - plateCX) * tFrac;
                    const wy0 = plateCY - midR + midR * tFrac;
                    const wy1 = plateCY + midR - midR * tFrac;
                    const alpha = Math.sin(tFrac * Math.PI) * 0.3;

                    if (alpha > 0.01) {
                        const color = isOdd
                            ? `rgba(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)},${alpha})`
                            : `rgba(${Math.round(cr*150)},${Math.round(cg*150)},${Math.round(cb*150)},${alpha * 0.5})`;

                        ctx.beginPath();
                        ctx.arc(wx, (wy0 + focalY) / 2 + (focalY - wy0) * tFrac * 0.5, 3, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(wx, (wy1 + focalY) / 2 + (focalY - wy1) * tFrac * 0.5, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            const totalAmp = Math.sqrt(totalAmpReal * totalAmpReal + totalAmpImag * totalAmpImag);

            // Draw focal point glow
            const glowIntensity = plateMode === 'open' ? 0.3 : (plateMode === 'plate' || plateMode === 'odd') ? 0.7 : 0.3;
            const glowR = 20 + Math.sin(time * 3) * 3;
            const grad = ctx.createRadialGradient(focalX, focalY, 0, focalX, focalY, glowR * 2);
            grad.addColorStop(0, `rgba(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)},${glowIntensity})`);
            grad.addColorStop(0.3, `rgba(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)},${glowIntensity * 0.5})`);
            grad.addColorStop(1, `rgba(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)},0)`);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(focalX, focalY, glowR * 2, 0, Math.PI * 2);
            ctx.fill();

            // Focal point core
            ctx.beginPath();
            ctx.arc(focalX, focalY, 4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,${glowIntensity})`;
            ctx.fill();

            ctx.fillStyle = '#888';
            ctx.font = '11px monospace';
            ctx.fillText('Focal point (f=' + f.toFixed(1) + 'm)', focalX - 50, focalY + 30);

            // Phasor diagram (bottom-right)
            const phasorCX = W * 0.82;
            const phasorCY = H * 0.7;
            const phasorR = Math.min(W * 0.1, H * 0.15);

            // Phasor circle
            ctx.beginPath();
            ctx.arc(phasorCX, phasorCY, phasorR, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(100,140,255,0.15)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw phasor arrows from each zone
            let accX = 0, accY = 0;
            ctx.beginPath();
            ctx.moveTo(phasorCX, phasorCY);

            for (let n = 0; n < N; n++) {
                const isOdd = (n % 2 === 0);
                const blocked = (plateMode !== 'open') && !isOdd;
                if (blocked) continue;

                const midR = n > 0 ? (zoneRadii[n] + zoneRadii[n-1]) / 2 : zoneRadii[0] / 2;
                const pathLen = Math.sqrt(midR * midR + (focalX - plateCX) * (focalX - plateCX));
                const phase = pathLen * 0.05 + wavePhase;
                const amp = phasorR * 0.3 / (n + 1);

                const dx = amp * Math.cos(phase);
                const dy = amp * Math.sin(phase);
                accX += dx;
                accY += dy;

                ctx.lineTo(phasorCX + accX, phasorCY + accY);
            }

            ctx.strokeStyle = `rgba(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)},0.5)`;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Resultant phasor
            ctx.beginPath();
            ctx.moveTo(phasorCX, phasorCY);
            ctx.lineTo(phasorCX + accX, phasorCY + accY);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Arrowhead
            const resAngle = Math.atan2(accY, accX);
            const resLen = Math.sqrt(accX * accX + accY * accY);
            ctx.beginPath();
            ctx.moveTo(phasorCX + accX, phasorCY + accY);
            ctx.lineTo(phasorCX + accX - 8 * Math.cos(resAngle - 0.3), phasorCY + accY - 8 * Math.sin(resAngle - 0.3));
            ctx.moveTo(phasorCX + accX, phasorCY + accY);
            ctx.lineTo(phasorCX + accX - 8 * Math.cos(resAngle + 0.3), phasorCY + accY - 8 * Math.sin(resAngle + 0.3));
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '11px monospace';
            ctx.fillText('Phasor Sum', phasorCX - 30, phasorCY - phasorR - 10);
            ctx.fillStyle = '#fff';
            ctx.fillText('|A| = ' + resLen.toFixed(1), phasorCX - 20, phasorCY + phasorR + 18);

            // Lens comparison (top-right area)
            const compX = W * 0.78;
            const compY = H * 0.2;
            ctx.fillStyle = '#555';
            ctx.font = '11px sans-serif';
            ctx.fillText('Comparison:', compX, compY - 15);

            // Regular lens
            ctx.beginPath();
            ctx.ellipse(compX + 20, compY + 20, 6, 25, 0, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(100,200,255,0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(100,200,255,0.08)';
            ctx.fill();
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Refractive Lens', compX - 5, compY + 55);

            // Zone plate mini
            for (let n = 4; n >= 0; n--) {
                const r = (n + 1) * 5;
                ctx.beginPath();
                ctx.arc(compX + 80, compY + 20, r, 0, Math.PI * 2);
                if (n % 2 === 0) {
                    ctx.fillStyle = `rgba(${Math.round(cr*150)},${Math.round(cg*150)},${Math.round(cb*150)},0.2)`;
                } else {
                    ctx.fillStyle = 'rgba(20,20,40,0.6)';
                }
                ctx.fill();
                ctx.strokeStyle = 'rgba(100,140,255,0.2)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Zone Plate', compX + 60, compY + 55);

            // Both focus!
            ctx.fillStyle = '#f0c060';
            ctx.font = '10px sans-serif';
            ctx.fillText('Both focus light!', compX + 20, compY + 70);

            // Update amplitude display
            const ampStr = plateMode === 'open'
                ? 'All zones: partial cancellation'
                : 'Zone plate: enhanced focusing (~' + (N/2).toFixed(0) + 'x brighter)';
            document.getElementById('ampDisplay').textContent = ampStr;

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Segoe UI, sans-serif';
            ctx.fillText('Fresnel Zones & Zone Plate Lens', W / 2 - 140, H - 15);

            time += 0.016;
            animId = requestAnimationFrame(draw);
        }

        window.reset = function() {
            time = 0;
            document.getElementById('wavelength').value = 550;
            document.getElementById('focal').value = 1;
            document.getElementById('numZones').value = 10;
            document.getElementById('speed').value = 1;
            setPlateMode('open');
        };

        draw();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
