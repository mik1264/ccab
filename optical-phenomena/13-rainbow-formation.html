<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rainbow Formation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
canvas { display: block; }
#controls {
    position: fixed; top: 15px; right: 15px; width: 250px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2);
}
#controls h3 { color: #7eb8ff; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
.control-row { margin-bottom: 10px; }
.control-row label { display: block; font-size: 12px; color: #8ab4f8; margin-bottom: 3px; }
.control-row input[type="range"] { width: 100%; accent-color: #5b8def; }
.control-row .value { float: right; color: #ffd475; font-size: 12px; font-weight: bold; }
.view-btn {
    display: inline-block; padding: 5px 12px; margin: 3px; border-radius: 6px; cursor: pointer;
    background: rgba(80,120,200,0.25); border: 1px solid rgba(100,140,255,0.3);
    color: #8ab4f8; font-size: 12px;
}
.view-btn:hover, .view-btn.active { background: rgba(80,120,200,0.5); color: #fff; }
#info {
    position: fixed; bottom: 15px; left: 15px; width: 340px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 18px; z-index: 10;
    border: 1px solid rgba(100,140,255,0.2); font-size: 13px; line-height: 1.5;
}
#info h3 { color: #7eb8ff; margin-bottom: 8px; font-size: 14px; }
a.back { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); color: #7eb8ff; text-decoration: none; z-index: 20; font-size: 13px; }
a.back:hover { color: #ffd475; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back to Gallery</a>
<canvas id="c"></canvas>

<div id="controls">
    <h3>Rainbow Controls</h3>
    <div class="control-row">
        <label>Droplet Size: <span class="value" id="vSize">120</span></label>
        <input type="range" id="sSize" min="60" max="200" step="5" value="120">
    </div>
    <div class="control-row">
        <label>Number of Rays: <span class="value" id="vRays">18</span></label>
        <input type="range" id="sRays" min="5" max="40" step="1" value="18">
    </div>
    <div style="margin-top:12px;">
        <span style="font-size:12px;color:#8ab4f8;">View:</span><br>
        <span class="view-btn active" id="btnDroplet" onclick="setView('droplet')">Droplet</span>
        <span class="view-btn" id="btnSky" onclick="setView('sky')">Sky View</span>
    </div>
</div>

<div id="info">
    <h3>Rainbow Formation</h3>
    <p><strong style="color:#ff8080;">Primary rainbow (42°):</strong> One internal reflection. Red on outside, violet on inside.</p>
    <p style="margin-top:6px;"><strong style="color:#8080ff;">Secondary rainbow (51°):</strong> Two internal reflections. Colors reversed - red on inside.</p>
    <p style="margin-top:6px;">The dark region between the two bows is <strong style="color:#ffd475;">Alexander's dark band</strong> - no light is directed into this zone.</p>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let dropletRadius = 120;
let numRays = 18;
let viewMode = 'droplet';
let animTime = 0;
let paused = false;

const wavelengths = [
    { wl: 700, r: 255, g: 30, b: 30, n: 1.3312 },
    { wl: 650, r: 255, g: 100, b: 0, n: 1.3320 },
    { wl: 600, r: 255, g: 180, b: 0, n: 1.3330 },
    { wl: 570, r: 240, g: 240, b: 0, n: 1.3340 },
    { wl: 530, r: 80, g: 255, b: 30, n: 1.3350 },
    { wl: 480, r: 0, g: 160, b: 255, n: 1.3370 },
    { wl: 450, r: 60, g: 60, b: 255, n: 1.3385 },
    { wl: 400, r: 130, g: 0, b: 220, n: 1.3430 },
];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const sSize = document.getElementById('sSize');
const sRays = document.getElementById('sRays');
sSize.addEventListener('input', () => { dropletRadius = parseInt(sSize.value); document.getElementById('vSize').textContent = dropletRadius; });
sRays.addEventListener('input', () => { numRays = parseInt(sRays.value); document.getElementById('vRays').textContent = numRays; });

function setView(v) {
    viewMode = v;
    document.getElementById('btnDroplet').classList.toggle('active', v === 'droplet');
    document.getElementById('btnSky').classList.toggle('active', v === 'sky');
}
window.setView = setView;

function traceDropletRay(cx, cy, r, impactY, n, numReflections) {
    // Ray comes from left, horizontal
    // Impact parameter: impactY relative to center
    const entryX = cx - Math.sqrt(r * r - impactY * impactY);
    const entryY = cy + impactY;

    // Normal at entry point (outward)
    const nx1 = (entryX - cx) / r;
    const ny1 = (entryY - cy) / r;

    // Incident direction (1, 0)
    const dirX = 1, dirY = 0;

    // Angle of incidence
    const cosI = -(dirX * nx1 + dirY * ny1);
    const sinI = Math.sqrt(1 - cosI * cosI);
    const sinR = sinI / n;
    if (Math.abs(sinR) > 1) return null;
    const cosR = Math.sqrt(1 - sinR * sinR);

    // Refracted direction into droplet
    let rdX = dirX / n + (cosI / n - cosR) * nx1;
    let rdY = dirY / n + (cosI / n - cosR) * ny1;
    const rdLen = Math.sqrt(rdX * rdX + rdY * rdY);
    rdX /= rdLen; rdY /= rdLen;

    const points = [{ x: entryX, y: entryY }];

    let curX = entryX, curY = entryY;
    let curDirX = rdX, curDirY = rdY;

    for (let ref = 0; ref < numReflections; ref++) {
        // Find next intersection with circle (inside)
        const dx = curDirX, dy = curDirY;
        const fx = curX - cx, fy = curY - cy;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - r * r;
        const disc = b * b - 4 * a * c;
        if (disc < 0) return null;
        const t = (-b + Math.sqrt(disc)) / (2 * a);
        const hitX = curX + dx * t;
        const hitY = curY + dy * t;
        points.push({ x: hitX, y: hitY });

        // Normal at hit (inward for reflection)
        const hnx = (hitX - cx) / r;
        const hny = (hitY - cy) / r;

        // Reflect
        const dot = curDirX * hnx + curDirY * hny;
        curDirX = curDirX - 2 * dot * hnx;
        curDirY = curDirY - 2 * dot * hny;
        curX = hitX;
        curY = hitY;
    }

    // Final refraction out
    const dx2 = curDirX, dy2 = curDirY;
    const fx2 = curX - cx, fy2 = curY - cy;
    const a2 = 1;
    const b2 = 2 * (fx2 * dx2 + fy2 * dy2);
    const c2 = fx2 * fx2 + fy2 * fy2 - r * r;
    const disc2 = b2 * b2 - 4 * a2 * c2;
    if (disc2 < 0) return null;
    const t2 = (-b2 + Math.sqrt(disc2)) / (2 * a2);
    const exitX = curX + dx2 * t2;
    const exitY = curY + dy2 * t2;
    points.push({ x: exitX, y: exitY });

    // Normal at exit
    const enx = (exitX - cx) / r;
    const eny = (exitY - cy) / r;

    // Refract out (n -> 1)
    const cosI2 = -(curDirX * enx + curDirY * eny);
    if (cosI2 < 0) {
        // Use inward normal
        const cosI2b = curDirX * enx + curDirY * eny;
        const sinI2 = Math.sqrt(1 - cosI2b * cosI2b);
        const sinR2 = sinI2 * n;
        if (Math.abs(sinR2) > 1) return null;
        const cosR2 = Math.sqrt(1 - sinR2 * sinR2);
        let edX = n * curDirX + (n * cosI2b - cosR2) * (-enx);
        let edY = n * curDirY + (n * cosI2b - cosR2) * (-eny);
        const edLen = Math.sqrt(edX * edX + edY * edY);
        edX /= edLen; edY /= edLen;
        return { points, exitDir: { x: edX, y: edY }, exitPoint: { x: exitX, y: exitY } };
    }
    const sinI2 = Math.sqrt(1 - cosI2 * cosI2);
    const sinR2 = sinI2 * n;
    if (Math.abs(sinR2) > 1) return null;
    const cosR2 = Math.sqrt(1 - sinR2 * sinR2);

    let edX = n * curDirX + (n * cosI2 - cosR2) * enx;
    let edY = n * curDirY + (n * cosI2 - cosR2) * eny;
    const edLen = Math.sqrt(edX * edX + edY * edY);
    edX /= edLen; edY /= edLen;

    return { points, exitDir: { x: edX, y: edY }, exitPoint: { x: exitX, y: exitY } };
}

function drawDropletView() {
    const cx = W * 0.45, cy = H * 0.5;
    const r = dropletRadius;

    // Draw droplet
    const grad = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, r * 0.1, cx, cy, r);
    grad.addColorStop(0, 'rgba(180,220,255,0.15)');
    grad.addColorStop(0.7, 'rgba(100,160,220,0.08)');
    grad.addColorStop(1, 'rgba(80,140,200,0.2)');
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(150,200,255,0.4)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Specular highlight
    ctx.beginPath();
    ctx.arc(cx - r * 0.3, cy - r * 0.3, r * 0.15, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fill();

    // Trace primary rainbow rays (1 reflection)
    for (let i = 0; i < numRays; i++) {
        const impactParam = -r * 0.95 + (r * 1.9) * i / (numRays - 1);

        for (const wl of wavelengths) {
            const result = traceDropletRay(cx, cy, r, impactParam, wl.n, 1);
            if (!result) continue;

            const color = `rgba(${wl.r},${wl.g},${wl.b}`;

            // Draw incoming ray
            ctx.strokeStyle = `${color},0.15)`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - r - 100, result.points[0].y);
            ctx.lineTo(result.points[0].x, result.points[0].y);
            ctx.stroke();

            // Draw path inside droplet
            ctx.strokeStyle = `${color},0.4)`;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(result.points[0].x, result.points[0].y);
            for (let p = 1; p < result.points.length; p++) {
                ctx.lineTo(result.points[p].x, result.points[p].y);
            }
            ctx.stroke();

            // Draw exit ray
            const ep = result.exitPoint;
            const ed = result.exitDir;
            ctx.strokeStyle = `${color},0.7)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(ep.x, ep.y);
            ctx.lineTo(ep.x + ed.x * 300, ep.y + ed.y * 300);
            ctx.stroke();

            // Glow on exit ray
            ctx.strokeStyle = `${color},0.15)`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(ep.x, ep.y);
            ctx.lineTo(ep.x + ed.x * 300, ep.y + ed.y * 300);
            ctx.stroke();
        }
    }

    // Labels
    ctx.fillStyle = 'rgba(255,255,240,0.5)';
    ctx.font = '12px Segoe UI';
    ctx.fillText('Sunlight', cx - r - 90, cy - r - 10);
    ctx.fillText('Primary bow rays', cx + r + 30, cy - 10);

    // Arrows for incoming light
    for (let i = 0; i < 3; i++) {
        const ay = cy - r * 0.6 + i * r * 0.6;
        ctx.strokeStyle = 'rgba(255,255,200,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx - r - 120, ay);
        ctx.lineTo(cx - r - 60, ay);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,200,0.3)';
        ctx.beginPath();
        ctx.moveTo(cx - r - 60, ay);
        ctx.lineTo(cx - r - 70, ay - 4);
        ctx.lineTo(cx - r - 70, ay + 4);
        ctx.fill();
    }

    // Angle annotation
    ctx.fillStyle = 'rgba(255,200,100,0.6)';
    ctx.font = '13px Georgia';
    ctx.fillText('~42° (primary)', cx + r + 20, cy + 40);
}

function drawSkyView() {
    const groundY = H * 0.85;
    const observerX = W * 0.5;

    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
    skyGrad.addColorStop(0, 'rgba(10,20,50,1)');
    skyGrad.addColorStop(1, 'rgba(20,30,60,1)');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, groundY);

    // Ground
    ctx.fillStyle = 'rgba(20,35,15,1)';
    ctx.fillRect(0, groundY, W, H - groundY);

    // Observer
    ctx.fillStyle = 'rgba(200,200,200,0.5)';
    ctx.beginPath();
    ctx.arc(observerX, groundY - 10, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(observerX - 3, groundY - 30, 6, 20);
    ctx.fillStyle = 'rgba(255,255,200,0.4)';
    ctx.font = '12px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Observer', observerX, groundY + 20);
    ctx.textAlign = 'left';

    // Draw sun rays from upper-left
    for (let i = 0; i < 5; i++) {
        const sx = W * 0.05 + i * 30;
        const sy = 20 + i * 15;
        ctx.strokeStyle = 'rgba(255,255,200,0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + 80, sy + 60);
        ctx.stroke();
    }
    ctx.fillStyle = 'rgba(255,220,100,0.4)';
    ctx.font = '13px Segoe UI';
    ctx.fillText('Sun (behind observer)', 20, 30);

    // Primary rainbow arc at ~42 degrees
    const primaryAngle = 42 * Math.PI / 180;
    const rainbowDist = H * 0.55;
    const primaryCenterY = groundY - 30;

    // Draw primary rainbow
    const primaryColors = [
        'rgba(255,30,30,', 'rgba(255,100,0,', 'rgba(255,180,0,',
        'rgba(255,255,0,', 'rgba(0,255,50,', 'rgba(0,150,255,',
        'rgba(60,60,255,', 'rgba(130,0,220,'
    ];

    for (let c = 0; c < primaryColors.length; c++) {
        const r = rainbowDist - c * 8;
        const alpha = 0.4 + 0.2 * Math.sin(animTime * 2 + c * 0.3);
        ctx.strokeStyle = primaryColors[c] + alpha + ')';
        ctx.lineWidth = 7;
        ctx.beginPath();
        ctx.arc(observerX, primaryCenterY, r, Math.PI + 0.3, Math.PI * 2 - 0.3);
        ctx.stroke();

        // Glow
        ctx.strokeStyle = primaryColors[c] + (alpha * 0.3) + ')';
        ctx.lineWidth = 15;
        ctx.beginPath();
        ctx.arc(observerX, primaryCenterY, r, Math.PI + 0.3, Math.PI * 2 - 0.3);
        ctx.stroke();
    }

    // Secondary rainbow (wider, fainter, reversed colors)
    const secondaryDist = rainbowDist + 80;
    const reversedColors = [...primaryColors].reverse();

    for (let c = 0; c < reversedColors.length; c++) {
        const r = secondaryDist - c * 7;
        const alpha = 0.2 + 0.1 * Math.sin(animTime * 2 + c * 0.3);
        ctx.strokeStyle = reversedColors[c] + alpha + ')';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(observerX, primaryCenterY, r, Math.PI + 0.25, Math.PI * 2 - 0.25);
        ctx.stroke();
    }

    // Alexander's dark band
    const darkInner = rainbowDist - primaryColors.length * 8 - 5;
    const darkOuter = secondaryDist + 5;
    ctx.fillStyle = 'rgba(0,0,10,0.3)';
    ctx.beginPath();
    ctx.arc(observerX, primaryCenterY, darkOuter, Math.PI + 0.25, Math.PI * 2 - 0.25);
    ctx.arc(observerX, primaryCenterY, darkInner, Math.PI * 2 - 0.3, Math.PI + 0.3, true);
    ctx.fill();

    // Labels
    ctx.fillStyle = 'rgba(255,200,100,0.7)';
    ctx.font = '13px Segoe UI';
    ctx.fillText('Primary Rainbow (42°)', observerX + rainbowDist * 0.5, primaryCenterY - rainbowDist * 0.65);
    ctx.fillStyle = 'rgba(150,180,255,0.6)';
    ctx.fillText('Secondary Rainbow (51°)', observerX + secondaryDist * 0.4, primaryCenterY - secondaryDist * 0.7);
    ctx.fillStyle = 'rgba(100,100,140,0.6)';
    ctx.fillText("Alexander's Dark Band", observerX - 80, primaryCenterY - (rainbowDist + 40) * 0.7);

    // Angle lines
    ctx.setLineDash([4, 6]);
    ctx.strokeStyle = 'rgba(255,200,100,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(observerX, primaryCenterY);
    ctx.lineTo(observerX + rainbowDist * Math.cos(primaryAngle), primaryCenterY - rainbowDist * Math.sin(primaryAngle));
    ctx.stroke();
    ctx.setLineDash([]);
}

function draw() {
    ctx.clearRect(0, 0, W, H);

    if (viewMode === 'droplet') {
        drawDropletView();
    } else {
        drawSkyView();
    }

    if (!paused) animTime += 0.016;
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}

window.reset = function() {
    dropletRadius = 120; numRays = 18; viewMode = 'droplet';
    sSize.value = 120; document.getElementById('vSize').textContent = '120';
    sRays.value = 18; document.getElementById('vRays').textContent = '18';
    setView('droplet');
    animTime = 0; paused = false;
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
