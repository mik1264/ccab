<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Rings - Optical Phenomena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        .back-link {
            position: fixed; top: 15px; left: 15px; color: #8af;
            text-decoration: none; font-size: 14px; z-index: 100;
            background: rgba(20,20,40,0.85); padding: 6px 14px;
            border-radius: 8px; backdrop-filter: blur(10px);
        }
        .back-link:hover { color: #bdf; }
        #controls {
            position: fixed; top: 15px; right: 15px;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 16px; z-index: 100;
            width: 260px; border: 1px solid rgba(100,140,255,0.15);
        }
        #controls h3 { color: #8af; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #aaa; }
        .control-group label span { color: #8af; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none;
            background: rgba(100,140,255,0.2); border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 50%; background: #8af; cursor: pointer;
        }
        .btn-row { display: flex; gap: 6px; margin-bottom: 10px; }
        .btn-row button {
            flex: 1; padding: 6px 4px; border: 1px solid rgba(100,140,255,0.3);
            background: rgba(100,140,255,0.1); color: #8af; border-radius: 6px;
            font-size: 11px; cursor: pointer; transition: 0.2s;
        }
        .btn-row button:hover { background: rgba(100,140,255,0.25); }
        .btn-row button.active { background: rgba(100,140,255,0.35); border-color: #8af; }
        .checkbox-group {
            display: flex; align-items: center; gap: 8px;
            margin-bottom: 10px; font-size: 12px; color: #aaa;
        }
        .checkbox-group input { accent-color: #8af; }
        #info {
            position: fixed; bottom: 15px; left: 15px;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 14px 18px; z-index: 100;
            max-width: 420px; border: 1px solid rgba(100,140,255,0.15);
            font-size: 12px; line-height: 1.6;
        }
        #info h4 { color: #8af; margin-bottom: 6px; font-size: 13px; }
        #info p { color: #bbb; }
        .formula { color: #8af; font-family: 'Georgia', serif; font-style: italic; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Gallery</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>Newton's Rings</h3>
        <div class="btn-row">
            <button id="btnMono" class="active">Monochromatic</button>
            <button id="btnWhite">White Light</button>
        </div>
        <div class="control-group">
            <label>Wavelength <span id="wlVal">550 nm</span></label>
            <input type="range" id="wavelength" min="380" max="750" value="550" step="5">
        </div>
        <div class="control-group">
            <label>Lens Curvature R <span id="curveVal">5.0 m</span></label>
            <input type="range" id="curvature" min="10" max="200" value="50" step="1">
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="showDiagram" checked>
            <label for="showDiagram">Show side diagram</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="showFormula" checked>
            <label for="showFormula">Show formula</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="animate" checked>
            <label for="animate">Animate wavelength</label>
        </div>
    </div>

    <div id="info">
        <h4>Newton's Rings</h4>
        <p>When a convex lens rests on a flat glass surface, a thin air wedge forms between them.
        Light reflecting from the top and bottom of this air gap interferes, creating concentric
        bright and dark rings. The air gap thickness increases as r&sup2;/2R, so the rings get
        closer together as they move outward.</p>
        <p class="formula" style="margin-top:6px;">r<sub>n</sub> = &radic;(n R &lambda;)</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, time = 0, animId;
        let lightMode = 'mono'; // 'mono' or 'white'

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        const els = {
            wavelength: document.getElementById('wavelength'),
            curvature: document.getElementById('curvature'),
            showDiagram: document.getElementById('showDiagram'),
            showFormula: document.getElementById('showFormula'),
            animateWL: document.getElementById('animate'),
            wlVal: document.getElementById('wlVal'),
            curveVal: document.getElementById('curveVal'),
            btnMono: document.getElementById('btnMono'),
            btnWhite: document.getElementById('btnWhite')
        };

        els.btnMono.addEventListener('click', () => {
            lightMode = 'mono';
            els.btnMono.classList.add('active');
            els.btnWhite.classList.remove('active');
        });
        els.btnWhite.addEventListener('click', () => {
            lightMode = 'white';
            els.btnWhite.classList.add('active');
            els.btnMono.classList.remove('active');
        });

        function wavelengthToRGB(wl) {
            let r=0, g=0, b=0;
            if (wl>=380&&wl<440){r=-(wl-440)/(440-380);b=1;}
            else if(wl>=440&&wl<490){g=(wl-440)/(490-440);b=1;}
            else if(wl>=490&&wl<510){g=1;b=-(wl-510)/(510-490);}
            else if(wl>=510&&wl<580){r=(wl-510)/(580-510);g=1;}
            else if(wl>=580&&wl<645){r=1;g=-(wl-645)/(645-580);}
            else if(wl>=645&&wl<=750){r=1;}
            let f;
            if(wl>=380&&wl<420)f=0.3+0.7*(wl-380)/(420-380);
            else if(wl>=420&&wl<=700)f=1.0;
            else if(wl>700&&wl<=750)f=0.3+0.7*(750-wl)/(750-700);
            else f=0;
            return [r*f,g*f,b*f];
        }

        function updateLabels() {
            const wl = +els.wavelength.value;
            const R = +els.curvature.value / 10;
            els.wlVal.textContent = wl + ' nm';
            els.curveVal.textContent = R.toFixed(1) + ' m';
        }
        [els.wavelength, els.curvature].forEach(e => e.addEventListener('input', updateLabels));
        updateLabels();

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            let wl = +els.wavelength.value;
            const R = +els.curvature.value / 10; // meters
            const showDiag = els.showDiagram.checked;
            const showForm = els.showFormula.checked;
            const doAnimate = els.animateWL.checked;

            if (doAnimate && lightMode === 'mono') {
                wl = 420 + (Math.sin(time * 0.3) * 0.5 + 0.5) * 280;
                els.wavelength.value = Math.round(wl);
                updateLabels();
            }

            // Ring pattern - top view
            const ringCx = W * 0.5;
            const ringCy = showDiag ? H * 0.4 : H * 0.5;
            const maxRadius = Math.min(W, H) * (showDiag ? 0.32 : 0.4);

            // Draw rings using radial approach
            // Air gap at radius r: t(r) = r^2 / (2R)
            // For reflection: path diff = 2t + lambda/2 (half wave shift from bottom surface)
            // Destructive (dark): 2t = m*lambda => r_m = sqrt(m*R*lambda)
            // Constructive (bright): 2t = (m+1/2)*lambda

            const lambdaM = wl * 1e-9; // convert nm to meters
            const pixelToMeter = (R * lambdaM * 50) / (maxRadius * maxRadius); // scale factor

            const step = 2;
            for (let py = ringCy - maxRadius; py < ringCy + maxRadius; py += step) {
                for (let px = ringCx - maxRadius; px < ringCx + maxRadius; px += step) {
                    const dx = px - ringCx;
                    const dy = py - ringCy;
                    const rPx = Math.sqrt(dx * dx + dy * dy);
                    if (rPx > maxRadius) continue;

                    if (lightMode === 'mono') {
                        // Air gap thickness at this radius (in wavelengths)
                        const rScaled = rPx * Math.sqrt(pixelToMeter);
                        const t = rScaled * rScaled / (2 * R); // thickness in meters
                        const pathDiff = 2 * t; // path difference
                        const phase = (pathDiff / lambdaM) * 2 * Math.PI + Math.PI; // +pi for half-wave shift
                        const intensity = Math.pow(Math.cos(phase / 2), 2);

                        const [cr, cg, cb] = wavelengthToRGB(wl);
                        const fade = 1 - (rPx / maxRadius) * 0.3;
                        ctx.fillStyle = `rgb(${Math.round(cr*intensity*fade*255)},${Math.round(cg*intensity*fade*255)},${Math.round(cb*intensity*fade*255)})`;
                    } else {
                        // White light: sum over wavelengths
                        let rr = 0, gg = 0, bb = 0;
                        for (let w = 400; w <= 700; w += 20) {
                            const lm = w * 1e-9;
                            const pxToM = (R * lm * 50) / (maxRadius * maxRadius);
                            const rs = rPx * Math.sqrt(pxToM);
                            const t = rs * rs / (2 * R);
                            const phase = (2 * t / lm) * 2 * Math.PI + Math.PI;
                            const intensity = Math.pow(Math.cos(phase / 2), 2);
                            const [cr, cg, cb] = wavelengthToRGB(w);
                            rr += cr * intensity;
                            gg += cg * intensity;
                            bb += cb * intensity;
                        }
                        const maxC = Math.max(rr, gg, bb, 0.01);
                        const scale = 0.9 / maxC;
                        const fade = 1 - (rPx / maxRadius) * 0.3;
                        ctx.fillStyle = `rgb(${Math.round(rr*scale*fade*255)},${Math.round(gg*scale*fade*255)},${Math.round(bb*scale*fade*255)})`;
                    }
                    ctx.fillRect(px, py, step, step);
                }
            }

            // Ring labels - mark a few ring numbers
            if (lightMode === 'mono') {
                ctx.font = '10px sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                for (let n = 1; n <= 5; n++) {
                    const rn = Math.sqrt(n * R * lambdaM / pixelToMeter);
                    if (rn < maxRadius) {
                        ctx.fillText('n=' + n, ringCx + rn + 4, ringCy - 4);
                    }
                }
            }

            // Side view diagram
            if (showDiag) {
                const diagY = H * 0.78;
                const diagW = W * 0.6;
                const diagX = W * 0.2;

                // Flat glass surface
                ctx.fillStyle = 'rgba(60,80,140,0.3)';
                ctx.fillRect(diagX, diagY, diagW, 20);
                ctx.strokeStyle = 'rgba(100,140,255,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(diagX, diagY);
                ctx.lineTo(diagX + diagW, diagY);
                ctx.stroke();

                // Convex lens (arc)
                const lensR = diagW * 0.8; // visual radius
                const lensCenter = diagY - lensR + 8;
                ctx.strokeStyle = 'rgba(140,180,255,0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const startAngle = Math.asin((diagW / 2) / lensR);
                ctx.arc(diagX + diagW / 2, lensCenter, lensR, Math.PI / 2 - startAngle, Math.PI / 2 + startAngle);
                ctx.stroke();

                // Air gap arrows
                ctx.strokeStyle = 'rgba(255,200,100,0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                for (let i = 1; i <= 4; i++) {
                    const xOff = i * diagW / 10;
                    const gapY = diagY - Math.sqrt(lensR * lensR - xOff * xOff) + lensR - 8;
                    ctx.beginPath();
                    ctx.moveTo(diagX + diagW / 2 + xOff, diagY);
                    ctx.lineTo(diagX + diagW / 2 + xOff, gapY);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Labels
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '11px sans-serif';
                ctx.fillText('Convex Lens', diagX + diagW / 2 - 35, lensCenter + lensR - 30);
                ctx.fillText('Flat Glass', diagX + diagW / 2 - 25, diagY + 35);
                ctx.fillStyle = 'rgba(255,200,100,0.5)';
                ctx.fillText('Air Gap', diagX + diagW / 2 + diagW / 5 + 5, diagY - 10);

                // Incident light arrows
                ctx.strokeStyle = 'rgba(255,255,150,0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const x = diagX + diagW * 0.2 + i * diagW * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(x, lensCenter + lensR - 60);
                    ctx.lineTo(x, lensCenter + lensR - 35);
                    ctx.stroke();
                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(x - 3, lensCenter + lensR - 40);
                    ctx.lineTo(x, lensCenter + lensR - 35);
                    ctx.lineTo(x + 3, lensCenter + lensR - 40);
                    ctx.stroke();
                }
                ctx.fillStyle = 'rgba(255,255,150,0.3)';
                ctx.fillText('Incident Light', diagX + diagW / 2 - 35, lensCenter + lensR - 65);
            }

            // Formula overlay
            if (showForm) {
                ctx.fillStyle = 'rgba(20,20,40,0.7)';
                const fX = W * 0.5 - 100;
                const fY = showDiag ? H * 0.6 : H * 0.75;
                ctx.fillRect(fX, fY, 200, 40);
                ctx.strokeStyle = 'rgba(100,140,255,0.3)';
                ctx.strokeRect(fX, fY, 200, 40);
                ctx.fillStyle = '#8af';
                ctx.font = '16px Georgia, serif';
                ctx.textAlign = 'center';
                ctx.fillText('r\u2099 = \u221A(n \u00B7 R \u00B7 \u03BB)', fX + 100, fY + 26);
                ctx.textAlign = 'left';
            }

            time += 0.016;
        }

        function animate() {
            draw();
            animId = requestAnimationFrame(animate);
        }

        window.reset = function() {
            time = 0;
            lightMode = 'mono';
            els.btnMono.classList.add('active');
            els.btnWhite.classList.remove('active');
            els.wavelength.value = 550;
            els.curvature.value = 50;
            els.showDiagram.checked = true;
            els.showFormula.checked = true;
            els.animateWL.checked = true;
            updateLabels();
        };

        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
