<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crowd Behavior | Social Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1a4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 100, 255, 0.3);
        }
        h1 { color: #a78bfa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #a78bfa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #a78bfa; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #c4b5fd; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #a78bfa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #a78bfa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Social Dynamics</a>

    <div class="controls">
        <h1>Crowd Behavior</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Social force model simulation</p>

        <div class="control-group">
            <label>Scenario:</label>
            <select id="scenario">
                <option value="evacuation">Emergency Evacuation</option>
                <option value="concert">Concert Crowd</option>
                <option value="crosswalk">Pedestrian Crossing</option>
            </select>
        </div>

        <div class="control-group">
            <label>Crowd Size: <span class="value" id="sizeValue">100</span></label>
            <input type="range" id="crowdSize" min="20" max="300" step="10" value="100">
        </div>

        <div class="control-group">
            <label>Panic Level: <span class="value" id="panicValue">0.3</span></label>
            <input type="range" id="panic" min="0" max="1" step="0.1" value="0.3">
        </div>

        <div class="control-group">
            <label>Desired Speed: <span class="value" id="speedValue">2.0</span></label>
            <input type="range" id="desiredSpeed" min="1" max="5" step="0.5" value="2.0">
        </div>

        <button id="resetBtn">Reset Simulation</button>
        <button id="addObstacle" style="background:#444;color:#fff">Add Obstacle (Click)</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time</span>
                <span class="stat-value" id="time">0s</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Evacuated</span>
                <span class="stat-value" id="evacuated">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Velocity</span>
                <span class="stat-value" id="avgVelocity">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Crowd Density</span>
                <span class="stat-value" id="density">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Click</strong> to create panic point or attractor.<br>
            <strong>Social Force Model</strong> simulates pedestrian movement with personal space and goal-seeking behavior.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initScene();
        }
        resize();
        window.onresize = resize;

        let people = [];
        let obstacles = [];
        let exits = [];
        let attractors = [];
        let crowdSize = 100;
        let panicLevel = 0.3;
        let desiredSpeed = 2.0;
        let scenario = 'evacuation';
        let time = 0;
        let evacuated = 0;
        let addingObstacle = false;

        const plotWidth = () => canvas.width - 350;
        const plotHeight = () => canvas.height;

        function initScene() {
            people = [];
            obstacles = [];
            exits = [];
            attractors = [];
            evacuated = 0;
            time = 0;

            const pw = plotWidth();
            const ph = plotHeight();

            switch (scenario) {
                case 'evacuation':
                    // Room with exits
                    obstacles = [
                        { x: 50, y: 50, w: pw - 100, h: 20 }, // Top wall
                        { x: 50, y: ph - 70, w: (pw - 200) / 2, h: 20 }, // Bottom left wall
                        { x: (pw + 100) / 2, y: ph - 70, w: (pw - 200) / 2, h: 20 }, // Bottom right wall
                        { x: 50, y: 50, w: 20, h: ph - 120 }, // Left wall
                        { x: pw - 70, y: 50, w: 20, h: ph - 120 }, // Right wall
                    ];
                    exits = [{ x: pw / 2, y: ph - 50, w: 100 }];

                    // People inside room
                    for (let i = 0; i < crowdSize; i++) {
                        people.push(createPerson(
                            100 + Math.random() * (pw - 250),
                            100 + Math.random() * (ph - 250)
                        ));
                    }
                    break;

                case 'concert':
                    // Stage at top
                    obstacles = [{ x: pw / 2 - 150, y: 30, w: 300, h: 60 }];
                    attractors = [{ x: pw / 2, y: 80 }];

                    for (let i = 0; i < crowdSize; i++) {
                        people.push(createPerson(
                            100 + Math.random() * (pw - 250),
                            200 + Math.random() * (ph - 300)
                        ));
                    }
                    break;

                case 'crosswalk':
                    // Two groups walking opposite directions
                    for (let i = 0; i < crowdSize / 2; i++) {
                        const p1 = createPerson(50 + Math.random() * 100, 100 + Math.random() * (ph - 200));
                        p1.targetX = pw - 50;
                        p1.group = 0;
                        people.push(p1);

                        const p2 = createPerson(pw - 150 + Math.random() * 100, 100 + Math.random() * (ph - 200));
                        p2.targetX = 50;
                        p2.group = 1;
                        people.push(p2);
                    }
                    break;
            }
        }

        function createPerson(x, y) {
            return {
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                radius: 8 + Math.random() * 4,
                mass: 60 + Math.random() * 40,
                targetX: null,
                targetY: null,
                group: 0,
                panic: 0
            };
        }

        function socialForce(person) {
            let fx = 0, fy = 0;

            // Goal force
            let goalX, goalY;

            if (person.targetX !== null) {
                goalX = person.targetX;
                goalY = person.y;
            } else if (exits.length > 0) {
                const exit = exits[0];
                goalX = exit.x;
                goalY = exit.y;
            } else if (attractors.length > 0) {
                goalX = attractors[0].x;
                goalY = attractors[0].y;
            } else {
                goalX = person.x;
                goalY = person.y;
            }

            const dx = goalX - person.x;
            const dy = goalY - person.y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;

            const speed = desiredSpeed * (1 + panicLevel * person.panic);
            const desiredVx = (dx / dist) * speed;
            const desiredVy = (dy / dist) * speed;

            const tau = 0.5; // Relaxation time
            fx += (desiredVx - person.vx) / tau * person.mass;
            fy += (desiredVy - person.vy) / tau * person.mass;

            // Repulsion from other people
            for (const other of people) {
                if (other === person) continue;

                const dx = person.x - other.x;
                const dy = person.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = person.radius + other.radius;

                if (dist < minDist * 3) {
                    const A = 2000 * (1 + panicLevel);
                    const B = 0.08;
                    const force = A * Math.exp((minDist - dist) / B / 100);

                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;

                    // Physical contact
                    if (dist < minDist) {
                        const k = 120000;
                        const overlap = minDist - dist;
                        fx += k * overlap * (dx / dist);
                        fy += k * overlap * (dy / dist);
                    }
                }
            }

            // Repulsion from obstacles
            for (const obs of obstacles) {
                const closestX = Math.max(obs.x, Math.min(obs.x + obs.w, person.x));
                const closestY = Math.max(obs.y, Math.min(obs.y + obs.h, person.y));

                const dx = person.x - closestX;
                const dy = person.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;

                if (dist < person.radius + 30) {
                    const force = 5000 * Math.exp(-dist / 20);
                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;
                }
            }

            return { fx, fy };
        }

        function update(dt) {
            const pw = plotWidth();
            const ph = plotHeight();

            for (let i = people.length - 1; i >= 0; i--) {
                const person = people[i];

                const { fx, fy } = socialForce(person);

                person.vx += fx / person.mass * dt;
                person.vy += fy / person.mass * dt;

                // Speed limit
                const speed = Math.sqrt(person.vx * person.vx + person.vy * person.vy);
                const maxSpeed = desiredSpeed * 2;
                if (speed > maxSpeed) {
                    person.vx *= maxSpeed / speed;
                    person.vy *= maxSpeed / speed;
                }

                person.x += person.vx * dt * 50;
                person.y += person.vy * dt * 50;

                // Update panic based on crowding
                let crowding = 0;
                for (const other of people) {
                    if (other === person) continue;
                    const dx = person.x - other.x;
                    const dy = person.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 50) crowding += (50 - dist) / 50;
                }
                person.panic = Math.min(1, crowding / 5);

                // Bounds
                person.x = Math.max(person.radius, Math.min(pw - person.radius, person.x));
                person.y = Math.max(person.radius, Math.min(ph - person.radius, person.y));

                // Check exits
                for (const exit of exits) {
                    if (person.x > exit.x - exit.w / 2 && person.x < exit.x + exit.w / 2 &&
                        person.y > exit.y - 30) {
                        people.splice(i, 1);
                        evacuated++;
                        break;
                    }
                }

                // Check crossing completion
                if (scenario === 'crosswalk') {
                    if ((person.group === 0 && person.x > pw - 70) ||
                        (person.group === 1 && person.x < 70)) {
                        people.splice(i, 1);
                        evacuated++;
                    }
                }
            }

            time += dt;
        }

        function updateStats() {
            let totalVel = 0;
            for (const p of people) {
                totalVel += Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            }
            const avgVel = people.length > 0 ? totalVel / people.length : 0;

            // Local density estimation
            let maxDensity = 0;
            const cellSize = 50;
            const pw = plotWidth();
            const ph = plotHeight();

            for (let x = 0; x < pw; x += cellSize) {
                for (let y = 0; y < ph; y += cellSize) {
                    let count = 0;
                    for (const p of people) {
                        if (p.x >= x && p.x < x + cellSize && p.y >= y && p.y < y + cellSize) {
                            count++;
                        }
                    }
                    const density = count / (cellSize * cellSize / 1000);
                    maxDensity = Math.max(maxDensity, density);
                }
            }

            document.getElementById('time').textContent = time.toFixed(1) + 's';
            document.getElementById('evacuated').textContent = evacuated;
            document.getElementById('avgVelocity').textContent = avgVel.toFixed(2) + ' m/s';
            document.getElementById('density').textContent = maxDensity.toFixed(1) + ' p/m²';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update(0.016);
            updateStats();

            // Draw obstacles
            for (const obs of obstacles) {
                ctx.fillStyle = '#444';
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            }

            // Draw exits
            for (const exit of exits) {
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(exit.x - exit.w / 2, exit.y - 10, exit.w, 20);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('EXIT', exit.x, exit.y + 4);
            }

            // Draw attractors
            for (const attr of attractors) {
                ctx.beginPath();
                ctx.arc(attr.x, attr.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#f59e0b';
                ctx.fill();
            }

            // Draw people
            for (const person of people) {
                ctx.beginPath();
                ctx.arc(person.x, person.y, person.radius, 0, Math.PI * 2);

                // Color based on panic level
                const r = Math.floor(100 + 155 * person.panic);
                const g = Math.floor(100 * (1 - person.panic));
                const b = Math.floor(250 * (1 - person.panic * 0.5));
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();

                // Direction indicator
                if (Math.abs(person.vx) + Math.abs(person.vy) > 0.1) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 2;
                    ctx.moveTo(person.x, person.y);
                    ctx.lineTo(person.x + person.vx * 5, person.y + person.vy * 5);
                    ctx.stroke();
                }
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Crowd Simulation: ${scenario.charAt(0).toUpperCase() + scenario.slice(1)}`, 50, 30);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('scenario').onchange = (e) => {
            scenario = e.target.value;
            initScene();
        };

        document.getElementById('crowdSize').oninput = (e) => {
            crowdSize = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = crowdSize;
        };

        document.getElementById('panic').oninput = (e) => {
            panicLevel = parseFloat(e.target.value);
            document.getElementById('panicValue').textContent = panicLevel.toFixed(1);
        };

        document.getElementById('desiredSpeed').oninput = (e) => {
            desiredSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = desiredSpeed.toFixed(1);
        };

        document.getElementById('resetBtn').onclick = initScene;

        document.getElementById('addObstacle').onclick = () => {
            addingObstacle = !addingObstacle;
            document.getElementById('addObstacle').style.background = addingObstacle ? '#a78bfa' : '#444';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            if (mx < plotWidth()) {
                if (addingObstacle) {
                    obstacles.push({ x: mx - 25, y: my - 25, w: 50, h: 50 });
                } else {
                    // Create panic point
                    for (const p of people) {
                        const dx = p.x - mx;
                        const dy = p.y - my;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 150) {
                            p.panic = 1;
                            p.vx += dx / dist * 3;
                            p.vy += dy / dist * 3;
                        }
                    }
                }
            }
        };

        // Initialize
        initScene();
        draw();
    </script>
</body>
</html>
