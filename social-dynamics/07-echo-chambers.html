<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Chambers - Opinion-Based Network Rewiring</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            background: linear-gradient(135deg, #1a1f35 0%, #0f1423 100%);
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #f43f5e, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #9ca3af;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: rgba(244, 63, 94, 0.1);
            color: #fb7185;
            text-decoration: none;
            border-radius: 8px;
            border: 1px solid rgba(244, 63, 94, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(244, 63, 94, 0.2);
            border-color: rgba(244, 63, 94, 0.5);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #151b2e;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            background: #0d1117;
        }

        .controls {
            background: #151b2e;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #fda4af;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-value {
            text-align: right;
            color: #fb7185;
            font-weight: 600;
            font-size: 0.95rem;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #f43f5e, #ec4899);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(244, 63, 94, 0.4);
        }

        .info-box {
            background: rgba(244, 63, 94, 0.1);
            border: 1px solid rgba(244, 63, 94, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .info-box h3 {
            color: #fda4af;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(244, 63, 94, 0.1);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(244, 63, 94, 0.2);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #9ca3af;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #fb7185;
        }

        .chart-container {
            background: #151b2e;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Social Dynamics</a>

        <header>
            <h1>Echo Chambers</h1>
            <p class="subtitle">Network rewiring based on opinion similarity creates isolated clusters where people only hear reinforcing views. Watch as homophilic connections segregate the social network into polarized echo chambers.</p>
        </header>

        <div class="main-grid">
            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
            </div>

            <div class="controls">
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Avg Clustering</div>
                        <div class="stat-value" id="clustering">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Polarization</div>
                        <div class="stat-value" id="polarization">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Cross-Group Links</div>
                        <div class="stat-value" id="crossLinks">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Rewirings</div>
                        <div class="stat-value" id="rewirings">0</div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Agents: <span class="control-value" id="agentCountValue">100</span></label>
                    <input type="range" id="agentCount" min="50" max="200" value="100" step="25">
                </div>

                <div class="control-group">
                    <label>Rewiring Rate: <span class="control-value" id="rewiringValue">0.10</span></label>
                    <input type="range" id="rewiring" min="0" max="0.5" value="0.10" step="0.05">
                </div>

                <div class="control-group">
                    <label>Homophily Strength: <span class="control-value" id="homophilyValue">0.80</span></label>
                    <input type="range" id="homophily" min="0" max="1" value="0.80" step="0.1">
                </div>

                <div class="control-group">
                    <label>Opinion Influence: <span class="control-value" id="influenceValue">0.05</span></label>
                    <input type="range" id="influence" min="0" max="0.2" value="0.05" step="0.01">
                </div>

                <button id="resetBtn">Reset Simulation</button>
                <button id="pauseBtn">Pause</button>

                <div class="info-box">
                    <h3>Echo Chamber Formation</h3>
                    <p>Agents have opinions (red=0 to blue=1) and social connections. Two dynamics:</p>
                    <p style="margin-top: 10px;">
                        • <strong>Rewiring:</strong> Cut links to dissimilar others, form new links to similar<br>
                        • <strong>Influence:</strong> Connected agents shift opinions toward each other
                    </p>
                    <p style="margin-top: 10px;">High homophily → Isolated echo chambers emerge</p>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="chartCanvas"></canvas>
        </div>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const chartCanvas = document.getElementById('chartCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const chartCtx = chartCanvas.getContext('2d');

        let agents = [];
        let edges = [];
        let history = [];
        let paused = false;
        let rewiringCount = 0;
        let animationId = null;

        const config = {
            agentCount: 100,
            rewiring: 0.10,
            homophily: 0.80,
            influence: 0.05
        };

        function initCanvas() {
            mainCanvas.width = mainCanvas.offsetWidth * window.devicePixelRatio;
            mainCanvas.height = 600 * window.devicePixelRatio;
            chartCanvas.width = chartCanvas.offsetWidth * window.devicePixelRatio;
            chartCanvas.height = 300 * window.devicePixelRatio;

            const scale = window.devicePixelRatio;
            mainCtx.scale(scale, scale);
            chartCtx.scale(scale, scale);
        }

        function createNetwork() {
            agents = [];
            edges = [];
            rewiringCount = 0;
            history = [];

            const width = mainCanvas.width / window.devicePixelRatio;
            const height = mainCanvas.height / window.devicePixelRatio;

            // Create agents with random opinions
            for (let i = 0; i < config.agentCount; i++) {
                const angle = (i / config.agentCount) * 2 * Math.PI;
                const radius = Math.min(width, height) * 0.35;

                agents.push({
                    id: i,
                    opinion: Math.random(),
                    x: width / 2 + Math.cos(angle) * radius,
                    y: height / 2 + Math.sin(angle) * radius,
                    neighbors: []
                });
            }

            // Create initial random network (small-world)
            const k = 4; // Initial connections
            for (let i = 0; i < config.agentCount; i++) {
                for (let j = 1; j <= k; j++) {
                    const neighbor = (i + j) % config.agentCount;
                    if (!agents[i].neighbors.includes(neighbor)) {
                        agents[i].neighbors.push(neighbor);
                        edges.push([i, neighbor]);
                    }
                }
            }
        }

        function getColor(opinion) {
            const red = Math.floor(239 * (1 - opinion) + 59 * opinion);
            const green = Math.floor(68 * (1 - opinion) + 130 * opinion);
            const blue = Math.floor(68 * (1 - opinion) + 246 * opinion);
            return `rgb(${red}, ${green}, ${blue})`;
        }

        function updateNetwork() {
            // Opinion influence
            agents.forEach(agent => {
                let sum = agent.opinion;
                let count = 1;

                agent.neighbors.forEach(nid => {
                    sum += agents[nid].opinion;
                    count++;
                });

                const avg = sum / count;
                agent.opinion += (avg - agent.opinion) * config.influence;
            });

            // Rewiring based on homophily
            if (Math.random() < config.rewiring) {
                const agent = agents[Math.floor(Math.random() * agents.length)];

                if (agent.neighbors.length > 0) {
                    // Find most dissimilar neighbor
                    let maxDiff = 0;
                    let worstNeighbor = null;

                    agent.neighbors.forEach(nid => {
                        const diff = Math.abs(agent.opinion - agents[nid].opinion);
                        if (diff > maxDiff) {
                            maxDiff = diff;
                            worstNeighbor = nid;
                        }
                    });

                    // Rewire with probability based on dissimilarity and homophily
                    if (maxDiff > (1 - config.homophily) && worstNeighbor !== null) {
                        // Remove edge
                        agent.neighbors = agent.neighbors.filter(n => n !== worstNeighbor);
                        agents[worstNeighbor].neighbors = agents[worstNeighbor].neighbors.filter(n => n !== agent.id);
                        edges = edges.filter(e =>
                            !((e[0] === agent.id && e[1] === worstNeighbor) ||
                              (e[1] === agent.id && e[0] === worstNeighbor))
                        );

                        // Add new edge to similar agent
                        const candidates = agents.filter(a =>
                            a.id !== agent.id &&
                            !agent.neighbors.includes(a.id) &&
                            Math.abs(a.opinion - agent.opinion) < 0.3
                        );

                        if (candidates.length > 0) {
                            const newNeighbor = candidates[Math.floor(Math.random() * candidates.length)];
                            agent.neighbors.push(newNeighbor.id);
                            newNeighbor.neighbors.push(agent.id);
                            edges.push([agent.id, newNeighbor.id]);
                            rewiringCount++;
                        }
                    }
                }
            }
        }

        function drawNetwork() {
            const width = mainCanvas.width / window.devicePixelRatio;
            const height = mainCanvas.height / window.devicePixelRatio;

            mainCtx.fillStyle = '#0d1117';
            mainCtx.fillRect(0, 0, width, height);

            // Draw edges
            edges.forEach(([i, j]) => {
                const a = agents[i];
                const b = agents[j];
                const diff = Math.abs(a.opinion - b.opinion);

                mainCtx.strokeStyle = diff > 0.5 ?
                    'rgba(239, 68, 68, 0.2)' :
                    'rgba(59, 130, 246, 0.2)';
                mainCtx.lineWidth = 1;
                mainCtx.beginPath();
                mainCtx.moveTo(a.x, a.y);
                mainCtx.lineTo(b.x, b.y);
                mainCtx.stroke();
            });

            // Draw agents
            agents.forEach(agent => {
                mainCtx.fillStyle = getColor(agent.opinion);
                mainCtx.beginPath();
                mainCtx.arc(agent.x, agent.y, 5, 0, Math.PI * 2);
                mainCtx.fill();

                mainCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                mainCtx.lineWidth = 1;
                mainCtx.stroke();
            });
        }

        function drawChart() {
            const width = chartCanvas.width / window.devicePixelRatio;
            const height = chartCanvas.height / window.devicePixelRatio;

            chartCtx.fillStyle = '#0d1117';
            chartCtx.fillRect(0, 0, width, height);

            if (history.length < 2) return;

            const maxHistory = 200;
            const displayHistory = history.slice(-maxHistory);
            const stepWidth = width / maxHistory;

            // Draw clustering coefficient
            chartCtx.strokeStyle = '#f43f5e';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            displayHistory.forEach((point, i) => {
                const x = i * stepWidth;
                const y = height - point.clustering * height;
                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            });
            chartCtx.stroke();

            // Draw polarization
            chartCtx.strokeStyle = '#ec4899';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            displayHistory.forEach((point, i) => {
                const x = i * stepWidth;
                const y = height - point.polarization * height;
                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            });
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#9ca3af';
            chartCtx.font = '12px sans-serif';
            chartCtx.fillText('Clustering Coefficient (Red)', 10, 20);
            chartCtx.fillText('Polarization (Pink)', 10, 40);
        }

        function calculateStats() {
            // Calculate clustering coefficient
            let totalClustering = 0;
            let nodesWithNeighbors = 0;

            agents.forEach(agent => {
                if (agent.neighbors.length > 1) {
                    let edges = 0;
                    const maxEdges = agent.neighbors.length * (agent.neighbors.length - 1) / 2;

                    for (let i = 0; i < agent.neighbors.length; i++) {
                        for (let j = i + 1; j < agent.neighbors.length; j++) {
                            if (agents[agent.neighbors[i]].neighbors.includes(agent.neighbors[j])) {
                                edges++;
                            }
                        }
                    }

                    totalClustering += maxEdges > 0 ? edges / maxEdges : 0;
                    nodesWithNeighbors++;
                }
            });

            const clustering = nodesWithNeighbors > 0 ? totalClustering / nodesWithNeighbors : 0;

            // Calculate polarization (variance)
            const opinions = agents.map(a => a.opinion);
            const mean = opinions.reduce((s, o) => s + o, 0) / opinions.length;
            const variance = opinions.reduce((s, o) => s + Math.pow(o - mean, 2), 0) / opinions.length;
            const polarization = Math.sqrt(variance);

            // Count cross-group links
            let crossLinks = 0;
            let totalLinks = edges.length;

            edges.forEach(([i, j]) => {
                if (Math.abs(agents[i].opinion - agents[j].opinion) > 0.5) {
                    crossLinks++;
                }
            });

            const crossLinkPercent = totalLinks > 0 ? (crossLinks / totalLinks) * 100 : 0;

            document.getElementById('clustering').textContent = clustering.toFixed(2);
            document.getElementById('polarization').textContent = polarization.toFixed(2);
            document.getElementById('crossLinks').textContent = crossLinkPercent.toFixed(0) + '%';
            document.getElementById('rewirings').textContent = rewiringCount;

            history.push({ clustering, polarization });
            if (history.length > 200) history.shift();
        }

        function animate() {
            if (!paused) {
                updateNetwork();
                calculateStats();
            }

            drawNetwork();
            drawChart();

            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('agentCount').addEventListener('input', (e) => {
            config.agentCount = parseInt(e.target.value);
            document.getElementById('agentCountValue').textContent = config.agentCount;
            createNetwork();
        });

        document.getElementById('rewiring').addEventListener('input', (e) => {
            config.rewiring = parseFloat(e.target.value);
            document.getElementById('rewiringValue').textContent = config.rewiring.toFixed(2);
        });

        document.getElementById('homophily').addEventListener('input', (e) => {
            config.homophily = parseFloat(e.target.value);
            document.getElementById('homophilyValue').textContent = config.homophily.toFixed(2);
        });

        document.getElementById('influence').addEventListener('input', (e) => {
            config.influence = parseFloat(e.target.value);
            document.getElementById('influenceValue').textContent = config.influence.toFixed(2);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            createNetwork();
        });

        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused;
            e.target.textContent = paused ? 'Resume' : 'Pause';
        });

        window.addEventListener('resize', () => {
            initCanvas();
        });

        // Initialize
        initCanvas();
        createNetwork();
        animate();
    </script>
</body>
</html>
