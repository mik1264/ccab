<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cultural Evolution | Social Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1a4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 100, 255, 0.3);
        }
        h1 { color: #a78bfa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #a78bfa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #a78bfa; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #c4b5fd; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #a78bfa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #a78bfa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .trait-legend {
            display: flex; flex-wrap: wrap; gap: 5px;
            margin-top: 10px; font-size: 0.8em;
        }
        .trait-item {
            display: flex; align-items: center; gap: 4px;
        }
        .trait-color {
            width: 12px; height: 12px; border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Social Dynamics</a>

    <div class="controls">
        <h1>Cultural Evolution</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Axelrod's culture model</p>

        <div class="control-group">
            <label>Grid Size: <span class="value" id="sizeValue">20</span></label>
            <input type="range" id="gridSize" min="10" max="40" step="5" value="20">
        </div>

        <div class="control-group">
            <label>Cultural Traits: <span class="value" id="traitsValue">5</span></label>
            <input type="range" id="numTraits" min="3" max="10" step="1" value="5">
        </div>

        <div class="control-group">
            <label>Values per Trait: <span class="value" id="valuesValue">10</span></label>
            <input type="range" id="numValues" min="2" max="20" step="1" value="10">
        </div>

        <div class="control-group">
            <label>Mutation Rate: <span class="value" id="mutationValue">0.01</span></label>
            <input type="range" id="mutation" min="0" max="0.1" step="0.005" value="0.01">
        </div>

        <button id="runBtn">Start Simulation</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Generations</span>
                <span class="stat-value" id="generations">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Cultural Regions</span>
                <span class="stat-value" id="regions">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg. Similarity</span>
                <span class="stat-value" id="similarity">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Active Boundaries</span>
                <span class="stat-value" id="boundaries">0</span>
            </div>
        </div>

        <div class="trait-legend" id="legend"></div>

        <div class="info">
            <strong>Axelrod Model:</strong> Agents share cultural traits with similar neighbors.<br>
            <strong>Convergence:</strong> Local homogenization leads to global polarization.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGrid();
        }
        resize();
        window.onresize = resize;

        let grid = [];
        let gridSize = 20;
        let numTraits = 5;
        let numValues = 10;
        let mutationRate = 0.01;
        let running = false;
        let generations = 0;
        let cellSize;

        const traitColors = [
            '#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#a855f7',
            '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'
        ];

        function initGrid() {
            grid = [];
            generations = 0;

            const pw = canvas.width - 350;
            const ph = canvas.height - 100;
            cellSize = Math.min(pw / gridSize, ph / gridSize);

            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    const traits = [];
                    for (let t = 0; t < numTraits; t++) {
                        traits.push(Math.floor(Math.random() * numValues));
                    }
                    grid[y][x] = { traits };
                }
            }

            updateLegend();
            updateStats();
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            for (let t = 0; t < numTraits; t++) {
                const item = document.createElement('div');
                item.className = 'trait-item';
                item.innerHTML = `<div class="trait-color" style="background:${traitColors[t % traitColors.length]}"></div>Trait ${t + 1}`;
                legend.appendChild(item);
            }
        }

        function getSimilarity(a, b) {
            let matches = 0;
            for (let t = 0; t < numTraits; t++) {
                if (a.traits[t] === b.traits[t]) matches++;
            }
            return matches / numTraits;
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            if (y > 0) neighbors.push({ x, y: y - 1 });
            if (y < gridSize - 1) neighbors.push({ x, y: y + 1 });
            if (x > 0) neighbors.push({ x: x - 1, y });
            if (x < gridSize - 1) neighbors.push({ x: x + 1, y });
            return neighbors;
        }

        function step() {
            // Pick random cell
            const x = Math.floor(Math.random() * gridSize);
            const y = Math.floor(Math.random() * gridSize);
            const cell = grid[y][x];

            // Pick random neighbor
            const neighbors = getNeighbors(x, y);
            const neighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
            const neighborCell = grid[neighbor.y][neighbor.x];

            // Calculate similarity
            const similarity = getSimilarity(cell, neighborCell);

            // Interact with probability proportional to similarity
            if (similarity > 0 && similarity < 1 && Math.random() < similarity) {
                // Find differing traits
                const differing = [];
                for (let t = 0; t < numTraits; t++) {
                    if (cell.traits[t] !== neighborCell.traits[t]) {
                        differing.push(t);
                    }
                }

                // Copy one differing trait
                if (differing.length > 0) {
                    const traitIndex = differing[Math.floor(Math.random() * differing.length)];
                    cell.traits[traitIndex] = neighborCell.traits[traitIndex];
                }
            }

            // Mutation
            if (Math.random() < mutationRate) {
                const traitIndex = Math.floor(Math.random() * numTraits);
                cell.traits[traitIndex] = Math.floor(Math.random() * numValues);
            }
        }

        function update() {
            if (!running) return;

            // Many steps per frame for faster simulation
            for (let i = 0; i < gridSize * gridSize; i++) {
                step();
            }
            generations++;
            updateStats();
        }

        function countRegions() {
            const visited = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            let regionCount = 0;

            function dfs(x, y, reference) {
                if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
                if (visited[y][x]) return;
                if (getSimilarity(grid[y][x], reference) < 1) return;

                visited[y][x] = true;
                dfs(x + 1, y, reference);
                dfs(x - 1, y, reference);
                dfs(x, y + 1, reference);
                dfs(x, y - 1, reference);
            }

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!visited[y][x]) {
                        dfs(x, y, grid[y][x]);
                        regionCount++;
                    }
                }
            }

            return regionCount;
        }

        function countActiveBoundaries() {
            let active = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const neighbors = getNeighbors(x, y);
                    for (const n of neighbors) {
                        const sim = getSimilarity(grid[y][x], grid[n.y][n.x]);
                        if (sim > 0 && sim < 1) {
                            active++;
                        }
                    }
                }
            }
            return active / 2; // Each boundary counted twice
        }

        function getAverageSimilarity() {
            let totalSim = 0;
            let count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const neighbors = getNeighbors(x, y);
                    for (const n of neighbors) {
                        totalSim += getSimilarity(grid[y][x], grid[n.y][n.x]);
                        count++;
                    }
                }
            }
            return count > 0 ? totalSim / count : 0;
        }

        function updateStats() {
            document.getElementById('generations').textContent = generations;
            document.getElementById('regions').textContent = countRegions();
            document.getElementById('similarity').textContent = (getAverageSimilarity() * 100).toFixed(1) + '%';
            document.getElementById('boundaries').textContent = Math.floor(countActiveBoundaries());
        }

        function getCellColor(cell) {
            // Mix trait colors based on trait values
            let r = 0, g = 0, b = 0;
            for (let t = 0; t < numTraits; t++) {
                const color = traitColors[t % traitColors.length];
                const weight = cell.traits[t] / (numValues - 1);
                const hex = color.slice(1);
                r += parseInt(hex.slice(0, 2), 16) * weight / numTraits;
                g += parseInt(hex.slice(2, 4), 16) * weight / numTraits;
                b += parseInt(hex.slice(4, 6), 16) * weight / numTraits;
            }
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            const offsetX = 50;
            const offsetY = 50;

            // Draw grid
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];
                    ctx.fillStyle = getCellColor(cell);
                    ctx.fillRect(
                        offsetX + x * cellSize,
                        offsetY + y * cellSize,
                        cellSize - 1,
                        cellSize - 1
                    );
                }
            }

            // Draw cultural boundaries
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];

                    // Check right neighbor
                    if (x < gridSize - 1) {
                        const right = grid[y][x + 1];
                        if (getSimilarity(cell, right) === 0) {
                            ctx.beginPath();
                            ctx.moveTo(offsetX + (x + 1) * cellSize, offsetY + y * cellSize);
                            ctx.lineTo(offsetX + (x + 1) * cellSize, offsetY + (y + 1) * cellSize);
                            ctx.stroke();
                        }
                    }

                    // Check bottom neighbor
                    if (y < gridSize - 1) {
                        const bottom = grid[y + 1][x];
                        if (getSimilarity(cell, bottom) === 0) {
                            ctx.beginPath();
                            ctx.moveTo(offsetX + x * cellSize, offsetY + (y + 1) * cellSize);
                            ctx.lineTo(offsetX + (x + 1) * cellSize, offsetY + (y + 1) * cellSize);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Axelrod Cultural Dynamics', 50, 30);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('gridSize').oninput = (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = gridSize;
        };

        document.getElementById('numTraits').oninput = (e) => {
            numTraits = parseInt(e.target.value);
            document.getElementById('traitsValue').textContent = numTraits;
        };

        document.getElementById('numValues').oninput = (e) => {
            numValues = parseInt(e.target.value);
            document.getElementById('valuesValue').textContent = numValues;
        };

        document.getElementById('mutation').oninput = (e) => {
            mutationRate = parseFloat(e.target.value);
            document.getElementById('mutationValue').textContent = mutationRate.toFixed(3);
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Start Simulation';
        };

        document.getElementById('resetBtn').onclick = initGrid;

        // Initialize
        initGrid();
        draw();
    </script>
</body>
</html>
