<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumor Spreading | Social Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1a4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 100, 255, 0.3);
        }
        h1 { color: #a78bfa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #a78bfa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #a78bfa; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #c4b5fd; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #a78bfa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #a78bfa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 8px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 15px; height: 15px; border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Social Dynamics</a>

    <div class="controls">
        <h1>Rumor Spreading</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">SIR-like information diffusion</p>

        <div class="control-group">
            <label>Model:</label>
            <select id="model">
                <option value="sir">SIR (Spreader-Ignorant-Stifler)</option>
                <option value="complex">Complex Contagion</option>
                <option value="independent">Independent Cascade</option>
            </select>
        </div>

        <div class="control-group">
            <label>Population: <span class="value" id="popValue">200</span></label>
            <input type="range" id="population" min="50" max="500" step="25" value="200">
        </div>

        <div class="control-group">
            <label>Spread Rate (β): <span class="value" id="betaValue">0.3</span></label>
            <input type="range" id="beta" min="0.1" max="0.8" step="0.05" value="0.3">
        </div>

        <div class="control-group">
            <label>Stifling Rate (γ): <span class="value" id="gammaValue">0.1</span></label>
            <input type="range" id="gamma" min="0" max="0.3" step="0.02" value="0.1">
        </div>

        <div class="control-group">
            <label>Network Density: <span class="value" id="densityValue">0.05</span></label>
            <input type="range" id="networkDensity" min="0.02" max="0.15" step="0.01" value="0.05">
        </div>

        <button id="startRumor">Start Rumor (Click Node)</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset Network</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time Step</span>
                <span class="stat-value" id="timeStep">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label" style="color:#666">Ignorant</span>
                <span class="stat-value" style="color:#666" id="ignorant">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label" style="color:#22c55e">Spreaders</span>
                <span class="stat-value" style="color:#22c55e" id="spreaders">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label" style="color:#ef4444">Stiflers</span>
                <span class="stat-value" style="color:#ef4444" id="stiflers">0</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background:#666"></div>
                <span>Ignorant (hasn't heard)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#22c55e"></div>
                <span>Spreader (actively sharing)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#ef4444"></div>
                <span>Stifler (stopped sharing)</span>
            </div>
        </div>

        <div class="info">
            <strong>Click</strong> on a node to start spreading a rumor.<br>
            <strong>SIR model:</strong> Spreaders become stiflers when meeting other spreaders/stiflers.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initNetwork();
        }
        resize();
        window.onresize = resize;

        const IGNORANT = 0;
        const SPREADER = 1;
        const STIFLER = 2;

        let nodes = [];
        let edges = [];
        let nPopulation = 200;
        let beta = 0.3;
        let gamma = 0.1;
        let density = 0.05;
        let model = 'sir';
        let timeStep = 0;
        let running = false;
        let history = [];

        function initNetwork() {
            nodes = [];
            edges = [];
            history = [];
            timeStep = 0;
            running = false;

            const pw = canvas.width - 400;
            const ph = canvas.height;

            // Create nodes
            for (let i = 0; i < nPopulation; i++) {
                nodes.push({
                    x: 100 + Math.random() * (pw - 200),
                    y: 100 + Math.random() * (ph - 200),
                    vx: 0,
                    vy: 0,
                    state: IGNORANT,
                    threshold: 0.1 + Math.random() * 0.3 // For complex contagion
                });
            }

            // Create edges based on proximity and density
            for (let i = 0; i < nPopulation; i++) {
                for (let j = i + 1; j < nPopulation; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Probability based on distance
                    const prob = density * Math.exp(-dist / 200);
                    if (Math.random() < prob) {
                        edges.push([i, j]);
                    }
                }
            }

            // Force-directed layout
            for (let iter = 0; iter < 100; iter++) {
                layoutStep();
            }

            updateStats();
        }

        function layoutStep() {
            const pw = canvas.width - 400;
            const ph = canvas.height;

            // Reset forces
            for (const node of nodes) {
                node.vx = 0;
                node.vy = 0;
            }

            // Repulsion
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;

                    const force = 500 / (dist * dist);
                    nodes[i].vx -= dx / dist * force;
                    nodes[i].vy -= dy / dist * force;
                    nodes[j].vx += dx / dist * force;
                    nodes[j].vy += dy / dist * force;
                }
            }

            // Attraction along edges
            for (const [i, j] of edges) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const force = dist * 0.01;
                nodes[i].vx += dx / dist * force;
                nodes[i].vy += dy / dist * force;
                nodes[j].vx -= dx / dist * force;
                nodes[j].vy -= dy / dist * force;
            }

            // Apply forces
            for (const node of nodes) {
                node.x += node.vx;
                node.y += node.vy;

                // Bounds
                node.x = Math.max(80, Math.min(pw - 80, node.x));
                node.y = Math.max(80, Math.min(ph - 80, node.y));
            }
        }

        function getNeighbors(nodeIdx) {
            const neighbors = [];
            for (const [i, j] of edges) {
                if (i === nodeIdx) neighbors.push(j);
                if (j === nodeIdx) neighbors.push(i);
            }
            return neighbors;
        }

        function updateSIR() {
            const newStates = nodes.map(n => n.state);

            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].state === SPREADER) {
                    const neighbors = getNeighbors(i);

                    for (const j of neighbors) {
                        if (nodes[j].state === IGNORANT) {
                            // Spread rumor
                            if (Math.random() < beta) {
                                newStates[j] = SPREADER;
                            }
                        } else if (nodes[j].state === SPREADER || nodes[j].state === STIFLER) {
                            // Become stifler
                            if (Math.random() < gamma) {
                                newStates[i] = STIFLER;
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < nodes.length; i++) {
                nodes[i].state = newStates[i];
            }
        }

        function updateComplexContagion() {
            const newStates = nodes.map(n => n.state);

            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].state === IGNORANT) {
                    const neighbors = getNeighbors(i);
                    if (neighbors.length === 0) continue;

                    const activeNeighbors = neighbors.filter(j =>
                        nodes[j].state === SPREADER
                    ).length;

                    const fraction = activeNeighbors / neighbors.length;

                    if (fraction >= nodes[i].threshold) {
                        newStates[i] = SPREADER;
                    }
                } else if (nodes[i].state === SPREADER) {
                    if (Math.random() < gamma) {
                        newStates[i] = STIFLER;
                    }
                }
            }

            for (let i = 0; i < nodes.length; i++) {
                nodes[i].state = newStates[i];
            }
        }

        function updateIndependentCascade() {
            const newStates = nodes.map(n => n.state);
            const activated = new Set();

            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].state === SPREADER) {
                    const neighbors = getNeighbors(i);

                    for (const j of neighbors) {
                        if (nodes[j].state === IGNORANT && !activated.has(j)) {
                            if (Math.random() < beta) {
                                newStates[j] = SPREADER;
                                activated.add(j);
                            }
                        }
                    }

                    // Spreader only spreads once then becomes stifler
                    newStates[i] = STIFLER;
                }
            }

            for (let i = 0; i < nodes.length; i++) {
                nodes[i].state = newStates[i];
            }
        }

        function update() {
            if (!running) return;

            // Check if any spreaders left
            const spreaders = nodes.filter(n => n.state === SPREADER).length;
            if (spreaders === 0) {
                running = false;
                return;
            }

            switch (model) {
                case 'sir': updateSIR(); break;
                case 'complex': updateComplexContagion(); break;
                case 'independent': updateIndependentCascade(); break;
            }

            timeStep++;
            updateStats();
        }

        function updateStats() {
            const counts = [0, 0, 0];
            for (const n of nodes) {
                counts[n.state]++;
            }

            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('ignorant').textContent = counts[IGNORANT];
            document.getElementById('spreaders').textContent = counts[SPREADER];
            document.getElementById('stiflers').textContent = counts[STIFLER];

            history.push([...counts]);
            if (history.length > 200) history.shift();
        }

        function drawGraph() {
            const graphX = 50;
            const graphY = canvas.height - 180;
            const graphW = canvas.width - 450;
            const graphH = 150;

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(graphX - 10, graphY - 30, graphW + 20, graphH + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Rumor Spread Over Time', graphX, graphY - 10);

            if (history.length < 2) return;

            const maxH = Math.max(1, nPopulation);

            // Draw stacked areas
            const colors = ['#666', '#22c55e', '#ef4444'];

            for (let layer = 2; layer >= 0; layer--) {
                ctx.beginPath();
                ctx.fillStyle = colors[layer] + '88';

                ctx.moveTo(graphX, graphY + graphH);

                for (let t = 0; t < history.length; t++) {
                    const x = graphX + (t / (history.length - 1)) * graphW;
                    let cumulative = 0;
                    for (let l = 0; l <= layer; l++) {
                        cumulative += history[t][l];
                    }
                    const y = graphY + graphH - (cumulative / maxH) * graphH;
                    ctx.lineTo(x, y);
                }

                ctx.lineTo(graphX + graphW, graphY + graphH);
                ctx.closePath();
                ctx.fill();
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            // Draw edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw active spreading edges
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.5)';
            ctx.lineWidth = 2;
            for (const [i, j] of edges) {
                if ((nodes[i].state === SPREADER && nodes[j].state === IGNORANT) ||
                    (nodes[j].state === SPREADER && nodes[i].state === IGNORANT)) {
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[j].x, nodes[j].y);
                    ctx.stroke();
                }
            }

            // Draw nodes
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];

                ctx.beginPath();
                ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);

                switch (node.state) {
                    case IGNORANT:
                        ctx.fillStyle = '#666';
                        break;
                    case SPREADER:
                        ctx.fillStyle = '#22c55e';
                        // Pulsing effect
                        ctx.arc(node.x, node.y, 12 + Math.sin(timeStep * 0.3) * 3, 0, Math.PI * 2);
                        break;
                    case STIFLER:
                        ctx.fillStyle = '#ef4444';
                        break;
                }
                ctx.fill();
            }

            drawGraph();

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Social Network - Rumor/Information Spreading', 50, 30);

            requestAnimationFrame(draw);
        }

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // Find clicked node
            for (let i = 0; i < nodes.length; i++) {
                const dx = nodes[i].x - mx;
                const dy = nodes[i].y - my;
                if (dx * dx + dy * dy < 200) {
                    nodes[i].state = SPREADER;
                    running = true;
                    break;
                }
            }
        };

        // Event listeners
        document.getElementById('model').onchange = (e) => {
            model = e.target.value;
        };

        document.getElementById('population').oninput = (e) => {
            nPopulation = parseInt(e.target.value);
            document.getElementById('popValue').textContent = nPopulation;
        };

        document.getElementById('beta').oninput = (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('betaValue').textContent = beta.toFixed(2);
        };

        document.getElementById('gamma').oninput = (e) => {
            gamma = parseFloat(e.target.value);
            document.getElementById('gammaValue').textContent = gamma.toFixed(2);
        };

        document.getElementById('networkDensity').oninput = (e) => {
            density = parseFloat(e.target.value);
            document.getElementById('densityValue').textContent = density.toFixed(2);
        };

        document.getElementById('startRumor').onclick = () => {
            // Start from random node
            const i = Math.floor(Math.random() * nodes.length);
            nodes[i].state = SPREADER;
            running = true;
        };

        document.getElementById('resetBtn').onclick = initNetwork;

        // Simulation loop
        setInterval(() => {
            if (running) update();
        }, 200);

        // Initialize
        initNetwork();
        draw();
    </script>
</body>
</html>
