<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Evolution | Social Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1a4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 100, 255, 0.3);
            max-height: 90vh;
            overflow-y: auto;
        }
        h1 { color: #a78bfa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #a78bfa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #a78bfa; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #c4b5fd; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #a78bfa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #a78bfa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .word-display {
            background: rgba(167, 139, 250, 0.1);
            border: 1px solid rgba(167, 139, 250, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
        }
        .word-item {
            display: inline-block;
            background: rgba(167, 139, 250, 0.2);
            padding: 3px 8px;
            margin: 2px;
            border-radius: 10px;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Social Dynamics</a>

    <div class="controls">
        <h1>Language Evolution</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Naming game dynamics</p>

        <div class="control-group">
            <label>Population: <span class="value" id="popValue">50</span></label>
            <input type="range" id="population" min="20" max="100" step="10" value="50">
        </div>

        <div class="control-group">
            <label>Objects in World: <span class="value" id="objectsValue">5</span></label>
            <input type="range" id="objects" min="3" max="15" step="1" value="5">
        </div>

        <div class="control-group">
            <label>Memory Size: <span class="value" id="memoryValue">10</span></label>
            <input type="range" id="memory" min="3" max="20" step="1" value="10">
        </div>

        <div class="control-group">
            <label>Interaction Range: <span class="value" id="rangeValue">100</span></label>
            <input type="range" id="range" min="50" max="200" step="10" value="100">
        </div>

        <button id="runBtn">Start Simulation</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Interactions</span>
                <span class="stat-value" id="interactions">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Success Rate</span>
                <span class="stat-value" id="successRate">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Unique Words</span>
                <span class="stat-value" id="uniqueWords">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Convergence</span>
                <span class="stat-value" id="convergence">0%</span>
            </div>
        </div>

        <div class="word-display" id="wordDisplay">
            <strong style="color:#a78bfa;">Dominant Words:</strong>
            <div id="dominantWords"></div>
        </div>

        <div class="info">
            <strong>Naming Game:</strong> Agents invent and negotiate shared vocabulary.<br>
            <strong>Convergence:</strong> Community agrees on names through interactions.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initSimulation();
        }
        resize();
        window.onresize = resize;

        let agents = [];
        let objects = [];
        let nPopulation = 50;
        let nObjects = 5;
        let memorySize = 10;
        let interactionRange = 100;
        let running = false;
        let interactions = 0;
        let successes = 0;
        let history = [];

        const objectColors = [
            '#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#a855f7',
            '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1',
            '#14b8a6', '#f43f5e', '#8b5cf6', '#eab308', '#10b981'
        ];

        function generateWord() {
            const consonants = 'bcdfghjklmnpqrstvwxyz';
            const vowels = 'aeiou';
            let word = '';
            const length = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < length; i++) {
                word += consonants[Math.floor(Math.random() * consonants.length)];
                word += vowels[Math.floor(Math.random() * vowels.length)];
            }
            return word;
        }

        function initSimulation() {
            agents = [];
            objects = [];
            interactions = 0;
            successes = 0;
            history = [];

            const pw = canvas.width - 350;
            const ph = canvas.height;

            // Create objects
            for (let i = 0; i < nObjects; i++) {
                objects.push({
                    id: i,
                    x: 100 + Math.random() * (pw - 200),
                    y: 100 + Math.random() * (ph - 200),
                    color: objectColors[i % objectColors.length]
                });
            }

            // Create agents
            for (let i = 0; i < nPopulation; i++) {
                const vocabulary = {};
                for (let j = 0; j < nObjects; j++) {
                    vocabulary[j] = []; // Empty vocabulary for each object
                }
                agents.push({
                    x: 100 + Math.random() * (pw - 200),
                    y: 100 + Math.random() * (ph - 200),
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    vocabulary: vocabulary,
                    speaking: false,
                    hearing: false,
                    lastSuccess: false
                });
            }

            updateStats();
        }

        function interact(speaker, hearer, objectId) {
            interactions++;

            // Speaker chooses a word
            let word;
            if (speaker.vocabulary[objectId].length === 0) {
                // Invent new word
                word = generateWord();
                speaker.vocabulary[objectId].push(word);
            } else {
                // Use random known word
                word = speaker.vocabulary[objectId][Math.floor(Math.random() * speaker.vocabulary[objectId].length)];
            }

            speaker.speaking = true;
            hearer.hearing = true;

            // Hearer interprets
            let success = false;
            if (hearer.vocabulary[objectId].includes(word)) {
                // Success! Both keep only this word
                success = true;
                successes++;
                speaker.vocabulary[objectId] = [word];
                hearer.vocabulary[objectId] = [word];
            } else {
                // Failure - hearer adds the word
                if (hearer.vocabulary[objectId].length < memorySize) {
                    hearer.vocabulary[objectId].push(word);
                } else {
                    // Replace oldest word
                    hearer.vocabulary[objectId].shift();
                    hearer.vocabulary[objectId].push(word);
                }
            }

            speaker.lastSuccess = success;
            hearer.lastSuccess = success;

            return success;
        }

        function getClosestObject(x, y) {
            let closest = null;
            let minDist = Infinity;
            for (const obj of objects) {
                const dx = obj.x - x;
                const dy = obj.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    closest = obj;
                }
            }
            return closest;
        }

        function update() {
            if (!running) return;

            const pw = canvas.width - 350;
            const ph = canvas.height;

            // Reset speaking/hearing flags
            for (const agent of agents) {
                agent.speaking = false;
                agent.hearing = false;
            }

            // Random interactions
            for (let i = 0; i < 5; i++) {
                const speakerIdx = Math.floor(Math.random() * agents.length);
                const speaker = agents[speakerIdx];

                // Find nearby agents
                const nearby = [];
                for (let j = 0; j < agents.length; j++) {
                    if (j === speakerIdx) continue;
                    const dx = agents[j].x - speaker.x;
                    const dy = agents[j].y - speaker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < interactionRange) {
                        nearby.push(agents[j]);
                    }
                }

                if (nearby.length > 0) {
                    const hearer = nearby[Math.floor(Math.random() * nearby.length)];
                    const midX = (speaker.x + hearer.x) / 2;
                    const midY = (speaker.y + hearer.y) / 2;
                    const obj = getClosestObject(midX, midY);
                    if (obj) {
                        interact(speaker, hearer, obj.id);
                    }
                }
            }

            // Move agents
            for (const agent of agents) {
                agent.vx += (Math.random() - 0.5) * 0.3;
                agent.vy += (Math.random() - 0.5) * 0.3;

                agent.vx *= 0.95;
                agent.vy *= 0.95;

                const speed = Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy);
                if (speed > 2) {
                    agent.vx *= 2 / speed;
                    agent.vy *= 2 / speed;
                }

                agent.x += agent.vx;
                agent.y += agent.vy;

                agent.x = Math.max(50, Math.min(pw - 50, agent.x));
                agent.y = Math.max(50, Math.min(ph - 50, agent.y));
            }

            updateStats();
        }

        function getDominantWords() {
            const wordCounts = {};
            for (let objId = 0; objId < nObjects; objId++) {
                wordCounts[objId] = {};
                for (const agent of agents) {
                    for (const word of agent.vocabulary[objId]) {
                        wordCounts[objId][word] = (wordCounts[objId][word] || 0) + 1;
                    }
                }
            }

            const dominant = {};
            for (let objId = 0; objId < nObjects; objId++) {
                const words = Object.entries(wordCounts[objId]);
                if (words.length > 0) {
                    words.sort((a, b) => b[1] - a[1]);
                    dominant[objId] = { word: words[0][0], count: words[0][1] };
                }
            }
            return dominant;
        }

        function getConvergence() {
            let totalAgree = 0;
            let totalPairs = 0;
            for (let objId = 0; objId < nObjects; objId++) {
                for (let i = 0; i < agents.length; i++) {
                    for (let j = i + 1; j < agents.length; j++) {
                        const a = agents[i].vocabulary[objId];
                        const b = agents[j].vocabulary[objId];
                        const shared = a.filter(w => b.includes(w));
                        if (shared.length > 0) totalAgree++;
                        totalPairs++;
                    }
                }
            }
            return totalPairs > 0 ? totalAgree / totalPairs : 0;
        }

        function getUniqueWordCount() {
            const allWords = new Set();
            for (const agent of agents) {
                for (let objId = 0; objId < nObjects; objId++) {
                    for (const word of agent.vocabulary[objId]) {
                        allWords.add(word);
                    }
                }
            }
            return allWords.size;
        }

        function updateStats() {
            const successRate = interactions > 0 ? (successes / interactions) * 100 : 0;
            document.getElementById('interactions').textContent = interactions;
            document.getElementById('successRate').textContent = successRate.toFixed(1) + '%';
            document.getElementById('uniqueWords').textContent = getUniqueWordCount();
            document.getElementById('convergence').textContent = (getConvergence() * 100).toFixed(1) + '%';

            // Update dominant words display
            const dominant = getDominantWords();
            const container = document.getElementById('dominantWords');
            container.innerHTML = '';
            for (let objId = 0; objId < nObjects; objId++) {
                if (dominant[objId]) {
                    const item = document.createElement('span');
                    item.className = 'word-item';
                    item.style.borderLeft = `3px solid ${objectColors[objId]}`;
                    item.textContent = `"${dominant[objId].word}" (${dominant[objId].count})`;
                    container.appendChild(item);
                }
            }

            history.push({ success: successRate, convergence: getConvergence() * 100 });
            if (history.length > 200) history.shift();
        }

        function drawHistory() {
            const graphX = 50;
            const graphY = canvas.height - 180;
            const graphW = canvas.width - 450;
            const graphH = 150;

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(graphX - 10, graphY - 30, graphW + 20, graphH + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Language Convergence Over Time', graphX, graphY - 10);

            if (history.length < 2) return;

            // Convergence line
            ctx.beginPath();
            ctx.strokeStyle = '#a78bfa';
            ctx.lineWidth = 2;
            for (let i = 0; i < history.length; i++) {
                const x = graphX + (i / (history.length - 1)) * graphW;
                const y = graphY + graphH - (history[i].convergence / 100) * graphH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Success rate line
            ctx.beginPath();
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            for (let i = 0; i < history.length; i++) {
                const x = graphX + (i / (history.length - 1)) * graphW;
                const y = graphY + graphH - (history[i].success / 100) * graphH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            // Draw objects
            for (const obj of objects) {
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, 25, 0, Math.PI * 2);
                ctx.fillStyle = obj.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`Obj ${obj.id + 1}`, obj.x, obj.y + 4);
            }

            // Draw agents
            for (const agent of agents) {
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, 6, 0, Math.PI * 2);

                if (agent.speaking) {
                    ctx.fillStyle = '#22c55e';
                } else if (agent.hearing) {
                    ctx.fillStyle = '#3b82f6';
                } else {
                    ctx.fillStyle = '#888';
                }
                ctx.fill();

                if (agent.lastSuccess) {
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            drawHistory();

            // Legend
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(canvas.width - 340, canvas.height - 100, 15, 15);
            ctx.fillStyle = '#a78bfa';
            ctx.fillRect(canvas.width - 340, canvas.height - 75, 15, 15);
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Success Rate', canvas.width - 320, canvas.height - 88);
            ctx.fillText('Convergence', canvas.width - 320, canvas.height - 63);

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText('Language Evolution - Naming Game', 50, 30);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('population').oninput = (e) => {
            nPopulation = parseInt(e.target.value);
            document.getElementById('popValue').textContent = nPopulation;
        };

        document.getElementById('objects').oninput = (e) => {
            nObjects = parseInt(e.target.value);
            document.getElementById('objectsValue').textContent = nObjects;
        };

        document.getElementById('memory').oninput = (e) => {
            memorySize = parseInt(e.target.value);
            document.getElementById('memoryValue').textContent = memorySize;
        };

        document.getElementById('range').oninput = (e) => {
            interactionRange = parseInt(e.target.value);
            document.getElementById('rangeValue').textContent = interactionRange;
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Start Simulation';
        };

        document.getElementById('resetBtn').onclick = initSimulation;

        // Initialize
        initSimulation();
        draw();
    </script>
</body>
</html>
