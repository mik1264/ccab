<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trust Dynamics | Social Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1a4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 100, 255, 0.3);
        }
        h1 { color: #a78bfa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #a78bfa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #a78bfa; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #c4b5fd; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #a78bfa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #a78bfa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Social Dynamics</a>

    <div class="controls">
        <h1>Trust Dynamics</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Reputation & cooperation</p>

        <div class="control-group">
            <label>Population: <span class="value" id="popValue">40</span></label>
            <input type="range" id="population" min="20" max="80" step="5" value="40">
        </div>

        <div class="control-group">
            <label>Trust Gain (Cooperation): <span class="value" id="gainValue">0.1</span></label>
            <input type="range" id="trustGain" min="0.01" max="0.3" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Trust Loss (Defection): <span class="value" id="lossValue">0.2</span></label>
            <input type="range" id="trustLoss" min="0.1" max="0.5" step="0.02" value="0.2">
        </div>

        <div class="control-group">
            <label>Defection Rate: <span class="value" id="defectValue">0.1</span></label>
            <input type="range" id="defectRate" min="0" max="0.5" step="0.02" value="0.1">
        </div>

        <div class="control-group">
            <label>Gossip Radius: <span class="value" id="gossipValue">150</span></label>
            <input type="range" id="gossipRadius" min="50" max="300" step="10" value="150">
        </div>

        <button id="runBtn">Start Simulation</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset</button>
        <button id="betrayBtn" style="background:#ef4444">Major Betrayal</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Interactions</span>
                <span class="stat-value" id="interactions">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg. Trust</span>
                <span class="stat-value" id="avgTrust">50%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Cooperation Rate</span>
                <span class="stat-value" id="coopRate">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Strong Bonds</span>
                <span class="stat-value" id="strongBonds">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Broken Bonds</span>
                <span class="stat-value" id="brokenBonds">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Trust Network:</strong> Trust builds slowly but breaks quickly.<br>
            <strong>Gossip:</strong> Reputation spreads through the network.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initSimulation();
        }
        resize();
        window.onresize = resize;

        let agents = [];
        let trustMatrix = [];
        let nPopulation = 40;
        let trustGain = 0.1;
        let trustLoss = 0.2;
        let defectRate = 0.1;
        let gossipRadius = 150;
        let running = false;
        let interactions = 0;
        let cooperations = 0;
        let history = [];

        function initSimulation() {
            agents = [];
            trustMatrix = [];
            interactions = 0;
            cooperations = 0;
            history = [];

            const pw = canvas.width - 350;
            const ph = canvas.height;

            // Initialize trust matrix (everyone starts neutral)
            for (let i = 0; i < nPopulation; i++) {
                trustMatrix[i] = [];
                for (let j = 0; j < nPopulation; j++) {
                    trustMatrix[i][j] = i === j ? 1 : 0.5;
                }
            }

            // Create agents
            for (let i = 0; i < nPopulation; i++) {
                agents.push({
                    id: i,
                    x: 150 + Math.random() * (pw - 300),
                    y: 100 + Math.random() * (ph - 200),
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    trustworthiness: 0.5 + Math.random() * 0.5, // Innate trustworthiness
                    cooperating: false,
                    defecting: false
                });
            }

            updateStats();
        }

        function interact(a, b) {
            interactions++;

            // Decision to cooperate based on trust
            const aTrustsB = trustMatrix[a.id][b.id];
            const bTrustsA = trustMatrix[b.id][a.id];

            // Will they cooperate?
            const aCooperates = Math.random() < aTrustsB * a.trustworthiness && Math.random() > defectRate;
            const bCooperates = Math.random() < bTrustsA * b.trustworthiness && Math.random() > defectRate;

            a.cooperating = aCooperates;
            a.defecting = !aCooperates;
            b.cooperating = bCooperates;
            b.defecting = !bCooperates;

            if (aCooperates && bCooperates) {
                // Both cooperate - trust increases
                trustMatrix[a.id][b.id] = Math.min(1, trustMatrix[a.id][b.id] + trustGain);
                trustMatrix[b.id][a.id] = Math.min(1, trustMatrix[b.id][a.id] + trustGain);
                cooperations += 2;
            } else if (!aCooperates && !bCooperates) {
                // Both defect - trust decreases slightly
                trustMatrix[a.id][b.id] = Math.max(0, trustMatrix[a.id][b.id] - trustLoss * 0.5);
                trustMatrix[b.id][a.id] = Math.max(0, trustMatrix[b.id][a.id] - trustLoss * 0.5);
            } else {
                // One defects - big trust loss for defector
                if (!aCooperates) {
                    trustMatrix[b.id][a.id] = Math.max(0, trustMatrix[b.id][a.id] - trustLoss);
                } else {
                    cooperations++;
                }
                if (!bCooperates) {
                    trustMatrix[a.id][b.id] = Math.max(0, trustMatrix[a.id][b.id] - trustLoss);
                } else {
                    cooperations++;
                }
            }

            // Gossip - spread reputation to nearby agents
            spreadGossip(a, b, aCooperates, bCooperates);
        }

        function spreadGossip(a, b, aCooperated, bCooperated) {
            for (const agent of agents) {
                if (agent.id === a.id || agent.id === b.id) continue;

                const distToA = Math.sqrt((agent.x - a.x) ** 2 + (agent.y - a.y) ** 2);
                const distToB = Math.sqrt((agent.x - b.x) ** 2 + (agent.y - b.y) ** 2);

                // If close to A, hear about B's behavior
                if (distToA < gossipRadius) {
                    const influence = 0.02 * (1 - distToA / gossipRadius);
                    if (bCooperated) {
                        trustMatrix[agent.id][b.id] = Math.min(1, trustMatrix[agent.id][b.id] + influence);
                    } else {
                        trustMatrix[agent.id][b.id] = Math.max(0, trustMatrix[agent.id][b.id] - influence * 2);
                    }
                }

                // If close to B, hear about A's behavior
                if (distToB < gossipRadius) {
                    const influence = 0.02 * (1 - distToB / gossipRadius);
                    if (aCooperated) {
                        trustMatrix[agent.id][a.id] = Math.min(1, trustMatrix[agent.id][a.id] + influence);
                    } else {
                        trustMatrix[agent.id][a.id] = Math.max(0, trustMatrix[agent.id][a.id] - influence * 2);
                    }
                }
            }
        }

        function majorBetrayal() {
            // Random agent betrays everyone nearby
            const betrayer = agents[Math.floor(Math.random() * agents.length)];
            for (const agent of agents) {
                if (agent.id === betrayer.id) continue;
                const dist = Math.sqrt((agent.x - betrayer.x) ** 2 + (agent.y - betrayer.y) ** 2);
                if (dist < 200) {
                    trustMatrix[agent.id][betrayer.id] = Math.max(0, trustMatrix[agent.id][betrayer.id] - 0.5);
                }
            }
            betrayer.trustworthiness = Math.max(0, betrayer.trustworthiness - 0.2);
        }

        function update() {
            if (!running) return;

            const pw = canvas.width - 350;
            const ph = canvas.height;

            // Reset visual states
            for (const agent of agents) {
                agent.cooperating = false;
                agent.defecting = false;
            }

            // Random interactions
            for (let i = 0; i < 3; i++) {
                const aIdx = Math.floor(Math.random() * agents.length);
                const a = agents[aIdx];

                // Find nearby partner
                const nearby = agents.filter((b, idx) => {
                    if (idx === aIdx) return false;
                    const dist = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
                    return dist < 100;
                });

                if (nearby.length > 0) {
                    const b = nearby[Math.floor(Math.random() * nearby.length)];
                    interact(a, b);
                }
            }

            // Move agents - attract to trusted, repel from untrusted
            for (const agent of agents) {
                let fx = 0, fy = 0;

                for (const other of agents) {
                    if (other.id === agent.id) continue;
                    const dx = other.x - agent.x;
                    const dy = other.y - agent.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;

                    const trust = trustMatrix[agent.id][other.id];

                    if (dist < 40) {
                        // Too close, repel
                        fx -= dx / dist * 0.5;
                        fy -= dy / dist * 0.5;
                    } else if (dist < 150) {
                        if (trust > 0.6) {
                            // Attract to trusted
                            fx += dx / dist * 0.1 * trust;
                            fy += dy / dist * 0.1 * trust;
                        } else if (trust < 0.3) {
                            // Avoid untrusted
                            fx -= dx / dist * 0.05 * (1 - trust);
                            fy -= dy / dist * 0.05 * (1 - trust);
                        }
                    }
                }

                agent.vx += fx + (Math.random() - 0.5) * 0.2;
                agent.vy += fy + (Math.random() - 0.5) * 0.2;

                agent.vx *= 0.95;
                agent.vy *= 0.95;

                const speed = Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy);
                if (speed > 2) {
                    agent.vx *= 2 / speed;
                    agent.vy *= 2 / speed;
                }

                agent.x += agent.vx;
                agent.y += agent.vy;

                agent.x = Math.max(50, Math.min(pw - 50, agent.x));
                agent.y = Math.max(50, Math.min(ph - 50, agent.y));
            }

            updateStats();
        }

        function getAverageTrust() {
            let total = 0;
            let count = 0;
            for (let i = 0; i < nPopulation; i++) {
                for (let j = 0; j < nPopulation; j++) {
                    if (i !== j) {
                        total += trustMatrix[i][j];
                        count++;
                    }
                }
            }
            return count > 0 ? total / count : 0;
        }

        function countBonds() {
            let strong = 0;
            let broken = 0;
            for (let i = 0; i < nPopulation; i++) {
                for (let j = i + 1; j < nPopulation; j++) {
                    const mutual = Math.min(trustMatrix[i][j], trustMatrix[j][i]);
                    if (mutual > 0.8) strong++;
                    if (mutual < 0.2) broken++;
                }
            }
            return { strong, broken };
        }

        function updateStats() {
            const avgTrust = getAverageTrust();
            const bonds = countBonds();
            const coopRate = interactions > 0 ? (cooperations / (interactions * 2)) * 100 : 0;

            document.getElementById('interactions').textContent = interactions;
            document.getElementById('avgTrust').textContent = (avgTrust * 100).toFixed(1) + '%';
            document.getElementById('coopRate').textContent = coopRate.toFixed(1) + '%';
            document.getElementById('strongBonds').textContent = bonds.strong;
            document.getElementById('brokenBonds').textContent = bonds.broken;

            history.push({ trust: avgTrust * 100, coop: coopRate });
            if (history.length > 200) history.shift();
        }

        function drawHistory() {
            const graphX = 50;
            const graphY = canvas.height - 180;
            const graphW = canvas.width - 450;
            const graphH = 150;

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(graphX - 10, graphY - 30, graphW + 20, graphH + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Trust & Cooperation Over Time', graphX, graphY - 10);

            if (history.length < 2) return;

            // Trust line
            ctx.beginPath();
            ctx.strokeStyle = '#a78bfa';
            ctx.lineWidth = 2;
            for (let i = 0; i < history.length; i++) {
                const x = graphX + (i / (history.length - 1)) * graphW;
                const y = graphY + graphH - (history[i].trust / 100) * graphH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Cooperation line
            ctx.beginPath();
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            for (let i = 0; i < history.length; i++) {
                const x = graphX + (i / (history.length - 1)) * graphW;
                const y = graphY + graphH - (history[i].coop / 100) * graphH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            // Draw trust links
            for (let i = 0; i < agents.length; i++) {
                for (let j = i + 1; j < agents.length; j++) {
                    const a = agents[i];
                    const b = agents[j];
                    const trust = Math.min(trustMatrix[i][j], trustMatrix[j][i]);

                    if (trust > 0.6) {
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.strokeStyle = `rgba(34, 197, 94, ${(trust - 0.6) * 2})`;
                        ctx.lineWidth = (trust - 0.6) * 3;
                        ctx.stroke();
                    } else if (trust < 0.2) {
                        const dist = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
                        if (dist < 100) {
                            ctx.beginPath();
                            ctx.moveTo(a.x, a.y);
                            ctx.lineTo(b.x, b.y);
                            ctx.strokeStyle = `rgba(239, 68, 68, ${(0.2 - trust) * 2})`;
                            ctx.lineWidth = 1;
                            ctx.setLineDash([3, 3]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                }
            }

            // Draw agents
            for (const agent of agents) {
                // Agent reputation glow
                const avgTrust = agents.reduce((sum, other) => {
                    if (other.id === agent.id) return sum;
                    return sum + trustMatrix[other.id][agent.id];
                }, 0) / (agents.length - 1);

                ctx.beginPath();
                ctx.arc(agent.x, agent.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(167, 139, 250, ${avgTrust * 0.3})`;
                ctx.fill();

                // Agent body
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, 8, 0, Math.PI * 2);

                if (agent.cooperating) {
                    ctx.fillStyle = '#22c55e';
                } else if (agent.defecting) {
                    ctx.fillStyle = '#ef4444';
                } else {
                    // Color by trustworthiness
                    const tw = agent.trustworthiness;
                    ctx.fillStyle = `rgb(${Math.floor(255 * (1 - tw))}, ${Math.floor(180 * tw)}, ${Math.floor(100 + 100 * tw)})`;
                }
                ctx.fill();

                // Border by reputation
                ctx.strokeStyle = avgTrust > 0.7 ? '#fbbf24' : (avgTrust < 0.3 ? '#666' : '#888');
                ctx.lineWidth = avgTrust > 0.7 ? 2 : 1;
                ctx.stroke();
            }

            drawHistory();

            // Legend
            ctx.fillStyle = '#a78bfa';
            ctx.fillRect(canvas.width - 340, canvas.height - 100, 15, 15);
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(canvas.width - 340, canvas.height - 75, 15, 15);
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Average Trust', canvas.width - 320, canvas.height - 88);
            ctx.fillText('Cooperation Rate', canvas.width - 320, canvas.height - 63);

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText('Trust Dynamics & Reputation', 50, 30);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('population').oninput = (e) => {
            nPopulation = parseInt(e.target.value);
            document.getElementById('popValue').textContent = nPopulation;
        };

        document.getElementById('trustGain').oninput = (e) => {
            trustGain = parseFloat(e.target.value);
            document.getElementById('gainValue').textContent = trustGain.toFixed(2);
        };

        document.getElementById('trustLoss').oninput = (e) => {
            trustLoss = parseFloat(e.target.value);
            document.getElementById('lossValue').textContent = trustLoss.toFixed(2);
        };

        document.getElementById('defectRate').oninput = (e) => {
            defectRate = parseFloat(e.target.value);
            document.getElementById('defectValue').textContent = defectRate.toFixed(2);
        };

        document.getElementById('gossipRadius').oninput = (e) => {
            gossipRadius = parseInt(e.target.value);
            document.getElementById('gossipValue').textContent = gossipRadius;
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Start Simulation';
        };

        document.getElementById('resetBtn').onclick = initSimulation;
        document.getElementById('betrayBtn').onclick = majorBetrayal;

        // Initialize
        initSimulation();
        draw();
    </script>
</body>
</html>
