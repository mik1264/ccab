<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opinion Dynamics | Social Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1a4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 100, 255, 0.3);
        }
        h1 { color: #a78bfa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #a78bfa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #a78bfa; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #c4b5fd; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #a78bfa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #a78bfa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Social Dynamics</a>

    <div class="controls">
        <h1>Opinion Dynamics</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Bounded confidence model</p>

        <div class="control-group">
            <label>Model:</label>
            <select id="model">
                <option value="deffuant">Deffuant (Pairwise)</option>
                <option value="hegselmann">Hegselmann-Krause</option>
                <option value="voter">Voter Model</option>
            </select>
        </div>

        <div class="control-group">
            <label>Agents: <span class="value" id="agentsValue">100</span></label>
            <input type="range" id="agents" min="20" max="300" step="10" value="100">
        </div>

        <div class="control-group">
            <label>Confidence Bound (ε): <span class="value" id="epsilonValue">0.2</span></label>
            <input type="range" id="epsilon" min="0.05" max="0.5" step="0.05" value="0.2">
        </div>

        <div class="control-group">
            <label>Convergence Rate (μ): <span class="value" id="muValue">0.5</span></label>
            <input type="range" id="mu" min="0.1" max="1" step="0.1" value="0.5">
        </div>

        <button id="runBtn">Run Simulation</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time Step</span>
                <span class="stat-value" id="timeStep">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Clusters</span>
                <span class="stat-value" id="clusters">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Opinion Variance</span>
                <span class="stat-value" id="variance">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Polarization</span>
                <span class="stat-value" id="polarization">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Bounded confidence:</strong> Agents only influence each other if their opinions are close enough (within ε).<br>
            Watch for consensus, fragmentation, or polarization.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let agents = [];
        let nAgents = 100;
        let epsilon = 0.2;
        let mu = 0.5;
        let model = 'deffuant';
        let running = false;
        let timeStep = 0;
        let history = [];

        function initAgents() {
            agents = [];
            for (let i = 0; i < nAgents; i++) {
                agents.push({
                    opinion: Math.random(),
                    x: 100 + Math.random() * (canvas.width - 500),
                    y: 100 + Math.random() * (canvas.height - 200)
                });
            }
            timeStep = 0;
            history = [agents.map(a => a.opinion)];
        }

        function updateDeffuant() {
            // Random pairwise interaction
            const i = Math.floor(Math.random() * nAgents);
            let j = Math.floor(Math.random() * nAgents);
            while (j === i) j = Math.floor(Math.random() * nAgents);

            const diff = Math.abs(agents[i].opinion - agents[j].opinion);
            if (diff < epsilon) {
                const avg = (agents[i].opinion + agents[j].opinion) / 2;
                agents[i].opinion += mu * (avg - agents[i].opinion);
                agents[j].opinion += mu * (avg - agents[j].opinion);
            }
        }

        function updateHegselmannKrause() {
            const newOpinions = [];

            for (let i = 0; i < nAgents; i++) {
                let sum = agents[i].opinion;
                let count = 1;

                for (let j = 0; j < nAgents; j++) {
                    if (i !== j && Math.abs(agents[i].opinion - agents[j].opinion) < epsilon) {
                        sum += agents[j].opinion;
                        count++;
                    }
                }

                newOpinions.push(sum / count);
            }

            for (let i = 0; i < nAgents; i++) {
                agents[i].opinion = newOpinions[i];
            }
        }

        function updateVoter() {
            // Random agent adopts random neighbor's opinion
            const i = Math.floor(Math.random() * nAgents);
            const j = Math.floor(Math.random() * nAgents);

            if (i !== j) {
                agents[i].opinion = agents[j].opinion;
            }
        }

        function update() {
            if (!running) return;

            const iterations = model === 'deffuant' ? 50 : 1;

            for (let iter = 0; iter < iterations; iter++) {
                switch (model) {
                    case 'deffuant': updateDeffuant(); break;
                    case 'hegselmann': updateHegselmannKrause(); break;
                    case 'voter': updateVoter(); break;
                }
            }

            timeStep++;

            // Record history
            if (timeStep % 5 === 0) {
                history.push(agents.map(a => a.opinion));
                if (history.length > 200) history.shift();
            }

            // Update positions based on opinions
            for (const agent of agents) {
                const targetX = 100 + agent.opinion * (canvas.width - 500);
                agent.x += (targetX - agent.x) * 0.1;
            }

            updateStats();
        }

        function countClusters() {
            const sorted = [...agents].sort((a, b) => a.opinion - b.opinion);
            let clusters = 1;
            const threshold = 0.02;

            for (let i = 1; i < sorted.length; i++) {
                if (sorted[i].opinion - sorted[i - 1].opinion > threshold) {
                    clusters++;
                }
            }

            return clusters;
        }

        function calculateVariance() {
            const mean = agents.reduce((s, a) => s + a.opinion, 0) / nAgents;
            const variance = agents.reduce((s, a) => s + (a.opinion - mean) ** 2, 0) / nAgents;
            return variance;
        }

        function calculatePolarization() {
            // Bimodality coefficient
            const opinions = agents.map(a => a.opinion);
            const n = opinions.length;
            const mean = opinions.reduce((s, x) => s + x, 0) / n;

            let m2 = 0, m3 = 0, m4 = 0;
            for (const x of opinions) {
                const d = x - mean;
                m2 += d * d;
                m3 += d * d * d;
                m4 += d * d * d * d;
            }
            m2 /= n; m3 /= n; m4 /= n;

            const skewness = m3 / Math.pow(m2, 1.5);
            const kurtosis = m4 / (m2 * m2);

            const bimodality = (skewness * skewness + 1) / kurtosis;
            return Math.min(1, bimodality).toFixed(2);
        }

        function updateStats() {
            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('clusters').textContent = countClusters();
            document.getElementById('variance').textContent = calculateVariance().toFixed(4);
            document.getElementById('polarization').textContent = calculatePolarization();
        }

        function drawHistogram() {
            const histX = 50;
            const histY = canvas.height - 180;
            const histW = canvas.width - 400;
            const histH = 150;

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(histX - 10, histY - 30, histW + 20, histH + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Opinion Distribution', histX, histY - 10);

            // Create histogram bins
            const bins = new Array(20).fill(0);
            for (const agent of agents) {
                const bin = Math.min(19, Math.floor(agent.opinion * 20));
                bins[bin]++;
            }

            const maxBin = Math.max(...bins);
            const binWidth = histW / 20;

            // Draw bars
            for (let i = 0; i < 20; i++) {
                const barH = maxBin > 0 ? (bins[i] / maxBin) * histH : 0;
                const hue = i * 18; // Color by opinion
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.fillRect(histX + i * binWidth, histY + histH - barH, binWidth - 2, barH);
            }

            // Axis labels
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.fillText('0', histX, histY + histH + 15);
            ctx.fillText('1', histX + histW - 10, histY + histH + 15);
            ctx.fillText('Opinion', histX + histW / 2 - 25, histY + histH + 15);
        }

        function drawTimeSeries() {
            if (history.length < 2) return;

            const tsX = 50;
            const tsY = 50;
            const tsW = canvas.width - 400;
            const tsH = 200;

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(tsX - 10, tsY - 20, tsW + 20, tsH + 40);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Opinion Evolution Over Time', tsX, tsY);

            // Draw opinion trajectories
            const step = Math.max(1, Math.floor(nAgents / 30));

            for (let a = 0; a < nAgents; a += step) {
                ctx.beginPath();
                const hue = agents[a].opinion * 360;
                ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.5)`;
                ctx.lineWidth = 1;

                for (let t = 0; t < history.length; t++) {
                    const x = tsX + (t / (history.length - 1)) * tsW;
                    const y = tsY + 20 + (1 - history[t][a]) * (tsH - 40);
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Axis
            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(tsX, tsY + tsH);
            ctx.lineTo(tsX + tsW, tsY + tsH);
            ctx.stroke();
        }

        function drawAgents() {
            // Background gradient by opinion
            const gradient = ctx.createLinearGradient(100, 0, canvas.width - 400, 0);
            gradient.addColorStop(0, 'rgba(255, 100, 100, 0.1)');
            gradient.addColorStop(0.5, 'rgba(100, 255, 100, 0.1)');
            gradient.addColorStop(1, 'rgba(100, 100, 255, 0.1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(100, 280, canvas.width - 500, canvas.height - 500);

            // Draw agents
            for (const agent of agents) {
                const hue = agent.opinion * 360;
                const y = 280 + Math.sin(agent.opinion * 20 + agent.x * 0.01) * 50 + (canvas.height - 500) / 2;

                ctx.beginPath();
                ctx.arc(agent.x, y, 6, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            drawTimeSeries();
            drawAgents();
            drawHistogram();

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('model').onchange = (e) => {
            model = e.target.value;
        };

        document.getElementById('agents').oninput = (e) => {
            nAgents = parseInt(e.target.value);
            document.getElementById('agentsValue').textContent = nAgents;
        };

        document.getElementById('epsilon').oninput = (e) => {
            epsilon = parseFloat(e.target.value);
            document.getElementById('epsilonValue').textContent = epsilon.toFixed(2);
        };

        document.getElementById('mu').oninput = (e) => {
            mu = parseFloat(e.target.value);
            document.getElementById('muValue').textContent = mu.toFixed(1);
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Run Simulation';
        };

        document.getElementById('resetBtn').onclick = () => {
            initAgents();
            running = false;
            document.getElementById('runBtn').textContent = 'Run Simulation';
            updateStats();
        };

        // Initialize
        initAgents();
        updateStats();
        draw();
    </script>
</body>
</html>
