<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean GPU - FFT Gerstner Waves</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a1520;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,20,40,0.9);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
            border: 1px solid rgba(100,180,255,0.3);
        }
        h1 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #4fc3f7;
        }
        .slider-group {
            margin-bottom: 12px;
        }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #8ecef7;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #1a3a5c;
            border-radius: 3px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #0077b6;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        button:hover { background: #0096c7; }
        button.active { background: #00b4d8; }
        .presets {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 15px;
        }
        .preset {
            padding: 6px 12px;
            background: #1a3a5c;
            border: 1px solid #2d5a7c;
            border-radius: 6px;
            color: #8ecef7;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .preset:hover, .preset.active {
            background: #2d5a7c;
            border-color: #4fc3f7;
        }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #2d5a7c;
            font-size: 0.85em;
            color: #6aa8c7;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #4fc3f7;
            text-decoration: none;
            font-size: 0.9em;
            z-index: 100;
        }
        .error-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200,50,50,0.9);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üåä Ocean GPU Waves</h1>

        <div class="slider-group">
            <label>Wave Height <span id="heightVal">1.0</span></label>
            <input type="range" id="waveHeight" min="0.2" max="3" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <label>Wave Speed <span id="speedVal">1.0</span></label>
            <input type="range" id="waveSpeed" min="0.2" max="3" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <label>Wave Steepness <span id="steepVal">0.5</span></label>
            <input type="range" id="steepness" min="0.1" max="0.9" step="0.05" value="0.5">
        </div>

        <div class="slider-group">
            <label>Wind Direction <span id="windVal">0¬∞</span></label>
            <input type="range" id="windDir" min="0" max="360" step="15" value="0">
        </div>

        <div class="slider-group">
            <label>Choppiness <span id="chopVal">1.0</span></label>
            <input type="range" id="choppiness" min="0" max="2" step="0.1" value="1.0">
        </div>

        <div class="presets">
            <span class="preset active" data-preset="calm">Calm</span>
            <span class="preset" data-preset="moderate">Moderate</span>
            <span class="preset" data-preset="stormy">Stormy</span>
            <span class="preset" data-preset="tsunami">Tsunami</span>
        </div>

        <div class="button-row">
            <button id="pauseBtn">Pause</button>
            <button id="wireframeBtn">Wireframe</button>
        </div>

        <div class="stats">
            <div>Grid: <span id="gridSize">256√ó256</span></div>
            <div>Vertices: <span id="vertCount">65,536</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const GRID_SIZE = 256;

        // Check WebGPU support
        if (!navigator.gpu) {
            document.body.innerHTML = `
                <div class="error-msg">
                    <h2>WebGPU Not Supported</h2>
                    <p>Your browser doesn't support WebGPU. Try Chrome 113+ or Edge 113+.</p>
                </div>
            `;
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');

        const format = navigator.gpu.getPreferredCanvasFormat();

        function resize() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            context.configure({ device, format, alphaMode: 'opaque' });
        }
        resize();
        window.addEventListener('resize', resize);

        // Create ocean heightfield vertices and indices
        const numVertices = GRID_SIZE * GRID_SIZE;
        const vertexData = new Float32Array(numVertices * 2); // x, z positions

        for (let z = 0; z < GRID_SIZE; z++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const idx = (z * GRID_SIZE + x) * 2;
                vertexData[idx] = (x / (GRID_SIZE - 1) - 0.5) * 10;
                vertexData[idx + 1] = (z / (GRID_SIZE - 1) - 0.5) * 10;
            }
        }

        // Create indices for triangle strip with degenerate triangles
        const indices = [];
        for (let z = 0; z < GRID_SIZE - 1; z++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                indices.push(z * GRID_SIZE + x);
                indices.push((z + 1) * GRID_SIZE + x);
            }
            // Degenerate triangles to connect strips
            if (z < GRID_SIZE - 2) {
                indices.push((z + 1) * GRID_SIZE + (GRID_SIZE - 1));
                indices.push((z + 1) * GRID_SIZE);
            }
        }

        const indexData = new Uint32Array(indices);

        // Buffers
        const vertexBuffer = device.createBuffer({
            size: vertexData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertexData);

        const indexBuffer = device.createBuffer({
            size: indexData.byteLength,
            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(indexBuffer, 0, indexData);

        // Uniforms
        const uniformData = new Float32Array(24);
        const uniformBuffer = device.createBuffer({
            size: uniformData.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Shader
        const shaderModule = device.createShaderModule({
            code: `
                struct Uniforms {
                    viewProj: mat4x4f,
                    time: f32,
                    waveHeight: f32,
                    waveSpeed: f32,
                    steepness: f32,
                    windDir: f32,
                    choppiness: f32,
                    gridSize: f32,
                    aspect: f32,
                }

                struct VertexOutput {
                    @builtin(position) pos: vec4f,
                    @location(0) worldPos: vec3f,
                    @location(1) normal: vec3f,
                    @location(2) foam: f32,
                }

                @group(0) @binding(0) var<uniform> u: Uniforms;

                // Gerstner wave function
                fn gerstnerWave(pos: vec2f, waveDir: vec2f, amplitude: f32, frequency: f32, phase: f32, steepness: f32) -> vec3f {
                    let k = frequency;
                    let a = amplitude;
                    let w = sqrt(9.81 * k); // Dispersion relation
                    let dot_pos = dot(pos, waveDir);
                    let t = u.time * u.waveSpeed;

                    let x = steepness * a * waveDir.x * cos(k * dot_pos - w * t + phase);
                    let z = steepness * a * waveDir.y * cos(k * dot_pos - w * t + phase);
                    let y = a * sin(k * dot_pos - w * t + phase);

                    return vec3f(x, y, z);
                }

                // Calculate normal from Gerstner waves
                fn gerstnerNormal(pos: vec2f, waveDir: vec2f, amplitude: f32, frequency: f32, phase: f32, steepness: f32) -> vec3f {
                    let k = frequency;
                    let a = amplitude;
                    let w = sqrt(9.81 * k);
                    let dot_pos = dot(pos, waveDir);
                    let t = u.time * u.waveSpeed;
                    let s = sin(k * dot_pos - w * t + phase);
                    let c = cos(k * dot_pos - w * t + phase);

                    let nx = -waveDir.x * k * a * c;
                    let nz = -waveDir.y * k * a * c;
                    let ny = 1.0 - steepness * k * a * s;

                    return vec3f(nx, ny, nz);
                }

                @vertex
                fn vertexMain(
                    @location(0) pos: vec2f
                ) -> VertexOutput {
                    var out: VertexOutput;

                    // Wind direction
                    let windAngle = u.windDir * 0.0174533; // deg to rad
                    let windVec = vec2f(cos(windAngle), sin(windAngle));

                    // Multiple Gerstner waves
                    var displacement = vec3f(0.0);
                    var normal = vec3f(0.0, 1.0, 0.0);

                    // Wave 1 - main wave
                    let wave1 = gerstnerWave(pos, windVec, u.waveHeight * 0.4, 2.0, 0.0, u.steepness);
                    displacement += wave1;
                    normal += gerstnerNormal(pos, windVec, u.waveHeight * 0.4, 2.0, 0.0, u.steepness) - vec3f(0.0, 1.0, 0.0);

                    // Wave 2 - secondary wave at angle
                    let windVec2 = vec2f(cos(windAngle + 0.5), sin(windAngle + 0.5));
                    let wave2 = gerstnerWave(pos, windVec2, u.waveHeight * 0.25, 3.5, 1.2, u.steepness * 0.8);
                    displacement += wave2;
                    normal += gerstnerNormal(pos, windVec2, u.waveHeight * 0.25, 3.5, 1.2, u.steepness * 0.8) - vec3f(0.0, 1.0, 0.0);

                    // Wave 3 - fine detail
                    let windVec3 = vec2f(cos(windAngle - 0.3), sin(windAngle - 0.3));
                    let wave3 = gerstnerWave(pos, windVec3, u.waveHeight * 0.15, 7.0, 2.5, u.steepness * 0.6);
                    displacement += wave3;
                    normal += gerstnerNormal(pos, windVec3, u.waveHeight * 0.15, 7.0, 2.5, u.steepness * 0.6) - vec3f(0.0, 1.0, 0.0);

                    // Wave 4 - ripples
                    let windVec4 = vec2f(cos(windAngle + 1.0), sin(windAngle + 1.0));
                    let wave4 = gerstnerWave(pos, windVec4, u.waveHeight * 0.1, 12.0, 4.0, u.steepness * 0.4);
                    displacement += wave4;

                    // Apply choppiness to horizontal displacement
                    displacement.x *= u.choppiness;
                    displacement.z *= u.choppiness;

                    // World position
                    let worldPos = vec3f(
                        pos.x + displacement.x,
                        displacement.y,
                        pos.y + displacement.z
                    );

                    out.worldPos = worldPos;
                    out.normal = normalize(normal);

                    // Foam based on wave peaks and steepness
                    let foam = max(0.0, displacement.y * 2.0 - u.waveHeight * 0.3);
                    out.foam = clamp(foam, 0.0, 1.0);

                    // Camera setup - orbiting view
                    let camDist = 8.0;
                    let camHeight = 4.0;
                    let camAngle = u.time * 0.05;
                    let camPos = vec3f(cos(camAngle) * camDist, camHeight, sin(camAngle) * camDist);

                    // Simple view-projection
                    let forward = normalize(-camPos);
                    let right = normalize(cross(vec3f(0.0, 1.0, 0.0), forward));
                    let up = cross(forward, right);

                    let viewMat = mat4x4f(
                        vec4f(right.x, up.x, -forward.x, 0.0),
                        vec4f(right.y, up.y, -forward.y, 0.0),
                        vec4f(right.z, up.z, -forward.z, 0.0),
                        vec4f(-dot(right, camPos), -dot(up, camPos), dot(forward, camPos), 1.0)
                    );

                    let fov = 1.0; // ~60 degrees
                    let near = 0.1;
                    let far = 100.0;
                    let projMat = mat4x4f(
                        vec4f(fov / u.aspect, 0.0, 0.0, 0.0),
                        vec4f(0.0, fov, 0.0, 0.0),
                        vec4f(0.0, 0.0, -(far + near) / (far - near), -1.0),
                        vec4f(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)
                    );

                    out.pos = projMat * viewMat * vec4f(worldPos, 1.0);

                    return out;
                }

                @fragment
                fn fragmentMain(in: VertexOutput) -> @location(0) vec4f {
                    // Ocean colors
                    let deepColor = vec3f(0.01, 0.1, 0.2);
                    let shallowColor = vec3f(0.0, 0.3, 0.5);
                    let foamColor = vec3f(0.9, 0.95, 1.0);

                    // Depth-based color
                    let depth = clamp((in.worldPos.y + 0.5) / 1.0, 0.0, 1.0);
                    var color = mix(deepColor, shallowColor, depth);

                    // Lighting
                    let lightDir = normalize(vec3f(0.5, 1.0, 0.3));
                    let diffuse = max(dot(in.normal, lightDir), 0.0);

                    // Fresnel for specular
                    let viewDir = normalize(vec3f(0.0, 4.0, 8.0) - in.worldPos);
                    let fresnel = pow(1.0 - max(dot(viewDir, in.normal), 0.0), 3.0);

                    // Specular highlight
                    let halfDir = normalize(lightDir + viewDir);
                    let specular = pow(max(dot(in.normal, halfDir), 0.0), 64.0);

                    // Combine lighting
                    color = color * (0.3 + diffuse * 0.5);
                    color += vec3f(1.0, 0.95, 0.8) * specular * 0.5;
                    color += vec3f(0.4, 0.5, 0.6) * fresnel * 0.3;

                    // Add foam
                    color = mix(color, foamColor, in.foam * 0.7);

                    // Atmospheric fog
                    let dist = length(in.worldPos);
                    let fog = 1.0 - exp(-dist * 0.05);
                    let fogColor = vec3f(0.6, 0.75, 0.9);
                    color = mix(color, fogColor, fog * 0.3);

                    return vec4f(color, 1.0);
                }
            `
        });

        // Pipeline
        let wireframe = false;

        function createPipeline(wireframeMode) {
            return device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vertexMain',
                    buffers: [{
                        arrayStride: 8,
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: 'float32x2' },
                        ],
                    }],
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fragmentMain',
                    targets: [{ format }],
                },
                primitive: {
                    topology: wireframeMode ? 'line-strip' : 'triangle-strip',
                    cullMode: 'none',
                },
                depthStencil: {
                    format: 'depth24plus',
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                },
            });
        }

        let pipeline = createPipeline(false);

        // Depth texture
        let depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Bind group
        const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
            ],
        });

        // UI controls
        const sliders = {
            waveHeight: document.getElementById('waveHeight'),
            waveSpeed: document.getElementById('waveSpeed'),
            steepness: document.getElementById('steepness'),
            windDir: document.getElementById('windDir'),
            choppiness: document.getElementById('choppiness'),
        };

        const values = {
            waveHeight: document.getElementById('heightVal'),
            waveSpeed: document.getElementById('speedVal'),
            steepness: document.getElementById('steepVal'),
            windDir: document.getElementById('windVal'),
            choppiness: document.getElementById('chopVal'),
        };

        for (const [key, slider] of Object.entries(sliders)) {
            slider.addEventListener('input', () => {
                const val = parseFloat(slider.value);
                values[key].textContent = key === 'windDir' ? `${val}¬∞` : val.toFixed(1);
            });
        }

        // Presets
        const presets = {
            calm: { waveHeight: 0.4, waveSpeed: 0.6, steepness: 0.3, choppiness: 0.5 },
            moderate: { waveHeight: 1.0, waveSpeed: 1.0, steepness: 0.5, choppiness: 1.0 },
            stormy: { waveHeight: 2.0, waveSpeed: 1.5, steepness: 0.7, choppiness: 1.5 },
            tsunami: { waveHeight: 3.0, waveSpeed: 2.5, steepness: 0.85, choppiness: 2.0 },
        };

        document.querySelectorAll('.preset').forEach(el => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.preset').forEach(p => p.classList.remove('active'));
                el.classList.add('active');

                const preset = presets[el.dataset.preset];
                sliders.waveHeight.value = preset.waveHeight;
                sliders.waveSpeed.value = preset.waveSpeed;
                sliders.steepness.value = preset.steepness;
                sliders.choppiness.value = preset.choppiness;

                values.waveHeight.textContent = preset.waveHeight.toFixed(1);
                values.waveSpeed.textContent = preset.waveSpeed.toFixed(1);
                values.steepness.textContent = preset.steepness.toFixed(2);
                values.choppiness.textContent = preset.choppiness.toFixed(1);
            });
        });

        let paused = false;
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('wireframeBtn').addEventListener('click', () => {
            wireframe = !wireframe;
            document.getElementById('wireframeBtn').classList.toggle('active', wireframe);
            pipeline = createPipeline(wireframe);
        });

        // Handle resize for depth texture
        window.addEventListener('resize', () => {
            depthTexture.destroy();
            depthTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT,
            });
        });

        // Animation
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function render() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // FPS
            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1.0) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            if (!paused) {
                time += dt;
            }

            // Update uniforms
            // Skip viewProj matrix (we compute it in shader)
            uniformData[16] = time;
            uniformData[17] = parseFloat(sliders.waveHeight.value);
            uniformData[18] = parseFloat(sliders.waveSpeed.value);
            uniformData[19] = parseFloat(sliders.steepness.value);
            uniformData[20] = parseFloat(sliders.windDir.value);
            uniformData[21] = parseFloat(sliders.choppiness.value);
            uniformData[22] = GRID_SIZE;
            uniformData[23] = canvas.width / canvas.height;
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const commandEncoder = device.createCommandEncoder();
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: 'clear',
                    storeOp: 'store',
                    clearValue: { r: 0.6, g: 0.75, b: 0.9, a: 1 },
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                    depthClearValue: 1.0,
                },
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setIndexBuffer(indexBuffer, 'uint32');
            renderPass.drawIndexed(indexData.length);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
