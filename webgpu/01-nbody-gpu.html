<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Body GPU Simulation - WebGPU - CCAB</title>
    <style>
        body { margin: 0; background: #0a0a0f; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 8px 16px; background: rgba(6, 182, 212, 0.2); color: #22d3ee; text-decoration: none; border-radius: 6px; z-index: 100; }
        .back-link:hover { background: rgba(6, 182, 212, 0.4); }
        canvas { display: block; }
        .controls { position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; z-index: 100; }
        .controls label { display: block; margin: 10px 0 5px; color: #22d3ee; font-size: 12px; }
        .controls input { width: 150px; }
        .stats { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 8px; font-size: 12px; }
        #error { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(239, 68, 68, 0.9); padding: 20px 40px; border-radius: 8px; display: none; text-align: center; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to WebGPU Gallery</a>

    <div class="controls">
        <label>Particles: <span id="countVal">50000</span></label>
        <input type="range" id="count" min="10000" max="100000" step="10000" value="50000">
        <label>Gravity: <span id="gravVal">1.0</span></label>
        <input type="range" id="gravity" min="0.1" max="5" step="0.1" value="1.0">
        <label>Damping: <span id="dampVal">0.99</span></label>
        <input type="range" id="damping" min="0.9" max="1" step="0.01" value="0.99">
        <br>
        <button onclick="resetSimulation()">Reset</button>
    </div>

    <div class="stats">
        FPS: <span id="fps">0</span> | Particles: <span id="particles">0</span>
    </div>

    <div id="error">
        WebGPU is not supported in your browser.<br>
        Please use Chrome 113+, Edge 113+, or Safari 18+.
    </div>

    <canvas id="canvas"></canvas>

    <script type="module">
        const canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let numParticles = 50000;
        let gravity = 1.0;
        let damping = 0.99;

        // Check WebGPU support
        if (!navigator.gpu) {
            document.getElementById('error').style.display = 'block';
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            document.getElementById('error').style.display = 'block';
            throw new Error('No WebGPU adapter found');
        }

        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();

        context.configure({
            device,
            format,
            alphaMode: 'premultiplied'
        });

        // Compute shader for particle simulation
        const computeShader = `
            struct Particle {
                pos: vec2f,
                vel: vec2f,
            }

            struct Uniforms {
                deltaTime: f32,
                gravity: f32,
                damping: f32,
                numParticles: u32,
                canvasWidth: f32,
                canvasHeight: f32,
            }

            @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
            @group(0) @binding(1) var<uniform> uniforms: Uniforms;

            @compute @workgroup_size(256)
            fn main(@builtin(global_invocation_id) id: vec3u) {
                let idx = id.x;
                if (idx >= uniforms.numParticles) { return; }

                var p = particles[idx];

                // Attract to center
                let center = vec2f(uniforms.canvasWidth / 2.0, uniforms.canvasHeight / 2.0);
                let toCenter = center - p.pos;
                let dist = length(toCenter);

                if (dist > 1.0) {
                    let force = normalize(toCenter) * uniforms.gravity * 50.0 / max(dist, 50.0);
                    p.vel += force * uniforms.deltaTime;
                }

                // Apply damping
                p.vel *= uniforms.damping;

                // Update position
                p.pos += p.vel * uniforms.deltaTime;

                // Boundary wrapping
                if (p.pos.x < 0.0) { p.pos.x += uniforms.canvasWidth; }
                if (p.pos.x > uniforms.canvasWidth) { p.pos.x -= uniforms.canvasWidth; }
                if (p.pos.y < 0.0) { p.pos.y += uniforms.canvasHeight; }
                if (p.pos.y > uniforms.canvasHeight) { p.pos.y -= uniforms.canvasHeight; }

                particles[idx] = p;
            }
        `;

        // Render shader
        const renderShader = `
            struct Particle {
                pos: vec2f,
                vel: vec2f,
            }

            struct VertexOutput {
                @builtin(position) position: vec4f,
                @location(0) color: vec4f,
            }

            @group(0) @binding(0) var<storage, read> particles: array<Particle>;
            @group(0) @binding(1) var<uniform> resolution: vec2f;

            @vertex
            fn vertexMain(@builtin(vertex_index) idx: u32) -> VertexOutput {
                let p = particles[idx];

                // Convert to clip space
                let x = (p.pos.x / resolution.x) * 2.0 - 1.0;
                let y = (p.pos.y / resolution.y) * -2.0 + 1.0;

                // Color based on velocity
                let speed = length(p.vel);
                let hue = speed * 0.01;

                var output: VertexOutput;
                output.position = vec4f(x, y, 0.0, 1.0);

                // HSL to RGB approximation
                let h = fract(hue) * 6.0;
                let c = 0.8;
                let x2 = c * (1.0 - abs(h % 2.0 - 1.0));
                var rgb: vec3f;
                if (h < 1.0) { rgb = vec3f(c, x2, 0.0); }
                else if (h < 2.0) { rgb = vec3f(x2, c, 0.0); }
                else if (h < 3.0) { rgb = vec3f(0.0, c, x2); }
                else if (h < 4.0) { rgb = vec3f(0.0, x2, c); }
                else if (h < 5.0) { rgb = vec3f(x2, 0.0, c); }
                else { rgb = vec3f(c, 0.0, x2); }

                output.color = vec4f(rgb + 0.2, 0.8);
                return output;
            }

            @fragment
            fn fragmentMain(@location(0) color: vec4f) -> @location(0) vec4f {
                return color;
            }
        `;

        // Create compute pipeline
        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: {
                module: device.createShaderModule({ code: computeShader }),
                entryPoint: 'main'
            }
        });

        // Create render pipeline
        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: device.createShaderModule({ code: renderShader }),
                entryPoint: 'vertexMain'
            },
            fragment: {
                module: device.createShaderModule({ code: renderShader }),
                entryPoint: 'fragmentMain',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
                        alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'add' }
                    }
                }]
            },
            primitive: { topology: 'point-list' }
        });

        let particleBuffer, uniformBuffer, computeBindGroup, renderBindGroup;

        function initParticles() {
            // Initialize particles
            const particles = new Float32Array(numParticles * 4); // pos.x, pos.y, vel.x, vel.y
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 200 + 100;
                particles[i * 4] = canvas.width / 2 + Math.cos(angle) * radius;
                particles[i * 4 + 1] = canvas.height / 2 + Math.sin(angle) * radius;
                particles[i * 4 + 2] = Math.cos(angle + Math.PI / 2) * (50 + Math.random() * 50);
                particles[i * 4 + 3] = Math.sin(angle + Math.PI / 2) * (50 + Math.random() * 50);
            }

            particleBuffer = device.createBuffer({
                size: particles.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(particleBuffer.getMappedRange()).set(particles);
            particleBuffer.unmap();

            // Uniform buffer for compute
            uniformBuffer = device.createBuffer({
                size: 32, // Aligned to 16 bytes
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Resolution uniform for render
            const resolutionBuffer = device.createBuffer({
                size: 8,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(resolutionBuffer, 0, new Float32Array([canvas.width, canvas.height]));

            // Bind groups
            computeBindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: uniformBuffer } }
                ]
            });

            renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: resolutionBuffer } }
                ]
            });

            document.getElementById('particles').textContent = numParticles.toLocaleString();
        }

        initParticles();

        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function render() {
            const now = performance.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            frameCount++;
            if (frameCount % 30 === 0) {
                fps = Math.round(1 / deltaTime);
                document.getElementById('fps').textContent = fps;
            }

            // Update uniforms
            const uniforms = new Float32Array([
                deltaTime, gravity, damping, 0, // Padding for alignment
                canvas.width, canvas.height, 0, 0
            ]);
            const uniformsU32 = new Uint32Array(uniforms.buffer);
            uniformsU32[3] = numParticles;
            device.queue.writeBuffer(uniformBuffer, 0, uniforms);

            const commandEncoder = device.createCommandEncoder();

            // Compute pass
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, computeBindGroup);
            computePass.dispatchWorkgroups(Math.ceil(numParticles / 256));
            computePass.end();

            // Render pass
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: 'clear',
                    clearValue: { r: 0.02, g: 0.02, b: 0.05, a: 1 },
                    storeOp: 'store'
                }]
            });
            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.draw(numParticles);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(render);
        }

        function resetSimulation() {
            initParticles();
        }

        // Controls
        document.getElementById('count').addEventListener('input', (e) => {
            numParticles = parseInt(e.target.value);
            document.getElementById('countVal').textContent = numParticles;
            initParticles();
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravVal').textContent = gravity.toFixed(1);
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            damping = parseFloat(e.target.value);
            document.getElementById('dampVal').textContent = damping.toFixed(2);
        });

        window.resetSimulation = resetSimulation;

        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles();
        });

        render();
    </script>
</body>
</html>
