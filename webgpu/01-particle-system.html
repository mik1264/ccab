<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Particle System</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #error {
            color: #fff;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
            background: rgba(255, 0, 0, 0.2);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="error" style="display: none;"></div>
    <script>
        const PARTICLE_COUNT = 100000;

        async function init() {
            const canvas = document.getElementById('canvas');
            const errorDiv = document.getElementById('error');

            if (!navigator.gpu) {
                errorDiv.textContent = 'WebGPU not supported. Please use Chrome Canary or Edge Canary with WebGPU enabled.';
                errorDiv.style.display = 'block';
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');

            const devicePixelRatio = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * devicePixelRatio;
            canvas.height = canvas.clientHeight * devicePixelRatio;

            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
            });

            // Compute shader to update particles
            const computeShader = `
                struct Particle {
                    position: vec2<f32>,
                    velocity: vec2<f32>,
                    color: vec4<f32>,
                }

                @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
                @group(0) @binding(1) var<uniform> params: vec4<f32>; // time, deltaTime, width, height

                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let index = global_id.x;
                    if (index >= ${PARTICLE_COUNT}u) {
                        return;
                    }

                    var particle = particles[index];
                    let time = params.x;
                    let dt = params.y;
                    let width = params.z;
                    let height = params.w;

                    // Apply gravity towards center
                    let center = vec2<f32>(width * 0.5, height * 0.5);
                    let toCenter = center - particle.position;
                    let dist = length(toCenter);
                    let gravity = normalize(toCenter) * 50.0 / max(dist, 1.0);

                    particle.velocity += gravity * dt;
                    particle.velocity *= 0.99; // Damping
                    particle.position += particle.velocity * dt;

                    // Bounce off edges
                    if (particle.position.x < 0.0 || particle.position.x > width) {
                        particle.velocity.x *= -0.8;
                        particle.position.x = clamp(particle.position.x, 0.0, width);
                    }
                    if (particle.position.y < 0.0 || particle.position.y > height) {
                        particle.velocity.y *= -0.8;
                        particle.position.y = clamp(particle.position.y, 0.0, height);
                    }

                    // Update color based on velocity
                    let speed = length(particle.velocity);
                    particle.color = vec4<f32>(
                        0.5 + 0.5 * sin(time + f32(index) * 0.01),
                        0.5 + 0.5 * cos(time + f32(index) * 0.02),
                        0.5 + 0.5 * sin(speed * 0.1),
                        1.0
                    );

                    particles[index] = particle;
                }
            `;

            // Render shader
            const renderShader = `
                struct Particle {
                    position: vec2<f32>,
                    velocity: vec2<f32>,
                    color: vec4<f32>,
                }

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) color: vec4<f32>,
                }

                @group(0) @binding(0) var<storage, read> particles: array<Particle>;
                @group(0) @binding(1) var<uniform> params: vec4<f32>;

                @vertex
                fn vs_main(@builtin(vertex_index) vertexIndex: u32, @builtin(instance_index) instanceIndex: u32) -> VertexOutput {
                    let particle = particles[instanceIndex];
                    let width = params.z;
                    let height = params.w;

                    // Create quad
                    var positions = array<vec2<f32>, 6>(
                        vec2<f32>(-2.0, -2.0),
                        vec2<f32>(2.0, -2.0),
                        vec2<f32>(-2.0, 2.0),
                        vec2<f32>(2.0, -2.0),
                        vec2<f32>(2.0, 2.0),
                        vec2<f32>(-2.0, 2.0)
                    );

                    let offset = positions[vertexIndex];
                    let pos = particle.position + offset;

                    var output: VertexOutput;
                    output.position = vec4<f32>(
                        (pos.x / width) * 2.0 - 1.0,
                        -((pos.y / height) * 2.0 - 1.0),
                        0.0, 1.0
                    );
                    output.color = particle.color;
                    return output;
                }

                @fragment
                fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
                    return input.color;
                }
            `;

            // Create particle buffer
            const particleArray = new Float32Array(PARTICLE_COUNT * 12); // 2 + 2 + 4 + 4 (padding)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                particleArray[offset + 0] = Math.random() * canvas.width;
                particleArray[offset + 1] = Math.random() * canvas.height;
                particleArray[offset + 2] = (Math.random() - 0.5) * 100;
                particleArray[offset + 3] = (Math.random() - 0.5) * 100;
                particleArray[offset + 4] = Math.random();
                particleArray[offset + 5] = Math.random();
                particleArray[offset + 6] = Math.random();
                particleArray[offset + 7] = 1.0;
            }

            const particleBuffer = device.createBuffer({
                size: particleArray.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(particleBuffer, 0, particleArray);

            const paramsBuffer = device.createBuffer({
                size: 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            // Create compute pipeline
            const computeModule = device.createShaderModule({ code: computeShader });
            const computePipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: computeModule,
                    entryPoint: 'main',
                },
            });

            const computeBindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: paramsBuffer } },
                ],
            });

            // Create render pipeline
            const renderModule = device.createShaderModule({ code: renderShader });
            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: renderModule,
                    entryPoint: 'vs_main',
                },
                fragment: {
                    module: renderModule,
                    entryPoint: 'fs_main',
                    targets: [{
                        format: presentationFormat,
                        blend: {
                            color: {
                                srcFactor: 'src-alpha',
                                dstFactor: 'one',
                                operation: 'add',
                            },
                            alpha: {
                                srcFactor: 'one',
                                dstFactor: 'one',
                                operation: 'add',
                            },
                        },
                    }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });

            const renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: paramsBuffer } },
                ],
            });

            let startTime = Date.now();
            let lastTime = startTime;

            function frame() {
                const now = Date.now();
                const time = (now - startTime) / 1000;
                const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
                lastTime = now;

                const params = new Float32Array([time, deltaTime, canvas.width, canvas.height]);
                device.queue.writeBuffer(paramsBuffer, 0, params);

                const commandEncoder = device.createCommandEncoder();

                // Compute pass
                const computePass = commandEncoder.beginComputePass();
                computePass.setPipeline(computePipeline);
                computePass.setBindGroup(0, computeBindGroup);
                computePass.dispatchWorkgroups(Math.ceil(PARTICLE_COUNT / 64));
                computePass.end();

                // Render pass
                const textureView = context.getCurrentTexture().createView();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });
                renderPass.setPipeline(renderPipeline);
                renderPass.setBindGroup(0, renderBindGroup);
                renderPass.draw(6, PARTICLE_COUNT);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                requestAnimationFrame(frame);
            }

            frame();
        }

        init();
    </script>
</body>
</html>
