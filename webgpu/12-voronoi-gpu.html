<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi GPU - Parallel Diagram Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 {
            font-size: 1.3em;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .slider-group {
            margin-bottom: 12px;
        }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #ff6b6b, #48dbfb);
            border-radius: 50%;
            cursor: pointer;
        }
        .modes {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 15px;
        }
        .mode {
            padding: 6px 12px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode:hover, .mode.active {
            background: #333;
            border-color: #48dbfb;
            color: #fff;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .checkbox-group {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            font-size: 0.85em;
            color: #aaa;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }
        .checkbox-group input {
            width: 16px;
            height: 16px;
            accent-color: #48dbfb;
        }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #48dbfb;
            text-decoration: none;
            font-size: 0.9em;
            z-index: 100;
        }
        .error-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200,50,50,0.9);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>◇ Voronoi GPU</h1>

        <div class="slider-group">
            <label>Seeds <span id="seedsVal">100</span></label>
            <input type="range" id="numSeeds" min="10" max="500" step="10" value="100">
        </div>

        <div class="slider-group">
            <label>Animation Speed <span id="speedVal">1.0</span></label>
            <input type="range" id="speed" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="modes">
            <span class="mode active" data-mode="distance">Distance</span>
            <span class="mode" data-mode="edges">Edges</span>
            <span class="mode" data-mode="cells">Cells</span>
            <span class="mode" data-mode="gradient">Gradient</span>
            <span class="mode" data-mode="manhattan">Manhattan</span>
            <span class="mode" data-mode="worley">Worley</span>
        </div>

        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="showPoints" checked>
                Show Seeds
            </label>
            <label>
                <input type="checkbox" id="animate" checked>
                Animate
            </label>
        </div>

        <div class="button-row">
            <button id="randomizeBtn">Randomize</button>
            <button id="screenshotBtn">Screenshot</button>
        </div>

        <div class="stats">
            <div>Resolution: <span id="resolution">0×0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">← Back to Gallery</a>

    <script type="module">
        const canvas = document.getElementById('canvas');

        // Check WebGPU support
        if (!navigator.gpu) {
            document.body.innerHTML = `
                <div class="error-msg">
                    <h2>WebGPU Not Supported</h2>
                    <p>Your browser doesn't support WebGPU. Try Chrome 113+ or Edge 113+.</p>
                </div>
            `;
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');

        const format = navigator.gpu.getPreferredCanvasFormat();

        function resize() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            context.configure({ device, format, alphaMode: 'opaque' });
            document.getElementById('resolution').textContent = `${canvas.width}×${canvas.height}`;
        }
        resize();
        window.addEventListener('resize', resize);

        // State
        let numSeeds = 100;
        let mode = 0; // 0=distance, 1=edges, 2=cells, 3=gradient, 4=manhattan, 5=worley
        let showPoints = true;
        let animate = true;
        let speed = 1.0;

        // Seed data: position (x, y), velocity (vx, vy), color (r, g, b, a)
        const MAX_SEEDS = 500;
        const seedData = new Float32Array(MAX_SEEDS * 8);

        function randomizeSeeds() {
            for (let i = 0; i < MAX_SEEDS; i++) {
                const idx = i * 8;
                seedData[idx] = Math.random(); // x
                seedData[idx + 1] = Math.random(); // y
                seedData[idx + 2] = (Math.random() - 0.5) * 0.5; // vx
                seedData[idx + 3] = (Math.random() - 0.5) * 0.5; // vy

                // Random vibrant color
                const hue = Math.random();
                const sat = 0.7 + Math.random() * 0.3;
                const light = 0.5 + Math.random() * 0.2;

                // HSL to RGB
                const c = (1 - Math.abs(2 * light - 1)) * sat;
                const x = c * (1 - Math.abs((hue * 6) % 2 - 1));
                const m = light - c / 2;
                let r, g, b;
                const h = hue * 6;
                if (h < 1) { r = c; g = x; b = 0; }
                else if (h < 2) { r = x; g = c; b = 0; }
                else if (h < 3) { r = 0; g = c; b = x; }
                else if (h < 4) { r = 0; g = x; b = c; }
                else if (h < 5) { r = x; g = 0; b = c; }
                else { r = c; g = 0; b = x; }

                seedData[idx + 4] = r + m;
                seedData[idx + 5] = g + m;
                seedData[idx + 6] = b + m;
                seedData[idx + 7] = 1.0;
            }
        }
        randomizeSeeds();

        // Buffers
        const seedBuffer = device.createBuffer({
            size: seedData.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(seedBuffer, 0, seedData);

        // Uniforms
        const uniformData = new Float32Array(8);
        const uniformBuffer = device.createBuffer({
            size: uniformData.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Compute shader for updating seeds
        const updateShader = device.createShaderModule({
            code: `
                struct Seed {
                    pos: vec2f,
                    vel: vec2f,
                    color: vec4f,
                }

                struct Uniforms {
                    resolution: vec2f,
                    time: f32,
                    numSeeds: f32,
                    mode: f32,
                    speed: f32,
                    showPoints: f32,
                    dt: f32,
                }

                @group(0) @binding(0) var<storage, read_write> seeds: array<Seed>;
                @group(0) @binding(1) var<uniform> u: Uniforms;

                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) id: vec3u) {
                    let idx = id.x;
                    if (idx >= u32(u.numSeeds)) { return; }

                    var seed = seeds[idx];

                    // Update position
                    seed.pos += seed.vel * u.dt * u.speed;

                    // Bounce off walls
                    if (seed.pos.x < 0.0) { seed.pos.x = 0.0; seed.vel.x *= -1.0; }
                    if (seed.pos.x > 1.0) { seed.pos.x = 1.0; seed.vel.x *= -1.0; }
                    if (seed.pos.y < 0.0) { seed.pos.y = 0.0; seed.vel.y *= -1.0; }
                    if (seed.pos.y > 1.0) { seed.pos.y = 1.0; seed.vel.y *= -1.0; }

                    seeds[idx] = seed;
                }
            `
        });

        const updatePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: {
                module: updateShader,
                entryPoint: 'main',
            },
        });

        // Render shader
        const renderShader = device.createShaderModule({
            code: `
                struct Seed {
                    pos: vec2f,
                    vel: vec2f,
                    color: vec4f,
                }

                struct Uniforms {
                    resolution: vec2f,
                    time: f32,
                    numSeeds: f32,
                    mode: f32,
                    speed: f32,
                    showPoints: f32,
                    dt: f32,
                }

                struct VertexOutput {
                    @builtin(position) pos: vec4f,
                    @location(0) uv: vec2f,
                }

                @group(0) @binding(0) var<storage, read> seeds: array<Seed>;
                @group(0) @binding(1) var<uniform> u: Uniforms;

                @vertex
                fn vertexMain(@builtin(vertex_index) idx: u32) -> VertexOutput {
                    var positions = array<vec2f, 6>(
                        vec2f(-1.0, -1.0),
                        vec2f(1.0, -1.0),
                        vec2f(-1.0, 1.0),
                        vec2f(-1.0, 1.0),
                        vec2f(1.0, -1.0),
                        vec2f(1.0, 1.0)
                    );

                    var out: VertexOutput;
                    out.pos = vec4f(positions[idx], 0.0, 1.0);
                    out.uv = positions[idx] * 0.5 + 0.5;
                    return out;
                }

                fn euclideanDist(a: vec2f, b: vec2f) -> f32 {
                    let d = a - b;
                    return sqrt(dot(d, d));
                }

                fn manhattanDist(a: vec2f, b: vec2f) -> f32 {
                    let d = abs(a - b);
                    return d.x + d.y;
                }

                @fragment
                fn fragmentMain(in: VertexOutput) -> @location(0) vec4f {
                    let aspect = u.resolution.x / u.resolution.y;
                    let uv = vec2f(in.uv.x * aspect, in.uv.y);

                    var minDist = 1e10;
                    var minDist2 = 1e10;
                    var closestIdx = 0u;
                    var closestColor = vec4f(0.0);

                    let numSeeds = u32(u.numSeeds);

                    // Find closest and second closest seeds
                    for (var i = 0u; i < numSeeds; i++) {
                        let seed = seeds[i];
                        let seedPos = vec2f(seed.pos.x * aspect, seed.pos.y);

                        var dist: f32;
                        if (u.mode == 4.0) {
                            dist = manhattanDist(uv, seedPos);
                        } else {
                            dist = euclideanDist(uv, seedPos);
                        }

                        if (dist < minDist) {
                            minDist2 = minDist;
                            minDist = dist;
                            closestIdx = i;
                            closestColor = seed.color;
                        } else if (dist < minDist2) {
                            minDist2 = dist;
                        }
                    }

                    var color: vec3f;

                    // Mode 0: Distance field
                    if (u.mode == 0.0) {
                        let d = minDist * 5.0;
                        color = closestColor.rgb * (1.0 - d * 0.5);
                        color = mix(color, vec3f(0.0), smoothstep(0.0, 0.003, minDist - minDist2 + 0.003));
                    }
                    // Mode 1: Edges only
                    else if (u.mode == 1.0) {
                        let edge = smoothstep(0.002, 0.005, minDist2 - minDist);
                        color = vec3f(1.0) * (1.0 - edge);
                    }
                    // Mode 2: Solid cells
                    else if (u.mode == 2.0) {
                        color = closestColor.rgb;
                        let edge = smoothstep(0.002, 0.004, minDist2 - minDist);
                        color = mix(vec3f(0.0), color, edge);
                    }
                    // Mode 3: Gradient cells
                    else if (u.mode == 3.0) {
                        let gradient = 1.0 - minDist * 3.0;
                        color = closestColor.rgb * gradient;
                        let edge = smoothstep(0.001, 0.003, minDist2 - minDist);
                        color = mix(vec3f(0.1), color, edge);
                    }
                    // Mode 4: Manhattan distance
                    else if (u.mode == 4.0) {
                        let d = minDist * 4.0;
                        color = closestColor.rgb * (1.0 - d * 0.3);
                        let edge = smoothstep(0.003, 0.008, minDist2 - minDist);
                        color = mix(vec3f(0.0), color, edge);
                    }
                    // Mode 5: Worley noise (F2 - F1)
                    else if (u.mode == 5.0) {
                        let worley = minDist2 - minDist;
                        let val = worley * 10.0;
                        color = vec3f(val) * closestColor.rgb;
                    }

                    // Draw seed points
                    if (u.showPoints > 0.5) {
                        let seedPos = vec2f(seeds[closestIdx].pos.x * aspect, seeds[closestIdx].pos.y);
                        let pointDist = euclideanDist(uv, seedPos);
                        if (pointDist < 0.008) {
                            color = vec3f(1.0);
                        }
                        if (pointDist < 0.005) {
                            color = vec3f(0.0);
                        }
                    }

                    return vec4f(color, 1.0);
                }
            `
        });

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: renderShader,
                entryPoint: 'vertexMain',
            },
            fragment: {
                module: renderShader,
                entryPoint: 'fragmentMain',
                targets: [{ format }],
            },
            primitive: { topology: 'triangle-list' },
        });

        // Bind groups
        const updateBindGroup = device.createBindGroup({
            layout: updatePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: seedBuffer } },
                { binding: 1, resource: { buffer: uniformBuffer } },
            ],
        });

        const renderBindGroup = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: seedBuffer } },
                { binding: 1, resource: { buffer: uniformBuffer } },
            ],
        });

        // UI
        document.getElementById('numSeeds').addEventListener('input', (e) => {
            numSeeds = parseInt(e.target.value);
            document.getElementById('seedsVal').textContent = numSeeds;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = speed.toFixed(1);
        });

        document.querySelectorAll('.mode').forEach((el, idx) => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.mode').forEach(m => m.classList.remove('active'));
                el.classList.add('active');
                mode = idx;
            });
        });

        document.getElementById('showPoints').addEventListener('change', (e) => {
            showPoints = e.target.checked;
        });

        document.getElementById('animate').addEventListener('change', (e) => {
            animate = e.target.checked;
        });

        document.getElementById('randomizeBtn').addEventListener('click', () => {
            randomizeSeeds();
            device.queue.writeBuffer(seedBuffer, 0, seedData);
        });

        document.getElementById('screenshotBtn').addEventListener('click', () => {
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `voronoi-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        // Animation
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function render() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            time += dt;

            // FPS
            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1.0) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            // Update uniforms
            uniformData[0] = canvas.width;
            uniformData[1] = canvas.height;
            uniformData[2] = time;
            uniformData[3] = numSeeds;
            uniformData[4] = mode;
            uniformData[5] = speed;
            uniformData[6] = showPoints ? 1 : 0;
            uniformData[7] = animate ? Math.min(dt, 0.05) : 0;
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const commandEncoder = device.createCommandEncoder();

            // Update seeds (compute pass)
            if (animate) {
                const computePass = commandEncoder.beginComputePass();
                computePass.setPipeline(updatePipeline);
                computePass.setBindGroup(0, updateBindGroup);
                computePass.dispatchWorkgroups(Math.ceil(numSeeds / 64));
                computePass.end();
            }

            // Render pass
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: 'clear',
                    storeOp: 'store',
                    clearValue: { r: 0.02, g: 0.02, b: 0.04, a: 1 },
                }],
            });
            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.draw(6);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
