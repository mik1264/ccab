<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Glass Refraction</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        async function init() {
            if (!navigator.gpu) { alert('WebGPU not supported'); return; }
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            const shaderCode = `
                @group(0) @binding(0) var outputTex: texture_storage_2d<rgba8unorm, write>;
                @group(0) @binding(1) var<uniform> time: f32;

                fn raySphere(ro: vec3<f32>, rd: vec3<f32>, center: vec3<f32>, radius: f32) -> vec2<f32> {
                    let oc = ro - center;
                    let b = dot(oc, rd);
                    let c = dot(oc, oc) - radius * radius;
                    let h = b * b - c;
                    if (h < 0.0) { return vec2<f32>(-1.0); }
                    let t = -b - sqrt(h);
                    return vec2<f32>(t, -b + sqrt(h));
                }

                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let coords = vec2<i32>(id.xy);
                    if (coords.x >= 800 || coords.y >= 800) { return; }

                    let uv = (vec2<f32>(coords) - 400.0) / 400.0;
                    var ro = vec3<f32>(0.0, 0.0, -5.0);
                    var rd = normalize(vec3<f32>(uv, 1.0));

                    var color = vec3<f32>(0.0);
                    let center = vec3<f32>(sin(time) * 0.5, cos(time * 0.7) * 0.5, 0.0);

                    // Glass sphere
                    let hit = raySphere(ro, rd, center, 1.0);
                    if (hit.x > 0.0) {
                        let hitPos = ro + rd * hit.x;
                        let normal = normalize(hitPos - center);

                        // Refraction
                        let eta = 1.0 / 1.5;
                        let refracted = refract(rd, normal, eta);

                        // Exit point
                        let exitHit = raySphere(hitPos + refracted * 0.01, refracted, center, 1.0);
                        if (exitHit.y > 0.0) {
                            let exitPos = hitPos + refracted * exitHit.y;
                            let exitNormal = normalize(center - exitPos);
                            let finalDir = refract(refracted, exitNormal, 1.5);

                            // Sample environment
                            color = vec3<f32>(
                                0.5 + 0.5 * sin(finalDir.x * 3.0 + time),
                                0.5 + 0.5 * sin(finalDir.y * 3.0 + time + 2.0),
                                0.5 + 0.5 * sin(finalDir.z * 3.0 + time + 4.0)
                            );
                        }

                        // Fresnel
                        let fresnel = pow(1.0 - abs(dot(rd, normal)), 3.0);
                        let reflection = reflect(rd, normal);
                        let skyColor = vec3<f32>(0.5, 0.7, 1.0) * (0.5 + 0.5 * reflection.y);
                        color = mix(color, skyColor, fresnel);
                    } else {
                        color = vec3<f32>(0.1, 0.2, 0.3);
                    }

                    textureStore(outputTex, coords, vec4<f32>(color, 1.0));
                }
            `;

            const texture = device.createTexture({ size: [800, 800], format: 'rgba8unorm', usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING });
            const timeBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const computePipeline = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: shaderCode }), entryPoint: 'main' }});
            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: device.createShaderModule({ code: `@vertex fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4<f32> { var pos = array(vec2(-1.0,-1.0), vec2(1.0,-1.0), vec2(-1.0,1.0), vec2(1.0,-1.0), vec2(1.0,1.0), vec2(-1.0,1.0)); return vec4<f32>(pos[i], 0.0, 1.0); }` }), entryPoint: 'vs' },
                fragment: { module: device.createShaderModule({ code: `@group(0) @binding(0) var tex: texture_2d<f32>; @fragment fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> { return textureLoad(tex, vec2<i32>(pos.xy), 0); }` }), entryPoint: 'fs', targets: [{ format }] }
            });

            let time = 0;
            function frame() {
                time += 0.016;
                device.queue.writeBuffer(timeBuffer, 0, new Float32Array([time]));

                const computeBG = device.createBindGroup({ layout: computePipeline.getBindGroupLayout(0), entries: [{ binding: 0, resource: texture.createView() }, { binding: 1, resource: { buffer: timeBuffer } }]});
                const renderBG = device.createBindGroup({ layout: renderPipeline.getBindGroupLayout(0), entries: [{ binding: 0, resource: texture.createView() }]});

                const encoder = device.createCommandEncoder();
                const compute = encoder.beginComputePass();
                compute.setPipeline(computePipeline); compute.setBindGroup(0, computeBG); compute.dispatchWorkgroups(100, 100); compute.end();

                const render = encoder.beginRenderPass({ colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: 'clear', storeOp: 'store' }]});
                render.setPipeline(renderPipeline); render.setBindGroup(0, renderBG); render.draw(6); render.end();

                device.queue.submit([encoder.finish()]);
                requestAnimationFrame(frame);
            }
            frame();
        }
        init();
    </script>
</body>
</html>
