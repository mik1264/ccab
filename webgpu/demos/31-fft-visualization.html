<!DOCTYPE html><html><head><meta charset="UTF-8"><title>WebGPU FFT Visualization</title><style>body{margin:0;background:linear-gradient(135deg,#1e3c72,#2a5298);display:flex;justify-content:center;align-items:center}canvas{display:block}</style></head><body><canvas id="c" width="1024" height="600"></canvas><script>async function init(){if(!navigator.gpu){alert('WebGPU not supported');return}const adapter=await navigator.gpu.requestAdapter();const device=await adapter.requestDevice();const canvas=document.getElementById('c');const context=canvas.getContext('webgpu');const format=navigator.gpu.getPreferredCanvasFormat();context.configure({device,format});const SIZE=1024;const shader=`@group(0)@binding(0)var<storage,read_write>data:array<vec2<f32>>;@group(0)@binding(1)var<uniform>params:vec4<u32>;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)id:vec3<u32>){let idx=id.x;if(idx>=${SIZE}u){return;}let stage=params.x;let k=idx;let n=${SIZE}u;let angle=-6.28318*f32(k)/f32(n);let twiddle=vec2<f32>(cos(angle),sin(angle));let even=data[k];let odd=data[k+n/2u];let t=vec2<f32>(even.x*twiddle.x-even.y*twiddle.y,even.x*twiddle.y+even.y*twiddle.x);data[k]=t+odd;data[k+n/2u]=t-odd;}`;const renderShader=`@group(0)@binding(0)var<storage,read>data:array<vec2<f32>>;@vertex fn vs(@builtin(vertex_index)vi:u32,@builtin(instance_index)ii:u32)->@builtin(position)vec4<f32>{let x=f32(ii)/${SIZE}.0*2.0-1.0;let mag=length(data[ii]);let height=mag*0.01;let y=select(-1.0,height*2.0-1.0,vi>=2u);let positions=array(vec2<f32>(x,-1.0),vec2<f32>(x+2.0/${SIZE}.0,-1.0),vec2<f32>(x,y),vec2<f32>(x+2.0/${SIZE}.0,y));return vec4<f32>(positions[vi],0.0,1.0);}@fragment fn fs(@builtin(position)pos:vec4<f32>)->@location(0)vec4<f32>{let t=pos.y/600.0;return vec4<f32>(0.3+t*0.5,0.6+t*0.3,0.9-t*0.2,1.0);}`;const dataBuffer=device.createBuffer({size:SIZE*8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const paramsBuffer=device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const computePipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:shader}),entryPoint:'main'}});const renderPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:device.createShaderModule({code:renderShader}),entryPoint:'vs'},fragment:{module:device.createShaderModule({code:renderShader}),entryPoint:'fs',targets:[{format}]},primitive:{topology:'triangle-strip'}});let time=0;function frame(){time+=0.016;const data=new Float32Array(SIZE*2);for(let i=0;i<SIZE;i++){data[i*2]=Math.sin(i*0.1+time)+Math.sin(i*0.05+time*2)+Math.sin(i*0.02+time*3);}device.queue.writeBuffer(dataBuffer,0,data);const computeBG=device.createBindGroup({layout:computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:dataBuffer}},{binding:1,resource:{buffer:paramsBuffer}}]});const renderBG=device.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:dataBuffer}}]});const encoder=device.createCommandEncoder();const render=encoder.beginRenderPass({colorAttachments:[{view:context.getCurrentTexture().createView(),loadOp:'clear',clearValue:{r:0.1,g:0.1,b:0.2,a:1},storeOp:'store'}]});render.setPipeline(renderPipeline);render.setBindGroup(0,renderBG);render.draw(4,SIZE);render.end();device.queue.submit([encoder.finish()]);requestAnimationFrame(frame);}frame();}init();</script></body></html>
