<!DOCTYPE html><html><head><meta charset="UTF-8"><title>WebGPU Hair Simulation</title><style>body{margin:0;background:#000;display:flex;justify-content:center;align-items:center}canvas{display:block}</style></head><body><canvas id="c" width="800" height="800"></canvas><script>async function init(){if(!navigator.gpu){alert('WebGPU not supported');return}const adapter=await navigator.gpu.requestAdapter();const device=await adapter.requestDevice();const canvas=document.getElementById('c');const context=canvas.getContext('webgpu');const format=navigator.gpu.getPreferredCanvasFormat();context.configure({device,format});const NUM_STRANDS=200;const POINTS_PER_STRAND=20;const TOTAL_POINTS=NUM_STRANDS*POINTS_PER_STRAND;const shader=`struct Point{pos:vec2<f32>,oldPos:vec2<f32>,}@group(0)@binding(0)var<storage,read_write>points:array<Point>;@group(0)@binding(1)var<uniform>params:vec4<f32>;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)id:vec3<u32>){let idx=id.x;if(idx>=${TOTAL_POINTS}u){return;}let strandIdx=idx/${POINTS_PER_STRAND}u;let pointIdx=idx%${POINTS_PER_STRAND}u;if(pointIdx==0u){return;}var p=points[idx];let vel=p.pos-p.oldPos;p.oldPos=p.pos;let wind=vec2<f32>(sin(params.x+f32(strandIdx)*0.1)*5.0,0.0);p.pos+=vel*0.98+vec2<f32>(0.0,1.0)*0.5+wind*0.1;if(p.pos.y>800.0){p.pos.y=800.0;p.oldPos.y=800.0;}points[idx]=p;}`;const constraintShader=`struct Point{pos:vec2<f32>,oldPos:vec2<f32>,}@group(0)@binding(0)var<storage,read_write>points:array<Point>;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)id:vec3<u32>){let idx=id.x;if(idx>=${TOTAL_POINTS}u||idx%${POINTS_PER_STRAND}u==0u){return;}let prevIdx=idx-1u;var p1=points[prevIdx];var p2=points[idx];let delta=p2.pos-p1.pos;let dist=length(delta);let restDist=15.0;let diff=(dist-restDist)/dist*0.5;if(prevIdx%${POINTS_PER_STRAND}u!=0u){p1.pos+=delta*diff;}p2.pos-=delta*diff;points[prevIdx]=p1;points[idx]=p2;}`;const renderShader=`struct Point{pos:vec2<f32>,oldPos:vec2<f32>,}@group(0)@binding(0)var<storage,read>points:array<Point>;@vertex fn vs(@builtin(vertex_index)vi:u32)->@builtin(position)vec4<f32>{let p=points[vi];return vec4<f32>((p.pos.x/400.0-1.0),-(p.pos.y/400.0-1.0),0.0,1.0);}@fragment fn fs()->@location(0)vec4<f32>{return vec4<f32>(0.8,0.6,0.4,0.8);}`;const pointData=new Float32Array(TOTAL_POINTS*4);for(let s=0;s<NUM_STRANDS;s++){const rootX=400+Math.cos(s/NUM_STRANDS*6.28)*100;const rootY=200;for(let p=0;p<POINTS_PER_STRAND;p++){const idx=(s*POINTS_PER_STRAND+p)*4;pointData[idx+0]=rootX;pointData[idx+1]=rootY+p*15;pointData[idx+2]=pointData[idx+0];pointData[idx+3]=pointData[idx+1];}}const pointBuffer=device.createBuffer({size:pointData.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});device.queue.writeBuffer(pointBuffer,0,pointData);const paramsBuffer=device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const computePipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:shader}),entryPoint:'main'}});const constraintPipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:constraintShader}),entryPoint:'main'}});const renderPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:device.createShaderModule({code:renderShader}),entryPoint:'vs'},fragment:{module:device.createShaderModule({code:renderShader}),entryPoint:'fs',targets:[{format,blend:{color:{srcFactor:'src-alpha',dstFactor:'one-minus-src-alpha'},alpha:{srcFactor:'one',dstFactor:'one'}}}]},primitive:{topology:'line-strip',stripIndexFormat:'uint32'}});let time=0;function frame(){time+=0.016;device.queue.writeBuffer(paramsBuffer,0,new Float32Array([time,0,0,0]));const computeBG=device.createBindGroup({layout:computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:pointBuffer}},{binding:1,resource:{buffer:paramsBuffer}}]});const constraintBG=device.createBindGroup({layout:constraintPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:pointBuffer}}]});const renderBG=device.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:pointBuffer}}]});const encoder=device.createCommandEncoder();const compute=encoder.beginComputePass();compute.setPipeline(computePipeline);compute.setBindGroup(0,computeBG);compute.dispatchWorkgroups(Math.ceil(TOTAL_POINTS/256));compute.end();for(let i=0;i<5;i++){const constraint=encoder.beginComputePass();constraint.setPipeline(constraintPipeline);constraint.setBindGroup(0,constraintBG);constraint.dispatchWorkgroups(Math.ceil(TOTAL_POINTS/256));constraint.end();}const render=encoder.beginRenderPass({colorAttachments:[{view:context.getCurrentTexture().createView(),loadOp:'clear',clearValue:{r:0.05,g:0.05,b:0.1,a:1},storeOp:'store'}]});render.setPipeline(renderPipeline);render.setBindGroup(0,renderBG);for(let s=0;s<NUM_STRANDS;s++){render.draw(POINTS_PER_STRAND,1,s*POINTS_PER_STRAND,0);}render.end();device.queue.submit([encoder.finish()]);requestAnimationFrame(frame);}frame();}init();</script></body></html>
