<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Cornell Box</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="600"></canvas>
    <script>
        async function init() {
            if (!navigator.gpu) { alert('WebGPU not supported'); return; }
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            const shaderCode = `
                @group(0) @binding(0) var outputTex: texture_storage_2d<rgba8unorm, write>;
                @group(0) @binding(1) var<uniform> time: f32;

                fn rayBox(ro: vec3<f32>, rd: vec3<f32>, boxMin: vec3<f32>, boxMax: vec3<f32>) -> vec2<f32> {
                    let t0 = (boxMin - ro) / rd;
                    let t1 = (boxMax - ro) / rd;
                    let tmin = min(t0, t1);
                    let tmax = max(t0, t1);
                    let tnear = max(max(tmin.x, tmin.y), tmin.z);
                    let tfar = min(min(tmax.x, tmax.y), tmax.z);
                    return vec2<f32>(tnear, tfar);
                }

                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let coords = vec2<i32>(id.xy);
                    if (coords.x >= 600 || coords.y >= 600) { return; }

                    let uv = (vec2<f32>(coords) - 300.0) / 300.0;
                    let angle = time * 0.3;
                    let ro = vec3<f32>(sin(angle) * 8.0, 0.0, cos(angle) * 8.0);
                    let lookAt = vec3<f32>(0.0, 0.0, 0.0);
                    let forward = normalize(lookAt - ro);
                    let right = normalize(cross(vec3<f32>(0.0, 1.0, 0.0), forward));
                    let up = cross(forward, right);
                    let rd = normalize(forward + uv.x * right + uv.y * up);

                    var color = vec3<f32>(0.0);

                    // Room walls
                    let hit = rayBox(ro, rd, vec3<f32>(-5.0, -5.0, -5.0), vec3<f32>(5.0, 5.0, 5.0));
                    if (hit.y > hit.x && hit.x > 0.0) {
                        let hitPos = ro + rd * hit.x;
                        let normal = normalize(step(4.9, abs(hitPos)) * sign(hitPos));

                        // Red left wall, green right wall, white others
                        if (normal.x < -0.9) { color = vec3<f32>(0.8, 0.2, 0.2); }
                        else if (normal.x > 0.9) { color = vec3<f32>(0.2, 0.8, 0.2); }
                        else { color = vec3<f32>(0.8); }

                        let lightDir = normalize(vec3<f32>(1.0, 2.0, -1.0));
                        color *= 0.3 + 0.7 * max(dot(normal, lightDir), 0.0);
                    }

                    textureStore(outputTex, coords, vec4<f32>(pow(color, vec3<f32>(1.0/2.2)), 1.0));
                }
            `;

            const texture = device.createTexture({ size: [600, 600], format: 'rgba8unorm', usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING });
            const timeBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const computePipeline = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: shaderCode }), entryPoint: 'main' }});
            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: device.createShaderModule({ code: `@vertex fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4<f32> { var pos = array(vec2(-1.0,-1.0), vec2(1.0,-1.0), vec2(-1.0,1.0), vec2(1.0,-1.0), vec2(1.0,1.0), vec2(-1.0,1.0)); return vec4<f32>(pos[i], 0.0, 1.0); }` }), entryPoint: 'vs' },
                fragment: { module: device.createShaderModule({ code: `@group(0) @binding(0) var tex: texture_2d<f32>; @fragment fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> { return textureLoad(tex, vec2<i32>(pos.xy), 0); }` }), entryPoint: 'fs', targets: [{ format }] }
            });

            let time = 0;
            function frame() {
                time += 0.016;
                device.queue.writeBuffer(timeBuffer, 0, new Float32Array([time]));

                const computeBG = device.createBindGroup({ layout: computePipeline.getBindGroupLayout(0), entries: [{ binding: 0, resource: texture.createView() }, { binding: 1, resource: { buffer: timeBuffer } }]});
                const renderBG = device.createBindGroup({ layout: renderPipeline.getBindGroupLayout(0), entries: [{ binding: 0, resource: texture.createView() }]});

                const encoder = device.createCommandEncoder();
                const compute = encoder.beginComputePass();
                compute.setPipeline(computePipeline); compute.setBindGroup(0, computeBG); compute.dispatchWorkgroups(75, 75); compute.end();

                const render = encoder.beginRenderPass({ colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: 'clear', storeOp: 'store' }]});
                render.setPipeline(renderPipeline); render.setBindGroup(0, renderBG); render.draw(6); render.end();

                device.queue.submit([encoder.finish()]);
                requestAnimationFrame(frame);
            }
            frame();
        }
        init();
    </script>
</body>
</html>
