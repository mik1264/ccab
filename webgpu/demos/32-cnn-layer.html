<!DOCTYPE html><html><head><meta charset="UTF-8"><title>WebGPU CNN Layer Visualization</title><style>body{margin:0;background:#111;display:flex;justify-content:center;align-items:center}canvas{display:block}</style></head><body><canvas id="c" width="800" height="800"></canvas><script>async function init(){if(!navigator.gpu){alert('WebGPU not supported');return}const adapter=await navigator.gpu.requestAdapter();const device=await adapter.requestDevice();const canvas=document.getElementById('c');const context=canvas.getContext('webgpu');const format=navigator.gpu.getPreferredCanvasFormat();context.configure({device,format});const SIZE=64;const shader=`@group(0)@binding(0)var<storage,read>input:array<f32>;@group(0)@binding(1)var<storage,read_write>output:array<f32>;@group(0)@binding(2)var<storage,read>weights:array<f32>;@compute @workgroup_size(8,8)fn main(@builtin(global_invocation_id)id:vec3<u32>){let x=id.x;let y=id.y;if(x>=${SIZE}u||y>=${SIZE}u){return;}var sum=0.0;for(var ky=0;ky<3;ky++){for(var kx=0;kx<3;kx++){let ix=i32(x)+kx-1;let iy=i32(y)+ky-1;if(ix>=0&&ix<${SIZE}&&iy>=0&&iy<${SIZE}){sum+=input[u32(iy)*${SIZE}u+u32(ix)]*weights[u32(ky)*3u+u32(kx)];}}}output[y*${SIZE}u+x]=max(sum,0.0);}`;const renderShader=`@group(0)@binding(0)var<storage,read>data:array<f32>;@vertex fn vs(@builtin(vertex_index)i:u32)->@builtin(position)vec4<f32>{var pos=array(vec2(-1.0,-1.0),vec2(1.0,-1.0),vec2(-1.0,1.0),vec2(1.0,-1.0),vec2(1.0,1.0),vec2(-1.0,1.0));return vec4<f32>(pos[i],0.0,1.0);}@fragment fn fs(@builtin(position)pos:vec4<f32>)->@location(0)vec4<f32>{let x=u32(pos.x/${SIZE}.0*f32(${SIZE}));let y=u32(pos.y/${SIZE}.0*f32(${SIZE}));let val=data[y*${SIZE}u+x];return vec4<f32>(val,val*0.8,val*0.6,1.0);}`;const inputData=new Float32Array(SIZE*SIZE);const weights=new Float32Array([0.0,-1.0,0.0,-1.0,5.0,-1.0,0.0,-1.0,0.0]);const inputBuffer=device.createBuffer({size:inputData.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const outputBuffer=device.createBuffer({size:inputData.byteLength,usage:GPUBufferUsage.STORAGE});const weightsBuffer=device.createBuffer({size:weights.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});device.queue.writeBuffer(weightsBuffer,0,weights);const computePipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:shader}),entryPoint:'main'}});const renderPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:device.createShaderModule({code:renderShader}),entryPoint:'vs'},fragment:{module:device.createShaderModule({code:renderShader}),entryPoint:'fs',targets:[{format}]}});let time=0;function frame(){time+=0.02;for(let y=0;y<SIZE;y++){for(let x=0;x<SIZE;x++){const dx=x-SIZE/2;const dy=y-SIZE/2;const dist=Math.sqrt(dx*dx+dy*dy);inputData[y*SIZE+x]=0.5+0.5*Math.sin(dist*0.3-time*3);}}device.queue.writeBuffer(inputBuffer,0,inputData);const computeBG=device.createBindGroup({layout:computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:inputBuffer}},{binding:1,resource:{buffer:outputBuffer}},{binding:2,resource:{buffer:weightsBuffer}}]});const renderBG=device.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:outputBuffer}}]});const encoder=device.createCommandEncoder();const compute=encoder.beginComputePass();compute.setPipeline(computePipeline);compute.setBindGroup(0,computeBG);compute.dispatchWorkgroups(8,8);compute.end();const render=encoder.beginRenderPass({colorAttachments:[{view:context.getCurrentTexture().createView(),loadOp:'clear',storeOp:'store'}]});render.setPipeline(renderPipeline);render.setBindGroup(0,renderBG);render.draw(6);render.end();device.queue.submit([encoder.finish()]);requestAnimationFrame(frame);}frame();}init();</script></body></html>
