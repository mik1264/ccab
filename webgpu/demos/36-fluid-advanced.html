<!DOCTYPE html><html><head><meta charset="UTF-8"><title>WebGPU Advanced Fluid Dynamics</title><style>body{margin:0;background:#000;display:flex;justify-content:center;align-items:center}canvas{display:block;cursor:pointer}</style></head><body><canvas id="c" width="512" height="512"></canvas><script>async function init(){if(!navigator.gpu){alert('WebGPU not supported');return}const adapter=await navigator.gpu.requestAdapter();const device=await adapter.requestDevice();const canvas=document.getElementById('c');const context=canvas.getContext('webgpu');const format=navigator.gpu.getPreferredCanvasFormat();context.configure({device,format});const SIZE=256;const shader=`@group(0)@binding(0)var vel:texture_2d<f32>;@group(0)@binding(1)var density:texture_2d<f32>;@group(0)@binding(2)var outVel:texture_storage_2d<rg32float,write>;@group(0)@binding(3)var outDensity:texture_storage_2d<r32float,write>;@group(0)@binding(4)var<uniform>params:vec4<f32>;@compute @workgroup_size(8,8)fn main(@builtin(global_invocation_id)id:vec3<u32>){let coords=vec2<i32>(id.xy);if(coords.x>=${SIZE}||coords.y>=${SIZE}){return;}let v=textureLoad(vel,coords,0).xy;let d=textureLoad(density,coords,0).r;let vx=textureLoad(vel,coords+vec2<i32>(1,0),0).x-textureLoad(vel,coords-vec2<i32>(1,0),0).x;let vy=textureLoad(vel,coords+vec2<i32>(0,1),0).y-textureLoad(vel,coords-vec2<i32>(0,1),0).y;let divergence=(vx+vy)*0.5;let vl=textureLoad(vel,coords-vec2<i32>(1,0),0).xy;let vr=textureLoad(vel,coords+vec2<i32>(1,0),0).xy;let vd=textureLoad(vel,coords-vec2<i32>(0,1),0).xy;let vu=textureLoad(vel,coords+vec2<i32>(0,1),0).xy;let newV=v-(vec2<f32>(vx,vy))*0.5;textureStore(outVel,coords,vec4<f32>(newV*0.99,0.0,0.0));let backPos=vec2<f32>(coords)-v*params.y;let backCoords=vec2<i32>(clamp(backPos,vec2<f32>(0.0),vec2<f32>(f32(${SIZE-1}))));let newD=textureLoad(density,backCoords,0).r*0.998;textureStore(outDensity,coords,vec4<f32>(newD,0.0,0.0,0.0));}`;const renderShader=`@group(0)@binding(0)var tex:texture_2d<f32>;@vertex fn vs(@builtin(vertex_index)i:u32)->@builtin(position)vec4<f32>{var pos=array(vec2(-1.0,-1.0),vec2(1.0,-1.0),vec2(-1.0,1.0),vec2(1.0,-1.0),vec2(1.0,1.0),vec2(-1.0,1.0));return vec4<f32>(pos[i],0.0,1.0);}@fragment fn fs(@builtin(position)pos:vec4<f32>)->@location(0)vec4<f32>{let coords=vec2<i32>(pos.xy*f32(${SIZE})/512.0);let d=textureLoad(tex,coords,0).r;let color=vec3<f32>(d*2.0,d*1.5,d*3.0);return vec4<f32>(color,1.0);}`;const createTexture=(format)=>device.createTexture({size:[SIZE,SIZE],format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING});const vel=[createTexture('rg32float'),createTexture('rg32float')];const density=[createTexture('r32float'),createTexture('r32float')];const paramsBuffer=device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const computePipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:shader}),entryPoint:'main'}});const renderPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:device.createShaderModule({code:renderShader}),entryPoint:'vs'},fragment:{module:device.createShaderModule({code:renderShader}),entryPoint:'fs',targets:[{format}]}});let step=0;let mouseX=SIZE/2,mouseY=SIZE/2;canvas.addEventListener('mousemove',e=>{mouseX=e.offsetX/canvas.width*SIZE;mouseY=e.offsetY/canvas.height*SIZE;});function frame(){device.queue.writeBuffer(paramsBuffer,0,new Float32Array([0,1.0,0,0]));const computeBG=device.createBindGroup({layout:computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:vel[step%2].createView()},{binding:1,resource:density[step%2].createView()},{binding:2,resource:vel[(step+1)%2].createView()},{binding:3,resource:density[(step+1)%2].createView()},{binding:4,resource:{buffer:paramsBuffer}}]});const renderBG=device.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:density[(step+1)%2].createView()}]});const encoder=device.createCommandEncoder();const compute=encoder.beginComputePass();compute.setPipeline(computePipeline);compute.setBindGroup(0,computeBG);compute.dispatchWorkgroups(32,32);compute.end();const render=encoder.beginRenderPass({colorAttachments:[{view:context.getCurrentTexture().createView(),loadOp:'clear',clearValue:{r:0,g:0,b:0,a:1},storeOp:'store'}]});render.setPipeline(renderPipeline);render.setBindGroup(0,renderBG);render.draw(6);render.end();device.queue.submit([encoder.finish()]);step++;requestAnimationFrame(frame);}frame();}init();</script></body></html>
