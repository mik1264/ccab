<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Bitonic Sort Visualization</title>
    <style>
        body { margin: 0; background: #0f0f23; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas" width="1024" height="768"></canvas>
    <script>
        const SIZE = 2048;

        async function init() {
            if (!navigator.gpu) { alert('WebGPU not supported'); return; }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            const sortShader = `
                @group(0) @binding(0) var<storage, read_write> data: array<f32>;
                @group(0) @binding(1) var<uniform> params: vec2<u32>; // stage, step

                @compute @workgroup_size(256)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let i = id.x;
                    if (i >= ${SIZE}u / 2u) { return; }

                    let stage = params.x;
                    let step = params.y;

                    let pairDistance = 1u << (step);
                    let blockWidth = 2u * pairDistance;

                    let leftId = (i / pairDistance) * blockWidth + (i % pairDistance);
                    let rightId = leftId + pairDistance;

                    let leftVal = data[leftId];
                    let rightVal = data[rightId];

                    let sameDirection = ((leftId >> stage) & 2u) == 0u;

                    if ((leftVal > rightVal) == sameDirection) {
                        data[leftId] = rightVal;
                        data[rightId] = leftVal;
                    }
                }
            `;

            const renderShader = `
                @group(0) @binding(0) var<storage, read> data: array<f32>;

                @vertex
                fn vs(@builtin(vertex_index) vi: u32, @builtin(instance_index) ii: u32) -> @builtin(position) vec4<f32> {
                    let x = f32(ii) / f32(${SIZE}) * 2.0 - 1.0;
                    let y = data[ii] * 2.0 - 1.0;
                    let positions = array(
                        vec2<f32>(x, -1.0), vec2<f32>(x + 2.0/f32(${SIZE}), -1.0),
                        vec2<f32>(x, y), vec2<f32>(x + 2.0/f32(${SIZE}), y)
                    );
                    return vec4<f32>(positions[vi], 0.0, 1.0);
                }

                @fragment
                fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
                    let hue = pos.x / 1024.0;
                    return vec4<f32>(
                        0.5 + 0.5 * sin(hue * 6.28),
                        0.5 + 0.5 * sin(hue * 6.28 + 2.09),
                        0.5 + 0.5 * sin(hue * 6.28 + 4.18),
                        1.0
                    );
                }
            `;

            const data = new Float32Array(SIZE);
            for (let i = 0; i < SIZE; i++) {
                data[i] = Math.random();
            }

            const dataBuffer = device.createBuffer({ size: SIZE * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
            device.queue.writeBuffer(dataBuffer, 0, data);

            const paramsBuffer = device.createBuffer({ size: 8, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const sortPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: { module: device.createShaderModule({ code: sortShader }), entryPoint: 'main' },
            });

            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: device.createShaderModule({ code: renderShader }), entryPoint: 'vs' },
                fragment: { module: device.createShaderModule({ code: renderShader }), entryPoint: 'fs', targets: [{ format }] },
                primitive: { topology: 'triangle-strip' },
            });

            let frameCount = 0;
            function frame() {
                if (frameCount % 60 === 0) {
                    for (let i = 0; i < SIZE; i++) {
                        data[i] = Math.random();
                    }
                    device.queue.writeBuffer(dataBuffer, 0, data);
                }

                const sortBG = device.createBindGroup({
                    layout: sortPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: dataBuffer } },
                        { binding: 1, resource: { buffer: paramsBuffer } },
                    ],
                });

                const renderBG = device.createBindGroup({
                    layout: renderPipeline.getBindGroupLayout(0),
                    entries: [{ binding: 0, resource: { buffer: dataBuffer } }],
                });

                const encoder = device.createCommandEncoder();

                // Bitonic sort
                const numStages = Math.log2(SIZE);
                for (let stage = 0; stage < numStages; stage++) {
                    for (let step = stage; step >= 0; step--) {
                        device.queue.writeBuffer(paramsBuffer, 0, new Uint32Array([stage, step]));

                        const compute = encoder.beginComputePass();
                        compute.setPipeline(sortPipeline);
                        compute.setBindGroup(0, sortBG);
                        compute.dispatchWorkgroups(Math.ceil(SIZE / 256 / 2));
                        compute.end();
                    }
                }

                const render = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        clearValue: { r: 0.06, g: 0.06, b: 0.14, a: 1 },
                        storeOp: 'store',
                    }],
                });
                render.setPipeline(renderPipeline);
                render.setBindGroup(0, renderBG);
                render.draw(4, SIZE);
                render.end();

                device.queue.submit([encoder.finish()]);

                frameCount++;
                setTimeout(() => requestAnimationFrame(frame), 50);
            }
            frame();
        }
        init();
    </script>
</body>
</html>
