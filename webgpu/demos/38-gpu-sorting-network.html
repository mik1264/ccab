<!DOCTYPE html><html><head><meta charset="UTF-8"><title>WebGPU Sorting Network</title><style>body{margin:0;background:linear-gradient(135deg,#2c3e50,#3498db);display:flex;justify-content:center;align-items:center}canvas{display:block}</style></head><body><canvas id="c" width="1024" height="768"></canvas><script>async function init(){if(!navigator.gpu){alert('WebGPU not supported');return}const adapter=await navigator.gpu.requestAdapter();const device=await adapter.requestDevice();const canvas=document.getElementById('c');const context=canvas.getContext('webgpu');const format=navigator.gpu.getPreferredCanvasFormat();context.configure({device,format});const SIZE=2048;const shader=`@group(0)@binding(0)var<storage,read_write>data:array<f32>;@group(0)@binding(1)var<uniform>params:vec4<u32>;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)id:vec3<u32>){let idx=id.x;if(idx>=${SIZE}u/2u){return;}let stage=params.x;let substage=params.y;let pairDistance=1u<<substage;let blockWidth=2u*pairDistance;let leftId=(idx/pairDistance)*blockWidth+(idx%pairDistance);let rightId=leftId+pairDistance;let direction=((leftId>>stage)&2u)==0u;var left=data[leftId];var right=data[rightId];if((left>right)==direction){data[leftId]=right;data[rightId]=left;}}`;const renderShader=`@group(0)@binding(0)var<storage,read>data:array<f32>;@vertex fn vs(@builtin(vertex_index)vi:u32,@builtin(instance_index)ii:u32)->@builtin(position)vec4<f32>{let x=f32(ii)/f32(${SIZE})*2.0-1.0;let y=data[ii]*2.0-1.0;let positions=array(vec2<f32>(x,-1.0),vec2<f32>(x+2.0/f32(${SIZE}),-1.0),vec2<f32>(x,y),vec2<f32>(x+2.0/f32(${SIZE}),y));return vec4<f32>(positions[vi],0.0,1.0);}@fragment fn fs(@builtin(position)pos:vec4<f32>)->@location(0)vec4<f32>{let t=pos.x/1024.0;return vec4<f32>(0.2+t*0.6,0.5+t*0.4,0.9-t*0.3,1.0);}`;const data=new Float32Array(SIZE);for(let i=0;i<SIZE;i++){data[i]=Math.random();}const dataBuffer=device.createBuffer({size:SIZE*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});device.queue.writeBuffer(dataBuffer,0,data);const paramsBuffer=device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const computePipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:shader}),entryPoint:'main'}});const renderPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:device.createShaderModule({code:renderShader}),entryPoint:'vs'},fragment:{module:device.createShaderModule({code:renderShader}),entryPoint:'fs',targets:[{format}]},primitive:{topology:'triangle-strip'}});let frameCount=0;function frame(){if(frameCount%120===0){for(let i=0;i<SIZE;i++){data[i]=Math.random();}device.queue.writeBuffer(dataBuffer,0,data);}const computeBG=device.createBindGroup({layout:computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:dataBuffer}},{binding:1,resource:{buffer:paramsBuffer}}]});const renderBG=device.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:dataBuffer}}]});const encoder=device.createCommandEncoder();const numStages=Math.log2(SIZE);for(let stage=0;stage<numStages;stage++){for(let substage=stage;substage>=0;substage--){device.queue.writeBuffer(paramsBuffer,0,new Uint32Array([stage,substage,0,0]));const compute=encoder.beginComputePass();compute.setPipeline(computePipeline);compute.setBindGroup(0,computeBG);compute.dispatchWorkgroups(Math.ceil(SIZE/256/2));compute.end();}}const render=encoder.beginRenderPass({colorAttachments:[{view:context.getCurrentTexture().createView(),loadOp:'clear',clearValue:{r:0.1,g:0.1,b:0.15,a:1},storeOp:'store'}]});render.setPipeline(renderPipeline);render.setBindGroup(0,renderBG);render.draw(4,SIZE);render.end();device.queue.submit([encoder.finish()]);frameCount++;setTimeout(()=>requestAnimationFrame(frame),50);}frame();}init();</script></body></html>
