<!DOCTYPE html><html><head><meta charset="UTF-8"><title>WebGPU SDF Shapes</title><style>body{margin:0;background:#000;display:flex;justify-content:center;align-items:center}canvas{display:block}</style></head><body><canvas id="c" width="800" height="800"></canvas><script>async function init(){if(!navigator.gpu){alert('WebGPU not supported');return}const adapter=await navigator.gpu.requestAdapter();const device=await adapter.requestDevice();const canvas=document.getElementById('c');const context=canvas.getContext('webgpu');const format=navigator.gpu.getPreferredCanvasFormat();context.configure({device,format});const shader=`@group(0)@binding(0)var outputTex:texture_storage_2d<rgba8unorm,write>;@group(0)@binding(1)var<uniform>time:f32;fn sdSphere(p:vec3<f32>,r:f32)->f32{return length(p)-r;}fn sdBox(p:vec3<f32>,b:vec3<f32>)->f32{let q=abs(p)-b;return length(max(q,vec3<f32>(0.0)))+min(max(q.x,max(q.y,q.z)),0.0);}fn sdTorus(p:vec3<f32>,t:vec2<f32>)->f32{let q=vec2<f32>(length(p.xz)-t.x,p.y);return length(q)-t.y;}fn opUnion(d1:f32,d2:f32)->f32{return min(d1,d2);}fn opSmoothUnion(d1:f32,d2:f32,k:f32)->f32{let h=clamp(0.5+0.5*(d2-d1)/k,0.0,1.0);return mix(d2,d1,h)-k*h*(1.0-h);}fn map(p:vec3<f32>)->f32{var d=sdBox(p,vec3<f32>(2.0,0.1,2.0));let sphere1=sdSphere(p-vec3<f32>(sin(time)*1.5,0.6,0.0),0.6);let sphere2=sdSphere(p-vec3<f32>(0.0,0.6,cos(time)*1.5),0.5);let torus=sdTorus(p-vec3<f32>(0.0,0.5,0.0),vec2<f32>(1.0,0.2));d=opUnion(d,opSmoothUnion(sphere1,sphere2,0.5));d=opUnion(d,torus);return d;}fn calcNormal(p:vec3<f32>)->vec3<f32>{let e=vec2<f32>(0.001,0.0);return normalize(vec3<f32>(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));}@compute @workgroup_size(8,8)fn main(@builtin(global_invocation_id)id:vec3<u32>){let coords=vec2<i32>(id.xy);if(coords.x>=800||coords.y>=800){return;}let uv=(vec2<f32>(coords)-400.0)/400.0;let angle=time*0.3;let ro=vec3<f32>(cos(angle)*4.0,2.0,sin(angle)*4.0);let lookAt=vec3<f32>(0.0,0.5,0.0);let forward=normalize(lookAt-ro);let right=normalize(cross(vec3<f32>(0.0,1.0,0.0),forward));let up=cross(forward,right);let rd=normalize(forward+uv.x*right+uv.y*up);var t=0.0;for(var i=0;i<100;i++){let p=ro+rd*t;let d=map(p);if(d<0.001){break;}t+=d;if(t>20.0){break;}}var color=vec3<f32>(0.0);if(t<20.0){let p=ro+rd*t;let n=calcNormal(p);let lightDir=normalize(vec3<f32>(1.0,2.0,-1.0));let diff=max(dot(n,lightDir),0.0);let spec=pow(max(dot(reflect(lightDir,n),rd),0.0),32.0);color=vec3<f32>(0.3,0.6,0.9)*(0.2+0.6*diff)+vec3<f32>(1.0)*spec*0.5;}else{color=vec3<f32>(0.1,0.1,0.2);}textureStore(outputTex,coords,vec4<f32>(color,1.0));}`;const texture=device.createTexture({size:[800,800],format:'rgba8unorm',usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING});const timeBuffer=device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const computePipeline=device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code:shader}),entryPoint:'main'}});const renderPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:device.createShaderModule({code:`@vertex fn vs(@builtin(vertex_index)i:u32)->@builtin(position)vec4<f32>{var pos=array(vec2(-1.0,-1.0),vec2(1.0,-1.0),vec2(-1.0,1.0),vec2(1.0,-1.0),vec2(1.0,1.0),vec2(-1.0,1.0));return vec4<f32>(pos[i],0.0,1.0);}`}),entryPoint:'vs'},fragment:{module:device.createShaderModule({code:`@group(0)@binding(0)var tex:texture_2d<f32>;@fragment fn fs(@builtin(position)pos:vec4<f32>)->@location(0)vec4<f32>{return textureLoad(tex,vec2<i32>(pos.xy),0);}`}),entryPoint:'fs',targets:[{format}]}});let time=0;function frame(){time+=0.016;device.queue.writeBuffer(timeBuffer,0,new Float32Array([time]));const computeBG=device.createBindGroup({layout:computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:texture.createView()},{binding:1,resource:{buffer:timeBuffer}}]});const renderBG=device.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:texture.createView()}]});const encoder=device.createCommandEncoder();const compute=encoder.beginComputePass();compute.setPipeline(computePipeline);compute.setBindGroup(0,computeBG);compute.dispatchWorkgroups(100,100);compute.end();const render=encoder.beginRenderPass({colorAttachments:[{view:context.getCurrentTexture().createView(),loadOp:'clear',storeOp:'store'}]});render.setPipeline(renderPipeline);render.setBindGroup(0,renderBG);render.draw(6);render.end();device.queue.submit([encoder.finish()]);requestAnimationFrame(frame);}frame();}init();</script></body></html>
