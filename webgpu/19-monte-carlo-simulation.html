<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Monte Carlo Simulation - Pi Estimation</title>
    <style>
        body { margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; justify-content: center; align-items: center; flex-direction: column; }
        canvas { display: block; margin: 20px; border-radius: 10px; }
        #info { color: white; font-family: monospace; font-size: 24px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    </style>
</head>
<body>
    <div id="info">Estimating Pi: 0.0000</div>
    <canvas id="canvas" width="600" height="600"></canvas>
    <script>
        const SAMPLES = 100000;

        async function init() {
            if (!navigator.gpu) { alert('WebGPU not supported'); return; }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            const monteCarloShader = `
                @group(0) @binding(0) var<storage, read_write> points: array<vec4<f32>>;
                @group(0) @binding(1) var<storage, read_write> counter: atomic<u32>;
                @group(0) @binding(2) var<uniform> seed: f32;

                fn hash(p: vec2<f32>) -> vec2<f32> {
                    var p2 = fract(p * vec2<f32>(123.34, 456.21));
                    p2 += dot(p2, p2 + 45.32);
                    return fract(vec2<f32>(p2.x * p2.y, p2.x + p2.y));
                }

                @compute @workgroup_size(256)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let idx = id.x;
                    if (idx >= ${SAMPLES}u) { return; }

                    let rnd = hash(vec2<f32>(f32(idx), seed));
                    let x = rnd.x * 2.0 - 1.0;
                    let y = rnd.y * 2.0 - 1.0;

                    let dist = x * x + y * y;
                    let inside = select(0.0, 1.0, dist <= 1.0);

                    if (inside > 0.5) {
                        atomicAdd(&counter, 1u);
                    }

                    points[idx] = vec4<f32>(x, y, inside, 1.0);
                }
            `;

            const renderShader = `
                @group(0) @binding(0) var<storage, read> points: array<vec4<f32>>;

                @vertex
                fn vs(@builtin(vertex_index) vi: u32, @builtin(instance_index) ii: u32) -> @builtin(position) vec4<f32> {
                    let point = points[ii];
                    let positions = array(
                        vec2<f32>(-0.003, -0.003), vec2<f32>(0.003, -0.003),
                        vec2<f32>(-0.003, 0.003), vec2<f32>(0.003, 0.003)
                    );
                    return vec4<f32>(point.xy + positions[vi], 0.0, 1.0);
                }

                @fragment
                fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
                    return vec4<f32>(0.9, 0.9, 1.0, 0.6);
                }
            `;

            const pointsBuffer = device.createBuffer({ size: SAMPLES * 16, usage: GPUBufferUsage.STORAGE });
            const counterBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
            const readBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });
            const seedBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const monteCarloPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: { module: device.createShaderModule({ code: monteCarloShader }), entryPoint: 'main' },
            });

            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: device.createShaderModule({ code: renderShader }), entryPoint: 'vs' },
                fragment: {
                    module: device.createShaderModule({ code: renderShader }),
                    entryPoint: 'fs',
                    targets: [{ format, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha' }, alpha: { srcFactor: 'one', dstFactor: 'one' } } }],
                },
                primitive: { topology: 'triangle-strip' },
            });

            let time = 0;
            async function frame() {
                time += 0.016;

                device.queue.writeBuffer(counterBuffer, 0, new Uint32Array([0]));
                device.queue.writeBuffer(seedBuffer, 0, new Float32Array([time * 100]));

                const monteCarloBG = device.createBindGroup({
                    layout: monteCarloPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: pointsBuffer } },
                        { binding: 1, resource: { buffer: counterBuffer } },
                        { binding: 2, resource: { buffer: seedBuffer } },
                    ],
                });

                const renderBG = device.createBindGroup({
                    layout: renderPipeline.getBindGroupLayout(0),
                    entries: [{ binding: 0, resource: { buffer: pointsBuffer } }],
                });

                const encoder = device.createCommandEncoder();

                const compute = encoder.beginComputePass();
                compute.setPipeline(monteCarloPipeline);
                compute.setBindGroup(0, monteCarloBG);
                compute.dispatchWorkgroups(Math.ceil(SAMPLES / 256));
                compute.end();

                encoder.copyBufferToBuffer(counterBuffer, 0, readBuffer, 0, 4);

                const render = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1 },
                        storeOp: 'store',
                    }],
                });
                render.setPipeline(renderPipeline);
                render.setBindGroup(0, renderBG);
                render.draw(4, SAMPLES);
                render.end();

                device.queue.submit([encoder.finish()]);

                await readBuffer.mapAsync(GPUMapMode.READ);
                const count = new Uint32Array(readBuffer.getMappedRange())[0];
                readBuffer.unmap();

                const piEstimate = (count / SAMPLES) * 4;
                document.getElementById('info').textContent = `Estimating Pi: ${piEstimate.toFixed(4)} (actual: 3.1416)`;

                requestAnimationFrame(frame);
            }
            frame();
        }
        init();
    </script>
</body>
</html>
