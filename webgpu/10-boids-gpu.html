<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids GPU - 50K Flocking Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #4fc3f7;
        }
        .slider-group {
            margin-bottom: 12px;
        }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #4fc3f7;
            color: #000;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        button:hover { background: #81d4fa; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #4fc3f7;
            text-decoration: none;
            font-size: 0.9em;
            z-index: 100;
        }
        .error-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200,50,50,0.9);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üê¶ Boids GPU - 50K</h1>

        <div class="slider-group">
            <label>Separation <span id="sepVal">1.5</span></label>
            <input type="range" id="separation" min="0" max="3" step="0.1" value="1.5">
        </div>

        <div class="slider-group">
            <label>Alignment <span id="aliVal">1.0</span></label>
            <input type="range" id="alignment" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <label>Cohesion <span id="cohVal">1.0</span></label>
            <input type="range" id="cohesion" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <label>Perception Radius <span id="radVal">50</span></label>
            <input type="range" id="radius" min="20" max="100" step="5" value="50">
        </div>

        <div class="slider-group">
            <label>Max Speed <span id="speedVal">3.0</span></label>
            <input type="range" id="maxSpeed" min="1" max="6" step="0.5" value="3.0">
        </div>

        <div class="button-row">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
        </div>

        <div class="stats">
            <div>Boids: <span id="boidCount">50,000</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const NUM_BOIDS = 50000;

        // Check WebGPU support
        if (!navigator.gpu) {
            document.body.innerHTML = `
                <div class="error-msg">
                    <h2>WebGPU Not Supported</h2>
                    <p>Your browser doesn't support WebGPU. Try Chrome 113+ or Edge 113+.</p>
                </div>
            `;
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');

        const format = navigator.gpu.getPreferredCanvasFormat();

        function resize() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            context.configure({ device, format, alphaMode: 'opaque' });
        }
        resize();
        window.addEventListener('resize', resize);

        // Boid data: position (x, y), velocity (vx, vy)
        const boidsData = new Float32Array(NUM_BOIDS * 4);

        function initBoids() {
            for (let i = 0; i < NUM_BOIDS; i++) {
                const idx = i * 4;
                boidsData[idx] = Math.random() * canvas.width;
                boidsData[idx + 1] = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                boidsData[idx + 2] = Math.cos(angle) * speed;
                boidsData[idx + 3] = Math.sin(angle) * speed;
            }
        }
        initBoids();

        // Create buffers
        const boidsBuffer = device.createBuffer({
            size: boidsData.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.VERTEX,
        });
        device.queue.writeBuffer(boidsBuffer, 0, boidsData);

        const boidsBufferB = device.createBuffer({
            size: boidsData.byteLength,
            usage: GPUBufferUsage.STORAGE,
        });

        // Uniforms: width, height, separation, alignment, cohesion, radius, maxSpeed, dt
        const uniformData = new Float32Array(8);
        const uniformBuffer = device.createBuffer({
            size: uniformData.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Compute shader for boids simulation
        const computeShader = device.createShaderModule({
            code: `
                struct Boid {
                    pos: vec2f,
                    vel: vec2f,
                }

                struct Uniforms {
                    size: vec2f,
                    separation: f32,
                    alignment: f32,
                    cohesion: f32,
                    radius: f32,
                    maxSpeed: f32,
                    dt: f32,
                }

                @group(0) @binding(0) var<storage, read> boidsIn: array<Boid>;
                @group(0) @binding(1) var<storage, read_write> boidsOut: array<Boid>;
                @group(0) @binding(2) var<uniform> u: Uniforms;

                @compute @workgroup_size(256)
                fn main(@builtin(global_invocation_id) id: vec3u) {
                    let idx = id.x;
                    let numBoids = arrayLength(&boidsIn);
                    if (idx >= numBoids) { return; }

                    let me = boidsIn[idx];
                    var pos = me.pos;
                    var vel = me.vel;

                    // Flocking behavior
                    var separation = vec2f(0.0);
                    var alignment = vec2f(0.0);
                    var cohesion = vec2f(0.0);
                    var neighborCount = 0u;

                    let radiusSq = u.radius * u.radius;

                    // Sample neighbors (for performance, we sample instead of checking all)
                    let sampleStep = max(1u, numBoids / 1000u);

                    for (var i = 0u; i < numBoids; i += sampleStep) {
                        if (i == idx) { continue; }

                        let other = boidsIn[i];
                        var diff = other.pos - pos;

                        // Wrap distance for toroidal space
                        if (diff.x > u.size.x * 0.5) { diff.x -= u.size.x; }
                        if (diff.x < -u.size.x * 0.5) { diff.x += u.size.x; }
                        if (diff.y > u.size.y * 0.5) { diff.y -= u.size.y; }
                        if (diff.y < -u.size.y * 0.5) { diff.y += u.size.y; }

                        let distSq = dot(diff, diff);

                        if (distSq < radiusSq && distSq > 0.01) {
                            let dist = sqrt(distSq);

                            // Separation - steer away from close neighbors
                            separation -= diff / dist;

                            // Alignment - match velocity of neighbors
                            alignment += other.vel;

                            // Cohesion - steer toward center of neighbors
                            cohesion += diff;

                            neighborCount += 1u;
                        }
                    }

                    if (neighborCount > 0u) {
                        let n = f32(neighborCount);
                        separation = separation / n * u.separation;
                        alignment = alignment / n * u.alignment;
                        cohesion = cohesion / n * u.cohesion;

                        vel += separation + alignment * 0.1 + cohesion * 0.05;
                    }

                    // Limit speed
                    let speed = length(vel);
                    if (speed > u.maxSpeed) {
                        vel = vel / speed * u.maxSpeed;
                    }

                    // Minimum speed
                    if (speed < 0.5) {
                        vel = normalize(vel + vec2f(0.001, 0.001)) * 0.5;
                    }

                    // Update position
                    pos += vel * u.dt;

                    // Wrap around screen
                    if (pos.x < 0.0) { pos.x += u.size.x; }
                    if (pos.x >= u.size.x) { pos.x -= u.size.x; }
                    if (pos.y < 0.0) { pos.y += u.size.y; }
                    if (pos.y >= u.size.y) { pos.y -= u.size.y; }

                    boidsOut[idx] = Boid(pos, vel);
                }
            `
        });

        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: {
                module: computeShader,
                entryPoint: 'main',
            },
        });

        // Render shader
        const renderShader = device.createShaderModule({
            code: `
                struct Uniforms {
                    size: vec2f,
                    separation: f32,
                    alignment: f32,
                    cohesion: f32,
                    radius: f32,
                    maxSpeed: f32,
                    dt: f32,
                }

                struct VertexOutput {
                    @builtin(position) pos: vec4f,
                    @location(0) color: vec4f,
                }

                @group(0) @binding(0) var<uniform> u: Uniforms;

                @vertex
                fn vertexMain(
                    @location(0) position: vec2f,
                    @location(1) velocity: vec2f
                ) -> VertexOutput {
                    var out: VertexOutput;

                    // Convert to NDC
                    let ndc = (position / u.size) * 2.0 - 1.0;
                    out.pos = vec4f(ndc.x, -ndc.y, 0.0, 1.0);

                    // Color based on velocity direction
                    let speed = length(velocity);
                    let angle = atan2(velocity.y, velocity.x);
                    let hue = (angle + 3.14159) / 6.28318;

                    // HSV to RGB
                    let h = hue * 6.0;
                    let f = h - floor(h);
                    let p = 0.3;
                    let q = 1.0 - f * 0.7;
                    let t = 0.3 + f * 0.7;

                    let hi = i32(floor(h)) % 6;
                    var rgb: vec3f;
                    if (hi == 0) { rgb = vec3f(1.0, t, p); }
                    else if (hi == 1) { rgb = vec3f(q, 1.0, p); }
                    else if (hi == 2) { rgb = vec3f(p, 1.0, t); }
                    else if (hi == 3) { rgb = vec3f(p, q, 1.0); }
                    else if (hi == 4) { rgb = vec3f(t, p, 1.0); }
                    else { rgb = vec3f(1.0, p, q); }

                    let alpha = min(1.0, speed / u.maxSpeed);
                    out.color = vec4f(rgb, 0.6 + alpha * 0.4);

                    return out;
                }

                @fragment
                fn fragmentMain(@location(0) color: vec4f) -> @location(0) vec4f {
                    return color;
                }
            `
        });

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: renderShader,
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 16,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x2' },
                        { shaderLocation: 1, offset: 8, format: 'float32x2' },
                    ],
                }],
            },
            fragment: {
                module: renderShader,
                entryPoint: 'fragmentMain',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha' },
                        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha' },
                    },
                }],
            },
            primitive: { topology: 'point-list' },
        });

        // Bind groups
        const computeBindGroupA = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: boidsBuffer } },
                { binding: 1, resource: { buffer: boidsBufferB } },
                { binding: 2, resource: { buffer: uniformBuffer } },
            ],
        });

        const computeBindGroupB = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: boidsBufferB } },
                { binding: 1, resource: { buffer: boidsBuffer } },
                { binding: 2, resource: { buffer: uniformBuffer } },
            ],
        });

        const renderBindGroup = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 2, resource: { buffer: uniformBuffer } },
            ],
        });

        // Need to recreate render bind group with uniform at binding 0
        const renderBindGroupLayout = device.createBindGroupLayout({
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: { type: 'uniform' },
            }],
        });

        const renderPipelineLayout = device.createPipelineLayout({
            bindGroupLayouts: [renderBindGroupLayout],
        });

        const renderPipeline2 = device.createRenderPipeline({
            layout: renderPipelineLayout,
            vertex: {
                module: renderShader,
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 16,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x2' },
                        { shaderLocation: 1, offset: 8, format: 'float32x2' },
                    ],
                }],
            },
            fragment: {
                module: renderShader,
                entryPoint: 'fragmentMain',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha' },
                        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha' },
                    },
                }],
            },
            primitive: { topology: 'point-list' },
        });

        const renderBindGroup2 = device.createBindGroup({
            layout: renderBindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
            ],
        });

        // UI
        const sliders = {
            separation: document.getElementById('separation'),
            alignment: document.getElementById('alignment'),
            cohesion: document.getElementById('cohesion'),
            radius: document.getElementById('radius'),
            maxSpeed: document.getElementById('maxSpeed'),
        };

        const values = {
            separation: document.getElementById('sepVal'),
            alignment: document.getElementById('aliVal'),
            cohesion: document.getElementById('cohVal'),
            radius: document.getElementById('radVal'),
            maxSpeed: document.getElementById('speedVal'),
        };

        for (const [key, slider] of Object.entries(sliders)) {
            slider.addEventListener('input', () => {
                values[key].textContent = slider.value;
            });
        }

        let paused = false;
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initBoids();
            device.queue.writeBuffer(boidsBuffer, 0, boidsData);
        });

        // Animation loop
        let frame = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function render() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // FPS counter
            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1.0) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            if (!paused) {
                // Update uniforms
                uniformData[0] = canvas.width;
                uniformData[1] = canvas.height;
                uniformData[2] = parseFloat(sliders.separation.value);
                uniformData[3] = parseFloat(sliders.alignment.value);
                uniformData[4] = parseFloat(sliders.cohesion.value);
                uniformData[5] = parseFloat(sliders.radius.value);
                uniformData[6] = parseFloat(sliders.maxSpeed.value);
                uniformData[7] = Math.min(dt, 0.05); // Cap dt
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                // Compute pass
                const commandEncoder = device.createCommandEncoder();
                const computePass = commandEncoder.beginComputePass();
                computePass.setPipeline(computePipeline);
                computePass.setBindGroup(0, frame % 2 === 0 ? computeBindGroupA : computeBindGroupB);
                computePass.dispatchWorkgroups(Math.ceil(NUM_BOIDS / 256));
                computePass.end();

                // Render pass
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        storeOp: 'store',
                        clearValue: { r: 0.02, g: 0.02, b: 0.04, a: 1 },
                    }],
                });
                renderPass.setPipeline(renderPipeline2);
                renderPass.setBindGroup(0, renderBindGroup2);
                renderPass.setVertexBuffer(0, frame % 2 === 0 ? boidsBufferB : boidsBuffer);
                renderPass.draw(NUM_BOIDS);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                frame++;
            }

            requestAnimationFrame(render);
        }

        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
