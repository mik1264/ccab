<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid MPM - WebGPU - CCAB</title>
    <style>
        body { margin: 0; background: #0a0a0f; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 8px 16px; background: rgba(6, 182, 212, 0.2); color: #22d3ee; text-decoration: none; border-radius: 6px; z-index: 100; }
        .back-link:hover { background: rgba(6, 182, 212, 0.4); }
        canvas { display: block; }
        .controls { position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); padding: 15px; border-radius: 8px; z-index: 100; font-size: 12px; }
        .controls label { display: block; margin: 8px 0 3px; color: #22d3ee; }
        .controls input { width: 120px; }
        .controls button { margin-top: 10px; padding: 8px 16px; background: #22d3ee; color: #000; border: none; border-radius: 4px; cursor: pointer; }
        .stats { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); padding: 10px 15px; border-radius: 8px; font-size: 12px; }
        #error { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(239, 68, 68, 0.9); padding: 20px 40px; border-radius: 8px; display: none; text-align: center; }
        .info { font-size: 10px; color: #888; margin-top: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to WebGPU Gallery</a>

    <div class="controls">
        <label>Particles: <span id="countVal">10000</span></label>
        <input type="range" id="count" min="5000" max="30000" step="5000" value="10000">
        <label>Gravity: <span id="gravVal">0.3</span></label>
        <input type="range" id="gravity" min="0" max="1" step="0.1" value="0.3">
        <label>Viscosity: <span id="viscVal">0.1</span></label>
        <input type="range" id="viscosity" min="0" max="0.5" step="0.05" value="0.1">
        <button onclick="resetFluid()">Reset</button>
        <div class="info">Click and drag to interact</div>
    </div>

    <div class="stats">
        FPS: <span id="fps">0</span> | Particles: <span id="particles">0</span>
    </div>

    <div id="error">WebGPU not supported</div>

    <canvas id="canvas"></canvas>

    <script type="module">
        const canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let numParticles = 10000;
        let gravityStrength = 0.3;
        let viscosity = 0.1;
        let mousePos = { x: -1000, y: -1000 };
        let mouseDown = false;

        if (!navigator.gpu) {
            document.getElementById('error').style.display = 'block';
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();

        context.configure({ device, format, alphaMode: 'premultiplied' });

        // Simplified MPM-like fluid simulation
        const computeShader = `
            struct Particle {
                pos: vec2f,
                vel: vec2f,
            }

            struct Uniforms {
                deltaTime: f32,
                gravity: f32,
                viscosity: f32,
                numParticles: u32,
                canvasWidth: f32,
                canvasHeight: f32,
                mouseX: f32,
                mouseY: f32,
                mouseActive: f32,
                _pad: f32,
            }

            @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
            @group(0) @binding(1) var<uniform> uniforms: Uniforms;

            fn hash(p: vec2f) -> f32 {
                return fract(sin(dot(p, vec2f(127.1, 311.7))) * 43758.5453);
            }

            @compute @workgroup_size(256)
            fn main(@builtin(global_invocation_id) id: vec3u) {
                let idx = id.x;
                if (idx >= uniforms.numParticles) { return; }

                var p = particles[idx];

                // Gravity
                p.vel.y += uniforms.gravity * uniforms.deltaTime * 500.0;

                // Mouse interaction
                if (uniforms.mouseActive > 0.5) {
                    let mouseP = vec2f(uniforms.mouseX, uniforms.mouseY);
                    let toMouse = mouseP - p.pos;
                    let dist = length(toMouse);
                    if (dist < 150.0 && dist > 1.0) {
                        let force = normalize(toMouse) * (150.0 - dist) * 2.0;
                        p.vel += force * uniforms.deltaTime;
                    }
                }

                // Simple pressure/density - check nearby particles
                var pressure = vec2f(0.0);
                let cellSize = 20.0;
                for (var i = 0u; i < uniforms.numParticles; i++) {
                    if (i == idx) { continue; }
                    // Sample a subset for performance
                    if ((i + idx) % 8u != 0u) { continue; }

                    let other = particles[i];
                    let diff = p.pos - other.pos;
                    let dist = length(diff);

                    if (dist < cellSize && dist > 0.1) {
                        let repulsion = normalize(diff) * (cellSize - dist) * 0.5;
                        pressure += repulsion;
                    }
                }
                p.vel += pressure * uniforms.deltaTime;

                // Viscosity (damping)
                p.vel *= (1.0 - uniforms.viscosity * uniforms.deltaTime);

                // Update position
                p.pos += p.vel * uniforms.deltaTime;

                // Boundaries with bounce
                let margin = 5.0;
                let bounce = 0.3;

                if (p.pos.x < margin) {
                    p.pos.x = margin;
                    p.vel.x *= -bounce;
                }
                if (p.pos.x > uniforms.canvasWidth - margin) {
                    p.pos.x = uniforms.canvasWidth - margin;
                    p.vel.x *= -bounce;
                }
                if (p.pos.y < margin) {
                    p.pos.y = margin;
                    p.vel.y *= -bounce;
                }
                if (p.pos.y > uniforms.canvasHeight - margin) {
                    p.pos.y = uniforms.canvasHeight - margin;
                    p.vel.y *= -bounce;
                }

                particles[idx] = p;
            }
        `;

        const renderShader = `
            struct Particle {
                pos: vec2f,
                vel: vec2f,
            }

            struct VertexOutput {
                @builtin(position) position: vec4f,
                @location(0) color: vec4f,
            }

            @group(0) @binding(0) var<storage, read> particles: array<Particle>;
            @group(0) @binding(1) var<uniform> resolution: vec2f;

            @vertex
            fn vertexMain(@builtin(vertex_index) idx: u32) -> VertexOutput {
                let p = particles[idx];
                let x = (p.pos.x / resolution.x) * 2.0 - 1.0;
                let y = (p.pos.y / resolution.y) * -2.0 + 1.0;

                let speed = length(p.vel);
                let t = clamp(speed / 200.0, 0.0, 1.0);

                // Blue to cyan to white gradient
                var color: vec3f;
                if (t < 0.5) {
                    color = mix(vec3f(0.1, 0.3, 0.8), vec3f(0.1, 0.8, 0.9), t * 2.0);
                } else {
                    color = mix(vec3f(0.1, 0.8, 0.9), vec3f(1.0, 1.0, 1.0), (t - 0.5) * 2.0);
                }

                var output: VertexOutput;
                output.position = vec4f(x, y, 0.0, 1.0);
                output.color = vec4f(color, 0.8);
                return output;
            }

            @fragment
            fn fragmentMain(@location(0) color: vec4f) -> @location(0) vec4f {
                return color;
            }
        `;

        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: { module: device.createShaderModule({ code: computeShader }), entryPoint: 'main' }
        });

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: { module: device.createShaderModule({ code: renderShader }), entryPoint: 'vertexMain' },
            fragment: {
                module: device.createShaderModule({ code: renderShader }),
                entryPoint: 'fragmentMain',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                        alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'add' }
                    }
                }]
            },
            primitive: { topology: 'point-list' }
        });

        let particleBuffer, uniformBuffer, resolutionBuffer;
        let computeBindGroup, renderBindGroup;

        function initFluid() {
            const particles = new Float32Array(numParticles * 4);
            const cols = Math.ceil(Math.sqrt(numParticles));
            const spacing = 8;
            const startX = canvas.width / 2 - (cols * spacing) / 2;
            const startY = 100;

            for (let i = 0; i < numParticles; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                particles[i * 4] = startX + col * spacing + (Math.random() - 0.5) * 4;
                particles[i * 4 + 1] = startY + row * spacing + (Math.random() - 0.5) * 4;
                particles[i * 4 + 2] = (Math.random() - 0.5) * 20;
                particles[i * 4 + 3] = Math.random() * 20;
            }

            particleBuffer = device.createBuffer({
                size: particles.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(particleBuffer.getMappedRange()).set(particles);
            particleBuffer.unmap();

            uniformBuffer = device.createBuffer({
                size: 48,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            resolutionBuffer = device.createBuffer({
                size: 8,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(resolutionBuffer, 0, new Float32Array([canvas.width, canvas.height]));

            computeBindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: uniformBuffer } }
                ]
            });

            renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: resolutionBuffer } }
                ]
            });

            document.getElementById('particles').textContent = numParticles.toLocaleString();
        }

        initFluid();

        let lastTime = performance.now();
        let frameCount = 0;

        function render() {
            const now = performance.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.033);
            lastTime = now;

            frameCount++;
            if (frameCount % 30 === 0) {
                document.getElementById('fps').textContent = Math.round(1 / deltaTime);
            }

            const uniforms = new ArrayBuffer(48);
            const f32 = new Float32Array(uniforms);
            const u32 = new Uint32Array(uniforms);

            f32[0] = deltaTime;
            f32[1] = gravityStrength;
            f32[2] = viscosity;
            u32[3] = numParticles;
            f32[4] = canvas.width;
            f32[5] = canvas.height;
            f32[6] = mousePos.x;
            f32[7] = mousePos.y;
            f32[8] = mouseDown ? 1.0 : 0.0;

            device.queue.writeBuffer(uniformBuffer, 0, uniforms);

            const commandEncoder = device.createCommandEncoder();

            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, computeBindGroup);
            computePass.dispatchWorkgroups(Math.ceil(numParticles / 256));
            computePass.end();

            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: 'clear',
                    clearValue: { r: 0.02, g: 0.02, b: 0.08, a: 1 },
                    storeOp: 'store'
                }]
            });
            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.draw(numParticles);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(render);
        }

        window.resetFluid = initFluid;

        // Controls
        document.getElementById('count').addEventListener('input', (e) => {
            numParticles = parseInt(e.target.value);
            document.getElementById('countVal').textContent = numParticles;
            initFluid();
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            gravityStrength = parseFloat(e.target.value);
            document.getElementById('gravVal').textContent = gravityStrength.toFixed(1);
        });

        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscVal').textContent = viscosity.toFixed(2);
        });

        // Mouse interaction
        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mouseleave', () => mouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            mousePos.x = e.clientX;
            mousePos.y = e.clientY;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            device.queue.writeBuffer(resolutionBuffer, 0, new Float32Array([canvas.width, canvas.height]));
        });

        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
