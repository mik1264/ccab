<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Marching - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
            padding-top: var(--header-height);
        }

        .container {
            display: flex;
            height: calc(100vh - var(--header-height));
        }

        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            padding: 1.5rem;
        }

        .sidebar h2 {
            font-family: var(--font-display);
            font-size: 1.5rem;
            color: var(--text-accent);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .tab-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition-base);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
            text-align: left;
        }

        .tab-btn:hover {
            background: var(--bg-primary);
            border-color: var(--text-accent);
            color: var(--text-primary);
        }

        .tab-btn.active {
            background: var(--text-accent);
            color: var(--bg-primary);
            border-color: var(--text-accent);
            font-weight: 500;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .control-group {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .control-group h3 {
            font-family: var(--font-heading);
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }

        .control {
            margin-bottom: 0.75rem;
        }

        .control label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            font-family: var(--font-mono);
        }

        .control input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--text-accent);
            cursor: pointer;
            border-radius: 50%;
        }

        .control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--text-accent);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .control input[type="number"],
        .control input[type="color"] {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
        }

        .control select {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .preset-btn {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition-base);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
        }

        .preset-btn:hover {
            background: var(--physics);
            color: var(--text-primary);
            border-color: var(--physics);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .info-overlay {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(10, 14, 26, 0.9);
            padding: 1rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-secondary);
            pointer-events: none;
        }

        .info-overlay div {
            margin-bottom: 0.25rem;
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .checkbox-control input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-control label {
            margin-bottom: 0 !important;
            cursor: pointer;
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <a href="../index.html" class="organic-back-link">‚Üê Back to Gallery</a>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-separator">/</span>
                <span class="nav-page">Ray Marching</span>
            </a>
        </div>
    </nav>

    <div class="container">
        <div class="sidebar">
            <h2>Ray Marching</h2>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="primitives">Primitives</button>
                <button class="tab-btn" data-tab="boolean">Boolean Operations</button>
                <button class="tab-btn" data-tab="fractals">Fractals</button>
                <button class="tab-btn" data-tab="camera">Camera</button>
                <button class="tab-btn" data-tab="lighting">Lighting</button>
                <button class="tab-btn" data-tab="presets">Presets</button>
            </div>

            <!-- Primitives Tab -->
            <div class="tab-content active" data-tab="primitives">
                <div class="control-group">
                    <h3>Shape Type</h3>
                    <div class="control">
                        <label>Shape</label>
                        <select id="shapeType">
                            <option value="0">Sphere</option>
                            <option value="1">Box</option>
                            <option value="2">Torus</option>
                            <option value="3">Cylinder</option>
                            <option value="4">Octahedron</option>
                            <option value="5">Cone</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Shape Parameters</h3>
                    <div class="control">
                        <label>Size: <span id="sizeValue">1.0</span></label>
                        <input type="range" id="shapeSize" min="0.1" max="3.0" step="0.1" value="1.0">
                    </div>
                    <div class="control">
                        <label>Param 1: <span id="param1Value">0.5</span></label>
                        <input type="range" id="shapeParam1" min="0.1" max="2.0" step="0.1" value="0.5">
                    </div>
                    <div class="control">
                        <label>Param 2: <span id="param2Value">0.5</span></label>
                        <input type="range" id="shapeParam2" min="0.1" max="2.0" step="0.1" value="0.5">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Rotation</h3>
                    <div class="control">
                        <label>Auto Rotate</label>
                        <div class="checkbox-control">
                            <input type="checkbox" id="autoRotate" checked>
                            <label for="autoRotate">Enable</label>
                        </div>
                    </div>
                    <div class="control">
                        <label>Speed: <span id="rotSpeedValue">0.5</span></label>
                        <input type="range" id="rotSpeed" min="0.0" max="2.0" step="0.1" value="0.5">
                    </div>
                </div>
            </div>

            <!-- Boolean Operations Tab -->
            <div class="tab-content" data-tab="boolean">
                <div class="control-group">
                    <h3>Operations</h3>
                    <div class="control">
                        <label>Operation</label>
                        <select id="boolOp">
                            <option value="0">Union</option>
                            <option value="1">Subtraction</option>
                            <option value="2">Intersection</option>
                            <option value="3">Smooth Union</option>
                            <option value="4">Smooth Subtraction</option>
                        </select>
                    </div>
                    <div class="control">
                        <label>Smoothness: <span id="smoothValue">0.3</span></label>
                        <input type="range" id="smoothness" min="0.0" max="1.0" step="0.05" value="0.3">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Second Shape</h3>
                    <div class="control">
                        <label>Type</label>
                        <select id="shape2Type">
                            <option value="0">Sphere</option>
                            <option value="1">Box</option>
                            <option value="2">Torus</option>
                            <option value="3">Cylinder</option>
                        </select>
                    </div>
                    <div class="control">
                        <label>Offset X: <span id="offset2XValue">1.0</span></label>
                        <input type="range" id="offset2X" min="-3.0" max="3.0" step="0.1" value="1.0">
                    </div>
                    <div class="control">
                        <label>Offset Y: <span id="offset2YValue">0.0</span></label>
                        <input type="range" id="offset2Y" min="-3.0" max="3.0" step="0.1" value="0.0">
                    </div>
                    <div class="control">
                        <label>Offset Z: <span id="offset2ZValue">0.0</span></label>
                        <input type="range" id="offset2Z" min="-3.0" max="3.0" step="0.1" value="0.0">
                    </div>
                </div>
            </div>

            <!-- Fractals Tab -->
            <div class="tab-content" data-tab="fractals">
                <div class="control-group">
                    <h3>Fractal Type</h3>
                    <div class="control">
                        <label>Type</label>
                        <select id="fractalType">
                            <option value="0">None</option>
                            <option value="1">Mandelbulb</option>
                            <option value="2">Menger Sponge</option>
                            <option value="3">Sierpinski</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Mandelbulb</h3>
                    <div class="control">
                        <label>Power: <span id="mandelbulbPowerValue">8.0</span></label>
                        <input type="range" id="mandelbulbPower" min="2.0" max="16.0" step="0.5" value="8.0">
                    </div>
                    <div class="control">
                        <label>Iterations: <span id="mandelbulbIterValue">8</span></label>
                        <input type="range" id="mandelbulbIter" min="4" max="16" step="1" value="8">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Menger Sponge</h3>
                    <div class="control">
                        <label>Iterations: <span id="mengerIterValue">4</span></label>
                        <input type="range" id="mengerIter" min="2" max="6" step="1" value="4">
                    </div>
                    <div class="control">
                        <label>Scale: <span id="mengerScaleValue">3.0</span></label>
                        <input type="range" id="mengerScale" min="2.0" max="5.0" step="0.5" value="3.0">
                    </div>
                </div>
            </div>

            <!-- Camera Tab -->
            <div class="tab-content" data-tab="camera">
                <div class="control-group">
                    <h3>Position</h3>
                    <div class="control">
                        <label>Distance: <span id="camDistValue">5.0</span></label>
                        <input type="range" id="camDist" min="2.0" max="20.0" step="0.5" value="5.0">
                    </div>
                    <div class="control">
                        <label>Height: <span id="camHeightValue">0.0</span></label>
                        <input type="range" id="camHeight" min="-5.0" max="5.0" step="0.1" value="0.0">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Projection</h3>
                    <div class="control">
                        <label>FOV: <span id="fovValue">45</span></label>
                        <input type="range" id="fov" min="20" max="90" step="5" value="45">
                    </div>
                </div>
            </div>

            <!-- Lighting Tab -->
            <div class="tab-content" data-tab="lighting">
                <div class="control-group">
                    <h3>Light Source</h3>
                    <div class="control">
                        <label>Light X: <span id="lightXValue">5.0</span></label>
                        <input type="range" id="lightX" min="-10.0" max="10.0" step="0.5" value="5.0">
                    </div>
                    <div class="control">
                        <label>Light Y: <span id="lightYValue">5.0</span></label>
                        <input type="range" id="lightY" min="-10.0" max="10.0" step="0.5" value="5.0">
                    </div>
                    <div class="control">
                        <label>Light Z: <span id="lightZValue">5.0</span></label>
                        <input type="range" id="lightZ" min="-10.0" max="10.0" step="0.5" value="5.0">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Material</h3>
                    <div class="control">
                        <label>Ambient: <span id="ambientValue">0.1</span></label>
                        <input type="range" id="ambient" min="0.0" max="0.5" step="0.05" value="0.1">
                    </div>
                    <div class="control">
                        <label>Diffuse: <span id="diffuseValue">0.7</span></label>
                        <input type="range" id="diffuse" min="0.0" max="1.0" step="0.05" value="0.7">
                    </div>
                    <div class="control">
                        <label>Specular: <span id="specularValue">0.5</span></label>
                        <input type="range" id="specular" min="0.0" max="1.0" step="0.05" value="0.5">
                    </div>
                    <div class="control">
                        <label>Shininess: <span id="shininessValue">32</span></label>
                        <input type="range" id="shininess" min="8" max="128" step="8" value="32">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Effects</h3>
                    <div class="checkbox-control">
                        <input type="checkbox" id="softShadows" checked>
                        <label for="softShadows">Soft Shadows</label>
                    </div>
                    <div class="checkbox-control">
                        <input type="checkbox" id="ambientOcclusion" checked>
                        <label for="ambientOcclusion">Ambient Occlusion</label>
                    </div>
                    <div class="control">
                        <label>AO Strength: <span id="aoStrengthValue">0.3</span></label>
                        <input type="range" id="aoStrength" min="0.0" max="1.0" step="0.05" value="0.3">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Colors</h3>
                    <div class="control">
                        <label>Object Color</label>
                        <input type="color" id="objColor" value="#667eea">
                    </div>
                    <div class="control">
                        <label>Background Color</label>
                        <input type="color" id="bgColor" value="#0a0e1a">
                    </div>
                </div>
            </div>

            <!-- Presets Tab -->
            <div class="tab-content" data-tab="presets">
                <div class="control-group">
                    <h3>Scene Presets</h3>
                    <button class="preset-btn" data-preset="default">Default Sphere</button>
                    <button class="preset-btn" data-preset="torus">Spinning Torus</button>
                    <button class="preset-btn" data-preset="boolean">Boolean Demo</button>
                    <button class="preset-btn" data-preset="mandelbulb">Mandelbulb</button>
                    <button class="preset-btn" data-preset="menger">Menger Sponge</button>
                    <button class="preset-btn" data-preset="cylinders">Nested Cylinders</button>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="info-overlay">
                <div>Drag to rotate camera</div>
                <div>FPS: <span id="fps">60</span></div>
                <div>Ray Steps: <span id="steps">0</span></div>
            </div>
        </div>
    </div>

    <script>
        // WebGL Setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported');
            throw new Error('WebGL 2 not supported');
        }

        // Vertex shader (simple fullscreen quad)
        const vertexShaderSource = `#version 300 es
            in vec4 position;
            void main() {
                gl_Position = position;
            }
        `;

        // Fragment shader with ray marching
        const fragmentShaderSource = `#version 300 es
            precision highp float;

            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec3 u_cameraPos;
            uniform float u_cameraAngle;
            uniform float u_cameraHeight;
            uniform float u_fov;

            // Shape parameters
            uniform int u_shapeType;
            uniform float u_shapeSize;
            uniform float u_shapeParam1;
            uniform float u_shapeParam2;
            uniform bool u_autoRotate;
            uniform float u_rotSpeed;

            // Boolean operations
            uniform int u_boolOp;
            uniform float u_smoothness;
            uniform int u_shape2Type;
            uniform vec3 u_offset2;

            // Fractals
            uniform int u_fractalType;
            uniform float u_mandelbulbPower;
            uniform int u_mandelbulbIter;
            uniform int u_mengerIter;
            uniform float u_mengerScale;

            // Lighting
            uniform vec3 u_lightPos;
            uniform float u_ambient;
            uniform float u_diffuse;
            uniform float u_specular;
            uniform float u_shininess;
            uniform bool u_softShadows;
            uniform bool u_ambientOcclusion;
            uniform float u_aoStrength;
            uniform vec3 u_objColor;
            uniform vec3 u_bgColor;

            out vec4 fragColor;

            const int MAX_STEPS = 128;
            const float MAX_DIST = 100.0;
            const float EPSILON = 0.001;

            // Rotation matrix
            mat3 rotateY(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
            }

            // SDF primitives
            float sdSphere(vec3 p, float r) {
                return length(p) - r;
            }

            float sdBox(vec3 p, vec3 b) {
                vec3 d = abs(p) - b;
                return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
            }

            float sdTorus(vec3 p, vec2 t) {
                vec2 q = vec2(length(p.xz) - t.x, p.y);
                return length(q) - t.y;
            }

            float sdCylinder(vec3 p, vec3 c) {
                return length(p.xz - c.xy) - c.z;
            }

            float sdOctahedron(vec3 p, float s) {
                p = abs(p);
                float m = p.x + p.y + p.z - s;
                vec3 q;
                if (3.0 * p.x < m) q = p.xyz;
                else if (3.0 * p.y < m) q = p.yzx;
                else if (3.0 * p.z < m) q = p.zxy;
                else return m * 0.57735027;

                float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);
                return length(vec3(q.x, q.y - s + k, q.z - k));
            }

            float sdCone(vec3 p, vec2 c, float h) {
                vec2 q = h * vec2(c.x / c.y, -1.0);
                vec2 w = vec2(length(p.xz), p.y);
                vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
                vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
                float k = sign(q.y);
                float d = min(dot(a, a), dot(b, b));
                float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
                return sqrt(d) * sign(s);
            }

            // Mandelbulb
            float sdMandelbulb(vec3 pos) {
                vec3 z = pos;
                float dr = 1.0;
                float r = 0.0;
                float power = u_mandelbulbPower;

                for (int i = 0; i < 16; i++) {
                    if (i >= u_mandelbulbIter) break;
                    r = length(z);
                    if (r > 2.0) break;

                    // Convert to polar coordinates
                    float theta = acos(z.z / r);
                    float phi = atan(z.y, z.x);
                    dr = pow(r, power - 1.0) * power * dr + 1.0;

                    // Scale and rotate
                    float zr = pow(r, power);
                    theta = theta * power;
                    phi = phi * power;

                    // Convert back to cartesian
                    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                    z += pos;
                }
                return 0.5 * log(r) * r / dr;
            }

            // Menger sponge
            float sdMengerSponge(vec3 p) {
                float d = sdBox(p, vec3(1.0));
                float s = 1.0;

                for (int i = 0; i < 6; i++) {
                    if (i >= u_mengerIter) break;
                    vec3 a = mod(p * s, 2.0) - 1.0;
                    s *= u_mengerScale;
                    vec3 r = abs(1.0 - 3.0 * abs(a));

                    float da = max(r.x, r.y);
                    float db = max(r.y, r.z);
                    float dc = max(r.z, r.x);
                    float c = (min(da, min(db, dc)) - 1.0) / s;

                    d = max(d, c);
                }
                return d;
            }

            // Boolean operations
            float opUnion(float d1, float d2) {
                return min(d1, d2);
            }

            float opSubtraction(float d1, float d2) {
                return max(d1, -d2);
            }

            float opIntersection(float d1, float d2) {
                return max(d1, d2);
            }

            float opSmoothUnion(float d1, float d2, float k) {
                float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
                return mix(d2, d1, h) - k * h * (1.0 - h);
            }

            float opSmoothSubtraction(float d1, float d2, float k) {
                float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
                return mix(d2, -d1, h) + k * h * (1.0 - h);
            }

            // Get primitive distance
            float getPrimitive(vec3 p, int shapeType, float size, float p1, float p2) {
                if (shapeType == 0) return sdSphere(p, size);
                else if (shapeType == 1) return sdBox(p, vec3(size));
                else if (shapeType == 2) return sdTorus(p, vec2(size, p1));
                else if (shapeType == 3) return sdCylinder(p, vec3(0.0, 0.0, size));
                else if (shapeType == 4) return sdOctahedron(p, size);
                else if (shapeType == 5) return sdCone(p, vec2(p1, p2), size);
                return sdSphere(p, size);
            }

            // Scene SDF
            float sceneSDF(vec3 p) {
                // Apply rotation if enabled
                vec3 p1 = p;
                if (u_autoRotate) {
                    p1 = rotateY(u_time * u_rotSpeed) * p1;
                }

                // Fractal rendering
                if (u_fractalType == 1) {
                    return sdMandelbulb(p1);
                } else if (u_fractalType == 2) {
                    return sdMengerSponge(p1);
                }

                // Primary shape
                float d1 = getPrimitive(p1, u_shapeType, u_shapeSize, u_shapeParam1, u_shapeParam2);

                // Boolean operations
                if (u_boolOp > 0) {
                    vec3 p2 = p - u_offset2;
                    if (u_autoRotate) {
                        p2 = rotateY(u_time * u_rotSpeed) * p2;
                    }
                    float d2 = getPrimitive(p2, u_shape2Type, u_shapeSize * 0.8, u_shapeParam1, u_shapeParam2);

                    if (u_boolOp == 1) d1 = opSubtraction(d1, d2);
                    else if (u_boolOp == 2) d1 = opIntersection(d1, d2);
                    else if (u_boolOp == 3) d1 = opSmoothUnion(d1, d2, u_smoothness);
                    else if (u_boolOp == 4) d1 = opSmoothSubtraction(d1, d2, u_smoothness);
                    else d1 = opUnion(d1, d2);
                }

                return d1;
            }

            // Calculate normal
            vec3 calcNormal(vec3 p) {
                vec2 e = vec2(EPSILON, 0.0);
                return normalize(vec3(
                    sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
                    sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
                    sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
                ));
            }

            // Soft shadows
            float calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
                float res = 1.0;
                float t = mint;
                for (int i = 0; i < 32; i++) {
                    float h = sceneSDF(ro + rd * t);
                    res = min(res, k * h / t);
                    t += clamp(h, 0.02, 0.2);
                    if (res < 0.005 || t > maxt) break;
                }
                return clamp(res, 0.0, 1.0);
            }

            // Ambient occlusion
            float calcAO(vec3 pos, vec3 nor) {
                float occ = 0.0;
                float sca = 1.0;
                for (int i = 0; i < 5; i++) {
                    float h = 0.01 + 0.12 * float(i) / 4.0;
                    float d = sceneSDF(pos + h * nor);
                    occ += (h - d) * sca;
                    sca *= 0.95;
                }
                return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
            }

            // Ray marching
            int rayMarch(vec3 ro, vec3 rd, out float dist) {
                dist = 0.0;
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 p = ro + rd * dist;
                    float d = sceneSDF(p);
                    dist += d;
                    if (d < EPSILON) return i;
                    if (dist > MAX_DIST) break;
                }
                return MAX_STEPS;
            }

            void main() {
                // Normalized pixel coordinates
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

                // Camera setup
                float angle = u_cameraAngle;
                vec3 ro = vec3(sin(angle) * u_cameraPos.x, u_cameraHeight, cos(angle) * u_cameraPos.x);
                vec3 target = vec3(0.0, 0.0, 0.0);
                vec3 forward = normalize(target - ro);
                vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
                vec3 up = cross(forward, right);

                // Ray direction
                float fovRad = radians(u_fov);
                vec3 rd = normalize(forward + uv.x * right * tan(fovRad / 2.0) + uv.y * up * tan(fovRad / 2.0));

                // Ray march
                float dist;
                int steps = rayMarch(ro, rd, dist);

                vec3 color = u_bgColor;

                if (dist < MAX_DIST) {
                    vec3 p = ro + rd * dist;
                    vec3 normal = calcNormal(p);
                    vec3 lightDir = normalize(u_lightPos - p);
                    vec3 viewDir = normalize(ro - p);
                    vec3 halfDir = normalize(lightDir + viewDir);

                    // Lighting components
                    float ambient = u_ambient;
                    float diffuse = max(dot(normal, lightDir), 0.0) * u_diffuse;
                    float specular = pow(max(dot(normal, halfDir), 0.0), u_shininess) * u_specular;

                    // Shadows
                    float shadow = 1.0;
                    if (u_softShadows) {
                        shadow = calcSoftShadow(p + normal * 0.01, lightDir, 0.02, 10.0, 8.0);
                    }

                    // Ambient occlusion
                    float ao = 1.0;
                    if (u_ambientOcclusion) {
                        ao = calcAO(p, normal);
                        ao = mix(1.0, ao, u_aoStrength);
                    }

                    // Combine lighting
                    float lighting = ambient + (diffuse + specular) * shadow;
                    color = u_objColor * lighting * ao;

                    // Distance fog
                    float fog = 1.0 - exp(-dist * 0.05);
                    color = mix(color, u_bgColor, fog);
                }

                // Gamma correction
                color = pow(color, vec3(1.0 / 2.2));

                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Create fullscreen quad
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const uniforms = {
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            time: gl.getUniformLocation(program, 'u_time'),
            cameraPos: gl.getUniformLocation(program, 'u_cameraPos'),
            cameraAngle: gl.getUniformLocation(program, 'u_cameraAngle'),
            cameraHeight: gl.getUniformLocation(program, 'u_cameraHeight'),
            fov: gl.getUniformLocation(program, 'u_fov'),
            shapeType: gl.getUniformLocation(program, 'u_shapeType'),
            shapeSize: gl.getUniformLocation(program, 'u_shapeSize'),
            shapeParam1: gl.getUniformLocation(program, 'u_shapeParam1'),
            shapeParam2: gl.getUniformLocation(program, 'u_shapeParam2'),
            autoRotate: gl.getUniformLocation(program, 'u_autoRotate'),
            rotSpeed: gl.getUniformLocation(program, 'u_rotSpeed'),
            boolOp: gl.getUniformLocation(program, 'u_boolOp'),
            smoothness: gl.getUniformLocation(program, 'u_smoothness'),
            shape2Type: gl.getUniformLocation(program, 'u_shape2Type'),
            offset2: gl.getUniformLocation(program, 'u_offset2'),
            fractalType: gl.getUniformLocation(program, 'u_fractalType'),
            mandelbulbPower: gl.getUniformLocation(program, 'u_mandelbulbPower'),
            mandelbulbIter: gl.getUniformLocation(program, 'u_mandelbulbIter'),
            mengerIter: gl.getUniformLocation(program, 'u_mengerIter'),
            mengerScale: gl.getUniformLocation(program, 'u_mengerScale'),
            lightPos: gl.getUniformLocation(program, 'u_lightPos'),
            ambient: gl.getUniformLocation(program, 'u_ambient'),
            diffuse: gl.getUniformLocation(program, 'u_diffuse'),
            specular: gl.getUniformLocation(program, 'u_specular'),
            shininess: gl.getUniformLocation(program, 'u_shininess'),
            softShadows: gl.getUniformLocation(program, 'u_softShadows'),
            ambientOcclusion: gl.getUniformLocation(program, 'u_ambientOcclusion'),
            aoStrength: gl.getUniformLocation(program, 'u_aoStrength'),
            objColor: gl.getUniformLocation(program, 'u_objColor'),
            bgColor: gl.getUniformLocation(program, 'u_bgColor')
        };

        // State
        const state = {
            time: 0,
            cameraAngle: 0,
            cameraDistance: 5.0,
            cameraHeight: 0.0,
            fov: 45,
            shapeType: 0,
            shapeSize: 1.0,
            shapeParam1: 0.5,
            shapeParam2: 0.5,
            autoRotate: true,
            rotSpeed: 0.5,
            boolOp: 0,
            smoothness: 0.3,
            shape2Type: 0,
            offset2: [1.0, 0.0, 0.0],
            fractalType: 0,
            mandelbulbPower: 8.0,
            mandelbulbIter: 8,
            mengerIter: 4,
            mengerScale: 3.0,
            lightPos: [5.0, 5.0, 5.0],
            ambient: 0.1,
            diffuse: 0.7,
            specular: 0.5,
            shininess: 32,
            softShadows: true,
            ambientOcclusion: true,
            aoStrength: 0.3,
            objColor: [0.4, 0.494, 0.918],
            bgColor: [0.039, 0.055, 0.102]
        };

        // Mouse interaction
        let isDragging = false;
        let lastMouseX = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                state.cameraAngle += deltaX * 0.01;
                lastMouseX = e.clientX;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;

                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                btn.classList.add('active');
                document.querySelector(`.tab-content[data-tab="${tabName}"]`).classList.add('active');
            });
        });

        // UI Controls
        function setupControl(id, property, isInt = false, updateValue = true) {
            const element = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Value');

            element.addEventListener('input', () => {
                const value = isInt ? parseInt(element.value) : parseFloat(element.value);

                if (property.includes('.')) {
                    const parts = property.split('.');
                    const index = parseInt(parts[1]);
                    state[parts[0]][index] = value;
                } else {
                    state[property] = value;
                }

                if (updateValue && valueSpan) {
                    valueSpan.textContent = isInt ? value : value.toFixed(2);
                }
            });
        }

        function setupCheckbox(id, property) {
            const element = document.getElementById(id);
            element.addEventListener('change', () => {
                state[property] = element.checked;
            });
        }

        function setupSelect(id, property) {
            const element = document.getElementById(id);
            element.addEventListener('change', () => {
                state[property] = parseInt(element.value);
            });
        }

        function setupColor(id, property) {
            const element = document.getElementById(id);
            element.addEventListener('input', () => {
                const hex = element.value;
                const r = parseInt(hex.substr(1, 2), 16) / 255;
                const g = parseInt(hex.substr(3, 2), 16) / 255;
                const b = parseInt(hex.substr(5, 2), 16) / 255;
                state[property] = [r, g, b];
            });
        }

        // Setup all controls
        setupControl('shapeSize', 'shapeSize');
        setupControl('shapeParam1', 'shapeParam1');
        setupControl('shapeParam2', 'shapeParam2');
        setupControl('rotSpeed', 'rotSpeed');
        setupControl('smoothness', 'smoothness');
        setupControl('offset2X', 'offset2.0');
        setupControl('offset2Y', 'offset2.1');
        setupControl('offset2Z', 'offset2.2');
        setupControl('mandelbulbPower', 'mandelbulbPower');
        setupControl('mandelbulbIter', 'mandelbulbIter', true);
        setupControl('mengerIter', 'mengerIter', true);
        setupControl('mengerScale', 'mengerScale');
        setupControl('camDist', 'cameraDistance');
        setupControl('camHeight', 'cameraHeight');
        setupControl('fov', 'fov', true);
        setupControl('lightX', 'lightPos.0');
        setupControl('lightY', 'lightPos.1');
        setupControl('lightZ', 'lightPos.2');
        setupControl('ambient', 'ambient');
        setupControl('diffuse', 'diffuse');
        setupControl('specular', 'specular');
        setupControl('shininess', 'shininess', true);
        setupControl('aoStrength', 'aoStrength');

        setupCheckbox('autoRotate', 'autoRotate');
        setupCheckbox('softShadows', 'softShadows');
        setupCheckbox('ambientOcclusion', 'ambientOcclusion');

        setupSelect('shapeType', 'shapeType');
        setupSelect('boolOp', 'boolOp');
        setupSelect('shape2Type', 'shape2Type');
        setupSelect('fractalType', 'fractalType');

        setupColor('objColor', 'objColor');
        setupColor('bgColor', 'bgColor');

        // Presets
        const presets = {
            default: () => {
                state.shapeType = 0;
                state.shapeSize = 1.0;
                state.autoRotate = true;
                state.boolOp = 0;
                state.fractalType = 0;
                document.getElementById('shapeType').value = '0';
                document.getElementById('shapeSize').value = '1.0';
                document.getElementById('sizeValue').textContent = '1.0';
            },
            torus: () => {
                state.shapeType = 2;
                state.shapeSize = 1.5;
                state.shapeParam1 = 0.5;
                state.autoRotate = true;
                state.boolOp = 0;
                state.fractalType = 0;
                document.getElementById('shapeType').value = '2';
                document.getElementById('shapeSize').value = '1.5';
                document.getElementById('sizeValue').textContent = '1.5';
            },
            boolean: () => {
                state.shapeType = 0;
                state.boolOp = 3;
                state.shape2Type = 1;
                state.smoothness = 0.5;
                state.fractalType = 0;
                document.getElementById('shapeType').value = '0';
                document.getElementById('boolOp').value = '3';
                document.getElementById('shape2Type').value = '1';
                document.getElementById('smoothness').value = '0.5';
                document.getElementById('smoothValue').textContent = '0.50';
            },
            mandelbulb: () => {
                state.fractalType = 1;
                state.mandelbulbPower = 8.0;
                state.mandelbulbIter = 8;
                state.cameraDistance = 3.0;
                state.boolOp = 0;
                document.getElementById('fractalType').value = '1';
                document.getElementById('camDist').value = '3.0';
                document.getElementById('camDistValue').textContent = '3.0';
            },
            menger: () => {
                state.fractalType = 2;
                state.mengerIter = 4;
                state.mengerScale = 3.0;
                state.cameraDistance = 4.0;
                state.boolOp = 0;
                document.getElementById('fractalType').value = '2';
                document.getElementById('camDist').value = '4.0';
                document.getElementById('camDistValue').textContent = '4.0';
            },
            cylinders: () => {
                state.shapeType = 3;
                state.boolOp = 1;
                state.shape2Type = 3;
                state.shapeSize = 1.5;
                state.offset2 = [0, 0.5, 0];
                state.fractalType = 0;
                document.getElementById('shapeType').value = '3';
                document.getElementById('boolOp').value = '1';
                document.getElementById('shape2Type').value = '3';
            }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (presets[preset]) {
                    presets[preset]();
                }
            });
        });

        // Resize canvas
        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        // FPS counter
        let fps = 60;
        let lastTime = performance.now();
        let frameCount = 0;

        // Render loop
        function render(time) {
            state.time = time * 0.001;

            // Update FPS
            frameCount++;
            if (time - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (time - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = time;
            }

            // Set uniforms
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, state.time);
            gl.uniform3f(uniforms.cameraPos, state.cameraDistance, 0, state.cameraDistance);
            gl.uniform1f(uniforms.cameraAngle, state.cameraAngle);
            gl.uniform1f(uniforms.cameraHeight, state.cameraHeight);
            gl.uniform1f(uniforms.fov, state.fov);
            gl.uniform1i(uniforms.shapeType, state.shapeType);
            gl.uniform1f(uniforms.shapeSize, state.shapeSize);
            gl.uniform1f(uniforms.shapeParam1, state.shapeParam1);
            gl.uniform1f(uniforms.shapeParam2, state.shapeParam2);
            gl.uniform1i(uniforms.autoRotate, state.autoRotate);
            gl.uniform1f(uniforms.rotSpeed, state.rotSpeed);
            gl.uniform1i(uniforms.boolOp, state.boolOp);
            gl.uniform1f(uniforms.smoothness, state.smoothness);
            gl.uniform1i(uniforms.shape2Type, state.shape2Type);
            gl.uniform3fv(uniforms.offset2, state.offset2);
            gl.uniform1i(uniforms.fractalType, state.fractalType);
            gl.uniform1f(uniforms.mandelbulbPower, state.mandelbulbPower);
            gl.uniform1i(uniforms.mandelbulbIter, state.mandelbulbIter);
            gl.uniform1i(uniforms.mengerIter, state.mengerIter);
            gl.uniform1f(uniforms.mengerScale, state.mengerScale);
            gl.uniform3fv(uniforms.lightPos, state.lightPos);
            gl.uniform1f(uniforms.ambient, state.ambient);
            gl.uniform1f(uniforms.diffuse, state.diffuse);
            gl.uniform1f(uniforms.specular, state.specular);
            gl.uniform1f(uniforms.shininess, state.shininess);
            gl.uniform1i(uniforms.softShadows, state.softShadows);
            gl.uniform1i(uniforms.ambientOcclusion, state.ambientOcclusion);
            gl.uniform1f(uniforms.aoStrength, state.aoStrength);
            gl.uniform3fv(uniforms.objColor, state.objColor);
            gl.uniform3fv(uniforms.bgColor, state.bgColor);

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
