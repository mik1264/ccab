<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truchet Tile Patterns - WebGL Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px;
            font-family: monospace; font-size: 14px; pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">Animated Truchet Tiling<br>Generative patterns from simple rules</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vs = `#version 300 es
            in vec2 a_position;
            void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
        `;

        const fs = `#version 300 es
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;
            out vec4 fragColor;

            float hash21(vec2 p) {
                p = fract(p * vec2(234.34, 435.345));
                p += dot(p, p + 34.23);
                return fract(p.x * p.y);
            }

            vec2 hash22(vec2 p) {
                float n = sin(dot(p, vec2(41, 289)));
                return fract(vec2(8.0 * n, n) * 46839.32);
            }

            float truchetPattern(vec2 uv) {
                vec2 gv = fract(uv) - 0.5;
                vec2 id = floor(uv);

                float n = hash21(id);
                float angle = n * 6.28318;

                // Rotate UV based on random angle
                float s = sin(angle);
                float c = cos(angle);
                mat2 rot = mat2(c, -s, s, c);
                gv = rot * gv;

                // Create arc pattern
                float d = abs(abs(gv.x + gv.y) - 0.5);
                d = smoothstep(0.01, 0.0, d - 0.2);

                return d;
            }

            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.0, 0.33, 0.67);
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);

                // Zoom and animate
                float zoom = 10.0;
                uv *= zoom;
                uv += vec2(u_time * 0.3, u_time * 0.2);

                // Multi-layer truchet
                float d1 = truchetPattern(uv);
                float d2 = truchetPattern(uv * 1.5 + vec2(u_time * 0.1));
                float d3 = truchetPattern(uv * 2.0 - vec2(u_time * 0.15));

                float pattern = d1 + d2 * 0.5 + d3 * 0.25;

                // Color based on pattern
                vec3 col = palette(pattern + u_time * 0.1);

                // Add grid lines
                vec2 gv = fract(uv) - 0.5;
                float grid = max(abs(gv.x), abs(gv.y));
                grid = smoothstep(0.49, 0.5, grid);
                col = mix(col, vec3(0.0), grid * 0.3);

                fragColor = vec4(col, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        const timeLoc = gl.getUniformLocation(program, 'u_time');

        function render(time) {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        render(0);
    </script>
</body>
</html>
