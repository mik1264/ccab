<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation - WebGL Shader</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        Drag mouse to create fluid motion<br>
        GPU-accelerated Navier-Stokes simulation
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vertexSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const advectShader = `#version 300 es
            precision highp float;
            uniform sampler2D u_velocity;
            uniform sampler2D u_source;
            uniform vec2 u_texelSize;
            uniform float u_dt;
            uniform float u_dissipation;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                vec2 coord = v_texCoord - u_dt * texture(u_velocity, v_texCoord).xy * u_texelSize;
                fragColor = u_dissipation * texture(u_source, coord);
            }
        `;

        const divergenceShader = `#version 300 es
            precision highp float;
            uniform sampler2D u_velocity;
            uniform vec2 u_texelSize;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                float L = texture(u_velocity, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
                float R = texture(u_velocity, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
                float T = texture(u_velocity, v_texCoord + vec2(0.0, u_texelSize.y)).y;
                float B = texture(u_velocity, v_texCoord - vec2(0.0, u_texelSize.y)).y;

                float div = 0.5 * (R - L + T - B);
                fragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `;

        const pressureShader = `#version 300 es
            precision highp float;
            uniform sampler2D u_pressure;
            uniform sampler2D u_divergence;
            uniform vec2 u_texelSize;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                float L = texture(u_pressure, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
                float R = texture(u_pressure, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
                float T = texture(u_pressure, v_texCoord + vec2(0.0, u_texelSize.y)).x;
                float B = texture(u_pressure, v_texCoord - vec2(0.0, u_texelSize.y)).x;
                float C = texture(u_divergence, v_texCoord).x;

                fragColor = vec4((L + R + B + T - C) * 0.25, 0.0, 0.0, 1.0);
            }
        `;

        const gradientSubtractShader = `#version 300 es
            precision highp float;
            uniform sampler2D u_pressure;
            uniform sampler2D u_velocity;
            uniform vec2 u_texelSize;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                float L = texture(u_pressure, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
                float R = texture(u_pressure, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
                float T = texture(u_pressure, v_texCoord + vec2(0.0, u_texelSize.y)).x;
                float B = texture(u_pressure, v_texCoord - vec2(0.0, u_texelSize.y)).x;

                vec2 velocity = texture(u_velocity, v_texCoord).xy;
                velocity -= 0.5 * vec2(R - L, T - B);
                fragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        const displayShader = `#version 300 es
            precision highp float;
            uniform sampler2D u_texture;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                vec3 col = texture(u_texture, v_texCoord).rgb;
                fragColor = vec4(col, 1.0);
            }
        `;

        const splatShader = `#version 300 es
            precision highp float;
            uniform sampler2D u_target;
            uniform vec2 u_point;
            uniform vec3 u_color;
            uniform float u_radius;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                vec2 p = v_texCoord - u_point;
                float splat = exp(-dot(p, p) / u_radius);
                vec3 base = texture(u_target, v_texCoord).xyz;
                fragColor = vec4(base + splat * u_color, 1.0);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function createProgram(vertSource, fragSource) {
            const program = gl.createProgram();
            gl.attachShader(program, compileShader(vertSource, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(fragSource, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            return program;
        }

        const programs = {
            advect: createProgram(vertexSource, advectShader),
            divergence: createProgram(vertexSource, divergenceShader),
            pressure: createProgram(vertexSource, pressureShader),
            gradientSubtract: createProgram(vertexSource, gradientSubtractShader),
            display: createProgram(vertexSource, displayShader),
            splat: createProgram(vertexSource, splatShader)
        };

        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        function createDoubleFBO(w, h) {
            const fbo1 = createFBO(w, h);
            const fbo2 = createFBO(w, h);
            return {
                read: fbo1,
                write: fbo2,
                swap() {
                    const temp = this.read;
                    this.read = this.write;
                    this.write = temp;
                }
            };
        }

        function createFBO(w, h) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return { fbo, texture, width: w, height: h };
        }

        const simRes = 256;
        const dyeRes = 512;

        let velocity = createDoubleFBO(simRes, simRes);
        let dye = createDoubleFBO(dyeRes, dyeRes);
        let divergence = createFBO(simRes, simRes);
        let pressure = createDoubleFBO(simRes, simRes);

        let pointerX = 0, pointerY = 0;
        let prevPointerX = 0, prevPointerY = 0;
        let pointerDown = false;

        canvas.addEventListener('mousedown', () => { pointerDown = true; });
        canvas.addEventListener('mouseup', () => { pointerDown = false; });
        canvas.addEventListener('mousemove', (e) => {
            prevPointerX = pointerX;
            prevPointerY = pointerY;
            pointerX = e.clientX / canvas.width;
            pointerY = 1.0 - e.clientY / canvas.height;
        });

        function blit(target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function render() {
            // Advect velocity
            gl.useProgram(programs.advect);
            gl.uniform2f(gl.getUniformLocation(programs.advect, 'u_texelSize'), 1.0 / simRes, 1.0 / simRes);
            gl.uniform1f(gl.getUniformLocation(programs.advect, 'u_dt'), 0.017);
            gl.uniform1f(gl.getUniformLocation(programs.advect, 'u_dissipation'), 0.98);
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_velocity'), 0);
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_source'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            blit(velocity.write.fbo);
            velocity.swap();

            // Advect dye
            gl.uniform2f(gl.getUniformLocation(programs.advect, 'u_texelSize'), 1.0 / dyeRes, 1.0 / dyeRes);
            gl.uniform1f(gl.getUniformLocation(programs.advect, 'u_dissipation'), 0.99);
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_source'), 1);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
            blit(dye.write.fbo);
            dye.swap();

            // Add splat
            if (pointerDown) {
                const dx = pointerX - prevPointerX;
                const dy = pointerY - prevPointerY;

                gl.useProgram(programs.splat);
                gl.uniform2f(gl.getUniformLocation(programs.splat, 'u_point'), pointerX, pointerY);
                gl.uniform3f(gl.getUniformLocation(programs.splat, 'u_color'), dx * 100, dy * 100, 0);
                gl.uniform1f(gl.getUniformLocation(programs.splat, 'u_radius'), 0.001);
                gl.uniform1i(gl.getUniformLocation(programs.splat, 'u_target'), 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                blit(velocity.write.fbo);
                velocity.swap();

                gl.uniform3f(gl.getUniformLocation(programs.splat, 'u_color'),
                    Math.random(), Math.random(), Math.random());
                gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
                blit(dye.write.fbo);
                dye.swap();
            }

            // Compute divergence
            gl.useProgram(programs.divergence);
            gl.uniform2f(gl.getUniformLocation(programs.divergence, 'u_texelSize'), 1.0 / simRes, 1.0 / simRes);
            gl.uniform1i(gl.getUniformLocation(programs.divergence, 'u_velocity'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            blit(divergence.fbo);

            // Solve pressure
            gl.useProgram(programs.pressure);
            gl.uniform2f(gl.getUniformLocation(programs.pressure, 'u_texelSize'), 1.0 / simRes, 1.0 / simRes);
            gl.uniform1i(gl.getUniformLocation(programs.pressure, 'u_pressure'), 0);
            gl.uniform1i(gl.getUniformLocation(programs.pressure, 'u_divergence'), 1);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, divergence.texture);

            for (let i = 0; i < 20; i++) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                blit(pressure.write.fbo);
                pressure.swap();
            }

            // Subtract gradient
            gl.useProgram(programs.gradientSubtract);
            gl.uniform2f(gl.getUniformLocation(programs.gradientSubtract, 'u_texelSize'), 1.0 / simRes, 1.0 / simRes);
            gl.uniform1i(gl.getUniformLocation(programs.gradientSubtract, 'u_pressure'), 0);
            gl.uniform1i(gl.getUniformLocation(programs.gradientSubtract, 'u_velocity'), 1);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            blit(velocity.write.fbo);
            velocity.swap();

            // Display
            gl.useProgram(programs.display);
            gl.uniform1i(gl.getUniformLocation(programs.display, 'u_texture'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
            blit(null);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
