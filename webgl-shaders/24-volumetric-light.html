<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric Light Rays - WebGL Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px;
            font-family: monospace; font-size: 14px; pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">God Rays / Volumetric Lighting<br>Move mouse to control light source</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vs = `#version 300 es
            in vec2 a_position;
            void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
        `;

        const fs = `#version 300 es
            precision highp float;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;
            out vec4 fragColor;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for(int i = 0; i < 5; i++) {
                    value += amplitude * noise(p);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;
                vec2 lightPos = u_mouse / u_resolution;

                // Ray direction
                vec2 ray = uv - lightPos;
                float rayLen = length(ray);
                vec2 rayDir = ray / rayLen;

                // Sample along the ray
                float samples = 100.0;
                float decay = 0.95;
                float weight = 0.8;
                float density = 0.4;

                vec3 rayColor = vec3(0.0);
                vec2 samplePos = uv;
                float illuminationDecay = 1.0;

                for(float i = 0.0; i < samples; i++) {
                    samplePos -= rayDir * rayLen / samples;

                    // Sample noise as volumetric density
                    float sampleDensity = fbm(samplePos * 5.0 + u_time * 0.1);
                    sampleDensity *= density;

                    illuminationDecay *= decay;
                    rayColor += sampleDensity * illuminationDecay * weight / samples;
                }

                // Add light source glow
                float glow = 1.0 - smoothstep(0.0, 0.2, length(uv - lightPos));
                vec3 lightColor = vec3(1.0, 0.9, 0.7);

                vec3 col = rayColor * lightColor + glow * lightColor * 2.0;

                // Add atmospheric color
                col = mix(col, vec3(0.1, 0.2, 0.4), smoothstep(0.0, 1.0, rayLen));

                fragColor = vec4(col, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        const mouseLoc = gl.getUniformLocation(program, 'u_mouse');
        const timeLoc = gl.getUniformLocation(program, 'u_time');

        let mouseX = canvas.width * 0.5;
        let mouseY = canvas.height * 0.5;

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = canvas.height - e.clientY;
        });

        function render(time) {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform2f(mouseLoc, mouseX, mouseY);
            gl.uniform1f(timeLoc, time * 0.001);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        render(0);
    </script>
</body>
</html>
