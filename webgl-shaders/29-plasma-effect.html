<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plasma Effect - WebGL Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px;
            font-family: monospace; font-size: 14px; pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">Classic Demoscene Plasma<br>Smooth oscillating color patterns</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vs = `#version 300 es
            in vec2 a_position;
            void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
        `;

        const fs = `#version 300 es
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;
            out vec4 fragColor;

            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.00, 0.33, 0.67);
                return a + b * cos(6.28318 * (c * t + d));
            }

            vec3 palette2(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(2.0, 1.0, 1.0);
                vec3 d = vec3(0.50, 0.20, 0.25);
                return a + b * cos(6.28318 * (c * t + d));
            }

            float plasma(vec2 uv, float time) {
                float cx = uv.x + 0.5 * sin(time / 5.0);
                float cy = uv.y + 0.5 * cos(time / 3.0);

                float value = sin(uv.x * 10.0 + time);
                value += sin(10.0 * (uv.x * sin(time / 2.0) + uv.y * cos(time / 3.0)) + time);

                value += sin(sqrt(100.0 * (cx * cx + cy * cy) + 1.0) + time);

                value += sin(sqrt(uv.x * uv.x + uv.y * uv.y + 1.0) - time);

                return value;
            }

            float plasma2(vec2 uv, float time) {
                float v = 0.0;

                // Layer 1: Horizontal waves
                v += sin(uv.x * 5.0 + time * 2.0);

                // Layer 2: Vertical waves
                v += sin(uv.y * 7.0 + time * 1.5);

                // Layer 3: Circular waves
                float dist = length(uv);
                v += sin(dist * 10.0 - time * 3.0);

                // Layer 4: Diagonal waves
                v += sin((uv.x + uv.y) * 6.0 + time * 1.8);

                // Layer 5: Rotating circular pattern
                float angle = atan(uv.y, uv.x);
                v += sin(angle * 5.0 + time * 2.5);

                // Layer 6: Expanding circles
                v += sin(dist * 8.0 + time * 2.0);

                return v;
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
                uv *= 2.0;

                float time = u_time * 0.5;

                // Generate plasma values
                float p1 = plasma(uv, time);
                float p2 = plasma2(uv * 0.8, time * 0.7);

                // Combine plasma patterns
                float combined = (p1 + p2) * 0.25;

                // Map to colors using palette
                vec3 col = palette(combined + time * 0.1);
                vec3 col2 = palette2(combined * 1.5 + time * 0.05);

                // Mix palettes
                col = mix(col, col2, sin(time) * 0.5 + 0.5);

                // Add glow effect
                float glow = smoothstep(0.5, 0.0, length(uv) * 0.5);
                col += glow * 0.2;

                // Add scanlines
                float scanline = sin(gl_FragCoord.y * 0.5) * 0.05;
                col -= scanline;

                // Vignette
                float vignette = 1.0 - length(uv * 0.5);
                col *= vignette * vignette;

                fragColor = vec4(col, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        const timeLoc = gl.getUniformLocation(program, 'u_time');

        function render(time) {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        render(0);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
