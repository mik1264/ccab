<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Dreaming - WebGL Shader</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        canvas { display: block; width: 100vw; height: 100vh; cursor: none; }

        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease, border-color 0.3s ease;
            mix-blend-mode: difference;
            z-index: 1000;
        }

        .cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 30px 40px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, transparent 100%);
            pointer-events: none;
            opacity: 0;
            animation: fadeIn 3s ease 1s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        h1 {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 200;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            opacity: 0.8;
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            font-style: italic;
        }

        .quote {
            position: absolute;
            bottom: 40px;
            left: 40px;
            right: 40px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
            font-style: italic;
            letter-spacing: 0.05em;
            line-height: 1.6;
            pointer-events: none;
            opacity: 0;
            animation: fadeIn 4s ease 3s forwards;
        }

        .back-link {
            position: absolute;
            top: 30px;
            right: 40px;
            color: rgba(255, 255, 255, 0.4);
            text-decoration: none;
            font-size: 0.8rem;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            transition: all 0.3s ease;
            letter-spacing: 0.1em;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
            color: #fff;
        }

        .breath-indicator {
            position: absolute;
            bottom: 30px;
            right: 40px;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.5); opacity: 0.6; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="cursor" id="cursor"></div>

    <div class="overlay">
        <h1>The Dreaming</h1>
        <p class="subtitle">consciousness emerging from chaos</p>
    </div>

    <a href="index.html" class="back-link">← Gallery</a>

    <p class="quote">
        "We are a way for the cosmos to know itself."<br>
        <span style="opacity: 0.5">— Carl Sagan</span>
    </p>

    <div class="breath-indicator"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const cursor = document.getElementById('cursor');
        const gl = canvas.getContext('webgl2', { antialias: true, alpha: false, preserveDrawingBuffer: false });

        if (!gl) {
            document.body.innerHTML = '<div style="color:white;padding:50px;text-align:center;font-family:sans-serif;"><h1>WebGL2 Required</h1><p>Your browser does not support WebGL2.</p></div>';
            throw new Error('WebGL2 not supported');
        }

        let width, height, dpr;
        let mouseX = 0.5, mouseY = 0.5;
        let targetMouseX = 0.5, targetMouseY = 0.5;
        let smoothMouseX = 0.5, smoothMouseY = 0.5;
        let mouseVelX = 0, mouseVelY = 0;
        let lastMouseX = 0.5, lastMouseY = 0.5;
        let attention = 0; // How much the user is "attending" (mouse movement)

        function resize() {
            dpr = Math.min(window.devicePixelRatio, 1.5); // Cap for performance
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        resize();
        window.addEventListener('resize', resize);

        // Custom cursor
        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
            targetMouseX = e.clientX / width;
            targetMouseY = 1.0 - e.clientY / height;
        });

        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;

            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_mouse;
            uniform vec2 u_mousevel;
            uniform float u_attention;

            in vec2 v_uv;
            out vec4 fragColor;

            #define PI 3.14159265359
            #define TAU 6.28318530718
            #define MAX_STEPS 100
            #define MAX_DIST 50.0
            #define SURF_DIST 0.001

            // ============================================
            // NOISE & HASH FUNCTIONS
            // ============================================

            float hash11(float p) {
                p = fract(p * 0.1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }

            float hash21(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * 0.1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec3 hash33(vec3 p3) {
                p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));
                p3 += dot(p3, p3.yxz + 33.33);
                return fract((p3.xxy + p3.yxx) * p3.zyx);
            }

            float noise3D(vec3 p) {
                vec3 i = floor(p);
                vec3 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);

                return mix(
                    mix(mix(hash21(i.xy + i.z * 127.1),
                            hash21(i.xy + vec2(1,0) + i.z * 127.1), f.x),
                        mix(hash21(i.xy + vec2(0,1) + i.z * 127.1),
                            hash21(i.xy + vec2(1,1) + i.z * 127.1), f.x), f.y),
                    mix(mix(hash21(i.xy + (i.z+1.0) * 127.1),
                            hash21(i.xy + vec2(1,0) + (i.z+1.0) * 127.1), f.x),
                        mix(hash21(i.xy + vec2(0,1) + (i.z+1.0) * 127.1),
                            hash21(i.xy + vec2(1,1) + (i.z+1.0) * 127.1), f.x), f.y),
                    f.z
                );
            }

            float fbm(vec3 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for(int i = 0; i < 5; i++) {
                    value += amplitude * noise3D(p);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }

            // ============================================
            // SIGNED DISTANCE FUNCTIONS
            // ============================================

            float sdSphere(vec3 p, float r) {
                return length(p) - r;
            }

            float sdTorus(vec3 p, vec2 t) {
                vec2 q = vec2(length(p.xz) - t.x, p.y);
                return length(q) - t.y;
            }

            float sdGyroid(vec3 p, float scale, float thickness) {
                p *= scale;
                return (abs(dot(sin(p), cos(p.zxy))) - thickness) / scale;
            }

            float sdOctahedron(vec3 p, float s) {
                p = abs(p);
                return (p.x + p.y + p.z - s) * 0.57735027;
            }

            // Smooth minimum for organic blending
            float smin(float a, float b, float k) {
                float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }

            float smax(float a, float b, float k) {
                return -smin(-a, -b, k);
            }

            // ============================================
            // ROTATION MATRICES
            // ============================================

            mat2 rot2D(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            mat3 rotateY(float a) {
                float s = sin(a), c = cos(a);
                return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
            }

            mat3 rotateX(float a) {
                float s = sin(a), c = cos(a);
                return mat3(1, 0, 0, 0, c, -s, 0, s, c);
            }

            // ============================================
            // THE DREAMING - CONSCIOUSNESS FORMS
            // ============================================

            // Breathing rhythm - the pulse of existence
            float breath() {
                return sin(u_time * 0.5) * 0.5 + 0.5;
            }

            float breathSlow() {
                return sin(u_time * 0.25) * 0.5 + 0.5;
            }

            // Neural pulse - thoughts firing
            float neuralPulse(vec3 p) {
                float t = u_time * 2.0;
                vec3 id = floor(p * 2.0);
                float phase = hash21(id.xy + id.z * 31.7) * TAU;
                float freq = 1.0 + hash21(id.xz) * 2.0;
                return smoothstep(0.7, 1.0, sin(t * freq + phase));
            }

            // The core consciousness - observer
            float consciousnessCore(vec3 p) {
                float b = breath();

                // Pulsing sphere at center
                float core = sdSphere(p, 0.3 + b * 0.1);

                // Orbiting thought-forms
                for(int i = 0; i < 3; i++) {
                    float fi = float(i);
                    float angle = u_time * (0.3 + fi * 0.1) + fi * TAU / 3.0;
                    float radius = 0.8 + sin(u_time * 0.5 + fi) * 0.2;
                    vec3 orbitPos = vec3(cos(angle) * radius, sin(angle * 0.7) * 0.3, sin(angle) * radius);
                    float thought = sdSphere(p - orbitPos, 0.1 + b * 0.05);
                    core = smin(core, thought, 0.3);
                }

                return core;
            }

            // Membrane of perception - the boundary between self and other
            float perceptionMembrane(vec3 p) {
                // Distorted sphere
                float r = 2.0 + breathSlow() * 0.3;
                float distortion = fbm(p * 2.0 + u_time * 0.1) * 0.5;
                float membrane = abs(length(p) - r) - 0.05 - distortion * 0.1;

                return membrane;
            }

            // Neural network - the web of connections
            float neuralWeb(vec3 p) {
                // Gyroid creates the neural lattice
                float gyroid = sdGyroid(p, 3.0 + breath() * 0.5, 0.03);

                // Modulate by distance from center
                float falloff = smoothstep(3.0, 1.0, length(p));
                gyroid = mix(1.0, gyroid, falloff);

                return gyroid;
            }

            // Thought fragments - emerging and dissolving ideas
            float thoughtFragments(vec3 p) {
                float d = 1000.0;

                // Multiple thought clusters
                for(int i = 0; i < 5; i++) {
                    float fi = float(i);
                    float t = u_time * 0.3 + fi * 1.23;

                    // Spiraling position
                    float angle = t + fi * TAU / 5.0;
                    float radius = 1.5 + sin(t * 0.5) * 0.5;
                    float height = sin(t * 0.7 + fi) * 1.0;
                    vec3 pos = vec3(cos(angle) * radius, height, sin(angle) * radius);

                    // Morphing shape - oscillates between forms
                    float morph = sin(t * 0.5 + fi) * 0.5 + 0.5;
                    vec3 localP = p - pos;
                    localP.xz *= rot2D(t);
                    localP.xy *= rot2D(t * 0.7);

                    float shape;
                    if(morph < 0.33) {
                        shape = sdSphere(localP, 0.15);
                    } else if(morph < 0.66) {
                        shape = sdOctahedron(localP, 0.2);
                    } else {
                        shape = sdTorus(localP, vec2(0.12, 0.04));
                    }

                    // Fade in and out
                    float life = sin(t + fi * 0.7) * 0.5 + 0.5;
                    shape = mix(1.0, shape, life);

                    d = smin(d, shape, 0.2);
                }

                return d;
            }

            // Observer effect - where attention goes, form follows
            float observerEffect(vec3 p, vec3 mouseDir) {
                // Create form where the observer looks
                vec3 focusPoint = mouseDir * 2.5;
                float attention_strength = u_attention * 0.5;

                vec3 toFocus = p - focusPoint;
                float focusDist = length(toFocus);

                // Crystallizing structure at focus point
                float crystal = 1000.0;
                if(attention_strength > 0.1) {
                    vec3 localP = toFocus;
                    localP.xz *= rot2D(u_time);
                    localP.xy *= rot2D(u_time * 0.7);

                    crystal = sdOctahedron(localP, 0.3 * attention_strength);

                    // Add orbiting particles
                    for(int i = 0; i < 4; i++) {
                        float fi = float(i);
                        float angle = u_time * 2.0 + fi * TAU / 4.0;
                        vec3 orbitP = localP - vec3(cos(angle), sin(angle * 0.5), sin(angle)) * 0.5 * attention_strength;
                        crystal = smin(crystal, sdSphere(orbitP, 0.05 * attention_strength), 0.1);
                    }
                }

                return crystal;
            }

            // The infinite - fractal depth suggesting infinity
            float infiniteDepth(vec3 p) {
                // Domain repetition with variation
                float scale = 4.0;
                vec3 rep = mod(p * scale, 2.0) - 1.0;
                vec3 id = floor(p * scale / 2.0);

                float variation = hash21(id.xy + id.z * 17.3);
                float size = 0.05 + variation * 0.03;
                size *= smoothstep(5.0, 2.0, length(p)); // Fade with distance

                return sdSphere(rep, size) / scale;
            }

            // ============================================
            // MAIN SCENE
            // ============================================

            float scene(vec3 p, out int materialID) {
                materialID = 0;
                float d = MAX_DIST;

                // Layer 1: Consciousness core
                float core = consciousnessCore(p);
                if(core < d) { d = core; materialID = 1; }

                // Layer 2: Perception membrane
                float membrane = perceptionMembrane(p);
                if(membrane < d) { d = membrane; materialID = 2; }

                // Layer 3: Neural web
                float neural = neuralWeb(p);
                if(neural < d - 0.1) { d = smin(d, neural, 0.1); materialID = 3; }

                // Layer 4: Thought fragments
                float thoughts = thoughtFragments(p);
                if(thoughts < d) { d = thoughts; materialID = 4; }

                // Layer 5: Observer effect
                vec3 mouseDir = normalize(vec3(u_mouse * 2.0 - 1.0, 0.5));
                float observer = observerEffect(p, mouseDir);
                if(observer < d) { d = observer; materialID = 5; }

                // Layer 6: Infinite depth (background)
                float infinite = infiniteDepth(p);
                d = smin(d, infinite, 0.05);

                return d;
            }

            float sceneSimple(vec3 p) {
                int dummy;
                return scene(p, dummy);
            }

            // ============================================
            // RAYMARCHING
            // ============================================

            vec3 getNormal(vec3 p) {
                vec2 e = vec2(0.001, 0.0);
                return normalize(vec3(
                    sceneSimple(p + e.xyy) - sceneSimple(p - e.xyy),
                    sceneSimple(p + e.yxy) - sceneSimple(p - e.yxy),
                    sceneSimple(p + e.yyx) - sceneSimple(p - e.yyx)
                ));
            }

            float raymarch(vec3 ro, vec3 rd, out int matID) {
                float t = 0.0;
                matID = 0;

                for(int i = 0; i < MAX_STEPS; i++) {
                    vec3 p = ro + rd * t;
                    int currentMat;
                    float d = scene(p, currentMat);

                    if(d < SURF_DIST) {
                        matID = currentMat;
                        return t;
                    }

                    if(t > MAX_DIST) break;

                    t += d * 0.8; // Slightly conservative for organic shapes
                }

                return -1.0;
            }

            // ============================================
            // MATERIALS & LIGHTING
            // ============================================

            vec3 getMaterial(int matID, vec3 p, vec3 n, vec3 rd) {
                float b = breath();
                float t = u_time;

                // Base colors for each material
                vec3 col;

                if(matID == 1) {
                    // Consciousness core - warm, pulsing gold/white
                    col = mix(vec3(1.0, 0.9, 0.7), vec3(1.0, 0.7, 0.4), b);
                    col += vec3(1.0, 0.8, 0.5) * pow(1.0 - abs(dot(n, rd)), 3.0); // Rim light
                } else if(matID == 2) {
                    // Perception membrane - translucent blue/purple
                    float fresnel = pow(1.0 - abs(dot(n, rd)), 4.0);
                    col = mix(vec3(0.2, 0.3, 0.5), vec3(0.5, 0.3, 0.6), fresnel);
                    col += vec3(0.3, 0.5, 0.8) * fresnel;
                } else if(matID == 3) {
                    // Neural web - bioluminescent cyan/green with pulses
                    float pulse = neuralPulse(p);
                    col = mix(vec3(0.1, 0.3, 0.3), vec3(0.2, 0.8, 0.6), pulse);
                    col += vec3(0.0, 1.0, 0.8) * pulse * 0.5; // Firing neurons glow
                } else if(matID == 4) {
                    // Thought fragments - shifting rainbow
                    float hue = fract(length(p) * 0.3 + t * 0.1);
                    col = 0.5 + 0.5 * cos(TAU * (hue + vec3(0.0, 0.33, 0.67)));
                } else if(matID == 5) {
                    // Observer effect - crystalline white/blue
                    float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);
                    col = mix(vec3(0.8, 0.9, 1.0), vec3(0.5, 0.7, 1.0), fresnel);
                    col += vec3(1.0) * u_attention * 0.3;
                } else {
                    // Infinite depth / default - deep space blue
                    col = vec3(0.05, 0.1, 0.2);
                }

                return col;
            }

            vec3 lighting(vec3 p, vec3 n, vec3 rd, int matID) {
                vec3 col = getMaterial(matID, p, n, rd);

                // Ambient
                vec3 ambient = vec3(0.05, 0.05, 0.1);

                // Key light - follows consciousness
                vec3 lightPos = vec3(sin(u_time * 0.3) * 3.0, 2.0, cos(u_time * 0.3) * 3.0);
                vec3 lightDir = normalize(lightPos - p);
                float diff = max(dot(n, lightDir), 0.0);
                vec3 diffuse = col * diff * 0.7;

                // Specular
                vec3 halfVec = normalize(lightDir - rd);
                float spec = pow(max(dot(n, halfVec), 0.0), 32.0);
                vec3 specular = vec3(1.0, 0.95, 0.9) * spec * 0.3;

                // Rim light for depth
                float rim = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);
                vec3 rimLight = vec3(0.3, 0.4, 0.6) * rim * 0.5;

                // Subsurface scattering approximation for organic feel
                float sss = pow(max(dot(rd, -lightDir), 0.0), 2.0) * 0.2;
                vec3 subsurface = col * sss;

                return ambient + diffuse + specular + rimLight + subsurface;
            }

            // ============================================
            // BACKGROUND & ATMOSPHERE
            // ============================================

            vec3 background(vec3 rd) {
                // Deep void with subtle color
                vec3 col = vec3(0.02, 0.02, 0.05);

                // Gradient based on direction
                col = mix(col, vec3(0.05, 0.02, 0.08), rd.y * 0.5 + 0.5);

                // Distant stars
                vec3 starP = rd * 500.0;
                vec3 starId = floor(starP);
                vec3 starF = fract(starP);

                for(int i = -1; i <= 1; i++) {
                    for(int j = -1; j <= 1; j++) {
                        for(int k = -1; k <= 1; k++) {
                            vec3 offset = vec3(i, j, k);
                            vec3 h = hash33(starId + offset);
                            vec3 starPos = offset - starF + h;
                            float d = length(starPos);

                            float brightness = h.x * h.y;
                            float twinkle = sin(u_time * (2.0 + h.z * 4.0) + h.x * TAU) * 0.3 + 0.7;
                            float star = smoothstep(0.1, 0.0, d) * brightness * twinkle;

                            col += star * 0.3;
                        }
                    }
                }

                // Subtle nebula clouds
                float nebula = fbm(rd * 3.0 + u_time * 0.02);
                col += vec3(0.1, 0.05, 0.15) * nebula * 0.3;

                return col;
            }

            // ============================================
            // POST PROCESSING
            // ============================================

            vec3 postProcess(vec3 col, vec2 uv) {
                // Glow / bloom approximation
                float brightness = dot(col, vec3(0.299, 0.587, 0.114));
                col += col * smoothstep(0.5, 1.0, brightness) * 0.4;

                // Chromatic aberration
                float caStrength = length(uv) * 0.01;
                // (simplified - actual CA would require texture sampling)

                // Vignette
                float vignette = 1.0 - pow(length(uv) * 0.7, 2.0);
                vignette = smoothstep(0.0, 1.0, vignette);
                col *= vignette;

                // Film grain
                float grain = hash21(uv * 1000.0 + u_time) * 0.02;
                col += grain;

                // Tone mapping
                col = col / (col + 0.5);

                // Color grading - slightly warm
                col = pow(col, vec3(0.95, 1.0, 1.05));

                // Gamma
                col = pow(col, vec3(1.0/2.2));

                // Breathing opacity pulse
                float breathAlpha = 0.95 + breath() * 0.05;
                col *= breathAlpha;

                return col;
            }

            // ============================================
            // MAIN
            // ============================================

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);

                // Camera
                float camDist = 6.0 - breathSlow() * 0.5;
                vec3 ro = vec3(0.0, 0.0, -camDist);

                // Gentle automatic rotation
                float autoRotY = u_time * 0.08;
                float autoRotX = sin(u_time * 0.05) * 0.15;

                // Mouse influence
                float mouseInfluence = 0.3;
                mat3 camRot = rotateY(autoRotY + (u_mouse.x - 0.5) * mouseInfluence)
                            * rotateX(autoRotX + (u_mouse.y - 0.5) * mouseInfluence * 0.5);

                ro = camRot * ro;
                vec3 rd = normalize(camRot * vec3(uv, 1.0));

                // Raymarch
                int matID;
                float t = raymarch(ro, rd, matID);

                vec3 col;

                if(t > 0.0) {
                    vec3 p = ro + rd * t;
                    vec3 n = getNormal(p);

                    col = lighting(p, n, rd, matID);

                    // Fog for depth
                    float fog = 1.0 - exp(-t * 0.05);
                    col = mix(col, background(rd), fog * 0.5);
                } else {
                    col = background(rd);
                }

                // Volumetric light rays from center
                vec3 centerDir = normalize(-ro);
                float centerAlign = max(0.0, dot(rd, centerDir));
                col += vec3(0.2, 0.15, 0.1) * pow(centerAlign, 8.0) * breath() * 0.3;

                // Post processing
                col = postProcess(col, uv);

                fragColor = vec4(col, 1.0);
            }
        `;

        // Compile shaders
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        // Fullscreen quad
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const mouseLoc = gl.getUniformLocation(program, 'u_mouse');
        const mouseVelLoc = gl.getUniformLocation(program, 'u_mousevel');
        const attentionLoc = gl.getUniformLocation(program, 'u_attention');

        function render(time) {
            // Smooth mouse with momentum
            const dx = targetMouseX - smoothMouseX;
            const dy = targetMouseY - smoothMouseY;
            smoothMouseX += dx * 0.08;
            smoothMouseY += dy * 0.08;

            // Calculate velocity for attention
            mouseVelX = smoothMouseX - lastMouseX;
            mouseVelY = smoothMouseY - lastMouseY;
            lastMouseX = smoothMouseX;
            lastMouseY = smoothMouseY;

            // Attention decays when mouse stops, increases when moving
            const movement = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
            attention = attention * 0.98 + movement * 50.0 * 0.02;
            attention = Math.min(attention, 1.0);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);
            gl.uniform2f(mouseLoc, smoothMouseX, smoothMouseY);
            gl.uniform2f(mouseVelLoc, mouseVelX * 100, mouseVelY * 100);
            gl.uniform1f(attentionLoc, attention);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        render(0);
    </script>
</body>
</html>
