<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergent Cosmos - WebGL Shader</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
            pointer-events: none;
        }

        h1 {
            color: #fff;
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 30px rgba(100, 150, 255, 0.5);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            letter-spacing: 0.1em;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            pointer-events: none;
        }

        .back-link {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
            color: #fff;
        }

        .fps {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.75rem;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="overlay">
        <h1>Emergent Cosmos</h1>
        <p class="subtitle">A journey through procedural spacetime</p>
    </div>

    <a href="index.html" class="back-link">← Gallery</a>

    <div class="controls">
        Move mouse to navigate • Click and drag to explore
    </div>

    <div class="fps" id="fps">-- FPS</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { antialias: true, alpha: false });

        if (!gl) {
            document.body.innerHTML = '<div style="color:white;padding:50px;text-align:center;"><h1>WebGL2 Required</h1><p>Your browser does not support WebGL2.</p></div>';
            throw new Error('WebGL2 not supported');
        }

        let width, height, dpr;
        let mouseX = 0.5, mouseY = 0.5;
        let targetMouseX = 0.5, targetMouseY = 0.5;
        let isDragging = false;
        let cameraRotX = 0, cameraRotY = 0;

        function resize() {
            dpr = Math.min(window.devicePixelRatio, 2);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        resize();
        window.addEventListener('resize', resize);

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX / width;
            targetMouseY = 1.0 - e.clientY / height;
            if (isDragging) {
                cameraRotY += (e.movementX / width) * 2;
                cameraRotX += (e.movementY / height) * 2;
                cameraRotX = Math.max(-1.5, Math.min(1.5, cameraRotX));
            }
        });

        canvas.addEventListener('mousedown', () => isDragging = true);
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        // Vertex shader - fullscreen quad
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader - the cosmic journey
        const fragmentShaderSource = `#version 300 es
            precision highp float;

            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_mouse;
            uniform vec2 u_camera;

            in vec2 v_uv;
            out vec4 fragColor;

            #define PI 3.14159265359
            #define TAU 6.28318530718
            #define MAX_STEPS 80
            #define MAX_DIST 100.0
            #define SURF_DIST 0.001

            // Hash functions for noise
            float hash11(float p) {
                p = fract(p * 0.1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }

            float hash21(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * 0.1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec2 hash22(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.xx + p3.yz) * p3.zy);
            }

            vec3 hash33(vec3 p3) {
                p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));
                p3 += dot(p3, p3.yxz + 33.33);
                return fract((p3.xxy + p3.yxx) * p3.zyx);
            }

            // Smooth noise
            float noise(vec3 p) {
                vec3 i = floor(p);
                vec3 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);

                return mix(
                    mix(mix(hash21(i.xy + i.z * 127.1), hash21(i.xy + vec2(1,0) + i.z * 127.1), f.x),
                        mix(hash21(i.xy + vec2(0,1) + i.z * 127.1), hash21(i.xy + vec2(1,1) + i.z * 127.1), f.x), f.y),
                    mix(mix(hash21(i.xy + (i.z+1.0) * 127.1), hash21(i.xy + vec2(1,0) + (i.z+1.0) * 127.1), f.x),
                        mix(hash21(i.xy + vec2(0,1) + (i.z+1.0) * 127.1), hash21(i.xy + vec2(1,1) + (i.z+1.0) * 127.1), f.x), f.y),
                    f.z
                );
            }

            // Fractal Brownian Motion
            float fbm(vec3 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;

                for(int i = 0; i < 5; i++) {
                    value += amplitude * noise(p * frequency);
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }

            // Domain warped fbm for organic look
            float warpedFbm(vec3 p) {
                vec3 q = vec3(
                    fbm(p + vec3(0.0, 0.0, 0.0)),
                    fbm(p + vec3(5.2, 1.3, 2.8)),
                    fbm(p + vec3(2.1, 7.9, 4.6))
                );

                vec3 r = vec3(
                    fbm(p + 4.0 * q + vec3(1.7, 9.2, 3.4) + u_time * 0.05),
                    fbm(p + 4.0 * q + vec3(8.3, 2.8, 6.1) + u_time * 0.03),
                    fbm(p + 4.0 * q + vec3(3.1, 5.7, 8.2) + u_time * 0.04)
                );

                return fbm(p + 4.0 * r);
            }

            // Nebula density function
            float nebulaDensity(vec3 p) {
                float t = u_time * 0.02;

                // Multiple swirling layers
                float d1 = warpedFbm(p * 0.5 + vec3(t * 0.1, 0, 0));
                float d2 = warpedFbm(p * 0.3 + vec3(0, t * 0.08, 0));
                float d3 = fbm(p * 0.8 + vec3(t * 0.05));

                // Combine layers
                float density = d1 * 0.5 + d2 * 0.3 + d3 * 0.2;

                // Add swirling motion around center
                float dist = length(p.xz);
                float angle = atan(p.z, p.x) + t * 0.1 + dist * 0.2;
                density += sin(angle * 3.0 + d1 * 5.0) * 0.1;

                // Fade at distance
                density *= smoothstep(15.0, 2.0, length(p));

                return max(0.0, density);
            }

            // Beautiful cosmic color palette
            vec3 cosmicPalette(float t, float density) {
                // Evolving base colors
                float phase = u_time * 0.03;

                vec3 deepSpace = vec3(0.02, 0.01, 0.05);
                vec3 nebulaPink = vec3(0.8, 0.2, 0.4);
                vec3 nebulaBlue = vec3(0.2, 0.4, 0.9);
                vec3 nebulaPurple = vec3(0.5, 0.2, 0.8);
                vec3 nebulaGold = vec3(0.9, 0.7, 0.3);
                vec3 nebulaTeal = vec3(0.1, 0.8, 0.7);

                // Color mixing based on position and time
                float mix1 = sin(t * TAU + phase) * 0.5 + 0.5;
                float mix2 = sin(t * TAU * 2.0 + phase * 1.3) * 0.5 + 0.5;
                float mix3 = sin(t * TAU * 0.5 + phase * 0.7) * 0.5 + 0.5;

                vec3 color = deepSpace;
                color = mix(color, nebulaPink, mix1 * density);
                color = mix(color, nebulaBlue, mix2 * density * 0.7);
                color = mix(color, nebulaPurple, mix3 * density * 0.5);
                color = mix(color, nebulaGold, pow(density, 2.0) * 0.3);
                color = mix(color, nebulaTeal, sin(t * 3.0 + phase) * 0.5 + 0.5 * density * 0.2);

                return color;
            }

            // Star field
            vec3 stars(vec3 rd) {
                vec3 col = vec3(0.0);

                // Multiple star layers for depth
                for(int layer = 0; layer < 3; layer++) {
                    float scale = 300.0 + float(layer) * 200.0;
                    vec3 p = rd * scale;
                    vec3 id = floor(p);
                    vec3 f = fract(p);

                    for(int i = -1; i <= 1; i++) {
                        for(int j = -1; j <= 1; j++) {
                            for(int k = -1; k <= 1; k++) {
                                vec3 offset = vec3(i, j, k);
                                vec3 h = hash33(id + offset);
                                vec3 r = offset - f + h;
                                float d = length(r);

                                // Star brightness with twinkle
                                float brightness = h.x;
                                float twinkle = sin(u_time * (3.0 + h.y * 5.0) + h.z * TAU) * 0.3 + 0.7;
                                float star = smoothstep(0.1, 0.0, d) * brightness * twinkle;

                                // Star color (mostly white with hints of color)
                                vec3 starColor = mix(
                                    vec3(1.0, 0.95, 0.9),  // Warm white
                                    vec3(0.9, 0.95, 1.0),  // Cool white
                                    h.z
                                );

                                // Some colored stars
                                if(h.x > 0.95) {
                                    starColor = mix(starColor, vec3(1.0, 0.6, 0.3), 0.5); // Orange giant
                                } else if(h.x > 0.9) {
                                    starColor = mix(starColor, vec3(0.6, 0.8, 1.0), 0.5); // Blue star
                                }

                                col += star * starColor * (1.0 - float(layer) * 0.2);
                            }
                        }
                    }
                }

                return col;
            }

            // Camera rotation matrix
            mat3 rotateY(float a) {
                float s = sin(a), c = cos(a);
                return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
            }

            mat3 rotateX(float a) {
                float s = sin(a), c = cos(a);
                return mat3(1, 0, 0, 0, c, -s, 0, s, c);
            }

            // Volumetric raymarching through nebula
            vec4 raymarchNebula(vec3 ro, vec3 rd) {
                vec4 col = vec4(0.0);

                float t = 0.0;
                float stepSize = 0.15;

                for(int i = 0; i < 60; i++) {
                    if(col.a > 0.95 || t > MAX_DIST) break;

                    vec3 p = ro + rd * t;

                    // Sample nebula density
                    float density = nebulaDensity(p);

                    if(density > 0.01) {
                        // Get color based on position and density
                        float colorIndex = length(p.xz) * 0.1 + p.y * 0.05 + density * 0.5;
                        vec3 nebulaColor = cosmicPalette(colorIndex, density);

                        // Add emission glow in dense areas
                        nebulaColor += vec3(1.0, 0.5, 0.8) * pow(density, 3.0) * 2.0;

                        // Accumulate color with density
                        float alpha = density * stepSize * 0.5;
                        col.rgb += nebulaColor * alpha * (1.0 - col.a);
                        col.a += alpha * (1.0 - col.a);
                    }

                    // Adaptive step size
                    t += stepSize * (0.5 + 0.5 * (1.0 - density));
                }

                return col;
            }

            // Glowing cosmic dust particles
            float cosmicDust(vec3 p, vec3 rd) {
                float dust = 0.0;

                for(int i = 0; i < 3; i++) {
                    float scale = 50.0 + float(i) * 30.0;
                    vec3 dustP = p * scale + u_time * (0.5 + float(i) * 0.3);
                    float n = fbm(dustP);
                    dust += n * 0.15 / float(i + 1);
                }

                return dust * 0.3;
            }

            // God rays / light shafts
            vec3 godRays(vec3 ro, vec3 rd) {
                vec3 lightPos = vec3(sin(u_time * 0.1) * 5.0, 3.0, cos(u_time * 0.1) * 5.0);
                vec3 lightDir = normalize(lightPos);

                float alignment = max(0.0, dot(rd, lightDir));
                float rays = pow(alignment, 16.0);

                // Add volumetric scattering
                float scatter = 0.0;
                float t = 0.0;
                for(int i = 0; i < 16; i++) {
                    vec3 p = ro + rd * t;
                    float dist = length(p - lightPos);
                    scatter += exp(-dist * 0.3) * 0.02;
                    t += 0.5;
                }

                vec3 lightColor = mix(
                    vec3(1.0, 0.8, 0.6),
                    vec3(0.8, 0.6, 1.0),
                    sin(u_time * 0.05) * 0.5 + 0.5
                );

                return lightColor * (rays * 0.5 + scatter);
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);

                // Camera setup with mouse control
                vec3 ro = vec3(0.0, 0.0, -8.0);

                // Automatic gentle rotation + mouse influence
                float autoRotY = u_time * 0.05;
                float autoRotX = sin(u_time * 0.03) * 0.2;

                mat3 camRot = rotateY(autoRotY + u_camera.y + (u_mouse.x - 0.5) * 0.5)
                            * rotateX(autoRotX + u_camera.x + (u_mouse.y - 0.5) * 0.3);

                ro = camRot * ro;

                // Ray direction with slight fish-eye for immersion
                float fov = 1.0 + length(uv) * 0.1;
                vec3 rd = normalize(camRot * vec3(uv * fov, 1.0));

                // Render layers
                vec3 col = vec3(0.0);

                // Background: deep space gradient
                vec3 spaceGradient = mix(
                    vec3(0.0, 0.0, 0.02),
                    vec3(0.02, 0.0, 0.05),
                    uv.y * 0.5 + 0.5
                );
                col = spaceGradient;

                // Stars
                col += stars(rd);

                // God rays
                col += godRays(ro, rd) * 0.3;

                // Main nebula volumetric rendering
                vec4 nebula = raymarchNebula(ro, rd);
                col = mix(col, nebula.rgb, nebula.a);

                // Additional cosmic dust overlay
                float dust = cosmicDust(ro + rd * 5.0, rd);
                col += vec3(0.5, 0.3, 0.6) * dust;

                // Post-processing

                // Bloom simulation on bright areas
                float brightness = dot(col, vec3(0.299, 0.587, 0.114));
                col += col * smoothstep(0.5, 1.5, brightness) * 0.5;

                // Subtle chromatic aberration
                vec2 caOffset = uv * 0.002;

                // Vignette
                float vignette = 1.0 - length(uv) * 0.4;
                vignette = smoothstep(0.0, 1.0, vignette);
                col *= vignette;

                // Film grain for organic feel
                float grain = hash21(uv + u_time) * 0.03;
                col += grain;

                // Tone mapping
                col = col / (col + 1.0);

                // Slight color grading
                col = pow(col, vec3(0.95, 1.0, 1.05));

                // Gamma correction
                col = pow(col, vec3(1.0/2.2));

                fragColor = vec4(col, 1.0);
            }
        `;

        // Compile shaders
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }

        // Fullscreen quad
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const mouseLoc = gl.getUniformLocation(program, 'u_mouse');
        const cameraLoc = gl.getUniformLocation(program, 'u_camera');

        // FPS counter
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        const fpsElement = document.getElementById('fps');

        function render(time) {
            // Smooth mouse
            mouseX += (targetMouseX - mouseX) * 0.05;
            mouseY += (targetMouseY - mouseY) * 0.05;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);
            gl.uniform2f(mouseLoc, mouseX, mouseY);
            gl.uniform2f(cameraLoc, cameraRotX, cameraRotY);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // FPS update
            frameCount++;
            if (time - lastFpsUpdate >= 1000) {
                fpsElement.textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsUpdate = time;
            }

            requestAnimationFrame(render);
        }

        render(0);
    </script>
</body>
</html>
