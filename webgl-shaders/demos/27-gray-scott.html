<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gray-Scott Reaction-Diffusion</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .info {
            position: absolute; top: 10px; left: 10px; color: #fff;
            font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px;
        }
    </style>
</head>
<body>
    <div class="info">Gray-Scott Reaction-Diffusion System<br>Click to add chemicals</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const width = 512;
        const height = 512;
        canvas.width = width;
        canvas.height = height;
        gl.viewport(0, 0, width, height);

        const vs = `attribute vec2 position; varying vec2 vUv; void main() { vUv = position * 0.5 + 0.5; gl_Position = vec4(position, 0.0, 1.0); }`;

        const computeShader = `
            precision highp float;
            uniform sampler2D uTexture;
            uniform vec2 resolution;
            uniform vec2 mousePos;
            uniform bool mouseDown;
            varying vec2 vUv;

            void main() {
                vec2 texel = 1.0 / resolution;
                vec4 center = texture2D(uTexture, vUv);

                // Laplacian for both chemicals
                vec4 laplacian = texture2D(uTexture, vUv + vec2(-texel.x, 0.0)) +
                                 texture2D(uTexture, vUv + vec2(texel.x, 0.0)) +
                                 texture2D(uTexture, vUv + vec2(0.0, -texel.y)) +
                                 texture2D(uTexture, vUv + vec2(0.0, texel.y)) -
                                 4.0 * center;

                float a = center.r;
                float b = center.g;

                float Da = 1.0;
                float Db = 0.5;
                float f = 0.055;
                float k = 0.062;

                float reaction = a * b * b;
                float da = Da * laplacian.r - reaction + f * (1.0 - a);
                float db = Db * laplacian.g + reaction - (k + f) * b;

                a += da * 0.6;
                b += db * 0.6;

                if(mouseDown && distance(vUv, mousePos) < 0.02) {
                    b = 1.0;
                }

                gl_FragColor = vec4(a, b, 0.0, 1.0);
            }
        `;

        const displayShader = `
            precision highp float;
            uniform sampler2D uTexture;
            varying vec2 vUv;

            void main() {
                vec4 data = texture2D(uTexture, vUv);
                float b = data.g;
                vec3 col = vec3(b * 2.0, b * 1.5, b * 3.0);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const computeProgram = gl.createProgram();
        gl.attachShader(computeProgram, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(computeProgram, createShader(gl, gl.FRAGMENT_SHADER, computeShader));
        gl.linkProgram(computeProgram);

        const displayProgram = gl.createProgram();
        gl.attachShader(displayProgram, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(displayProgram, createShader(gl, gl.FRAGMENT_SHADER, displayShader));
        gl.linkProgram(displayProgram);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        // Create textures and framebuffers
        const textures = [gl.createTexture(), gl.createTexture()];
        const framebuffers = [gl.createFramebuffer(), gl.createFramebuffer()];

        const initialData = new Float32Array(width * height * 4);
        for(let i = 0; i < width * height; i++) {
            initialData[i * 4] = 1.0;
            initialData[i * 4 + 1] = Math.random() < 0.01 ? 1.0 : 0.0;
        }

        textures.forEach((texture, i) => {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, initialData);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        });

        let currentBuffer = 0;
        let mouseDown = false;
        let mousePos = [0.5, 0.5];

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            mousePos = [e.offsetX / canvas.width, 1.0 - e.offsetY / canvas.height];
        });

        function render() {
            // Compute step
            gl.useProgram(computeProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1 - currentBuffer]);

            const posLoc = gl.getAttribLocation(computeProgram, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBuffer]);
            gl.uniform1i(gl.getUniformLocation(computeProgram, 'uTexture'), 0);
            gl.uniform2f(gl.getUniformLocation(computeProgram, 'resolution'), width, height);
            gl.uniform2f(gl.getUniformLocation(computeProgram, 'mousePos'), mousePos[0], mousePos[1]);
            gl.uniform1i(gl.getUniformLocation(computeProgram, 'mouseDown'), mouseDown);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            currentBuffer = 1 - currentBuffer;

            // Display step
            gl.useProgram(displayProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            const dispPosLoc = gl.getAttribLocation(displayProgram, 'position');
            gl.enableVertexAttribArray(dispPosLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(dispPosLoc, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBuffer]);
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uTexture'), 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        if(gl.getExtension('OES_texture_float')) {
            render();
        } else {
            document.querySelector('.info').textContent = 'Float textures not supported';
        }
    </script>
</body>
</html>
