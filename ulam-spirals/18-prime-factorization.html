<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime Factorization Spiral</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0f; overflow: hidden; font-family: system-ui; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; text-decoration: none;
            background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 25px;
            font-size: 14px; transition: all 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .legend {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 15px;
            color: white; font-size: 13px;
        }
        .legend h3 { color: #DDA15E; margin-bottom: 12px; }
        .legend-item { display: flex; align-items: center; margin: 6px 0; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; margin-right: 8px; }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 15px;
        }
        .controls h3 { color: #DDA15E; margin-bottom: 15px; }
        .controls label { color: white; display: block; margin: 10px 0; font-size: 14px; }
        .controls select { padding: 5px; width: 150px; }
        .info {
            position: fixed; bottom: 20px; left: 20px; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 15px 20px; border-radius: 10px;
            color: white; font-size: 13px;
        }
        .info span { color: #DDA15E; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="controls">
        <h3>Factorization View</h3>
        <label>Color by:
            <select id="colorMode">
                <option value="largest">Largest Prime Factor</option>
                <option value="smallest">Smallest Prime Factor</option>
                <option value="count">Number of Prime Factors</option>
                <option value="omega">Distinct Prime Factors</option>
            </select>
        </label>
    </div>
    <div class="info">
        Hover to see: <span id="hoverInfo">-</span>
    </div>
    <div class="legend" id="legend">
        <h3>Largest Prime Factor</h3>
        <div class="legend-item"><div class="legend-color" style="background:#ff4444"></div>Factor: 2</div>
        <div class="legend-item"><div class="legend-color" style="background:#ff8844"></div>Factor: 3</div>
        <div class="legend-item"><div class="legend-color" style="background:#ffcc44"></div>Factor: 5</div>
        <div class="legend-item"><div class="legend-color" style="background:#88ff44"></div>Factor: 7</div>
        <div class="legend-item"><div class="legend-color" style="background:#44ffcc"></div>Factor: 11+</div>
        <div class="legend-item"><div class="legend-color" style="background:#fff"></div>Prime (itself)</div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 151;
        const maxN = gridSize * gridSize;
        let cellSize;
        let colorMode = 'largest';

        // Sieve and factorization
        const smallestFactor = new Array(maxN + 1).fill(0);
        const largestFactor = new Array(maxN + 1).fill(0);
        const factorCount = new Array(maxN + 1).fill(0);
        const distinctFactors = new Array(maxN + 1).fill(0);

        // Initialize
        for (let i = 2; i <= maxN; i++) {
            if (smallestFactor[i] === 0) {
                // i is prime
                smallestFactor[i] = i;
                largestFactor[i] = i;
                factorCount[i] = 1;
                distinctFactors[i] = 1;

                for (let j = i * 2; j <= maxN; j += i) {
                    if (smallestFactor[j] === 0) smallestFactor[j] = i;
                    largestFactor[j] = i;
                }
            }
        }

        // Count factors
        for (let i = 2; i <= maxN; i++) {
            if (factorCount[i] === 0) {
                let n = i;
                let count = 0;
                let distinct = 0;
                let lastFactor = 0;

                while (n > 1) {
                    const f = smallestFactor[n];
                    count++;
                    if (f !== lastFactor) {
                        distinct++;
                        lastFactor = f;
                    }
                    n = n / f;
                }

                factorCount[i] = count;
                distinctFactors[i] = distinct;
            }
        }

        function isPrime(n) {
            return n > 1 && smallestFactor[n] === n;
        }

        function getFactorColor(n) {
            if (isPrime(n)) return { h: 0, s: 0, l: 100 }; // White for primes

            let value;
            switch (colorMode) {
                case 'largest':
                    value = largestFactor[n];
                    if (value === 2) return { h: 0, s: 80, l: 50 };
                    if (value === 3) return { h: 30, s: 80, l: 50 };
                    if (value === 5) return { h: 50, s: 80, l: 50 };
                    if (value === 7) return { h: 100, s: 80, l: 50 };
                    if (value === 11) return { h: 160, s: 80, l: 50 };
                    if (value === 13) return { h: 200, s: 80, l: 50 };
                    return { h: 240 + (value % 120), s: 70, l: 45 };

                case 'smallest':
                    value = smallestFactor[n];
                    if (value === 2) return { h: 0, s: 80, l: 50 };
                    if (value === 3) return { h: 60, s: 80, l: 50 };
                    if (value === 5) return { h: 120, s: 80, l: 50 };
                    if (value === 7) return { h: 180, s: 80, l: 50 };
                    return { h: 240, s: 80, l: 50 };

                case 'count':
                    value = factorCount[n];
                    const hue = Math.min(value * 30, 270);
                    return { h: hue, s: 80, l: 50 };

                case 'omega':
                    value = distinctFactors[n];
                    return { h: value * 60, s: 80, l: 50 };
            }
        }

        function getSpiralCoord(n) {
            if (n === 1) return { x: 0, y: 0 };
            let layer = Math.ceil((Math.sqrt(n) - 1) / 2);
            let leg = Math.floor((n - (2 * layer - 1) ** 2) / (2 * layer));
            let element = (n - (2 * layer - 1) ** 2) % (2 * layer);
            let x, y;
            switch (leg) {
                case 0: x = layer; y = -layer + 1 + element; break;
                case 1: x = layer - 1 - element; y = layer; break;
                case 2: x = -layer; y = layer - 1 - element; break;
                case 3: x = -layer + 1 + element; y = -layer; break;
            }
            return { x, y };
        }

        function getNumberFromCoord(gx, gy) {
            if (gx === 0 && gy === 0) return 1;
            const layer = Math.max(Math.abs(gx), Math.abs(gy));
            const sideLength = 2 * layer;
            const startOfLayer = (2 * layer - 1) ** 2 + 1;

            if (gx === layer && gy > -layer) {
                return startOfLayer + (gy + layer - 1);
            } else if (gy === layer) {
                return startOfLayer + sideLength - 1 + (layer - gx);
            } else if (gx === -layer) {
                return startOfLayer + 2 * sideLength - 1 + (layer - gy);
            } else {
                return startOfLayer + 3 * sideLength - 1 + (gx + layer);
            }
        }

        function factorize(n) {
            if (n <= 1) return '1';
            if (isPrime(n)) return `${n} (prime)`;

            const factors = [];
            let temp = n;
            while (temp > 1) {
                const f = smallestFactor[temp];
                let count = 0;
                while (temp % f === 0) {
                    temp /= f;
                    count++;
                }
                factors.push(count > 1 ? `${f}^${count}` : `${f}`);
            }
            return factors.join(' × ');
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cellSize = Math.min(canvas.width, canvas.height) / gridSize;
            draw();
        }

        function draw() {
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2;

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let n = 2; n <= maxN; n++) {
                const { x, y } = getSpiralCoord(n);
                const px = offsetX + x * cellSize;
                const py = offsetY + y * cellSize;

                if (px < -cellSize || px > canvas.width + cellSize ||
                    py < -cellSize || py > canvas.height + cellSize) continue;

                const color = getFactorColor(n);
                const size = isPrime(n) ? 0.4 : 0.35;

                ctx.fillStyle = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
                ctx.beginPath();
                ctx.arc(px, py, cellSize * size, 0, Math.PI * 2);
                ctx.fill();

                if (isPrime(n)) {
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(px, py, cellSize * 0.55, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Center (1)
            ctx.fillStyle = '#BC6C25';
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, cellSize * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        canvas.addEventListener('mousemove', (e) => {
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2;
            const gx = Math.round((e.clientX - offsetX) / cellSize);
            const gy = Math.round((e.clientY - offsetY) / cellSize);
            const n = getNumberFromCoord(gx, gy);

            if (n >= 1 && n <= maxN) {
                document.getElementById('hoverInfo').textContent = `${n} = ${factorize(n)}`;
            }
        });

        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
            draw();
        });

        window.addEventListener('resize', resize);
        resize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
