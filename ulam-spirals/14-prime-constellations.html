<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime Constellations - Ulam Spiral</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #050510; overflow: hidden; font-family: system-ui; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; text-decoration: none;
            background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 25px;
            font-size: 14px; transition: all 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 15px;
        }
        .controls h3 { color: #DDA15E; margin-bottom: 15px; }
        .controls label { color: white; display: block; margin: 10px 0; font-size: 14px; }
        .controls input { width: 150px; }
        .info {
            position: fixed; bottom: 20px; left: 20px; z-index: 100;
            color: rgba(255,255,255,0.6); font-size: 13px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div class="controls">
        <h3>Constellation Settings</h3>
        <label>Max Distance: <span id="distVal">3</span>
            <input type="range" id="maxDist" min="1" max="8" value="3">
        </label>
        <label>
            <input type="checkbox" id="animate" checked> Animate
        </label>
        <label>
            <input type="checkbox" id="showLabels"> Show Numbers
        </label>
    </div>
    <div class="info">Primes connected to nearby primes form constellation patterns</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 151;
        const maxN = gridSize * gridSize;
        let cellSize;
        let maxDist = 3;
        let animate = true;
        let showLabels = false;
        let time = 0;

        // Sieve
        const primes = [];
        const isPrimeArr = new Array(maxN + 1).fill(true);
        isPrimeArr[0] = isPrimeArr[1] = false;
        for (let i = 2; i * i <= maxN; i++) {
            if (isPrimeArr[i]) {
                for (let j = i * i; j <= maxN; j += i) {
                    isPrimeArr[j] = false;
                }
            }
        }
        for (let i = 2; i <= maxN; i++) {
            if (isPrimeArr[i]) primes.push(i);
        }

        // Cache coordinates
        const coords = new Map();
        function getSpiralCoord(n) {
            if (coords.has(n)) return coords.get(n);
            if (n === 1) { coords.set(n, { x: 0, y: 0 }); return { x: 0, y: 0 }; }
            let layer = Math.ceil((Math.sqrt(n) - 1) / 2);
            let leg = Math.floor((n - (2 * layer - 1) ** 2) / (2 * layer));
            let element = (n - (2 * layer - 1) ** 2) % (2 * layer);
            let x, y;
            switch (leg) {
                case 0: x = layer; y = -layer + 1 + element; break;
                case 1: x = layer - 1 - element; y = layer; break;
                case 2: x = -layer; y = layer - 1 - element; break;
                case 3: x = -layer + 1 + element; y = -layer; break;
            }
            coords.set(n, { x, y });
            return { x, y };
        }

        // Pre-compute all coords
        for (let n = 1; n <= maxN; n++) getSpiralCoord(n);

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cellSize = Math.min(canvas.width, canvas.height) / gridSize;
        }

        function distance(c1, c2) {
            return Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
        }

        function draw() {
            if (animate) time += 0.01;

            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2;

            // Fade effect for trails
            ctx.fillStyle = 'rgba(5, 5, 16, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw constellation lines
            for (let i = 0; i < primes.length; i++) {
                const p1 = primes[i];
                const c1 = coords.get(p1);
                const px1 = offsetX + c1.x * cellSize;
                const py1 = offsetY + c1.y * cellSize;

                // Check nearby primes
                for (let j = i + 1; j < primes.length && j < i + 50; j++) {
                    const p2 = primes[j];
                    const c2 = coords.get(p2);
                    const dist = distance(c1, c2);

                    if (dist <= maxDist) {
                        const px2 = offsetX + c2.x * cellSize;
                        const py2 = offsetY + c2.y * cellSize;

                        // Animated gradient
                        const hue = animate ? (time * 30 + i * 0.5) % 360 : 45;
                        const alpha = 0.3 + 0.2 * Math.sin(time * 2 + i * 0.1);

                        ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                        ctx.lineWidth = (maxDist - dist + 1) * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(px1, py1);
                        ctx.lineTo(px2, py2);
                        ctx.stroke();
                    }
                }
            }

            // Draw prime stars
            for (const p of primes) {
                const c = coords.get(p);
                const px = offsetX + c.x * cellSize;
                const py = offsetY + c.y * cellSize;

                if (px < -cellSize * 2 || px > canvas.width + cellSize * 2 ||
                    py < -cellSize * 2 || py > canvas.height + cellSize * 2) continue;

                // Twinkling effect
                const twinkle = animate ? 0.7 + 0.3 * Math.sin(time * 5 + p) : 1;
                const size = cellSize * 0.3 * twinkle;

                // Glow
                const gradient = ctx.createRadialGradient(px, py, 0, px, py, size * 2);
                gradient.addColorStop(0, `rgba(255, 240, 200, ${twinkle})`);
                gradient.addColorStop(0.5, `rgba(255, 215, 100, ${twinkle * 0.3})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(px, py, size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = `rgba(255, 250, 230, ${twinkle})`;
                ctx.beginPath();
                ctx.arc(px, py, size * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Labels
                if (showLabels && cellSize > 6 && p < 500) {
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(p, px, py - size - 3);
                }
            }

            // Center marker
            ctx.fillStyle = '#BC6C25';
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, cellSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            requestAnimationFrame(draw);
        }

        document.getElementById('maxDist').addEventListener('input', (e) => {
            maxDist = parseInt(e.target.value);
            document.getElementById('distVal').textContent = maxDist;
        });

        document.getElementById('animate').addEventListener('change', (e) => {
            animate = e.target.checked;
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            showLabels = e.target.checked;
        });

        window.addEventListener('resize', resize);
        resize();
        draw();
    </script>
</body>
</html>
