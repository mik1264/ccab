<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Pendulum Chaos - CCAB</title>
    <meta name="description" content="Interactive triple pendulum simulation demonstrating chaotic behavior. Watch how tiny differences in initial conditions lead to dramatically different outcomes.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.5);
            color: #a78bfa;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(167, 139, 250, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(167, 139, 250, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 12px;
            color: #a78bfa;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(167, 139, 250, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            font-weight: 600;
            color: #c4b5fd;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(167, 139, 250, 0.2);
        }

        .control-group label {
            color: #a78bfa;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 90px;
            accent-color: #a78bfa;
        }

        .control-group span {
            color: #e0e0e0;
            font-size: 10px;
            margin-left: 6px;
        }

        button {
            background: rgba(167, 139, 250, 0.2);
            border: 1px solid rgba(167, 139, 250, 0.5);
            color: #a78bfa;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(167, 139, 250, 0.4);
        }

        .pendulum-selector {
            position: fixed;
            top: 80px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        .pendulum-selector button {
            font-size: 11px;
            padding: 8px 14px;
        }

        .pendulum-selector button.active {
            background: rgba(167, 139, 250, 0.5);
            border-color: #a78bfa;
        }

        #fps-display {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.5);
            color: #a78bfa;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="info">
        <h3>Triple Pendulum Chaos</h3>
        <div>Pendulums: <span id="num-pendulums">3</span></div>
        <div>Showing: <span id="trail-count">3</span> trails</div>
        <p>
            A triple pendulum exhibits chaotic behavior - tiny differences in starting positions
            lead to wildly different paths. Each colored trail starts with a slightly different angle.
        </p>
    </div>

    <div class="pendulum-selector">
        <button onclick="setNumPendulums(1)">Single</button>
        <button onclick="setNumPendulums(2)">Double</button>
        <button onclick="setNumPendulums(3)" class="active">Triple</button>
        <button onclick="setNumPendulums(4)">Quad</button>
    </div>

    <div id="fps-display">FPS: <span id="fps">60</span></div>

    <div id="controls">
        <div class="control-group">
            <label>Trail Count</label>
            <input type="range" id="trailCount" min="1" max="10" value="3">
            <span id="trailCountVal">3</span>
        </div>
        <div class="control-group">
            <label>Angle Diff (°)</label>
            <input type="range" id="angleDiff" min="0.001" max="5" step="0.001" value="0.1">
            <span id="angleDiffVal">0.1</span>
        </div>
        <div class="control-group">
            <label>Trail Length</label>
            <input type="range" id="trailLength" min="100" max="2000" value="500">
            <span id="trailLengthVal">500</span>
        </div>
        <div class="control-group">
            <label>Speed</label>
            <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1">
            <span id="speedVal">1x</span>
        </div>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="togglePause()">Pause</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
    // Triple (and n-tuple) Pendulum Simulation
    // Uses Lagrangian mechanics and RK4 integration
    // Demonstrates sensitive dependence on initial conditions (chaos)

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Configuration
    let config = {
        numPendulums: 3,      // Number of segments
        trailCount: 3,        // Number of parallel simulations
        angleDiff: 0.1,       // Angle difference between trails (degrees)
        trailLength: 500,     // Number of trail points to store
        speed: 1.0,           // Simulation speed multiplier
        g: 9.81,              // Gravity
        length: 1,            // Length of each segment (normalized)
        mass: 1               // Mass of each bob
    };

    let paused = false;
    let pendulumSystems = [];

    // Colors for different trails (rainbow gradient)
    const trailColors = [
        '#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff',
        '#5f27cd', '#00d2d3', '#ff9f43', '#1dd1a1', '#ee5a24'
    ];

    // Resize canvas
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // PendulumSystem class - handles physics for one n-tuple pendulum
    class PendulumSystem {
        constructor(numSegments, initialAngles, color) {
            this.n = numSegments;
            this.angles = [...initialAngles];
            this.angularVelocities = new Array(this.n).fill(0);
            this.lengths = new Array(this.n).fill(config.length);
            this.masses = new Array(this.n).fill(config.mass);
            this.color = color;
            this.trail = [];
        }

        // Get (x, y) positions of all bobs
        getPositions(scale, cx, cy) {
            const positions = [];
            let x = cx;
            let y = cy;

            for (let i = 0; i < this.n; i++) {
                x += this.lengths[i] * scale * Math.sin(this.angles[i]);
                y += this.lengths[i] * scale * Math.cos(this.angles[i]);
                positions.push({ x, y });
            }
            return positions;
        }

        // Compute angular accelerations using Lagrangian mechanics
        computeAccelerations() {
            const n = this.n;
            const theta = this.angles;
            const omega = this.angularVelocities;
            const m = this.masses;
            const L = this.lengths;
            const g = config.g;

            // For general n-pendulum, we solve: M * alpha = F
            // where M is the mass matrix and F is the force vector

            // Build mass matrix M and force vector F
            const M = [];
            const F = [];

            for (let i = 0; i < n; i++) {
                M[i] = new Array(n).fill(0);
                F[i] = 0;
            }

            // Calculate total mass from each bob to the end
            const totalMassFromI = [];
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = i; j < n; j++) {
                    sum += m[j];
                }
                totalMassFromI[i] = sum;
            }

            // Fill mass matrix
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const minIJ = Math.min(i, j);
                    const maxIJ = Math.max(i, j);
                    let massSum = 0;
                    for (let k = maxIJ; k < n; k++) {
                        massSum += m[k];
                    }
                    M[i][j] = massSum * L[i] * L[j] * Math.cos(theta[i] - theta[j]);
                }
            }

            // Fill force vector
            for (let i = 0; i < n; i++) {
                // Gravity term
                F[i] = -totalMassFromI[i] * g * L[i] * Math.sin(theta[i]);

                // Coriolis/centrifugal terms
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const minIJ = Math.min(i, j);
                        const maxIJ = Math.max(i, j);
                        let massSum = 0;
                        for (let k = maxIJ; k < n; k++) {
                            massSum += m[k];
                        }
                        F[i] -= massSum * L[i] * L[j] * omega[j] * omega[j] * Math.sin(theta[i] - theta[j]);
                    }
                }
            }

            // Solve M * alpha = F using Gaussian elimination
            const alpha = this.solveLinearSystem(M, F);
            return alpha;
        }

        // Gaussian elimination solver
        solveLinearSystem(A, b) {
            const n = b.length;
            const augmented = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                // Eliminate column
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }

            // Back substitution
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }

            return x;
        }

        // RK4 integration step
        step(dt) {
            const n = this.n;

            // State: [theta1, ..., thetan, omega1, ..., omegan]
            const getState = () => [...this.angles, ...this.angularVelocities];

            const setState = (state) => {
                for (let i = 0; i < n; i++) {
                    this.angles[i] = state[i];
                    this.angularVelocities[i] = state[n + i];
                }
            };

            const derivative = () => {
                const alpha = this.computeAccelerations();
                return [...this.angularVelocities, ...alpha];
            };

            const state0 = getState();

            // k1
            const k1 = derivative();

            // k2
            for (let i = 0; i < 2 * n; i++) {
                const newState = state0.map((s, j) => s + dt / 2 * k1[j]);
                setState(newState);
            }
            const k2 = derivative();

            // k3
            for (let i = 0; i < 2 * n; i++) {
                const newState = state0.map((s, j) => s + dt / 2 * k2[j]);
                setState(newState);
            }
            const k3 = derivative();

            // k4
            for (let i = 0; i < 2 * n; i++) {
                const newState = state0.map((s, j) => s + dt * k3[j]);
                setState(newState);
            }
            const k4 = derivative();

            // Combine
            const newState = state0.map((s, i) =>
                s + dt / 6 * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i])
            );
            setState(newState);
        }

        // Update trail
        updateTrail(scale, cx, cy) {
            const positions = this.getPositions(scale, cx, cy);
            const lastPos = positions[positions.length - 1];
            this.trail.push({ x: lastPos.x, y: lastPos.y });

            if (this.trail.length > config.trailLength) {
                this.trail.shift();
            }
        }

        // Draw the pendulum and its trail
        draw(ctx, scale, cx, cy) {
            const positions = this.getPositions(scale, cx, cy);

            // Draw trail
            if (this.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) {
                    const alpha = i / this.trail.length;
                    ctx.strokeStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = 1 + alpha;
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.stroke();
            }

            // Draw rods
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            for (const pos of positions) {
                ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // Draw bobs
            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 8 - i, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw pivot
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#666';
            ctx.fill();
        }
    }

    // Initialize simulation
    function initSimulation() {
        pendulumSystems = [];

        const baseAngle = Math.PI / 2 + 0.5; // Starting angle

        for (let i = 0; i < config.trailCount; i++) {
            const angleOffset = (i - (config.trailCount - 1) / 2) * (config.angleDiff * Math.PI / 180);
            const angles = new Array(config.numPendulums).fill(baseAngle + angleOffset);
            const color = trailColors[i % trailColors.length];
            pendulumSystems.push(new PendulumSystem(config.numPendulums, angles, color));
        }

        document.getElementById('num-pendulums').textContent = config.numPendulums;
        document.getElementById('trail-count').textContent = config.trailCount;
    }

    function setNumPendulums(n) {
        config.numPendulums = n;
        initSimulation();

        // Update button states
        document.querySelectorAll('.pendulum-selector button').forEach((btn, i) => {
            btn.classList.toggle('active', i + 1 === n);
        });
    }

    function resetSimulation() {
        initSimulation();
    }

    function togglePause() {
        paused = !paused;
    }

    // Setup controls
    function setupControls() {
        document.getElementById('trailCount').addEventListener('input', (e) => {
            config.trailCount = parseInt(e.target.value);
            document.getElementById('trailCountVal').textContent = config.trailCount;
            initSimulation();
        });

        document.getElementById('angleDiff').addEventListener('input', (e) => {
            config.angleDiff = parseFloat(e.target.value);
            document.getElementById('angleDiffVal').textContent = config.angleDiff.toFixed(3);
        });

        document.getElementById('trailLength').addEventListener('input', (e) => {
            config.trailLength = parseInt(e.target.value);
            document.getElementById('trailLengthVal').textContent = config.trailLength;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = config.speed.toFixed(1) + 'x';
        });
    }

    // Animation loop
    let lastTime = 0;
    let frameCount = 0;
    let fpsTime = 0;

    function animate(currentTime) {
        // FPS counter
        frameCount++;
        if (currentTime - fpsTime > 1000) {
            document.getElementById('fps').textContent = frameCount;
            frameCount = 0;
            fpsTime = currentTime;
        }

        const dt = Math.min((currentTime - lastTime) / 1000, 0.1) * config.speed;
        lastTime = currentTime;

        // Clear canvas
        ctx.fillStyle = 'rgba(15, 12, 41, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cx = canvas.width / 2;
        const cy = canvas.height * 0.35;
        const scale = Math.min(canvas.width, canvas.height) * 0.15;

        if (!paused) {
            // Physics simulation (multiple sub-steps for stability)
            const subSteps = 4;
            const subDt = dt / subSteps;
            for (let step = 0; step < subSteps; step++) {
                for (const system of pendulumSystems) {
                    system.step(subDt);
                }
            }

            // Update trails
            for (const system of pendulumSystems) {
                system.updateTrail(scale, cx, cy);
            }
        }

        // Draw all pendulums
        for (const system of pendulumSystems) {
            system.draw(ctx, scale, cx, cy);
        }

        requestAnimationFrame(animate);
    }

    // Start
    setupControls();
    initSimulation();
    requestAnimationFrame(animate);
    </script>
</body>
</html>
