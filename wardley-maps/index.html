<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wardley Map Builder for Aviation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ── Top Bar ───────────────────────────────────── */
        .top-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            z-index: 100;
            flex-shrink: 0;
        }
        .back-link {
            color: #8A9A5B;
            text-decoration: none;
            font-weight: 500;
            font-size: 0.85rem;
            transition: color 0.2s;
        }
        .back-link:hover { color: #DDA15E; }
        .top-bar h1 {
            font-size: 1rem;
            font-weight: 600;
            color: #e6edf3;
            flex: 1;
        }
        .top-bar h1 span { color: #8A9A5B; font-weight: 400; }

        .toolbar-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .toolbar-sep {
            width: 1px;
            height: 20px;
            background: #30363d;
            margin: 0 4px;
        }

        .btn {
            padding: 5px 12px;
            border: 1px solid #30363d;
            background: #21262d;
            color: #c9d1d9;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .btn:hover { background: #30363d; border-color: #8b949e; }
        .btn.active { background: #388bfd22; border-color: #388bfd; color: #58a6ff; }
        .btn.heatmap-active { background: #da363422; border-color: #f0883e; color: #f0883e; }
        .btn.cluster-active { background: #388bfd22; border-color: #a371f7; color: #a371f7; }
        .btn-accent {
            background: #606C38;
            border-color: #8A9A5B;
            color: #FEFAE0;
        }
        .btn-accent:hover { background: #8A9A5B; }

        /* ── Layout ────────────────────────────────────── */
        .app-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ── Left Sidebar ──────────────────────────────── */
        .sidebar {
            width: 260px;
            background: #161b22;
            border-right: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow-y: auto;
        }
        .sidebar-section {
            border-bottom: 1px solid #30363d;
        }
        .sidebar-header {
            padding: 10px 14px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #8b949e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        .sidebar-header:hover { color: #c9d1d9; }
        .sidebar-header .chevron {
            transition: transform 0.2s;
            font-size: 0.65rem;
        }
        .sidebar-header.collapsed .chevron { transform: rotate(-90deg); }
        .sidebar-body { padding: 6px 10px 10px; }
        .sidebar-header.collapsed + .sidebar-body { display: none; }

        .domain-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 7px 10px;
            border: 1px solid transparent;
            background: transparent;
            color: #c9d1d9;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            margin-bottom: 2px;
        }
        .domain-btn:hover { background: #21262d; }
        .domain-btn.active { background: #21262d; border-color: #30363d; }
        .domain-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .domain-btn .count {
            margin-left: auto;
            font-size: 0.7rem;
            color: #8b949e;
            background: #21262d;
            padding: 1px 6px;
            border-radius: 10px;
        }

        .component-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 6px;
        }
        .component-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .component-item:hover { background: #21262d; }
        .component-item .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* ── Map Canvas Area ───────────────────────────── */
        .map-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0d1117;
        }
        #mapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: default;
        }

        /* ── Right Panel (Detail/Annotation) ───────────── */
        .detail-panel {
            width: 300px;
            background: #161b22;
            border-left: 1px solid #30363d;
            display: none;
            flex-direction: column;
            flex-shrink: 0;
            overflow-y: auto;
        }
        .detail-panel.open { display: flex; }
        .detail-header {
            padding: 12px 14px;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .detail-header h3 {
            font-size: 0.9rem;
            color: #e6edf3;
        }
        .detail-close {
            background: none;
            border: none;
            color: #8b949e;
            cursor: pointer;
            font-size: 1.1rem;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .detail-close:hover { background: #21262d; color: #c9d1d9; }
        .detail-body { padding: 14px; flex: 1; }

        .field-group { margin-bottom: 14px; }
        .field-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: #8b949e;
            margin-bottom: 4px;
        }
        .field-value {
            font-size: 0.85rem;
            color: #e6edf3;
        }
        .field-input {
            width: 100%;
            padding: 6px 10px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
        }
        .field-input:focus {
            outline: none;
            border-color: #388bfd;
        }
        textarea.field-input { min-height: 80px; }

        .evolution-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .delete-btn {
            width: 100%;
            padding: 8px;
            background: #da363433;
            border: 1px solid #da3634;
            color: #f85149;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-top: 10px;
        }
        .delete-btn:hover { background: #da363455; }

        /* ── Competitor Legend ──────────────────────────── */
        .competitor-legend {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: rgba(22, 27, 34, 0.92);
            backdrop-filter: blur(10px);
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 12px 16px;
            font-size: 0.75rem;
            z-index: 50;
            display: none;
        }
        .competitor-legend.visible { display: block; }
        .competitor-legend h4 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #8b949e;
            margin-bottom: 8px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        .legend-marker {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 2px solid;
            opacity: 0.8;
        }

        /* ── Map Legend ─────────────────────────────────── */
        .map-legend {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(22, 27, 34, 0.92);
            backdrop-filter: blur(10px);
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 12px 16px;
            font-size: 0.75rem;
            z-index: 50;
            display: none;
        }
        .map-legend.visible { display: block; }
        .map-legend h4 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #8b949e;
            margin-bottom: 8px;
        }

        /* ── Toast ─────────────────────────────────────── */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(60px);
            background: #161b22;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.85rem;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* ── Context Menu ──────────────────────────────── */
        .context-menu {
            position: fixed;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 4px;
            z-index: 200;
            display: none;
            min-width: 160px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        .context-menu.visible { display: block; }
        .context-item {
            display: block;
            width: 100%;
            padding: 6px 12px;
            background: none;
            border: none;
            color: #c9d1d9;
            font-size: 0.8rem;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
        }
        .context-item:hover { background: #21262d; }
        .context-item.danger { color: #f85149; }
        .context-item.danger:hover { background: #da363422; }
        .context-sep {
            height: 1px;
            background: #30363d;
            margin: 4px 0;
        }

        /* ── Modal ──────────────────────────────────────── */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.visible { display: flex; }
        .modal {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 24px;
            min-width: 360px;
            max-width: 500px;
        }
        .modal h3 {
            font-size: 1rem;
            color: #e6edf3;
            margin-bottom: 16px;
        }
        .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }

        /* ── Link Mode ────────────────────────────────── */
        .btn.link-active {
            background: #da363433;
            border-color: #f0883e;
            color: #f0883e;
            box-shadow: 0 0 8px rgba(240, 136, 62, 0.25);
        }
        .btn.link-active:hover {
            background: #da363455;
        }
        .link-mode-indicator {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(240, 136, 62, 0.15);
            border: 1px solid #f0883e;
            color: #f0883e;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.78rem;
            font-weight: 500;
            z-index: 60;
            display: none;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }
        .link-mode-indicator.visible {
            display: block;
        }

        /* ── Timeline Bar ─── */
        .timeline-bar { position:absolute; bottom:0; left:0; right:0; height:36px; background:rgba(22,27,34,0.95); backdrop-filter:blur(10px); border-top:1px solid #30363d; display:none; align-items:center; padding:0 16px; gap:8px; z-index:60; }
        .timeline-bar.visible { display:flex; }
        .timeline-track { flex:1; height:100%; position:relative; display:flex; align-items:center; }
        .timeline-line { position:absolute; left:0; right:0; top:50%; height:2px; background:#30363d; transform:translateY(-50%); }
        .timeline-dot { position:relative; width:14px; height:14px; border-radius:50%; background:#606C38; border:2px solid #8A9A5B; cursor:pointer; z-index:1; flex-shrink:0; transition:all 0.15s; }
        .timeline-dot:hover { transform:scale(1.3); background:#8A9A5B; border-color:#DDA15E; }
        .timeline-dot.active { background:#DDA15E; border-color:#FEFAE0; box-shadow:0 0 8px rgba(221,161,94,0.5); }
        .timeline-tooltip { position:absolute; bottom:100%; left:50%; transform:translateX(-50%); background:#161b22; border:1px solid #30363d; border-radius:6px; padding:6px 10px; font-size:0.72rem; color:#c9d1d9; white-space:nowrap; pointer-events:none; opacity:0; transition:opacity 0.15s; z-index:70; margin-bottom:6px; }
        .timeline-dot:hover .timeline-tooltip { opacity:1; }
        .timeline-tooltip .snap-date { color:#8b949e; font-size:0.65rem; display:block; margin-top:2px; }
        .timeline-label { font-size:0.7rem; color:#8b949e; flex-shrink:0; user-select:none; }
        .snapshot-modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:310; display:none; align-items:center; justify-content:center; }
        .snapshot-modal-overlay.visible { display:flex; }

        /* ── Scrollbar ─────────────────────────────────── */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #484f58; }

        /* ── Theme System ─────────────────────────────────── */
        :root {
            --theme-bg: #0d1117;
            --theme-surface: #161b22;
            --theme-surface-hover: #21262d;
            --theme-border: #30363d;
            --theme-border-strong: #484f58;
            --theme-text: #c9d1d9;
            --theme-text-bright: #e6edf3;
            --theme-text-muted: #8b949e;
            --theme-text-faint: #6e7681;
            --theme-canvas-bg: #0d1117;
            --theme-grid: #21262d;
            --theme-grid-strong: #30363d;
            --theme-input-bg: #0d1117;
            --theme-overlay-bg: rgba(22, 27, 34, 0.92);
            --theme-modal-bg: rgba(0,0,0,0.6);
            --theme-shadow: rgba(0,0,0,0.4);
            --theme-scrollbar: #30363d;
            --theme-scrollbar-hover: #484f58;
        }
        body { background: var(--theme-bg); color: var(--theme-text); }
        .top-bar { background: var(--theme-surface); border-bottom-color: var(--theme-border); }
        .top-bar h1 { color: var(--theme-text-bright); }
        .toolbar-sep { background: var(--theme-border); }
        .btn { border-color: var(--theme-border); background: var(--theme-surface-hover); color: var(--theme-text); }
        .btn:hover { background: var(--theme-border); border-color: var(--theme-text-muted); }
        .sidebar { background: var(--theme-surface); border-right-color: var(--theme-border); }
        .sidebar-section { border-bottom-color: var(--theme-border); }
        .sidebar-header { color: var(--theme-text-muted); }
        .sidebar-header:hover { color: var(--theme-text); }
        .domain-btn { color: var(--theme-text); }
        .domain-btn:hover { background: var(--theme-surface-hover); }
        .domain-btn.active { background: var(--theme-surface-hover); border-color: var(--theme-border); }
        .domain-btn .count { color: var(--theme-text-muted); background: var(--theme-surface-hover); }
        .component-item:hover { background: var(--theme-surface-hover); }
        .map-area { background: var(--theme-canvas-bg); }
        .detail-panel { background: var(--theme-surface); border-left-color: var(--theme-border); }
        .detail-header { border-bottom-color: var(--theme-border); }
        .detail-header h3 { color: var(--theme-text-bright); }
        .detail-close { color: var(--theme-text-muted); }
        .detail-close:hover { background: var(--theme-surface-hover); color: var(--theme-text); }
        .field-label { color: var(--theme-text-muted); }
        .field-value { color: var(--theme-text-bright); }
        .field-input { background: var(--theme-input-bg); border-color: var(--theme-border); color: var(--theme-text); }
        .context-menu { background: var(--theme-surface); border-color: var(--theme-border); box-shadow: 0 8px 24px var(--theme-shadow); }
        .context-item { color: var(--theme-text); }
        .context-item:hover { background: var(--theme-surface-hover); }
        .context-sep { background: var(--theme-border); }
        .modal-overlay { background: var(--theme-modal-bg); }
        .modal { background: var(--theme-surface); border-color: var(--theme-border); }
        .modal h3 { color: var(--theme-text-bright); }
        .toast { background: var(--theme-surface); border-color: var(--theme-border); color: var(--theme-text); }
        .map-legend, .competitor-legend { background: var(--theme-overlay-bg); border-color: var(--theme-border); }
        .map-legend h4, .competitor-legend h4 { color: var(--theme-text-muted); }
        .theme-select {
            padding: 4px 8px;
            border: 1px solid var(--theme-border);
            background: var(--theme-surface-hover);
            color: var(--theme-text);
            border-radius: 6px;
            font-size: 0.78rem;
            cursor: pointer;
            font-family: inherit;
        }
        .theme-select:hover { border-color: var(--theme-text-muted); }
        .theme-select:focus { outline: none; border-color: #388bfd; }
        body.theme-presentation .sidebar { display: none !important; }
        body.theme-presentation .detail-panel { display: none !important; }
        body.theme-presentation .top-bar { padding: 4px 12px; }
        body.theme-presentation .top-bar h1 { font-size: 1.2rem; }
        body.theme-presentation .map-area { flex: 1; }

        /* ── Search & Filter ──────────────────────────────── */
        .search-filter-bar {
            padding: 0 10px 8px;
        }
        .search-input-wrap {
            position: relative;
            margin-bottom: 6px;
        }
        .search-input-wrap .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #6e7681;
            font-size: 0.75rem;
            pointer-events: none;
        }
        .search-input-wrap .search-clear {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6e7681;
            font-size: 0.85rem;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            display: none;
        }
        .search-input-wrap .search-clear:hover {
            color: #c9d1d9;
            background: #21262d;
        }
        .search-input-wrap .search-clear.visible {
            display: block;
        }
        #searchInput {
            width: 100%;
            padding: 6px 26px 6px 28px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 0.8rem;
            font-family: inherit;
        }
        #searchInput:focus {
            outline: none;
            border-color: #388bfd;
        }
        #searchInput::placeholder {
            color: #484f58;
        }
        .evo-filter-row {
            display: flex;
            gap: 4px;
        }
        .evo-filter-btn {
            flex: 1;
            padding: 3px 0;
            border: 1px solid #30363d;
            background: #21262d;
            color: #8b949e;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }
        .evo-filter-btn:hover {
            border-color: #8b949e;
            color: #c9d1d9;
        }
        .evo-filter-btn.active {
            color: #fff;
        }
        .evo-filter-btn[data-stage="0"].active {
            background: #f0883e33;
            border-color: #f0883e;
            color: #f0883e;
        }
        .evo-filter-btn[data-stage="1"].active {
            background: #d2992233;
            border-color: #d29922;
            color: #d29922;
        }
        .evo-filter-btn[data-stage="2"].active {
            background: #3fb95033;
            border-color: #3fb950;
            color: #3fb950;
        }
        .evo-filter-btn[data-stage="3"].active {
            background: #58a6ff33;
            border-color: #58a6ff;
            color: #58a6ff;
        }
        .filter-active-hint {
            font-size: 0.65rem;
            color: #6e7681;
            text-align: center;
            margin-top: 4px;
            display: none;
        }
        .filter-active-hint.visible {
            display: block;
        }

        /* ── Minimap ──────────────────────────────────────── */
        .minimap-container {
            position: absolute;
            bottom: 16px;
            left: 16px;
            width: 180px;
            height: 130px;
            background: rgba(22, 27, 34, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid #30363d;
            border-radius: 8px;
            z-index: 50;
            overflow: hidden;
            cursor: crosshair;
            display: none;
        }
        .minimap-container.visible {
            display: block;
        }
        .minimap-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>

<!-- Top Toolbar -->
<div class="top-bar">
    <a href="../index.html" class="back-link">← Gallery</a>
    <h1>Wardley Map Builder <span>/ Aviation</span></h1>
    <div class="toolbar-group">
        <button class="btn" id="btnUndo" title="Undo (Ctrl+Z)">↩ Undo</button>
        <button class="btn" id="btnRedo" title="Redo (Ctrl+Y)">↪ Redo</button>
    </div>
    <div class="toolbar-sep"></div>
    <div class="toolbar-group">
        <button class="btn" id="btnAddNode" title="Add component (A)">+ Component</button>
        <button class="btn" id="btnLink" title="Link mode (K) — drag between nodes to connect, click lines to remove">Link</button>
        <button class="btn" id="btnCompetitors" title="Toggle competitor overlay (C)">Competitors</button>
        <button class="btn" id="btnLegend" title="Toggle legend (L)">Legend</button>
        <button class="btn" id="btnHeatmap" title="Toggle heatmap overlay (H)">Heatmap</button>
        <button class="btn" id="btnCluster" title="Toggle cluster hulls (J)">Clusters</button>
    </div>
    <div class="toolbar-sep"></div>
    <div class="toolbar-group">
        <button class="btn" id="btnSave" title="Save to browser (Ctrl+S)">Save</button>
        <button class="btn" id="btnLoad" title="Load from browser">Load</button>
        <button class="btn" id="btnExportPNG" title="Export enhanced PNG (2x)">PNG</button>
        <button class="btn" id="btnCopyClipboard" title="Copy map to clipboard">Copy</button>
        <button class="btn" id="btnExportSVG" title="Export as SVG">SVG</button>
        <button class="btn" id="btnExportCSV" title="Export as CSV">CSV</button>
        <button class="btn" id="btnImportJSON" title="Import map JSON">Import</button>
        <button class="btn btn-accent" id="btnExportDoc" title="Export strategy document">Strategy Doc</button>
    </div>
    <div class="toolbar-sep"></div>
    <div class="toolbar-group">
        <button class="btn" id="btnForceLayout" title="Force-directed auto layout (Shift+F)">Auto Layout</button>
        <button class="btn" id="btnSpread" title="Spread components evenly by stage">Spread</button>
    </div>
    <div class="toolbar-sep"></div>
    <div class="toolbar-group">
        <button class="btn" id="btnSnapshot" title="Save snapshot (T)">Snapshot</button>
        <button class="btn" id="btnCompare" title="Compare with previous snapshot">Compare</button>
    </div>
    <div class="toolbar-sep"></div>
    <div class="toolbar-group">
        <select class="theme-select" id="themeSelect" title="Theme (T)">
            <option value="dark">Dark</option>
            <option value="light">Light</option>
            <option value="presentation">Presentation</option>
            <option value="print">Print</option>
        </select>
    </div>
</div>

<!-- Main Layout -->
<div class="app-layout">

    <!-- Left Sidebar -->
    <div class="sidebar">
        <!-- Domains -->
        <div class="sidebar-section">
            <div class="sidebar-header" data-section="domains">
                Aviation Domains <span class="chevron">▼</span>
            </div>
            <div class="sidebar-body" id="domainList"></div>
        </div>

        <!-- Components -->
        <div class="sidebar-section">
            <div class="sidebar-header" data-section="components">
                Components on Map <span class="chevron">▼</span>
            </div>
            <div class="sidebar-body">
                <div class="search-filter-bar">
                    <div class="search-input-wrap">
                        <span class="search-icon">&#x1F50D;</span>
                        <input type="text" id="searchInput" class="field-input" placeholder="Search components… ( / )" style="padding-left:28px;padding-right:26px;font-size:0.8rem">
                        <button class="search-clear" id="searchClear" title="Clear search">&#x2715;</button>
                    </div>
                    <div class="evo-filter-row">
                        <button class="evo-filter-btn" data-stage="0" title="Genesis (0-17%)">G</button>
                        <button class="evo-filter-btn" data-stage="1" title="Custom Built (17-40%)">C</button>
                        <button class="evo-filter-btn" data-stage="2" title="Product / Rental (40-70%)">P</button>
                        <button class="evo-filter-btn" data-stage="3" title="Commodity / Utility (70-100%)">U</button>
                    </div>
                    <div class="filter-active-hint" id="filterHint">Filtering active &mdash; dimmed nodes on map</div>
                </div>
                <div class="component-list" id="componentList"></div>
            </div>
        </div>

        <!-- Quick Actions -->
        <div class="sidebar-section">
            <div class="sidebar-header" data-section="actions">
                Quick Actions <span class="chevron">▼</span>
            </div>
            <div class="sidebar-body">
                <button class="domain-btn" id="btnLoadAll">
                    <span class="domain-dot" style="background:linear-gradient(135deg,#8B4513,#2E86AB,#A23B72)"></span>
                    Load All Domains
                </button>
                <button class="domain-btn" id="btnClearMap">
                    <span class="domain-dot" style="background:#f85149"></span>
                    Clear Map
                </button>
                <button class="domain-btn" id="btnResetPositions">
                    <span class="domain-dot" style="background:#8b949e"></span>
                    Reset Positions
                </button>
                <button class="domain-btn" id="btnSnapGrid">
                    <span class="domain-dot" style="background:#58a6ff"></span>
                    <span id="snapLabel">Snap to Grid: Off</span>
                </button>
            </div>
        </div>

        <!-- Keyboard Shortcuts -->
        <div class="sidebar-section">
            <div class="sidebar-header collapsed" data-section="shortcuts">
                Keyboard Shortcuts <span class="chevron">▼</span>
            </div>
            <div class="sidebar-body" style="font-size:0.72rem; color:#8b949e; line-height:1.8">
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">A</kbd> Add component</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">C</kbd> Toggle competitors</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">L</kbd> Toggle legend</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">K</kbd> Toggle link mode</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">G</kbd> Toggle snap-to-grid</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">T</kbd> Cycle theme</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">H</kbd> Toggle heatmap</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">J</kbd> Toggle clusters</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Del</kbd> Delete selected</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Esc</kbd> Deselect / close panel</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Ctrl+Z</kbd> Undo</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Ctrl+S</kbd> Save</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">1-6</kbd> Load domain</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Scroll</kbd> Zoom</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Shift+F</kbd> Auto layout</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">Middle-drag</kbd> Pan</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">T</kbd> Save snapshot</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">/</kbd> Search components</div>
                <div><kbd style="background:#21262d;padding:1px 5px;border-radius:3px;border:1px solid #30363d">M</kbd> Toggle minimap</div>
            </div>
        </div>
    </div>

    <!-- Map Canvas -->
    <div class="map-area" id="mapArea">
        <canvas id="mapCanvas"></canvas>

        <!-- Link Mode Indicator -->
        <div class="link-mode-indicator" id="linkModeIndicator">Link Mode: drag node-to-node to connect, click line to remove</div>

        <!-- Map Legend Overlay -->
        <div class="map-legend" id="mapLegend">
            <h4>Evolution Stages</h4>
            <div style="margin-bottom:8px;color:#58a6ff">← Less evolved &nbsp;&nbsp; More evolved →</div>
            <div class="legend-item"><span style="color:#f0883e">■</span> Genesis — novel, uncertain</div>
            <div class="legend-item"><span style="color:#d29922">■</span> Custom Built — emerging</div>
            <div class="legend-item"><span style="color:#3fb950">■</span> Product / Rental — maturing</div>
            <div class="legend-item"><span style="color:#58a6ff">■</span> Commodity / Utility — standard</div>
            <div style="margin-top:10px"><h4>Value Chain</h4></div>
            <div>↑ Visible to user</div>
            <div>↓ Invisible infrastructure</div>
            <div style="margin-top:10px"><h4>Interactions</h4></div>
            <div>Click node → select &amp; edit</div>
            <div>Drag node → reposition</div>
            <div>Right-click → context menu</div>
            <div>Double-click map → add component</div>
        </div>

        <!-- Competitor Legend -->
        <div class="competitor-legend" id="competitorLegend">
            <h4>Competitor Archetypes</h4>
            <div class="legend-item">
                <span class="legend-marker" style="background:rgba(56,139,253,0.15);border-color:#58a6ff"></span>
                Legacy / Full-Service
            </div>
            <div class="legend-item">
                <span class="legend-marker" style="background:rgba(63,185,80,0.15);border-color:#3fb950"></span>
                Low-Cost Carrier (LCC)
            </div>
            <div class="legend-item">
                <span class="legend-marker" style="background:rgba(210,153,34,0.15);border-color:#d29922"></span>
                Ultra-Low-Cost (ULCC)
            </div>
        </div>
        <!-- Minimap Overlay -->
        <div class="minimap-container" id="minimapContainer">
            <canvas id="minimapCanvas"></canvas>
        </div>
        <!-- Timeline Bar -->
        <div class="timeline-bar" id="timelineBar">
            <span class="timeline-label">Snapshots</span>
            <div class="timeline-track" id="timelineTrack">
                <div class="timeline-line"></div>
            </div>
        </div>
    </div>

    <!-- Right Detail Panel -->
    <div class="detail-panel" id="detailPanel">
        <div class="detail-header">
            <h3 id="detailTitle">Component</h3>
            <button class="detail-close" id="detailClose">✕</button>
        </div>
        <div class="detail-body" id="detailBody"></div>
    </div>
</div>

<!-- Context Menu -->
<div class="context-menu" id="contextMenu">
    <button class="context-item" data-action="edit">Edit details…</button>
    <button class="context-item" data-action="annotate">Add annotation…</button>
    <button class="context-item" data-action="arrow">Add movement arrow →</button>
    <div class="context-sep"></div>
    <button class="context-item" data-action="duplicate">Duplicate</button>
    <button class="context-item danger" data-action="delete">Delete</button>
</div>

<!-- Add Component Modal -->
<div class="modal-overlay" id="addModal">
    <div class="modal">
        <h3>Add Component</h3>
        <div class="field-group">
            <div class="field-label">Name</div>
            <input class="field-input" id="addName" placeholder="Component name" autofocus>
        </div>
        <div class="field-group">
            <div class="field-label">Domain</div>
            <select class="field-input" id="addDomain"></select>
        </div>
        <div class="modal-actions">
            <button class="btn" id="addCancel">Cancel</button>
            <button class="btn btn-accent" id="addConfirm">Add</button>
        </div>
    </div>
</div>

<!-- Snapshot Name Modal -->
<div class="snapshot-modal-overlay" id="snapshotModal">
    <div class="modal">
        <h3>Save Snapshot</h3>
        <div class="field-group">
            <div class="field-label">Snapshot Name</div>
            <input class="field-input" id="snapshotName" placeholder="e.g. Baseline, After reorg..." autofocus>
        </div>
        <div style="font-size:0.75rem;color:#8b949e;margin-top:-8px;margin-bottom:12px" id="snapshotCount"></div>
        <div class="modal-actions">
            <button class="btn" id="snapshotCancel">Cancel</button>
            <button class="btn btn-accent" id="snapshotConfirm">Save Snapshot</button>
        </div>
    </div>
</div>

<!-- Hidden file input for JSON import -->
<input type="file" id="jsonFileInput" accept=".json" style="display:none">

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ══════════════════════════════════════════════════════════════
// WARDLEY MAP BUILDER FOR AVIATION
// ══════════════════════════════════════════════════════════════

(function() {
'use strict';

// ── Domain Colors & Config ────────────────────────────────
const DOMAIN_COLORS = {
    maintenance: '#CD853F',
    crew:        '#2E86AB',
    scheduling:  '#A23B72',
    revenue:     '#F18F01',
    flight_ops:  '#C73E1D',
    passenger:   '#9B59B6'
};

const DOMAIN_LABELS = {
    maintenance: 'Maintenance / MRO',
    crew:        'Crew Management',
    scheduling:  'Scheduling / Network',
    revenue:     'Revenue / Pricing',
    flight_ops:  'Flight Operations',
    passenger:   'Passenger Experience'
};

const EVOLUTION_STAGES = [
    { label: 'Genesis',          x0: 0,    x1: 0.17, color: '#f0883e' },
    { label: 'Custom Built',     x0: 0.17, x1: 0.40, color: '#d29922' },
    { label: 'Product / Rental', x0: 0.40, x1: 0.70, color: '#3fb950' },
    { label: 'Commodity',        x0: 0.70, x1: 1.0,  color: '#58a6ff' }
];

// ── Aviation Components Data ──────────────────────────────
const AVIATION_COMPONENTS = [
    // === Maintenance / MRO ===
    { id: 'mro_predictive',    name: 'Predictive Maintenance AI',   domain: 'maintenance', x: 0.12, y: 0.35, deps: ['mro_sensor_data','mro_data_analytics'], desc: 'ML models predicting component failures before they occur. Still emerging, high strategic value.' },
    { id: 'mro_digital_twin',  name: 'Digital Twin Platform',       domain: 'maintenance', x: 0.20, y: 0.40, deps: ['mro_sensor_data'], desc: 'Virtual replica of aircraft for simulation and monitoring. Custom-built for each fleet type.' },
    { id: 'mro_sensor_data',   name: 'IoT Sensor Networks',         domain: 'maintenance', x: 0.52, y: 0.20, deps: [], desc: 'On-aircraft sensors for engine, airframe, and systems monitoring. Increasingly productized.' },
    { id: 'mro_parts_mgmt',    name: 'Parts Inventory System',      domain: 'maintenance', x: 0.62, y: 0.30, deps: ['mro_supply_chain'], desc: 'Rotable and expendable parts tracking across stations.' },
    { id: 'mro_supply_chain',  name: 'MRO Supply Chain',            domain: 'maintenance', x: 0.55, y: 0.15, deps: [], desc: 'Global network of parts suppliers, repair shops, and logistics.' },
    { id: 'mro_data_analytics',name: 'Maintenance Analytics',       domain: 'maintenance', x: 0.35, y: 0.25, deps: [], desc: 'Statistical analysis of maintenance events, MTBF, reliability trends.' },
    { id: 'mro_compliance',    name: 'Regulatory Compliance',       domain: 'maintenance', x: 0.75, y: 0.10, deps: [], desc: 'FAA/EASA airworthiness directives, service bulletins, AD tracking. Highly standardized.' },
    { id: 'mro_line_maint',    name: 'Line Maintenance Ops',        domain: 'maintenance', x: 0.58, y: 0.45, deps: ['mro_parts_mgmt','mro_compliance'], desc: 'Day-to-day aircraft checks between flights (transit, daily, weekly).' },

    // === Crew Management ===
    { id: 'crew_pairing',      name: 'Crew Pairing Optimizer',      domain: 'crew', x: 0.30, y: 0.55, deps: ['crew_rules_engine','crew_bidding'], desc: 'Optimization algorithms to build efficient crew pairings. Mathematically complex, custom-built.' },
    { id: 'crew_rostering',    name: 'Crew Rostering',              domain: 'crew', x: 0.42, y: 0.60, deps: ['crew_pairing','crew_rules_engine'], desc: 'Monthly roster assignment balancing seniority, preferences, legality.' },
    { id: 'crew_rules_engine', name: 'Fatigue & Legality Rules',    domain: 'crew', x: 0.65, y: 0.40, deps: [], desc: 'FAR 117/EASA FTL compliance engine. Regulatory requirement, well-understood.' },
    { id: 'crew_training',     name: 'Training & Certification',    domain: 'crew', x: 0.55, y: 0.50, deps: [], desc: 'Type ratings, recurrent training, qualification tracking.' },
    { id: 'crew_bidding',      name: 'Crew Bidding System',         domain: 'crew', x: 0.48, y: 0.65, deps: [], desc: 'Preferential bidding for schedules. Increasingly a product/SaaS offering.' },
    { id: 'crew_disruption',   name: 'Crew Recovery & Disruption',  domain: 'crew', x: 0.22, y: 0.52, deps: ['crew_rostering','crew_rules_engine'], desc: 'Real-time crew reassignment during irregular operations. Still heavily custom.' },

    // === Scheduling / Network ===
    { id: 'sched_network',     name: 'Network Planning',            domain: 'scheduling', x: 0.28, y: 0.85, deps: ['sched_demand','sched_slots'], desc: 'Strategic route network design. High-value, highly custom competitive differentiator.' },
    { id: 'sched_demand',      name: 'Demand Forecasting',          domain: 'scheduling', x: 0.32, y: 0.72, deps: [], desc: 'Predicting passenger demand by market. Increasingly AI-driven.' },
    { id: 'sched_fleet_assign',name: 'Fleet Assignment',            domain: 'scheduling', x: 0.38, y: 0.78, deps: ['sched_network'], desc: 'Matching aircraft types to routes for optimal economics.' },
    { id: 'sched_slots',       name: 'Slot Management',             domain: 'scheduling', x: 0.70, y: 0.68, deps: [], desc: 'Airport slot allocation and compliance. Governed by IATA WSG, commoditized.' },
    { id: 'sched_codeshare',   name: 'Codeshare / Alliance',        domain: 'scheduling', x: 0.52, y: 0.82, deps: ['sched_network'], desc: 'Interline and codeshare agreements. Product-level maturity.' },
    { id: 'sched_tail_assign', name: 'Tail Assignment',             domain: 'scheduling', x: 0.35, y: 0.70, deps: ['sched_fleet_assign','mro_line_maint'], desc: 'Assigning specific aircraft to flights considering maintenance needs.' },

    // === Revenue / Pricing ===
    { id: 'rev_dynamic',       name: 'Dynamic Pricing Engine',      domain: 'revenue', x: 0.25, y: 0.90, deps: ['rev_demand_model','rev_fare_classes'], desc: 'Real-time price optimization using willingness-to-pay models. Key differentiator.' },
    { id: 'rev_demand_model',  name: 'Revenue Demand Models',       domain: 'revenue', x: 0.30, y: 0.75, deps: [], desc: 'Econometric models of price elasticity and competitive response.' },
    { id: 'rev_fare_classes',  name: 'Fare Class Structure',        domain: 'revenue', x: 0.60, y: 0.80, deps: [], desc: 'Booking class hierarchy (Y, B, M, etc.). Industry standard pattern.' },
    { id: 'rev_ancillary',     name: 'Ancillary Revenue',           domain: 'revenue', x: 0.42, y: 0.92, deps: [], desc: 'Baggage, seats, upgrades, bundles. Rapidly evolving product space.' },
    { id: 'rev_distribution',  name: 'Distribution (GDS/NDC)',      domain: 'revenue', x: 0.72, y: 0.65, deps: [], desc: 'GDS connections (Amadeus, Sabre) and NDC direct channels. Commodity infrastructure.' },
    { id: 'rev_loyalty',       name: 'Loyalty / FFP',               domain: 'revenue', x: 0.50, y: 0.88, deps: [], desc: 'Frequent flyer programs and partner ecosystems. Major revenue center.' },

    // === Flight Operations ===
    { id: 'ops_dispatch',      name: 'Flight Dispatch',             domain: 'flight_ops', x: 0.55, y: 0.55, deps: ['ops_weather','ops_fuel','ops_notam'], desc: 'Operational flight planning, release, and monitoring.' },
    { id: 'ops_weather',       name: 'Weather Intelligence',        domain: 'flight_ops', x: 0.60, y: 0.30, deps: [], desc: 'Aviation weather data integration (METAR, TAF, SIGMET). Productized services.' },
    { id: 'ops_fuel',          name: 'Fuel Optimization',           domain: 'flight_ops', x: 0.35, y: 0.42, deps: ['ops_weather'], desc: 'Fuel uplift optimization considering tankering, alternate planning. Custom analytics.' },
    { id: 'ops_notam',         name: 'NOTAM Processing',            domain: 'flight_ops', x: 0.78, y: 0.25, deps: [], desc: 'Notices to airmen — parsing and filtering. Mostly automated commodity.' },
    { id: 'ops_ground',        name: 'Ground Operations',           domain: 'flight_ops', x: 0.58, y: 0.48, deps: [], desc: 'Gate management, turnaround coordination, GSE scheduling.' },
    { id: 'ops_disruption',    name: 'IROPS Recovery Engine',       domain: 'flight_ops', x: 0.15, y: 0.58, deps: ['ops_dispatch','crew_disruption','sched_tail_assign'], desc: 'Integrated irregular operations recovery. The holy grail — still mostly genesis/custom.' },

    // === Passenger Experience ===
    { id: 'pax_booking',       name: 'Booking Platform',            domain: 'passenger', x: 0.65, y: 0.95, deps: ['rev_distribution','rev_fare_classes'], desc: 'Online booking engine. Mature product, many vendor solutions.' },
    { id: 'pax_checkin',       name: 'Check-in System',             domain: 'passenger', x: 0.72, y: 0.88, deps: [], desc: 'Web, mobile, and kiosk check-in. Highly commoditized.' },
    { id: 'pax_dcs',           name: 'Departure Control (DCS)',     domain: 'passenger', x: 0.78, y: 0.75, deps: ['pax_checkin'], desc: 'Boarding, weight & balance, load control. Core commodity infrastructure.' },
    { id: 'pax_mobile_app',    name: 'Mobile App / Digital',        domain: 'passenger', x: 0.45, y: 0.95, deps: ['pax_booking','rev_ancillary'], desc: 'Customer-facing digital touchpoints. Competitive differentiator.' },
    { id: 'pax_inflight',      name: 'In-Flight Experience',        domain: 'passenger', x: 0.38, y: 0.85, deps: [], desc: 'IFE, connectivity, F&B, cabin service. Product differentiation area.' },
    { id: 'pax_disruption',    name: 'Passenger Re-accommodation',  domain: 'passenger', x: 0.28, y: 0.78, deps: ['ops_disruption','pax_booking'], desc: 'Automated rebooking during disruptions. Emerging AI solutions.' },
];

// ── Competitor Archetypes ─────────────────────────────────
const COMPETITOR_PROFILES = {
    legacy: {
        name: 'Legacy / Full-Service',
        color: '#58a6ff',
        offsets: {
            mro_predictive: { dx: 0.02, dy: -0.02 },
            crew_pairing:   { dx: -0.02, dy: 0.02 },
            sched_network:  { dx: 0.05, dy: 0 },
            rev_dynamic:    { dx: 0.03, dy: 0 },
            rev_loyalty:    { dx: 0.05, dy: 0.02 },
            pax_inflight:   { dx: 0.08, dy: 0.02 },
            pax_booking:    { dx: -0.03, dy: 0 },
            rev_ancillary:  { dx: -0.05, dy: 0 },
            ops_disruption: { dx: 0.03, dy: 0 },
            sched_codeshare:{ dx: 0.05, dy: 0 },
        }
    },
    lcc: {
        name: 'Low-Cost Carrier',
        color: '#3fb950',
        offsets: {
            sched_network:  { dx: -0.05, dy: 0.05 },
            rev_dynamic:    { dx: 0.08, dy: 0 },
            rev_ancillary:  { dx: 0.10, dy: 0 },
            pax_inflight:   { dx: -0.10, dy: -0.05 },
            pax_mobile_app: { dx: 0.05, dy: 0 },
            rev_loyalty:    { dx: -0.08, dy: 0 },
            ops_fuel:       { dx: 0.05, dy: 0 },
            crew_pairing:   { dx: 0.05, dy: 0 },
        }
    },
    ulcc: {
        name: 'Ultra-Low-Cost',
        color: '#d29922',
        offsets: {
            rev_ancillary:  { dx: 0.15, dy: 0.02 },
            pax_inflight:   { dx: -0.15, dy: -0.08 },
            rev_loyalty:    { dx: -0.15, dy: -0.03 },
            sched_network:  { dx: -0.10, dy: 0.03 },
            pax_booking:    { dx: 0.10, dy: 0 },
            rev_dynamic:    { dx: 0.12, dy: 0 },
            ops_fuel:       { dx: 0.10, dy: 0.02 },
            sched_codeshare:{ dx: -0.20, dy: 0 },
            crew_pairing:   { dx: 0.08, dy: 0.03 },
        }
    }
};

// ── State ─────────────────────────────────────────────────
let components = [];
let selectedId = null;
let hoveredId = null;
let dragId = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let showCompetitors = false;
let showLegend = false;
let showHeatmap = false;
let showClusters = false;
let snapToGrid = false;

// Heatmap cache
let heatmapCanvas = null;
let heatmapCtx = null;
let heatmapDirty = true;
let heatmapLastPositionHash = '';

// Search & Filter state
let searchQuery = '';
let activeStageFilters = new Set();
let linkMode = false;
let linkSourceId = null;
let linkPreviewX = 0;
let linkPreviewY = 0;
let isLinkDragging = false;
let undoStack = [];
let redoStack = [];

// ── Theme System ──────────────────────────────────────────
const THEMES = {
    dark: {
        name: 'Dark',
        bg: '#0d1117', surface: '#161b22', surfaceHover: '#21262d',
        border: '#30363d', borderStrong: '#484f58',
        text: '#c9d1d9', textBright: '#e6edf3', textMuted: '#8b949e', textFaint: '#6e7681',
        canvasBg: '#0d1117', grid: '#21262d', gridStrong: '#30363d', nodeText: '#e6edf3',
        inputBg: '#0d1117',
        overlayBg: 'rgba(22, 27, 34, 0.92)', modalBg: 'rgba(0,0,0,0.6)',
        shadow: 'rgba(0,0,0,0.4)', scrollbar: '#30363d', scrollbarHover: '#484f58',
        depLine: '#30363d88', stageAlpha: '08', stageLabelAlpha: '99',
        printMode: false, presentationMode: false
    },
    light: {
        name: 'Light',
        bg: '#f6f8fa', surface: '#ffffff', surfaceHover: '#f0f2f5',
        border: '#d0d7de', borderStrong: '#afb8c1',
        text: '#1f2328', textBright: '#1f2328', textMuted: '#656d76', textFaint: '#8b949e',
        canvasBg: '#ffffff', grid: '#e1e4e8', gridStrong: '#d0d7de', nodeText: '#1f2328',
        inputBg: '#f6f8fa',
        overlayBg: 'rgba(255, 255, 255, 0.92)', modalBg: 'rgba(0,0,0,0.3)',
        shadow: 'rgba(0,0,0,0.12)', scrollbar: '#d0d7de', scrollbarHover: '#afb8c1',
        depLine: '#d0d7de88', stageAlpha: '0c', stageLabelAlpha: '99',
        printMode: false, presentationMode: false
    },
    presentation: {
        name: 'Presentation',
        bg: '#000000', surface: '#0a0a0a', surfaceHover: '#1a1a1a',
        border: '#333333', borderStrong: '#555555',
        text: '#ffffff', textBright: '#ffffff', textMuted: '#aaaaaa', textFaint: '#777777',
        canvasBg: '#000000', grid: '#1a1a1a', gridStrong: '#333333', nodeText: '#ffffff',
        inputBg: '#0a0a0a',
        overlayBg: 'rgba(0, 0, 0, 0.92)', modalBg: 'rgba(0,0,0,0.8)',
        shadow: 'rgba(0,0,0,0.6)', scrollbar: '#333333', scrollbarHover: '#555555',
        depLine: '#33333388', stageAlpha: '12', stageLabelAlpha: 'cc',
        printMode: false, presentationMode: true
    },
    print: {
        name: 'Print',
        bg: '#ffffff', surface: '#ffffff', surfaceHover: '#f5f5f5',
        border: '#cccccc', borderStrong: '#999999',
        text: '#000000', textBright: '#000000', textMuted: '#555555', textFaint: '#888888',
        canvasBg: '#ffffff', grid: '#e0e0e0', gridStrong: '#cccccc', nodeText: '#000000',
        inputBg: '#f5f5f5',
        overlayBg: 'rgba(255, 255, 255, 0.95)', modalBg: 'rgba(0,0,0,0.3)',
        shadow: 'rgba(0,0,0,0.1)', scrollbar: '#cccccc', scrollbarHover: '#999999',
        depLine: '#00000044', stageAlpha: '00', stageLabelAlpha: '88',
        printMode: true, presentationMode: false
    }
};

let currentTheme = 'dark';

function applyTheme(themeKey) {
    const theme = THEMES[themeKey];
    if (!theme) return;
    currentTheme = themeKey;
    const root = document.documentElement;
    root.style.setProperty('--theme-bg', theme.bg);
    root.style.setProperty('--theme-surface', theme.surface);
    root.style.setProperty('--theme-surface-hover', theme.surfaceHover);
    root.style.setProperty('--theme-border', theme.border);
    root.style.setProperty('--theme-border-strong', theme.borderStrong);
    root.style.setProperty('--theme-text', theme.text);
    root.style.setProperty('--theme-text-bright', theme.textBright);
    root.style.setProperty('--theme-text-muted', theme.textMuted);
    root.style.setProperty('--theme-text-faint', theme.textFaint);
    root.style.setProperty('--theme-canvas-bg', theme.canvasBg);
    root.style.setProperty('--theme-grid', theme.grid);
    root.style.setProperty('--theme-grid-strong', theme.gridStrong);
    root.style.setProperty('--theme-input-bg', theme.inputBg);
    root.style.setProperty('--theme-overlay-bg', theme.overlayBg);
    root.style.setProperty('--theme-modal-bg', theme.modalBg);
    root.style.setProperty('--theme-shadow', theme.shadow);
    root.style.setProperty('--theme-scrollbar', theme.scrollbar);
    root.style.setProperty('--theme-scrollbar-hover', theme.scrollbarHover);
    document.body.classList.remove('theme-presentation', 'theme-print');
    if (theme.presentationMode) document.body.classList.add('theme-presentation');
    if (theme.printMode) document.body.classList.add('theme-print');
    const sel = document.getElementById('themeSelect');
    if (sel) sel.value = themeKey;
    localStorage.setItem('wardley-theme', themeKey);
    if (typeof resize === 'function') resize();
    toast('Theme: ' + theme.name);
}

function cycleTheme() {
    const keys = Object.keys(THEMES);
    const idx = keys.indexOf(currentTheme);
    applyTheme(keys[(idx + 1) % keys.length]);
}

// Theme select handler
(function() {
    const sel = document.getElementById('themeSelect');
    if (sel) sel.addEventListener('change', function() { applyTheme(this.value); });
})();

// Restore saved theme
(function() {
    const saved = localStorage.getItem('wardley-theme');
    if (saved && THEMES[saved]) {
        currentTheme = saved;
        const theme = THEMES[saved];
        const root = document.documentElement;
        root.style.setProperty('--theme-bg', theme.bg);
        root.style.setProperty('--theme-surface', theme.surface);
        root.style.setProperty('--theme-surface-hover', theme.surfaceHover);
        root.style.setProperty('--theme-border', theme.border);
        root.style.setProperty('--theme-border-strong', theme.borderStrong);
        root.style.setProperty('--theme-text', theme.text);
        root.style.setProperty('--theme-text-bright', theme.textBright);
        root.style.setProperty('--theme-text-muted', theme.textMuted);
        root.style.setProperty('--theme-text-faint', theme.textFaint);
        root.style.setProperty('--theme-canvas-bg', theme.canvasBg);
        root.style.setProperty('--theme-grid', theme.grid);
        root.style.setProperty('--theme-grid-strong', theme.gridStrong);
        root.style.setProperty('--theme-input-bg', theme.inputBg);
        root.style.setProperty('--theme-overlay-bg', theme.overlayBg);
        root.style.setProperty('--theme-modal-bg', theme.modalBg);
        root.style.setProperty('--theme-shadow', theme.shadow);
        root.style.setProperty('--theme-scrollbar', theme.scrollbar);
        root.style.setProperty('--theme-scrollbar-hover', theme.scrollbarHover);
        document.body.classList.remove('theme-presentation', 'theme-print');
        if (theme.presentationMode) document.body.classList.add('theme-presentation');
        if (theme.printMode) document.body.classList.add('theme-print');
        const sel = document.getElementById('themeSelect');
        if (sel) sel.value = saved;
    }
})();


// Camera / transform
let camX = 0, camY = 0, camZoom = 1;
let isPanning = false;
let panStartX = 0, panStartY = 0;
let panCamStartX = 0, panCamStartY = 0;

// Map margins (in canvas coords)
const MAP_PADDING = { top: 60, right: 40, bottom: 50, left: 60 };

// ── Canvas Setup ──────────────────────────────────────────
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const mapArea = document.getElementById('mapArea');

let W, H, mapX, mapY, mapW, mapH;

function resize() {
    const rect = mapArea.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    W = rect.width;
    H = rect.height;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    mapX = MAP_PADDING.left;
    mapY = MAP_PADDING.top;
    mapW = W - MAP_PADDING.left - MAP_PADDING.right;
    mapH = H - MAP_PADDING.top - MAP_PADDING.bottom;
    draw();
}

// ── Coordinate Transforms ─────────────────────────────────
// Data coords (0-1) → screen coords
function dataToScreen(dx, dy) {
    const sx = mapX + dx * mapW;
    const sy = mapY + (1 - dy) * mapH; // y is inverted (high=visible=top)
    // Apply camera
    return {
        x: (sx - camX) * camZoom + W / 2,
        y: (sy - camY) * camZoom + H / 2
    };
}

// Screen coords → data coords (0-1)
function screenToData(sx, sy) {
    const wx = (sx - W / 2) / camZoom + camX;
    const wy = (sy - H / 2) / camZoom + camY;
    const dx = (wx - mapX) / mapW;
    const dy = 1 - (wy - mapY) / mapH;
    return { x: Math.max(0, Math.min(1, dx)), y: Math.max(0, Math.min(1, dy)) };
}

// ── Drawing ───────────────────────────────────────────────
function draw() {
    ctx.clearRect(0, 0, W, H);
    ctx.save();

    // Background
    const T = THEMES[currentTheme];
    ctx.fillStyle = T.canvasBg;
    ctx.fillRect(0, 0, W, H);

    drawGrid();
    drawHeatmapOverlay();
    drawClusterOverlay();
    drawDependencies();
    if (showCompetitors) drawCompetitors();
    drawComponents();
    drawMovementArrows();
    if (typeof compareMode !== "undefined" && compareMode) drawCompareOverlay();

    ctx.restore();
}

function drawGrid() {
    const T = THEMES[currentTheme];
    // Evolution stage backgrounds
    for (let i = 0; i < EVOLUTION_STAGES.length; i++) {
        const stage = EVOLUTION_STAGES[i];
        const p0 = dataToScreen(stage.x0, 1);
        const p1 = dataToScreen(stage.x1, 0);
        ctx.fillStyle = stage.color + T.stageAlpha;
        ctx.fillRect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y);

        // Stage label at bottom
        const mid = dataToScreen((stage.x0 + stage.x1) / 2, 0);
        ctx.fillStyle = stage.color + T.stageLabelAlpha;
        ctx.font = T.presentationMode ? 'bold 14px system-ui' : '11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(stage.label, mid.x, mid.y + 20);
    }

    // Stage boundaries
    for (let i = 1; i < EVOLUTION_STAGES.length; i++) {
        const p = dataToScreen(EVOLUTION_STAGES[i].x0, 1);
        const p2 = dataToScreen(EVOLUTION_STAGES[i].x0, 0);
        ctx.strokeStyle = T.gridStrong;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Grid lines (subtle)
    ctx.strokeStyle = T.grid;
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 10; i++) {
        const p0 = dataToScreen(i / 10, 1);
        const p1 = dataToScreen(i / 10, 0);
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();

        const h0 = dataToScreen(0, i / 10);
        const h1 = dataToScreen(1, i / 10);
        ctx.beginPath();
        ctx.moveTo(h0.x, h0.y);
        ctx.lineTo(h1.x, h1.y);
        ctx.stroke();
    }

    // Axis labels
    ctx.fillStyle = T.textMuted;
    ctx.font = T.presentationMode ? 'bold 14px system-ui' : 'bold 11px system-ui';

    // X axis
    const xLeft = dataToScreen(0, 0);
    const xRight = dataToScreen(1, 0);
    ctx.textAlign = 'center';
    ctx.fillText('Evolution →', (xLeft.x + xRight.x) / 2, xLeft.y + 38);

    // Y axis
    ctx.save();
    const yTop = dataToScreen(0, 1);
    const yBot = dataToScreen(0, 0);
    ctx.translate(yTop.x - 40, (yTop.y + yBot.y) / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Value Chain (visible → invisible)', 0, 0);
    ctx.restore();

    // Y axis endpoint labels
    ctx.font = T.presentationMode ? '12px system-ui' : '10px system-ui';
    ctx.fillStyle = T.textFaint;
    ctx.textAlign = 'right';
    const topP = dataToScreen(0, 1);
    const botP = dataToScreen(0, 0);
    ctx.fillText('Visible', topP.x - 8, topP.y + 4);
    ctx.fillText('Invisible', botP.x - 8, botP.y);

    // Border
    const tl = dataToScreen(0, 1);
    const br = dataToScreen(1, 0);
    ctx.strokeStyle = T.gridStrong;
    ctx.lineWidth = T.printMode ? 1.5 : 1;
    ctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
}

function drawDependencies() {
    const T = THEMES[currentTheme];
    for (const comp of components) {
        for (const depId of (comp.deps || [])) {
            const dep = components.find(c => c.id === depId);
            if (!dep) continue;
            const from = dataToScreen(comp.x, comp.y);
            const to = dataToScreen(dep.x, dep.y);
            const cp = getBezierControlPoint(from.x, from.y, to.x, to.y);
            ctx.strokeStyle = T.depLine;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.quadraticCurveTo(cp.x, cp.y, to.x, to.y);
            ctx.stroke();
            drawDepArrowhead(from.x, from.y, to.x, to.y, cp.x, cp.y);
        }
    }
    // Link mode preview line
    if (linkMode && isLinkDragging && linkSourceId) {
        const sourceComp = components.find(c => c.id === linkSourceId);
        if (sourceComp) {
            const from = dataToScreen(sourceComp.x, sourceComp.y);
            ctx.strokeStyle = '#f0883eaa';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(linkPreviewX, linkPreviewY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(linkPreviewX, linkPreviewY, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#f0883eaa';
            ctx.fill();
        }
    }
}

function getBezierControlPoint(x1, y1, x2, y2) {
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.hypot(dx, dy);
    if (len === 0) return { x: mx, y: my };
    const offset = Math.min(30, len * 0.15);
    const nx = -dy / len;
    const ny = dx / len;
    return { x: mx + nx * offset, y: my + ny * offset };
}

function drawDepArrowhead(x1, y1, x2, y2, cpx, cpy) {
    const tdx = x2 - cpx;
    const tdy = y2 - cpy;
    const angle = Math.atan2(tdy, tdx);
    const headLen = 8;
    const headAngle = 0.38;
    const nodeR = 18 * camZoom;
    const tipX = x2 - Math.cos(angle) * nodeR;
    const tipY = y2 - Math.sin(angle) * nodeR;
    ctx.fillStyle = '#30363dcc';
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - headLen * Math.cos(angle - headAngle), tipY - headLen * Math.sin(angle - headAngle));
    ctx.lineTo(tipX - headLen * Math.cos(angle + headAngle), tipY - headLen * Math.sin(angle + headAngle));
    ctx.closePath();
    ctx.fill();
}

function hitTestBezierLine(sx, sy, threshold) {
    if (typeof threshold === 'undefined') threshold = 8;
    let closest = null;
    let closestDist = threshold;
    for (const comp of components) {
        for (const depId of (comp.deps || [])) {
            const dep = components.find(c => c.id === depId);
            if (!dep) continue;
            const from = dataToScreen(comp.x, comp.y);
            const to = dataToScreen(dep.x, dep.y);
            const cp = getBezierControlPoint(from.x, from.y, to.x, to.y);
            const dist = distToQuadBezier(sx, sy, from.x, from.y, cp.x, cp.y, to.x, to.y);
            if (dist < closestDist) {
                closestDist = dist;
                closest = { fromId: comp.id, toId: depId };
            }
        }
    }
    return closest;
}

function distToQuadBezier(px, py, x0, y0, cpx, cpy, x1, y1) {
    let minDist = Infinity;
    const steps = 20;
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const invT = 1 - t;
        const bx = invT * invT * x0 + 2 * invT * t * cpx + t * t * x1;
        const by = invT * invT * y0 + 2 * invT * t * cpy + t * t * y1;
        const d = Math.hypot(px - bx, py - by);
        if (d < minDist) minDist = d;
    }
    return minDist;
}

function toggleLinkMode() {
    linkMode = !linkMode;
    document.getElementById('btnLink').classList.toggle('link-active', linkMode);
    document.getElementById('linkModeIndicator').classList.toggle('visible', linkMode);
    linkSourceId = null;
    isLinkDragging = false;
    canvas.style.cursor = linkMode ? 'crosshair' : 'default';
    draw();
    toast(linkMode ? 'Link mode ON' : 'Link mode OFF');
}

// ── Search & Filter Logic ────────────────────────────────
function getEvolutionStageIndex(x) {
    for (let i = 0; i < EVOLUTION_STAGES.length; i++) {
        if (x >= EVOLUTION_STAGES[i].x0 && x < EVOLUTION_STAGES[i].x1) return i;
    }
    return EVOLUTION_STAGES.length - 1;
}

function matchesFilter(comp) {
    if (searchQuery && !comp.name.toLowerCase().includes(searchQuery)) return false;
    if (activeStageFilters.size > 0) {
        const stageIdx = getEvolutionStageIndex(comp.x);
        if (!activeStageFilters.has(stageIdx)) return false;
    }
    return true;
}

function isFilterActive() {
    return searchQuery.length > 0 || activeStageFilters.size > 0;
}

function drawComponents() {
    const T = THEMES[currentTheme];
    const nodeRadius = 18 * camZoom;
    const fontSize = Math.max(9, 11 * camZoom);

    const filtering = isFilterActive();
    for (const comp of components) {
        const pos = dataToScreen(comp.x, comp.y);
        const color = DOMAIN_COLORS[comp.domain] || '#8b949e';
        const isSelected = comp.id === selectedId;
        const isHovered = comp.id === hoveredId;
        const matches = !filtering || matchesFilter(comp);

        ctx.globalAlpha = matches ? 1.0 : 0.3;

        // Glow for selected
        if (isSelected && matches) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 16;
        }

        // Node circle
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = isSelected ? color + 'cc' : isHovered ? color + '99' : color + '55';
        ctx.fill();
        ctx.strokeStyle = isSelected ? T.nodeText : color;
        ctx.lineWidth = isSelected ? 2.5 : 1.5;
        ctx.stroke();

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        // Label
        ctx.fillStyle = T.nodeText;
        ctx.font = `${isSelected ? 'bold ' : ''}${fontSize}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        const label = comp.name;
        const maxLabelWidth = 120 * camZoom;
        // Word wrap
        const words = label.split(' ');
        let lines = [];
        let currentLine = '';
        for (const word of words) {
            const test = currentLine ? currentLine + ' ' + word : word;
            if (ctx.measureText(test).width > maxLabelWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = test;
            }
        }
        if (currentLine) lines.push(currentLine);

        const lineHeight = fontSize + 2;
        const labelY = pos.y + nodeRadius + 4;
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], pos.x, labelY + i * lineHeight);
        }

        // Annotation indicator
        if (comp.annotation) {
            ctx.fillStyle = '#DDA15E';
            ctx.beginPath();
            ctx.arc(pos.x + nodeRadius - 2, pos.y - nodeRadius + 2, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.globalAlpha = 1.0;
    }
}

function drawMovementArrows() {
    for (const comp of components) {
        if (!comp.arrow) continue;
        const pos = dataToScreen(comp.x, comp.y);
        const r = 18 * camZoom;
        const arrowLen = 30 * camZoom;
        const color = DOMAIN_COLORS[comp.domain] || '#8b949e';

        let dx = 0, dy = 0;
        if (comp.arrow === 'right') { dx = 1; }
        else if (comp.arrow === 'left') { dx = -1; }
        else if (comp.arrow === 'up') { dy = -1; }
        else if (comp.arrow === 'down') { dy = 1; }

        const startX = pos.x + dx * (r + 4);
        const startY = pos.y + dy * (r + 4);
        const endX = startX + dx * arrowLen;
        const endY = startY + dy * arrowLen;

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Arrowhead
        const headLen = 8;
        const angle = Math.atan2(endY - startY, endX - startX);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - headLen * Math.cos(angle - 0.4), endY - headLen * Math.sin(angle - 0.4));
        ctx.lineTo(endX - headLen * Math.cos(angle + 0.4), endY - headLen * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
    }
}

function drawCompetitors() {
    const r = 10 * camZoom;
    for (const [key, profile] of Object.entries(COMPETITOR_PROFILES)) {
        for (const comp of components) {
            const offset = profile.offsets[comp.id];
            if (!offset) continue;
            const cx = Math.max(0, Math.min(1, comp.x + offset.dx));
            const cy = Math.max(0, Math.min(1, comp.y + offset.dy));
            const pos = dataToScreen(cx, cy);

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
            ctx.fillStyle = profile.color + '25';
            ctx.fill();
            ctx.strokeStyle = profile.color + '88';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 2]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Initial letter
            ctx.fillStyle = profile.color;
            ctx.font = `bold ${Math.max(8, 9 * camZoom)}px system-ui`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(key[0].toUpperCase(), pos.x, pos.y);
        }
    }
}

// ── Heatmap: Gaussian KDE ─────────────────────────────────
function computePositionHash(){let h=components.length+'|';for(const c of components)h+=c.x.toFixed(4)+','+c.y.toFixed(4)+'|';return h;}
function ensureHeatmapCanvas(){if(!heatmapCanvas){heatmapCanvas=document.createElement('canvas');heatmapCtx=heatmapCanvas.getContext('2d');}if(heatmapCanvas.width!==Math.ceil(W)||heatmapCanvas.height!==Math.ceil(H)){heatmapCanvas.width=Math.ceil(W);heatmapCanvas.height=Math.ceil(H);heatmapDirty=true;}}
function buildHeatmap(){
    if(components.length===0)return;ensureHeatmapCanvas();
    var posHash=computePositionHash();if(!heatmapDirty&&posHash===heatmapLastPositionHash)return;
    heatmapLastPositionHash=posHash;heatmapDirty=false;
    var hw=heatmapCanvas.width,hh=heatmapCanvas.height;heatmapCtx.clearRect(0,0,hw,hh);
    var sc=4,sw=Math.ceil(hw/sc),sh=Math.ceil(hh/sc);
    var density=new Float32Array(sw*sh),maxD=0;
    var sPos=components.map(function(c){return dataToScreen(c.x,c.y);});
    var rA=dataToScreen(0.5,0.5),rB=dataToScreen(0.58,0.5);
    var krs=Math.hypot(rB.x-rA.x,rB.y-rA.y)/sc,inv=1.0/(krs*krs*0.5);
    for(var yi=0;yi<sh;yi++)for(var xi=0;xi<sw;xi++){
        var sx2=(xi+0.5)*sc,sy2=(yi+0.5)*sc,d=0;
        for(var si=0;si<sPos.length;si++){var dx2=sx2-sPos[si].x,dy2=sy2-sPos[si].y;d+=Math.exp(-(dx2*dx2+dy2*dy2)*inv);}
        density[yi*sw+xi]=d;if(d>maxD)maxD=d;
    }
    if(maxD===0)return;
    var imgData=heatmapCtx.createImageData(sw,sh),px=imgData.data;
    for(var ii=0;ii<sw*sh;ii++){
        var t=density[ii]/maxD,r2,g2,b2,a2;
        if(t<0.01){r2=0;g2=0;b2=0;a2=0;}
        else if(t<0.2){var lt=(t-0.01)/0.19;r2=0;g2=0;b2=80+lt*100|0;a2=lt*140|0;}
        else if(t<0.4){var lt=(t-0.2)/0.2;r2=0;g2=lt*200|0;b2=180-lt*40|0;a2=140+lt*30|0;}
        else if(t<0.6){var lt=(t-0.4)/0.2;r2=lt*80|0;g2=200-lt*20|0;b2=140-lt*120|0;a2=170+lt*20|0;}
        else if(t<0.8){var lt=(t-0.6)/0.2;r2=80+lt*175|0;g2=180+lt*55|0;b2=20-lt*20|0;a2=190+lt*15|0;}
        else{var lt=(t-0.8)/0.2;r2=255;g2=235-lt*195|0;b2=0;a2=205+lt*40|0;}
        var idx2=ii*4;px[idx2]=r2;px[idx2+1]=g2;px[idx2+2]=b2;px[idx2+3]=a2;
    }
    var tc=document.createElement('canvas');tc.width=sw;tc.height=sh;
    tc.getContext('2d').putImageData(imgData,0,0);
    heatmapCtx.imageSmoothingEnabled=true;heatmapCtx.imageSmoothingQuality='high';
    heatmapCtx.drawImage(tc,0,0,sw,sh,0,0,hw,hh);
}
function drawHeatmapOverlay(){
    if(!showHeatmap||components.length===0)return;buildHeatmap();if(!heatmapCanvas)return;
    var tl=dataToScreen(0,1),br=dataToScreen(1,0);
    ctx.save();ctx.beginPath();ctx.rect(tl.x,tl.y,br.x-tl.x,br.y-tl.y);ctx.clip();
    ctx.globalAlpha=0.55;ctx.drawImage(heatmapCanvas,0,0);ctx.globalAlpha=1.0;ctx.restore();
}
// ── Cluster: Convex Hulls per Domain ──────────────────────
function convexHull(pts){
    if(pts.length<3)return pts.slice();var piv=0;
    for(var i=1;i<pts.length;i++){if(pts[i].y>pts[piv].y||(pts[i].y===pts[piv].y&&pts[i].x<pts[piv].x))piv=i;}
    var tmp=pts[0];pts[0]=pts[piv];pts[piv]=tmp;var p0=pts[0];
    var sorted=pts.slice(1).sort(function(a,b){var aa=Math.atan2(a.y-p0.y,a.x-p0.x),ab=Math.atan2(b.y-p0.y,b.x-p0.x);return Math.abs(aa-ab)<1e-10?Math.hypot(a.x-p0.x,a.y-p0.y)-Math.hypot(b.x-p0.x,b.y-p0.y):aa-ab;});
    var stk=[p0];for(var j=0;j<sorted.length;j++){var pt=sorted[j];while(stk.length>1){var sa=stk[stk.length-2],sb=stk[stk.length-1];if((sb.x-sa.x)*(pt.y-sa.y)-(sb.y-sa.y)*(pt.x-sa.x)<=0)stk.pop();else break;}stk.push(pt);}
    return stk;
}
function expandHull(hp,pad){
    if(hp.length<2)return hp;var cx=0,cy=0;for(var i=0;i<hp.length;i++){cx+=hp[i].x;cy+=hp[i].y;}cx/=hp.length;cy/=hp.length;
    return hp.map(function(p){var dx=p.x-cx,dy=p.y-cy,d=Math.hypot(dx,dy);return d===0?{x:p.x+pad,y:p.y}:{x:cx+dx*(d+pad)/d,y:cy+dy*(d+pad)/d};});
}
function drawClusterOverlay(){
    if(!showClusters||components.length===0)return;
    var byD={};for(var i=0;i<components.length;i++){var c=components[i];if(!byD[c.domain])byD[c.domain]=[];byD[c.domain].push(c);}
    var tl=dataToScreen(0,1),br=dataToScreen(1,0);
    ctx.save();ctx.beginPath();ctx.rect(tl.x,tl.y,br.x-tl.x,br.y-tl.y);ctx.clip();
    var domains=Object.keys(byD);
    for(var di=0;di<domains.length;di++){
        var domain=domains[di],comps=byD[domain];if(comps.length<1)continue;
        var color=DOMAIN_COLORS[domain]||'#8b949e';
        var sp=comps.map(function(c){return dataToScreen(c.x,c.y);});
        if(sp.length===1){ctx.beginPath();ctx.arc(sp[0].x,sp[0].y,30,0,Math.PI*2);ctx.fillStyle=color+'14';ctx.fill();ctx.strokeStyle=color+'4D';ctx.lineWidth=1.5;ctx.setLineDash([6,3]);ctx.stroke();ctx.setLineDash([]);continue;}
        if(sp.length===2){var p1=sp[0],p2=sp[1],pad2=20,ddx=p2.x-p1.x,ddy=p2.y-p1.y,len=Math.hypot(ddx,ddy),nx=-ddy/len*pad2,ny=ddx/len*pad2;ctx.beginPath();ctx.moveTo(p1.x+nx,p1.y+ny);ctx.lineTo(p2.x+nx,p2.y+ny);ctx.arc(p2.x,p2.y,pad2,Math.atan2(ny,nx),Math.atan2(-ny,-nx));ctx.lineTo(p1.x-nx,p1.y-ny);ctx.arc(p1.x,p1.y,pad2,Math.atan2(-ny,-nx),Math.atan2(ny,nx));ctx.closePath();ctx.fillStyle=color+'14';ctx.fill();ctx.strokeStyle=color+'4D';ctx.lineWidth=1.5;ctx.setLineDash([6,3]);ctx.stroke();ctx.setLineDash([]);continue;}
        var hull=convexHull(sp.map(function(p){return{x:p.x,y:p.y};})),exp=expandHull(hull,20);if(exp.length<3)continue;
        ctx.beginPath();var f=exp[0],l=exp[exp.length-1];ctx.moveTo((l.x+f.x)/2,(l.y+f.y)/2);
        for(var ei=0;ei<exp.length;ei++){var cc=exp[ei],nn=exp[(ei+1)%exp.length];ctx.quadraticCurveTo(cc.x,cc.y,(cc.x+nn.x)/2,(cc.y+nn.y)/2);}
        ctx.closePath();ctx.fillStyle=color+'14';ctx.fill();ctx.strokeStyle=color+'4D';ctx.lineWidth=1.5;ctx.setLineDash([6,3]);ctx.stroke();ctx.setLineDash([]);
        var cx2=0,cy2=0;for(var ci=0;ci<sp.length;ci++){cx2+=sp[ci].x;cy2+=sp[ci].y;}cx2/=sp.length;cy2/=sp.length;
        ctx.fillStyle=color+'88';ctx.font='bold 10px system-ui';ctx.textAlign='center';ctx.textBaseline='middle';
        ctx.fillText(DOMAIN_LABELS[domain]||domain,cx2,cy2-(sp.length>5?0:20));
    }
    ctx.restore();
}
function toggleHeatmap(){showHeatmap=!showHeatmap;var btn=document.getElementById('btnHeatmap');if(btn){btn.classList.toggle('active',showHeatmap);btn.classList.toggle('heatmap-active',showHeatmap);}if(showHeatmap)heatmapDirty=true;draw();toast('Heatmap: '+(showHeatmap?'ON':'OFF'));}
function toggleClusters(){showClusters=!showClusters;var btn=document.getElementById('btnCluster');if(btn){btn.classList.toggle('active',showClusters);btn.classList.toggle('cluster-active',showClusters);}draw();toast('Cluster view: '+(showClusters?'ON':'OFF'));}

// ── Hit Testing ───────────────────────────────────────────
function hitTest(sx, sy) {
    const r = 20 * camZoom;
    for (let i = components.length - 1; i >= 0; i--) {
        const c = components[i];
        const p = dataToScreen(c.x, c.y);
        const dist = Math.hypot(sx - p.x, sy - p.y);
        if (dist <= r) return c.id;
    }
    return null;
}

// ── Undo/Redo ─────────────────────────────────────────────
function saveState() {
    undoStack.push(JSON.stringify(components));
    if (undoStack.length > 50) undoStack.shift();
    redoStack = [];
}

function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(JSON.stringify(components));
    components = JSON.parse(undoStack.pop());
    selectedId = null;
    closeDetail();
    updateComponentList();
    draw();
    toast('Undo');
}

function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(JSON.stringify(components));
    components = JSON.parse(redoStack.pop());
    selectedId = null;
    closeDetail();
    updateComponentList();
    draw();
    toast('Redo');
}

// ── Toast ─────────────────────────────────────────────────
const toastEl = document.getElementById('toast');
let toastTimer = null;
function toast(msg) {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2000);
}

// ── Domain Loading ────────────────────────────────────────
function loadDomain(domainKey) {
    saveState();
    const toAdd = AVIATION_COMPONENTS.filter(c => c.domain === domainKey);
    let count = 0;
    for (const template of toAdd) {
        if (components.find(c => c.id === template.id)) continue;
        components.push({
            id: template.id,
            name: template.name,
            domain: template.domain,
            x: template.x,
            y: template.y,
            deps: [...(template.deps || [])],
            desc: template.desc || '',
            annotation: '',
            arrow: null
        });
        count++;
    }
    updateComponentList();
    draw();
    if (count > 0) toast(`Added ${count} ${DOMAIN_LABELS[domainKey]} components`);
    else toast(`${DOMAIN_LABELS[domainKey]} already loaded`);
}

function loadAll() {
    saveState();
    let count = 0;
    for (const template of AVIATION_COMPONENTS) {
        if (components.find(c => c.id === template.id)) continue;
        components.push({
            id: template.id,
            name: template.name,
            domain: template.domain,
            x: template.x,
            y: template.y,
            deps: [...(template.deps || [])],
            desc: template.desc || '',
            annotation: '',
            arrow: null
        });
        count++;
    }
    updateComponentList();
    draw();
    toast(`Loaded ${count} components across all domains`);
}

function clearMap() {
    if (components.length === 0) return;
    saveState();
    components = [];
    selectedId = null;
    closeDetail();
    updateComponentList();
    draw();
    toast('Map cleared');
}

function resetPositions() {
    saveState();
    for (const comp of components) {
        const template = AVIATION_COMPONENTS.find(t => t.id === comp.id);
        if (template) {
            comp.x = template.x;
            comp.y = template.y;
        }
    }
    draw();
    toast('Positions reset to defaults');
}

// ── UI: Sidebar ───────────────────────────────────────────
function buildSidebar() {
    const list = document.getElementById('domainList');
    const domainKeys = Object.keys(DOMAIN_COLORS);
    list.innerHTML = domainKeys.map((key, i) => `
        <button class="domain-btn" data-domain="${key}">
            <span class="domain-dot" style="background:${DOMAIN_COLORS[key]}"></span>
            ${DOMAIN_LABELS[key]}
            <span class="count">${AVIATION_COMPONENTS.filter(c => c.domain === key).length}</span>
        </button>
    `).join('');

    list.querySelectorAll('.domain-btn').forEach(btn => {
        btn.addEventListener('click', () => loadDomain(btn.dataset.domain));
    });

    // Populate add modal domain select
    const select = document.getElementById('addDomain');
    select.innerHTML = domainKeys.map(k =>
        `<option value="${k}">${DOMAIN_LABELS[k]}</option>`
    ).join('');
}

function updateComponentList() {
    const list = document.getElementById('componentList');
    if (components.length === 0) {
        list.innerHTML = '<div style="color:#6e7681;font-size:0.75rem;padding:8px">No components on map. Click a domain above to load.</div>';
        return;
    }
    const filtering = isFilterActive();
    const filtered = filtering ? components.filter(matchesFilter) : components;
    if (filtered.length === 0 && filtering) {
        list.innerHTML = '<div style="color:#6e7681;font-size:0.75rem;padding:8px">No matching components.</div>';
        return;
    }
    // Group by domain
    const byDomain = {};
    for (const c of filtered) {
        if (!byDomain[c.domain]) byDomain[c.domain] = [];
        byDomain[c.domain].push(c);
    }
    let html = '';
    for (const [domain, comps] of Object.entries(byDomain)) {
        for (const c of comps) {
            html += `<div class="component-item" data-id="${c.id}" style="${c.id === selectedId ? 'background:#21262d' : ''}">
                <span class="dot" style="background:${DOMAIN_COLORS[domain]}"></span>
                ${c.name}
            </div>`;
        }
    }
    list.innerHTML = html;
    list.querySelectorAll('.component-item').forEach(el => {
        el.addEventListener('click', () => {
            selectedId = el.dataset.id;
            openDetail(selectedId);
            draw();
        });
    });
}

// Collapsible sidebar sections
document.querySelectorAll('.sidebar-header').forEach(h => {
    h.addEventListener('click', () => h.classList.toggle('collapsed'));
});

// ── UI: Detail Panel ──────────────────────────────────────
function openDetail(id) {
    const comp = components.find(c => c.id === id);
    if (!comp) return;
    const panel = document.getElementById('detailPanel');
    const title = document.getElementById('detailTitle');
    const body = document.getElementById('detailBody');

    title.textContent = comp.name;

    const evoStage = EVOLUTION_STAGES.find(s => comp.x >= s.x0 && comp.x < s.x1) || EVOLUTION_STAGES[3];

    body.innerHTML = `
        <div class="field-group">
            <div class="field-label">Domain</div>
            <div class="field-value" style="display:flex;align-items:center;gap:6px">
                <span class="dot" style="width:8px;height:8px;border-radius:50%;background:${DOMAIN_COLORS[comp.domain]};display:inline-block"></span>
                ${DOMAIN_LABELS[comp.domain]}
            </div>
        </div>
        <div class="field-group">
            <div class="field-label">Evolution Stage</div>
            <div class="field-value">
                <span class="evolution-badge" style="background:${evoStage.color}22;color:${evoStage.color}">${evoStage.label}</span>
                <span style="color:#6e7681;font-size:0.75rem;margin-left:6px">(${(comp.x * 100).toFixed(0)}%)</span>
            </div>
        </div>
        <div class="field-group">
            <div class="field-label">Value Chain Position</div>
            <div class="field-value">${comp.y >= 0.7 ? 'Visible' : comp.y >= 0.4 ? 'Mid-chain' : 'Infrastructure'} <span style="color:#6e7681;font-size:0.75rem">(${(comp.y * 100).toFixed(0)}%)</span></div>
        </div>
        <div class="field-group">
            <div class="field-label">Name</div>
            <input class="field-input" id="editName" value="${escHtml(comp.name)}">
        </div>
        <div class="field-group">
            <div class="field-label">Description</div>
            <textarea class="field-input" id="editDesc">${escHtml(comp.desc || '')}</textarea>
        </div>
        <div class="field-group">
            <div class="field-label">Strategic Annotation</div>
            <textarea class="field-input" id="editAnnotation" placeholder="Add strategic notes…">${escHtml(comp.annotation || '')}</textarea>
        </div>
        <div class="field-group">
            <div class="field-label">Movement Arrow</div>
            <div style="display:flex;gap:4px">
                <button class="btn ${comp.arrow === 'right' ? 'active' : ''}" data-arrow="right">→ Evolve</button>
                <button class="btn ${comp.arrow === 'left' ? 'active' : ''}" data-arrow="left">← De-evolve</button>
                <button class="btn ${comp.arrow === null ? 'active' : ''}" data-arrow="none">None</button>
            </div>
        </div>
        <div class="field-group">
            <div class="field-label">Dependencies</div>
            <div style="font-size:0.8rem;color:#8b949e">
                ${(comp.deps || []).map(dId => {
                    const d = components.find(c => c.id === dId);
                    return d ? `<div style="margin:2px 0">→ ${d.name}</div>` : '';
                }).join('') || '<div>No dependencies</div>'}
            </div>
        </div>
        <button class="delete-btn" id="editDelete">Delete Component</button>
    `;

    panel.classList.add('open');

    // Bind events
    const nameInput = document.getElementById('editName');
    const descInput = document.getElementById('editDesc');
    const annotInput = document.getElementById('editAnnotation');

    nameInput.addEventListener('change', () => {
        saveState();
        comp.name = nameInput.value;
        title.textContent = comp.name;
        updateComponentList();
        draw();
    });
    descInput.addEventListener('change', () => {
        comp.desc = descInput.value;
    });
    annotInput.addEventListener('change', () => {
        comp.annotation = annotInput.value;
        draw();
    });

    body.querySelectorAll('[data-arrow]').forEach(btn => {
        btn.addEventListener('click', () => {
            saveState();
            comp.arrow = btn.dataset.arrow === 'none' ? null : btn.dataset.arrow;
            openDetail(id); // refresh
            draw();
        });
    });

    document.getElementById('editDelete').addEventListener('click', () => {
        saveState();
        components = components.filter(c => c.id !== id);
        // Clean up deps
        for (const c of components) {
            c.deps = (c.deps || []).filter(d => d !== id);
        }
        selectedId = null;
        closeDetail();
        updateComponentList();
        draw();
        toast('Deleted: ' + comp.name);
    });
}

function closeDetail() {
    document.getElementById('detailPanel').classList.remove('open');
}

function escHtml(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ── UI: Add Component Modal ───────────────────────────────
let addAtX = 0.5, addAtY = 0.5;

function showAddModal(x, y) {
    addAtX = x || 0.5;
    addAtY = y || 0.5;
    document.getElementById('addModal').classList.add('visible');
    const nameInput = document.getElementById('addName');
    nameInput.value = '';
    nameInput.focus();
}

function hideAddModal() {
    document.getElementById('addModal').classList.remove('visible');
}

function addComponent() {
    const name = document.getElementById('addName').value.trim();
    const domain = document.getElementById('addDomain').value;
    if (!name) return;

    saveState();
    const id = 'custom_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6);
    components.push({
        id, name, domain,
        x: addAtX,
        y: addAtY,
        deps: [],
        desc: '',
        annotation: '',
        arrow: null
    });
    hideAddModal();
    updateComponentList();
    selectedId = id;
    openDetail(id);
    draw();
    toast('Added: ' + name);
}

document.getElementById('addConfirm').addEventListener('click', addComponent);
document.getElementById('addCancel').addEventListener('click', hideAddModal);
document.getElementById('addName').addEventListener('keydown', e => {
    if (e.key === 'Enter') addComponent();
    if (e.key === 'Escape') hideAddModal();
});

// ── UI: Context Menu ──────────────────────────────────────
const contextMenu = document.getElementById('contextMenu');
let contextTargetId = null;

function showContextMenu(x, y, id) {
    contextTargetId = id;
    contextMenu.style.left = x + 'px';
    contextMenu.style.top = y + 'px';
    contextMenu.classList.add('visible');
}

function hideContextMenu() {
    contextMenu.classList.remove('visible');
    contextTargetId = null;
}

contextMenu.querySelectorAll('.context-item').forEach(item => {
    item.addEventListener('click', () => {
        const action = item.dataset.action;
        const comp = components.find(c => c.id === contextTargetId);
        if (!comp) { hideContextMenu(); return; }

        switch (action) {
            case 'edit':
                selectedId = comp.id;
                openDetail(comp.id);
                draw();
                break;
            case 'annotate':
                selectedId = comp.id;
                openDetail(comp.id);
                draw();
                setTimeout(() => {
                    const el = document.getElementById('editAnnotation');
                    if (el) el.focus();
                }, 100);
                break;
            case 'arrow':
                saveState();
                comp.arrow = comp.arrow === 'right' ? null : 'right';
                draw();
                if (selectedId === comp.id) openDetail(comp.id);
                break;
            case 'duplicate':
                saveState();
                const dup = {
                    ...JSON.parse(JSON.stringify(comp)),
                    id: 'dup_' + Date.now(),
                    name: comp.name + ' (copy)',
                    x: Math.min(1, comp.x + 0.03),
                    y: Math.max(0, comp.y - 0.03)
                };
                components.push(dup);
                updateComponentList();
                draw();
                toast('Duplicated: ' + comp.name);
                break;
            case 'delete':
                saveState();
                components = components.filter(c => c.id !== comp.id);
                for (const c of components) {
                    c.deps = (c.deps || []).filter(d => d !== comp.id);
                }
                if (selectedId === comp.id) { selectedId = null; closeDetail(); }
                updateComponentList();
                draw();
                toast('Deleted: ' + comp.name);
                break;
        }
        hideContextMenu();
    });
});

// ── Mouse/Touch Events ────────────────────────────────────
canvas.addEventListener('mousedown', e => {
    hideContextMenu();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Right click
    if (e.button === 2) {
        const id = hitTest(mx, my);
        if (id) {
            e.preventDefault();
            showContextMenu(e.clientX, e.clientY, id);
        }
        return;
    }

    // Middle button pan
    if (e.button === 1) {
        isPanning = true;
        panStartX = mx;
        panStartY = my;
        panCamStartX = camX;
        panCamStartY = camY;
        canvas.style.cursor = 'grabbing';
        e.preventDefault();
        return;
    }

    // Link mode behavior
    if (linkMode) {
        const id = hitTest(mx, my);
        if (id) {
            linkSourceId = id;
            isLinkDragging = true;
            linkPreviewX = mx;
            linkPreviewY = my;
            canvas.style.cursor = 'crosshair';
            return;
        } else {
            const lineHit = hitTestBezierLine(mx, my, 8);
            if (lineHit) {
                saveState();
                const fromComp = components.find(c => c.id === lineHit.fromId);
                if (fromComp) {
                    fromComp.deps = (fromComp.deps || []).filter(d => d !== lineHit.toId);
                    const toComp = components.find(c => c.id === lineHit.toId);
                    toast('Removed link: ' + fromComp.name + ' \u2192 ' + (toComp ? toComp.name : lineHit.toId));
                    if (selectedId) openDetail(selectedId);
                    updateComponentList();
                    draw();
                }
                return;
            }
            isPanning = true;
            panStartX = mx;
            panStartY = my;
            panCamStartX = camX;
            panCamStartY = camY;
            return;
        }
    }

    // Normal mode
    const id = hitTest(mx, my);
    if (id) {
        // Start drag
        dragId = id;
        const comp = components.find(c => c.id === id);
        const pos = dataToScreen(comp.x, comp.y);
        dragOffsetX = mx - pos.x;
        dragOffsetY = my - pos.y;
        selectedId = id;
        openDetail(id);
        updateComponentList();
        draw();
        canvas.style.cursor = 'grabbing';
    } else {
        selectedId = null;
        closeDetail();
        updateComponentList();
        draw();

        // Start pan with left click on empty space
        isPanning = true;
        panStartX = mx;
        panStartY = my;
        panCamStartX = camX;
        panCamStartY = camY;
    }
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (isPanning) {
        const dx = (mx - panStartX) / camZoom;
        const dy = (my - panStartY) / camZoom;
        camX = panCamStartX - dx;
        camY = panCamStartY - dy;
        draw();
        return;
    }

    // Link mode: dragging preview line
    if (linkMode && isLinkDragging) {
        linkPreviewX = mx;
        linkPreviewY = my;
        const targetId = hitTest(mx, my);
        hoveredId = targetId;
        canvas.style.cursor = targetId && targetId !== linkSourceId ? 'cell' : 'crosshair';
        draw();
        return;
    }

    if (dragId) {
        const comp = components.find(c => c.id === dragId);
        if (!comp) return;
        let data = screenToData(mx - dragOffsetX, my - dragOffsetY);
        if (snapToGrid) {
            data.x = Math.round(data.x * 20) / 20;
            data.y = Math.round(data.y * 20) / 20;
        }
        comp.x = data.x;
        comp.y = data.y;
        draw();
        return;
    }

    // Hover
    const id = hitTest(mx, my);
    if (linkMode) {
        if (id !== hoveredId) {
            hoveredId = id;
            draw();
        }
        if (!id) {
            const lineHit = hitTestBezierLine(mx, my, 8);
            canvas.style.cursor = lineHit ? 'pointer' : 'crosshair';
        } else {
            canvas.style.cursor = 'crosshair';
        }
    } else {
        if (id !== hoveredId) {
            hoveredId = id;
            canvas.style.cursor = id ? 'grab' : 'default';
            draw();
        }
    }
});

canvas.addEventListener('mouseup', e => {
    // Link mode: finish link drag
    if (linkMode && isLinkDragging && linkSourceId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const targetId = hitTest(mx, my);
        if (targetId && targetId !== linkSourceId) {
            const sourceComp = components.find(c => c.id === linkSourceId);
            if (sourceComp) {
                if (!(sourceComp.deps || []).includes(targetId)) {
                    saveState();
                    if (!sourceComp.deps) sourceComp.deps = [];
                    sourceComp.deps.push(targetId);
                    const targetComp = components.find(c => c.id === targetId);
                    toast('Linked: ' + sourceComp.name + ' \u2192 ' + (targetComp ? targetComp.name : targetId));
                    if (selectedId) openDetail(selectedId);
                    updateComponentList();
                } else {
                    toast('Link already exists');
                }
            }
        }
        linkSourceId = null;
        isLinkDragging = false;
        canvas.style.cursor = 'crosshair';
        draw();
        return;
    }

    if (dragId) {
        saveState();
        dragId = null;
        canvas.style.cursor = hoveredId ? 'grab' : (linkMode ? 'crosshair' : 'default');
        if (selectedId) openDetail(selectedId); // refresh position data
    }
    if (isPanning) {
        isPanning = false;
        canvas.style.cursor = linkMode ? 'crosshair' : 'default';
    }
});

canvas.addEventListener('dblclick', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const id = hitTest(mx, my);
    if (!id) {
        const data = screenToData(mx, my);
        showAddModal(data.x, data.y);
    }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

// Zoom
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.3, Math.min(4, camZoom * delta));

    // Zoom toward cursor
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const wx = (mx - W / 2) / camZoom + camX;
    const wy = (my - H / 2) / camZoom + camY;

    camZoom = newZoom;
    camX = wx - (mx - W / 2) / camZoom;
    camY = wy - (my - H / 2) / camZoom;

    draw();
}, { passive: false });

// Touch support
let touchDragId = null;
let lastTouchDist = 0;
let lastTouchCenter = null;

canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        const id = hitTest(mx, my);
        if (id) {
            touchDragId = id;
            const comp = components.find(c => c.id === id);
            const pos = dataToScreen(comp.x, comp.y);
            dragOffsetX = mx - pos.x;
            dragOffsetY = my - pos.y;
            selectedId = id;
            openDetail(id);
            draw();
            e.preventDefault();
        }
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.hypot(dx, dy);
        lastTouchCenter = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
        e.preventDefault();
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && touchDragId) {
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        const comp = components.find(c => c.id === touchDragId);
        if (comp) {
            let data = screenToData(mx - dragOffsetX, my - dragOffsetY);
            if (snapToGrid) {
                data.x = Math.round(data.x * 20) / 20;
                data.y = Math.round(data.y * 20) / 20;
            }
            comp.x = data.x;
            comp.y = data.y;
            draw();
        }
        e.preventDefault();
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        const scale = dist / lastTouchDist;
        camZoom = Math.max(0.3, Math.min(4, camZoom * scale));
        lastTouchDist = dist;
        draw();
        e.preventDefault();
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    if (touchDragId) {
        saveState();
        touchDragId = null;
        if (selectedId) openDetail(selectedId);
    }
});

// ── Keyboard Shortcuts ────────────────────────────────────
document.addEventListener('keydown', e => {
    // Don't intercept when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') {
            e.target.blur();
        }
        return;
    }

    if (e.key === 'F' && e.shiftKey) {
        e.preventDefault();
        forceDirectedLayout();
    } else if (e.key === 'a' || e.key === 'A') {
        showAddModal(0.5, 0.5);
    } else if (e.key === 'c') {
        toggleCompetitors();
    } else if (e.key === 'l') {
        toggleLegend();
    } else if (e.key === 'g') {
        toggleSnap();
    } else if (e.key === 'h') {
        toggleHeatmap();
    } else if (e.key === 'j') {
        toggleClusters();
    } else if (e.key === 't') {
        cycleTheme();
    } else if (e.key === 'k' || e.key === 'K') {
        toggleLinkMode();
    } else if (e.key === '/') {
        e.preventDefault();
        document.getElementById('searchInput').focus();
    } else if (e.key === 'm' || e.key === 'M') {
        toggleMinimap();
    } else if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedId) {
            const comp = components.find(c => c.id === selectedId);
            if (comp) {
                saveState();
                components = components.filter(c => c.id !== selectedId);
                for (const c of components) {
                    c.deps = (c.deps || []).filter(d => d !== selectedId);
                }
                toast('Deleted: ' + comp.name);
                selectedId = null;
                closeDetail();
                updateComponentList();
                draw();
            }
        }
    } else if (e.key === 'Escape') {
        if (linkMode) {
            toggleLinkMode();
        } else if (document.getElementById('addModal').classList.contains('visible')) {
            hideAddModal();
        } else {
            selectedId = null;
            closeDetail();
            updateComponentList();
            draw();
        }
        hideContextMenu();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        redo();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveMap();
    } else if (e.key === "t") {
        showSnapshotModal();
    } else if (e.key >= '1' && e.key <= '6') {
        const domains = Object.keys(DOMAIN_COLORS);
        const idx = parseInt(e.key) - 1;
        if (idx < domains.length) loadDomain(domains[idx]);
    }
});

// ── Search & Filter Wiring ───────────────────────────────
const searchInput = document.getElementById('searchInput');
const searchClear = document.getElementById('searchClear');
const filterHint = document.getElementById('filterHint');

searchInput.addEventListener('input', () => {
    searchQuery = searchInput.value.trim().toLowerCase();
    searchClear.classList.toggle('visible', searchInput.value.length > 0);
    filterHint.classList.toggle('visible', isFilterActive());
    updateComponentList();
    draw();
});

searchClear.addEventListener('click', () => {
    searchInput.value = '';
    searchQuery = '';
    searchClear.classList.remove('visible');
    filterHint.classList.toggle('visible', isFilterActive());
    updateComponentList();
    draw();
    searchInput.focus();
});

document.querySelectorAll('.evo-filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const stage = parseInt(btn.dataset.stage);
        if (activeStageFilters.has(stage)) {
            activeStageFilters.delete(stage);
            btn.classList.remove('active');
        } else {
            activeStageFilters.add(stage);
            btn.classList.add('active');
        }
        filterHint.classList.toggle('visible', isFilterActive());
        updateComponentList();
        draw();
    });
});

// Close context menu on click outside
document.addEventListener('click', e => {
    if (!contextMenu.contains(e.target)) hideContextMenu();
});

// ── Toolbar Buttons ───────────────────────────────────────
document.getElementById('btnUndo').addEventListener('click', undo);
document.getElementById('btnRedo').addEventListener('click', redo);
document.getElementById('btnAddNode').addEventListener('click', () => showAddModal(0.5, 0.5));
document.getElementById('btnLink').addEventListener('click', toggleLinkMode);
document.getElementById('btnLoadAll').addEventListener('click', loadAll);
document.getElementById('btnClearMap').addEventListener('click', clearMap);
document.getElementById('btnResetPositions').addEventListener('click', resetPositions);

document.getElementById('btnCompetitors').addEventListener('click', toggleCompetitors);
document.getElementById('btnLegend').addEventListener('click', toggleLegend);
document.getElementById('btnHeatmap').addEventListener('click', toggleHeatmap);
document.getElementById('btnCluster').addEventListener('click', toggleClusters);

function toggleCompetitors() {
    showCompetitors = !showCompetitors;
    document.getElementById('btnCompetitors').classList.toggle('active', showCompetitors);
    document.getElementById('competitorLegend').classList.toggle('visible', showCompetitors);
    draw();
}

function toggleLegend() {
    showLegend = !showLegend;
    document.getElementById('btnLegend').classList.toggle('active', showLegend);
    document.getElementById('mapLegend').classList.toggle('visible', showLegend);
}

document.getElementById('btnSnapGrid').addEventListener('click', toggleSnap);
function toggleSnap() {
    snapToGrid = !snapToGrid;
    document.getElementById('snapLabel').textContent = 'Snap to Grid: ' + (snapToGrid ? 'On' : 'Off');
    toast('Snap to grid: ' + (snapToGrid ? 'ON' : 'OFF'));
}

document.getElementById('detailClose').addEventListener('click', () => {
    selectedId = null;
    closeDetail();
    updateComponentList();
    draw();
});

// ── Save / Load ───────────────────────────────────────────
function saveMap() {
    const data = {
        version: 1,
        components: components,
        camera: { x: camX, y: camY, zoom: camZoom }
    };
    localStorage.setItem('wardley-aviation-map', JSON.stringify(data));

    // Also trigger download
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'wardley-aviation-map.json';
    a.click();
    URL.revokeObjectURL(url);
    toast('Map saved');
}

function loadMap() {
    const data = localStorage.getItem('wardley-aviation-map');
    if (!data) {
        toast('No saved map found');
        return;
    }
    try {
        const parsed = JSON.parse(data);
        components = parsed.components || [];
        if (parsed.camera) {
            camX = parsed.camera.x || 0;
            camY = parsed.camera.y || 0;
            camZoom = parsed.camera.zoom || 1;
        }
        selectedId = null;
        closeDetail();
        updateComponentList();
        draw();
        toast('Map loaded');
    } catch (err) {
        toast('Error loading map');
    }
}

document.getElementById('btnSave').addEventListener('click', saveMap);
document.getElementById('btnLoad').addEventListener('click', loadMap);

// ── Export: Enhanced PNG (2x with title, legend, white bg) ─
function renderExportCanvas() {
    const PAD = 40;
    const TITLE_AREA = 60;
    const LEGEND_AREA = 60;
    const scale = 2;
    const totalW = W + PAD * 2;
    const totalH = H + PAD * 2 + TITLE_AREA + LEGEND_AREA;

    const offCanvas = document.createElement('canvas');
    offCanvas.width = totalW * scale;
    offCanvas.height = totalH * scale;
    const offCtx = offCanvas.getContext('2d');
    offCtx.scale(scale, scale);

    // White background
    offCtx.fillStyle = '#ffffff';
    offCtx.fillRect(0, 0, totalW, totalH);

    // Title banner
    offCtx.fillStyle = '#1a1a2e';
    offCtx.font = 'bold 24px system-ui, -apple-system, sans-serif';
    offCtx.textAlign = 'left';
    offCtx.textBaseline = 'top';
    offCtx.fillText('Wardley Map \u2014 Aviation', PAD, PAD);

    const today = new Date();
    const dateStr = today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    offCtx.fillStyle = '#6e7681';
    offCtx.font = '14px system-ui, -apple-system, sans-serif';
    offCtx.fillText(dateStr, PAD, PAD + 30);

    offCtx.textAlign = 'right';
    offCtx.fillStyle = '#8b949e';
    offCtx.font = '13px system-ui';
    offCtx.fillText(components.length + ' components', totalW - PAD, PAD + 32);

    // Draw the map canvas
    const mapOffsetY = PAD + TITLE_AREA;
    offCtx.drawImage(canvas, PAD, mapOffsetY, W, H);

    // Evolution stage labels below map
    const stageY = mapOffsetY + H + 12;
    offCtx.textAlign = 'center';
    offCtx.font = '12px system-ui';
    for (const stage of EVOLUTION_STAGES) {
        const midX = PAD + mapX + ((stage.x0 + stage.x1) / 2) * mapW;
        offCtx.fillStyle = stage.color;
        offCtx.fillText(stage.label, midX, stageY);
    }
    offCtx.fillStyle = '#8b949e';
    offCtx.font = 'bold 11px system-ui';
    offCtx.fillText('Evolution \u2192', PAD + mapX + mapW / 2, stageY + 18);

    // Domain legend at bottom-left
    const legendY = stageY + 32;
    offCtx.textAlign = 'left';
    offCtx.font = 'bold 11px system-ui';
    offCtx.fillStyle = '#1a1a2e';
    offCtx.fillText('DOMAINS', PAD, legendY);

    let lx = PAD;
    const activeDomains = [...new Set(components.map(c => c.domain))];
    const domainsToShow = activeDomains.length > 0 ? activeDomains : Object.keys(DOMAIN_COLORS);
    offCtx.font = '11px system-ui';
    for (const dk of domainsToShow) {
        offCtx.fillStyle = DOMAIN_COLORS[dk];
        offCtx.beginPath();
        offCtx.arc(lx + 6, legendY + 18, 5, 0, Math.PI * 2);
        offCtx.fill();
        offCtx.fillStyle = '#1a1a2e';
        const lbl = DOMAIN_LABELS[dk];
        offCtx.fillText(lbl, lx + 16, legendY + 14);
        lx += offCtx.measureText(lbl).width + 32;
    }

    return offCanvas;
}

document.getElementById('btnExportPNG').addEventListener('click', () => {
    const offCanvas = renderExportCanvas();
    offCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'wardley-aviation-map.png';
        a.click();
        URL.revokeObjectURL(url);
        toast('Exported enhanced PNG (2x)');
    }, 'image/png');
});

// ── Copy to Clipboard ─────────────────────────────────────
document.getElementById('btnCopyClipboard').addEventListener('click', async () => {
    const offCanvas = renderExportCanvas();
    try {
        const blob = await new Promise(resolve => offCanvas.toBlob(resolve, 'image/png'));
        await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
        ]);
        toast('Map copied to clipboard');
    } catch (err) {
        toast('Clipboard copy failed \u2014 try PNG export instead');
        console.warn('Clipboard write failed:', err);
    }
});

// ── CSV Export ────────────────────────────────────────────
document.getElementById('btnExportCSV').addEventListener('click', () => {
    if (components.length === 0) { toast('No components to export'); return; }

    function csvField(val) {
        const str = String(val == null ? '' : val);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    }

    const header = ['name','domain','domain_label','evolution_x','value_chain_y','stage','annotation','description'];
    const rows = [header.join(',')];
    for (const comp of components) {
        const stage = EVOLUTION_STAGES.find(s => comp.x >= s.x0 && comp.x < s.x1) || EVOLUTION_STAGES[3];
        rows.push([
            csvField(comp.name),
            csvField(comp.domain),
            csvField(DOMAIN_LABELS[comp.domain] || comp.domain),
            csvField(comp.x.toFixed(3)),
            csvField(comp.y.toFixed(3)),
            csvField(stage.label),
            csvField(comp.annotation || ''),
            csvField(comp.desc || '')
        ].join(','));
    }

    const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'wardley-aviation-components.csv';
    a.click();
    URL.revokeObjectURL(url);
    toast('Exported CSV (' + components.length + ' components)');
});

// ── JSON Import ───────────────────────────────────────────
const jsonFileInput = document.getElementById('jsonFileInput');

document.getElementById('btnImportJSON').addEventListener('click', () => {
    jsonFileInput.value = '';
    jsonFileInput.click();
});

jsonFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    if (!file.name.endsWith('.json')) { toast('Please select a .json file'); return; }

    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            const data = JSON.parse(ev.target.result);
            if (!data.components || !Array.isArray(data.components)) {
                toast('Invalid file: missing components array'); return;
            }
            for (let i = 0; i < data.components.length; i++) {
                const c = data.components[i];
                if (typeof c.id !== 'string' || typeof c.name !== 'string') {
                    toast('Invalid component at index ' + i + ': missing id or name'); return;
                }
                if (typeof c.x !== 'number' || typeof c.y !== 'number') {
                    toast('Invalid component "' + c.name + '": missing x/y'); return;
                }
                if (typeof c.domain !== 'string') {
                    toast('Invalid component "' + c.name + '": missing domain'); return;
                }
            }
            saveState();
            components = data.components.map(c => ({
                id: c.id, name: c.name, domain: c.domain,
                x: Math.max(0, Math.min(1, c.x)),
                y: Math.max(0, Math.min(1, c.y)),
                deps: Array.isArray(c.deps) ? c.deps : [],
                desc: c.desc || '', annotation: c.annotation || '',
                arrow: c.arrow || null
            }));
            if (data.camera) {
                camX = data.camera.x || 0;
                camY = data.camera.y || 0;
                camZoom = data.camera.zoom || 1;
            }
            selectedId = null;
            closeDetail();
            updateComponentList();
            draw();
            toast('Imported ' + components.length + ' components from ' + file.name);
        } catch (err) {
            toast('Failed to parse JSON: ' + err.message);
        }
    };
    reader.onerror = () => toast('Failed to read file');
    reader.readAsText(file);
});



// ── Export: SVG ────────────────────────────────────────────
document.getElementById('btnExportSVG').addEventListener('click', () => {
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">`;
    svg += `<rect width="${W}" height="${H}" fill="${THEMES[currentTheme].canvasBg}"/>`;

    // Stage backgrounds
    for (const stage of EVOLUTION_STAGES) {
        const p0 = dataToScreen(stage.x0, 1);
        const p1 = dataToScreen(stage.x1, 0);
        svg += `<rect x="${p0.x}" y="${p0.y}" width="${p1.x - p0.x}" height="${p1.y - p0.y}" fill="${stage.color}" opacity="0.03"/>`;
    }

    // Dependencies (bezier curves with arrowheads)
    svg += '<defs><marker id="depArrow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6 Z" fill="#30363d" opacity="0.5"/></marker></defs>';
    for (const comp of components) {
        for (const depId of (comp.deps || [])) {
            const dep = components.find(c => c.id === depId);
            if (!dep) continue;
            const from = dataToScreen(comp.x, comp.y);
            const to = dataToScreen(dep.x, dep.y);
            const cp = getBezierControlPoint(from.x, from.y, to.x, to.y);
            svg += `<path d="M${from.x},${from.y} Q${cp.x},${cp.y} ${to.x},${to.y}" stroke="#30363d" stroke-opacity="0.5" fill="none" marker-end="url(#depArrow)"/>`;
        }
    }

    // Components
    for (const comp of components) {
        const pos = dataToScreen(comp.x, comp.y);
        const color = DOMAIN_COLORS[comp.domain] || '#8b949e';
        svg += `<circle cx="${pos.x}" cy="${pos.y}" r="18" fill="${color}" fill-opacity="0.35" stroke="${color}" stroke-width="1.5"/>`;
        svg += `<text x="${pos.x}" y="${pos.y + 28}" text-anchor="middle" fill="${THEMES[currentTheme].nodeText}" font-size="11" font-family="system-ui">${escSvg(comp.name)}</text>`;
    }

    // Axis labels
    const xLeft = dataToScreen(0, 0);
    const xRight = dataToScreen(1, 0);
    svg += `<text x="${(xLeft.x + xRight.x) / 2}" y="${xLeft.y + 38}" text-anchor="middle" fill="${THEMES[currentTheme].textMuted}" font-size="11" font-weight="bold" font-family="system-ui">Evolution →</text>`;

    for (const stage of EVOLUTION_STAGES) {
        const mid = dataToScreen((stage.x0 + stage.x1) / 2, 0);
        svg += `<text x="${mid.x}" y="${mid.y + 20}" text-anchor="middle" fill="${stage.color}" fill-opacity="0.6" font-size="11" font-family="system-ui">${stage.label}</text>`;
    }

    svg += '</svg>';

    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'wardley-aviation-map.svg';
    a.click();
    URL.revokeObjectURL(url);
    toast('Exported SVG');
});

function escSvg(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── Export: Strategy Document ──────────────────────────────
document.getElementById('btnExportDoc').addEventListener('click', () => {
    let doc = '# Wardley Map Strategy Document — Aviation\n\n';
    doc += `Generated: ${new Date().toISOString().split('T')[0]}\n\n`;
    doc += `## Map Overview\n\n`;
    doc += `- **Components**: ${components.length}\n`;
    doc += `- **Domains**: ${[...new Set(components.map(c => c.domain))].map(d => DOMAIN_LABELS[d]).join(', ')}\n\n`;

    // Group by domain
    const domains = [...new Set(components.map(c => c.domain))];
    for (const domain of domains) {
        const domComps = components.filter(c => c.domain === domain);
        doc += `## ${DOMAIN_LABELS[domain]}\n\n`;

        for (const comp of domComps.sort((a, b) => b.y - a.y)) {
            const stage = EVOLUTION_STAGES.find(s => comp.x >= s.x0 && comp.x < s.x1) || EVOLUTION_STAGES[3];
            doc += `### ${comp.name}\n`;
            doc += `- **Evolution**: ${stage.label} (${(comp.x * 100).toFixed(0)}%)\n`;
            doc += `- **Value Chain**: ${comp.y >= 0.7 ? 'Visible' : comp.y >= 0.4 ? 'Mid-chain' : 'Infrastructure'} (${(comp.y * 100).toFixed(0)}%)\n`;
            if (comp.desc) doc += `- **Description**: ${comp.desc}\n`;
            if (comp.annotation) doc += `- **Strategic Notes**: ${comp.annotation}\n`;
            if (comp.arrow) doc += `- **Movement**: ${comp.arrow === 'right' ? 'Evolving →' : 'De-evolving ←'}\n`;
            const deps = (comp.deps || []).map(d => components.find(c => c.id === d)).filter(Boolean);
            if (deps.length) doc += `- **Depends on**: ${deps.map(d => d.name).join(', ')}\n`;
            doc += '\n';
        }
    }

    // Competitor analysis
    if (showCompetitors) {
        doc += `## Competitor Analysis\n\n`;
        for (const [key, profile] of Object.entries(COMPETITOR_PROFILES)) {
            doc += `### ${profile.name}\n`;
            const emphasized = [];
            const deemphasized = [];
            for (const [compId, offset] of Object.entries(profile.offsets)) {
                const comp = components.find(c => c.id === compId);
                if (!comp) continue;
                if (offset.dx > 0) emphasized.push(comp.name);
                else if (offset.dx < 0) deemphasized.push(comp.name);
            }
            if (emphasized.length) doc += `- **More evolved**: ${emphasized.join(', ')}\n`;
            if (deemphasized.length) doc += `- **Less evolved**: ${deemphasized.join(', ')}\n`;
            doc += '\n';
        }
    }

    const blob = new Blob([doc], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'wardley-aviation-strategy.md';
    a.click();
    URL.revokeObjectURL(url);
    toast('Exported strategy document');
});

// ── Auto-Layout: Force-Directed ───────────────────────────
let layoutAnimId = null;

function forceDirectedLayout() {
    if (components.length < 2) {
        toast('Need at least 2 components for auto layout');
        return;
    }
    if (layoutAnimId) { cancelAnimationFrame(layoutAnimId); layoutAnimId = null; }
    saveState();
    const origX = {};
    for (const c of components) origX[c.id] = c.x;

    const totalIter = 120, repStr = 0.008, attrStr = 0.05, xAnch = 0.3, damp = 0.85, minD = 0.05;
    const vx = {}, vy = {};
    for (const c of components) { vx[c.id] = 0; vy[c.id] = 0; }

    const startPos = {}, simPos = {};
    for (const c of components) {
        startPos[c.id] = { x: c.x, y: c.y };
        simPos[c.id] = { x: c.x, y: c.y };
    }

    for (let iter = 0; iter < totalIter; iter++) {
        const temp = 1.0 - (iter / totalIter), step = temp * 0.5;
        const fx = {}, fy = {};
        for (const c of components) { fx[c.id] = 0; fy[c.id] = 0; }

        for (let i = 0; i < components.length; i++) {
            for (let j = i + 1; j < components.length; j++) {
                const a = components[i], b = components[j];
                let dx = simPos[a.id].x - simPos[b.id].x;
                let dy = simPos[a.id].y - simPos[b.id].y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 0.001) { dx = (Math.random() - 0.5) * 0.01; dy = (Math.random() - 0.5) * 0.01; dist = Math.sqrt(dx * dx + dy * dy); }
                const f = repStr / (Math.max(dist, minD) ** 2);
                const fdx = (dx / dist) * f, fdy = (dy / dist) * f;
                fx[a.id] += fdx; fy[a.id] += fdy;
                fx[b.id] -= fdx; fy[b.id] -= fdy;
            }
        }

        for (const c of components) {
            for (const depId of (c.deps || [])) {
                const dep = components.find(d => d.id === depId);
                if (!dep) continue;
                const dx = simPos[dep.id].x - simPos[c.id].x;
                const dy = simPos[dep.id].y - simPos[c.id].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 0.001) continue;
                const f = attrStr * dist;
                const fdx = (dx / dist) * f, fdy = (dy / dist) * f;
                fx[c.id] += fdx; fy[c.id] += fdy;
                fx[dep.id] -= fdx; fy[dep.id] -= fdy;
            }
        }

        for (const c of components) fx[c.id] += (origX[c.id] - simPos[c.id].x) * xAnch;

        for (const c of components) {
            vx[c.id] = (vx[c.id] + fx[c.id]) * damp * step;
            vy[c.id] = (vy[c.id] + fy[c.id]) * damp * step;
            simPos[c.id].x = Math.max(0.02, Math.min(0.98, simPos[c.id].x + vx[c.id]));
            simPos[c.id].y = Math.max(0.02, Math.min(0.98, simPos[c.id].y + vy[c.id]));
        }
    }

    const animStart = performance.now();
    function animateLayout(ts) {
        const t = Math.min(1, (ts - animStart) / 2000);
        const ease = 1 - Math.pow(1 - t, 3);
        for (const c of components) {
            c.x = startPos[c.id].x + (simPos[c.id].x - startPos[c.id].x) * ease;
            c.y = startPos[c.id].y + (simPos[c.id].y - startPos[c.id].y) * ease;
        }
        draw();
        if (t < 1) { layoutAnimId = requestAnimationFrame(animateLayout); }
        else { layoutAnimId = null; if (selectedId) openDetail(selectedId); toast('Auto layout complete'); }
    }
    layoutAnimId = requestAnimationFrame(animateLayout);
}

function spreadComponents() {
    if (components.length < 2) { toast('Need at least 2 components to spread'); return; }
    if (layoutAnimId) { cancelAnimationFrame(layoutAnimId); layoutAnimId = null; }
    saveState();
    const groups = {};
    for (const c of components) {
        let si = EVOLUTION_STAGES.findIndex(s => c.x >= s.x0 && c.x < s.x1);
        if (si === -1) si = EVOLUTION_STAGES.length - 1;
        if (!groups[si]) groups[si] = [];
        groups[si].push(c);
    }
    const startPos = {}, targetPos = {};
    for (const c of components) startPos[c.id] = { x: c.x, y: c.y };
    for (const [si, comps] of Object.entries(groups)) {
        comps.sort((a, b) => b.y - a.y);
        const n = comps.length, mg = 0.08, rng = 1 - 2 * mg;
        for (let i = 0; i < n; i++) {
            targetPos[comps[i].id] = { x: comps[i].x, y: n === 1 ? 0.5 : (1 - mg) - (i / (n - 1)) * rng };
        }
    }
    for (const c of components) if (!targetPos[c.id]) targetPos[c.id] = { x: c.x, y: c.y };
    const animStart = performance.now();
    function animateSpread(ts) {
        const t = Math.min(1, (ts - animStart) / 500);
        const ease = 1 - (1 - t) * (1 - t);
        for (const c of components) {
            c.x = startPos[c.id].x + (targetPos[c.id].x - startPos[c.id].x) * ease;
            c.y = startPos[c.id].y + (targetPos[c.id].y - startPos[c.id].y) * ease;
        }
        draw();
        if (t < 1) { layoutAnimId = requestAnimationFrame(animateSpread); }
        else { layoutAnimId = null; if (selectedId) openDetail(selectedId); toast('Components spread evenly'); }
    }
    layoutAnimId = requestAnimationFrame(animateSpread);
}

document.getElementById('btnForceLayout').addEventListener('click', forceDirectedLayout);
document.getElementById('btnSpread').addEventListener('click', spreadComponents);

// ── Window Reset (for enhance.js) ─────────────────────────
window.reset = function() {
    components = [];
    selectedId = null;
    closeDetail();
    camX = 0;
    camY = 0;
    camZoom = 1;
    undoStack = [];
    redoStack = [];
    updateComponentList();
    draw();
    toast('Map reset');
};

// ── Init ──────────────────────────────────────────────────
buildSidebar();
updateComponentList();
resize();

// Center camera
camX = mapX + mapW / 2;
camY = mapY + mapH / 2;
draw();

window.addEventListener('resize', () => {
    resize();
    camX = mapX + mapW / 2;
    camY = mapY + mapH / 2;
    draw();
});

// Auto-load from localStorage on startup
const saved = localStorage.getItem('wardley-aviation-map');
if (saved) {
    try {
        const parsed = JSON.parse(saved);
        if (parsed.components && parsed.components.length > 0) {
            // Don't auto-load, let user choose
        }
    } catch(e) {}
}


// ── Timeline Snapshots & Comparison ────────────────────────

var SNAPSHOT_STORAGE_KEY = 'wardley-aviation-snapshots';
var MAX_SNAPSHOTS = 20;
var snapshots = [];
var compareMode = false;
var compareSnapshotIndex = -1;

function loadSnapshots() {
    try {
        var raw = localStorage.getItem(SNAPSHOT_STORAGE_KEY);
        if (raw) {
            snapshots = JSON.parse(raw);
            if (!Array.isArray(snapshots)) snapshots = [];
        }
    } catch (e) {
        snapshots = [];
    }
    renderTimeline();
}

function persistSnapshots() {
    localStorage.setItem(SNAPSHOT_STORAGE_KEY, JSON.stringify(snapshots));
}

function showSnapshotModal() {
    var overlay = document.getElementById('snapshotModal');
    overlay.classList.add('visible');
    var nameInput = document.getElementById('snapshotName');
    nameInput.value = '';
    nameInput.focus();
    document.getElementById('snapshotCount').textContent =
        snapshots.length + ' of ' + MAX_SNAPSHOTS + ' snapshots used';
}

function hideSnapshotModal() {
    document.getElementById('snapshotModal').classList.remove('visible');
}

function createSnapshot() {
    var nameInput = document.getElementById('snapshotName');
    var name = nameInput.value.trim() || ('Snapshot ' + (snapshots.length + 1));

    if (snapshots.length >= MAX_SNAPSHOTS) {
        toast('Max ' + MAX_SNAPSHOTS + ' snapshots reached. Delete one first.');
        hideSnapshotModal();
        return;
    }

    var snapshot = {
        id: 'snap_' + Date.now(),
        name: name,
        timestamp: new Date().toISOString(),
        components: JSON.parse(JSON.stringify(components)),
        camera: { x: camX, y: camY, zoom: camZoom }
    };

    snapshots.push(snapshot);
    persistSnapshots();
    renderTimeline();
    hideSnapshotModal();
    toast('Snapshot saved: ' + name);
}

function loadSnapshotByIndex(index) {
    if (index < 0 || index >= snapshots.length) return;
    var snap = snapshots[index];

    saveState();
    components = JSON.parse(JSON.stringify(snap.components));

    if (snap.camera) {
        camX = snap.camera.x || 0;
        camY = snap.camera.y || 0;
        camZoom = snap.camera.zoom || 1;
    }

    selectedId = null;
    closeDetail();
    updateComponentList();
    draw();
    toast('Loaded: ' + snap.name);
    renderTimeline();
}

function deleteSnapshot(index) {
    if (index < 0 || index >= snapshots.length) return;
    var name = snapshots[index].name;
    snapshots.splice(index, 1);
    persistSnapshots();

    if (compareMode) {
        compareMode = false;
        document.getElementById('btnCompare').classList.remove('active');
        compareSnapshotIndex = -1;
    }

    renderTimeline();
    draw();
    toast('Deleted snapshot: ' + name);
}

function toggleCompareMode() {
    if (snapshots.length < 2) {
        toast('Need at least 2 snapshots to compare');
        return;
    }

    compareMode = !compareMode;
    document.getElementById('btnCompare').classList.toggle('active', compareMode);

    if (compareMode) {
        compareSnapshotIndex = snapshots.length - 2;
        toast('Compare ON — ghost from "' + snapshots[compareSnapshotIndex].name + '"');
    } else {
        compareSnapshotIndex = -1;
        toast('Compare mode OFF');
    }
    renderTimeline();
    draw();
}

function renderTimeline() {
    var bar = document.getElementById('timelineBar');
    var track = document.getElementById('timelineTrack');

    if (snapshots.length === 0) {
        bar.classList.remove('visible');
        return;
    }

    bar.classList.add('visible');

    var old = track.querySelectorAll('.timeline-dot, .tl-spacer');
    old.forEach(function(el) { el.remove(); });

    for (var i = 0; i < snapshots.length; i++) {
        var snap = snapshots[i];
        var dot = document.createElement('div');
        dot.className = 'timeline-dot';
        if (compareMode && i === compareSnapshotIndex) {
            dot.classList.add('active');
        }

        var d = new Date(snap.timestamp);
        var dateStr = d.toLocaleDateString(undefined, {
            month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
        });

        var tooltip = document.createElement('div');
        tooltip.className = 'timeline-tooltip';
        tooltip.innerHTML = '<strong>' + escHtml(snap.name) + '</strong>' +
            '<span class="snap-date">' + dateStr + '</span>';
        dot.appendChild(tooltip);

        if (i > 0) {
            var spacer = document.createElement('div');
            spacer.className = 'tl-spacer';
            spacer.style.flex = '1 1 auto';
            track.appendChild(spacer);
        }

        (function(idx) {
            dot.addEventListener('click', function(e) {
                e.stopPropagation();
                if (compareMode) {
                    compareSnapshotIndex = idx;
                    renderTimeline();
                    draw();
                    toast('Comparing against: ' + snapshots[idx].name);
                } else {
                    loadSnapshotByIndex(idx);
                }
            });
            dot.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                deleteSnapshot(idx);
            });
        })(i);

        track.appendChild(dot);
    }
}

function drawCompareOverlay() {
    if (!compareMode || compareSnapshotIndex < 0 || compareSnapshotIndex >= snapshots.length) return;

    var ghostComponents = snapshots[compareSnapshotIndex].components;
    if (!ghostComponents || !ghostComponents.length) return;

    var nodeRadius = 18 * camZoom;
    var fontSize = Math.max(8, 10 * camZoom);

    var currentById = {};
    for (var ci = 0; ci < components.length; ci++) {
        currentById[components[ci].id] = components[ci];
    }

    for (var gi = 0; gi < ghostComponents.length; gi++) {
        var ghost = ghostComponents[gi];
        var ghostPos = dataToScreen(ghost.x, ghost.y);
        var color = DOMAIN_COLORS[ghost.domain] || '#8b949e';
        var current = currentById[ghost.id];

        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(ghostPos.x, ghostPos.y, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = color + '33';
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 3]);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = '#8b949e';
        ctx.font = fontSize + 'px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(ghost.name, ghostPos.x, ghostPos.y + nodeRadius + 2);
        ctx.globalAlpha = 1.0;

        if (current) {
            var currentPos = dataToScreen(current.x, current.y);
            var dx = currentPos.x - ghostPos.x;
            var dy = currentPos.y - ghostPos.y;
            var dist = Math.hypot(dx, dy);

            if (dist > 5) {
                var angle = Math.atan2(dy, dx);

                ctx.strokeStyle = '#DDA15E';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(
                    ghostPos.x + Math.cos(angle) * (nodeRadius + 2),
                    ghostPos.y + Math.sin(angle) * (nodeRadius + 2)
                );
                ctx.lineTo(
                    currentPos.x - Math.cos(angle) * (nodeRadius + 6),
                    currentPos.y - Math.sin(angle) * (nodeRadius + 6)
                );
                ctx.stroke();
                ctx.setLineDash([]);

                var headLen = 10;
                var tipX = currentPos.x - Math.cos(angle) * (nodeRadius + 4);
                var tipY = currentPos.y - Math.sin(angle) * (nodeRadius + 4);
                ctx.fillStyle = '#DDA15E';
                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(tipX - headLen * Math.cos(angle - 0.35),
                           tipY - headLen * Math.sin(angle - 0.35));
                ctx.lineTo(tipX - headLen * Math.cos(angle + 0.35),
                           tipY - headLen * Math.sin(angle + 0.35));
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
    }
}

// Wire up snapshot toolbar buttons
document.getElementById('btnSnapshot').addEventListener('click', showSnapshotModal);
document.getElementById('btnCompare').addEventListener('click', toggleCompareMode);
document.getElementById('snapshotConfirm').addEventListener('click', createSnapshot);
document.getElementById('snapshotCancel').addEventListener('click', hideSnapshotModal);
document.getElementById('snapshotName').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') createSnapshot();
    if (e.key === 'Escape') hideSnapshotModal();
});

// Load snapshots from storage on init
loadSnapshots();


// ══════════════════════════════════════════════════════════════
// SMOOTH ANIMATIONS & TRANSITIONS
// ══════════════════════════════════════════════════════════════

function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

const compAnimState = {};
let selectionPulse = null;

// Camera momentum
let camVelX = 0, camVelY = 0;
let prevPanScreenX = 0, prevPanScreenY = 0;
let prevPanTime = 0;

// Smooth zoom
let zoomFrom = camZoom, zoomTo = camZoom;
let zoomStartTime = 0;
const ZOOM_DURATION = 150;
let zoomAnchorWX = 0, zoomAnchorWY = 0;
let zoomAnchorSX = 0, zoomAnchorSY = 0;

// rAF loop
let _animFrameId = null;
let _animRunning = false;

function _hasActiveAnimations(now) {
    for (const id in compAnimState) {
        if ((now - compAnimState[id].startTime - compAnimState[id].staggerDelay) < 400) return true;
    }
    if (selectionPulse) return true;
    if (Math.abs(camVelX) > 0.05 || Math.abs(camVelY) > 0.05) return true;
    if (zoomFrom !== zoomTo && (now - zoomStartTime) < ZOOM_DURATION) return true;
    return false;
}

function startAnimLoop() {
    if (_animRunning) return;
    _animRunning = true;
    _animFrameId = requestAnimationFrame(_animTick);
}

function _animTick(now) {
    if (!_animRunning) return;

    // 1. Entrance animations
    for (const id in compAnimState) {
        const a = compAnimState[id];
        const elapsed = now - a.startTime - a.staggerDelay;
        if (elapsed < 0) {
            a.opacity = 0;
            a.scale = 0.5;
        } else {
            const t = Math.min(1, elapsed / 400);
            const e = easeOutCubic(t);
            a.opacity = e;
            a.scale = 0.5 + 0.5 * e;
        }
    }

    // 2. Selection pulse expiry
    if (selectionPulse && (now - selectionPulse.startTime) >= 300) {
        selectionPulse = null;
    }

    // 3. Camera momentum
    if (Math.abs(camVelX) > 0.05 || Math.abs(camVelY) > 0.05) {
        camX -= camVelX;
        camY -= camVelY;
        camVelX *= 0.92;
        camVelY *= 0.92;
        if (Math.abs(camVelX) <= 0.05) camVelX = 0;
        if (Math.abs(camVelY) <= 0.05) camVelY = 0;
    }

    // 4. Smooth zoom
    if (zoomFrom !== zoomTo) {
        const elapsed = now - zoomStartTime;
        if (elapsed >= ZOOM_DURATION) {
            camZoom = zoomTo;
            zoomFrom = zoomTo;
        } else {
            const t = easeOutCubic(elapsed / ZOOM_DURATION);
            camZoom = zoomFrom + (zoomTo - zoomFrom) * t;
        }
        camX = zoomAnchorWX - (zoomAnchorSX - W / 2) / camZoom;
        camY = zoomAnchorWY - (zoomAnchorSY - H / 2) / camZoom;
    }

    // 5. Redraw
    draw();

    if (_hasActiveAnimations(now)) {
        _animFrameId = requestAnimationFrame(_animTick);
    } else {
        _animRunning = false;
        _animFrameId = null;
        draw();
    }
}

// Animated component drawing with entrance + pulse effects + search filter
function _drawComponentsAnimated() {
    const T = THEMES[currentTheme];
    const nodeRadiusBase = 18 * camZoom;
    const fontSizeBase = Math.max(9, 11 * camZoom);
    const filtering = isFilterActive();

    for (const comp of components) {
        const anim = compAnimState[comp.id];
        const opacity = anim ? anim.opacity : 1;
        const animScale = anim ? anim.scale : 1;
        const matches = !filtering || matchesFilter(comp);

        if (opacity <= 0.001) continue;

        const pos = dataToScreen(comp.x, comp.y);
        const color = DOMAIN_COLORS[comp.domain] || '#8b949e';
        const isSelected = comp.id === selectedId;
        const isHovered = comp.id === hoveredId;

        // Selection pulse scale
        let pulseScale = 1;
        if (selectionPulse && selectionPulse.id === comp.id) {
            const elapsed = performance.now() - selectionPulse.startTime;
            if (elapsed < 300) {
                const t = elapsed / 300;
                const peak = t < 0.35 ? (t / 0.35) : (1 - (t - 0.35) / 0.65);
                pulseScale = 1 + 0.2 * easeOutCubic(peak);
            }
        }

        const finalScale = animScale * pulseScale;
        const nodeRadius = nodeRadiusBase * finalScale;
        const fontSize = fontSizeBase * finalScale;

        ctx.save();
        ctx.globalAlpha = (matches ? 1.0 : 0.3) * opacity;

        if (isSelected && matches) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 16;
        }

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = isSelected ? color + 'cc' : isHovered ? color + '99' : color + '55';
        ctx.fill();
        ctx.strokeStyle = isSelected ? T.nodeText : color;
        ctx.lineWidth = isSelected ? 2.5 : 1.5;
        ctx.stroke();

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        ctx.fillStyle = T.nodeText;
        ctx.font = `${isSelected ? 'bold ' : ''}${fontSize}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        const maxLabelWidth = 120 * camZoom * finalScale;
        const words = comp.name.split(' ');
        let lines = [];
        let currentLine = '';
        for (const word of words) {
            const test = currentLine ? currentLine + ' ' + word : word;
            if (ctx.measureText(test).width > maxLabelWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = test;
            }
        }
        if (currentLine) lines.push(currentLine);

        const lineHeight = fontSize + 2;
        const labelY = pos.y + nodeRadius + 4;
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], pos.x, labelY + i * lineHeight);
        }

        if (comp.annotation) {
            ctx.fillStyle = '#DDA15E';
            ctx.beginPath();
            ctx.arc(pos.x + nodeRadius - 2, pos.y - nodeRadius + 2, 5 * finalScale, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}

// Reassign draw() to use animated component rendering
const _origDrawForAnim = draw;
draw = function() {
    ctx.clearRect(0, 0, W, H);
    ctx.save();

    const T = THEMES[currentTheme];
    ctx.fillStyle = T.canvasBg;
    ctx.fillRect(0, 0, W, H);

    drawGrid();
    drawHeatmapOverlay();
    drawClusterOverlay();
    drawDependencies();
    if (showCompetitors) drawCompetitors();
    _drawComponentsAnimated();
    drawMovementArrows();
    if (typeof compareMode !== "undefined" && compareMode) drawCompareOverlay();

    ctx.restore();
};

// Wrap loadDomain: staggered entrance animation
const _origLoadDomain = loadDomain;
loadDomain = function(domainKey) {
    const beforeIds = new Set(components.map(c => c.id));
    _origLoadDomain(domainKey);
    const now = performance.now();
    let idx = 0;
    for (const comp of components) {
        if (!beforeIds.has(comp.id) && !compAnimState[comp.id]) {
            compAnimState[comp.id] = { opacity: 0, scale: 0.5, startTime: now, staggerDelay: idx * 50 };
            idx++;
        }
    }
    if (idx > 0) startAnimLoop();
};

// Wrap loadAll: staggered entrance animation
const _origLoadAll = loadAll;
loadAll = function() {
    const beforeIds = new Set(components.map(c => c.id));
    _origLoadAll();
    const now = performance.now();
    let idx = 0;
    for (const comp of components) {
        if (!beforeIds.has(comp.id) && !compAnimState[comp.id]) {
            compAnimState[comp.id] = { opacity: 0, scale: 0.5, startTime: now, staggerDelay: idx * 50 };
            idx++;
        }
    }
    if (idx > 0) startAnimLoop();
};

// Wrap openDetail: selection pulse
const _origOpenDetail = openDetail;
openDetail = function(id) {
    selectionPulse = { id: id, startTime: performance.now() };
    startAnimLoop();
    _origOpenDetail(id);
};

// Camera momentum: velocity tracking during pan
canvas.addEventListener('mousemove', function(e) {
    if (!isPanning) {
        prevPanScreenX = 0;
        prevPanScreenY = 0;
        prevPanTime = 0;
        return;
    }
    const now = performance.now();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (prevPanTime > 0) {
        const dt = now - prevPanTime;
        if (dt > 0 && dt < 100) {
            camVelX = (mx - prevPanScreenX) / camZoom;
            camVelY = (my - prevPanScreenY) / camZoom;
        }
    }
    prevPanScreenX = mx;
    prevPanScreenY = my;
    prevPanTime = now;
}, true);

canvas.addEventListener('mouseup', function() {
    if (isPanning && !dragId) {
        if (Math.abs(camVelX) > 0.5 || Math.abs(camVelY) > 0.5) {
            startAnimLoop();
        } else {
            camVelX = 0;
            camVelY = 0;
        }
    } else {
        camVelX = 0;
        camVelY = 0;
    }
    prevPanTime = 0;
}, true);

canvas.addEventListener('mousedown', function() {
    camVelX = 0;
    camVelY = 0;
}, true);

// Smooth zoom: capture-phase wheel handler
canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const delta = e.deltaY > 0 ? 0.9 : 1.1;

    if (zoomFrom !== zoomTo) {
        const elapsed = performance.now() - zoomStartTime;
        if (elapsed < ZOOM_DURATION) {
            const t = easeOutCubic(elapsed / ZOOM_DURATION);
            zoomFrom = zoomFrom + (zoomTo - zoomFrom) * t;
        } else {
            zoomFrom = zoomTo;
        }
    } else {
        zoomFrom = camZoom;
    }

    zoomAnchorWX = (mx - W / 2) / camZoom + camX;
    zoomAnchorWY = (my - H / 2) / camZoom + camY;
    zoomAnchorSX = mx;
    zoomAnchorSY = my;

    zoomTo = Math.max(0.3, Math.min(4, zoomFrom * delta));
    zoomStartTime = performance.now();
    startAnimLoop();
}, { capture: true, passive: false });


// ══════════════════════════════════════════════════════════════
// MINIMAP OVERLAY
// ══════════════════════════════════════════════════════════════

let showMinimap = false;
const minimapContainer = document.getElementById('minimapContainer');
const minimapCanvas = document.getElementById('minimapCanvas');
const minimapCtx = minimapCanvas.getContext('2d');
const MM_W = 180;
const MM_H = 130;
const MM_PAD = 8;

(function() {
    const dpr = window.devicePixelRatio || 1;
    minimapCanvas.width = MM_W * dpr;
    minimapCanvas.height = MM_H * dpr;
    minimapCanvas.style.width = MM_W + 'px';
    minimapCanvas.style.height = MM_H + 'px';
    minimapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
})();

function toggleMinimap() {
    showMinimap = !showMinimap;
    minimapContainer.classList.toggle('visible', showMinimap);
    if (showMinimap) drawMinimap();
    toast('Minimap: ' + (showMinimap ? 'ON' : 'OFF'));
}

function dataToMM(dx, dy) {
    return {
        x: MM_PAD + dx * (MM_W - 2 * MM_PAD),
        y: MM_PAD + (1 - dy) * (MM_H - 2 * MM_PAD)
    };
}

function mmToData(mx, my) {
    return {
        x: Math.max(0, Math.min(1, (mx - MM_PAD) / (MM_W - 2 * MM_PAD))),
        y: Math.max(0, Math.min(1, 1 - (my - MM_PAD) / (MM_H - 2 * MM_PAD)))
    };
}

function drawMinimap() {
    if (!showMinimap) return;
    const mc = minimapCtx;
    mc.clearRect(0, 0, MM_W, MM_H);

    mc.fillStyle = 'rgba(13, 17, 23, 0.6)';
    mc.fillRect(0, 0, MM_W, MM_H);

    const tl = dataToMM(0, 1);
    const br = dataToMM(1, 0);
    mc.strokeStyle = '#30363d';
    mc.lineWidth = 0.5;
    mc.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);

    mc.setLineDash([2, 2]);
    mc.strokeStyle = '#30363d66';
    for (let i = 1; i < EVOLUTION_STAGES.length; i++) {
        const sx = EVOLUTION_STAGES[i].x0;
        const p1 = dataToMM(sx, 1);
        const p2 = dataToMM(sx, 0);
        mc.beginPath();
        mc.moveTo(p1.x, p1.y);
        mc.lineTo(p2.x, p2.y);
        mc.stroke();
    }
    mc.setLineDash([]);

    mc.lineWidth = 0.5;
    mc.strokeStyle = '#8b949e44';
    for (const comp of components) {
        for (const depId of (comp.deps || [])) {
            const dep = components.find(c => c.id === depId);
            if (!dep) continue;
            const from = dataToMM(comp.x, comp.y);
            const to = dataToMM(dep.x, dep.y);
            mc.beginPath();
            mc.moveTo(from.x, from.y);
            mc.lineTo(to.x, to.y);
            mc.stroke();
        }
    }

    for (const comp of components) {
        const pos = dataToMM(comp.x, comp.y);
        const color = DOMAIN_COLORS[comp.domain] || '#8b949e';
        mc.beginPath();
        mc.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
        mc.fillStyle = comp.id === selectedId ? '#ffffff' : color;
        mc.fill();
    }

    const tlData = screenToData(0, 0);
    const brData = screenToData(W, H);
    const vx0 = Math.max(0, Math.min(1, tlData.x));
    const vy1 = Math.max(0, Math.min(1, tlData.y));
    const vx1 = Math.max(0, Math.min(1, brData.x));
    const vy0 = Math.max(0, Math.min(1, brData.y));

    const vpTL = dataToMM(vx0, vy1);
    const vpBR = dataToMM(vx1, vy0);
    const vpW = vpBR.x - vpTL.x;
    const vpH = vpBR.y - vpTL.y;

    mc.fillStyle = 'rgba(255, 255, 255, 0.08)';
    mc.fillRect(vpTL.x, vpTL.y, vpW, vpH);
    mc.strokeStyle = 'rgba(255, 255, 255, 0.45)';
    mc.lineWidth = 1;
    mc.strokeRect(vpTL.x, vpTL.y, vpW, vpH);
}

function minimapPanTo(dx, dy) {
    camX = mapX + dx * mapW;
    camY = mapY + (1 - dy) * mapH;
    draw();
}

let mmDragging = false;

function handleMMPointer(e) {
    const rect = minimapCanvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (MM_W / rect.width);
    const my = (e.clientY - rect.top) * (MM_H / rect.height);
    const data = mmToData(mx, my);
    minimapPanTo(data.x, data.y);
}

minimapContainer.addEventListener('mousedown', function(e) {
    e.stopPropagation();
    e.preventDefault();
    mmDragging = true;
    handleMMPointer(e);
});

document.addEventListener('mousemove', function(e) {
    if (!mmDragging) return;
    e.preventDefault();
    handleMMPointer(e);
});

document.addEventListener('mouseup', function() {
    mmDragging = false;
});

minimapContainer.addEventListener('touchstart', function(e) {
    e.stopPropagation();
    e.preventDefault();
    mmDragging = true;
    handleMMPointer(e.touches[0]);
}, { passive: false });

minimapContainer.addEventListener('touchmove', function(e) {
    if (!mmDragging) return;
    e.preventDefault();
    handleMMPointer(e.touches[0]);
}, { passive: false });

minimapContainer.addEventListener('touchend', function() {
    mmDragging = false;
}, { passive: false });

// Wrap draw() to also update minimap
const _origDrawForMinimap = draw;
draw = function() {
    _origDrawForMinimap();
    drawMinimap();
};

})();
</script>
<script>
// ══════════════════════════════════════════════════════════════
// INTERACTIVE ONBOARDING TUTORIAL
// ══════════════════════════════════════════════════════════════
// ══════════════════════════════════════════════════════════════
// WARDLEY MAP BUILDER — INTERACTIVE ONBOARDING TUTORIAL
// ══════════════════════════════════════════════════════════════
//
// Inject this AFTER the main app IIFE in index.html.
// It references existing DOM IDs: domainList, mapCanvas, mapArea,
// btnCompetitors, btnExportDoc, and the toast() function.
//
// Sections: CSS | HTML | JS
// ══════════════════════════════════════════════════════════════

// ── CSS ──────────────────────────────────────────────────────
(function injectTutorialCSS() {
    const style = document.createElement('style');
    style.textContent = `
/* ── Tutorial Overlay ────────────────────────────────────── */
.tut-overlay {
    position: fixed;
    inset: 0;
    z-index: 9000;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.tut-overlay.active {
    pointer-events: auto;
}
.tut-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

/* Dark backdrop rendered via SVG mask for the spotlight cutout */
.tut-backdrop {
    position: fixed;
    inset: 0;
    z-index: 9001;
    pointer-events: auto;
}

/* ── Tooltip ─────────────────────────────────────────────── */
.tut-tooltip {
    position: fixed;
    z-index: 9010;
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 12px;
    padding: 20px 24px 16px;
    max-width: 360px;
    min-width: 280px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
    color: #c9d1d9;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 0.25s ease, transform 0.25s ease;
    pointer-events: auto;
}
.tut-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
}

.tut-tooltip-step {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #8A9A5B;
    margin-bottom: 8px;
    font-weight: 600;
}
.tut-tooltip-title {
    font-size: 1rem;
    font-weight: 600;
    color: #e6edf3;
    margin-bottom: 8px;
    line-height: 1.3;
}
.tut-tooltip-body {
    font-size: 0.85rem;
    color: #8b949e;
    line-height: 1.55;
    margin-bottom: 16px;
}

.tut-tooltip-nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    border-top: 1px solid #30363d;
    padding-top: 12px;
}
.tut-tooltip-dots {
    display: flex;
    gap: 5px;
}
.tut-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: #30363d;
    transition: background 0.2s;
}
.tut-dot.active {
    background: #8A9A5B;
}
.tut-dot.done {
    background: #606C38;
}

.tut-tooltip-buttons {
    display: flex;
    gap: 6px;
}
.tut-btn {
    padding: 5px 14px;
    border: 1px solid #30363d;
    background: #21262d;
    color: #c9d1d9;
    border-radius: 6px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
    font-family: inherit;
}
.tut-btn:hover {
    background: #30363d;
    border-color: #8b949e;
}
.tut-btn-primary {
    background: #606C38;
    border-color: #8A9A5B;
    color: #FEFAE0;
}
.tut-btn-primary:hover {
    background: #8A9A5B;
}
.tut-btn-skip {
    background: none;
    border: none;
    color: #6e7681;
    font-size: 0.75rem;
    padding: 5px 8px;
}
.tut-btn-skip:hover {
    color: #c9d1d9;
}

/* ── Welcome overlay (step 1 centered card) ──────────────── */
.tut-welcome {
    position: fixed;
    inset: 0;
    z-index: 9010;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
}
.tut-welcome-card {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 16px;
    padding: 32px 36px 24px;
    max-width: 440px;
    text-align: center;
    box-shadow: 0 16px 48px rgba(0,0,0,0.6);
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.3s ease, transform 0.3s ease;
}
.tut-welcome-card.visible {
    opacity: 1;
    transform: scale(1);
}
.tut-welcome-icon {
    font-size: 2.2rem;
    margin-bottom: 12px;
    display: block;
}
.tut-welcome-card h2 {
    font-size: 1.2rem;
    color: #e6edf3;
    margin-bottom: 12px;
    font-weight: 600;
}
.tut-welcome-card p {
    font-size: 0.88rem;
    color: #8b949e;
    line-height: 1.6;
    margin-bottom: 24px;
}
.tut-welcome-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}

/* ── Help/replay button in toolbar ───────────────────────── */
.tut-help-btn {
    padding: 5px 10px;
    border: 1px solid #30363d;
    background: #21262d;
    color: #c9d1d9;
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.15s;
    font-weight: 600;
    font-family: inherit;
    line-height: 1;
}
.tut-help-btn:hover {
    background: #30363d;
    border-color: #8b949e;
    color: #e6edf3;
}

/* ── Spotlight pulse ring ────────────────────────────────── */
@keyframes tut-pulse {
    0%   { box-shadow: 0 0 0 0 rgba(138,154,91,0.4); }
    70%  { box-shadow: 0 0 0 10px rgba(138,154,91,0); }
    100% { box-shadow: 0 0 0 0 rgba(138,154,91,0); }
}
.tut-spotlight-ring {
    position: fixed;
    z-index: 9005;
    border: 2px solid #8A9A5B;
    border-radius: 8px;
    pointer-events: none;
    animation: tut-pulse 2s infinite;
    transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
}
`;
    document.head.appendChild(style);
})();


// ── HTML (injected dynamically) ──────────────────────────────
// ── JS  (tutorial engine) ────────────────────────────────────
(function initTutorial() {
    'use strict';

    // -- Tutorial step definitions --
    const STEPS = [
        {
            // Step 1: Welcome overlay (centered, no highlight)
            type: 'welcome',
            title: 'Welcome to Wardley Map Builder',
            body: 'Wardley Maps are a strategic planning tool that visualises the components needed to serve user needs, plotted by their position in the value chain (visibility) and their evolutionary stage (maturity). This builder lets you explore, customise, and export aviation-industry Wardley Maps interactively.',
        },
        {
            // Step 2: Domain list
            type: 'highlight',
            target: '#domainList',
            title: 'Aviation Domains',
            body: 'Click any domain to load its aviation components onto the map. Each domain (Maintenance, Crew, Scheduling, Revenue, Flight Ops, Passenger) contains pre-configured components with realistic positions and dependencies.',
            placement: 'right',
        },
        {
            // Step 3: Canvas — drag
            type: 'highlight',
            target: '#mapArea',
            title: 'The Map Canvas',
            body: 'Drag components to reposition them along the evolution axis (horizontal) and value chain (vertical). Scroll to zoom, or click-and-drag empty space to pan around the map.',
            placement: 'left',
        },
        {
            // Step 4: Canvas — right-click
            type: 'highlight',
            target: '#mapArea',
            title: 'Context Menu',
            body: 'Right-click any component for a context menu with options to annotate, add movement arrows, duplicate, or delete. Double-click empty space to add a new custom component.',
            placement: 'left',
        },
        {
            // Step 5: Competitors button
            type: 'highlight',
            target: '#btnCompetitors',
            title: 'Competitor Overlays',
            body: 'Toggle competitor overlays to visualise how Full-Service Carriers, Low-Cost Carriers, and Ultra-Low-Cost Carriers position the same components differently on the evolution axis.',
            placement: 'bottom',
        },
        {
            // Step 6: Strategy Doc button
            type: 'highlight',
            target: '#btnExportDoc',
            title: 'Export Strategy Document',
            body: 'Export your current map as a formatted Markdown strategy document including component details, evolution stages, annotations, and competitor analysis.',
            placement: 'bottom',
        },
    ];

    let currentStep = -1;
    let overlayEl = null;
    let backdropSvg = null;
    let tooltipEl = null;
    let welcomeEl = null;
    let spotlightRing = null;
    let isRunning = false;

    // -- Build DOM elements --
    function buildDOM() {
        // Overlay container
        overlayEl = document.createElement('div');
        overlayEl.className = 'tut-overlay hidden';

        // SVG backdrop with mask cutout
        backdropSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        backdropSvg.setAttribute('class', 'tut-backdrop');
        backdropSvg.style.width = '100%';
        backdropSvg.style.height = '100%';
        backdropSvg.innerHTML = `
            <defs>
                <mask id="tut-mask">
                    <rect width="100%" height="100%" fill="white"/>
                    <rect id="tut-cutout" x="0" y="0" width="0" height="0" rx="8" fill="black"/>
                </mask>
            </defs>
            <rect width="100%" height="100%" fill="rgba(0,0,0,0.7)" mask="url(#tut-mask)"/>
        `;
        overlayEl.appendChild(backdropSvg);

        // Spotlight ring
        spotlightRing = document.createElement('div');
        spotlightRing.className = 'tut-spotlight-ring';
        spotlightRing.style.display = 'none';
        overlayEl.appendChild(spotlightRing);

        // Tooltip
        tooltipEl = document.createElement('div');
        tooltipEl.className = 'tut-tooltip';
        overlayEl.appendChild(tooltipEl);

        // Welcome overlay
        welcomeEl = document.createElement('div');
        welcomeEl.className = 'tut-welcome';
        welcomeEl.style.display = 'none';
        overlayEl.appendChild(welcomeEl);

        document.body.appendChild(overlayEl);
    }

    // -- Position the SVG cutout around a target element --
    function positionCutout(targetEl) {
        const cutout = document.getElementById('tut-cutout');
        if (!targetEl || !cutout) {
            cutout.setAttribute('width', '0');
            cutout.setAttribute('height', '0');
            spotlightRing.style.display = 'none';
            return;
        }
        const rect = targetEl.getBoundingClientRect();
        const pad = 6;
        cutout.setAttribute('x', rect.left - pad);
        cutout.setAttribute('y', rect.top - pad);
        cutout.setAttribute('width', rect.width + pad * 2);
        cutout.setAttribute('height', rect.height + pad * 2);

        spotlightRing.style.display = 'block';
        spotlightRing.style.left = (rect.left - pad) + 'px';
        spotlightRing.style.top = (rect.top - pad) + 'px';
        spotlightRing.style.width = (rect.width + pad * 2) + 'px';
        spotlightRing.style.height = (rect.height + pad * 2) + 'px';
    }

    // -- Position tooltip relative to target --
    function positionTooltip(targetEl, placement) {
        if (!targetEl) return;
        const rect = targetEl.getBoundingClientRect();
        const gap = 14;

        // Reset for measurement
        tooltipEl.style.left = '0px';
        tooltipEl.style.top = '0px';
        tooltipEl.classList.add('visible');
        const tw = tooltipEl.offsetWidth;
        const th = tooltipEl.offsetHeight;

        let left, top;

        switch (placement) {
            case 'right':
                left = rect.right + gap;
                top = rect.top + rect.height / 2 - th / 2;
                break;
            case 'left':
                left = rect.left - tw - gap;
                top = rect.top + rect.height / 2 - th / 2;
                break;
            case 'bottom':
                left = rect.left + rect.width / 2 - tw / 2;
                top = rect.bottom + gap;
                break;
            case 'top':
                left = rect.left + rect.width / 2 - tw / 2;
                top = rect.top - th - gap;
                break;
            default:
                left = rect.right + gap;
                top = rect.top;
        }

        // Clamp to viewport
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        if (left + tw > vw - 12) left = vw - tw - 12;
        if (left < 12) left = 12;
        if (top + th > vh - 12) top = vh - th - 12;
        if (top < 12) top = 12;

        tooltipEl.style.left = left + 'px';
        tooltipEl.style.top = top + 'px';
    }

    // -- Render dots for step navigation --
    function renderDots() {
        let html = '';
        for (let i = 0; i < STEPS.length; i++) {
            const cls = i === currentStep ? 'active' : i < currentStep ? 'done' : '';
            html += `<span class="tut-dot ${cls}"></span>`;
        }
        return html;
    }

    // -- Show a specific step --
    function showStep(idx) {
        currentStep = idx;
        if (idx < 0 || idx >= STEPS.length) {
            endTutorial();
            return;
        }

        const step = STEPS[idx];

        // Show overlay
        overlayEl.classList.remove('hidden');
        overlayEl.classList.add('active');

        if (step.type === 'welcome') {
            // Hide tooltip, show welcome card
            tooltipEl.classList.remove('visible');
            tooltipEl.style.display = 'none';
            spotlightRing.style.display = 'none';
            const cutout = document.getElementById('tut-cutout');
            if (cutout) {
                cutout.setAttribute('width', '0');
                cutout.setAttribute('height', '0');
            }

            welcomeEl.style.display = 'flex';
            welcomeEl.innerHTML = `
                <div class="tut-welcome-card">
                    <span class="tut-welcome-icon">\u{1F5FA}</span>
                    <h2>${step.title}</h2>
                    <p>${step.body}</p>
                    <div class="tut-welcome-actions">
                        <button class="tut-btn tut-btn-skip" id="tutSkipWelcome">Skip tutorial</button>
                        <button class="tut-btn tut-btn-primary" id="tutStartWelcome">Get Started</button>
                    </div>
                </div>
            `;
            requestAnimationFrame(() => {
                const card = welcomeEl.querySelector('.tut-welcome-card');
                if (card) card.classList.add('visible');
            });

            document.getElementById('tutStartWelcome').addEventListener('click', () => showStep(1));
            document.getElementById('tutSkipWelcome').addEventListener('click', () => endTutorial());
            return;
        }

        // Highlight steps
        welcomeEl.style.display = 'none';
        tooltipEl.style.display = '';
        tooltipEl.classList.remove('visible');

        const targetEl = document.querySelector(step.target);
        positionCutout(targetEl);

        // Build tooltip content
        const isFirst = idx === 0;
        const isLast = idx === STEPS.length - 1;

        tooltipEl.innerHTML = `
            <div class="tut-tooltip-step">Step ${idx} of ${STEPS.length - 1}</div>
            <div class="tut-tooltip-title">${step.title}</div>
            <div class="tut-tooltip-body">${step.body}</div>
            <div class="tut-tooltip-nav">
                <div class="tut-tooltip-dots">${renderDots()}</div>
                <div class="tut-tooltip-buttons">
                    <button class="tut-btn tut-btn-skip" id="tutSkipBtn">Skip</button>
                    ${idx > 1 ? '<button class="tut-btn" id="tutBackBtn">Back</button>' : ''}
                    <button class="tut-btn tut-btn-primary" id="tutNextBtn">${isLast ? 'Done' : 'Next'}</button>
                </div>
            </div>
        `;

        positionTooltip(targetEl, step.placement);

        // Animate in
        requestAnimationFrame(() => {
            tooltipEl.classList.add('visible');
        });

        // Bind buttons
        document.getElementById('tutNextBtn').addEventListener('click', () => {
            if (isLast) endTutorial();
            else showStep(idx + 1);
        });
        document.getElementById('tutSkipBtn').addEventListener('click', () => endTutorial());
        const backBtn = document.getElementById('tutBackBtn');
        if (backBtn) backBtn.addEventListener('click', () => showStep(idx - 1));
    }

    // -- End tutorial --
    function endTutorial() {
        isRunning = false;
        currentStep = -1;
        overlayEl.classList.add('hidden');
        overlayEl.classList.remove('active');
        tooltipEl.classList.remove('visible');
        welcomeEl.style.display = 'none';
        spotlightRing.style.display = 'none';
        localStorage.setItem('wardley-tutorial-done', '1');

        // Use the app's existing toast if available
        if (typeof window.toast === 'function') {
            // Not accessible from IIFE — use DOM toast
        }
        const toastEl = document.getElementById('toast');
        if (toastEl) {
            toastEl.textContent = 'Tutorial complete — press ? to replay';
            toastEl.classList.add('show');
            setTimeout(() => toastEl.classList.remove('show'), 2500);
        }
    }

    // -- Start tutorial --
    function startTutorial() {
        if (isRunning) return;
        isRunning = true;
        buildDOM();
        showStep(0);
    }

    // -- Replay (rebuild DOM each time for clean state) --
    function replayTutorial() {
        if (isRunning) return;
        // Remove old overlay if exists
        if (overlayEl && overlayEl.parentNode) {
            overlayEl.parentNode.removeChild(overlayEl);
        }
        overlayEl = null;
        isRunning = false;
        startTutorial();
    }

    // -- Inject "?" help button into toolbar --
    (function injectHelpButton() {
        const toolbar = document.querySelector('.top-bar');
        if (!toolbar) return;

        // Add separator + button
        const sep = document.createElement('div');
        sep.className = 'toolbar-sep';
        toolbar.appendChild(sep);

        const btn = document.createElement('button');
        btn.className = 'tut-help-btn';
        btn.title = 'Replay onboarding tutorial';
        btn.textContent = '?';
        btn.addEventListener('click', replayTutorial);
        toolbar.appendChild(btn);
    })();

    // -- Handle window resize while tutorial is active --
    window.addEventListener('resize', () => {
        if (!isRunning || currentStep < 0 || currentStep >= STEPS.length) return;
        const step = STEPS[currentStep];
        if (step.type === 'highlight' && step.target) {
            const targetEl = document.querySelector(step.target);
            positionCutout(targetEl);
            positionTooltip(targetEl, step.placement);
        }
    });

    // -- Keyboard: Escape to skip, ArrowRight/ArrowLeft to navigate --
    document.addEventListener('keydown', (e) => {
        if (!isRunning) return;
        if (e.key === 'Escape') {
            e.stopPropagation();
            endTutorial();
        } else if (e.key === 'ArrowRight' || e.key === 'Enter') {
            e.stopPropagation();
            if (currentStep >= STEPS.length - 1) endTutorial();
            else showStep(currentStep + 1);
        } else if (e.key === 'ArrowLeft') {
            e.stopPropagation();
            if (currentStep > 0) showStep(currentStep - 1);
        }
    }, true); // capture phase so it runs before the app's handler

    // -- Auto-show on first visit --
    if (!localStorage.getItem('wardley-tutorial-done')) {
        // Small delay to let the app finish initialising
        setTimeout(startTutorial, 600);
    }

})();

</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
