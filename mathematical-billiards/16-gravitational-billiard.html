<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gravitational Billiard - Parabolic Arcs Under Gravity</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120, 160, 255, 0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 230px; max-height: 90vh; overflow-y: auto;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#info { position: fixed; bottom: 20px; left: 20px; z-index: 100; font-size: 0.8em; color: #6a8; background: rgba(10,14,30,0.6); backdrop-filter: blur(10px); padding: 10px 14px; border-radius: 8px; max-width: 420px; line-height: 1.5; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Gravitational Billiard</h3>
  <div class="ctrl-row">
    <label>Gravity Strength <span class="val" id="vGrav">0.30</span></label>
    <input type="range" id="sGrav" min="0" max="1.0" step="0.01" value="0.30">
  </div>
  <div class="ctrl-row">
    <label>Trail Length <span class="val" id="vTrail">3000</span></label>
    <input type="range" id="sTrail" min="100" max="8000" step="100" value="3000">
  </div>
  <div class="ctrl-row">
    <label>Ball Speed <span class="val" id="vSpeed">5</span></label>
    <input type="range" id="sSpeed" min="1" max="12" step="0.5" value="5">
  </div>
  <div style="margin-top:8px;">
    <label style="font-size:0.8em; color:#8ab;">Container Shape</label>
    <div style="margin-top:4px;">
      <button class="btn active" data-shape="circle">Circle</button>
      <button class="btn" data-shape="rect">Rectangle</button>
      <button class="btn" data-shape="wedge">Wedge</button>
    </div>
  </div>
  <div style="margin-top:10px;">
    <button class="btn" id="bClear">Clear Trails</button>
    <button class="btn" id="bReset">Reset</button>
  </div>
  <p style="font-size:0.7em; color:#68a; margin-top:10px;">Click inside the container to launch a ball</p>
</div>
<div id="info">
  <strong style="color:#8af;">Gravitational Billiard:</strong> A ball bounces inside a container under the influence of gravity. Instead of straight-line paths, the ball follows parabolic arcs between bounces, creating rich, flowing patterns. At zero gravity this reduces to a standard billiard.
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R;
let gravity = 0.30;
let speed = 5;
let maxTrail = 3000;
let shape = 'circle';
let ball = null;
let trail = [];
let bounces = 0;
let paused = false;
const dt = 0.3;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  cx = W / 2;
  cy = H / 2;
  R = Math.min(W, H) * 0.38;
}
resize();
window.addEventListener('resize', resize);

function initBall(x, y, angle) {
  if (x === undefined) {
    x = cx;
    y = cy - R * 0.3;
  }
  if (angle === undefined) angle = Math.random() * Math.PI * 2;
  ball = { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed };
  trail = [{ x: ball.x, y: ball.y, spd: speed }];
  bounces = 0;
}

function getShapeButtons() {
  return document.querySelectorAll('[data-shape]');
}

getShapeButtons().forEach(b => {
  b.addEventListener('click', () => {
    getShapeButtons().forEach(bb => bb.classList.remove('active'));
    b.classList.add('active');
    shape = b.dataset.shape;
    initBall();
  });
});

document.getElementById('sGrav').addEventListener('input', e => {
  gravity = parseFloat(e.target.value);
  document.getElementById('vGrav').textContent = gravity.toFixed(2);
});
document.getElementById('sTrail').addEventListener('input', e => {
  maxTrail = parseInt(e.target.value);
  document.getElementById('vTrail').textContent = maxTrail;
});
document.getElementById('sSpeed').addEventListener('input', e => {
  speed = parseFloat(e.target.value);
  document.getElementById('vSpeed').textContent = speed;
});
document.getElementById('bClear').addEventListener('click', () => { trail = []; });
document.getElementById('bReset').addEventListener('click', () => { initBall(); });

canvas.addEventListener('click', e => {
  const mx = e.clientX, my = e.clientY;
  if (isInside(mx, my)) {
    const angle = Math.atan2(my - cy, mx - cx) + Math.PI / 2;
    initBall(mx, my, angle);
  }
});

function isInside(x, y) {
  if (shape === 'circle') {
    return Math.hypot(x - cx, y - cy) < R;
  } else if (shape === 'rect') {
    return Math.abs(x - cx) < R && Math.abs(y - cy) < R * 0.7;
  } else {
    // wedge: triangle
    const hw = R * 1.0, hh = R * 0.9;
    const lx = x - cx, ly = y - (cy + hh * 0.3);
    if (ly > hh * 0.5 || ly < -hh * 0.5) return false;
    const wr = hw * (0.5 - ly / hh);
    return Math.abs(lx) < wr;
  }
}

function reflectCircle() {
  const dx = ball.x - cx, dy = ball.y - cy;
  const dist = Math.hypot(dx, dy);
  if (dist >= R) {
    const nx = dx / dist, ny = dy / dist;
    ball.x = cx + nx * (R - 1);
    ball.y = cy + ny * (R - 1);
    const dot = ball.vx * nx + ball.vy * ny;
    ball.vx -= 2 * dot * nx;
    ball.vy -= 2 * dot * ny;
    bounces++;
  }
}

function reflectRect() {
  const hw = R, hh = R * 0.7;
  const left = cx - hw, right = cx + hw, top = cy - hh, bottom = cy + hh;
  if (ball.x <= left) { ball.x = left + 1; ball.vx = Math.abs(ball.vx); bounces++; }
  if (ball.x >= right) { ball.x = right - 1; ball.vx = -Math.abs(ball.vx); bounces++; }
  if (ball.y <= top) { ball.y = top + 1; ball.vy = Math.abs(ball.vy); bounces++; }
  if (ball.y >= bottom) { ball.y = bottom - 1; ball.vy = -Math.abs(ball.vy); bounces++; }
}

function reflectWedge() {
  const hh = R * 0.9;
  const centerY = cy + hh * 0.3;
  const topY = centerY - hh * 0.5;
  const bottomY = centerY + hh * 0.5;

  if (ball.y <= topY) { ball.y = topY + 1; ball.vy = Math.abs(ball.vy); bounces++; }
  if (ball.y >= bottomY) { ball.y = bottomY - 1; ball.vy = -Math.abs(ball.vy); bounces++; }

  const ly = ball.y - centerY;
  const hw = R * (0.5 - ly / hh);
  if (ball.x <= cx - hw) {
    const slope = R / hh;
    const len = Math.sqrt(1 + slope * slope);
    const nx = 1 / len, ny = slope / len;
    const dot = ball.vx * nx + ball.vy * ny;
    ball.vx -= 2 * dot * nx;
    ball.vy -= 2 * dot * ny;
    ball.x = cx - hw + 2;
    bounces++;
  }
  if (ball.x >= cx + hw) {
    const slope = R / hh;
    const len = Math.sqrt(1 + slope * slope);
    const nx = -1 / len, ny = slope / len;
    const dot = ball.vx * nx + ball.vy * ny;
    ball.vx -= 2 * dot * nx;
    ball.vy -= 2 * dot * ny;
    ball.x = cx + hw - 2;
    bounces++;
  }
}

function step() {
  if (!ball || paused) return;
  for (let i = 0; i < 4; i++) {
    ball.vy += gravity * dt * 0.5;
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;
    ball.vy += gravity * dt * 0.5;

    if (shape === 'circle') reflectCircle();
    else if (shape === 'rect') reflectRect();
    else reflectWedge();

    const spd = Math.hypot(ball.vx, ball.vy);
    trail.push({ x: ball.x, y: ball.y, spd });
    if (trail.length > maxTrail) trail.shift();
  }
}

function drawContainer() {
  ctx.strokeStyle = 'rgba(100,160,255,0.3)';
  ctx.lineWidth = 2;
  if (shape === 'circle') {
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.stroke();
  } else if (shape === 'rect') {
    ctx.strokeRect(cx - R, cy - R * 0.7, R * 2, R * 1.4);
  } else {
    const hh = R * 0.9, centerY = cy + hh * 0.3;
    ctx.beginPath();
    const topW = R * (0.5 + 0.5);
    const botW = R * (0.5 - 0.5);
    ctx.moveTo(cx - topW, centerY - hh * 0.5);
    ctx.lineTo(cx + topW, centerY - hh * 0.5);
    ctx.lineTo(cx + botW, centerY + hh * 0.5);
    ctx.lineTo(cx - botW, centerY + hh * 0.5);
    ctx.closePath();
    ctx.stroke();
  }
}

function draw() {
  ctx.fillStyle = 'rgba(10,14,26,0.15)';
  ctx.fillRect(0, 0, W, H);

  drawContainer();

  if (trail.length > 1) {
    const maxSpd = speed * 3;
    for (let i = 1; i < trail.length; i++) {
      const t = i / trail.length;
      const spd = trail[i].spd;
      const bright = Math.min(1, spd / maxSpd);
      const hue = 200 + bright * 60;
      const alpha = (0.2 + 0.6 * t) * (0.3 + 0.7 * bright);
      ctx.strokeStyle = `hsla(${hue}, 80%, ${40 + bright * 40}%, ${alpha})`;
      ctx.lineWidth = 1 + bright * 1.5;
      ctx.beginPath();
      ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
      ctx.lineTo(trail[i].x, trail[i].y);
      ctx.stroke();
    }
  }

  if (ball) {
    const spd = Math.hypot(ball.vx, ball.vy);
    const bright = Math.min(1, spd / (speed * 3));
    const glow = 6 + bright * 10;
    ctx.shadowColor = `hsla(210, 90%, 70%, 0.8)`;
    ctx.shadowBlur = glow;
    ctx.fillStyle = `hsl(210, 85%, ${55 + bright * 30}%)`;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, 4 + bright * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // gravity arrow indicator
  if (gravity > 0.01) {
    const arrowLen = 20 + gravity * 40;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,180,80,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(60, H - 60);
    ctx.lineTo(60, H - 60 + arrowLen);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,180,80,0.4)';
    ctx.beginPath();
    ctx.moveTo(54, H - 60 + arrowLen);
    ctx.lineTo(66, H - 60 + arrowLen);
    ctx.lineTo(60, H - 60 + arrowLen + 8);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,180,80,0.5)';
    ctx.font = '11px sans-serif';
    ctx.fillText('g', 70, H - 60 + arrowLen / 2 + 4);
    ctx.restore();
  }
}

function animate() {
  step();
  draw();
  requestAnimationFrame(animate);
}

window.reset = function() {
  trail = [];
  initBall();
};

initBall();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
