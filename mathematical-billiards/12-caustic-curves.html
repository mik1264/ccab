<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Caustic Curves - Envelopes of Reflected Rays</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120, 160, 255, 0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 220px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#info { position: fixed; bottom: 20px; left: 20px; right: 20px; z-index: 100; font-size: 0.8em; color: #7a9ab8; background: rgba(10,14,30,0.7); backdrop-filter: blur(10px); padding: 10px 16px; border-radius: 8px; text-align: center; max-width: 700px; margin: 0 auto; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Caustic Curves</h3>
  <div class="ctrl-row">
    <label>Table Shape</label>
    <div>
      <button class="btn active" data-shape="circle">Circle</button>
      <button class="btn" data-shape="ellipse">Ellipse</button>
    </div>
  </div>
  <div class="ctrl-row">
    <label>Number of Rays <span class="val" id="vRays">200</span></label>
    <input type="range" id="sRays" min="10" max="1000" step="10" value="200">
  </div>
  <div class="ctrl-row">
    <label>Reflection Angle <span class="val" id="vAngle">0.30</span></label>
    <input type="range" id="sAngle" min="0.02" max="1.50" step="0.01" value="0.30">
  </div>
  <div class="ctrl-row">
    <label>Reflections Depth <span class="val" id="vDepth">3</span></label>
    <input type="range" id="sDepth" min="1" max="10" step="1" value="3">
  </div>
  <div class="ctrl-row">
    <label>Ellipse Ratio <span class="val" id="vRatio">0.60</span></label>
    <input type="range" id="sRatio" min="0.20" max="0.95" step="0.01" value="0.60">
  </div>
  <div style="margin-top:8px;">
    <button class="btn" id="bAnimate">Animate Angle</button>
    <button class="btn" id="bCoffee">Coffee Cup</button>
  </div>
</div>
<div id="info">Caustics appear everywhere: in coffee cups, swimming pools, glasses of water, and whispering galleries. They are the envelopes of families of reflected rays.</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R;
let shape = 'circle';
let numRays = 200;
let reflAngle = 0.30;
let reflDepth = 3;
let ellipseRatio = 0.60;
let animating = false;
let coffeeMode = false;
let paused = false;
let time = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W / 2;
  cy = H / 2;
  R = Math.min(W, H) * 0.35;
}
window.addEventListener('resize', resize);
resize();

function boundaryPos(t) {
  if (shape === 'ellipse') {
    return { x: cx + R * Math.cos(t), y: cy + R * ellipseRatio * Math.sin(t) };
  }
  return { x: cx + R * Math.cos(t), y: cy + R * Math.sin(t) };
}

function normalAt(t) {
  if (shape === 'ellipse') {
    const a = R, b = R * ellipseRatio;
    let nx = Math.cos(t) / a;
    let ny = Math.sin(t) / b;
    const len = Math.sqrt(nx * nx + ny * ny);
    return { nx: nx / len, ny: ny / len };
  }
  return { nx: Math.cos(t), ny: Math.sin(t) };
}

function reflectVec(vx, vy, nx, ny) {
  const dot = vx * nx + vy * ny;
  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
}

function intersectRayEllipse(ox, oy, dx, dy) {
  const a = shape === 'ellipse' ? R : R;
  const b = shape === 'ellipse' ? R * ellipseRatio : R;
  const Ox = ox - cx, Oy = oy - cy;
  const A = (dx * dx) / (a * a) + (dy * dy) / (b * b);
  const B = 2 * ((Ox * dx) / (a * a) + (Oy * dy) / (b * b));
  const C = (Ox * Ox) / (a * a) + (Oy * Oy) / (b * b) - 1;
  const disc = B * B - 4 * A * C;
  if (disc < 0) return null;
  const sqrtD = Math.sqrt(disc);
  let t1 = (-B + sqrtD) / (2 * A);
  let t2 = (-B - sqrtD) / (2 * A);
  let t = (t1 > 0.001 && t2 > 0.001) ? Math.min(t1, t2) : (t1 > 0.001 ? t1 : t2);
  if (t < 0.001) return null;
  const hx = ox + dx * t;
  const hy = oy + dy * t;
  const angle = Math.atan2((hy - cy) / (b * b) * (a * a), hx - cx);
  // Approximate boundary parameter
  const paramAngle = Math.atan2((hy - cy) / b, (hx - cx) / a);
  return { x: hx, y: hy, t, param: paramAngle };
}

function drawTable() {
  ctx.strokeStyle = 'rgba(120,180,255,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  if (shape === 'ellipse') {
    ctx.ellipse(cx, cy, R, R * ellipseRatio, 0, 0, Math.PI * 2);
  } else {
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
  }
  ctx.stroke();
}

function traceRay(startAngle, dirAngle) {
  const p = boundaryPos(startAngle);
  const n = normalAt(startAngle);
  // incoming direction: inward at given angle from the normal
  const inwardNx = -n.nx;
  const inwardNy = -n.ny;
  // rotate inward normal by dirAngle to get the reflected direction
  const cosA = Math.cos(dirAngle);
  const sinA = Math.sin(dirAngle);
  let vx = inwardNx * cosA - inwardNy * sinA;
  let vy = inwardNx * sinA + inwardNy * cosA;

  const segments = [];
  let ox = p.x, oy = p.y;

  for (let d = 0; d < reflDepth; d++) {
    const hit = intersectRayEllipse(ox, oy, vx, vy);
    if (!hit || hit.t < 0.01) break;
    segments.push({ x1: ox, y1: oy, x2: hit.x, y2: hit.y });
    // reflect
    const hitN = normalAt(hit.param);
    const ref = reflectVec(vx, vy, hitN.nx, hitN.ny);
    vx = ref.vx;
    vy = ref.vy;
    ox = hit.x;
    oy = hit.y;
  }
  return segments;
}

function traceCoffeeRay(startAngle) {
  // Parallel rays from the left (simulating distant light source)
  const p = boundaryPos(startAngle);
  // Only rays hitting the right side of the circle
  let vx = 1, vy = 0; // horizontal rays from left

  const segments = [];
  // Start from far left at the y-height of boundary point
  const startX = cx - R - 50;
  const startY = p.y;

  // First, trace the incoming ray to the boundary
  const hit = intersectRayEllipse(startX, startY, vx, vy);
  if (!hit) return segments;
  segments.push({ x1: startX, y1: startY, x2: hit.x, y2: hit.y });

  // reflect once
  const hitN = normalAt(hit.param);
  const ref = reflectVec(vx, vy, hitN.nx, hitN.ny);
  const hit2 = intersectRayEllipse(hit.x, hit.y, ref.vx, ref.vy);
  if (hit2) {
    segments.push({ x1: hit.x, y1: hit.y, x2: hit2.x, y2: hit2.y });
  } else {
    // ray goes to edge of screen
    segments.push({ x1: hit.x, y1: hit.y, x2: hit.x + ref.vx * R * 3, y2: hit.y + ref.vy * R * 3 });
  }
  return segments;
}

function draw() {
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  if (animating && !paused) {
    time += 0.005;
    reflAngle = 0.1 + 0.7 * (0.5 + 0.5 * Math.sin(time));
    document.getElementById('sAngle').value = reflAngle.toFixed(2);
    document.getElementById('vAngle').textContent = reflAngle.toFixed(2);
  }

  drawTable();

  // title
  ctx.fillStyle = '#8af';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  if (coffeeMode) {
    ctx.fillText('Coffee Cup Caustic (Cardioid)', cx, 30);
  } else {
    ctx.fillText('Caustic Curves - ' + shape.charAt(0).toUpperCase() + shape.slice(1), cx, 30);
  }

  // draw rays
  const allSegments = [];
  for (let i = 0; i < numRays; i++) {
    const t = (i / numRays) * Math.PI * 2;
    let segs;
    if (coffeeMode) {
      segs = traceCoffeeRay(t);
    } else {
      segs = traceRay(t, reflAngle);
    }
    allSegments.push(...segs);
  }

  // Draw all segments with additive blending for caustic glow
  ctx.globalCompositeOperation = 'lighter';
  const alpha = Math.max(0.02, Math.min(0.15, 30 / numRays));
  for (const seg of allSegments) {
    ctx.strokeStyle = `rgba(100,180,255,${alpha})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(seg.x1, seg.y1);
    ctx.lineTo(seg.x2, seg.y2);
    ctx.stroke();
  }

  // Extra glow pass - draw segment midpoints for brightness
  const glowAlpha = Math.max(0.01, Math.min(0.08, 15 / numRays));
  ctx.lineWidth = 2;
  for (const seg of allSegments) {
    ctx.strokeStyle = `rgba(150,220,255,${glowAlpha})`;
    ctx.beginPath();
    ctx.moveTo(seg.x1, seg.y1);
    ctx.lineTo(seg.x2, seg.y2);
    ctx.stroke();
  }

  ctx.globalCompositeOperation = 'source-over';

  // Draw boundary launch points
  if (!coffeeMode) {
    ctx.fillStyle = 'rgba(100,200,150,0.15)';
    for (let i = 0; i < numRays; i++) {
      const t = (i / numRays) * Math.PI * 2;
      const p = boundaryPos(t);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  requestAnimationFrame(draw);
}

// Controls
document.querySelectorAll('[data-shape]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-shape]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    shape = btn.dataset.shape;
    coffeeMode = false;
    document.getElementById('bCoffee').classList.remove('active');
  });
});

document.getElementById('sRays').addEventListener('input', e => {
  numRays = parseInt(e.target.value);
  document.getElementById('vRays').textContent = numRays;
});

document.getElementById('sAngle').addEventListener('input', e => {
  reflAngle = parseFloat(e.target.value);
  document.getElementById('vAngle').textContent = reflAngle.toFixed(2);
});

document.getElementById('sDepth').addEventListener('input', e => {
  reflDepth = parseInt(e.target.value);
  document.getElementById('vDepth').textContent = reflDepth;
});

document.getElementById('sRatio').addEventListener('input', e => {
  ellipseRatio = parseFloat(e.target.value);
  document.getElementById('vRatio').textContent = ellipseRatio.toFixed(2);
});

document.getElementById('bAnimate').addEventListener('click', function() {
  animating = !animating;
  this.classList.toggle('active');
});

document.getElementById('bCoffee').addEventListener('click', function() {
  coffeeMode = !coffeeMode;
  this.classList.toggle('active');
  if (coffeeMode) {
    shape = 'circle';
    document.querySelectorAll('[data-shape]').forEach(b => b.classList.remove('active'));
    document.querySelector('[data-shape="circle"]').classList.add('active');
  }
});

window.reset = function() {
  reflAngle = 0.30;
  numRays = 200;
  reflDepth = 3;
  ellipseRatio = 0.60;
  shape = 'circle';
  animating = false;
  coffeeMode = false;
  time = 0;
  document.getElementById('sRays').value = 200;
  document.getElementById('vRays').textContent = '200';
  document.getElementById('sAngle').value = '0.30';
  document.getElementById('vAngle').textContent = '0.30';
  document.getElementById('sDepth').value = 3;
  document.getElementById('vDepth').textContent = '3';
  document.getElementById('sRatio').value = '0.60';
  document.getElementById('vRatio').textContent = '0.60';
  document.querySelectorAll('[data-shape]').forEach(b => b.classList.remove('active'));
  document.querySelector('[data-shape="circle"]').classList.add('active');
  document.getElementById('bAnimate').classList.remove('active');
  document.getElementById('bCoffee').classList.remove('active');
};

draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>