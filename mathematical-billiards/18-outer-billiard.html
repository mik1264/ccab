<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Outer Billiard - Dynamics Outside the Table</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120, 160, 255, 0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 230px; max-height: 90vh; overflow-y: auto;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#info { position: fixed; bottom: 20px; left: 20px; z-index: 100; font-size: 0.8em; color: #6a8; background: rgba(10,14,30,0.6); backdrop-filter: blur(10px); padding: 10px 14px; border-radius: 8px; max-width: 440px; line-height: 1.5; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Outer Billiard</h3>
  <div style="margin-bottom:10px;">
    <label style="font-size:0.8em;color:#8ab;">Table Shape</label>
    <div style="margin-top:4px;">
      <button class="btn active" data-shape="circle">Circle</button>
      <button class="btn" data-shape="square">Square</button>
      <button class="btn" data-shape="triangle">Triangle</button>
      <button class="btn" data-shape="pentagon">Pentagon</button>
      <button class="btn" data-shape="irregular">Irregular</button>
    </div>
  </div>
  <div class="ctrl-row">
    <label>Iterations per frame <span class="val" id="vIter">5</span></label>
    <input type="range" id="sIter" min="1" max="20" step="1" value="5">
  </div>
  <div class="ctrl-row">
    <label>Orbit Count <span class="val" id="vOrbits">8</span></label>
    <input type="range" id="sOrbits" min="1" max="30" step="1" value="8">
  </div>
  <div class="ctrl-row">
    <label>Max Points <span class="val" id="vMax">5000</span></label>
    <input type="range" id="sMax" min="500" max="20000" step="500" value="5000">
  </div>
  <div style="margin-top:8px;">
    <label style="font-size:0.8em;color:#8ab;">Display</label>
    <div style="margin-top:4px;">
      <button class="btn active" id="bPoints">Points</button>
      <button class="btn" id="bLines">Lines</button>
      <button class="btn" id="bBoth">Both</button>
    </div>
  </div>
  <div style="margin-top:8px;">
    <button class="btn" id="bClear">Clear</button>
    <button class="btn" id="bReset">Reset</button>
    <button class="btn" id="bMulti">Multi-Orbit</button>
  </div>
  <p style="font-size:0.7em;color:#68a;margin-top:10px;">Click outside the table to start an orbit</p>
</div>
<div id="info">
  <strong style="color:#8af;">Outer Billiard:</strong> Instead of bouncing inside a shape, the ball hops <em>outside</em> it. From point P, draw a tangent to the nearest vertex T, then reflect P through T to get P'. For polygons, orbits can be periodic, quasi-periodic, or even escape to infinity (Schwartz, 2007).
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, tableR;
let currentShape = 'circle';
let itersPerFrame = 5;
let maxOrbits = 8;
let maxPoints = 5000;
let displayMode = 'points'; // points, lines, both
let paused = false;

let tableVertices = [];
let orbits = []; // each orbit: { points: [{x,y}], color: string, active: bool }

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  cx = W / 2;
  cy = H / 2;
  tableR = Math.min(W, H) * 0.12;
  buildTable();
}

function buildTable() {
  tableVertices = [];
  if (currentShape === 'circle') {
    // Approximate circle with 64 vertices
    for (let i = 0; i < 64; i++) {
      const a = (i / 64) * Math.PI * 2;
      tableVertices.push({ x: cx + Math.cos(a) * tableR, y: cy + Math.sin(a) * tableR });
    }
  } else if (currentShape === 'square') {
    const s = tableR;
    tableVertices = [
      { x: cx - s, y: cy - s }, { x: cx + s, y: cy - s },
      { x: cx + s, y: cy + s }, { x: cx - s, y: cy + s }
    ];
  } else if (currentShape === 'triangle') {
    for (let i = 0; i < 3; i++) {
      const a = (i / 3) * Math.PI * 2 - Math.PI / 2;
      tableVertices.push({ x: cx + Math.cos(a) * tableR * 1.3, y: cy + Math.sin(a) * tableR * 1.3 });
    }
  } else if (currentShape === 'pentagon') {
    for (let i = 0; i < 5; i++) {
      const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
      tableVertices.push({ x: cx + Math.cos(a) * tableR, y: cy + Math.sin(a) * tableR });
    }
  } else {
    // Irregular convex polygon
    const angles = [0, 0.8, 1.7, 2.9, 3.8, 5.0].sort();
    for (const a of angles) {
      const r = tableR * (0.7 + 0.3 * Math.sin(a * 3));
      tableVertices.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
    }
  }
}

// Find the tangent point: for a polygon, the "rightmost" vertex as seen from P
function findTangentVertex(px, py) {
  const n = tableVertices.length;
  let bestIdx = 0;
  let bestAngle = -Infinity;
  // Find the vertex that subtends the largest "rightward" angle from P
  // We pick the vertex that is closest to being the support point on the right
  const toCenterAngle = Math.atan2(cy - py, cx - px);

  for (let i = 0; i < n; i++) {
    const vx = tableVertices[i].x - px;
    const vy = tableVertices[i].y - py;
    let angle = Math.atan2(vy, vx) - toCenterAngle;
    // Normalize to [-PI, PI]
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    if (angle > bestAngle) {
      bestAngle = angle;
      bestIdx = i;
    }
  }
  return tableVertices[bestIdx];
}

// Outer billiard map: reflect P through T
function outerBilliardStep(px, py) {
  const T = findTangentVertex(px, py);
  return { x: 2 * T.x - px, y: 2 * T.y - py };
}

function isInsideTable(px, py) {
  // Ray casting
  const n = tableVertices.length;
  let inside = false;
  for (let i = 0, j = n - 1; i < n; j = i++) {
    const xi = tableVertices[i].x, yi = tableVertices[i].y;
    const xj = tableVertices[j].x, yj = tableVertices[j].y;
    if ((yi > py) !== (yj > py) && px < (xj - xi) * (py - yi) / (yj - yi) + xi) {
      inside = !inside;
    }
  }
  return inside;
}

function addOrbit(sx, sy) {
  if (orbits.length >= maxOrbits) orbits.shift();
  const hue = (orbits.length * 47 + 180) % 360;
  orbits.push({
    points: [{ x: sx, y: sy }],
    color: `hsl(${hue}, 75%, 60%)`,
    hue: hue,
    active: true
  });
}

function addMultiOrbits() {
  orbits = [];
  for (let i = 0; i < maxOrbits; i++) {
    const angle = (i / maxOrbits) * Math.PI * 2;
    const dist = tableR * (1.5 + i * 0.15);
    const sx = cx + Math.cos(angle) * dist;
    const sy = cy + Math.sin(angle) * dist;
    addOrbit(sx, sy);
  }
}

function stepOrbits() {
  if (paused) return;
  for (const orbit of orbits) {
    if (!orbit.active) continue;
    for (let i = 0; i < itersPerFrame; i++) {
      const last = orbit.points[orbit.points.length - 1];
      const next = outerBilliardStep(last.x, last.y);
      // Check bounds - if it escapes too far, stop
      if (Math.abs(next.x - cx) > W * 2 || Math.abs(next.y - cy) > H * 2) {
        orbit.active = false;
        break;
      }
      orbit.points.push(next);
      if (orbit.points.length > maxPoints) {
        orbit.points.shift();
      }
    }
  }
}

function drawTable() {
  const n = tableVertices.length;
  if (n < 2) return;
  // Fill
  ctx.fillStyle = 'rgba(40, 60, 100, 0.3)';
  ctx.beginPath();
  ctx.moveTo(tableVertices[0].x, tableVertices[0].y);
  for (let i = 1; i < n; i++) ctx.lineTo(tableVertices[i].x, tableVertices[i].y);
  ctx.closePath();
  ctx.fill();
  // Stroke
  ctx.strokeStyle = 'rgba(100,160,255,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(tableVertices[0].x, tableVertices[0].y);
  for (let i = 1; i < n; i++) ctx.lineTo(tableVertices[i].x, tableVertices[i].y);
  ctx.closePath();
  ctx.stroke();
  // Vertices
  if (n <= 10) {
    ctx.fillStyle = 'rgba(150,200,255,0.7)';
    for (const v of tableVertices) {
      ctx.beginPath();
      ctx.arc(v.x, v.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function draw() {
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Subtle grid
  ctx.strokeStyle = 'rgba(60,80,120,0.08)';
  ctx.lineWidth = 1;
  const gridSize = 50;
  for (let x = cx % gridSize; x < W; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = cy % gridSize; y < H; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  drawTable();

  // Draw orbits
  for (const orbit of orbits) {
    const pts = orbit.points;
    if (pts.length < 1) continue;

    if (displayMode === 'lines' || displayMode === 'both') {
      ctx.strokeStyle = orbit.color.replace('60%)', '50%)').replace('75%', '50%');
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (displayMode === 'points' || displayMode === 'both') {
      for (let i = 0; i < pts.length; i++) {
        const t = i / pts.length;
        const alpha = 0.15 + 0.85 * t;
        const hue = (orbit.hue + i * 0.1) % 360;
        ctx.fillStyle = `hsla(${hue}, 75%, 60%, ${alpha})`;
        const size = 1 + t * 1.5;
        ctx.fillRect(pts[i].x - size / 2, pts[i].y - size / 2, size, size);
      }
    }

    // Current point highlight
    if (pts.length > 0) {
      const last = pts[pts.length - 1];
      ctx.shadowColor = orbit.color;
      ctx.shadowBlur = 8;
      ctx.fillStyle = orbit.color;
      ctx.beginPath();
      ctx.arc(last.x, last.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // Iteration count
  if (orbits.length > 0) {
    const totalPts = orbits.reduce((s, o) => s + o.points.length, 0);
    ctx.fillStyle = 'rgba(100,170,130,0.6)';
    ctx.font = '12px sans-serif';
    ctx.fillText(`Orbits: ${orbits.length}  |  Total points: ${totalPts}`, 20, H - 20);
  }
}

function animate() {
  stepOrbits();
  draw();
  requestAnimationFrame(animate);
}

// Controls
resize();
window.addEventListener('resize', resize);

document.querySelectorAll('[data-shape]').forEach(b => {
  b.addEventListener('click', () => {
    document.querySelectorAll('[data-shape]').forEach(bb => bb.classList.remove('active'));
    b.classList.add('active');
    currentShape = b.dataset.shape;
    buildTable();
    orbits = [];
    addMultiOrbits();
  });
});

document.getElementById('sIter').addEventListener('input', e => {
  itersPerFrame = parseInt(e.target.value);
  document.getElementById('vIter').textContent = itersPerFrame;
});
document.getElementById('sOrbits').addEventListener('input', e => {
  maxOrbits = parseInt(e.target.value);
  document.getElementById('vOrbits').textContent = maxOrbits;
});
document.getElementById('sMax').addEventListener('input', e => {
  maxPoints = parseInt(e.target.value);
  document.getElementById('vMax').textContent = maxPoints;
});

document.getElementById('bPoints').addEventListener('click', () => {
  displayMode = 'points';
  document.getElementById('bPoints').classList.add('active');
  document.getElementById('bLines').classList.remove('active');
  document.getElementById('bBoth').classList.remove('active');
});
document.getElementById('bLines').addEventListener('click', () => {
  displayMode = 'lines';
  document.getElementById('bLines').classList.add('active');
  document.getElementById('bPoints').classList.remove('active');
  document.getElementById('bBoth').classList.remove('active');
});
document.getElementById('bBoth').addEventListener('click', () => {
  displayMode = 'both';
  document.getElementById('bBoth').classList.add('active');
  document.getElementById('bPoints').classList.remove('active');
  document.getElementById('bLines').classList.remove('active');
});

document.getElementById('bClear').addEventListener('click', () => { orbits = []; });
document.getElementById('bReset').addEventListener('click', () => { orbits = []; addMultiOrbits(); });
document.getElementById('bMulti').addEventListener('click', addMultiOrbits);

canvas.addEventListener('click', e => {
  const mx = e.clientX, my = e.clientY;
  if (!isInsideTable(mx, my)) {
    addOrbit(mx, my);
  }
});

window.reset = function() {
  orbits = [];
  addMultiOrbits();
};

addMultiOrbits();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
