<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Magnetic Billiard - Larmor Orbits & Curved Paths</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120, 160, 255, 0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 240px; max-height: 90vh; overflow-y: auto;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#info { position: fixed; bottom: 20px; left: 20px; z-index: 100; font-size: 0.8em; color: #6a8; background: rgba(10,14,30,0.6); backdrop-filter: blur(10px); padding: 10px 14px; border-radius: 8px; max-width: 420px; line-height: 1.5; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Magnetic Billiard</h3>
  <div class="ctrl-row">
    <label>Magnetic Field (B) <span class="val" id="vField">0.40</span></label>
    <input type="range" id="sField" min="0.01" max="2.0" step="0.01" value="0.40">
  </div>
  <div class="ctrl-row">
    <label>Larmor Radius <span class="val" id="vLarmor">--</span></label>
  </div>
  <div class="ctrl-row">
    <label>Trail Length <span class="val" id="vTrail">4000</span></label>
    <input type="range" id="sTrail" min="200" max="10000" step="200" value="4000">
  </div>
  <div class="ctrl-row">
    <label>Speed <span class="val" id="vSpeed">3.0</span></label>
    <input type="range" id="sSpeed" min="0.5" max="8" step="0.25" value="3.0">
  </div>
  <div style="margin-top:8px;">
    <label style="font-size:0.8em;color:#8ab;">Field Direction</label>
    <div style="margin-top:4px;">
      <button class="btn active" id="bCW">Clockwise</button>
      <button class="btn" id="bCCW">Counter-CW</button>
    </div>
  </div>
  <div style="margin-top:8px;">
    <label style="font-size:0.8em;color:#8ab;">Container</label>
    <div style="margin-top:4px;">
      <button class="btn active" data-shape="circle">Circle</button>
      <button class="btn" data-shape="rect">Rectangle</button>
    </div>
  </div>
  <div style="margin-top:8px;">
    <button class="btn" id="bShowLarmor">Show Larmor Circle</button>
    <button class="btn" id="bClear">Clear</button>
    <button class="btn" id="bReset">Reset</button>
  </div>
  <p style="font-size:0.7em;color:#68a;margin-top:10px;">Click inside to launch</p>
</div>
<div id="info">
  <strong style="color:#8af;">Magnetic Billiard:</strong> A charged particle in a uniform magnetic field follows circular arcs (Larmor orbits) between wall reflections. Tight spirals hug the boundary at strong fields; weak fields approach classical billiards. These model electrons in mesoscopic quantum devices.
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R;
let fieldB = 0.40;
let fieldSign = 1; // 1=CW, -1=CCW
let ballSpeed = 3.0;
let maxTrail = 4000;
let shape = 'circle';
let showLarmor = false;
let ball = null;
let trail = [];
let bounces = 0;
let paused = false;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  cx = W / 2;
  cy = H / 2;
  R = Math.min(W, H) * 0.38;
}
resize();
window.addEventListener('resize', resize);

function larmorRadius() {
  return ballSpeed / (fieldB + 0.001);
}

function initBall(x, y, angle) {
  if (x === undefined) { x = cx + R * 0.3; y = cy; }
  if (angle === undefined) angle = -Math.PI / 2 + (Math.random() - 0.5) * 1.0;
  ball = { x, y, vx: Math.cos(angle) * ballSpeed, vy: Math.sin(angle) * ballSpeed };
  trail = [{ x: ball.x, y: ball.y }];
  bounces = 0;
  updateLarmorDisplay();
}

function updateLarmorDisplay() {
  const lr = larmorRadius();
  document.getElementById('vLarmor').textContent = lr.toFixed(1) + 'px';
}

// Circular arc stepping: the particle orbits a center, we advance the angle
function step() {
  if (!ball || paused) return;
  const stepsPerFrame = 6;
  const subDt = 0.4;
  for (let s = 0; s < stepsPerFrame; s++) {
    // In a magnetic field, the acceleration is perpendicular to velocity
    // a_x = sign * omega * v_y, a_y = -sign * omega * v_x
    // omega = v / r_L = fieldB
    const omega = fieldB * fieldSign;
    // Velocity Verlet for circular motion
    const ax = omega * ball.vy;
    const ay = -omega * ball.vx;
    ball.vx += ax * subDt;
    ball.vy += ay * subDt;
    // Renormalize speed to prevent drift
    const spd = Math.hypot(ball.vx, ball.vy);
    if (spd > 0.001) {
      ball.vx = ball.vx / spd * ballSpeed;
      ball.vy = ball.vy / spd * ballSpeed;
    }
    ball.x += ball.vx * subDt;
    ball.y += ball.vy * subDt;

    // Reflect at boundary
    if (shape === 'circle') {
      const dx = ball.x - cx, dy = ball.y - cy;
      const dist = Math.hypot(dx, dy);
      if (dist >= R) {
        const nx = dx / dist, ny = dy / dist;
        ball.x = cx + nx * (R - 1);
        ball.y = cy + ny * (R - 1);
        const dot = ball.vx * nx + ball.vy * ny;
        ball.vx -= 2 * dot * nx;
        ball.vy -= 2 * dot * ny;
        // Renormalize
        const s2 = Math.hypot(ball.vx, ball.vy);
        if (s2 > 0.001) { ball.vx = ball.vx / s2 * ballSpeed; ball.vy = ball.vy / s2 * ballSpeed; }
        bounces++;
      }
    } else {
      const hw = R, hh = R * 0.7;
      const L = cx - hw, Ri = cx + hw, T = cy - hh, B = cy + hh;
      let hit = false;
      if (ball.x <= L) { ball.x = L + 1; ball.vx = Math.abs(ball.vx); hit = true; }
      if (ball.x >= Ri) { ball.x = Ri - 1; ball.vx = -Math.abs(ball.vx); hit = true; }
      if (ball.y <= T) { ball.y = T + 1; ball.vy = Math.abs(ball.vy); hit = true; }
      if (ball.y >= B) { ball.y = B - 1; ball.vy = -Math.abs(ball.vy); hit = true; }
      if (hit) bounces++;
    }

    trail.push({ x: ball.x, y: ball.y });
    if (trail.length > maxTrail) trail.shift();
  }
}

function drawContainer() {
  ctx.strokeStyle = 'rgba(100,160,255,0.25)';
  ctx.lineWidth = 2;
  if (shape === 'circle') {
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.stroke();
  } else {
    ctx.strokeRect(cx - R, cy - R * 0.7, R * 2, R * 1.4);
  }
}

function draw() {
  ctx.fillStyle = 'rgba(10,14,26,0.12)';
  ctx.fillRect(0, 0, W, H);
  drawContainer();

  // Draw trail with spirograph coloring
  if (trail.length > 1) {
    for (let i = 1; i < trail.length; i++) {
      const t = i / trail.length;
      const hue = (i * 0.15) % 360;
      const alpha = 0.15 + 0.65 * t;
      ctx.strokeStyle = `hsla(${hue}, 75%, 60%, ${alpha})`;
      ctx.lineWidth = 1.2 + t * 0.8;
      ctx.beginPath();
      ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
      ctx.lineTo(trail[i].x, trail[i].y);
      ctx.stroke();
    }
  }

  // Larmor circle overlay
  if (showLarmor && ball) {
    const lr = larmorRadius();
    // Center of Larmor circle is perpendicular to velocity
    const spd = Math.hypot(ball.vx, ball.vy);
    if (spd > 0.01) {
      const perpX = -ball.vy / spd * fieldSign;
      const perpY = ball.vx / spd * fieldSign;
      const lcx = ball.x + perpX * lr;
      const lcy = ball.y + perpY * lr;
      ctx.strokeStyle = 'rgba(255,200,100,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.arc(lcx, lcy, lr, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      // Center dot
      ctx.fillStyle = 'rgba(255,200,100,0.5)';
      ctx.beginPath();
      ctx.arc(lcx, lcy, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Ball
  if (ball) {
    const hue = (bounces * 25) % 360;
    ctx.shadowColor = `hsla(${hue}, 80%, 65%, 0.8)`;
    ctx.shadowBlur = 12;
    ctx.fillStyle = `hsl(${hue}, 80%, 65%)`;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Field direction indicator
  ctx.save();
  ctx.strokeStyle = 'rgba(180,140,255,0.4)';
  ctx.lineWidth = 1.5;
  const arrowR = 15;
  const acx = 50, acy = H - 50;
  ctx.beginPath();
  ctx.arc(acx, acy, arrowR, 0, Math.PI * 1.5);
  ctx.stroke();
  // arrowhead
  const aDir = fieldSign > 0 ? 1 : -1;
  const tipAngle = fieldSign > 0 ? -Math.PI / 2 : Math.PI;
  const tipX = acx + Math.cos(tipAngle) * arrowR;
  const tipY = acy + Math.sin(tipAngle) * arrowR;
  ctx.fillStyle = 'rgba(180,140,255,0.5)';
  ctx.beginPath();
  ctx.arc(tipX, tipY, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(180,140,255,0.5)';
  ctx.font = '11px sans-serif';
  ctx.fillText('B ' + (fieldSign > 0 ? 'CW' : 'CCW'), acx - 10, acy + arrowR + 16);
  ctx.restore();
}

function animate() {
  step();
  draw();
  requestAnimationFrame(animate);
}

// Controls
document.getElementById('sField').addEventListener('input', e => {
  fieldB = parseFloat(e.target.value);
  document.getElementById('vField').textContent = fieldB.toFixed(2);
  updateLarmorDisplay();
});
document.getElementById('sTrail').addEventListener('input', e => {
  maxTrail = parseInt(e.target.value);
  document.getElementById('vTrail').textContent = maxTrail;
});
document.getElementById('sSpeed').addEventListener('input', e => {
  ballSpeed = parseFloat(e.target.value);
  document.getElementById('vSpeed').textContent = ballSpeed.toFixed(1);
  // Update ball speed
  if (ball) {
    const spd = Math.hypot(ball.vx, ball.vy);
    if (spd > 0.01) { ball.vx = ball.vx / spd * ballSpeed; ball.vy = ball.vy / spd * ballSpeed; }
  }
  updateLarmorDisplay();
});
document.getElementById('bCW').addEventListener('click', () => {
  fieldSign = 1;
  document.getElementById('bCW').classList.add('active');
  document.getElementById('bCCW').classList.remove('active');
});
document.getElementById('bCCW').addEventListener('click', () => {
  fieldSign = -1;
  document.getElementById('bCCW').classList.add('active');
  document.getElementById('bCW').classList.remove('active');
});
document.querySelectorAll('[data-shape]').forEach(b => {
  b.addEventListener('click', () => {
    document.querySelectorAll('[data-shape]').forEach(bb => bb.classList.remove('active'));
    b.classList.add('active');
    shape = b.dataset.shape;
    initBall();
  });
});
document.getElementById('bShowLarmor').addEventListener('click', function() {
  showLarmor = !showLarmor;
  this.classList.toggle('active');
});
document.getElementById('bClear').addEventListener('click', () => { trail = []; });
document.getElementById('bReset').addEventListener('click', () => { initBall(); });

canvas.addEventListener('click', e => {
  const mx = e.clientX, my = e.clientY;
  let inside = false;
  if (shape === 'circle') inside = Math.hypot(mx - cx, my - cy) < R;
  else inside = Math.abs(mx - cx) < R && Math.abs(my - cy) < R * 0.7;
  if (inside) {
    const angle = Math.atan2(my - cy, mx - cx) + Math.PI / 2;
    initBall(mx, my, angle);
  }
});

window.reset = function() {
  trail = [];
  initBall();
};

initBall();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
