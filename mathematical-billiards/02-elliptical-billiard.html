<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Elliptical Billiard - Whispering Gallery</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10,14,30,0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 230px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#stats { position: fixed; bottom: 20px; left: 20px; z-index: 100; font-size: 0.85em; color: #6a8; background: rgba(10,14,30,0.6); backdrop-filter: blur(10px); padding: 8px 14px; border-radius: 8px; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Elliptical Billiard</h3>
  <div class="ctrl-row">
    <label>Eccentricity <span class="val" id="vEcc">0.60</span></label>
    <input type="range" id="sEcc" min="0.05" max="0.95" step="0.01" value="0.60">
  </div>
  <div class="ctrl-row">
    <label>Trail Length <span class="val" id="vTrail">3000</span></label>
    <input type="range" id="sTrail" min="100" max="10000" step="100" value="3000">
  </div>
  <div class="ctrl-row">
    <label>Speed <span class="val" id="vSpeed">4</span></label>
    <input type="range" id="sSpeed" min="1" max="12" step="0.5" value="4">
  </div>
  <div style="margin-top:10px;">
    <button class="btn active" id="bFoci">Foci</button>
    <button class="btn" id="bCaustic">Caustic</button>
    <button class="btn" id="bWhisper">Whisper Demo</button>
  </div>
  <div style="margin-top:6px; font-size:0.72em; color:#6a8;">Click inside to set start point. Drag for direction.</div>
</div>
<div id="stats">Bounces: <span id="bounceCount">0</span> | <span id="causticType">--</span></div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, a, b, ecc = 0.6;
let ball = { x: 0, y: 0, vx: 0, vy: 0 };
let trail = [];
let maxTrail = 3000;
let speed = 4;
let bounces = 0;
let showFoci = true;
let showCaustic = false;
let paused = false;
let dragging = false, dragStart = null;
let whisperMode = false;
let whisperPulses = [];

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W / 2; cy = H / 2;
  computeEllipse();
}

function computeEllipse() {
  const maxR = Math.min(W, H) * 0.38;
  a = maxR;
  b = a * Math.sqrt(1 - ecc * ecc);
}

function fociX() { return Math.sqrt(a * a - b * b); }

function isInsideEllipse(x, y) {
  const lx = (x - cx) / a, ly = (y - cy) / b;
  return lx * lx + ly * ly < 1;
}

function ellipseNormal(x, y) {
  const nx = (x - cx) / (a * a);
  const ny = (y - cy) / (b * b);
  const len = Math.sqrt(nx * nx + ny * ny);
  return { x: nx / len, y: ny / len };
}

function ellipseValue(x, y) {
  const lx = (x - cx) / a, ly = (y - cy) / b;
  return lx * lx + ly * ly;
}

resize();

function initBall() {
  trail = []; bounces = 0;
  const angle = Math.PI * 0.25;
  ball.x = cx + a * Math.cos(angle);
  ball.y = cy + b * Math.sin(angle);
  // Aim slightly off-focus for interesting caustic
  const target = { x: cx + fociX() * 0.3, y: cy - 20 };
  const dx = target.x - ball.x, dy = target.y - ball.y;
  const len = Math.sqrt(dx * dx + dy * dy);
  ball.vx = dx / len; ball.vy = dy / len;
  trail.push({ x: ball.x, y: ball.y });
  whisperPulses = [];
}
initBall();

function startWhisper() {
  whisperMode = true;
  trail = []; bounces = 0;
  const f = fociX();
  ball.x = cx - f; ball.y = cy;
  const ang = Math.PI * 0.15 + Math.random() * 0.3;
  ball.vx = Math.cos(ang); ball.vy = Math.sin(ang);
  trail.push({ x: ball.x, y: ball.y });
  whisperPulses = [{ x: cx - f, y: cy, r: 0, alpha: 1 }];
}

function update() {
  if (paused) return;
  for (let s = 0; s < speed * 2; s++) {
    const step = 2;
    ball.x += ball.vx * step;
    ball.y += ball.vy * step;
    const ev = ellipseValue(ball.x, ball.y);
    if (ev >= 1) {
      const n = ellipseNormal(ball.x, ball.y);
      const dot = ball.vx * n.x + ball.vy * n.y;
      ball.vx -= 2 * dot * n.x;
      ball.vy -= 2 * dot * n.y;
      // Push ball back inside
      const scale = 0.998;
      const lx = (ball.x - cx) / a, ly = (ball.y - cy) / b;
      const r = Math.sqrt(lx * lx + ly * ly);
      ball.x = cx + (lx / r) * scale * a;
      ball.y = cy + (ly / r) * scale * b;
      bounces++;
      if (whisperMode) {
        whisperPulses.push({ x: ball.x, y: ball.y, r: 0, alpha: 0.7 });
      }
    }
    trail.push({ x: ball.x, y: ball.y });
    if (trail.length > maxTrail) trail.shift();
  }
  // Update whisper pulses
  for (let i = whisperPulses.length - 1; i >= 0; i--) {
    whisperPulses[i].r += 1.5;
    whisperPulses[i].alpha *= 0.995;
    if (whisperPulses[i].alpha < 0.01) whisperPulses.splice(i, 1);
  }
  document.getElementById('bounceCount').textContent = bounces;
}

function drawEllipse() {
  ctx.beginPath();
  ctx.ellipse(cx, cy, a, b, 0, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(100,160,255,0.3)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.shadowColor = '#4488ff';
  ctx.shadowBlur = 12;
  ctx.beginPath();
  ctx.ellipse(cx, cy, a, b, 0, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(80,140,255,0.1)';
  ctx.lineWidth = 5;
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function drawFoci() {
  if (!showFoci) return;
  const f = fociX();
  for (const sign of [-1, 1]) {
    ctx.shadowColor = '#ffaa44';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(cx + sign * f, cy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#ffcc66';
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(cx + sign * f, cy, 2, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
  }
}

function drawCaustic() {
  if (!showCaustic || trail.length < 10) return;
  // Estimate the caustic: find minimum distance from each trail line to center
  // For a proper caustic, compute the confocal ellipse/hyperbola parameter
  const f = fociX();
  // Check if trajectory passes between foci using first segment
  if (trail.length > 2) {
    const p1 = trail[0], p2 = trail[Math.min(trail.length - 1, 20)];
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len > 0) {
      // Distance from each focus to the line
      const nx = -dy / len, ny = dx / len;
      const d1 = Math.abs((cx - f - p1.x) * nx + (cy - p1.y) * ny);
      const d2 = Math.abs((cx + f - p1.x) * nx + (cy - p1.y) * ny);
      // Confocal ellipse caustic: semi-axes
      const ca = (d1 + d2) / 2;
      const cb2 = ca * ca - f * f;
      if (cb2 > 0) {
        const cb = Math.sqrt(cb2);
        ctx.beginPath();
        ctx.ellipse(cx, cy, ca, cb, 0, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,140,60,0.4)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
        document.getElementById('causticType').textContent = 'Confocal ellipse caustic';
      } else {
        document.getElementById('causticType').textContent = 'Confocal hyperbola caustic';
      }
    }
  }
}

function draw() {
  ctx.fillStyle = 'rgba(10,14,30,0.15)';
  ctx.fillRect(0, 0, W, H);
  drawEllipse();
  drawFoci();
  drawCaustic();
  // Whisper pulses
  for (const p of whisperPulses) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,200,100,${p.alpha * 0.3})`;
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  // Trail
  if (trail.length > 1) {
    const len = trail.length;
    for (let i = 1; i < len; i++) {
      const t = i / len;
      const hue = whisperMode ? 30 + t * 30 : 180 + t * 80;
      ctx.beginPath();
      ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
      ctx.lineTo(trail[i].x, trail[i].y);
      ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${t * 0.7})`;
      ctx.lineWidth = 1 + t * 1.5;
      ctx.stroke();
    }
  }
  // Ball
  ctx.shadowColor = '#88ccff';
  ctx.shadowBlur = 18;
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, 4, 0, Math.PI * 2);
  ctx.fillStyle = '#bbddff';
  ctx.fill();
  ctx.shadowBlur = 0;
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Controls
document.getElementById('sEcc').addEventListener('input', function() {
  ecc = parseFloat(this.value);
  document.getElementById('vEcc').textContent = ecc.toFixed(2);
  computeEllipse();
  initBall();
});
document.getElementById('sTrail').addEventListener('input', function() {
  maxTrail = parseInt(this.value);
  document.getElementById('vTrail').textContent = maxTrail;
});
document.getElementById('sSpeed').addEventListener('input', function() {
  speed = parseFloat(this.value);
  document.getElementById('vSpeed').textContent = speed;
});
document.getElementById('bFoci').addEventListener('click', function() {
  showFoci = !showFoci; this.classList.toggle('active');
});
document.getElementById('bCaustic').addEventListener('click', function() {
  showCaustic = !showCaustic; this.classList.toggle('active');
});
document.getElementById('bWhisper').addEventListener('click', function() {
  whisperMode = !whisperMode;
  this.classList.toggle('active');
  if (whisperMode) startWhisper();
});

canvas.addEventListener('mousedown', function(e) {
  if (isInsideEllipse(e.clientX, e.clientY)) {
    dragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
  }
});
canvas.addEventListener('mouseup', function(e) {
  if (dragging && dragStart) {
    const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len > 5) {
      trail = []; bounces = 0; whisperPulses = [];
      ball.x = dragStart.x; ball.y = dragStart.y;
      ball.vx = dx / len; ball.vy = dy / len;
      trail.push({ x: ball.x, y: ball.y });
    }
    dragging = false; dragStart = null;
  }
});

window.addEventListener('resize', resize);
window.addEventListener('keydown', function(e) {
  if (e.code === 'Space') { e.preventDefault(); paused = !paused; }
});

window.reset = function() {
  whisperMode = false;
  document.getElementById('bWhisper').classList.remove('active');
  initBall();
  ctx.clearRect(0, 0, W, H);
};

requestAnimationFrame(loop);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>