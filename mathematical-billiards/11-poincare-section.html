<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Poincare Section - Phase Space Portraits</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120, 160, 255, 0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 220px; max-height: 90vh; overflow-y: auto;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#info { position: fixed; bottom: 20px; left: 20px; right: 20px; z-index: 100; font-size: 0.8em; color: #7a9ab8; background: rgba(10,14,30,0.7); backdrop-filter: blur(10px); padding: 10px 16px; border-radius: 8px; text-align: center; max-width: 700px; margin: 0 auto; }
.divider { width: 100%; height: 1px; background: rgba(120,160,255,0.15); margin: 10px 0; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Poincare Section</h3>
  <div class="ctrl-row">
    <label>Table Shape</label>
    <div>
      <button class="btn active" data-shape="circle">Circle</button>
      <button class="btn" data-shape="ellipse">Ellipse</button>
      <button class="btn" data-shape="stadium">Stadium</button>
      <button class="btn" data-shape="mushroom">Mushroom</button>
      <button class="btn" data-shape="sinai">Sinai</button>
    </div>
  </div>
  <div class="ctrl-row">
    <label>Speed <span class="val" id="vSpeed">5</span></label>
    <input type="range" id="sSpeed" min="1" max="20" step="1" value="5">
  </div>
  <div class="divider"></div>
  <div class="ctrl-row" style="font-size:0.75em; color:#6a8;">
    Click on the billiard table to launch a new ball. Each launch gets a unique color.
  </div>
  <div>
    <button class="btn" id="bClear">Clear Phase Space</button>
    <button class="btn" id="bReset">Reset All</button>
  </div>
</div>
<div id="info">The Poincare section reduces continuous billiard dynamics to a discrete map. Regular motion creates smooth curves; chaos creates scattered dots.</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
let shape = 'circle';
let speed = 5;
let paused = false;
let balls = [];
let phasePoints = [];
let colorIndex = 0;
const colors = ['#ff6b6b','#51cf66','#339af0','#fcc419','#cc5de8','#20c997','#ff922b','#f06595','#74c0fc','#a9e34b'];

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function getTableParams() {
  const panelW = W / 2;
  const cx = panelW / 2;
  const cy = H / 2;
  const R = Math.min(panelW, H) * 0.35;
  return { cx, cy, R, panelW };
}

function boundaryPoint(shape, t, R) {
  // t in [0, 2*PI], returns {x, y} relative to center
  if (shape === 'circle') {
    return { x: R * Math.cos(t), y: R * Math.sin(t) };
  } else if (shape === 'ellipse') {
    return { x: R * Math.cos(t), y: R * 0.6 * Math.sin(t) };
  } else if (shape === 'stadium') {
    const straight = R * 0.5;
    const r = R * 0.5;
    const perim = 2 * Math.PI * r + 4 * straight;
    let s = ((t % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    s = s / (2 * Math.PI) * perim;
    if (s < Math.PI * r) {
      const a = s / r;
      return { x: straight + r * Math.cos(Math.PI / 2 - a), y: r * Math.sin(Math.PI / 2 - a) };
    } else if (s < Math.PI * r + 2 * straight) {
      const d = s - Math.PI * r;
      return { x: straight - d, y: -r };
    } else if (s < 2 * Math.PI * r + 2 * straight) {
      const a = (s - Math.PI * r - 2 * straight) / r;
      return { x: -straight + r * Math.cos(-Math.PI / 2 - a), y: r * Math.sin(-Math.PI / 2 - a) };
    } else {
      const d = s - 2 * Math.PI * r - 2 * straight;
      return { x: -straight + d, y: r };
    }
  }
  return { x: R * Math.cos(t), y: R * Math.sin(t) };
}

function drawTable(cx, cy, R) {
  ctx.strokeStyle = 'rgba(120,180,255,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  if (shape === 'circle') {
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
  } else if (shape === 'ellipse') {
    ctx.ellipse(cx, cy, R, R * 0.6, 0, 0, Math.PI * 2);
  } else if (shape === 'stadium') {
    const straight = R * 0.5;
    const r = R * 0.5;
    ctx.arc(cx + straight, cy, r, -Math.PI / 2, Math.PI / 2);
    ctx.lineTo(cx - straight, cy + r);
    ctx.arc(cx - straight, cy, r, Math.PI / 2, 3 * Math.PI / 2);
    ctx.lineTo(cx + straight, cy - r);
  } else if (shape === 'mushroom') {
    const r = R * 0.7;
    ctx.arc(cx, cy - R * 0.1, r, Math.PI, 2 * Math.PI);
    const stemW = R * 0.35;
    const stemH = R * 0.8;
    ctx.lineTo(cx + stemW, cy - R * 0.1);
    ctx.lineTo(cx + stemW, cy - R * 0.1 + stemH);
    ctx.lineTo(cx - stemW, cy - R * 0.1 + stemH);
    ctx.lineTo(cx - stemW, cy - R * 0.1);
    ctx.closePath();
  } else if (shape === 'sinai') {
    const s = R * 0.9;
    ctx.rect(cx - s, cy - s, 2 * s, 2 * s);
    ctx.moveTo(cx + R * 0.25, cy);
    ctx.arc(cx, cy, R * 0.25, 0, Math.PI * 2, true);
  }
  ctx.stroke();
}

function getNormal(shape, x, y, R) {
  if (shape === 'circle') {
    const len = Math.sqrt(x * x + y * y);
    return { nx: -x / len, ny: -y / len };
  } else if (shape === 'ellipse') {
    const a = R, b = R * 0.6;
    let nx = x / (a * a), ny = y / (b * b);
    const len = Math.sqrt(nx * nx + ny * ny);
    return { nx: -nx / len, ny: -ny / len };
  } else if (shape === 'stadium') {
    const straight = R * 0.5;
    const r = R * 0.5;
    if (x > straight) {
      const dx = x - straight, dy = y;
      const len = Math.sqrt(dx * dx + dy * dy);
      return { nx: -dx / len, ny: -dy / len };
    } else if (x < -straight) {
      const dx = x + straight, dy = y;
      const len = Math.sqrt(dx * dx + dy * dy);
      return { nx: -dx / len, ny: -dy / len };
    } else if (y > 0) {
      return { nx: 0, ny: -1 };
    } else {
      return { nx: 0, ny: 1 };
    }
  } else if (shape === 'mushroom') {
    const r = R * 0.7;
    const capCy = -R * 0.1;
    const dx = x, dy = y - capCy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dy < 0 && dist > r * 0.9) {
      return { nx: -dx / dist, ny: -dy / dist };
    }
    const stemW = R * 0.35;
    const stemBottom = capCy + R * 0.8;
    if (Math.abs(y - stemBottom) < 2) return { nx: 0, ny: -1 };
    if (x > 0) return { nx: -1, ny: 0 };
    return { nx: 1, ny: 0 };
  } else if (shape === 'sinai') {
    const s = R * 0.9;
    const innerR = R * 0.25;
    const distCenter = Math.sqrt(x * x + y * y);
    if (distCenter < innerR + 3) {
      return { nx: x / distCenter, ny: y / distCenter };
    }
    if (Math.abs(x - s) < 3) return { nx: -1, ny: 0 };
    if (Math.abs(x + s) < 3) return { nx: 1, ny: 0 };
    if (Math.abs(y - s) < 3) return { nx: 0, ny: -1 };
    return { nx: 0, ny: 1 };
  }
  return { nx: 0, ny: -1 };
}

function isInside(shape, x, y, R) {
  if (shape === 'circle') return x * x + y * y < R * R;
  if (shape === 'ellipse') return (x * x) / (R * R) + (y * y) / (R * 0.6 * R * 0.6) < 1;
  if (shape === 'stadium') {
    const straight = R * 0.5, r = R * 0.5;
    if (x >= -straight && x <= straight && Math.abs(y) <= r) return true;
    if (x > straight) return (x - straight) * (x - straight) + y * y < r * r;
    if (x < -straight) return (x + straight) * (x + straight) + y * y < r * r;
    return false;
  }
  if (shape === 'mushroom') {
    const r = R * 0.7, capCy = -R * 0.1;
    const stemW = R * 0.35, stemBottom = capCy + R * 0.8;
    const inCap = (x * x + (y - capCy) * (y - capCy) < r * r) && y < capCy;
    const inStem = Math.abs(x) < stemW && y >= capCy && y < stemBottom;
    return inCap || inStem;
  }
  if (shape === 'sinai') {
    const s = R * 0.9, innerR = R * 0.25;
    return Math.abs(x) < s && Math.abs(y) < s && x * x + y * y > innerR * innerR;
  }
  return false;
}

function getBoundaryParam(shape, x, y, R) {
  if (shape === 'circle') {
    return ((Math.atan2(y, x) / (2 * Math.PI)) + 1) % 1;
  } else if (shape === 'ellipse') {
    return ((Math.atan2(y / (R * 0.6), x / R) / (2 * Math.PI)) + 1) % 1;
  } else if (shape === 'stadium') {
    const straight = R * 0.5, r = R * 0.5;
    const perim = 2 * Math.PI * r + 4 * straight;
    let s;
    if (x > straight) {
      const a = Math.atan2(y, x - straight);
      s = (Math.PI / 2 - a + 2 * Math.PI) % (2 * Math.PI);
      if (s > Math.PI) s = Math.PI;
      s = s * r;
    } else if (x < -straight) {
      const a = Math.atan2(y, x + straight);
      s = (-Math.PI / 2 - a + 2 * Math.PI) % (2 * Math.PI);
      if (s > Math.PI) s = Math.PI;
      s = 2 * straight + Math.PI * r + s * r;
    } else if (y <= 0) {
      s = Math.PI * r + (straight - x);
    } else {
      s = 2 * Math.PI * r + 2 * straight + (x + straight);
    }
    return s / perim;
  } else if (shape === 'sinai') {
    const s = R * 0.9;
    const perim = 8 * s + 2 * Math.PI * R * 0.25;
    const distC = Math.sqrt(x * x + y * y);
    if (distC < R * 0.25 + 5) {
      const a = ((Math.atan2(y, x) / (2 * Math.PI)) + 1) % 1;
      return (8 * s + a * 2 * Math.PI * R * 0.25) / perim;
    }
    if (Math.abs(y + s) < 3) return (s + x + s) / perim;
    if (Math.abs(x - s) < 3) return (2 * s + s + y + s) / perim;
    if (Math.abs(y - s) < 3) return (4 * s + s - x + s) / perim;
    return (6 * s + s - y + s) / perim;
  }
  return ((Math.atan2(y, x) / (2 * Math.PI)) + 1) % 1;
}

function reflect(vx, vy, nx, ny) {
  const dot = vx * nx + vy * ny;
  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
}

function getReflectionAngle(vx, vy, nx, ny) {
  const dot = -(vx * nx + vy * ny);
  const speed = Math.sqrt(vx * vx + vy * vy);
  return Math.acos(Math.min(1, Math.max(-1, dot / speed)));
}

function createBall(x, y, angle) {
  const col = colors[colorIndex % colors.length];
  colorIndex++;
  const spd = 2;
  return {
    x, y,
    vx: spd * Math.cos(angle),
    vy: spd * Math.sin(angle),
    color: col,
    trail: [{ x, y }],
    bounces: 0
  };
}

function stepBall(ball, R, dt) {
  const steps = Math.ceil(dt);
  const subDt = dt / steps;
  for (let s = 0; s < steps; s++) {
    ball.x += ball.vx * subDt;
    ball.y += ball.vy * subDt;
    if (!isInside(shape, ball.x, ball.y, R)) {
      ball.x -= ball.vx * subDt;
      ball.y -= ball.vy * subDt;
      // binary search for exact collision
      let lo = 0, hi = subDt;
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        const tx = ball.x + ball.vx * mid;
        const ty = ball.y + ball.vy * mid;
        if (isInside(shape, tx, ty, R)) lo = mid; else hi = mid;
      }
      ball.x += ball.vx * lo;
      ball.y += ball.vy * lo;
      const n = getNormal(shape, ball.x, ball.y, R);
      const angle = getReflectionAngle(ball.vx, ball.vy, n.nx, n.ny);
      const param = getBoundaryParam(shape, ball.x, ball.y, R);
      phasePoints.push({ s: param, theta: angle, color: ball.color });
      const ref = reflect(ball.vx, ball.vy, n.nx, n.ny);
      ball.vx = ref.vx;
      ball.vy = ref.vy;
      ball.bounces++;
      const rem = subDt - lo;
      ball.x += ball.vx * rem;
      ball.y += ball.vy * rem;
    }
    ball.trail.push({ x: ball.x, y: ball.y });
    if (ball.trail.length > 500) ball.trail.shift();
  }
}

function drawPhaseSpace() {
  const p = getTableParams();
  const px = p.panelW;
  const pw = W - px;
  const margin = 40;
  const plotX = px + margin;
  const plotY = margin + 30;
  const plotW = pw - 2 * margin;
  const plotH = H - 2 * margin - 60;

  // axes
  ctx.strokeStyle = 'rgba(120,180,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotX, plotY);
  ctx.lineTo(plotX, plotY + plotH);
  ctx.lineTo(plotX + plotW, plotY + plotH);
  ctx.stroke();

  // labels
  ctx.fillStyle = '#6a8ab8';
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Boundary Position (s)', plotX + plotW / 2, plotY + plotH + 30);
  ctx.save();
  ctx.translate(plotX - 25, plotY + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Reflection Angle (\u03B8)', 0, 0);
  ctx.restore();

  ctx.fillStyle = '#8af';
  ctx.font = 'bold 13px Segoe UI';
  ctx.fillText('Phase Space (Poincare Section)', px + pw / 2, 25);

  // ticks
  ctx.fillStyle = '#5a7a98';
  ctx.font = '9px Segoe UI';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 4; i++) {
    const x = plotX + (i / 4) * plotW;
    ctx.fillText((i / 4).toFixed(1), x, plotY + plotH + 14);
  }
  ctx.textAlign = 'right';
  ctx.fillText('0', plotX - 5, plotY + plotH + 4);
  ctx.fillText('\u03C0/2', plotX - 5, plotY + plotH / 2 + 4);
  ctx.fillText('\u03C0', plotX - 5, plotY + 4);

  // divider
  ctx.strokeStyle = 'rgba(120,180,255,0.2)';
  ctx.beginPath();
  ctx.moveTo(px, 0);
  ctx.lineTo(px, H);
  ctx.stroke();

  // points
  for (const pt of phasePoints) {
    const x = plotX + pt.s * plotW;
    const y = plotY + plotH - (pt.theta / Math.PI) * plotH;
    ctx.fillStyle = pt.color;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(x - 1, y - 1, 2, 2);
  }
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  const p = getTableParams();

  // draw billiard table
  drawTable(p.cx, p.cy, p.R);

  // label
  ctx.fillStyle = '#8af';
  ctx.font = 'bold 13px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Billiard Table (' + shape + ')', p.panelW / 2, 25);

  // draw balls and trails
  for (const ball of balls) {
    ctx.strokeStyle = ball.color;
    ctx.lineWidth = 0.8;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    for (let i = 0; i < ball.trail.length; i++) {
      const t = ball.trail[i];
      if (i === 0) ctx.moveTo(p.cx + t.x, p.cy + t.y);
      else ctx.lineTo(p.cx + t.x, p.cy + t.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.fillStyle = ball.color;
    ctx.beginPath();
    ctx.arc(p.cx + ball.x, p.cy + ball.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  drawPhaseSpace();
}

function animate() {
  if (!paused) {
    const p = getTableParams();
    for (let i = 0; i < speed; i++) {
      for (const ball of balls) {
        stepBall(ball, p.R, 1);
      }
    }
  }
  draw();
  requestAnimationFrame(animate);
}

// Controls
document.querySelectorAll('[data-shape]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-shape]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    shape = btn.dataset.shape;
    resetAll();
  });
});

document.getElementById('sSpeed').addEventListener('input', e => {
  speed = parseInt(e.target.value);
  document.getElementById('vSpeed').textContent = speed;
});

document.getElementById('bClear').addEventListener('click', () => {
  phasePoints = [];
});

document.getElementById('bReset').addEventListener('click', resetAll);

canvas.addEventListener('click', e => {
  const p = getTableParams();
  const mx = e.clientX - p.cx;
  const my = e.clientY - p.cy;
  if (e.clientX < p.panelW && isInside(shape, mx, my, p.R)) {
    const angle = Math.random() * Math.PI * 2;
    balls.push(createBall(mx, my, angle));
  }
});

function resetAll() {
  balls = [];
  phasePoints = [];
  colorIndex = 0;
  // auto-launch one ball
  const p = getTableParams();
  let startX, startY;
  if (shape === 'sinai') {
    startX = p.R * 0.5;
    startY = p.R * 0.5;
  } else {
    startX = 0;
    startY = 0;
  }
  balls.push(createBall(startX, startY, 0.7));
}

window.reset = resetAll;

resetAll();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>