<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Triangular Billiard - Unsolved Problems</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(10,14,30,0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 240px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 8px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn { background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3); color: #8af; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px; }
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
#stats { position: fixed; bottom: 20px; left: 20px; z-index: 100; font-size: 0.85em; color: #6a8; background: rgba(10,14,30,0.6); backdrop-filter: blur(10px); padding: 8px 14px; border-radius: 8px; }
#triType { position: fixed; bottom: 55px; left: 20px; z-index: 100; font-size: 0.8em; background: rgba(10,14,30,0.6); backdrop-filter: blur(10px); padding: 8px 14px; border-radius: 8px; max-width: 340px; }
</style>
</head>
<body>
<a href="index.html">&larr; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Triangular Billiard</h3>
  <div class="ctrl-row">
    <label>Speed <span class="val" id="vSpeed">3</span></label>
    <input type="range" id="sSpeed" min="1" max="10" step="0.5" value="3">
  </div>
  <div class="ctrl-row">
    <label>Trail Length <span class="val" id="vTrail">3000</span></label>
    <input type="range" id="sTrail" min="100" max="10000" step="100" value="3000">
  </div>
  <div style="margin-top:10px;">
    <button class="btn" id="bFagnano">Fagnano Orbit</button>
    <button class="btn" id="bPreset1">Equilateral</button>
    <button class="btn" id="bPreset2">Right (30-60-90)</button>
    <button class="btn" id="bPreset3">Obtuse</button>
  </div>
  <div style="margin-top:8px; font-size:0.72em; color:#6a8;">Drag vertices to reshape. Click inside + drag for ball direction.</div>
</div>
<div id="triType" style="color:#8fa;"></div>
<div id="stats">Bounces: <span id="bounceCount">0</span></div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

// Triangle vertices (screen coords)
let verts = [];
let ball = { x: 0, y: 0, vx: 0, vy: 0 };
let trail = [];
let maxTrail = 3000;
let speed = 3;
let bounces = 0;
let paused = false;
let dragVert = -1;
let draggingBall = false, dragStart = null;
let showFagnano = false;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  if (verts.length === 0) resetTriangle();
}

function resetTriangle() {
  const cx = W / 2, cy = H / 2;
  const s = Math.min(W, H) * 0.32;
  verts = [
    { x: cx, y: cy - s },
    { x: cx - s * 0.9, y: cy + s * 0.6 },
    { x: cx + s * 0.9, y: cy + s * 0.6 }
  ];
  initBallInTriangle();
}

function setEquilateral() {
  const cx = W / 2, cy = H / 2;
  const s = Math.min(W, H) * 0.32;
  for (let i = 0; i < 3; i++) {
    const a = -Math.PI / 2 + (i * 2 * Math.PI / 3);
    verts[i] = { x: cx + s * Math.cos(a), y: cy + s * Math.sin(a) };
  }
  initBallInTriangle();
}

function setRight() {
  const cx = W / 2, cy = H / 2;
  const s = Math.min(W, H) * 0.32;
  verts = [
    { x: cx - s, y: cy + s * 0.6 },
    { x: cx + s, y: cy + s * 0.6 },
    { x: cx - s, y: cy - s * 0.6 }
  ];
  initBallInTriangle();
}

function setObtuse() {
  const cx = W / 2, cy = H / 2;
  const s = Math.min(W, H) * 0.32;
  verts = [
    { x: cx, y: cy - s * 0.3 },
    { x: cx - s * 1.2, y: cy + s * 0.6 },
    { x: cx + s * 1.2, y: cy + s * 0.6 }
  ];
  initBallInTriangle();
}

function triangleAngles() {
  const angles = [];
  for (let i = 0; i < 3; i++) {
    const a = verts[i], b = verts[(i + 1) % 3], c = verts[(i + 2) % 3];
    const ab = { x: b.x - a.x, y: b.y - a.y };
    const ac = { x: c.x - a.x, y: c.y - a.y };
    const dot = ab.x * ac.x + ab.y * ac.y;
    const la = Math.sqrt(ab.x * ab.x + ab.y * ab.y);
    const lb = Math.sqrt(ac.x * ac.x + ac.y * ac.y);
    angles.push(Math.acos(Math.max(-1, Math.min(1, dot / (la * lb)))));
  }
  return angles;
}

function triangleType() {
  const angles = triangleAngles();
  const maxA = Math.max(...angles);
  const deg90 = Math.PI / 2;
  if (Math.abs(maxA - deg90) < 0.03) return 'right';
  if (maxA > deg90) return 'obtuse';
  return 'acute';
}

function pointInTriangle(px, py) {
  const [a, b, c] = verts;
  const d1 = (px - b.x) * (a.y - b.y) - (a.x - b.x) * (py - b.y);
  const d2 = (px - c.x) * (b.y - c.y) - (b.x - c.x) * (py - c.y);
  const d3 = (px - a.x) * (c.y - a.y) - (c.x - a.x) * (py - a.y);
  const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
  const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
  return !(hasNeg && hasPos);
}

function initBallInTriangle() {
  trail = []; bounces = 0;
  const cx = (verts[0].x + verts[1].x + verts[2].x) / 3;
  const cy = (verts[0].y + verts[1].y + verts[2].y) / 3;
  ball.x = cx; ball.y = cy;
  const ang = Math.random() * Math.PI * 2;
  ball.vx = Math.cos(ang);
  ball.vy = Math.sin(ang);
  trail.push({ x: ball.x, y: ball.y });
  updateTriInfo();
}

function updateTriInfo() {
  const angles = triangleAngles();
  const degs = angles.map(a => (a * 180 / Math.PI).toFixed(1));
  const type = triangleType();
  const colors = { acute: '#8fa', right: '#ff8', obtuse: '#f88' };
  let msg = `${type.charAt(0).toUpperCase() + type.slice(1)} triangle: ${degs[0]}째 / ${degs[1]}째 / ${degs[2]}째`;
  if (type === 'obtuse') {
    msg += '\nWhether every obtuse triangle has a periodic billiard orbit is an open question!';
  }
  const el = document.getElementById('triType');
  el.textContent = msg;
  el.style.color = colors[type];
}

// Fagnano orbit: pedal triangle (feet of altitudes) - only for acute triangles
function fagnanoOrbit() {
  if (triangleType() !== 'acute') return null;
  const feet = [];
  for (let i = 0; i < 3; i++) {
    const a = verts[i];
    const b = verts[(i + 1) % 3];
    const c = verts[(i + 2) % 3];
    // Foot of altitude from a to side bc
    const bx = c.x - b.x, by = c.y - b.y;
    const t = ((a.x - b.x) * bx + (a.y - b.y) * by) / (bx * bx + by * by);
    feet.push({ x: b.x + t * bx, y: b.y + t * by });
  }
  return feet;
}

resize();

function edgeNormal(i) {
  const a = verts[i], b = verts[(i + 1) % 3];
  const dx = b.x - a.x, dy = b.y - a.y;
  const len = Math.sqrt(dx * dx + dy * dy);
  // Outward normal (assuming CCW winding, flip if needed)
  let nx = -dy / len, ny = dx / len;
  // Ensure it points inward (toward the third vertex)
  const c = verts[(i + 2) % 3];
  const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
  if (nx * (c.x - mx) + ny * (c.y - my) < 0) {
    nx = -nx; ny = -ny;
  }
  // We need outward normal for reflection, so negate
  return { x: -nx, y: -ny };
}

function segmentIntersect(px, py, dx, dy, ax, ay, bx, by) {
  const ex = bx - ax, ey = by - ay;
  const denom = dx * ey - dy * ex;
  if (Math.abs(denom) < 1e-12) return Infinity;
  const t = ((ax - px) * ey - (ay - py) * ex) / denom;
  const u = ((ax - px) * dy - (ay - py) * dx) / denom;
  if (u >= 0 && u <= 1 && t > 0.001) return t;
  return Infinity;
}

function update() {
  if (paused) return;
  for (let s = 0; s < speed * 2; s++) {
    // Find nearest wall intersection
    let minT = Infinity, hitEdge = -1;
    for (let i = 0; i < 3; i++) {
      const a = verts[i], b = verts[(i + 1) % 3];
      const t = segmentIntersect(ball.x, ball.y, ball.vx, ball.vy, a.x, a.y, b.x, b.y);
      if (t < minT) { minT = t; hitEdge = i; }
    }
    const step = Math.min(2, minT - 0.1);
    if (step > 0.01) {
      ball.x += ball.vx * step;
      ball.y += ball.vy * step;
    }
    if (minT < 2.5 && hitEdge >= 0) {
      // Move to wall
      ball.x += ball.vx * (minT - 0.5);
      ball.y += ball.vy * (minT - 0.5);
      // Reflect
      const n = edgeNormal(hitEdge);
      const dot = ball.vx * n.x + ball.vy * n.y;
      ball.vx -= 2 * dot * n.x;
      ball.vy -= 2 * dot * n.y;
      // Nudge inward
      ball.x -= n.x * 0.5;
      ball.y -= n.y * 0.5;
      bounces++;
    }
    trail.push({ x: ball.x, y: ball.y });
    if (trail.length > maxTrail) trail.shift();
  }
  document.getElementById('bounceCount').textContent = bounces;
}

function draw() {
  ctx.fillStyle = 'rgba(10,14,30,0.18)';
  ctx.fillRect(0, 0, W, H);

  const type = triangleType();
  const edgeColor = type === 'acute' ? 'rgba(100,200,150,0.4)' : type === 'right' ? 'rgba(255,220,80,0.4)' : 'rgba(255,100,100,0.4)';
  const glowColor = type === 'acute' ? '#44cc88' : type === 'right' ? '#ccaa44' : '#cc4444';

  // Triangle edges with glow
  ctx.shadowColor = glowColor;
  ctx.shadowBlur = 12;
  ctx.beginPath();
  ctx.moveTo(verts[0].x, verts[0].y);
  ctx.lineTo(verts[1].x, verts[1].y);
  ctx.lineTo(verts[2].x, verts[2].y);
  ctx.closePath();
  ctx.strokeStyle = edgeColor;
  ctx.lineWidth = 2.5;
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Vertex handles
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(verts[i].x, verts[i].y, 7, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(200,220,255,0.15)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(200,220,255,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Angle label
    const angles = triangleAngles();
    ctx.fillStyle = 'rgba(200,220,255,0.6)';
    ctx.font = '11px sans-serif';
    const cx = (verts[0].x + verts[1].x + verts[2].x) / 3;
    const cy = (verts[0].y + verts[1].y + verts[2].y) / 3;
    const offX = (verts[i].x - cx) * 0.2;
    const offY = (verts[i].y - cy) * 0.2;
    ctx.fillText((angles[i] * 180 / Math.PI).toFixed(1) + '째', verts[i].x + offX - 12, verts[i].y + offY);
  }

  // Fagnano orbit
  if (showFagnano) {
    const f = fagnanoOrbit();
    if (f) {
      ctx.beginPath();
      ctx.moveTo(f[0].x, f[0].y);
      ctx.lineTo(f[1].x, f[1].y);
      ctx.lineTo(f[2].x, f[2].y);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(255,200,80,0.7)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
      for (const p of f) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#ffcc44';
        ctx.fill();
      }
    }
  }

  // Trail
  if (trail.length > 1) {
    const len = trail.length;
    for (let i = 1; i < len; i++) {
      const t = i / len;
      const hue = type === 'acute' ? 120 + t * 60 : type === 'right' ? 40 + t * 30 : 0 + t * 30;
      ctx.beginPath();
      ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
      ctx.lineTo(trail[i].x, trail[i].y);
      ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${t * 0.6})`;
      ctx.lineWidth = 1 + t * 1.3;
      ctx.stroke();
    }
  }

  // Ball
  ctx.shadowColor = '#88ccff';
  ctx.shadowBlur = 18;
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, 4, 0, Math.PI * 2);
  ctx.fillStyle = '#bbddff';
  ctx.fill();
  ctx.shadowBlur = 0;
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Drag vertices
canvas.addEventListener('mousedown', function(e) {
  for (let i = 0; i < 3; i++) {
    const dx = e.clientX - verts[i].x, dy = e.clientY - verts[i].y;
    if (dx * dx + dy * dy < 400) { dragVert = i; return; }
  }
  if (pointInTriangle(e.clientX, e.clientY)) {
    draggingBall = true;
    dragStart = { x: e.clientX, y: e.clientY };
  }
});
canvas.addEventListener('mousemove', function(e) {
  if (dragVert >= 0) {
    verts[dragVert].x = e.clientX;
    verts[dragVert].y = e.clientY;
    updateTriInfo();
  }
});
canvas.addEventListener('mouseup', function(e) {
  if (dragVert >= 0) {
    dragVert = -1;
    // Reinit ball if outside triangle
    if (!pointInTriangle(ball.x, ball.y)) initBallInTriangle();
  }
  if (draggingBall && dragStart) {
    const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len > 5) {
      trail = []; bounces = 0;
      ball.x = dragStart.x; ball.y = dragStart.y;
      ball.vx = dx / len; ball.vy = dy / len;
      trail.push({ x: ball.x, y: ball.y });
    }
    draggingBall = false; dragStart = null;
  }
});

// Controls
document.getElementById('sSpeed').addEventListener('input', function() {
  speed = parseFloat(this.value);
  document.getElementById('vSpeed').textContent = speed;
});
document.getElementById('sTrail').addEventListener('input', function() {
  maxTrail = parseInt(this.value);
  document.getElementById('vTrail').textContent = maxTrail;
});
document.getElementById('bFagnano').addEventListener('click', function() {
  showFagnano = !showFagnano;
  this.classList.toggle('active');
  if (showFagnano && triangleType() === 'acute') {
    // Launch ball along the Fagnano orbit
    const f = fagnanoOrbit();
    if (f) {
      trail = []; bounces = 0;
      ball.x = f[0].x; ball.y = f[0].y;
      const dx = f[1].x - f[0].x, dy = f[1].y - f[0].y;
      const len = Math.sqrt(dx * dx + dy * dy);
      ball.vx = dx / len; ball.vy = dy / len;
      trail.push({ x: ball.x, y: ball.y });
    }
  }
});
document.getElementById('bPreset1').addEventListener('click', setEquilateral);
document.getElementById('bPreset2').addEventListener('click', setRight);
document.getElementById('bPreset3').addEventListener('click', setObtuse);

window.addEventListener('resize', function() { resize(); });
window.addEventListener('keydown', function(e) {
  if (e.code === 'Space') { e.preventDefault(); paused = !paused; }
});

window.reset = function() {
  resetTriangle();
  ctx.clearRect(0, 0, W, H);
};

requestAnimationFrame(loop);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>