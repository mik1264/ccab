<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StoryLeaf Branch Visualizer - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e8e6e1;
            overflow: hidden;
        }

        #container { width: 100vw; height: 100vh; }

        /* Loading */
        #loading {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            width: 50px; height: 50px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #7ecf8a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* Error */
        #error {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(225,29,72,0.9);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            z-index: 1001;
        }

        #error h2 { margin: 0 0 1rem; font-size: 1.5rem; }

        /* Back Link */
        .back-link {
            position: fixed;
            top: 10px; left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            color: #7ecf8a;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(126,207,138,0.2);
            transform: translateX(-4px);
        }

        /* Title Overlay */
        #title-overlay {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 998;
            pointer-events: none;
        }

        #title-overlay h1 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #7ecf8a;
            text-shadow: 0 0 20px rgba(126,207,138,0.3);
            letter-spacing: 0.05em;
        }

        #title-overlay p {
            font-size: 0.8rem;
            color: rgba(232,230,225,0.5);
            margin-top: 2px;
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 80px; right: 10px;
            background: rgba(0,0,0,0.7);
            color: #7ecf8a;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 999;
        }

        .fps-good { color: #10b981; }
        .fps-medium { color: #fbbf24; }
        .fps-poor { color: #e11d48; }

        /* Story Panel */
        #story-panel {
            position: fixed;
            top: 0; right: -420px;
            width: 400px;
            height: 100vh;
            background: rgba(10,14,26,0.95);
            border-left: 1px solid rgba(126,207,138,0.2);
            z-index: 1000;
            transition: right 0.4s cubic-bezier(0.16,1,0.3,1);
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(20px);
        }

        #story-panel.open { right: 0; }

        .panel-header {
            padding: 20px;
            border-bottom: 1px solid rgba(126,207,138,0.15);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .panel-header h2 {
            font-size: 1.1rem;
            color: #7ecf8a;
            max-width: 300px;
        }

        .panel-close {
            background: none;
            border: 1px solid rgba(126,207,138,0.3);
            color: #7ecf8a;
            width: 30px; height: 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .panel-close:hover {
            background: rgba(126,207,138,0.15);
        }

        .panel-meta {
            padding: 12px 20px;
            border-bottom: 1px solid rgba(126,207,138,0.1);
            display: flex;
            gap: 16px;
            font-size: 0.8rem;
            color: rgba(232,230,225,0.5);
        }

        .panel-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .meta-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .panel-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
            font-size: 0.95rem;
            color: rgba(232,230,225,0.85);
        }

        .panel-body p { margin-bottom: 1em; }

        .panel-children {
            padding: 0 20px 20px;
            border-top: 1px solid rgba(126,207,138,0.1);
        }

        .panel-children h3 {
            font-size: 0.85rem;
            color: rgba(232,230,225,0.5);
            margin: 12px 0 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .child-branch {
            display: block;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(126,207,138,0.05);
            border: 1px solid rgba(126,207,138,0.1);
            border-radius: 8px;
            color: #7ecf8a;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            text-decoration: none;
        }

        .child-branch:hover {
            background: rgba(126,207,138,0.15);
            transform: translateX(4px);
        }

        .child-branch .branch-readers {
            font-size: 0.75rem;
            color: rgba(232,230,225,0.4);
            margin-left: 8px;
        }

        /* Controls */
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 999;
        }

        .ctrl-btn {
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(126,207,138,0.3);
            color: #7ecf8a;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            font-family: inherit;
        }

        .ctrl-btn:hover {
            background: rgba(126,207,138,0.15);
        }

        .ctrl-btn.active {
            background: rgba(126,207,138,0.2);
            border-color: #7ecf8a;
        }

        /* Legend */
        #legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.75rem;
            z-index: 998;
            border: 1px solid rgba(126,207,138,0.15);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-item:last-child { margin-bottom: 0; }

        .legend-swatch {
            width: 12px; height: 12px;
            border-radius: 50%;
        }

        /* Stats bar */
        #stats-bar {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 0.75rem;
            z-index: 998;
            border: 1px solid rgba(126,207,138,0.15);
            line-height: 1.6;
        }

        .stat-label { color: rgba(232,230,225,0.4); }
        .stat-value { color: #7ecf8a; font-weight: 600; }

        /* Tooltip */
        #tooltip {
            position: fixed;
            display: none;
            background: rgba(10,14,26,0.95);
            border: 1px solid rgba(126,207,138,0.3);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1100;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }

        .tooltip-title {
            color: #7ecf8a;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .tooltip-author {
            color: rgba(232,230,225,0.5);
            font-size: 0.75rem;
        }

        /* Growth notification */
        .growth-notification {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: rgba(126,207,138,0.15);
            border: 1px solid rgba(126,207,138,0.3);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: #7ecf8a;
            z-index: 1000;
            opacity: 0;
            transition: all 0.4s ease;
            pointer-events: none;
        }

        .growth-notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        @media (max-width: 600px) {
            #story-panel { width: 100vw; right: -100vw; }
            #legend { display: none; }
            #stats-bar { font-size: 0.65rem; padding: 6px 10px; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="title-overlay">
        <h1>StoryLeaf Branch Visualizer</h1>
        <p>Click any node to read its story fragment. Scroll to zoom. Drag to orbit.</p>
    </div>

    <div id="fps-counter">FPS: <span id="fps-value">0</span></div>

    <div id="stats-bar">
        <span class="stat-label">Nodes: </span><span class="stat-value" id="stat-nodes">0</span><br>
        <span class="stat-label">Branches: </span><span class="stat-value" id="stat-branches">0</span><br>
        <span class="stat-label">Max Depth: </span><span class="stat-value" id="stat-depth">0</span><br>
        <span class="stat-label">Readers: </span><span class="stat-value" id="stat-readers">0</span>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <p>Growing the story tree...</p>
    </div>

    <div id="error">
        <h2>Error Loading Demo</h2>
        <p id="error-message"></p>
    </div>

    <div id="tooltip">
        <div class="tooltip-title" id="tooltip-title"></div>
        <div class="tooltip-author" id="tooltip-author"></div>
    </div>

    <div class="growth-notification" id="growth-notif">New branch added!</div>

    <div id="story-panel">
        <div class="panel-header">
            <h2 id="panel-title">Story Fragment</h2>
            <button class="panel-close" id="panel-close">&times;</button>
        </div>
        <div class="panel-meta" id="panel-meta"></div>
        <div class="panel-body" id="panel-body"></div>
        <div class="panel-children" id="panel-children"></div>
    </div>

    <div id="controls">
        <button class="ctrl-btn" id="btn-reset">Reset View</button>
        <button class="ctrl-btn" id="btn-top">Top View</button>
        <button class="ctrl-btn active" id="btn-grow">Auto-Grow: ON</button>
        <button class="ctrl-btn" id="btn-color">Color: Author</button>
    </div>

    <div id="legend">
        <div class="legend-item">
            <div class="legend-swatch" style="background:#7ecf8a;"></div>
            <span>Root node</span>
        </div>
        <div class="legend-item">
            <div class="legend-swatch" style="background:#f9a825;"></div>
            <span>Popular path</span>
        </div>
        <div class="legend-item">
            <div class="legend-swatch" style="background:#42a5f5;"></div>
            <span>Recent branch</span>
        </div>
        <div class="legend-item">
            <div class="legend-swatch" style="background: rgba(126,207,138,0.3);"></div>
            <span>Unexplored</span>
        </div>
    </div>

    <div id="container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        window.addEventListener('error', (e) => {
            showError(`Runtime Error: ${e.message}`);
        });

        function showError(msg) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error-message').textContent = msg;
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // ─── FPS Counter ────────────────────────────────
        class FPSCounter {
            constructor() {
                this.fps = 0;
                this.frames = 0;
                this.lastTime = performance.now();
                this.el = document.getElementById('fps-value');
            }
            update() {
                this.frames++;
                const now = performance.now();
                const dt = now - this.lastTime;
                if (dt >= 1000) {
                    this.fps = Math.round((this.frames * 1000) / dt);
                    this.frames = 0;
                    this.lastTime = now;
                    this.el.textContent = this.fps;
                    this.el.className = this.fps >= 55 ? 'fps-good' : this.fps >= 30 ? 'fps-medium' : 'fps-poor';
                }
            }
        }

        // ─── Story Data Generator ───────────────────────
        const AUTHORS = [
            { name: 'Elena Moss', color: 0x7ecf8a },
            { name: 'Kai Tanaka', color: 0x42a5f5 },
            { name: 'Ava Blackwood', color: 0xf9a825 },
            { name: 'Marcus Reed', color: 0xef5350 },
            { name: 'Luna Vargas', color: 0xab47bc },
            { name: 'Jin Woo-Park', color: 0x26c6da },
            { name: 'Sienna Okafor', color: 0xff7043 },
            { name: 'Rowan Hale', color: 0x66bb6a }
        ];

        const STORY_FRAGMENTS = [
            {
                title: "The Hollow Gate",
                text: "The gate appeared at dawn, rising from the mist like a wound in the world. Its frame was carved from a wood that had no name — dark, veined with silver, warm to the touch despite the frost. Lira pressed her palm to the surface and felt it hum. Not a sound, but a vibration that settled into her bones. She had been warned about the gates. Everyone had. But warnings felt like old clothes: worn thin and too small for the shape of her curiosity."
            },
            {
                title: "Through the Canopy",
                text: "Above, the canopy closed like a cathedral ceiling painted in every shade of green. Shafts of light fell in columns, each one alive with motes of pollen and dust. Kai moved through the forest without a trail, guided only by the pull he'd felt since childhood — a tug behind his sternum, faint but insistent. The trees here were ancient. Their roots surfaced like the spines of sleeping dragons, and their bark was written in a language he was only beginning to read."
            },
            {
                title: "The Cartographer's Dilemma",
                text: "The map refused to stay still. Every time Ava unrolled the parchment, the coastlines had shifted, the mountains had migrated east, and one river — the Selenne — had coiled itself into a new shape entirely. She weighted the corners with stones and watched, breath held, as a forest sprouted in real time where yesterday there had been desert. 'The world is dreaming,' her teacher had said. 'Your job is to draw it before it wakes.'"
            },
            {
                title: "Beneath the Signal",
                text: "Marcus pressed his headphones tighter. Beneath the static, beneath the hiss and crackle of a dying frequency, there was something. A pattern. Not music, not speech — something older. He'd been monitoring this signal for three weeks from the rooftop of the abandoned observatory, and tonight, for the first time, the pattern had changed. Three pulses, then silence. Three pulses, then a frequency so low it felt like the earth was breathing."
            },
            {
                title: "The Seed Vault",
                text: "Luna descended the stairs with practiced care. The vault stretched out before her, row upon row of glass cylinders fogged with condensation. Inside each one: a seed. Not the ordinary kind — not wheat or corn or sunflower. These seeds held memories. Plant one, and a tree would grow that bore fruit containing someone's lost afternoon, someone's forgotten name. The vault was the last library, and Luna was its only reader."
            },
            {
                title: "The River Remembers",
                text: "Jin stood at the river's edge where the water ran silver under moonlight. This was the Selenne — the river that appeared on no two maps the same way. He knelt and dipped his hand. Cold. Then warm. Then something else entirely: a rush of images, faces, voices speaking in a tongue he didn't know but somehow understood. The river remembered everything that had ever touched its surface, and tonight, it wanted to tell him a story."
            },
            {
                title: "Clockwork Garden",
                text: "Sienna wound the key three turns. The garden shuddered. Then, with the precision of a master watchmaker's dream, it unfolded. Brass petals spiraled open. Copper vines extended along invisible trellises. Tiny gears whirred inside crystal stems, pumping something luminous — not sap, not oil, but something between light and liquid. Her grandmother had built this garden in the years before the silence, when machines still listened to the people who made them."
            },
            {
                title: "The Last Translation",
                text: "Rowan stared at the final page. After four years of work, the translation was nearly complete — every symbol decoded, every glyph mapped to its meaning. The text was a warning. It described a door that should never be opened, a sound that should never be sung, and a name that, once spoken, could not be taken back. His pen hovered. The last word was also a name. His name. Written in a language that had been dead for ten thousand years."
            },
            {
                title: "The Whale's Archive",
                text: "Deep beneath the grey-green swells, the whale sang. But this was no ordinary song — it was layered, harmonic, dense with data that human ears could only graze. Lira's underwater microphone trembled with the weight of it. She'd theorized for years that whale song was more than communication. It was storage. Each phrase, a compressed archive of oceanic memory: temperature, current, the position of every school of fish. The sea had its own librarian."
            },
            {
                title: "Ember Market",
                text: "The market only appeared on nights when two moons were visible — a rare alignment that happened perhaps three times a year. Kai navigated the stalls by lantern-light, each vendor offering something impossible: bottled lightning, folded shadows, jars of preserved silence. He was looking for one stall in particular — the old woman who traded in moments. Specifically, she could sell you a moment you'd never lived, stitched so seamlessly into your memory that you'd swear it had always been yours."
            },
            {
                title: "The Observatory Sings",
                text: "When the dome opened, the stars poured in like music. Ava climbed the ladder to the ancient telescope and pressed her eye to the cold brass eyepiece. The stars were wrong. Not displaced — rearranged. As if someone had reached into the sky and shuffled the constellations like cards. She checked her charts, triple-checked her coordinates. The North Star hadn't moved in ten thousand years. Tonight, it was gone."
            },
            {
                title: "Root Network",
                text: "The roots spoke in chemical whispers. Marcus had finally cracked the protocol — the molecular language that trees used to communicate through their fungal networks. Phosphorus meant danger. Nitrogen meant plenty. But tonight, the roots were transmitting something unprecedented: a complex sugar molecule that, when decoded, resolved into what could only be described as a question. The forest was asking something, and it was waiting for an answer."
            },
            {
                title: "The Paper Rebellion",
                text: "Luna unfolded the origami crane and read the message hidden in its creases. The resistance communicated only in paper — folded, passed hand to hand, dissolved in water after reading. In a world where every screen was watched and every voice recorded, paper was the last private medium. She refolded the crane, adding her own message in a crease only her contact would know to check, and set it on the windowsill to be collected by the wind."
            },
            {
                title: "Tide Glass",
                text: "Jin collected the glass the sea had made: fragments tumbled smooth by decades of salt and sand, each one holding a faint prismatic glow. But these weren't ordinary sea-glass pieces. When held to the light at the correct angle, each one projected an image — a moment from the life of whoever had last held the original bottle or window or cup before it shattered and fell into the ocean. He arranged them in a mosaic on his workshop table and watched a stranger's life unspool in colored light."
            },
            {
                title: "Spore Drift",
                text: "The spores drifted like snow through the abandoned city. Sienna watched from behind her respirator as they settled on concrete, on steel, on the skeletal frames of cars. Where they landed, green erupted: vines, moss, ferns unfurling with impossible speed. The biologists called it accelerated succession. Sienna called it what it was — the planet's immune response, finally strong enough to reclaim what had been taken."
            },
            {
                title: "The Dream Cartography",
                text: "Rowan pinned another thread to the map on his wall. Red for recurring dreams, blue for nightmares, gold for the rare lucid ones. After cataloguing six hundred dreams from three hundred volunteers, a pattern had emerged. Everyone — regardless of age, culture, or geography — shared exactly one dream. A door. A red door, standing alone in an empty white room. No one could open it. No one could look away. And the door was always, always slightly ajar."
            },
            {
                title: "The Lighthouse Code",
                text: "The lighthouse had been dark for twenty years. When its beam suddenly returned, cutting through the coastal fog like a blade, the harbor town of Mere Point erupted in confusion. The lighthouse was sealed — cemented shut after the last keeper vanished. But someone, or something, was operating the light. Lira watched from the clifftop as the beam swept, paused, swept again. Not a random pattern. A code. She reached for her notebook and began counting the intervals."
            },
            {
                title: "Woven Frequencies",
                text: "Kai ran his fingers across the tapestry. To the eye it was beautiful — threads of indigo and gold forming geometric patterns that seemed to shift as he moved. But when he held his frequency scanner against the weave, the readings were unmistakable: encoded in the spacing of the threads, in the tension of the warp and weft, was a radio signal. Someone had woven a broadcast into fabric. The tapestry was six hundred years old."
            },
            {
                title: "The Frost Equation",
                text: "The frost on the window was mathematical. Not in the vague, poetic sense — Ava had confirmed it with calipers and a microscope. Each crystal branched according to a specific recursive formula, and the formula was not one found in nature. It was artificial, designed, planted. Someone had engineered frost that, when decoded, would yield a proof. A proof of what, she didn't yet know. But the frost was spreading, and the equation was growing more complex by the hour."
            },
            {
                title: "Memory Coral",
                text: "The coral was dying. Bleached white, brittle, crumbling at Marcus's touch. But within its calcium lattice, patterns persisted — ridges and channels too regular to be natural. Under the electron microscope, the truth emerged: the coral had been encoding data. Water temperature, salinity, pH — centuries of environmental records, written in bone-like mineral by an organism with no brain, no nervous system, and no reason to remember. And yet it had remembered everything."
            },
            {
                title: "The Silence Collector",
                text: "Luna's collection was housed in mason jars, each one sealed with wax and labeled in her careful hand. Jar 47: Silence of a cathedral at 3 AM. Jar 112: Silence after a child's question that no one could answer. Jar 203: The silence between lightning and thunder. They looked empty, and in every measurable way they were. But when she unscrewed a lid and held the jar to her ear, each silence had its own texture, its own weight, its own particular way of pressing against the eardrum."
            }
        ];

        const BRANCH_TITLES = [
            "follows the signal deeper", "turns back to warn the others", "opens the hidden door",
            "chooses the mountain path", "decodes the second message", "refuses the offer",
            "enters the Archive alone", "trusts the stranger", "follows the river upstream",
            "waits until nightfall", "takes the forbidden route", "breaks the seal",
            "calls out into the dark", "climbs the tower", "reads the inscription aloud",
            "plants the last seed", "ignites the beacon", "descends into the vault",
            "confronts the keeper", "crosses the threshold", "rewrites the map",
            "sings the forgotten melody", "releases the signal", "embraces the silence",
            "shatters the glass", "unweaves the tapestry", "follows the frost line",
            "listens to the coral", "opens the final jar", "speaks the name"
        ];

        // ─── Tree Data Structure ────────────────────────
        let nodeIdCounter = 0;
        const allNodes = [];

        function createNode(parentId, depth) {
            const author = AUTHORS[Math.floor(Math.random() * AUTHORS.length)];
            const fragment = STORY_FRAGMENTS[Math.floor(Math.random() * STORY_FRAGMENTS.length)];
            const branchTitle = parentId === null
                ? fragment.title
                : BRANCH_TITLES[Math.floor(Math.random() * BRANCH_TITLES.length)];

            const readers = parentId === null
                ? 500 + Math.floor(Math.random() * 2000)
                : Math.max(1, Math.floor((allNodes[parentId]?.readers || 100) * (0.2 + Math.random() * 0.6)));

            const node = {
                id: nodeIdCounter++,
                parentId,
                depth,
                author,
                title: branchTitle,
                fragment: fragment.text,
                fragmentTitle: fragment.title,
                readers,
                children: [],
                timestamp: Date.now() - Math.floor(Math.random() * 30 * 24 * 60 * 60 * 1000),
                mesh: null,
                line: null,
                targetPos: new THREE.Vector3(),
                currentPos: new THREE.Vector3(),
                scale: 0,
                targetScale: 1
            };

            allNodes.push(node);

            if (parentId !== null && allNodes[parentId]) {
                allNodes[parentId].children.push(node.id);
            }

            return node;
        }

        // Layout: radial tree expanding outward and upward
        function layoutTree() {
            const depthSpacing = 3.5;
            const visited = new Set();

            function layoutSubtree(nodeId, angleStart, angleEnd, radius) {
                if (visited.has(nodeId)) return;
                visited.add(nodeId);

                const node = allNodes[nodeId];
                if (!node) return;

                if (node.parentId === null) {
                    node.targetPos.set(0, 0, 0);
                } else {
                    const angleMid = (angleStart + angleEnd) / 2;
                    const y = node.depth * depthSpacing;
                    const r = radius;
                    node.targetPos.set(
                        Math.cos(angleMid) * r,
                        y,
                        Math.sin(angleMid) * r
                    );
                }

                const children = node.children;
                if (children.length === 0) return;

                const angleRange = angleEnd - angleStart;
                const childAngleStep = angleRange / children.length;

                children.forEach((childId, i) => {
                    const cStart = angleStart + childAngleStep * i;
                    const cEnd = cStart + childAngleStep;
                    const childRadius = radius + 1.5 + Math.random() * 1.0;
                    layoutSubtree(childId, cStart, cEnd, childRadius);
                });
            }

            if (allNodes.length > 0) {
                layoutSubtree(0, 0, Math.PI * 2, 2.5);
            }
        }

        // Generate initial tree
        function generateInitialTree() {
            const root = createNode(null, 0);

            // Level 1: 3-5 main branches
            const l1Count = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < l1Count; i++) {
                const l1 = createNode(root.id, 1);

                // Level 2: 1-4 branches each
                const l2Count = 1 + Math.floor(Math.random() * 4);
                for (let j = 0; j < l2Count; j++) {
                    const l2 = createNode(l1.id, 2);

                    // Level 3: 0-3 branches
                    const l3Count = Math.floor(Math.random() * 4);
                    for (let k = 0; k < l3Count; k++) {
                        const l3 = createNode(l2.id, 3);

                        // Level 4: 0-2 branches
                        const l4Count = Math.floor(Math.random() * 3);
                        for (let m = 0; m < l4Count; m++) {
                            const l4 = createNode(l3.id, 4);

                            // Level 5: 0-1 branches
                            if (Math.random() > 0.5) {
                                createNode(l4.id, 5);
                            }
                        }
                    }
                }
            }

            layoutTree();
        }

        // ─── Three.js Scene ─────────────────────────────
        try {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e1a);
            scene.fog = new THREE.FogExp2(0x0a0e1a, 0.018);

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(12, 15, 12);
            camera.lookAt(0, 5, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.target.set(0, 5, 0);
            controls.maxDistance = 60;
            controls.minDistance = 3;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x334455, 0.6);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);

            const accentLight = new THREE.PointLight(0x7ecf8a, 0.5, 50);
            accentLight.position.set(-5, 10, -5);
            scene.add(accentLight);

            const warmLight = new THREE.PointLight(0xf9a825, 0.3, 40);
            warmLight.position.set(5, 8, 5);
            scene.add(warmLight);

            // Ground plane
            const groundGeo = new THREE.CircleGeometry(30, 64);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0d1220,
                roughness: 0.9,
                metalness: 0.1,
                transparent: true,
                opacity: 0.5
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);

            // Ground grid
            const gridHelper = new THREE.GridHelper(30, 30, 0x1a2040, 0x141830);
            gridHelper.position.y = -0.05;
            scene.add(gridHelper);

            // Particle field
            const particleCount = 800;
            const particleGeo = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = (Math.random() - 0.5) * 50;
                particlePositions[i * 3 + 1] = Math.random() * 25;
                particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                particleSizes[i] = Math.random() * 2 + 0.5;
            }
            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            const particleMat = new THREE.PointsMaterial({
                color: 0x7ecf8a,
                size: 0.08,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            const particles = new THREE.Points(particleGeo, particleMat);
            scene.add(particles);

            // ─── Node/Edge Rendering ────────────────────
            const nodeGroup = new THREE.Group();
            const edgeGroup = new THREE.Group();
            scene.add(nodeGroup);
            scene.add(edgeGroup);

            // Shared geometries
            const nodeSphereGeo = new THREE.SphereGeometry(1, 16, 12);
            const nodeGlowGeo = new THREE.SphereGeometry(1.3, 16, 12);

            let colorMode = 'author'; // 'author' | 'popularity' | 'depth'

            function getNodeColor(node) {
                if (colorMode === 'author') {
                    return node.author.color;
                } else if (colorMode === 'popularity') {
                    const maxReaders = allNodes.reduce((m, n) => Math.max(m, n.readers), 1);
                    const t = node.readers / maxReaders;
                    const col = new THREE.Color();
                    col.setHSL(0.08 + t * 0.25, 0.8, 0.4 + t * 0.3);
                    return col.getHex();
                } else {
                    const maxDepth = allNodes.reduce((m, n) => Math.max(m, n.depth), 1);
                    const t = node.depth / maxDepth;
                    const col = new THREE.Color();
                    col.setHSL(0.3 - t * 0.15, 0.6, 0.4 + t * 0.2);
                    return col.getHex();
                }
            }

            function getNodeSize(node) {
                const maxReaders = allNodes.reduce((m, n) => Math.max(m, n.readers), 1);
                const t = node.readers / maxReaders;
                return 0.15 + t * 0.4;
            }

            function createNodeMesh(node) {
                const size = getNodeSize(node);
                const color = getNodeColor(node);

                const mat = new THREE.MeshStandardMaterial({
                    color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    roughness: 0.4,
                    metalness: 0.6
                });

                const mesh = new THREE.Mesh(nodeSphereGeo, mat);
                mesh.scale.setScalar(0);
                mesh.castShadow = true;
                mesh.userData = { nodeId: node.id };

                // Glow
                const glowMat = new THREE.MeshBasicMaterial({
                    color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(nodeGlowGeo, glowMat);
                glow.scale.setScalar(1.4);
                mesh.add(glow);

                mesh.position.copy(node.currentPos);
                nodeGroup.add(mesh);
                node.mesh = mesh;
                node.scale = 0;

                return mesh;
            }

            function createEdge(node) {
                if (node.parentId === null) return;
                const parent = allNodes[node.parentId];
                if (!parent) return;

                const curve = new THREE.CubicBezierCurve3(
                    parent.currentPos.clone(),
                    new THREE.Vector3(
                        parent.currentPos.x,
                        parent.currentPos.y + (node.currentPos.y - parent.currentPos.y) * 0.6,
                        parent.currentPos.z
                    ),
                    new THREE.Vector3(
                        node.currentPos.x,
                        parent.currentPos.y + (node.currentPos.y - parent.currentPos.y) * 0.4,
                        node.currentPos.z
                    ),
                    node.currentPos.clone()
                );

                const points = curve.getPoints(20);
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);

                const maxReaders = allNodes.reduce((m, n) => Math.max(m, n.readers), 1);
                const t = node.readers / maxReaders;
                const lineColor = new THREE.Color().setHSL(0.38 - t * 0.1, 0.5, 0.25 + t * 0.3);

                const lineMat = new THREE.LineBasicMaterial({
                    color: lineColor,
                    transparent: true,
                    opacity: 0.3 + t * 0.5,
                    linewidth: 1
                });

                const line = new THREE.Line(lineGeo, lineMat);
                edgeGroup.add(line);
                node.line = line;
            }

            function updateEdge(node) {
                if (node.parentId === null || !node.line) return;
                const parent = allNodes[node.parentId];
                if (!parent) return;

                const curve = new THREE.CubicBezierCurve3(
                    parent.currentPos.clone(),
                    new THREE.Vector3(
                        parent.currentPos.x,
                        parent.currentPos.y + (node.currentPos.y - parent.currentPos.y) * 0.6,
                        parent.currentPos.z
                    ),
                    new THREE.Vector3(
                        node.currentPos.x,
                        parent.currentPos.y + (node.currentPos.y - parent.currentPos.y) * 0.4,
                        node.currentPos.z
                    ),
                    node.currentPos.clone()
                );

                const points = curve.getPoints(20);
                node.line.geometry.dispose();
                node.line.geometry = new THREE.BufferGeometry().setFromPoints(points);
            }

            function rebuildVisuals() {
                // Clear
                while (nodeGroup.children.length) {
                    const c = nodeGroup.children[0];
                    c.traverse(obj => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    });
                    nodeGroup.remove(c);
                }
                while (edgeGroup.children.length) {
                    const c = edgeGroup.children[0];
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                    edgeGroup.remove(c);
                }

                allNodes.forEach(node => {
                    node.currentPos.copy(node.targetPos);
                    createNodeMesh(node);
                    node.scale = 1;
                    node.mesh.scale.setScalar(getNodeSize(node));
                    createEdge(node);
                });
            }

            // ─── Generate & Render Initial Tree ─────────
            generateInitialTree();
            rebuildVisuals();
            updateStats();

            // ─── Interaction ────────────────────────────
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let hoveredNode = null;
            let selectedNode = null;

            const tooltip = document.getElementById('tooltip');
            const tooltipTitle = document.getElementById('tooltip-title');
            const tooltipAuthor = document.getElementById('tooltip-author');

            function onMouseMove(e) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodeGroup.children, false);

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    const nid = obj.userData.nodeId;
                    if (nid !== undefined) {
                        const node = allNodes[nid];
                        if (hoveredNode !== nid) {
                            hoveredNode = nid;
                            document.body.style.cursor = 'pointer';

                            tooltipTitle.textContent = node.title;
                            tooltipAuthor.textContent = `${node.author.name} · ${node.readers.toLocaleString()} readers`;
                        }
                        tooltip.style.display = 'block';
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY - 10) + 'px';
                    }
                } else {
                    if (hoveredNode !== null) {
                        hoveredNode = null;
                        document.body.style.cursor = 'default';
                        tooltip.style.display = 'none';
                    }
                }
            }

            function onMouseClick(e) {
                if (e.target.closest('#story-panel') || e.target.closest('#controls') ||
                    e.target.closest('.back-link') || e.target.closest('#legend') ||
                    e.target.closest('#stats-bar')) return;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodeGroup.children, false);

                if (intersects.length > 0) {
                    const nid = intersects[0].object.userData.nodeId;
                    if (nid !== undefined) {
                        openStoryPanel(nid);
                    }
                }
            }

            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);

            // ─── Story Panel ────────────────────────────
            const panel = document.getElementById('story-panel');
            const panelTitle = document.getElementById('panel-title');
            const panelMeta = document.getElementById('panel-meta');
            const panelBody = document.getElementById('panel-body');
            const panelChildren = document.getElementById('panel-children');

            function openStoryPanel(nodeId) {
                const node = allNodes[nodeId];
                if (!node) return;

                selectedNode = nodeId;

                // Highlight selected node
                allNodes.forEach(n => {
                    if (n.mesh) {
                        const baseIntensity = n.id === nodeId ? 0.8 : 0.3;
                        n.mesh.material.emissiveIntensity = baseIntensity;
                    }
                });

                panelTitle.textContent = node.fragmentTitle;

                const date = new Date(node.timestamp);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                panelMeta.innerHTML = `
                    <span><span class="meta-dot" style="background:#${node.author.color.toString(16).padStart(6, '0')};"></span> ${node.author.name}</span>
                    <span>${node.readers.toLocaleString()} readers</span>
                    <span>${dateStr}</span>
                    <span>Depth ${node.depth}</span>
                `;

                const branchLabel = node.parentId !== null ? `<p style="color:#7ecf8a;font-size:0.85rem;margin-bottom:8px;font-style:italic;">Branch: "${node.title}"</p>` : '';
                panelBody.innerHTML = branchLabel + `<p>${node.fragment}</p>`;

                if (node.children.length > 0) {
                    let childHtml = '<h3>Branch Paths</h3>';
                    node.children.forEach(cid => {
                        const child = allNodes[cid];
                        if (child) {
                            childHtml += `<a class="child-branch" data-node="${cid}">
                                "${child.title}"
                                <span class="branch-readers">${child.readers.toLocaleString()} readers</span>
                            </a>`;
                        }
                    });
                    panelChildren.innerHTML = childHtml;
                    panelChildren.style.display = 'block';

                    panelChildren.querySelectorAll('.child-branch').forEach(el => {
                        el.addEventListener('click', () => {
                            openStoryPanel(parseInt(el.dataset.node));
                        });
                    });
                } else {
                    panelChildren.innerHTML = '<h3>Leaf Node</h3><p style="font-size:0.8rem;color:rgba(232,230,225,0.4);padding-bottom:12px;">This branch has no further paths. A story ending — or a new beginning waiting to be written.</p>';
                    panelChildren.style.display = 'block';
                }

                panel.classList.add('open');
            }

            document.getElementById('panel-close').addEventListener('click', () => {
                panel.classList.remove('open');
                selectedNode = null;
                allNodes.forEach(n => {
                    if (n.mesh) n.mesh.material.emissiveIntensity = 0.3;
                });
            });

            // ─── Controls ───────────────────────────────
            let autoGrow = true;

            document.getElementById('btn-reset').addEventListener('click', () => {
                camera.position.set(12, 15, 12);
                controls.target.set(0, 5, 0);
            });

            document.getElementById('btn-top').addEventListener('click', () => {
                camera.position.set(0, 30, 0.1);
                controls.target.set(0, 0, 0);
            });

            document.getElementById('btn-grow').addEventListener('click', function() {
                autoGrow = !autoGrow;
                this.textContent = `Auto-Grow: ${autoGrow ? 'ON' : 'OFF'}`;
                this.classList.toggle('active', autoGrow);
            });

            document.getElementById('btn-color').addEventListener('click', function() {
                if (colorMode === 'author') {
                    colorMode = 'popularity';
                    this.textContent = 'Color: Popularity';
                } else if (colorMode === 'popularity') {
                    colorMode = 'depth';
                    this.textContent = 'Color: Depth';
                } else {
                    colorMode = 'author';
                    this.textContent = 'Color: Author';
                }

                // Update all node colors
                allNodes.forEach(node => {
                    if (node.mesh) {
                        const color = getNodeColor(node);
                        node.mesh.material.color.setHex(color);
                        node.mesh.material.emissive.setHex(color);
                        // Update glow
                        if (node.mesh.children[0]) {
                            node.mesh.children[0].material.color.setHex(color);
                        }
                    }
                });

                // Update legend
                updateLegend();
            });

            function updateLegend() {
                const legendEl = document.getElementById('legend');
                if (colorMode === 'author') {
                    legendEl.innerHTML = AUTHORS.slice(0, 5).map(a =>
                        `<div class="legend-item"><div class="legend-swatch" style="background:#${a.color.toString(16).padStart(6, '0')};"></div><span>${a.name}</span></div>`
                    ).join('') + `<div class="legend-item"><div class="legend-swatch" style="background:#888;"></div><span>+ ${AUTHORS.length - 5} more</span></div>`;
                } else if (colorMode === 'popularity') {
                    legendEl.innerHTML = `
                        <div class="legend-item"><div class="legend-swatch" style="background:#f9a825;"></div><span>Most popular</span></div>
                        <div class="legend-item"><div class="legend-swatch" style="background:#8ab34f;"></div><span>Moderate</span></div>
                        <div class="legend-item"><div class="legend-swatch" style="background:#5a7a3a;"></div><span>Least visited</span></div>
                    `;
                } else {
                    legendEl.innerHTML = `
                        <div class="legend-item"><div class="legend-swatch" style="background:#7ecf8a;"></div><span>Root (depth 0)</span></div>
                        <div class="legend-item"><div class="legend-swatch" style="background:#5aa06a;"></div><span>Mid-depth</span></div>
                        <div class="legend-item"><div class="legend-swatch" style="background:#3d7850;"></div><span>Deep branches</span></div>
                    `;
                }
            }

            // ─── Auto-Grow ──────────────────────────────
            let lastGrowTime = performance.now();
            const growInterval = 4000; // ms between new branches

            function growNewBranch() {
                // Pick a random leaf or shallow node
                const candidates = allNodes.filter(n => n.children.length < 3 && n.depth < 7);
                if (candidates.length === 0) return;

                const parent = candidates[Math.floor(Math.random() * candidates.length)];
                const newNode = createNode(parent.id, parent.depth + 1);
                layoutTree();

                newNode.currentPos.copy(allNodes[parent.id].currentPos);
                createNodeMesh(newNode);
                createEdge(newNode);

                // Show notification
                const notif = document.getElementById('growth-notif');
                notif.textContent = `New branch: "${newNode.title}" by ${newNode.author.name}`;
                notif.classList.add('show');
                setTimeout(() => notif.classList.remove('show'), 2500);

                updateStats();
            }

            function updateStats() {
                document.getElementById('stat-nodes').textContent = allNodes.length;
                const branches = allNodes.filter(n => n.children.length > 1).length;
                document.getElementById('stat-branches').textContent = branches;
                const maxDepth = allNodes.reduce((m, n) => Math.max(m, n.depth), 0);
                document.getElementById('stat-depth').textContent = maxDepth;
                const totalReaders = allNodes.reduce((s, n) => s + n.readers, 0);
                document.getElementById('stat-readers').textContent = totalReaders.toLocaleString();
            }

            // ─── Animation Loop ─────────────────────────
            const fpsCounter = new FPSCounter();
            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                fpsCounter.update();

                const dt = clock.getDelta();
                const time = clock.getElapsedTime();

                // Smooth position interpolation
                allNodes.forEach(node => {
                    if (node.mesh) {
                        node.currentPos.lerp(node.targetPos, 0.04);
                        node.mesh.position.copy(node.currentPos);

                        // Scale animation
                        const targetSize = getNodeSize(node);
                        node.scale += (node.targetScale - node.scale) * 0.05;
                        node.mesh.scale.setScalar(targetSize * node.scale);

                        // Subtle hover pulse
                        if (hoveredNode === node.id) {
                            const pulse = 1 + Math.sin(time * 4) * 0.08;
                            node.mesh.scale.multiplyScalar(pulse);
                        }

                        // Selected glow
                        if (selectedNode === node.id) {
                            node.mesh.material.emissiveIntensity = 0.5 + Math.sin(time * 3) * 0.3;
                        }

                        updateEdge(node);
                    }
                });

                // Particle drift
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 1] += Math.sin(time + i * 0.1) * 0.002;
                    positions[i * 3] += Math.cos(time * 0.3 + i * 0.05) * 0.001;
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Auto-grow
                if (autoGrow && performance.now() - lastGrowTime > growInterval && allNodes.length < 200) {
                    lastGrowTime = performance.now();
                    growNewBranch();
                }

                controls.update();
                renderer.render(scene, camera);
            }

            // Resize handler
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }, 150);
            });

            hideLoading();
            animate();

            // Cleanup
            window.addEventListener('beforeunload', () => {
                renderer.dispose();
                nodeSphereGeo.dispose();
                nodeGlowGeo.dispose();
                groundGeo.dispose();
                groundMat.dispose();
                particleGeo.dispose();
                particleMat.dispose();
            });

        } catch (error) {
            showError(`Initialization Error: ${error.message}`);
            console.error(error);
        }
    </script>
</body>
</html>
