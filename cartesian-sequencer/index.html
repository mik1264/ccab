<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>René-Style Cartesian Sequencer | CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --panel-bg: #1a1a1a;
            --panel-dark: #0d0d0d;
            --panel-light: #2a2a2a;
            --x-red: #ff4444;
            --x-red-dim: #661a1a;
            --y-green: #44ff44;
            --y-green-dim: #1a661a;
            --c-orange: #ff8844;
            --c-orange-dim: #663311;
            --knob-bg: #333;
            --knob-indicator: #eee;
            --led-off: #333;
            --text-dim: #666;
            --text-bright: #ccc;
            --cream: #FEFAE0;
            --sage: #8A9A5B;
            --moss: #606C38;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            min-height: 100vh;
            color: var(--text-bright);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* Back link */
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            text-decoration: none;
            color: var(--text-dim);
            font-size: 0.85rem;
            transition: all 0.3s ease;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-bright);
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 20px;
            margin-top: 40px;
        }

        .header h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            color: var(--text-bright);
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .header .subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        /* Main panel - Eurorack style */
        .module-panel {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow:
                0 20px 60px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.05);
            max-width: 900px;
            width: 100%;
        }

        /* Channel selector tabs */
        .channel-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .channel-tab {
            padding: 10px 25px;
            border: none;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .channel-tab.x-channel {
            background: var(--x-red-dim);
            color: var(--x-red);
        }

        .channel-tab.x-channel.active {
            background: var(--x-red);
            color: #000;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
        }

        .channel-tab.y-channel {
            background: var(--y-green-dim);
            color: var(--y-green);
        }

        .channel-tab.y-channel.active {
            background: var(--y-green);
            color: #000;
            box-shadow: 0 0 20px rgba(68, 255, 68, 0.4);
        }

        .channel-tab.c-channel {
            background: var(--c-orange-dim);
            color: var(--c-orange);
        }

        .channel-tab.c-channel.active {
            background: var(--c-orange);
            color: #000;
            box-shadow: 0 0 20px rgba(255, 136, 68, 0.4);
        }

        /* Page tabs */
        .page-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .page-tab {
            padding: 6px 14px;
            border: 1px solid var(--panel-light);
            border-radius: 4px;
            background: var(--panel-dark);
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .page-tab:hover {
            border-color: var(--text-dim);
        }

        .page-tab.active {
            background: var(--panel-light);
            color: var(--text-bright);
            border-color: var(--text-bright);
        }

        /* Main grid area */
        .grid-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* CV Knob Grid */
        .knob-grid {
            display: grid;
            grid-template-columns: repeat(4, 70px);
            grid-template-rows: repeat(4, 70px);
            gap: 8px;
            background: var(--panel-dark);
            padding: 12px;
            border-radius: 8px;
        }

        .knob-cell {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cv-knob {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #444, #222);
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 2px solid #555;
        }

        .cv-knob:hover {
            border-color: #777;
        }

        .cv-knob.active {
            box-shadow: 0 0 15px var(--c-orange);
        }

        .cv-knob .indicator {
            position: absolute;
            width: 4px;
            height: 18px;
            background: var(--knob-indicator);
            border-radius: 2px;
            top: 6px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
        }

        .cv-knob .led-ring {
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 3px solid transparent;
            transition: all 0.1s ease;
        }

        .cv-knob.lit .led-ring {
            border-color: var(--c-orange);
            box-shadow: 0 0 10px var(--c-orange);
        }

        .cv-knob.x-lit .led-ring {
            border-color: var(--x-red);
            box-shadow: 0 0 10px var(--x-red);
        }

        .cv-knob.y-lit .led-ring {
            border-color: var(--y-green);
            box-shadow: 0 0 10px var(--y-green);
        }

        .knob-value {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        /* Button Grid (for Access/Gate/Glide pages) */
        .button-grid {
            display: grid;
            grid-template-columns: repeat(4, 70px);
            grid-template-rows: repeat(4, 70px);
            gap: 8px;
            background: var(--panel-dark);
            padding: 12px;
            border-radius: 8px;
        }

        .grid-button {
            width: 56px;
            height: 56px;
            border-radius: 8px;
            border: none;
            background: var(--panel-light);
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-button:hover {
            background: #3a3a3a;
        }

        .grid-button .led {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--led-off);
            transition: all 0.1s ease;
        }

        .grid-button.on .led {
            background: var(--c-orange);
            box-shadow: 0 0 15px var(--c-orange);
        }

        .grid-button.x-on .led {
            background: var(--x-red);
            box-shadow: 0 0 15px var(--x-red);
        }

        .grid-button.y-on .led {
            background: var(--y-green);
            box-shadow: 0 0 15px var(--y-green);
        }

        .grid-button.current {
            border: 2px solid var(--c-orange);
        }

        /* Snake Pattern Selector */
        .snake-grid {
            display: grid;
            grid-template-columns: repeat(4, 70px);
            grid-template-rows: repeat(4, 70px);
            gap: 8px;
            background: var(--panel-dark);
            padding: 12px;
            border-radius: 8px;
        }

        .snake-button {
            width: 56px;
            height: 56px;
            border-radius: 8px;
            border: 2px solid var(--panel-light);
            background: var(--panel-bg);
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
        }

        .snake-button:hover {
            border-color: var(--text-dim);
        }

        .snake-button.selected {
            border-color: var(--c-orange);
            background: var(--c-orange-dim);
        }

        .snake-preview {
            width: 100%;
            height: 100%;
        }

        /* Control panel */
        .controls-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-section {
            background: var(--panel-dark);
            border-radius: 8px;
            padding: 12px;
        }

        .control-section h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        /* Transport */
        .transport-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        .transport-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 2px solid var(--panel-light);
            background: var(--panel-bg);
            color: var(--text-dim);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .transport-btn:hover {
            border-color: var(--text-bright);
            color: var(--text-bright);
        }

        .transport-btn.playing {
            border-color: var(--x-red);
            color: var(--x-red);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
        }

        /* Tempo control */
        .tempo-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tempo-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            color: var(--text-bright);
            min-width: 50px;
        }

        .param-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--panel-light);
            border-radius: 3px;
            outline: none;
        }

        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-bright);
            cursor: pointer;
        }

        /* Direction buttons */
        .direction-row {
            display: flex;
            gap: 8px;
        }

        .dir-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--panel-light);
            border-radius: 4px;
            background: var(--panel-bg);
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dir-btn:hover {
            border-color: var(--text-dim);
        }

        .dir-btn.active {
            background: var(--panel-light);
            color: var(--text-bright);
            border-color: var(--text-bright);
        }

        /* Clock dividers */
        .clock-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .clock-row label {
            font-size: 0.75rem;
            color: var(--text-dim);
            min-width: 50px;
        }

        .clock-select {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--panel-light);
            border-radius: 4px;
            background: var(--panel-bg);
            color: var(--text-bright);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        /* Quantization */
        .quant-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .note-btn {
            width: 32px;
            height: 28px;
            border: 1px solid var(--panel-light);
            border-radius: 3px;
            background: var(--panel-bg);
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .note-btn:hover {
            border-color: var(--text-dim);
        }

        .note-btn.active {
            background: var(--c-orange-dim);
            border-color: var(--c-orange);
            color: var(--c-orange);
        }

        .note-btn.black {
            background: var(--panel-dark);
        }

        /* Output section */
        .outputs-section {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: var(--panel-dark);
            border-radius: 8px;
        }

        .output-channel {
            flex: 1;
            text-align: center;
        }

        .output-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .output-label.x { color: var(--x-red); }
        .output-label.y { color: var(--y-green); }
        .output-label.c { color: var(--c-orange); }

        .output-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--text-bright);
        }

        .gate-led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--led-off);
            margin: 8px auto 0;
            transition: all 0.05s ease;
        }

        .gate-led.on {
            background: #fff;
            box-shadow: 0 0 10px #fff;
        }

        /* Scope */
        .scope-container {
            width: 100%;
            height: 60px;
            background: var(--panel-dark);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 10px;
        }

        #scopeCanvas {
            width: 100%;
            height: 100%;
        }

        /* Info bar */
        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            background: var(--panel-dark);
            border-radius: 6px;
            margin-top: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .info-item {
            color: var(--text-dim);
        }

        .info-item span {
            color: var(--text-bright);
        }

        /* Help text */
        .help-text {
            text-align: center;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 15px;
            opacity: 0.7;
        }

        /* Responsive */
        @media (max-width: 800px) {
            .grid-area {
                flex-direction: column;
            }

            .knob-grid, .button-grid, .snake-grid {
                grid-template-columns: repeat(4, 60px);
                grid-template-rows: repeat(4, 60px);
            }

            .cv-knob, .grid-button, .snake-button {
                width: 48px;
                height: 48px;
            }
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--panel-light);
            border-top-color: var(--c-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 15px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <!-- Loading -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">INITIALIZING...</div>
    </div>

    <!-- Back link -->
    <a href="../index.html" class="back-link">
        <span>←</span>
        <span>Gallery</span>
    </a>

    <header class="header">
        <h1>René</h1>
        <p class="subtitle">3D Cartesian Music Sequencer • Three Channels • 16 Snake Patterns</p>
    </header>

    <div class="module-panel">
        <!-- Channel selector -->
        <div class="channel-tabs">
            <button class="channel-tab x-channel active" data-channel="x">X</button>
            <button class="channel-tab y-channel" data-channel="y">Y</button>
            <button class="channel-tab c-channel" data-channel="c">C</button>
        </div>

        <!-- Page tabs -->
        <div class="page-tabs">
            <button class="page-tab active" data-page="cv">CV</button>
            <button class="page-tab" data-page="access">Access</button>
            <button class="page-tab" data-page="gate">Gate</button>
            <button class="page-tab" data-page="glide">Glide</button>
            <button class="page-tab" data-page="snake">Snake</button>
            <button class="page-tab" data-page="quant">Quant</button>
        </div>

        <div class="grid-area">
            <!-- CV Knob Grid (visible on CV page) -->
            <div class="knob-grid" id="knobGrid"></div>

            <!-- Button Grid (visible on Access/Gate/Glide pages) -->
            <div class="button-grid" id="buttonGrid" style="display: none;"></div>

            <!-- Snake Pattern Grid -->
            <div class="snake-grid" id="snakeGrid" style="display: none;"></div>

            <!-- Controls panel -->
            <div class="controls-panel">
                <!-- Transport -->
                <div class="control-section">
                    <h4>Transport</h4>
                    <div class="transport-row">
                        <button class="transport-btn" id="resetBtn" title="Reset">⟲</button>
                        <button class="transport-btn" id="playBtn" title="Play/Stop">▶</button>
                    </div>
                    <div class="tempo-control" style="margin-top: 12px;">
                        <span class="tempo-display" id="tempoDisplay">120</span>
                        <input type="range" class="param-slider" id="tempoSlider" min="30" max="300" value="120">
                        <span style="font-size: 0.7rem; color: var(--text-dim);">BPM</span>
                    </div>
                </div>

                <!-- X Clock -->
                <div class="control-section" id="xClockSection">
                    <h4 style="color: var(--x-red);">X Clock</h4>
                    <div class="clock-row">
                        <label>Div</label>
                        <select class="clock-select" id="xDivision">
                            <option value="0.25">1/16</option>
                            <option value="0.5">1/8</option>
                            <option value="1" selected>1/4</option>
                            <option value="2">1/2</option>
                            <option value="4">1 bar</option>
                        </select>
                    </div>
                    <div class="direction-row" style="margin-top: 8px;">
                        <button class="dir-btn active" data-axis="x" data-dir="fwd">FWD</button>
                        <button class="dir-btn" data-axis="x" data-dir="bwd">BWD</button>
                        <button class="dir-btn" data-axis="x" data-dir="pend">PEND</button>
                    </div>
                </div>

                <!-- Y Clock -->
                <div class="control-section" id="yClockSection">
                    <h4 style="color: var(--y-green);">Y Clock</h4>
                    <div class="clock-row">
                        <label>Div</label>
                        <select class="clock-select" id="yDivision">
                            <option value="0.25">1/16</option>
                            <option value="0.5">1/8</option>
                            <option value="1">1/4</option>
                            <option value="2" selected>1/2</option>
                            <option value="4">1 bar</option>
                        </select>
                    </div>
                    <div class="direction-row" style="margin-top: 8px;">
                        <button class="dir-btn active" data-axis="y" data-dir="fwd">FWD</button>
                        <button class="dir-btn" data-axis="y" data-dir="bwd">BWD</button>
                        <button class="dir-btn" data-axis="y" data-dir="pend">PEND</button>
                    </div>
                </div>

                <!-- Quantization (shown on Quant page) -->
                <div class="control-section" id="quantSection" style="display: none;">
                    <h4>Scale Notes</h4>
                    <div class="quant-row" id="quantNotes"></div>
                    <div class="clock-row">
                        <label>Octaves</label>
                        <select class="clock-select" id="octaveRange">
                            <option value="1">1 Oct</option>
                            <option value="2" selected>2 Oct</option>
                            <option value="3">3 Oct</option>
                            <option value="4">4 Oct</option>
                        </select>
                    </div>
                    <div class="clock-row" style="margin-top: 8px;">
                        <label>Root</label>
                        <select class="clock-select" id="rootNote">
                            <option value="0">C</option>
                            <option value="1">C#</option>
                            <option value="2">D</option>
                            <option value="3">D#</option>
                            <option value="4">E</option>
                            <option value="5">F</option>
                            <option value="6">F#</option>
                            <option value="7">G</option>
                            <option value="8">G#</option>
                            <option value="9">A</option>
                            <option value="10">A#</option>
                            <option value="11">B</option>
                        </select>
                    </div>
                </div>

                <!-- Scope -->
                <div class="scope-container">
                    <canvas id="scopeCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Outputs -->
        <div class="outputs-section">
            <div class="output-channel">
                <div class="output-label x">X CV</div>
                <div class="output-value" id="xCvOut">C4</div>
                <div class="gate-led" id="xGateLed"></div>
            </div>
            <div class="output-channel">
                <div class="output-label y">Y CV</div>
                <div class="output-value" id="yCvOut">C4</div>
                <div class="gate-led" id="yGateLed"></div>
            </div>
            <div class="output-channel">
                <div class="output-label c">C CV</div>
                <div class="output-value" id="cCvOut">C4</div>
                <div class="gate-led" id="cGateLed"></div>
            </div>
        </div>

        <!-- Info bar -->
        <div class="info-bar">
            <div class="info-item">X: <span id="xPosDisplay">0</span></div>
            <div class="info-item">Y: <span id="yPosDisplay">0</span></div>
            <div class="info-item">Snake: <span id="snakeDisplay">1</span></div>
            <div class="info-item">Step: <span id="stepDisplay">0</span></div>
        </div>
    </div>

    <p class="help-text">Click knobs to edit CV • Space to play/stop • R to reset • Based on Make Noise René</p>

    <script>
    // ============================================
    // RENÉ-STYLE CARTESIAN SEQUENCER
    // Three channels: X (Snake), Y (Snake), C (Cartesian)
    // ============================================

    const GRID_SIZE = 4;
    const TOTAL_STEPS = 16;
    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // 16 Snake patterns - each defines the order to traverse 16 grid positions
    // Positions are numbered 0-15 in row-major order (0-3 = row 0, 4-7 = row 1, etc.)
    const SNAKE_PATTERNS = [
        // 1: Left-to-right, bottom-to-top
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
        // 2: Boustrophedon (snake) horizontal
        [0, 1, 2, 3, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12],
        // 3: Right-to-left, bottom-to-top
        [3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12],
        // 4: Boustrophedon reverse
        [3, 2, 1, 0, 4, 5, 6, 7, 11, 10, 9, 8, 12, 13, 14, 15],
        // 5: Column-wise left-to-right
        [0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15],
        // 6: Boustrophedon vertical
        [0, 4, 8, 12, 13, 9, 5, 1, 2, 6, 10, 14, 15, 11, 7, 3],
        // 7: Column-wise right-to-left
        [3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12],
        // 8: Spiral inward clockwise
        [0, 1, 2, 3, 7, 11, 15, 14, 13, 12, 8, 4, 5, 6, 10, 9],
        // 9: Spiral inward counter-clockwise
        [0, 4, 8, 12, 13, 14, 15, 11, 7, 3, 2, 1, 5, 9, 10, 6],
        // 10: Diagonal zigzag
        [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15],
        // 11: Anti-diagonal
        [3, 2, 6, 1, 5, 9, 0, 4, 8, 12, 13, 10, 7, 14, 11, 15],
        // 12: Center outward
        [5, 6, 9, 10, 1, 2, 4, 7, 8, 11, 13, 14, 0, 3, 12, 15],
        // 13: Corners first
        [0, 3, 12, 15, 1, 2, 4, 7, 8, 11, 13, 14, 5, 6, 9, 10],
        // 14: Random-ish pattern 1
        [0, 5, 10, 15, 3, 6, 9, 12, 1, 4, 11, 14, 2, 7, 8, 13],
        // 15: Random-ish pattern 2
        [0, 7, 8, 15, 1, 6, 9, 14, 2, 5, 10, 13, 3, 4, 11, 12],
        // 16: Checkerboard
        [0, 2, 5, 7, 8, 10, 13, 15, 1, 3, 4, 6, 9, 11, 12, 14]
    ];

    // State for each channel
    const channels = {
        x: {
            cv: Array(16).fill(0).map(() => Math.random() * 24 - 12), // -12 to +12 semitones
            access: Array(16).fill(true),
            gate: Array(16).fill(true),
            glide: Array(16).fill(false),
            snakePattern: 0,
            direction: 'fwd', // fwd, bwd, pend
            pendDir: 1,
            division: 1,
            position: 0, // Current snake position (0-15)
            quantNotes: [true, false, true, false, true, true, false, true, false, true, false, true], // C major
            octaveRange: 2,
            rootNote: 0
        },
        y: {
            cv: Array(16).fill(0).map(() => Math.random() * 24 - 12),
            access: Array(16).fill(true),
            gate: Array(16).fill(true),
            glide: Array(16).fill(false),
            snakePattern: 1,
            direction: 'fwd',
            pendDir: 1,
            division: 2,
            position: 0,
            quantNotes: [true, false, true, false, true, true, false, true, false, true, false, true],
            octaveRange: 2,
            rootNote: 0
        },
        c: {
            cv: Array(16).fill(0).map(() => Math.random() * 24 - 12),
            access: Array(16).fill(true),
            gate: Array(16).fill(true),
            glide: Array(16).fill(false),
            quantNotes: [true, false, true, false, true, true, false, true, false, true, false, true],
            octaveRange: 2,
            rootNote: 0
        }
    };

    // Global state
    const state = {
        currentChannel: 'x',
        currentPage: 'cv',
        tempo: 120,
        playing: false,
        stepCount: 0,
        // Cartesian positions derived from X and Y snake positions
        xCoord: 0,
        yCoord: 0
    };

    // Convert snake position to grid coordinates
    function snakePosToCoord(channel, position) {
        const pattern = SNAKE_PATTERNS[channels[channel].snakePattern];
        const gridPos = pattern[position % pattern.length];
        return {
            x: gridPos % GRID_SIZE,
            y: Math.floor(gridPos / GRID_SIZE)
        };
    }

    // Get grid index from x,y coordinates
    function coordToIndex(x, y) {
        return y * GRID_SIZE + x;
    }

    // Quantize CV value to scale
    function quantizeCV(channel, rawCV) {
        const ch = channels[channel];
        const activeNotes = ch.quantNotes.map((active, i) => active ? i : -1).filter(n => n >= 0);
        if (activeNotes.length === 0) return rawCV; // No quantization

        const octaveRange = ch.octaveRange;
        const rootNote = ch.rootNote;

        // Convert raw CV (-24 to +24 semitones) to MIDI note
        const baseMidi = 60 + rootNote; // Middle C + root
        const rawMidi = baseMidi + rawCV;

        // Find closest note in scale
        const noteInOctave = ((Math.round(rawMidi) % 12) + 12) % 12;
        let closestNote = activeNotes[0];
        let minDist = 12;
        for (const note of activeNotes) {
            const dist = Math.min(Math.abs(note - noteInOctave), 12 - Math.abs(note - noteInOctave));
            if (dist < minDist) {
                minDist = dist;
                closestNote = note;
            }
        }

        // Reconstruct MIDI note
        const octave = Math.floor(rawMidi / 12);
        let quantizedMidi = octave * 12 + closestNote;

        // Clamp to octave range
        const minMidi = baseMidi;
        const maxMidi = baseMidi + (octaveRange * 12) - 1;
        quantizedMidi = Math.max(minMidi, Math.min(maxMidi, quantizedMidi));

        return quantizedMidi - baseMidi;
    }

    // Get MIDI note from channel and grid position
    function getMidiNote(channel, gridIndex) {
        const ch = channels[channel];
        const rawCV = ch.cv[gridIndex];
        const quantizedCV = quantizeCV(channel, rawCV);
        return 60 + ch.rootNote + quantizedCV;
    }

    function midiToNoteName(midi) {
        const octave = Math.floor(midi / 12) - 1;
        const note = NOTE_NAMES[midi % 12];
        return note + octave;
    }

    // Advance snake position
    function advanceSnake(channel) {
        const ch = channels[channel];
        const patternLength = SNAKE_PATTERNS[ch.snakePattern].length;
        let newPos = ch.position;

        // Find next accessible position
        let attempts = 0;
        do {
            switch (ch.direction) {
                case 'fwd':
                    newPos = (newPos + 1) % patternLength;
                    break;
                case 'bwd':
                    newPos = (newPos - 1 + patternLength) % patternLength;
                    break;
                case 'pend':
                    newPos = newPos + ch.pendDir;
                    if (newPos >= patternLength - 1) {
                        newPos = patternLength - 1;
                        ch.pendDir = -1;
                    } else if (newPos <= 0) {
                        newPos = 0;
                        ch.pendDir = 1;
                    }
                    break;
            }
            attempts++;

            // Get grid index for this snake position
            const coord = snakePosToCoord(channel, newPos);
            const gridIndex = coordToIndex(coord.x, coord.y);

            // Check access (SEEK behavior - skip inaccessible)
            if (ch.access[gridIndex] || attempts >= patternLength) {
                break;
            }
        } while (attempts < patternLength);

        ch.position = newPos;
        return snakePosToCoord(channel, newPos);
    }

    // ============================================
    // WEB AUDIO ENGINE
    // ============================================

    let audioContext = null;
    let masterGain = null;
    let compressor = null;
    let analyser = null;
    let analyserData = null;

    async function initAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyserData = new Uint8Array(analyser.frequencyBinCount);

            compressor = audioContext.createDynamicsCompressor();
            compressor.threshold.value = -18;
            compressor.knee.value = 10;
            compressor.ratio.value = 4;

            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.5;

            compressor.connect(analyser);
            analyser.connect(masterGain);
            masterGain.connect(audioContext.destination);

            requestAnimationFrame(drawScope);
            return true;
        } catch (e) {
            console.error('Audio init failed:', e);
            return false;
        }
    }

    function playNote(midiNote, time, duration, channelType) {
        if (!audioContext || audioContext.state !== 'running') return;

        const freq = 440 * Math.pow(2, (midiNote - 69) / 12);

        // Different timbres for different channels
        const osc1 = audioContext.createOscillator();
        const osc2 = audioContext.createOscillator();

        if (channelType === 'x') {
            osc1.type = 'sawtooth';
            osc2.type = 'sawtooth';
        } else if (channelType === 'y') {
            osc1.type = 'square';
            osc2.type = 'triangle';
        } else {
            osc1.type = 'sawtooth';
            osc2.type = 'square';
        }

        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 1.003;

        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = freq * 4;
        filter.Q.value = 2;

        const envelope = audioContext.createGain();
        envelope.gain.value = 0;

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(envelope);
        envelope.connect(compressor);

        const attack = 0.008;
        const decay = 0.1;
        const sustain = 0.3;
        const release = 0.15;

        envelope.gain.setValueAtTime(0, time);
        envelope.gain.linearRampToValueAtTime(0.25, time + attack);
        envelope.gain.linearRampToValueAtTime(sustain * 0.25, time + attack + decay);
        envelope.gain.setValueAtTime(sustain * 0.25, time + duration - release);
        envelope.gain.linearRampToValueAtTime(0, time + duration);

        filter.frequency.setValueAtTime(freq * 2, time);
        filter.frequency.linearRampToValueAtTime(freq * 6, time + attack);
        filter.frequency.exponentialRampToValueAtTime(freq * 1.5, time + attack + decay + 0.05);

        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + duration + 0.1);
        osc2.stop(time + duration + 0.1);
    }

    function drawScope() {
        if (!analyser) {
            requestAnimationFrame(drawScope);
            return;
        }

        const canvas = document.getElementById('scopeCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = canvas.offsetWidth * 2;
        const height = canvas.height = canvas.offsetHeight * 2;

        analyser.getByteTimeDomainData(analyserData);

        ctx.fillStyle = 'rgba(13, 13, 13, 0.3)';
        ctx.fillRect(0, 0, width, height);

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ff8844';
        ctx.beginPath();

        const sliceWidth = width / analyserData.length;
        let x = 0;

        for (let i = 0; i < analyserData.length; i++) {
            const v = analyserData[i] / 128.0;
            const y = v * height / 2;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            x += sliceWidth;
        }

        ctx.stroke();
        requestAnimationFrame(drawScope);
    }

    // ============================================
    // SCHEDULER
    // ============================================

    const scheduler = {
        nextXTickTime: 0,
        nextYTickTime: 0,
        lookahead: 0.1,
        scheduleInterval: 25,
        timerId: null
    };

    function getSecondsPerBeat() {
        return 60.0 / state.tempo;
    }

    function scheduleXTick(time) {
        const coord = advanceSnake('x');
        state.xCoord = coord.x;

        const gridIndex = coordToIndex(coord.x, coord.y);
        const ch = channels.x;

        // Flash gate LED
        if (ch.gate[gridIndex] && ch.access[gridIndex]) {
            const midiNote = getMidiNote('x', gridIndex);
            const duration = getSecondsPerBeat() * ch.division * 0.8;
            playNote(midiNote, time, Math.min(duration, 0.5), 'x');

            requestAnimationFrame(() => {
                document.getElementById('xGateLed').classList.add('on');
                setTimeout(() => document.getElementById('xGateLed').classList.remove('on'), 100);
            });
        }

        // Also trigger Cartesian channel
        triggerCartesian(time);
        requestAnimationFrame(updateUI);
    }

    function scheduleYTick(time) {
        const coord = advanceSnake('y');
        state.yCoord = coord.y;

        const gridIndex = coordToIndex(coord.x, coord.y);
        const ch = channels.y;

        if (ch.gate[gridIndex] && ch.access[gridIndex]) {
            const midiNote = getMidiNote('y', gridIndex);
            const duration = getSecondsPerBeat() * ch.division * 0.8;
            playNote(midiNote, time, Math.min(duration, 0.5), 'y');

            requestAnimationFrame(() => {
                document.getElementById('yGateLed').classList.add('on');
                setTimeout(() => document.getElementById('yGateLed').classList.remove('on'), 100);
            });
        }

        // Also trigger Cartesian channel
        triggerCartesian(time);
        requestAnimationFrame(updateUI);
    }

    let lastCartesianPos = -1;

    function triggerCartesian(time) {
        // Cartesian channel uses X coord from X channel, Y coord from Y channel
        const gridIndex = coordToIndex(state.xCoord, state.yCoord);

        if (gridIndex === lastCartesianPos) return;
        lastCartesianPos = gridIndex;

        state.stepCount++;
        const ch = channels.c;

        if (ch.gate[gridIndex] && ch.access[gridIndex]) {
            const midiNote = getMidiNote('c', gridIndex);
            const duration = getSecondsPerBeat() * 0.8;
            playNote(midiNote, time, Math.min(duration, 0.5), 'c');

            requestAnimationFrame(() => {
                document.getElementById('cGateLed').classList.add('on');
                setTimeout(() => document.getElementById('cGateLed').classList.remove('on'), 100);
            });
        }
    }

    function runScheduler() {
        if (!state.playing || !audioContext) return;

        const currentTime = audioContext.currentTime;
        const secondsPerBeat = getSecondsPerBeat();

        while (scheduler.nextXTickTime < currentTime + scheduler.lookahead) {
            scheduleXTick(scheduler.nextXTickTime);
            scheduler.nextXTickTime += secondsPerBeat * channels.x.division;
        }

        while (scheduler.nextYTickTime < currentTime + scheduler.lookahead) {
            scheduleYTick(scheduler.nextYTickTime);
            scheduler.nextYTickTime += secondsPerBeat * channels.y.division;
        }
    }

    function startSequencer() {
        if (!audioContext) return;
        if (audioContext.state === 'suspended') audioContext.resume();

        state.playing = true;
        lastCartesianPos = -1;

        const now = audioContext.currentTime;
        scheduler.nextXTickTime = now;
        scheduler.nextYTickTime = now;

        scheduler.timerId = setInterval(runScheduler, scheduler.scheduleInterval);
        updatePlayButton();
    }

    function stopSequencer() {
        state.playing = false;
        if (scheduler.timerId) {
            clearInterval(scheduler.timerId);
            scheduler.timerId = null;
        }
        updatePlayButton();
    }

    function resetSequencer() {
        channels.x.position = 0;
        channels.y.position = 0;
        channels.x.pendDir = 1;
        channels.y.pendDir = 1;
        state.xCoord = 0;
        state.yCoord = 0;
        lastCartesianPos = -1;
        state.stepCount = 0;
        updateUI();
    }

    // ============================================
    // UI
    // ============================================

    function createKnobGrid() {
        const grid = document.getElementById('knobGrid');
        grid.innerHTML = '';

        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.className = 'knob-cell';

            const knob = document.createElement('div');
            knob.className = 'cv-knob';
            knob.dataset.index = i;

            const ledRing = document.createElement('div');
            ledRing.className = 'led-ring';

            const indicator = document.createElement('div');
            indicator.className = 'indicator';

            const value = document.createElement('div');
            value.className = 'knob-value';

            knob.appendChild(ledRing);
            knob.appendChild(indicator);
            cell.appendChild(knob);
            cell.appendChild(value);
            grid.appendChild(cell);

            // Click to edit
            knob.addEventListener('click', () => editKnob(i));
        }

        updateKnobGrid();
    }

    function updateKnobGrid() {
        const ch = channels[state.currentChannel];
        const knobs = document.querySelectorAll('.cv-knob');
        const values = document.querySelectorAll('.knob-value');

        // Get current positions
        const xCoord = snakePosToCoord('x', channels.x.position);
        const yCoord = snakePosToCoord('y', channels.y.position);
        const xGridIndex = coordToIndex(xCoord.x, xCoord.y);
        const yGridIndex = coordToIndex(yCoord.x, yCoord.y);
        const cGridIndex = coordToIndex(state.xCoord, state.yCoord);

        knobs.forEach((knob, i) => {
            const cv = ch.cv[i];
            const rotation = (cv + 24) / 48 * 270 - 135; // Map to -135 to +135 degrees
            knob.querySelector('.indicator').style.transform = `translateX(-50%) rotate(${rotation}deg)`;

            const midiNote = getMidiNote(state.currentChannel, i);
            values[i].textContent = midiToNoteName(midiNote);

            // LED ring based on position
            knob.classList.remove('lit', 'x-lit', 'y-lit');
            if (state.currentChannel === 'c' && i === cGridIndex) {
                knob.classList.add('lit');
            } else if (state.currentChannel === 'x' && i === xGridIndex) {
                knob.classList.add('x-lit');
            } else if (state.currentChannel === 'y' && i === yGridIndex) {
                knob.classList.add('y-lit');
            }
        });
    }

    function createButtonGrid() {
        const grid = document.getElementById('buttonGrid');
        grid.innerHTML = '';

        for (let i = 0; i < 16; i++) {
            const btn = document.createElement('button');
            btn.className = 'grid-button';
            btn.dataset.index = i;

            const led = document.createElement('div');
            led.className = 'led';
            btn.appendChild(led);

            btn.addEventListener('click', () => toggleGridButton(i));
            grid.appendChild(btn);
        }

        updateButtonGrid();
    }

    function updateButtonGrid() {
        const ch = channels[state.currentChannel];
        const buttons = document.querySelectorAll('.grid-button');

        let dataArray;
        switch (state.currentPage) {
            case 'access': dataArray = ch.access; break;
            case 'gate': dataArray = ch.gate; break;
            case 'glide': dataArray = ch.glide; break;
            default: return;
        }

        const xCoord = snakePosToCoord('x', channels.x.position);
        const yCoord = snakePosToCoord('y', channels.y.position);
        const cGridIndex = coordToIndex(state.xCoord, state.yCoord);

        buttons.forEach((btn, i) => {
            btn.classList.remove('on', 'x-on', 'y-on', 'current');

            if (dataArray[i]) {
                if (state.currentChannel === 'x') btn.classList.add('x-on');
                else if (state.currentChannel === 'y') btn.classList.add('y-on');
                else btn.classList.add('on');
            }

            // Mark current position
            if (state.currentChannel === 'c' && i === cGridIndex) {
                btn.classList.add('current');
            }
        });
    }

    function createSnakeGrid() {
        const grid = document.getElementById('snakeGrid');
        grid.innerHTML = '';

        for (let i = 0; i < 16; i++) {
            const btn = document.createElement('button');
            btn.className = 'snake-button';
            btn.dataset.pattern = i;

            // Draw mini preview of pattern
            const preview = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            preview.setAttribute('class', 'snake-preview');
            preview.setAttribute('viewBox', '0 0 40 40');

            const pattern = SNAKE_PATTERNS[i];
            let pathD = '';
            pattern.forEach((pos, idx) => {
                const x = (pos % 4) * 10 + 5;
                const y = Math.floor(pos / 4) * 10 + 5;
                pathD += (idx === 0 ? 'M' : 'L') + x + ',' + y + ' ';
            });

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathD);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', state.currentChannel === 'x' ? '#ff4444' : '#44ff44');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');

            preview.appendChild(path);
            btn.appendChild(preview);

            btn.addEventListener('click', () => selectSnakePattern(i));
            grid.appendChild(btn);
        }

        updateSnakeGrid();
    }

    function updateSnakeGrid() {
        if (state.currentChannel === 'c') return; // C channel has no snake

        const ch = channels[state.currentChannel];
        const buttons = document.querySelectorAll('.snake-button');

        buttons.forEach((btn, i) => {
            btn.classList.toggle('selected', i === ch.snakePattern);

            // Update path color
            const path = btn.querySelector('path');
            if (path) {
                path.setAttribute('stroke', state.currentChannel === 'x' ? '#ff4444' : '#44ff44');
            }
        });
    }

    function createQuantNotes() {
        const container = document.getElementById('quantNotes');
        container.innerHTML = '';

        const noteLabels = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const blackNotes = [1, 3, 6, 8, 10];

        noteLabels.forEach((label, i) => {
            const btn = document.createElement('button');
            btn.className = 'note-btn' + (blackNotes.includes(i) ? ' black' : '');
            btn.textContent = label;
            btn.dataset.note = i;
            btn.addEventListener('click', () => toggleQuantNote(i));
            container.appendChild(btn);
        });

        updateQuantNotes();
    }

    function updateQuantNotes() {
        const ch = channels[state.currentChannel];
        const buttons = document.querySelectorAll('.note-btn');

        buttons.forEach((btn, i) => {
            btn.classList.toggle('active', ch.quantNotes[i]);
        });
    }

    function editKnob(index) {
        const ch = channels[state.currentChannel];
        const newVal = prompt(`CV for step ${index + 1} (current: ${ch.cv[index].toFixed(1)}):`, ch.cv[index].toFixed(1));
        if (newVal !== null) {
            ch.cv[index] = Math.max(-24, Math.min(24, parseFloat(newVal) || 0));
            updateKnobGrid();
            saveState();
        }
    }

    function toggleGridButton(index) {
        const ch = channels[state.currentChannel];
        switch (state.currentPage) {
            case 'access': ch.access[index] = !ch.access[index]; break;
            case 'gate': ch.gate[index] = !ch.gate[index]; break;
            case 'glide': ch.glide[index] = !ch.glide[index]; break;
        }
        updateButtonGrid();
        saveState();
    }

    function selectSnakePattern(index) {
        if (state.currentChannel === 'c') return;
        channels[state.currentChannel].snakePattern = index;
        updateSnakeGrid();
        saveState();
    }

    function toggleQuantNote(index) {
        const ch = channels[state.currentChannel];
        ch.quantNotes[index] = !ch.quantNotes[index];
        updateQuantNotes();
        updateKnobGrid();
        saveState();
    }

    function updateUI() {
        // Update output displays
        const xCoord = snakePosToCoord('x', channels.x.position);
        const yCoord = snakePosToCoord('y', channels.y.position);
        const xGridIndex = coordToIndex(xCoord.x, xCoord.y);
        const yGridIndex = coordToIndex(yCoord.x, yCoord.y);
        const cGridIndex = coordToIndex(state.xCoord, state.yCoord);

        document.getElementById('xCvOut').textContent = midiToNoteName(getMidiNote('x', xGridIndex));
        document.getElementById('yCvOut').textContent = midiToNoteName(getMidiNote('y', yGridIndex));
        document.getElementById('cCvOut').textContent = midiToNoteName(getMidiNote('c', cGridIndex));

        // Update info bar
        document.getElementById('xPosDisplay').textContent = state.xCoord;
        document.getElementById('yPosDisplay').textContent = state.yCoord;
        document.getElementById('snakeDisplay').textContent =
            state.currentChannel === 'c' ? '-' : (channels[state.currentChannel].snakePattern + 1);
        document.getElementById('stepDisplay').textContent = state.stepCount;

        // Update current page display
        if (state.currentPage === 'cv') {
            updateKnobGrid();
        } else if (['access', 'gate', 'glide'].includes(state.currentPage)) {
            updateButtonGrid();
        } else if (state.currentPage === 'snake') {
            updateSnakeGrid();
        } else if (state.currentPage === 'quant') {
            updateQuantNotes();
        }
    }

    function updatePlayButton() {
        const btn = document.getElementById('playBtn');
        btn.classList.toggle('playing', state.playing);
        btn.textContent = state.playing ? '■' : '▶';
    }

    function switchPage(page) {
        state.currentPage = page;

        // Update tab highlighting
        document.querySelectorAll('.page-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.page === page);
        });

        // Show appropriate grid
        document.getElementById('knobGrid').style.display = page === 'cv' ? 'grid' : 'none';
        document.getElementById('buttonGrid').style.display = ['access', 'gate', 'glide'].includes(page) ? 'grid' : 'none';
        document.getElementById('snakeGrid').style.display = page === 'snake' ? 'grid' : 'none';

        // Show quant section
        document.getElementById('quantSection').style.display = page === 'quant' ? 'block' : 'none';
        document.getElementById('xClockSection').style.display = page === 'quant' ? 'none' : 'block';
        document.getElementById('yClockSection').style.display = page === 'quant' ? 'none' : 'block';

        // Disable snake for C channel
        if (page === 'snake' && state.currentChannel === 'c') {
            switchPage('cv');
            return;
        }

        updateUI();
    }

    function switchChannel(channel) {
        state.currentChannel = channel;

        document.querySelectorAll('.channel-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.channel === channel);
        });

        // C channel has no snake page
        const snakeTab = document.querySelector('[data-page="snake"]');
        snakeTab.style.opacity = channel === 'c' ? '0.3' : '1';
        snakeTab.style.pointerEvents = channel === 'c' ? 'none' : 'auto';

        if (state.currentPage === 'snake' && channel === 'c') {
            switchPage('cv');
        }

        // Update quant controls
        const ch = channels[channel];
        document.getElementById('octaveRange').value = ch.octaveRange;
        document.getElementById('rootNote').value = ch.rootNote;

        updateUI();
    }

    // ============================================
    // PERSISTENCE
    // ============================================

    function saveState() {
        localStorage.setItem('reneSequencer', JSON.stringify({ channels, tempo: state.tempo }));
    }

    function loadState() {
        try {
            const saved = localStorage.getItem('reneSequencer');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.channels) {
                    Object.assign(channels.x, data.channels.x);
                    Object.assign(channels.y, data.channels.y);
                    Object.assign(channels.c, data.channels.c);
                }
                if (data.tempo) state.tempo = data.tempo;
                return true;
            }
        } catch (e) {
            console.warn('Load state failed:', e);
        }
        return false;
    }

    // ============================================
    // EVENT LISTENERS
    // ============================================

    function setupEventListeners() {
        // Channel tabs
        document.querySelectorAll('.channel-tab').forEach(tab => {
            tab.addEventListener('click', () => switchChannel(tab.dataset.channel));
        });

        // Page tabs
        document.querySelectorAll('.page-tab').forEach(tab => {
            tab.addEventListener('click', () => switchPage(tab.dataset.page));
        });

        // Transport
        document.getElementById('playBtn').addEventListener('click', () => {
            state.playing ? stopSequencer() : startSequencer();
        });

        document.getElementById('resetBtn').addEventListener('click', resetSequencer);

        // Tempo
        document.getElementById('tempoSlider').addEventListener('input', (e) => {
            state.tempo = parseInt(e.target.value);
            document.getElementById('tempoDisplay').textContent = state.tempo;
            saveState();
        });

        // Clock divisions
        document.getElementById('xDivision').addEventListener('change', (e) => {
            channels.x.division = parseFloat(e.target.value);
            saveState();
        });

        document.getElementById('yDivision').addEventListener('change', (e) => {
            channels.y.division = parseFloat(e.target.value);
            saveState();
        });

        // Direction buttons
        document.querySelectorAll('.dir-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const axis = btn.dataset.axis;
                const dir = btn.dataset.dir;
                channels[axis].direction = dir;
                channels[axis].pendDir = 1;

                // Update button states
                document.querySelectorAll(`.dir-btn[data-axis="${axis}"]`).forEach(b => {
                    b.classList.toggle('active', b.dataset.dir === dir);
                });
                saveState();
            });
        });

        // Quant controls
        document.getElementById('octaveRange').addEventListener('change', (e) => {
            channels[state.currentChannel].octaveRange = parseInt(e.target.value);
            updateKnobGrid();
            saveState();
        });

        document.getElementById('rootNote').addEventListener('change', (e) => {
            channels[state.currentChannel].rootNote = parseInt(e.target.value);
            updateKnobGrid();
            saveState();
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.target.matches('input, select')) return;
            if (e.code === 'Space') {
                e.preventDefault();
                state.playing ? stopSequencer() : startSequencer();
            } else if (e.code === 'KeyR') {
                resetSequencer();
            }
        });
    }

    // ============================================
    // INIT
    // ============================================

    async function init() {
        loadState();

        createKnobGrid();
        createButtonGrid();
        createSnakeGrid();
        createQuantNotes();
        setupEventListeners();

        document.getElementById('tempoSlider').value = state.tempo;
        document.getElementById('tempoDisplay').textContent = state.tempo;

        updateUI();

        await initAudio();

        setTimeout(() => {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }, 300);

        console.log('René Sequencer initialized');
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
