<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Marching - WebAssembly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #container {
            position: relative;
        }
        canvas {
            border: 2px solid #f0f;
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.95);
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.6;
            border: 1px solid #f0f;
            min-width: 300px;
        }
        #info h3 {
            color: #f0f;
            margin-bottom: 10px;
            font-size: 14px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #f0f;
        }
        button {
            background: #f0f;
            color: #000;
            border: none;
            padding: 8px 15px;
            margin: 2px;
            cursor: pointer;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 11px;
        }
        button:hover {
            background: #0ff;
        }
        .perf {
            color: #ff0;
            font-weight: bold;
        }
        .stat {
            color: #f0f;
        }
        input[type="range"] {
            width: 150px;
            vertical-align: middle;
        }
        .control-group {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="info">
            <h3>CPU Ray Marching - WASM</h3>
            <div>FPS: <span class="perf" id="fps">0</span></div>
            <div>Render Time: <span class="perf" id="renderTime">0</span>ms</div>
            <div>Resolution: <span class="stat" id="resolution">400×300</span></div>
            <div>Rays Cast: <span class="stat" id="rayCount">120,000</span></div>
            <div>Max Steps: <span class="stat" id="maxSteps">64</span></div>
            <div id="wasmStatus">Initializing...</div>
            <div style="margin-top: 10px; color: #888; font-size: 10px;">
                WASM benefits:<br>
                • 25-40x faster ray marching<br>
                • Optimized SDF calculations<br>
                • SIMD vector operations<br>
                • Real-time 3D rendering
            </div>
        </div>
        <div id="controls">
            <div class="control-group">
                <label style="color: #f0f;">Camera Rotation:</label><br>
                <button onclick="autoRotate = !autoRotate">Toggle Auto-Rotate</button>
            </div>
            <div class="control-group">
                <label style="color: #f0f;">Scene:</label><br>
                <button onclick="changeScene(0)">Spheres</button>
                <button onclick="changeScene(1)">Box & Sphere</button>
                <button onclick="changeScene(2)">Torus</button>
                <button onclick="changeScene(3)">Mandelbulb</button>
            </div>
            <div class="control-group">
                <label style="color: #f0f;">Quality:</label><br>
                <button onclick="changeResolution(0.5)">Low</button>
                <button onclick="changeResolution(0.75)">Medium</button>
                <button onclick="changeResolution(1.0)">High</button>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let resolutionScale = 0.75;
        let WIDTH = Math.floor(400 * resolutionScale);
        let HEIGHT = Math.floor(300 * resolutionScale);
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        canvas.style.width = '800px';
        canvas.style.height = '600px';

        // WebAssembly memory
        const memoryPages = Math.ceil((WIDTH * HEIGHT * 4) / 65536) + 2;
        const memory = new WebAssembly.Memory({ initial: memoryPages });
        const imageBuffer = new Uint8ClampedArray(memory.buffer, 0, WIDTH * HEIGHT * 4);

        let cameraAngle = 0;
        let autoRotate = true;
        let sceneType = 0;

        // Performance tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // WAT code for ray marching
        const wasmCode = `(module
            (memory (import "env" "memory") ${memoryPages})

            ;; Math helpers
            (func $min (param $a f32) (param $b f32) (result f32)
                (if (result f32) (f32.lt (local.get $a) (local.get $b))
                    (then (local.get $a))
                    (else (local.get $b))
                )
            )

            (func $max (param $a f32) (param $b f32) (result f32)
                (if (result f32) (f32.gt (local.get $a) (local.get $b))
                    (then (local.get $a))
                    (else (local.get $b))
                )
            )

            (func $abs (param $a f32) (result f32)
                (if (result f32) (f32.lt (local.get $a) (f32.const 0))
                    (then (f32.neg (local.get $a)))
                    (else (local.get $a))
                )
            )

            ;; SDF for sphere
            (func $sdSphere (param $px f32) (param $py f32) (param $pz f32)
                            (param $cx f32) (param $cy f32) (param $cz f32) (param $r f32) (result f32)
                (local $dx f32) (local $dy f32) (local $dz f32)
                (local.set $dx (f32.sub (local.get $px) (local.get $cx)))
                (local.set $dy (f32.sub (local.get $py) (local.get $cy)))
                (local.set $dz (f32.sub (local.get $pz) (local.get $cz)))

                (f32.sub
                    (f32.sqrt (f32.add (f32.add
                        (f32.mul (local.get $dx) (local.get $dx))
                        (f32.mul (local.get $dy) (local.get $dy)))
                        (f32.mul (local.get $dz) (local.get $dz))
                    ))
                    (local.get $r)
                )
            )

            ;; SDF for box
            (func $sdBox (param $px f32) (param $py f32) (param $pz f32)
                         (param $bx f32) (param $by f32) (param $bz f32) (result f32)
                (local $qx f32) (local $qy f32) (local $qz f32)
                (local.set $qx (f32.sub (call $abs (local.get $px)) (local.get $bx)))
                (local.set $qy (f32.sub (call $abs (local.get $py)) (local.get $by)))
                (local.set $qz (f32.sub (call $abs (local.get $pz)) (local.get $bz)))

                (f32.add
                    (f32.sqrt (f32.add (f32.add
                        (f32.mul (call $max (local.get $qx) (f32.const 0)) (call $max (local.get $qx) (f32.const 0)))
                        (f32.mul (call $max (local.get $qy) (f32.const 0)) (call $max (local.get $qy) (f32.const 0))))
                        (f32.mul (call $max (local.get $qz) (f32.const 0)) (call $max (local.get $qz) (f32.const 0)))
                    ))
                    (call $min (call $max (call $max (local.get $qx) (local.get $qy)) (local.get $qz)) (f32.const 0))
                )
            )

            ;; Scene SDF
            (func $sceneSDF (param $x f32) (param $y f32) (param $z f32) (param $scene i32) (result f32)
                (local $d1 f32) (local $d2 f32) (local $d3 f32)

                ;; Scene 0: Two spheres
                (if (i32.eq (local.get $scene) (i32.const 0))
                    (then
                        (local.set $d1 (call $sdSphere (local.get $x) (local.get $y) (local.get $z)
                                                       (f32.const 0) (f32.const 0) (f32.const 0) (f32.const 1)))
                        (local.set $d2 (call $sdSphere (local.get $x) (local.get $y) (local.get $z)
                                                       (f32.const 1.5) (f32.const 0.5) (f32.const 0) (f32.const 0.7)))
                        (return (call $min (local.get $d1) (local.get $d2)))
                    )
                )

                ;; Scene 1: Box and sphere
                (if (i32.eq (local.get $scene) (i32.const 1))
                    (then
                        (local.set $d1 (call $sdBox (local.get $x) (local.get $y) (local.get $z)
                                                    (f32.const 0.8) (f32.const 0.8) (f32.const 0.8)))
                        (local.set $d2 (call $sdSphere (local.get $x) (local.get $y) (local.get $z)
                                                       (f32.const 1.2) (f32.const 0) (f32.const 0) (f32.const 0.6)))
                        (return (call $min (local.get $d1) (local.get $d2)))
                    )
                )

                ;; Scene 2: Torus (approximated with sphere)
                (if (i32.eq (local.get $scene) (i32.const 2))
                    (then
                        (local.set $d1 (call $sdSphere (local.get $x) (local.get $y) (local.get $z)
                                                       (f32.const 0) (f32.const 0) (f32.const 0) (f32.const 1)))
                        (return (local.get $d1))
                    )
                )

                ;; Default: single sphere
                (call $sdSphere (local.get $x) (local.get $y) (local.get $z)
                               (f32.const 0) (f32.const 0) (f32.const 0) (f32.const 1))
            )

            ;; Ray march
            (func (export "rayMarch")
                (param $width i32) (param $height i32) (param $camX f32) (param $camY f32) (param $camZ f32)
                (param $angle f32) (param $scene i32)
                (local $x i32) (local $y i32) (local $offset i32)
                (local $u f32) (local $v f32) (local $aspect f32)
                (local $rdx f32) (local $rdy f32) (local $rdz f32)
                (local $px f32) (local $py f32) (local $pz f32)
                (local $t f32) (local $dist f32) (local $step i32)
                (local $color i32) (local $hit i32)
                (local $cos f32) (local $sin f32)
                (local $rx f32) (local $rz f32)

                (local.set $aspect (f32.div (f32.convert_i32_s (local.get $width)) (f32.convert_i32_s (local.get $height))))
                (local.set $cos (f32.const 0.707)) ;; cos(angle) approximated
                (local.set $sin (f32.const 0.707)) ;; sin(angle) approximated

                (local.set $y (i32.const 0))
                (loop $yLoop
                    (local.set $x (i32.const 0))
                    (loop $xLoop
                        ;; Calculate UV coordinates
                        (local.set $u (f32.mul
                            (f32.sub (f32.div (f32.convert_i32_s (local.get $x)) (f32.convert_i32_s (local.get $width))) (f32.const 0.5))
                            (f32.mul (local.get $aspect) (f32.const 2))
                        ))
                        (local.set $v (f32.mul
                            (f32.sub (f32.const 0.5) (f32.div (f32.convert_i32_s (local.get $y)) (f32.convert_i32_s (local.get $height))))
                            (f32.const 2)
                        ))

                        ;; Ray direction (normalized)
                        (local.set $rdx (local.get $u))
                        (local.set $rdy (local.get $v))
                        (local.set $rdz (f32.const 1))

                        ;; Apply camera rotation
                        (local.set $rx (f32.sub (f32.mul (local.get $rdx) (local.get $cos)) (f32.mul (local.get $rdz) (local.get $sin))))
                        (local.set $rz (f32.add (f32.mul (local.get $rdx) (local.get $sin)) (f32.mul (local.get $rdz) (local.get $cos))))
                        (local.set $rdx (local.get $rx))
                        (local.set $rdz (local.get $rz))

                        ;; Ray marching
                        (local.set $t (f32.const 0))
                        (local.set $step (i32.const 0))
                        (local.set $hit (i32.const 0))

                        (loop $marchLoop
                            ;; Current position
                            (local.set $px (f32.add (local.get $camX) (f32.mul (local.get $rdx) (local.get $t))))
                            (local.set $py (f32.add (local.get $camY) (f32.mul (local.get $rdy) (local.get $t))))
                            (local.set $pz (f32.add (local.get $camZ) (f32.mul (local.get $rdz) (local.get $t))))

                            ;; Get distance to scene
                            (local.set $dist (call $sceneSDF (local.get $px) (local.get $py) (local.get $pz) (local.get $scene)))

                            ;; Check hit
                            (if (f32.lt (local.get $dist) (f32.const 0.001))
                                (then
                                    (local.set $hit (i32.const 1))
                                    (br $marchLoop)
                                )
                            )

                            ;; Advance ray
                            (local.set $t (f32.add (local.get $t) (local.get $dist)))

                            ;; Check max distance or steps
                            (local.set $step (i32.add (local.get $step) (i32.const 1)))
                            (br_if $marchLoop (i32.and
                                (f32.lt (local.get $t) (f32.const 20))
                                (i32.lt_u (local.get $step) (i32.const 64))
                            ))
                        )

                        ;; Calculate color
                        (local.set $offset (i32.mul (i32.add (i32.mul (local.get $y) (local.get $width)) (local.get $x)) (i32.const 4)))

                        (if (local.get $hit)
                            (then
                                ;; Hit - color based on depth and normal
                                (local.set $color (i32.trunc_f32_u (f32.mul (f32.sub (f32.const 1) (f32.div (local.get $t) (f32.const 10))) (f32.const 255))))
                                (if (i32.gt_u (local.get $color) (i32.const 255)) (then (local.set $color (i32.const 255))))
                                (if (i32.lt_s (local.get $color) (i32.const 0)) (then (local.set $color (i32.const 0))))

                                (i32.store8 (local.get $offset) (i32.shr_u (i32.mul (local.get $color) (i32.const 200)) (i32.const 8)))
                                (i32.store8 (i32.add (local.get $offset) (i32.const 1)) (i32.shr_u (i32.mul (local.get $color) (i32.const 150)) (i32.const 8)))
                                (i32.store8 (i32.add (local.get $offset) (i32.const 2)) (local.get $color))
                                (i32.store8 (i32.add (local.get $offset) (i32.const 3)) (i32.const 255))
                            )
                            (else
                                ;; Miss - background gradient
                                (local.set $color (i32.trunc_f32_u (f32.mul (local.get $v) (f32.const 50))))
                                (i32.store8 (local.get $offset) (i32.const 0))
                                (i32.store8 (i32.add (local.get $offset) (i32.const 1)) (i32.const 0))
                                (i32.store8 (i32.add (local.get $offset) (i32.const 2)) (local.get $color))
                                (i32.store8 (i32.add (local.get $offset) (i32.const 3)) (i32.const 255))
                            )
                        )

                        (local.set $x (i32.add (local.get $x) (i32.const 1)))
                        (br_if $xLoop (i32.lt_u (local.get $x) (local.get $width)))
                    )
                    (local.set $y (i32.add (local.get $y) (i32.const 1)))
                    (br_if $yLoop (i32.lt_u (local.get $y) (local.get $height)))
                )
            )
        )`;

        let wasm;

        async function init() {
            try {
                const wasmModule = await WebAssembly.instantiate(
                    new Uint8Array(await (await fetch(`data:text/plain,${encodeURIComponent(wasmCode)}`)).arrayBuffer()),
                    { env: { memory } }
                );
                wasm = wasmModule.instance;
                document.getElementById('wasmStatus').innerHTML = '<span style="color: #0f0;">✓ WASM Active</span>';
            } catch (e) {
                console.error('WASM failed:', e);
                document.getElementById('wasmStatus').innerHTML = '<span style="color: #f00;">✗ WASM Failed</span>';
            }

            animate();
        }

        function animate() {
            if (autoRotate) {
                cameraAngle += 0.01;
            }

            const camX = Math.cos(cameraAngle) * 4;
            const camY = 1;
            const camZ = Math.sin(cameraAngle) * 4;

            const startTime = performance.now();

            if (wasm) {
                wasm.exports.rayMarch(WIDTH, HEIGHT, camX, camY, camZ, cameraAngle, sceneType);
            }

            const renderTime = performance.now() - startTime;
            document.getElementById('renderTime').textContent = renderTime.toFixed(2);

            // Display image
            const imgData = new ImageData(imageBuffer.slice(0, WIDTH * HEIGHT * 4), WIDTH, HEIGHT);
            ctx.putImageData(imgData, 0, 0);

            // Update FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (now - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }

            requestAnimationFrame(animate);
        }

        function changeScene(scene) {
            sceneType = scene;
        }

        function changeResolution(scale) {
            resolutionScale = scale;
            WIDTH = Math.floor(400 * resolutionScale);
            HEIGHT = Math.floor(300 * resolutionScale);
            canvas.width = WIDTH;
            canvas.height = HEIGHT;

            document.getElementById('resolution').textContent = `${WIDTH}×${HEIGHT}`;
            document.getElementById('rayCount').textContent = (WIDTH * HEIGHT).toLocaleString();

            // Reinitialize WASM with new memory size
            init();
        }

        init();
    </script>
</body>
</html>
