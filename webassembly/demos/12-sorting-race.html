<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Race - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1400;
        const height = canvas.height = 800;

        const ARRAY_SIZE = 100;
        const ALGORITHMS = 6;

        class SortVisualizer {
            constructor(name, sortFn, y) {
                this.name = name;
                this.sortFn = sortFn;
                this.y = y;
                this.reset();
            }

            reset() {
                this.array = Array.from({ length: ARRAY_SIZE }, () => Math.random());
                this.comparisons = 0;
                this.swaps = 0;
                this.done = false;
                this.generator = this.sortFn(this.array, this);
            }

            step() {
                if (!this.done) {
                    const result = this.generator.next();
                    if (result.done) {
                        this.done = true;
                    }
                }
            }

            draw(x, w, h) {
                const barWidth = w / ARRAY_SIZE;

                // Draw bars
                for (let i = 0; i < ARRAY_SIZE; i++) {
                    const barHeight = this.array[i] * h;
                    const hue = this.array[i] * 360;

                    ctx.fillStyle = this.done ? '#0f0' : `hsl(${hue}, 70%, 50%)`;
                    ctx.fillRect(
                        x + i * barWidth,
                        this.y + h - barHeight,
                        Math.ceil(barWidth) - 1,
                        barHeight
                    );
                }

                // Draw label
                ctx.fillStyle = this.done ? '#0f0' : '#fff';
                ctx.font = '14px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(
                    `${this.name} | Cmp: ${this.comparisons} | Swaps: ${this.swaps}`,
                    x,
                    this.y - 5
                );
            }
        }

        // Bubble Sort
        function* bubbleSort(arr, viz) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    viz.comparisons++;
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        viz.swaps++;
                        yield;
                    }
                }
            }
        }

        // Selection Sort
        function* selectionSort(arr, viz) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                for (let j = i + 1; j < n; j++) {
                    viz.comparisons++;
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    viz.swaps++;
                    yield;
                }
            }
        }

        // Insertion Sort
        function* insertionSort(arr, viz) {
            const n = arr.length;
            for (let i = 1; i < n; i++) {
                let key = arr[i];
                let j = i - 1;
                while (j >= 0 && arr[j] > key) {
                    viz.comparisons++;
                    arr[j + 1] = arr[j];
                    j--;
                    viz.swaps++;
                    yield;
                }
                arr[j + 1] = key;
            }
        }

        // Quick Sort
        function* quickSort(arr, viz, low = 0, high = arr.length - 1) {
            if (low < high) {
                let pi = low;
                const pivot = arr[high];

                for (let i = low; i < high; i++) {
                    viz.comparisons++;
                    if (arr[i] < pivot) {
                        [arr[i], arr[pi]] = [arr[pi], arr[i]];
                        pi++;
                        viz.swaps++;
                        yield;
                    }
                }
                [arr[pi], arr[high]] = [arr[high], arr[pi]];
                viz.swaps++;
                yield;

                yield* quickSort(arr, viz, low, pi - 1);
                yield* quickSort(arr, viz, pi + 1, high);
            }
        }

        // Merge Sort
        function* mergeSort(arr, viz, left = 0, right = arr.length - 1) {
            if (left < right) {
                const mid = Math.floor((left + right) / 2);
                yield* mergeSort(arr, viz, left, mid);
                yield* mergeSort(arr, viz, mid + 1, right);
                yield* merge(arr, viz, left, mid, right);
            }
        }

        function* merge(arr, viz, left, mid, right) {
            const leftArr = arr.slice(left, mid + 1);
            const rightArr = arr.slice(mid + 1, right + 1);

            let i = 0, j = 0, k = left;

            while (i < leftArr.length && j < rightArr.length) {
                viz.comparisons++;
                if (leftArr[i] <= rightArr[j]) {
                    arr[k++] = leftArr[i++];
                } else {
                    arr[k++] = rightArr[j++];
                }
                viz.swaps++;
                yield;
            }

            while (i < leftArr.length) {
                arr[k++] = leftArr[i++];
                viz.swaps++;
                yield;
            }

            while (j < rightArr.length) {
                arr[k++] = rightArr[j++];
                viz.swaps++;
                yield;
            }
        }

        // Heap Sort
        function* heapSort(arr, viz) {
            const n = arr.length;

            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                yield* heapify(arr, viz, n, i);
            }

            for (let i = n - 1; i > 0; i--) {
                [arr[0], arr[i]] = [arr[i], arr[0]];
                viz.swaps++;
                yield;
                yield* heapify(arr, viz, i, 0);
            }
        }

        function* heapify(arr, viz, n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            if (left < n) {
                viz.comparisons++;
                if (arr[left] > arr[largest]) largest = left;
            }

            if (right < n) {
                viz.comparisons++;
                if (arr[right] > arr[largest]) largest = right;
            }

            if (largest !== i) {
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                viz.swaps++;
                yield;
                yield* heapify(arr, viz, n, largest);
            }
        }

        const visualizers = [
            new SortVisualizer('Bubble Sort', bubbleSort, 50),
            new SortVisualizer('Selection Sort', selectionSort, 170),
            new SortVisualizer('Insertion Sort', insertionSort, 290),
            new SortVisualizer('Quick Sort', quickSort, 410),
            new SortVisualizer('Merge Sort', mergeSort, 530),
            new SortVisualizer('Heap Sort', heapSort, 650)
        ];

        let frame = 0;

        function animate() {
            frame++;

            // Reset every 5 seconds if all done
            if (frame % 300 === 0 && visualizers.every(v => v.done)) {
                visualizers.forEach(v => v.reset());
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Step all algorithms
            visualizers.forEach(v => {
                if (!v.done) {
                    for (let i = 0; i < 2; i++) v.step();
                }
                v.draw(50, width - 100, 100);
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
