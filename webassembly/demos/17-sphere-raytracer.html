<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sphere Ray Tracer - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            border: 2px solid #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 800;
        const height = canvas.height = 600;

        let time = 0;

        const spheres = [
            { x: 0, y: 0, z: 5, r: 1, color: [255, 50, 50] },
            { x: -2, y: -0.5, z: 4, r: 0.7, color: [50, 255, 50] },
            { x: 2, y: -0.5, z: 4.5, r: 0.8, color: [50, 50, 255] },
            { x: 0, y: 1.5, z: 3.5, r: 0.5, color: [255, 255, 50] }
        ];

        function raySphereIntersect(ox, oy, oz, dx, dy, dz, sx, sy, sz, sr) {
            const a = dx * dx + dy * dy + dz * dz;
            const b = 2 * (dx * (ox - sx) + dy * (oy - sy) + dz * (oz - sz));
            const c = (ox - sx) ** 2 + (oy - sy) ** 2 + (oz - sz) ** 2 - sr * sr;
            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) return null;

            const t = (-b - Math.sqrt(discriminant)) / (2 * a);
            if (t < 0) return null;

            return {
                t,
                x: ox + dx * t,
                y: oy + dy * t,
                z: oz + dz * t
            };
        }

        function getNormal(x, y, z, sx, sy, sz, sr) {
            const nx = (x - sx) / sr;
            const ny = (y - sy) / sr;
            const nz = (z - sz) / sr;
            const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
            return { x: nx / len, y: ny / len, z: nz / len };
        }

        function trace(ox, oy, oz, dx, dy, dz) {
            let closestT = Infinity;
            let closestSphere = null;
            let hitPoint = null;

            for (const sphere of spheres) {
                const hit = raySphereIntersect(ox, oy, oz, dx, dy, dz,
                    sphere.x, sphere.y, sphere.z, sphere.r);

                if (hit && hit.t < closestT) {
                    closestT = hit.t;
                    closestSphere = sphere;
                    hitPoint = hit;
                }
            }

            if (!closestSphere) {
                return [20, 20, 30];
            }

            const normal = getNormal(hitPoint.x, hitPoint.y, hitPoint.z,
                closestSphere.x, closestSphere.y, closestSphere.z, closestSphere.r);

            const lightX = Math.cos(time) * 3;
            const lightY = 3;
            const lightZ = 3 + Math.sin(time) * 2;

            const toLightX = lightX - hitPoint.x;
            const toLightY = lightY - hitPoint.y;
            const toLightZ = lightZ - hitPoint.z;
            const toLightLen = Math.sqrt(toLightX ** 2 + toLightY ** 2 + toLightZ ** 2);

            const diffuse = Math.max(0, (
                normal.x * toLightX +
                normal.y * toLightY +
                normal.z * toLightZ
            ) / toLightLen);

            const viewX = -dx;
            const viewY = -dy;
            const viewZ = -dz;

            const reflectX = 2 * normal.x * diffuse - toLightX / toLightLen;
            const reflectY = 2 * normal.y * diffuse - toLightY / toLightLen;
            const reflectZ = 2 * normal.z * diffuse - toLightZ / toLightLen;

            const specular = Math.max(0, reflectX * viewX + reflectY * viewY + reflectZ * viewZ);
            const spec = Math.pow(specular, 32);

            const ambient = 0.1;
            const brightness = ambient + diffuse * 0.7 + spec * 0.8;

            return [
                closestSphere.color[0] * brightness,
                closestSphere.color[1] * brightness,
                closestSphere.color[2] * brightness
            ];
        }

        function animate() {
            time += 0.02;

            spheres[1].x = -2 + Math.cos(time) * 0.5;
            spheres[1].y = -0.5 + Math.sin(time * 1.3) * 0.3;

            spheres[2].x = 2 + Math.sin(time * 0.8) * 0.5;
            spheres[2].z = 4.5 + Math.cos(time * 0.6) * 0.5;

            const imageData = ctx.createImageData(width, height);

            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const u = (x / width) * 2 - 1;
                    const v = (y / height) * 2 - 1;

                    const dx = u;
                    const dy = -v;
                    const dz = 1;
                    const len = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    const color = trace(0, 0, 0, dx / len, dy / len, dz / len);

                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            if (y + dy < height && x + dx < width) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                imageData.data[idx] = color[0];
                                imageData.data[idx + 1] = color[1];
                                imageData.data[idx + 2] = color[2];
                                imageData.data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
