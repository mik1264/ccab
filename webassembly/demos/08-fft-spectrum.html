<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFT Spectrum Analyzer - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #container {
            text-align: center;
        }
        canvas {
            border: 2px solid #222;
            display: block;
            margin: 10px auto;
        }
        button {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div>
            <button id="startBtn">Start Audio</button>
            <button id="stopBtn">Stop</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1024;
        const height = canvas.height = 512;

        let audioContext;
        let analyser;
        let dataArray;
        let bufferLength;
        let oscillator;
        let animating = false;

        // WebAssembly for FFT visualization processing
        const memory = new WebAssembly.Memory({ initial: 10 });
        const buffer = new Float32Array(memory.buffer);

        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60,
            0x02, 0x7f, 0x7f, 0x01, 0x7d, 0x03, 0x02, 0x01, 0x00, 0x05, 0x03, 0x01,
            0x00, 0x0a, 0x07, 0x0b, 0x01, 0x09, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73,
            0x73, 0x00, 0x00, 0x0a, 0x17, 0x01, 0x15, 0x00, 0x20, 0x00, 0x41, 0x02,
            0x74, 0x2a, 0x02, 0x00, 0x21, 0x02, 0x20, 0x02, 0x20, 0x01, 0xb8, 0xa0,
            0x43, 0x00, 0x00, 0x00, 0x43, 0xa0, 0x0b
        ]);

        let wasm;

        async function init() {
            try {
                const module = await WebAssembly.instantiate(wasmCode, {
                    env: { memory }
                });
                wasm = module.instance;
            } catch (e) {
                console.log('WASM init failed');
            }
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            if (animating) return;

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            // Create complex audio signal
            const masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(analyser);
            analyser.connect(audioContext.destination);

            // Multiple oscillators for rich spectrum
            for (let i = 0; i < 5; i++) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();

                osc.type = ['sine', 'square', 'sawtooth', 'triangle'][i % 4];
                osc.frequency.value = 220 * (i + 1) + Math.random() * 50;

                lfo.frequency.value = 0.5 + Math.random() * 2;
                lfoGain.gain.value = 50;

                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);

                gain.gain.value = 0.15 / (i + 1);
                osc.connect(gain);
                gain.connect(masterGain);

                osc.start();
                lfo.start();
            }

            animating = true;
            animate();
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            if (audioContext) {
                audioContext.close();
                animating = false;
            }
        });

        function animate() {
            if (!animating) return;

            analyser.getByteFrequencyData(dataArray);

            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            const barWidth = width / bufferLength;
            let x = 0;

            // Frequency bars
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * height * 0.8;

                const hue = (i / bufferLength) * 360;
                const brightness = 30 + (dataArray[i] / 255) * 50;

                ctx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);

                // Mirror effect
                ctx.fillStyle = `hsla(${hue}, 100%, ${brightness}%, 0.3)`;
                ctx.fillRect(x, 0, barWidth, barHeight);

                x += barWidth;
            }

            // Waveform overlay
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const sliceWidth = width / bufferLength;
            x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 255;
                const y = height / 2 + (v - 0.5) * height * 0.5;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            ctx.stroke();

            // Circular visualization
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 100;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            for (let i = 0; i < bufferLength; i += 4) {
                const angle = (i / bufferLength) * Math.PI * 2;
                const amp = (dataArray[i] / 255) * 100;

                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + amp);
                const y2 = centerY + Math.sin(angle) * (radius + amp);

                const hue = (i / bufferLength) * 360;
                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>
