<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellular Automata 3D - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1000;
        const height = canvas.height = 700;

        const SIZE = 20;
        let grid = new Uint8Array(SIZE * SIZE * SIZE);
        let nextGrid = new Uint8Array(SIZE * SIZE * SIZE);

        for (let i = 0; i < SIZE * SIZE * SIZE; i++) {
            grid[i] = Math.random() > 0.7 ? 1 : 0;
        }

        let angleY = 0;

        function getCell(x, y, z) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return 0;
            return grid[z * SIZE * SIZE + y * SIZE + x];
        }

        function countNeighbors(x, y, z) {
            let count = 0;
            for (let dz = -1; dz <= 1; dz++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;
                        count += getCell(x + dx, y + dy, z + dz);
                    }
                }
            }
            return count;
        }

        function update() {
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const idx = z * SIZE * SIZE + y * SIZE + x;
                        const neighbors = countNeighbors(x, y, z);
                        const current = grid[idx];

                        if (current === 1) {
                            nextGrid[idx] = (neighbors >= 5 && neighbors <= 7) ? 1 : 0;
                        } else {
                            nextGrid[idx] = (neighbors === 6) ? 1 : 0;
                        }
                    }
                }
            }

            [grid, nextGrid] = [nextGrid, grid];
        }

        function rotateY(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos + z * sin,
                y: y,
                z: -x * sin + z * cos
            };
        }

        function project(x, y, z) {
            const scale = 20;
            const distance = 50;
            const factor = scale / (distance + z);

            return {
                x: width / 2 + x * factor,
                y: height / 2 - y * factor,
                z: z
            };
        }

        let frame = 0;

        function animate() {
            frame++;
            angleY += 0.01;

            if (frame % 5 === 0) {
                update();
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const cubes = [];

            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const idx = z * SIZE * SIZE + y * SIZE + x;
                        if (grid[idx] === 1) {
                            const cx = x - SIZE / 2;
                            const cy = y - SIZE / 2;
                            const cz = z - SIZE / 2;

                            const rotated = rotateY(cx, cy, cz, angleY);
                            const projected = project(rotated.x, rotated.y, rotated.z);

                            cubes.push({
                                x: projected.x,
                                y: projected.y,
                                z: projected.z,
                                size: 12
                            });
                        }
                    }
                }
            }

            cubes.sort((a, b) => a.z - b.z);

            cubes.forEach(cube => {
                const depth = (cube.z + 50) / 100;
                const hue = depth * 240;
                const brightness = 30 + depth * 50;

                ctx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                ctx.fillRect(
                    cube.x - cube.size / 2,
                    cube.y - cube.size / 2,
                    cube.size,
                    cube.size
                );

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    cube.x - cube.size / 2,
                    cube.y - cube.size / 2,
                    cube.size,
                    cube.size
                );
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
