<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualization - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        #container {
            text-align: center;
        }
        canvas {
            border: 2px solid #1a1a1a;
            display: block;
            margin: 20px auto;
            cursor: crosshair;
        }
        #info {
            color: #0f0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="info">Click to add obstacles | Path updates in real-time</div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1000;
        const height = canvas.height = 700;

        const COLS = 50;
        const ROWS = 35;
        const CELL_SIZE = width / COLS;

        const grid = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));

        let start = { x: 5, y: 17 };
        let goal = { x: 44, y: 17 };

        // Add random obstacles
        for (let i = 0; i < 200; i++) {
            const x = Math.floor(Math.random() * COLS);
            const y = Math.floor(Math.random() * ROWS);
            if ((x !== start.x || y !== start.y) && (x !== goal.x || y !== goal.y)) {
                grid[y][x] = 1;
            }
        }

        // WebAssembly heuristic calculation
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x09, 0x01, 0x60,
            0x04, 0x7f, 0x7f, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07,
            0x0d, 0x01, 0x09, 0x68, 0x65, 0x75, 0x72, 0x69, 0x73, 0x74, 0x69, 0x63,
            0x00, 0x00, 0x0a, 0x28, 0x01, 0x26, 0x01, 0x02, 0x7f, 0x20, 0x02, 0x20,
            0x00, 0x6b, 0x21, 0x04, 0x20, 0x03, 0x20, 0x01, 0x6b, 0x21, 0x05, 0x20,
            0x04, 0x41, 0x00, 0x48, 0x04, 0x40, 0x41, 0x00, 0x20, 0x04, 0x6b, 0x21,
            0x04, 0x0b, 0x20, 0x05, 0x41, 0x00, 0x48, 0x04, 0x40, 0x41, 0x00, 0x20,
            0x05, 0x6b, 0x21, 0x05, 0x0b, 0x20, 0x04, 0x20, 0x05, 0x6a, 0x0b
        ]);

        let wasm;

        async function init() {
            try {
                const module = await WebAssembly.instantiate(wasmCode);
                wasm = module.instance;
            } catch (e) {
                console.log('WASM fallback');
            }
            animate();
        }

        function heuristic(x1, y1, x2, y2) {
            if (wasm) {
                return wasm.exports.heuristic(x1, y1, x2, y2);
            }
            return Math.abs(x2 - x1) + Math.abs(y2 - y1);
        }

        function aStar() {
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const key = (p) => `${p.x},${p.y}`;

            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start.x, start.y, goal.x, goal.y));

            const visitedOrder = [];

            while (openSet.length > 0) {
                // Find node with lowest fScore
                let current = openSet[0];
                let currentIdx = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if ((fScore.get(key(openSet[i])) || Infinity) < (fScore.get(key(current)) || Infinity)) {
                        current = openSet[i];
                        currentIdx = i;
                    }
                }

                if (current.x === goal.x && current.y === goal.y) {
                    // Reconstruct path
                    const path = [];
                    let temp = current;
                    while (cameFrom.has(key(temp))) {
                        path.unshift(temp);
                        temp = cameFrom.get(key(temp));
                    }
                    path.unshift(start);
                    return { path, visited: visitedOrder };
                }

                openSet.splice(currentIdx, 1);
                visitedOrder.push(current);

                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= COLS || neighbor.y < 0 || neighbor.y >= ROWS) continue;
                    if (grid[neighbor.y][neighbor.x] === 1) continue;

                    const tentativeGScore = (gScore.get(key(current)) || 0) + 1;
                    const neighborKey = key(neighbor);

                    if (tentativeGScore < (gScore.get(neighborKey) || Infinity)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor.x, neighbor.y, goal.x, goal.y));

                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            return { path: [], visited: visitedOrder };
        }

        let pathResult = aStar();

        function animate() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;

                    if (grid[y][x] === 1) {
                        ctx.fillStyle = '#333';
                    } else {
                        ctx.fillStyle = '#111';
                    }

                    ctx.fillRect(px, py, CELL_SIZE - 1, CELL_SIZE - 1);
                }
            }

            // Draw visited cells
            for (let i = 0; i < pathResult.visited.length; i++) {
                const p = pathResult.visited[i];
                const intensity = i / pathResult.visited.length;

                ctx.fillStyle = `rgba(0, 100, 255, ${intensity * 0.5})`;
                ctx.fillRect(
                    p.x * CELL_SIZE,
                    p.y * CELL_SIZE,
                    CELL_SIZE - 1,
                    CELL_SIZE - 1
                );
            }

            // Draw path
            if (pathResult.path.length > 0) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();

                for (let i = 0; i < pathResult.path.length; i++) {
                    const p = pathResult.path[i];
                    const px = p.x * CELL_SIZE + CELL_SIZE / 2;
                    const py = p.y * CELL_SIZE + CELL_SIZE / 2;

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }

                ctx.stroke();

                // Draw path cells
                pathResult.path.forEach((p, i) => {
                    const hue = (i / pathResult.path.length) * 120;
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.6)`;
                    ctx.fillRect(
                        p.x * CELL_SIZE + 2,
                        p.y * CELL_SIZE + 2,
                        CELL_SIZE - 5,
                        CELL_SIZE - 5
                    );
                });
            }

            // Draw start
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(
                start.x * CELL_SIZE + CELL_SIZE / 2,
                start.y * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE / 3,
                0,
                Math.PI * 2
            );
            ctx.fill();

            // Draw goal
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(
                goal.x * CELL_SIZE + CELL_SIZE / 2,
                goal.y * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE / 3,
                0,
                Math.PI * 2
            );
            ctx.fill();

            // Animate goal
            goal.x = Math.floor(25 + Math.sin(Date.now() * 0.001) * 15);
            goal.y = Math.floor(17 + Math.cos(Date.now() * 0.0007) * 12);

            if (grid[goal.y] && grid[goal.y][goal.x] !== 1) {
                pathResult = aStar();
            }

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                if ((x !== start.x || y !== start.y) && (x !== goal.x || y !== goal.y)) {
                    grid[y][x] = grid[y][x] === 1 ? 0 : 1;
                    pathResult = aStar();
                }
            }
        });

        init();
    </script>
</body>
</html>
