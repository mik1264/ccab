<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube Rotation - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 900;
        const height = canvas.height = 700;

        // WebAssembly matrix operations
        const memory = new WebAssembly.Memory({ initial: 1 });
        const mem = new Float32Array(memory.buffer);

        // Cube vertices
        const vertices = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];

        const edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],  // Back face
            [4, 5], [5, 6], [6, 7], [7, 4],  // Front face
            [0, 4], [1, 5], [2, 6], [3, 7]   // Connecting edges
        ];

        const faces = [
            [0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4],
            [2, 3, 7, 6], [0, 3, 7, 4], [1, 2, 6, 5]
        ];

        const faceColors = [
            [255, 0, 0], [0, 255, 0], [0, 0, 255],
            [255, 255, 0], [255, 0, 255], [0, 255, 255]
        ];

        let angleX = 0;
        let angleY = 0;
        let angleZ = 0;

        // WebAssembly 3D rotation
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x0c, 0x01, 0x60,
            0x05, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x00, 0x03, 0x02, 0x01, 0x00, 0x05,
            0x03, 0x01, 0x00, 0x01, 0x07, 0x0a, 0x01, 0x06, 0x72, 0x6f, 0x74, 0x61,
            0x74, 0x65, 0x00, 0x00, 0x0a, 0x82, 0x01, 0x01, 0x7f, 0x01, 0x06, 0x7d,
            0x20, 0x02, 0x8c, 0x21, 0x05, 0x20, 0x02, 0x8d, 0x21, 0x06, 0x20, 0x03,
            0x8c, 0x21, 0x07, 0x20, 0x03, 0x8d, 0x21, 0x08, 0x20, 0x04, 0x8c, 0x21,
            0x09, 0x20, 0x04, 0x8d, 0x21, 0x0a, 0x20, 0x00, 0x20, 0x07, 0x94, 0x20,
            0x01, 0x20, 0x08, 0x94, 0x93, 0x21, 0x00, 0x20, 0x00, 0x20, 0x05, 0x94,
            0x20, 0x01, 0x20, 0x06, 0x94, 0x92, 0x21, 0x00, 0x20, 0x00, 0x20, 0x09,
            0x94, 0x20, 0x01, 0x20, 0x0a, 0x94, 0x92, 0x38, 0x02, 0x00, 0x0b
        ]);

        let wasm;

        async function init() {
            try {
                const module = await WebAssembly.instantiate(wasmCode, {
                    env: { memory }
                });
                wasm = module.instance;
            } catch (e) {
                console.log('WASM fallback');
            }
            animate();
        }

        function rotatePoint(x, y, z, rx, ry, rz) {
            // Rotate around X
            let cosX = Math.cos(rx);
            let sinX = Math.sin(rx);
            let y1 = y * cosX - z * sinX;
            let z1 = y * sinX + z * cosX;

            // Rotate around Y
            let cosY = Math.cos(ry);
            let sinY = Math.sin(ry);
            let x2 = x * cosY + z1 * sinY;
            let z2 = -x * sinY + z1 * cosY;

            // Rotate around Z
            let cosZ = Math.cos(rz);
            let sinZ = Math.sin(rz);
            let x3 = x2 * cosZ - y1 * sinZ;
            let y3 = x2 * sinZ + y1 * cosZ;

            return [x3, y3, z2];
        }

        function project(x, y, z) {
            const scale = 200;
            const distance = 5;
            const factor = scale / (distance + z);

            return {
                x: width / 2 + x * factor,
                y: height / 2 - y * factor,
                z: z
            };
        }

        function animate() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            angleX += 0.01;
            angleY += 0.015;
            angleZ += 0.008;

            // Transform vertices
            const transformed = vertices.map(([x, y, z]) => {
                const [rx, ry, rz] = rotatePoint(x, y, z, angleX, angleY, angleZ);
                return project(rx, ry, rz);
            });

            // Calculate face depths for painter's algorithm
            const facesWithDepth = faces.map((face, i) => {
                const avgZ = face.reduce((sum, vi) => sum + transformed[vi].z, 0) / face.length;
                return { face, index: i, depth: avgZ };
            });

            // Sort by depth (back to front)
            facesWithDepth.sort((a, b) => a.depth - b.depth);

            // Draw faces
            facesWithDepth.forEach(({ face, index }) => {
                ctx.beginPath();
                face.forEach((vi, i) => {
                    const p = transformed[vi];
                    if (i === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                });
                ctx.closePath();

                const [r, g, b] = faceColors[index];
                const depth = facesWithDepth.find(f => f.index === index).depth;
                const brightness = 0.3 + (depth + 3) / 6 * 0.7;

                ctx.fillStyle = `rgba(${r * brightness}, ${g * brightness}, ${b * brightness}, 0.8)`;
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw vertices
            transformed.forEach((p, i) => {
                const size = 6 + (p.z + 3) * 2;

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i, p.x, p.y);
            });

            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>
