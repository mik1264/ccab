<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marching Cubes - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1000;
        const height = canvas.height = 700;

        const GRID_SIZE = 20;
        const CELL_SIZE = 2;
        let time = 0;

        function scalarField(x, y, z, t) {
            const freq = 0.15;
            const value =
                Math.sin(x * freq + t) +
                Math.sin(y * freq + t * 1.3) +
                Math.sin(z * freq + t * 0.7) +
                Math.sin(Math.sqrt(x * x + y * y + z * z) * freq * 0.5 + t);

            return value;
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function interpolateVertex(x1, y1, z1, v1, x2, y2, z2, v2, isovalue) {
            if (Math.abs(isovalue - v1) < 0.001) return { x: x1, y: y1, z: z1 };
            if (Math.abs(isovalue - v2) < 0.001) return { x: x2, y: y2, z: z2 };
            if (Math.abs(v1 - v2) < 0.001) return { x: x1, y: y1, z: z1 };

            const t = (isovalue - v1) / (v2 - v1);
            return {
                x: lerp(x1, x2, t),
                y: lerp(y1, y2, t),
                z: lerp(z1, z2, t)
            };
        }

        function rotateY(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos + z * sin,
                y: y,
                z: -x * sin + z * cos
            };
        }

        function rotateX(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x,
                y: y * cos - z * sin,
                z: y * sin + z * cos
            };
        }

        function project(x, y, z) {
            const scale = 15;
            const distance = 50;
            const factor = scale / (distance + z);

            return {
                x: width / 2 + x * factor,
                y: height / 2 - y * factor,
                z: z
            };
        }

        function animate() {
            time += 0.02;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const triangles = [];
            const isovalue = 0;

            for (let z = -GRID_SIZE; z < GRID_SIZE; z += CELL_SIZE) {
                for (let y = -GRID_SIZE; y < GRID_SIZE; y += CELL_SIZE) {
                    for (let x = -GRID_SIZE; x < GRID_SIZE; x += CELL_SIZE) {
                        const v000 = scalarField(x, y, z, time);
                        const v100 = scalarField(x + CELL_SIZE, y, z, time);
                        const v110 = scalarField(x + CELL_SIZE, y + CELL_SIZE, z, time);
                        const v010 = scalarField(x, y + CELL_SIZE, z, time);
                        const v001 = scalarField(x, y, z + CELL_SIZE, time);
                        const v101 = scalarField(x + CELL_SIZE, y, z + CELL_SIZE, time);
                        const v111 = scalarField(x + CELL_SIZE, y + CELL_SIZE, z + CELL_SIZE, time);
                        const v011 = scalarField(x, y + CELL_SIZE, z + CELL_SIZE, time);

                        let cubeindex = 0;
                        if (v000 < isovalue) cubeindex |= 1;
                        if (v100 < isovalue) cubeindex |= 2;
                        if (v110 < isovalue) cubeindex |= 4;
                        if (v010 < isovalue) cubeindex |= 8;
                        if (v001 < isovalue) cubeindex |= 16;
                        if (v101 < isovalue) cubeindex |= 32;
                        if (v111 < isovalue) cubeindex |= 64;
                        if (v011 < isovalue) cubeindex |= 128;

                        if (cubeindex !== 0 && cubeindex !== 255) {
                            const edgeVertices = [
                                interpolateVertex(x, y, z, v000, x + CELL_SIZE, y, z, v100, isovalue),
                                interpolateVertex(x + CELL_SIZE, y, z, v100, x + CELL_SIZE, y + CELL_SIZE, z, v110, isovalue),
                                interpolateVertex(x + CELL_SIZE, y + CELL_SIZE, z, v110, x, y + CELL_SIZE, z, v010, isovalue),
                                interpolateVertex(x, y + CELL_SIZE, z, v010, x, y, z, v000, isovalue),
                                interpolateVertex(x, y, z + CELL_SIZE, v001, x + CELL_SIZE, y, z + CELL_SIZE, v101, isovalue),
                                interpolateVertex(x + CELL_SIZE, y, z + CELL_SIZE, v101, x + CELL_SIZE, y + CELL_SIZE, z + CELL_SIZE, v111, isovalue),
                                interpolateVertex(x + CELL_SIZE, y + CELL_SIZE, z + CELL_SIZE, v111, x, y + CELL_SIZE, z + CELL_SIZE, v011, isovalue),
                                interpolateVertex(x, y + CELL_SIZE, z + CELL_SIZE, v011, x, y, z + CELL_SIZE, v001, isovalue),
                                interpolateVertex(x, y, z, v000, x, y, z + CELL_SIZE, v001, isovalue),
                                interpolateVertex(x + CELL_SIZE, y, z, v100, x + CELL_SIZE, y, z + CELL_SIZE, v101, isovalue),
                                interpolateVertex(x + CELL_SIZE, y + CELL_SIZE, z, v110, x + CELL_SIZE, y + CELL_SIZE, z + CELL_SIZE, v111, isovalue),
                                interpolateVertex(x, y + CELL_SIZE, z, v010, x, y + CELL_SIZE, z + CELL_SIZE, v011, isovalue)
                            ];

                            for (let i = 0; i < edgeVertices.length; i += 3) {
                                if (edgeVertices[i]) {
                                    triangles.push([
                                        edgeVertices[i],
                                        edgeVertices[i + 1] || edgeVertices[i],
                                        edgeVertices[i + 2] || edgeVertices[i]
                                    ]);
                                }
                            }
                        }
                    }
                }
            }

            const transformedTriangles = triangles.map(tri => {
                return tri.map(v => {
                    let p = rotateY(v.x, v.y, v.z, time * 0.5);
                    p = rotateX(p.x, p.y, p.z, 0.5);
                    return project(p.x, p.y, p.z);
                });
            });

            transformedTriangles.sort((a, b) => {
                const avgZa = (a[0].z + a[1].z + a[2].z) / 3;
                const avgZb = (b[0].z + b[1].z + b[2].z) / 3;
                return avgZa - avgZb;
            });

            transformedTriangles.forEach((tri, idx) => {
                const hue = (idx / transformedTriangles.length) * 360;

                ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 0.5;

                ctx.beginPath();
                ctx.moveTo(tri[0].x, tri[0].y);
                ctx.lineTo(tri[1].x, tri[1].y);
                ctx.lineTo(tri[2].x, tri[2].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
