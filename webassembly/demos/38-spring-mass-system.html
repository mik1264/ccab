<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Mass System - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1000;
        const height = canvas.height = 700;

        class Mass {
            constructor(x, y, fixed = false) {
                this.x = x;
                this.y = y;
                this.px = x;
                this.py = y;
                this.fx = 0;
                this.fy = 0;
                this.fixed = fixed;
                this.mass = 1;
            }

            update(dt) {
                if (this.fixed) return;

                const vx = (this.x - this.px) * 0.99;
                const vy = (this.y - this.py) * 0.99;

                this.px = this.x;
                this.py = this.y;

                const ax = this.fx / this.mass;
                const ay = this.fy / this.mass + 0.5;

                this.x += vx + ax * dt * dt;
                this.y += vy + ay * dt * dt;

                this.fx = 0;
                this.fy = 0;

                if (this.y > height - 50) {
                    this.y = height - 50;
                    this.py = this.y + (this.y - this.py) * 0.5;
                }

                if (this.x < 50) {
                    this.x = 50;
                    this.px = this.x + (this.x - this.px) * 0.5;
                }

                if (this.x > width - 50) {
                    this.x = width - 50;
                    this.px = this.x + (this.x - this.px) * 0.5;
                }
            }

            applyForce(fx, fy) {
                this.fx += fx;
                this.fy += fy;
            }
        }

        class Spring {
            constructor(m1, m2, restLength, stiffness, damping) {
                this.m1 = m1;
                this.m2 = m2;
                this.restLength = restLength;
                this.stiffness = stiffness;
                this.damping = damping;
            }

            update() {
                const dx = this.m2.x - this.m1.x;
                const dy = this.m2.y - this.m1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return;

                const force = (dist - this.restLength) * this.stiffness;

                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;

                const vx = (this.m2.x - this.m2.px) - (this.m1.x - this.m1.px);
                const vy = (this.m2.y - this.m2.py) - (this.m1.y - this.m1.py);

                const dampingForceX = vx * this.damping;
                const dampingForceY = vy * this.damping;

                this.m1.applyForce(fx + dampingForceX, fy + dampingForceY);
                this.m2.applyForce(-fx - dampingForceX, -fy - dampingForceY);
            }

            draw() {
                const dx = this.m2.x - this.m1.x;
                const dy = this.m2.y - this.m1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const extension = Math.abs(dist - this.restLength) / this.restLength;

                const hue = Math.max(0, 120 - extension * 300);

                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.lineWidth = 2 + extension * 5;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(this.m1.x, this.m1.y);
                ctx.lineTo(this.m2.x, this.m2.y);
                ctx.stroke();
            }
        }

        const masses = [];
        const springs = [];

        const gridWidth = 15;
        const gridHeight = 10;
        const spacing = 50;

        const startX = (width - (gridWidth - 1) * spacing) / 2;
        const startY = 100;

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                const fixed = y === 0 && (x % 3 === 0);
                masses.push(new Mass(
                    startX + x * spacing,
                    startY + y * spacing,
                    fixed
                ));
            }
        }

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                const idx = y * gridWidth + x;

                if (x < gridWidth - 1) {
                    springs.push(new Spring(masses[idx], masses[idx + 1], spacing, 0.5, 0.1));
                }

                if (y < gridHeight - 1) {
                    springs.push(new Spring(masses[idx], masses[idx + gridWidth], spacing, 0.5, 0.1));
                }

                if (x < gridWidth - 1 && y < gridHeight - 1) {
                    const diag = Math.sqrt(spacing * spacing * 2);
                    springs.push(new Spring(masses[idx], masses[idx + gridWidth + 1], diag, 0.3, 0.05));
                }

                if (x > 0 && y < gridHeight - 1) {
                    const diag = Math.sqrt(spacing * spacing * 2);
                    springs.push(new Spring(masses[idx], masses[idx + gridWidth - 1], diag, 0.3, 0.05));
                }
            }
        }

        let mouseX = -1000;
        let mouseY = -1000;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);

        function animate() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            springs.forEach(spring => spring.update());

            if (mouseDown) {
                masses.forEach(mass => {
                    const dx = mouseX - mass.x;
                    const dy = mouseY - mass.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 100 && !mass.fixed) {
                        mass.applyForce(dx * 0.1, dy * 0.1);
                    }
                });
            }

            masses.forEach(mass => mass.update(1));

            springs.forEach(spring => spring.draw());

            masses.forEach(mass => {
                if (mass.fixed) {
                    ctx.fillStyle = '#f00';
                } else {
                    ctx.fillStyle = '#0ff';
                }

                ctx.beginPath();
                ctx.arc(mass.x, mass.y, mass.fixed ? 6 : 4, 0, Math.PI * 2);
                ctx.fill();

                if (!mass.fixed) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
