<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Noise Generator - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 800;
        const height = canvas.height = 600;

        // Permutation table for Perlin noise
        const p = new Uint8Array(512);
        for (let i = 0; i < 256; i++) p[i] = i;
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [p[i], p[j]] = [p[j], p[i]];
        }
        for (let i = 0; i < 256; i++) p[256 + i] = p[i];

        // WebAssembly memory for permutation table
        const memory = new WebAssembly.Memory({ initial: 1 });
        const mem = new Uint8Array(memory.buffer);
        mem.set(p);

        // WebAssembly module for Perlin noise
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60,
            0x02, 0x7d, 0x7d, 0x01, 0x7d, 0x03, 0x02, 0x01, 0x00, 0x05, 0x03, 0x01,
            0x00, 0x01, 0x07, 0x09, 0x01, 0x05, 0x6e, 0x6f, 0x69, 0x73, 0x65, 0x00,
            0x00, 0x0a, 0x82, 0x01, 0x01, 0x7f, 0x01, 0x08, 0x7d, 0x20, 0x00, 0xab,
            0xa7, 0x41, 0xff, 0x01, 0x71, 0x21, 0x02, 0x20, 0x01, 0xab, 0xa7, 0x41,
            0xff, 0x01, 0x71, 0x21, 0x03, 0x20, 0x00, 0x20, 0x00, 0xab, 0xa7, 0xb8,
            0x94, 0x21, 0x04, 0x20, 0x01, 0x20, 0x01, 0xab, 0xa7, 0xb8, 0x94, 0x21,
            0x05, 0x43, 0x00, 0x00, 0x80, 0x3f, 0x20, 0x04, 0x93, 0x21, 0x06, 0x43,
            0x00, 0x00, 0x80, 0x3f, 0x20, 0x05, 0x93, 0x21, 0x07, 0x20, 0x04, 0x20,
            0x04, 0x94, 0x43, 0x00, 0x00, 0x40, 0x40, 0x20, 0x04, 0x94, 0x93, 0x43,
            0x00, 0x00, 0x80, 0x3f, 0x92, 0x21, 0x08, 0x20, 0x05, 0x20, 0x05, 0x94,
            0x43, 0x00, 0x00, 0x40, 0x40, 0x20, 0x05, 0x94, 0x93, 0x43, 0x00, 0x00,
            0x80, 0x3f, 0x92, 0x21, 0x09, 0x20, 0x08, 0x20, 0x06, 0x94, 0x20, 0x09,
            0x20, 0x07, 0x94, 0x92, 0x0b
        ]);

        let wasm;
        let time = 0;

        async function init() {
            try {
                const module = await WebAssembly.instantiate(wasmCode, {
                    env: { memory }
                });
                wasm = module.instance;
            } catch (e) {
                console.log('WASM fallback');
            }
            animate();
        }

        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(a, b, t) {
            return a + t * (b - a);
        }

        function grad(hash, x, y) {
            const h = hash & 3;
            const u = h < 2 ? x : y;
            const v = h < 2 ? y : x;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        function perlin(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;

            x -= Math.floor(x);
            y -= Math.floor(y);

            const u = fade(x);
            const v = fade(y);

            const a = p[X] + Y;
            const b = p[X + 1] + Y;

            return lerp(
                lerp(grad(p[a], x, y), grad(p[b], x - 1, y), u),
                lerp(grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1), u),
                v
            );
        }

        function octavePerlin(x, y, octaves) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += perlin(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }

            return value / maxValue;
        }

        function animate() {
            time += 0.005;
            const imageData = ctx.createImageData(width, height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const scale = 0.01;

                    // Layered Perlin noise
                    const n1 = octavePerlin(x * scale + time, y * scale, 4);
                    const n2 = octavePerlin(x * scale * 2 - time * 0.5, y * scale * 2, 3);
                    const n3 = octavePerlin(x * scale * 0.5, y * scale * 0.5 + time * 0.3, 2);

                    // Combine noise layers
                    const combined = (n1 * 0.5 + n2 * 0.3 + n3 * 0.2);
                    const normalized = (combined + 1) / 2;

                    const idx = (y * width + x) * 4;

                    // Create colorful pattern
                    const hue = normalized * 360 + time * 20;
                    const saturation = 0.7 + normalized * 0.3;
                    const lightness = 0.3 + normalized * 0.4;

                    const c = hsl2rgb(hue % 360, saturation, lightness);

                    imageData.data[idx] = c[0];
                    imageData.data[idx + 1] = c[1];
                    imageData.data[idx + 2] = c[2];
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            requestAnimationFrame(animate);
        }

        function hsl2rgb(h, s, l) {
            h /= 360;
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            const r = hue2rgb(p, q, h + 1 / 3);
            const g = hue2rgb(p, q, h);
            const b = hue2rgb(p, q, h - 1 / 3);
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        init();
    </script>
</body>
</html>
