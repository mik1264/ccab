<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Marching - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 800;
        const height = canvas.height = 600;

        let time = 0;

        // WebAssembly for distance field calculations
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x01, 0x60,
            0x03, 0x7d, 0x7d, 0x7d, 0x01, 0x7d, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0d,
            0x01, 0x09, 0x73, 0x64, 0x66, 0x53, 0x70, 0x68, 0x65, 0x72, 0x65, 0x00,
            0x00, 0x0a, 0x18, 0x01, 0x16, 0x00, 0x20, 0x00, 0x20, 0x00, 0x94, 0x20,
            0x01, 0x20, 0x01, 0x94, 0x92, 0x20, 0x02, 0x20, 0x02, 0x94, 0x92, 0x91,
            0x43, 0x00, 0x00, 0x80, 0x3f, 0x93, 0x0b
        ]);

        let wasm;

        async function init() {
            try {
                const module = await WebAssembly.instantiate(wasmCode);
                wasm = module.instance;
            } catch (e) {
                console.log('WASM fallback');
            }
            animate();
        }

        function sdSphere(x, y, z) {
            if (wasm) {
                return wasm.exports.sdfSphere(x, y, z);
            }
            return Math.sqrt(x * x + y * y + z * z) - 1;
        }

        function sdBox(x, y, z, bx, by, bz) {
            const dx = Math.abs(x) - bx;
            const dy = Math.abs(y) - by;
            const dz = Math.abs(z) - bz;
            return Math.sqrt(
                Math.max(dx, 0) ** 2 +
                Math.max(dy, 0) ** 2 +
                Math.max(dz, 0) ** 2
            ) + Math.min(Math.max(dx, Math.max(dy, dz)), 0);
        }

        function sdfScene(x, y, z, t) {
            // Rotating spheres
            const s1 = sdSphere(
                x - Math.cos(t) * 2,
                y - Math.sin(t * 1.3) * 1.5,
                z - Math.sin(t * 0.7) * 2
            );

            const s2 = sdSphere(
                x + Math.cos(t * 0.8) * 2.5,
                y + Math.sin(t) * 1.2,
                z - 1
            );

            // Box
            const b = sdBox(
                x - Math.sin(t * 0.5) * 1.5,
                y,
                z + 2,
                0.8, 0.8, 0.8
            );

            // Floor
            const floor = y + 2;

            return Math.min(Math.min(s1, s2), Math.min(b, floor));
        }

        function rayMarch(ox, oy, oz, dx, dy, dz, t) {
            let dist = 0;
            for (let i = 0; i < 64; i++) {
                const x = ox + dx * dist;
                const y = oy + dy * dist;
                const z = oz + dz * dist;

                const d = sdfScene(x, y, z, t);

                if (d < 0.001) {
                    return { hit: true, dist, pos: { x, y, z }, steps: i };
                }

                dist += d;

                if (dist > 20) {
                    return { hit: false, dist: 20 };
                }
            }
            return { hit: false, dist };
        }

        function getNormal(x, y, z, t) {
            const eps = 0.001;
            return {
                x: sdfScene(x + eps, y, z, t) - sdfScene(x - eps, y, z, t),
                y: sdfScene(x, y + eps, z, t) - sdfScene(x, y - eps, z, t),
                z: sdfScene(x, y, z + eps, t) - sdfScene(x, y, z - eps, t)
            };
        }

        function animate() {
            time += 0.016;
            const imageData = ctx.createImageData(width, height);

            const camX = Math.cos(time * 0.3) * 5;
            const camY = 1;
            const camZ = Math.sin(time * 0.3) * 5;

            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const u = (x / width) * 2 - 1;
                    const v = (y / height) * 2 - 1;

                    // Ray direction
                    const dx = u - camX * 0.1;
                    const dy = -v;
                    const dz = 1;
                    const len = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    const result = rayMarch(
                        camX, camY, camZ,
                        dx / len, dy / len, dz / len,
                        time
                    );

                    const idx = (y * width + x) * 4;

                    if (result.hit) {
                        const normal = getNormal(result.pos.x, result.pos.y, result.pos.z, time);
                        const normLen = Math.sqrt(normal.x ** 2 + normal.y ** 2 + normal.z ** 2);
                        const nx = normal.x / normLen;
                        const ny = normal.y / normLen;
                        const nz = normal.z / normLen;

                        // Simple lighting
                        const lightX = Math.cos(time) * 3;
                        const lightY = 3;
                        const lightZ = Math.sin(time) * 3;

                        const toLightX = lightX - result.pos.x;
                        const toLightY = lightY - result.pos.y;
                        const toLightZ = lightZ - result.pos.z;
                        const toLightLen = Math.sqrt(toLightX ** 2 + toLightY ** 2 + toLightZ ** 2);

                        const diff = Math.max(0, (nx * toLightX + ny * toLightY + nz * toLightZ) / toLightLen);
                        const ao = 1 - result.steps / 64;

                        const brightness = diff * ao * 255;
                        const hue = (result.pos.y + 2) * 60;

                        const r = Math.floor(brightness * (1 + Math.sin(hue) * 0.5));
                        const g = Math.floor(brightness * (1 + Math.sin(hue + 2) * 0.5));
                        const b = Math.floor(brightness * (1 + Math.sin(hue + 4) * 0.5));

                        // Write to 2x2 block for performance
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                if (y + dy < height && x + dx < width) {
                                    const i = ((y + dy) * width + (x + dx)) * 4;
                                    imageData.data[i] = r;
                                    imageData.data[i + 1] = g;
                                    imageData.data[i + 2] = b;
                                    imageData.data[i + 3] = 255;
                                }
                            }
                        }
                    } else {
                        // Sky
                        const skyColor = Math.floor((1 - v * 0.5) * 30);
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                if (y + dy < height && x + dx < width) {
                                    const i = ((y + dy) * width + (x + dx)) * 4;
                                    imageData.data[i] = skyColor;
                                    imageData.data[i + 1] = skyColor * 1.2;
                                    imageData.data[i + 2] = skyColor * 1.5;
                                    imageData.data[i + 3] = 255;
                                }
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>
