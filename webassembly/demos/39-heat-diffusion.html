<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heat Diffusion - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridWidth = 200;
        const gridHeight = 200;
        canvas.width = gridWidth * 4;
        canvas.height = gridHeight * 4;

        const grid = new Float32Array(gridWidth * gridHeight);
        const nextGrid = new Float32Array(gridWidth * gridHeight);

        for (let i = 0; i < gridWidth * gridHeight; i++) {
            grid[i] = 0;
        }

        const sources = [
            { x: gridWidth / 4, y: gridHeight / 2, temp: 1 },
            { x: gridWidth * 3 / 4, y: gridHeight / 2, temp: 1 }
        ];

        const diffusionRate = 0.2;

        function diffuse() {
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 1; x < gridWidth - 1; x++) {
                    const idx = y * gridWidth + x;

                    const sum = (
                        grid[idx - 1] +
                        grid[idx + 1] +
                        grid[idx - gridWidth] +
                        grid[idx + gridWidth]
                    ) / 4;

                    nextGrid[idx] = grid[idx] + (sum - grid[idx]) * diffusionRate;
                }
            }

            for (let i = 0; i < gridWidth * gridHeight; i++) {
                grid[i] = nextGrid[i];
            }

            sources.forEach(source => {
                const idx = Math.floor(source.y) * gridWidth + Math.floor(source.x);
                grid[idx] = source.temp;

                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = Math.floor(source.x) + dx;
                        const ny = Math.floor(source.y) + dy;
                        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                            const nidx = ny * gridWidth + nx;
                            grid[nidx] = Math.max(grid[nidx], source.temp * 0.8);
                        }
                    }
                }
            });

            for (let x = 0; x < gridWidth; x++) {
                grid[x] = 0;
                grid[(gridHeight - 1) * gridWidth + x] = 0;
            }

            for (let y = 0; y < gridHeight; y++) {
                grid[y * gridWidth] = 0;
                grid[y * gridWidth + gridWidth - 1] = 0;
            }
        }

        function tempToColor(temp) {
            temp = Math.max(0, Math.min(1, temp));

            let r, g, b;

            if (temp < 0.25) {
                const t = temp / 0.25;
                r = 0;
                g = 0;
                b = Math.floor(t * 255);
            } else if (temp < 0.5) {
                const t = (temp - 0.25) / 0.25;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (temp < 0.75) {
                const t = (temp - 0.5) / 0.25;
                r = Math.floor(t * 255);
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else {
                const t = (temp - 0.75) / 0.25;
                r = 255;
                g = Math.floor((1 - t) * 255);
                b = 0;
            }

            return [r, g, b];
        }

        function draw() {
            const imageData = ctx.createImageData(gridWidth, gridHeight);

            for (let i = 0; i < gridWidth * gridHeight; i++) {
                const [r, g, b] = tempToColor(grid[i]);

                imageData.data[i * 4] = r;
                imageData.data[i * 4 + 1] = g;
                imageData.data[i * 4 + 2] = b;
                imageData.data[i * 4 + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, gridWidth, gridHeight, 0, 0, canvas.width, canvas.height);

            sources.forEach(source => {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(source.x * 4, source.y * 4, 12, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        let mouseX = -1;
        let mouseY = -1;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = Math.floor((e.clientX - rect.left) / 4);
            mouseY = Math.floor((e.clientY - rect.top) / 4);
        });

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);

        function animate() {
            for (let i = 0; i < 5; i++) {
                diffuse();
            }

            if (mouseDown && mouseX >= 0 && mouseX < gridWidth && mouseY >= 0 && mouseY < gridHeight) {
                for (let dy = -5; dy <= 5; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        const nx = mouseX + dx;
                        const ny = mouseY + dy;
                        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                            const idx = ny * gridWidth + nx;
                            grid[idx] = Math.max(grid[idx], 1);
                        }
                    }
                }
            }

            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
