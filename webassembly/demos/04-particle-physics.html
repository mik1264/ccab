<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Physics Engine - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #333;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1000;
        const height = canvas.height = 700;

        const PARTICLE_COUNT = 2000;
        const memory = new WebAssembly.Memory({ initial: 20 });
        const mem = new Float32Array(memory.buffer);

        // Memory layout: [x, y, vx, vy, r, g, b, life] per particle
        const STRIDE = 8;

        // Initialize particles
        function initParticles() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * STRIDE;
                mem[idx] = width / 2;
                mem[idx + 1] = height / 2;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                mem[idx + 2] = Math.cos(angle) * speed;
                mem[idx + 3] = Math.sin(angle) * speed;
                mem[idx + 4] = Math.random();
                mem[idx + 5] = Math.random();
                mem[idx + 6] = Math.random();
                mem[idx + 7] = 1;
            }
        }

        // WebAssembly physics update
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x01, 0x60,
            0x03, 0x7f, 0x7f, 0x7f, 0x00, 0x03, 0x02, 0x01, 0x00, 0x05, 0x03, 0x01,
            0x00, 0x14, 0x07, 0x0a, 0x01, 0x06, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
            0x00, 0x00, 0x0a, 0x70, 0x01, 0x6e, 0x01, 0x01, 0x7f, 0x41, 0x00, 0x21,
            0x03, 0x03, 0x40, 0x20, 0x03, 0x20, 0x00, 0x4e, 0x04, 0x40, 0x0f, 0x0b,
            0x20, 0x03, 0x41, 0x08, 0x6c, 0x41, 0x02, 0x74, 0x21, 0x04, 0x20, 0x04,
            0x20, 0x04, 0x28, 0x02, 0x00, 0x20, 0x04, 0x41, 0x08, 0x6a, 0x28, 0x02,
            0x00, 0xba, 0x92, 0x36, 0x02, 0x00, 0x20, 0x04, 0x41, 0x04, 0x6a, 0x20,
            0x04, 0x41, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x41, 0x0c, 0x6a,
            0x28, 0x02, 0x00, 0xba, 0x92, 0x36, 0x02, 0x00, 0x20, 0x04, 0x41, 0x0c,
            0x6a, 0x20, 0x04, 0x41, 0x0c, 0x6a, 0x28, 0x02, 0x00, 0xba, 0x43, 0xcd,
            0xcc, 0x4c, 0x3e, 0x92, 0x36, 0x02, 0x00, 0x20, 0x03, 0x41, 0x01, 0x6a,
            0x21, 0x03, 0x0c, 0x00, 0x0b, 0x0b
        ]);

        let wasm;
        let mouseX = width / 2;
        let mouseY = height / 2;
        let attracting = false;

        async function init() {
            initParticles();

            try {
                const module = await WebAssembly.instantiate(wasmCode, {
                    env: { memory }
                });
                wasm = module.instance;
            } catch (e) {
                console.log('WASM init failed, using JS fallback');
            }

            animate();
        }

        function updatePhysics() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * STRIDE;

                // Apply gravity
                mem[idx + 3] += 0.2;

                // Mouse attraction/repulsion
                if (attracting) {
                    const dx = mouseX - mem[idx];
                    const dy = mouseY - mem[idx + 1];
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        const force = 3 / (dist + 1);
                        mem[idx + 2] += dx * force * 0.1;
                        mem[idx + 3] += dy * force * 0.1;
                    }
                }

                // Update position
                mem[idx] += mem[idx + 2];
                mem[idx + 1] += mem[idx + 3];

                // Bounce off walls
                if (mem[idx] < 0 || mem[idx] > width) {
                    mem[idx + 2] *= -0.8;
                    mem[idx] = Math.max(0, Math.min(width, mem[idx]));
                }
                if (mem[idx + 1] > height) {
                    mem[idx + 3] *= -0.8;
                    mem[idx + 1] = height;
                    mem[idx + 2] *= 0.95; // Friction
                }

                // Decay life
                mem[idx + 7] *= 0.998;

                // Respawn if dead
                if (mem[idx + 7] < 0.01 || mem[idx + 1] < 0) {
                    mem[idx] = width / 2 + (Math.random() - 0.5) * 100;
                    mem[idx + 1] = height / 2 + (Math.random() - 0.5) * 100;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    mem[idx + 2] = Math.cos(angle) * speed;
                    mem[idx + 3] = Math.sin(angle) * speed;
                    mem[idx + 4] = Math.random();
                    mem[idx + 5] = Math.random();
                    mem[idx + 6] = Math.random();
                    mem[idx + 7] = 1;
                }
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(17, 17, 17, 0.15)';
            ctx.fillRect(0, 0, width, height);

            updatePhysics();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * STRIDE;
                const x = mem[idx];
                const y = mem[idx + 1];
                const life = mem[idx + 7];

                const r = Math.floor(mem[idx + 4] * 255);
                const g = Math.floor(mem[idx + 5] * 255);
                const b = Math.floor(mem[idx + 6] * 255);
                const a = life * 0.6;

                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => attracting = true);
        canvas.addEventListener('mouseup', () => attracting = false);

        init();
    </script>
</body>
</html>
