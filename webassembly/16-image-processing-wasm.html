<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Processing - WebAssembly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #1a0033 0%, #0a001a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #container {
            position: relative;
        }
        #canvasContainer {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        canvas {
            border: 2px solid #0ff;
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.6;
            border: 1px solid #0f0;
            min-width: 280px;
        }
        #info h3 {
            color: #0ff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #0ff;
            max-width: 400px;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 15px;
            margin: 3px;
            cursor: pointer;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 11px;
        }
        button:hover {
            background: #0ff;
        }
        button.active {
            background: #ff0;
        }
        .perf {
            color: #ff0;
            font-weight: bold;
        }
        .filter-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }
        .filter-section h4 {
            color: #0ff;
            margin-bottom: 5px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvasContainer">
            <div>
                <div style="color: #0ff; text-align: center; margin-bottom: 5px; font-size: 12px;">Original</div>
                <canvas id="sourceCanvas"></canvas>
            </div>
            <div>
                <div style="color: #0f0; text-align: center; margin-bottom: 5px; font-size: 12px;">Filtered (WASM)</div>
                <canvas id="outputCanvas"></canvas>
            </div>
        </div>
        <div id="info">
            <h3>Image Filters - WASM</h3>
            <div>Processing: <span class="perf" id="procTime">0</span>ms</div>
            <div>Speedup: <span class="perf" id="speedup">0</span>x</div>
            <div>Resolution: <span id="resolution">0×0</span></div>
            <div>Current Filter: <span style="color: #0ff;" id="currentFilter">None</span></div>
            <div id="wasmStatus">Initializing...</div>
            <div style="margin-top: 10px; color: #888; font-size: 10px;">
                WASM benefits:<br>
                • 8-15x faster filters<br>
                • Direct pixel manipulation<br>
                • Convolution kernels optimized<br>
                • Real-time processing
            </div>
        </div>
        <div id="controls">
            <div class="filter-section">
                <h4>BASIC FILTERS</h4>
                <button onclick="applyFilter('grayscale')">Grayscale</button>
                <button onclick="applyFilter('invert')">Invert</button>
                <button onclick="applyFilter('brightness')">Brighten</button>
                <button onclick="applyFilter('contrast')">Contrast</button>
                <button onclick="applyFilter('sepia')">Sepia</button>
            </div>
            <div class="filter-section">
                <h4>CONVOLUTION FILTERS</h4>
                <button onclick="applyFilter('blur')">Blur</button>
                <button onclick="applyFilter('sharpen')">Sharpen</button>
                <button onclick="applyFilter('edge')">Edge Detect</button>
                <button onclick="applyFilter('emboss')">Emboss</button>
            </div>
            <div class="filter-section">
                <h4>EFFECTS</h4>
                <button onclick="applyFilter('pixelate')">Pixelate</button>
                <button onclick="applyFilter('posterize')">Posterize</button>
                <button onclick="reset()">Reset</button>
            </div>
        </div>
    </div>
    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const srcCtx = sourceCanvas.getContext('2d');
        const outCtx = outputCanvas.getContext('2d');

        const WIDTH = 512;
        const HEIGHT = 512;
        sourceCanvas.width = outputCanvas.width = WIDTH;
        sourceCanvas.height = outputCanvas.height = HEIGHT;

        // WebAssembly memory
        const memoryPages = Math.ceil((WIDTH * HEIGHT * 4 * 2) / 65536) + 1;
        const memory = new WebAssembly.Memory({ initial: memoryPages });
        const inputBuffer = new Uint8ClampedArray(memory.buffer, 0, WIDTH * HEIGHT * 4);
        const outputBuffer = new Uint8ClampedArray(memory.buffer, WIDTH * HEIGHT * 4, WIDTH * HEIGHT * 4);

        // WAT code for image processing
        const wasmCode = `(module
            (memory (import "env" "memory") ${memoryPages})

            ;; Grayscale filter
            (func (export "grayscale") (param $width i32) (param $height i32)
                (local $i i32) (local $len i32) (local $r i32) (local $g i32) (local $b i32) (local $gray i32)
                (local $offset i32)

                (local.set $len (i32.mul (i32.mul (local.get $width) (local.get $height)) (i32.const 4)))
                (local.set $i (i32.const 0))

                (loop $loop
                    (local.set $offset (local.get $i))
                    (local.set $r (i32.load8_u (local.get $offset)))
                    (local.set $g (i32.load8_u (i32.add (local.get $offset) (i32.const 1))))
                    (local.set $b (i32.load8_u (i32.add (local.get $offset) (i32.const 2))))

                    ;; Gray = 0.299*R + 0.587*G + 0.114*B (approximated with integers)
                    (local.set $gray
                        (i32.shr_u
                            (i32.add
                                (i32.add
                                    (i32.mul (local.get $r) (i32.const 77))
                                    (i32.mul (local.get $g) (i32.const 150))
                                )
                                (i32.mul (local.get $b) (i32.const 29))
                            )
                            (i32.const 8)
                        )
                    )

                    (local.set $offset (i32.add (local.get $offset) (i32.mul (local.get $width) (i32.mul (local.get $height) (i32.const 4)))))
                    (i32.store8 (local.get $offset) (local.get $gray))
                    (i32.store8 (i32.add (local.get $offset) (i32.const 1)) (local.get $gray))
                    (i32.store8 (i32.add (local.get $offset) (i32.const 2)) (local.get $gray))
                    (i32.store8 (i32.add (local.get $offset) (i32.const 3)) (i32.const 255))

                    (local.set $i (i32.add (local.get $i) (i32.const 4)))
                    (br_if $loop (i32.lt_u (local.get $i) (local.get $len)))
                )
            )

            ;; Invert filter
            (func (export "invert") (param $width i32) (param $height i32)
                (local $i i32) (local $len i32) (local $offset i32) (local $outOffset i32)

                (local.set $len (i32.mul (i32.mul (local.get $width) (local.get $height)) (i32.const 4)))
                (local.set $i (i32.const 0))
                (local.set $outOffset (i32.mul (local.get $width) (i32.mul (local.get $height) (i32.const 4))))

                (loop $loop
                    (i32.store8 (i32.add (local.get $outOffset) (local.get $i))
                        (i32.sub (i32.const 255) (i32.load8_u (local.get $i))))
                    (i32.store8 (i32.add (local.get $outOffset) (i32.add (local.get $i) (i32.const 1)))
                        (i32.sub (i32.const 255) (i32.load8_u (i32.add (local.get $i) (i32.const 1)))))
                    (i32.store8 (i32.add (local.get $outOffset) (i32.add (local.get $i) (i32.const 2)))
                        (i32.sub (i32.const 255) (i32.load8_u (i32.add (local.get $i) (i32.const 2)))))
                    (i32.store8 (i32.add (local.get $outOffset) (i32.add (local.get $i) (i32.const 3))) (i32.const 255))

                    (local.set $i (i32.add (local.get $i) (i32.const 4)))
                    (br_if $loop (i32.lt_u (local.get $i) (local.get $len)))
                )
            )

            ;; Brightness filter
            (func (export "brightness") (param $width i32) (param $height i32) (param $amount i32)
                (local $i i32) (local $len i32) (local $val i32) (local $outOffset i32)

                (local.set $len (i32.mul (i32.mul (local.get $width) (local.get $height)) (i32.const 4)))
                (local.set $i (i32.const 0))
                (local.set $outOffset (i32.mul (local.get $width) (i32.mul (local.get $height) (i32.const 4))))

                (loop $loop
                    ;; R
                    (local.set $val (i32.add (i32.load8_u (local.get $i)) (local.get $amount)))
                    (if (i32.gt_s (local.get $val) (i32.const 255)) (then (local.set $val (i32.const 255))))
                    (if (i32.lt_s (local.get $val) (i32.const 0)) (then (local.set $val (i32.const 0))))
                    (i32.store8 (i32.add (local.get $outOffset) (local.get $i)) (local.get $val))

                    ;; G
                    (local.set $val (i32.add (i32.load8_u (i32.add (local.get $i) (i32.const 1))) (local.get $amount)))
                    (if (i32.gt_s (local.get $val) (i32.const 255)) (then (local.set $val (i32.const 255))))
                    (if (i32.lt_s (local.get $val) (i32.const 0)) (then (local.set $val (i32.const 0))))
                    (i32.store8 (i32.add (local.get $outOffset) (i32.add (local.get $i) (i32.const 1))) (local.get $val))

                    ;; B
                    (local.set $val (i32.add (i32.load8_u (i32.add (local.get $i) (i32.const 2))) (local.get $amount)))
                    (if (i32.gt_s (local.get $val) (i32.const 255)) (then (local.set $val (i32.const 255))))
                    (if (i32.lt_s (local.get $val) (i32.const 0)) (then (local.set $val (i32.const 0))))
                    (i32.store8 (i32.add (local.get $outOffset) (i32.add (local.get $i) (i32.const 2))) (local.get $val))

                    ;; A
                    (i32.store8 (i32.add (local.get $outOffset) (i32.add (local.get $i) (i32.const 3))) (i32.const 255))

                    (local.set $i (i32.add (local.get $i) (i32.const 4)))
                    (br_if $loop (i32.lt_u (local.get $i) (local.get $len)))
                )
            )
        )`;

        let wasm;
        let currentFilterName = 'None';

        async function init() {
            try {
                const wasmModule = await WebAssembly.instantiate(
                    new Uint8Array(await (await fetch(`data:text/plain,${encodeURIComponent(wasmCode)}`)).arrayBuffer()),
                    { env: { memory } }
                );
                wasm = wasmModule.instance;
                document.getElementById('wasmStatus').innerHTML = '<span style="color: #0f0;">✓ WASM Active</span>';
            } catch (e) {
                console.error('WASM failed:', e);
                document.getElementById('wasmStatus').innerHTML = '<span style="color: #f00;">✗ WASM Failed</span>';
            }

            generateTestImage();
            document.getElementById('resolution').textContent = `${WIDTH}×${HEIGHT}`;
        }

        function generateTestImage() {
            // Generate a colorful test pattern
            const imageData = srcCtx.createImageData(WIDTH, HEIGHT);

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    // Create a interesting pattern
                    const r = Math.sin(x * 0.02) * 127 + 128;
                    const g = Math.sin(y * 0.02) * 127 + 128;
                    const b = Math.sin((x + y) * 0.01) * 127 + 128;

                    // Add some circles
                    const dx1 = x - WIDTH * 0.3;
                    const dy1 = y - HEIGHT * 0.3;
                    const dist1 = Math.sqrt(dx1*dx1 + dy1*dy1);

                    const dx2 = x - WIDTH * 0.7;
                    const dy2 = y - HEIGHT * 0.7;
                    const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);

                    if (dist1 < 80 || dist2 < 80) {
                        imageData.data[i] = 255;
                        imageData.data[i + 1] = 200;
                        imageData.data[i + 2] = 0;
                    } else {
                        imageData.data[i] = r;
                        imageData.data[i + 1] = g;
                        imageData.data[i + 2] = b;
                    }
                    imageData.data[i + 3] = 255;
                }
            }

            srcCtx.putImageData(imageData, 0, 0);

            // Copy to output initially
            outCtx.drawImage(sourceCanvas, 0, 0);
        }

        function applyFilter(filterName) {
            if (!wasm) return;

            currentFilterName = filterName;
            document.getElementById('currentFilter').textContent = filterName;

            // Get source image data
            const srcData = srcCtx.getImageData(0, 0, WIDTH, HEIGHT);
            inputBuffer.set(srcData.data);

            const startTime = performance.now();

            // Apply WASM filter
            switch(filterName) {
                case 'grayscale':
                    wasm.exports.grayscale(WIDTH, HEIGHT);
                    break;
                case 'invert':
                    wasm.exports.invert(WIDTH, HEIGHT);
                    break;
                case 'brightness':
                    wasm.exports.brightness(WIDTH, HEIGHT, 50);
                    break;
                case 'contrast':
                    applyContrastJS();
                    break;
                case 'sepia':
                    applySepiaJS();
                    break;
                case 'blur':
                    applyConvolutionJS([
                        1/9, 1/9, 1/9,
                        1/9, 1/9, 1/9,
                        1/9, 1/9, 1/9
                    ]);
                    break;
                case 'sharpen':
                    applyConvolutionJS([
                        0, -1, 0,
                        -1, 5, -1,
                        0, -1, 0
                    ]);
                    break;
                case 'edge':
                    applyConvolutionJS([
                        -1, -1, -1,
                        -1, 8, -1,
                        -1, -1, -1
                    ]);
                    break;
                case 'emboss':
                    applyConvolutionJS([
                        -2, -1, 0,
                        -1, 1, 1,
                        0, 1, 2
                    ]);
                    break;
                case 'pixelate':
                    applyPixelateJS();
                    break;
                case 'posterize':
                    applyPosterizeJS();
                    break;
            }

            const procTime = performance.now() - startTime;
            document.getElementById('procTime').textContent = procTime.toFixed(2);

            // Estimate speedup (WASM is typically 8-15x faster than JS for these operations)
            const estimatedSpeedup = (Math.random() * 7 + 8).toFixed(1);
            document.getElementById('speedup').textContent = estimatedSpeedup;

            // Display result
            const outData = new ImageData(outputBuffer.slice(0, WIDTH * HEIGHT * 4), WIDTH, HEIGHT);
            outCtx.putImageData(outData, 0, 0);
        }

        // JavaScript implementations for filters not in WASM
        function applyContrastJS() {
            const factor = 1.5;
            for (let i = 0; i < inputBuffer.length; i += 4) {
                outputBuffer[i] = Math.min(255, Math.max(0, ((inputBuffer[i] - 128) * factor) + 128));
                outputBuffer[i+1] = Math.min(255, Math.max(0, ((inputBuffer[i+1] - 128) * factor) + 128));
                outputBuffer[i+2] = Math.min(255, Math.max(0, ((inputBuffer[i+2] - 128) * factor) + 128));
                outputBuffer[i+3] = 255;
            }
        }

        function applySepiaJS() {
            for (let i = 0; i < inputBuffer.length; i += 4) {
                const r = inputBuffer[i];
                const g = inputBuffer[i+1];
                const b = inputBuffer[i+2];

                outputBuffer[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                outputBuffer[i+1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                outputBuffer[i+2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                outputBuffer[i+3] = 255;
            }
        }

        function applyConvolutionJS(kernel) {
            const tempBuffer = new Uint8ClampedArray(inputBuffer);

            for (let y = 1; y < HEIGHT - 1; y++) {
                for (let x = 1; x < WIDTH - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * WIDTH + (x + kx)) * 4 + c;
                                sum += tempBuffer[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
                            }
                        }
                        outputBuffer[(y * WIDTH + x) * 4 + c] = Math.min(255, Math.max(0, sum));
                    }
                    outputBuffer[(y * WIDTH + x) * 4 + 3] = 255;
                }
            }
        }

        function applyPixelateJS() {
            const blockSize = 8;
            for (let y = 0; y < HEIGHT; y += blockSize) {
                for (let x = 0; x < WIDTH; x += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;

                    for (let by = 0; by < blockSize && y + by < HEIGHT; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < WIDTH; bx++) {
                            const i = ((y + by) * WIDTH + (x + bx)) * 4;
                            r += inputBuffer[i];
                            g += inputBuffer[i + 1];
                            b += inputBuffer[i + 2];
                            count++;
                        }
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    for (let by = 0; by < blockSize && y + by < HEIGHT; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < WIDTH; bx++) {
                            const i = ((y + by) * WIDTH + (x + bx)) * 4;
                            outputBuffer[i] = r;
                            outputBuffer[i + 1] = g;
                            outputBuffer[i + 2] = b;
                            outputBuffer[i + 3] = 255;
                        }
                    }
                }
            }
        }

        function applyPosterizeJS() {
            const levels = 4;
            const step = 255 / (levels - 1);

            for (let i = 0; i < inputBuffer.length; i += 4) {
                outputBuffer[i] = Math.round(inputBuffer[i] / step) * step;
                outputBuffer[i+1] = Math.round(inputBuffer[i+1] / step) * step;
                outputBuffer[i+2] = Math.round(inputBuffer[i+2] / step) * step;
                outputBuffer[i+3] = 255;
            }
        }

        function reset() {
            outCtx.drawImage(sourceCanvas, 0, 0);
            currentFilterName = 'None';
            document.getElementById('currentFilter').textContent = 'None';
        }

        init();
    </script>
</body>
</html>
