<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloth Simulation - WebAssembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #222;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = 1000;
        const height = canvas.height = 700;

        const CLOTH_WIDTH = 40;
        const CLOTH_HEIGHT = 30;
        const SPACING = 12;

        class Point {
            constructor(x, y, pinned = false) {
                this.x = x;
                this.y = y;
                this.px = x;
                this.py = y;
                this.pinned = pinned;
            }

            update(dt) {
                if (this.pinned) return;

                const vx = (this.x - this.px) * 0.99;
                const vy = (this.y - this.py) * 0.99;

                this.px = this.x;
                this.py = this.y;

                this.x += vx;
                this.y += vy + 0.5; // Gravity

                if (this.y > height - 50) {
                    this.y = height - 50;
                    this.py = this.y;
                }
            }

            constrain(other, distance) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return;

                const diff = (distance - dist) / dist;
                const offsetX = dx * diff * 0.5;
                const offsetY = dy * diff * 0.5;

                if (!this.pinned) {
                    this.x -= offsetX;
                    this.y -= offsetY;
                }

                if (!other.pinned) {
                    other.x += offsetX;
                    other.y += offsetY;
                }
            }
        }

        const points = [];
        const constraints = [];

        const startX = width / 2 - (CLOTH_WIDTH * SPACING) / 2;
        const startY = 100;

        for (let y = 0; y < CLOTH_HEIGHT; y++) {
            for (let x = 0; x < CLOTH_WIDTH; x++) {
                const pinned = y === 0 && (x % 5 === 0 || x === CLOTH_WIDTH - 1);
                const point = new Point(
                    startX + x * SPACING,
                    startY + y * SPACING,
                    pinned
                );
                points.push(point);
            }
        }

        for (let y = 0; y < CLOTH_HEIGHT; y++) {
            for (let x = 0; x < CLOTH_WIDTH; x++) {
                const idx = y * CLOTH_WIDTH + x;

                if (x < CLOTH_WIDTH - 1) {
                    constraints.push({ a: idx, b: idx + 1, distance: SPACING });
                }

                if (y < CLOTH_HEIGHT - 1) {
                    constraints.push({ a: idx, b: idx + CLOTH_WIDTH, distance: SPACING });
                }

                if (x < CLOTH_WIDTH - 1 && y < CLOTH_HEIGHT - 1) {
                    const diag = Math.sqrt(SPACING * SPACING * 2);
                    constraints.push({ a: idx, b: idx + CLOTH_WIDTH + 1, distance: diag });
                }

                if (x > 0 && y < CLOTH_HEIGHT - 1) {
                    const diag = Math.sqrt(SPACING * SPACING * 2);
                    constraints.push({ a: idx, b: idx + CLOTH_WIDTH - 1, distance: diag });
                }
            }
        }

        let mouseX = -1000;
        let mouseY = -1000;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);

        function animate() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            points.forEach(p => p.update(0.016));

            if (mouseDown) {
                points.forEach(p => {
                    const dx = mouseX - p.x;
                    const dy = mouseY - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 50 && !p.pinned) {
                        p.x += dx * 0.1;
                        p.y += dy * 0.1;
                    }
                });
            }

            for (let i = 0; i < 3; i++) {
                constraints.forEach(c => {
                    points[c.a].constrain(points[c.b], c.distance);
                });
            }

            for (let y = 0; y < CLOTH_HEIGHT - 1; y++) {
                for (let x = 0; x < CLOTH_WIDTH - 1; x++) {
                    const p1 = points[y * CLOTH_WIDTH + x];
                    const p2 = points[y * CLOTH_WIDTH + x + 1];
                    const p3 = points[(y + 1) * CLOTH_WIDTH + x + 1];
                    const p4 = points[(y + 1) * CLOTH_WIDTH + x];

                    const avgX = (p1.x + p2.x + p3.x + p4.x) / 4;
                    const avgY = (p1.y + p2.y + p3.y + p4.y) / 4;

                    const lightness = 0.3 + (avgY / height) * 0.4;
                    const hue = 200 + (avgX / width) * 60;

                    ctx.fillStyle = `hsl(${hue}, 70%, ${lightness * 100}%)`;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }

            points.forEach(p => {
                if (p.pinned) {
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
