<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Flow Field - Screensaver Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a12; overflow: hidden; }
        canvas { display: block; cursor: pointer; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-family: system-ui;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px;
            font-size: 14px; transition: all 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        #info {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            color: rgba(255,255,255,0.5); font-family: monospace; font-size: 12px;
        }
        #paused {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: system-ui; font-size: 24px;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        #paused.show { opacity: 0.7; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Gallery</a>
    <div id="info">FPS: <span id="fps">0</span></div>
    <div id="paused">PAUSED</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let isPaused = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let time = 0;

        canvas.addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('paused').classList.toggle('show', isPaused);
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles();
        }
        window.addEventListener('resize', resize);

        // Simplex-like noise implementation
        class Noise {
            constructor() {
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 256; i++) {
                    this.perm[i] = this.perm[i + 256] = Math.floor(Math.random() * 256);
                }
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;
                return this.lerp(
                    this.lerp(this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y), u),
                    this.lerp(this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1), u),
                    v
                );
            }
        }

        const noise = new Noise();
        const particles = [];
        const numParticles = 2000;
        const noiseScale = 0.005;

        function initParticles() {
            particles.length = 0;
            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0,
                    life: Math.random() * 500 + 100
                });
            }
        }

        resize();

        function render() {
            if (!isPaused) {
                time += 0.016;
            }

            ctx.fillStyle = 'rgba(10, 10, 18, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!isPaused) {
                particles.forEach((p, i) => {
                    // Get flow field angle from noise
                    const angle = noise.noise2D(p.x * noiseScale, p.y * noiseScale + time * 0.1) * Math.PI * 4;

                    p.vx += Math.cos(angle) * 0.5;
                    p.vy += Math.sin(angle) * 0.5;

                    // Damping
                    p.vx *= 0.95;
                    p.vy *= 0.95;

                    // Limit speed
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    if (speed > 4) {
                        p.vx = (p.vx / speed) * 4;
                        p.vy = (p.vy / speed) * 4;
                    }

                    p.x += p.vx;
                    p.y += p.vy;

                    p.life--;

                    // Wrap around
                    if (p.x < 0) p.x = canvas.width;
                    if (p.x > canvas.width) p.x = 0;
                    if (p.y < 0) p.y = canvas.height;
                    if (p.y > canvas.height) p.y = 0;

                    // Respawn dead particles
                    if (p.life <= 0) {
                        p.x = Math.random() * canvas.width;
                        p.y = Math.random() * canvas.height;
                        p.vx = 0;
                        p.vy = 0;
                        p.life = Math.random() * 500 + 100;
                    }
                });
            }

            // Draw particles
            particles.forEach((p, i) => {
                const hue = (time * 20 + p.x * 0.1 + p.y * 0.1) % 360;
                const alpha = Math.min(1, p.life / 100);
                ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }

            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
