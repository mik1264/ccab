<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Swarm - Screensaver Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #08080c; overflow: hidden; }
        canvas { display: block; cursor: pointer; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-family: system-ui;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px;
            font-size: 14px; transition: all 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        #info {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            color: rgba(255,255,255,0.5); font-family: monospace; font-size: 12px;
        }
        #paused {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: system-ui; font-size: 24px;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        #paused.show { opacity: 0.7; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Gallery</a>
    <div id="info">FPS: <span id="fps">0</span></div>
    <div id="paused">PAUSED</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let isPaused = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let time = 0;

        canvas.addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('paused').classList.toggle('show', isPaused);
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initSwarm();
        }
        window.addEventListener('resize', resize);

        const particles = [];
        const numParticles = 200;
        let globalBest = { x: 0, y: 0, fitness: Infinity };
        let targetX, targetY;

        // Moving target
        function updateTarget() {
            targetX = canvas.width / 2 + Math.sin(time * 0.3) * canvas.width * 0.3;
            targetY = canvas.height / 2 + Math.cos(time * 0.2) * canvas.height * 0.3;
        }

        function fitness(x, y) {
            return Math.sqrt((x - targetX) ** 2 + (y - targetY) ** 2);
        }

        function initSwarm() {
            particles.length = 0;
            for (let i = 0; i < numParticles; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    bestX: x,
                    bestY: y,
                    bestFitness: Infinity,
                    trail: [],
                    hue: Math.random() * 60 + 180
                });
            }
            globalBest = { x: canvas.width / 2, y: canvas.height / 2, fitness: Infinity };
        }

        resize();

        // PSO parameters
        const w = 0.5;  // Inertia
        const c1 = 1.5; // Cognitive
        const c2 = 1.5; // Social

        function render() {
            if (!isPaused) {
                time += 0.016;
                updateTarget();

                particles.forEach(p => {
                    // Update velocity
                    const r1 = Math.random();
                    const r2 = Math.random();

                    p.vx = w * p.vx
                         + c1 * r1 * (p.bestX - p.x)
                         + c2 * r2 * (globalBest.x - p.x);
                    p.vy = w * p.vy
                         + c1 * r1 * (p.bestY - p.y)
                         + c2 * r2 * (globalBest.y - p.y);

                    // Limit speed
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    const maxSpeed = 8;
                    if (speed > maxSpeed) {
                        p.vx = (p.vx / speed) * maxSpeed;
                        p.vy = (p.vy / speed) * maxSpeed;
                    }

                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;

                    // Bounce off walls
                    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                    p.x = Math.max(0, Math.min(canvas.width, p.x));
                    p.y = Math.max(0, Math.min(canvas.height, p.y));

                    // Evaluate fitness
                    const f = fitness(p.x, p.y);
                    if (f < p.bestFitness) {
                        p.bestFitness = f;
                        p.bestX = p.x;
                        p.bestY = p.y;
                    }
                    if (f < globalBest.fitness) {
                        globalBest.fitness = f;
                        globalBest.x = p.x;
                        globalBest.y = p.y;
                    }

                    // Trail
                    p.trail.push({ x: p.x, y: p.y });
                    if (p.trail.length > 20) p.trail.shift();
                });

                // Reset global best periodically as target moves
                if (Math.floor(time * 10) % 50 === 0) {
                    globalBest.fitness = Infinity;
                }
            }

            ctx.fillStyle = 'rgba(8, 8, 12, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw target
            const gradient = ctx.createRadialGradient(targetX, targetY, 0, targetX, targetY, 50);
            gradient.addColorStop(0, 'rgba(255, 200, 50, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(targetX, targetY, 50, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(targetX, targetY, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 220, 100, 0.8)';
            ctx.fill();

            // Draw particles
            particles.forEach((p, i) => {
                // Trail
                if (p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    for (let j = 1; j < p.trail.length; j++) {
                        ctx.lineTo(p.trail[j].x, p.trail[j].y);
                    }
                    const hue = (p.hue + time * 20) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Particle
                const hue = (p.hue + time * 20) % 360;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${hue}, 80%, 65%, 0.9)`;
                ctx.fill();
            });

            // Draw connection to global best
            ctx.beginPath();
            ctx.arc(globalBest.x, globalBest.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.fill();

            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }

            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
