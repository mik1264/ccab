<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ice Sheet Dynamics</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Nunito', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 1.4rem; font-weight: 600;
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center;
}
.title-overlay .subtitle {
    font-size: 0.8rem; opacity: 0.7; margin-top: 4px; font-weight: 300;
}
.organic-back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    display: flex; align-items: center; gap: 8px;
    padding: 8px 16px; border-radius: 20px;
    background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
    color: #fff; text-decoration: none; font-size: 0.9rem;
    transition: background 0.3s;
}
.organic-back-link:hover { background: rgba(255,255,255,0.2); }
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
    padding: 12px 24px; border-radius: 20px; color: #fff; font-size: 0.85rem;
}
.controls label { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.controls input[type="range"] { width: 110px; }
.info-panel {
    position: fixed; top: 80px; right: 20px; z-index: 10;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(10px);
    padding: 12px 16px; border-radius: 12px; color: #fff; font-size: 0.75rem;
    line-height: 1.6;
}
</style>
</head>
<body>
<a href="../index.html" class="organic-back-link">
    <span class="back-arrow">&larr;</span>
    <span class="back-text">Gallery</span>
</a>
<div class="title-overlay">
    Ice Sheet Dynamics
    <div class="subtitle">Glacial flow, snowfall accumulation, and iceberg calving</div>
</div>
<div class="info-panel">
    <div>Temperature: <span id="tempDisplay">-15</span>&deg;C</div>
    <div>Ice Volume: <span id="iceVol">0</span>%</div>
    <div>Icebergs: <span id="bergCount">0</span></div>
    <div>Snowfall Rate: <span id="snowRate">0</span></div>
</div>
<div class="controls">
    <label>Temperature: <input type="range" id="tempSlider" min="-30" max="10" step="1" value="-10"> <span id="tempVal">-10</span>&deg;C</label>
    <label>Snowfall: <input type="range" id="snowSlider" min="0.2" max="3" step="0.1" value="1"> <span id="snowVal">1.0</span></label>
    <label>Gravity: <input type="range" id="gravSlider" min="0.5" max="3" step="0.1" value="1"> <span id="gravVal">1.0</span></label>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    initTerrain();
}

// Terrain profile - mountain/continent shape
const COLS = 200;
let terrain = [];
let iceThickness = [];

function initTerrain() {
    terrain = [];
    iceThickness = new Array(COLS).fill(0);
    const dx = W / COLS;
    for (let i = 0; i < COLS; i++) {
        const x = i / COLS;
        // Mountain/plateau shape
        let h = 0;
        h += Math.sin(x * Math.PI) * 0.4; // Main dome
        h += Math.sin(x * Math.PI * 2.5) * 0.05; // Small variation
        h += Math.sin(x * Math.PI * 7) * 0.02; // Roughness
        // Steep coast on right side
        if (x > 0.85) {
            h *= 1 - ((x - 0.85) / 0.15) * 0.8;
        }
        // Lower on left
        if (x < 0.1) {
            h *= x / 0.1;
        }
        terrain.push(h);
        iceThickness[i] = h > 0.05 ? 30 + h * 80 : 0;
    }
}

resize();
window.addEventListener('resize', resize);

// Snowflakes
const snowflakes = [];
const MAX_SNOW = 300;

class Snowflake {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = Math.random() * W;
        this.y = -10;
        this.vy = 0.5 + Math.random() * 1.5;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.size = 1 + Math.random() * 2;
        this.wobble = Math.random() * Math.PI * 2;
    }
    update(snowRate) {
        this.wobble += 0.05;
        this.x += this.vx + Math.sin(this.wobble) * 0.3;
        this.y += this.vy * snowRate;

        const col = Math.floor((this.x / W) * COLS);
        if (col >= 0 && col < COLS) {
            const terrainY = getTerrainY(col);
            const iceY = terrainY - iceThickness[col];
            if (this.y >= iceY) {
                // Accumulate ice
                iceThickness[col] = Math.min(iceThickness[col] + 0.05 * snowRate, 200);
                this.reset();
                return;
            }
        }
        if (this.y > H || this.x < -10 || this.x > W + 10) {
            this.reset();
        }
    }
    draw() {
        ctx.fillStyle = 'rgba(220, 230, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

for (let i = 0; i < MAX_SNOW; i++) {
    snowflakes.push(new Snowflake());
}

// Icebergs
const icebergs = [];

class Iceberg {
    constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.vx = 0.5 + Math.random() * 1;
        this.vy = 0;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.02;
        this.life = 1;
        this.vertices = [];
        // Random polygon shape
        const numVerts = 5 + Math.floor(Math.random() * 4);
        for (let i = 0; i < numVerts; i++) {
            const angle = (i / numVerts) * Math.PI * 2;
            const r = this.size * (0.5 + Math.random() * 0.5);
            this.vertices.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
        }
    }
    update(temp) {
        this.vy += 0.02; // gravity
        // Buoyancy in water
        const waterLevel = H * 0.75;
        if (this.y > waterLevel) {
            this.vy -= 0.04;
            this.vx *= 0.99;
        }
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotSpeed;

        // Melt rate based on temperature
        const meltRate = temp > 0 ? temp * 0.002 : Math.max(0, (temp + 5) * 0.0005);
        this.life -= meltRate;
        this.size *= (1 - meltRate * 0.01);

        if (this.life <= 0 || this.x > W + 50 || this.size < 2) return false;
        return true;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = `rgba(180, 210, 240, ${this.life * 0.8})`;
        ctx.strokeStyle = `rgba(200, 230, 255, ${this.life * 0.5})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) {
            ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
}

function getTerrainY(col) {
    if (col < 0 || col >= COLS) return H * 0.75;
    return H * 0.75 - terrain[col] * H * 0.4;
}

function drawOcean() {
    const waterLevel = H * 0.75;
    const grad = ctx.createLinearGradient(0, waterLevel, 0, H);
    grad.addColorStop(0, 'rgba(20, 50, 100, 0.7)');
    grad.addColorStop(1, 'rgba(10, 25, 50, 0.9)');
    ctx.fillStyle = grad;
    ctx.fillRect(W * 0.82, waterLevel, W * 0.18, H - waterLevel);

    // Water surface shimmer
    const time = Date.now() * 0.001;
    ctx.strokeStyle = 'rgba(100, 160, 220, 0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = W * 0.82; x < W; x += 3) {
        const y = waterLevel + Math.sin(x * 0.03 + time) * 2;
        if (x === Math.ceil(W * 0.82)) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
}

function drawTerrain() {
    const dx = W / COLS;

    // Rock/ground
    ctx.fillStyle = '#3a3020';
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let i = 0; i < COLS; i++) {
        ctx.lineTo(i * dx, getTerrainY(i));
    }
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();

    // Terrain texture
    ctx.strokeStyle = 'rgba(60, 50, 30, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < COLS; i++) {
        ctx.moveTo(i * dx, getTerrainY(i));
        ctx.lineTo(i * dx, getTerrainY(i) + 5);
    }
    ctx.stroke();
}

function drawIce(temp) {
    const dx = W / COLS;

    // Ice body with gradient
    ctx.beginPath();
    for (let i = 0; i < COLS; i++) {
        const terrainY = getTerrainY(i);
        const iceY = terrainY - iceThickness[i];
        if (i === 0) ctx.moveTo(i * dx, terrainY);
        ctx.lineTo(i * dx, iceY);
    }
    // Close along terrain
    for (let i = COLS - 1; i >= 0; i--) {
        ctx.lineTo(i * dx, getTerrainY(i));
    }
    ctx.closePath();

    const grad = ctx.createLinearGradient(0, H * 0.2, 0, H * 0.75);
    grad.addColorStop(0, 'rgba(200, 220, 255, 0.9)');
    grad.addColorStop(0.3, 'rgba(160, 195, 235, 0.85)');
    grad.addColorStop(0.7, 'rgba(130, 170, 220, 0.8)');
    grad.addColorStop(1, 'rgba(100, 150, 200, 0.75)');
    ctx.fillStyle = grad;
    ctx.fill();

    // Ice surface highlight
    ctx.strokeStyle = 'rgba(230, 240, 255, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < COLS; i++) {
        const terrainY = getTerrainY(i);
        const iceY = terrainY - iceThickness[i];
        if (i === 0) ctx.moveTo(i * dx, iceY);
        else ctx.lineTo(i * dx, iceY);
    }
    ctx.stroke();

    // Crevasses
    ctx.strokeStyle = 'rgba(60, 100, 160, 0.3)';
    ctx.lineWidth = 1;
    for (let i = 10; i < COLS - 10; i += 15) {
        if (iceThickness[i] > 20) {
            const terrainY = getTerrainY(i);
            const iceY = terrainY - iceThickness[i];
            ctx.beginPath();
            ctx.moveTo(i * dx, iceY);
            ctx.lineTo(i * dx + 3, iceY + iceThickness[i] * 0.3);
            ctx.stroke();
        }
    }
}

function updateIce(temp, gravity, snowRate) {
    // Glacial flow: ice flows downhill
    for (let i = 1; i < COLS - 1; i++) {
        const slope = terrain[i - 1] - terrain[i + 1];
        const flow = slope * gravity * 0.02 * (iceThickness[i] / 100);

        if (flow > 0 && iceThickness[i] > 1) {
            const transfer = Math.min(iceThickness[i] * 0.01 * gravity, iceThickness[i]);
            iceThickness[i] -= transfer;
            if (i + 1 < COLS) iceThickness[i + 1] += transfer * 0.95;
        } else if (flow < 0 && iceThickness[i] > 1) {
            const transfer = Math.min(iceThickness[i] * 0.01 * gravity, iceThickness[i]);
            iceThickness[i] -= transfer;
            if (i - 1 >= 0) iceThickness[i - 1] += transfer * 0.95;
        }
    }

    // Spreading under own weight
    for (let i = 1; i < COLS - 1; i++) {
        if (iceThickness[i] > 50) {
            const spread = (iceThickness[i] - 50) * 0.001 * gravity;
            iceThickness[i] -= spread * 2;
            iceThickness[i - 1] += spread;
            iceThickness[i + 1] += spread;
        }
    }

    // Melting
    const meltRate = temp > 0 ? temp * 0.05 : Math.max(0, (temp + 5) * 0.005);
    for (let i = 0; i < COLS; i++) {
        iceThickness[i] = Math.max(0, iceThickness[i] - meltRate);
    }

    // Calving at coast (right edge where terrain drops to sea level)
    const coastCol = Math.floor(COLS * 0.85);
    for (let i = coastCol; i < COLS; i++) {
        if (iceThickness[i] > 15 && Math.random() < 0.005 * gravity) {
            const dx = W / COLS;
            const bergSize = 5 + iceThickness[i] * 0.2;
            icebergs.push(new Iceberg(
                i * dx,
                getTerrainY(i) - iceThickness[i] * 0.5,
                bergSize
            ));
            iceThickness[i] *= 0.5;
        }
    }
}

function drawSky(temp) {
    const grad = ctx.createLinearGradient(0, 0, 0, H * 0.5);
    if (temp < -10) {
        grad.addColorStop(0, '#050818');
        grad.addColorStop(1, '#0a1530');
    } else if (temp < 0) {
        grad.addColorStop(0, '#081020');
        grad.addColorStop(1, '#102040');
    } else {
        grad.addColorStop(0, '#102030');
        grad.addColorStop(1, '#1a3050');
    }
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
}

function drawFlowArrows() {
    const dx = W / COLS;
    ctx.fillStyle = 'rgba(100, 180, 255, 0.15)';
    for (let i = 20; i < COLS - 20; i += 25) {
        if (iceThickness[i] > 20 && i + 1 < COLS) {
            const slope = terrain[i] - terrain[Math.min(i + 5, COLS - 1)];
            if (Math.abs(slope) > 0.01) {
                const terrainY = getTerrainY(i);
                const midY = terrainY - iceThickness[i] * 0.5;
                const dir = slope > 0 ? 1 : -1;
                ctx.save();
                ctx.translate(i * dx, midY);
                ctx.scale(dir, 1);
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(-4, -5);
                ctx.lineTo(-4, 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
    }
}

let time = 0;

function animate() {
    const temp = parseInt(document.getElementById('tempSlider').value);
    const snowRate = parseFloat(document.getElementById('snowSlider').value);
    const gravity = parseFloat(document.getElementById('gravSlider').value);
    document.getElementById('tempVal').textContent = temp;
    document.getElementById('snowVal').textContent = snowRate.toFixed(1);
    document.getElementById('gravVal').textContent = gravity.toFixed(1);

    drawSky(temp);
    drawOcean();
    updateIce(temp, gravity, snowRate);
    drawTerrain();
    drawIce(temp);
    drawFlowArrows();

    // Snow
    if (temp < 5) {
        for (const s of snowflakes) {
            s.update(snowRate);
            s.draw();
        }
    }

    // Icebergs
    for (let i = icebergs.length - 1; i >= 0; i--) {
        if (!icebergs[i].update(temp)) {
            icebergs.splice(i, 1);
        } else {
            icebergs[i].draw();
        }
    }

    // Info
    let totalIce = 0;
    for (let i = 0; i < COLS; i++) totalIce += iceThickness[i];
    const maxIce = COLS * 200;
    document.getElementById('tempDisplay').textContent = temp;
    document.getElementById('iceVol').textContent = ((totalIce / maxIce) * 100).toFixed(1);
    document.getElementById('bergCount').textContent = icebergs.length;
    document.getElementById('snowRate').textContent = (temp < 5 ? snowRate : 0).toFixed(1);

    time += 0.016;
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
