<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Percolation Simulation - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"],
        select {
            width: 100px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .info-box p {
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .percolates-yes {
            color: #4ade80;
            font-weight: bold;
        }

        .percolates-no {
            color: #f87171;
            font-weight: bold;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            input[type="range"] {
                width: 150px;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Percolation Theory</h1>
        <p class="subtitle">Phase Transitions, Critical Phenomena, and Cluster Formation</p>

        <div class="tabs">
            <div class="tab active" data-view="site">Site Percolation</div>
            <div class="tab" data-view="bond">Bond Percolation</div>
            <div class="tab" data-view="critical">Critical Sweep</div>
            <div class="tab" data-view="cluster">Cluster Analysis</div>
        </div>

        <!-- Site Percolation View -->
        <div class="view active" id="site">
            <div class="info-box">
                <h3>Site Percolation</h3>
                <p>In site percolation, each site on a grid is independently occupied with probability p. Two occupied sites are considered connected if they are adjacent (horizontally or vertically). As p increases, small isolated clusters merge into larger ones. At the critical threshold p<sub>c</sub> ≈ 0.593 for the 2D square lattice, a giant cluster emerges that spans the entire system.</p>
                <p><strong>Applications:</strong> Forest fire spread, disease transmission, porous media flow, network connectivity.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="siteProbability">Probability p: <span id="siteProbVal">0.59</span></label>
                    <input type="range" id="siteProbability" min="0" max="1" step="0.01" value="0.59">
                </div>
                <div class="control-group">
                    <label for="siteGridSize">Grid Size:</label>
                    <select id="siteGridSize">
                        <option value="50">50x50</option>
                        <option value="100" selected>100x100</option>
                        <option value="150">150x150</option>
                        <option value="200">200x200</option>
                    </select>
                </div>
                <button onclick="generateSitePercolation()">Generate</button>
                <button onclick="setSiteProbability(0.593)" class="secondary">p<sub>c</sub> ≈ 0.593</button>
            </div>

            <canvas id="siteCanvas"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #1f2937;"></div>
                    <span>Empty</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #6b7280;"></div>
                    <span>Occupied</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fbbf24;"></div>
                    <span>Spanning Cluster</span>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="siteProbability">0.59</div>
                        <div class="stat-label">Probability (p)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="siteOccupied">0</div>
                        <div class="stat-label">Occupied Sites</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="siteLargestCluster">0</div>
                        <div class="stat-label">Largest Cluster</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sitePercolates">-</div>
                        <div class="stat-label">Percolates?</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bond Percolation View -->
        <div class="view" id="bond">
            <div class="info-box">
                <h3>Bond Percolation</h3>
                <p>In bond percolation, every site is present, but connections (bonds) between adjacent sites exist with probability p. Two sites are in the same cluster if they are connected by a path of open bonds. For the 2D square lattice, the critical threshold is exactly p<sub>c</sub> = 0.5, a remarkable result proven analytically.</p>
                <p><strong>Applications:</strong> Network reliability, electrical conductivity, polymer gelation.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="bondProbability">Probability p: <span id="bondProbVal">0.50</span></label>
                    <input type="range" id="bondProbability" min="0" max="1" step="0.01" value="0.50">
                </div>
                <div class="control-group">
                    <label for="bondGridSize">Grid Size:</label>
                    <select id="bondGridSize">
                        <option value="50">50x50</option>
                        <option value="100" selected>100x100</option>
                        <option value="150">150x150</option>
                        <option value="200">200x200</option>
                    </select>
                </div>
                <button onclick="generateBondPercolation()">Generate</button>
                <button onclick="setBondProbability(0.5)" class="secondary">p<sub>c</sub> = 0.5</button>
            </div>

            <canvas id="bondCanvas"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #1f2937;"></div>
                    <span>Closed Bond</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #6b7280;"></div>
                    <span>Open Bond</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fbbf24;"></div>
                    <span>Spanning Path</span>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="bondProbabilityVal">0.50</div>
                        <div class="stat-label">Probability (p)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="bondOpen">0</div>
                        <div class="stat-label">Open Bonds</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="bondLargestCluster">0</div>
                        <div class="stat-label">Largest Cluster</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="bondPercolates">-</div>
                        <div class="stat-label">Percolates?</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Critical Sweep View -->
        <div class="view" id="critical">
            <div class="info-box">
                <h3>Critical Threshold Analysis</h3>
                <p>The percolation threshold marks a dramatic phase transition. Below p<sub>c</sub>, only small finite clusters exist. Above p<sub>c</sub>, an infinite spanning cluster appears with probability 1 (in the infinite lattice limit). At exactly p<sub>c</sub>, the system exhibits scale-invariant fractal structure and power-law behavior.</p>
                <ul>
                    <li><strong>Site Percolation:</strong> p<sub>c</sub> ≈ 0.5927 (numerical)</li>
                    <li><strong>Bond Percolation:</strong> p<sub>c</sub> = 0.5000 (exact)</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="sweepType">Type:</label>
                    <select id="sweepType">
                        <option value="site">Site Percolation</option>
                        <option value="bond" selected>Bond Percolation</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="sweepSpeed">Speed:</label>
                    <select id="sweepSpeed">
                        <option value="slow">Slow</option>
                        <option value="medium" selected>Medium</option>
                        <option value="fast">Fast</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="sweepTrials">Trials/Point:</label>
                    <select id="sweepTrials">
                        <option value="10">10</option>
                        <option value="20" selected>20</option>
                        <option value="50">50</option>
                    </select>
                </div>
                <button onclick="startCriticalSweep()">Start Sweep</button>
                <button onclick="stopCriticalSweep()" class="secondary">Stop</button>
            </div>

            <canvas id="criticalCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="sweepP">0.00</div>
                        <div class="stat-label">Current p</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sweepPercProb">0.00</div>
                        <div class="stat-label">Percolation Probability</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sweepClusterSize">0.00</div>
                        <div class="stat-label">Avg Largest Cluster</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cluster Analysis View -->
        <div class="view" id="cluster">
            <div class="info-box">
                <h3>Cluster Coloring & Analysis</h3>
                <p>Each connected component (cluster) is colored differently. The Union-Find algorithm efficiently identifies clusters in O(N α(N)) time, where α is the inverse Ackermann function (effectively constant). Near p<sub>c</sub>, you'll see a beautiful fractal distribution of cluster sizes - small clusters everywhere, with occasional large sprawling clusters.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="clusterProbability">Probability p: <span id="clusterProbVal">0.59</span></label>
                    <input type="range" id="clusterProbability" min="0" max="1" step="0.01" value="0.59">
                </div>
                <div class="control-group">
                    <label for="clusterType">Type:</label>
                    <select id="clusterType">
                        <option value="site" selected>Site</option>
                        <option value="bond">Bond</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="clusterGridSize">Grid Size:</label>
                    <select id="clusterGridSize">
                        <option value="50">50x50</option>
                        <option value="100" selected>100x100</option>
                        <option value="150">150x150</option>
                    </select>
                </div>
                <button onclick="generateClusterAnalysis()">Generate</button>
            </div>

            <canvas id="clusterCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="clusterCount">0</div>
                        <div class="stat-label">Total Clusters</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="clusterLargest">0</div>
                        <div class="stat-label">Largest Cluster</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="clusterAvgSize">0.00</div>
                        <div class="stat-label">Average Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="clusterPercolates">-</div>
                        <div class="stat-label">Percolates?</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Union-Find data structure for efficient cluster detection
        class UnionFind {
            constructor(size) {
                this.parent = Array.from({ length: size }, (_, i) => i);
                this.rank = Array(size).fill(0);
                this.size = Array(size).fill(1);
            }

            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]); // Path compression
                }
                return this.parent[x];
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);

                if (rootX === rootY) return false;

                // Union by rank
                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                    this.size[rootY] += this.size[rootX];
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                    this.size[rootX] += this.size[rootY];
                } else {
                    this.parent[rootY] = rootX;
                    this.size[rootX] += this.size[rootY];
                    this.rank[rootX]++;
                }

                return true;
            }

            getSize(x) {
                return this.size[this.find(x)];
            }

            getClusters() {
                const clusters = new Map();
                for (let i = 0; i < this.parent.length; i++) {
                    const root = this.find(i);
                    if (!clusters.has(root)) {
                        clusters.set(root, []);
                    }
                    clusters.get(root).push(i);
                }
                return Array.from(clusters.values());
            }
        }

        // Initialize canvases
        function initCanvases() {
            ['siteCanvas', 'bondCanvas', 'criticalCanvas', 'clusterCanvas'].forEach(id => {
                const canvas = document.getElementById(id);
                const size = id === 'criticalCanvas' ? 600 : 800;
                const height = id === 'criticalCanvas' ? 400 : 800;
                canvas.width = Math.min(size, window.innerWidth - 100);
                canvas.height = id === 'criticalCanvas' ? height : canvas.width;
            });
        }

        // Site Percolation
        function generateSitePercolation() {
            const p = parseFloat(document.getElementById('siteProbability').value);
            const size = parseInt(document.getElementById('siteGridSize').value);
            const canvas = document.getElementById('siteCanvas');
            const ctx = canvas.getContext('2d');

            // Generate grid
            const grid = Array(size).fill().map(() => Array(size).fill(false));
            let occupied = 0;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (Math.random() < p) {
                        grid[i][j] = true;
                        occupied++;
                    }
                }
            }

            // Find clusters using Union-Find
            const uf = new UnionFind(size * size);

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (!grid[i][j]) continue;

                    const idx = i * size + j;

                    // Check right neighbor
                    if (j + 1 < size && grid[i][j + 1]) {
                        uf.union(idx, i * size + (j + 1));
                    }

                    // Check down neighbor
                    if (i + 1 < size && grid[i + 1][j]) {
                        uf.union(idx, (i + 1) * size + j);
                    }
                }
            }

            // Check for spanning cluster (top to bottom)
            const topNodes = [];
            const bottomNodes = [];

            for (let j = 0; j < size; j++) {
                if (grid[0][j]) topNodes.push(uf.find(j));
                if (grid[size - 1][j]) bottomNodes.push(uf.find((size - 1) * size + j));
            }

            const spanningRoot = topNodes.find(t => bottomNodes.includes(t));
            const percolates = spanningRoot !== undefined;

            // Find largest cluster
            let largestSize = 0;
            for (let i = 0; i < size * size; i++) {
                if (grid[Math.floor(i / size)][i % size]) {
                    largestSize = Math.max(largestSize, uf.getSize(i));
                }
            }

            // Draw
            const cellSize = canvas.width / size;
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (grid[i][j]) {
                        const idx = i * size + j;
                        const isSpanning = percolates && uf.find(idx) === spanningRoot;

                        ctx.fillStyle = isSpanning ? '#fbbf24' : '#6b7280';
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize - 0.5, cellSize - 0.5);
                    }
                }
            }

            // Update stats
            document.getElementById('siteProbability').textContent = p.toFixed(2);
            document.getElementById('siteOccupied').textContent = occupied.toLocaleString();
            document.getElementById('siteLargestCluster').textContent = largestSize.toLocaleString();
            document.getElementById('sitePercolates').innerHTML = percolates ?
                '<span class="percolates-yes">YES</span>' :
                '<span class="percolates-no">NO</span>';
        }

        // Bond Percolation
        function generateBondPercolation() {
            const p = parseFloat(document.getElementById('bondProbability').value);
            const size = parseInt(document.getElementById('bondGridSize').value);
            const canvas = document.getElementById('bondCanvas');
            const ctx = canvas.getContext('2d');

            // Generate bonds (horizontal and vertical)
            const hBonds = Array(size).fill().map(() => Array(size - 1).fill(false));
            const vBonds = Array(size - 1).fill().map(() => Array(size).fill(false));
            let openBonds = 0;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size - 1; j++) {
                    if (Math.random() < p) {
                        hBonds[i][j] = true;
                        openBonds++;
                    }
                }
            }

            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size; j++) {
                    if (Math.random() < p) {
                        vBonds[i][j] = true;
                        openBonds++;
                    }
                }
            }

            // Find clusters using Union-Find
            const uf = new UnionFind(size * size);

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size - 1; j++) {
                    if (hBonds[i][j]) {
                        uf.union(i * size + j, i * size + (j + 1));
                    }
                }
            }

            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size; j++) {
                    if (vBonds[i][j]) {
                        uf.union(i * size + j, (i + 1) * size + j);
                    }
                }
            }

            // Check for spanning cluster
            const topNodes = Array.from({ length: size }, (_, j) => uf.find(j));
            const bottomNodes = Array.from({ length: size }, (_, j) => uf.find((size - 1) * size + j));

            const spanningRoot = topNodes.find(t => bottomNodes.includes(t));
            const percolates = spanningRoot !== undefined;

            // Find largest cluster
            let largestSize = 0;
            for (let i = 0; i < size * size; i++) {
                largestSize = Math.max(largestSize, uf.getSize(i));
            }

            // Draw
            const cellSize = canvas.width / size;
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw all sites
            ctx.fillStyle = '#4b5563';
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    ctx.beginPath();
                    ctx.arc((j + 0.5) * cellSize, (i + 0.5) * cellSize, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw horizontal bonds
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size - 1; j++) {
                    if (hBonds[i][j]) {
                        const idx1 = i * size + j;
                        const idx2 = i * size + (j + 1);
                        const isSpanning = percolates && (uf.find(idx1) === spanningRoot || uf.find(idx2) === spanningRoot);

                        ctx.strokeStyle = isSpanning ? '#fbbf24' : '#6b7280';
                        ctx.lineWidth = isSpanning ? 2 : 1;
                        ctx.beginPath();
                        ctx.moveTo((j + 0.5) * cellSize, (i + 0.5) * cellSize);
                        ctx.lineTo((j + 1.5) * cellSize, (i + 0.5) * cellSize);
                        ctx.stroke();
                    }
                }
            }

            // Draw vertical bonds
            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size; j++) {
                    if (vBonds[i][j]) {
                        const idx1 = i * size + j;
                        const idx2 = (i + 1) * size + j;
                        const isSpanning = percolates && (uf.find(idx1) === spanningRoot || uf.find(idx2) === spanningRoot);

                        ctx.strokeStyle = isSpanning ? '#fbbf24' : '#6b7280';
                        ctx.lineWidth = isSpanning ? 2 : 1;
                        ctx.beginPath();
                        ctx.moveTo((j + 0.5) * cellSize, (i + 0.5) * cellSize);
                        ctx.lineTo((j + 0.5) * cellSize, (i + 1.5) * cellSize);
                        ctx.stroke();
                    }
                }
            }

            // Update stats
            document.getElementById('bondProbabilityVal').textContent = p.toFixed(2);
            document.getElementById('bondOpen').textContent = openBonds.toLocaleString();
            document.getElementById('bondLargestCluster').textContent = largestSize.toLocaleString();
            document.getElementById('bondPercolates').innerHTML = percolates ?
                '<span class="percolates-yes">YES</span>' :
                '<span class="percolates-no">NO</span>';
        }

        // Critical Sweep
        let sweepInterval = null;
        let sweepData = [];

        function startCriticalSweep() {
            stopCriticalSweep();

            const type = document.getElementById('sweepType').value;
            const speed = document.getElementById('sweepSpeed').value;
            const trials = parseInt(document.getElementById('sweepTrials').value);

            sweepData = [];
            let currentP = 0.0;

            const delay = speed === 'slow' ? 500 : speed === 'medium' ? 200 : 100;

            sweepInterval = setInterval(() => {
                let percolationCount = 0;
                let totalLargestCluster = 0;

                // Run multiple trials
                for (let trial = 0; trial < trials; trial++) {
                    const result = simulatePercolation(type, currentP, 50);
                    if (result.percolates) percolationCount++;
                    totalLargestCluster += result.largestCluster;
                }

                const percProb = percolationCount / trials;
                const avgCluster = totalLargestCluster / trials;

                sweepData.push({ p: currentP, percProb, avgCluster });

                document.getElementById('sweepP').textContent = currentP.toFixed(3);
                document.getElementById('sweepPercProb').textContent = percProb.toFixed(3);
                document.getElementById('sweepClusterSize').textContent = avgCluster.toFixed(1);

                drawCriticalCurve();

                currentP += 0.02;
                if (currentP > 1.0) {
                    stopCriticalSweep();
                }
            }, delay);
        }

        function stopCriticalSweep() {
            if (sweepInterval) {
                clearInterval(sweepInterval);
                sweepInterval = null;
            }
        }

        function simulatePercolation(type, p, size) {
            if (type === 'site') {
                const grid = Array(size).fill().map(() => Array(size).fill(false));

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (Math.random() < p) grid[i][j] = true;
                    }
                }

                const uf = new UnionFind(size * size);

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (!grid[i][j]) continue;
                        const idx = i * size + j;

                        if (j + 1 < size && grid[i][j + 1]) {
                            uf.union(idx, i * size + (j + 1));
                        }
                        if (i + 1 < size && grid[i + 1][j]) {
                            uf.union(idx, (i + 1) * size + j);
                        }
                    }
                }

                const topNodes = [];
                const bottomNodes = [];

                for (let j = 0; j < size; j++) {
                    if (grid[0][j]) topNodes.push(uf.find(j));
                    if (grid[size - 1][j]) bottomNodes.push(uf.find((size - 1) * size + j));
                }

                const percolates = topNodes.some(t => bottomNodes.includes(t));

                let largestCluster = 0;
                for (let i = 0; i < size * size; i++) {
                    if (grid[Math.floor(i / size)][i % size]) {
                        largestCluster = Math.max(largestCluster, uf.getSize(i));
                    }
                }

                return { percolates, largestCluster };

            } else { // bond
                const hBonds = Array(size).fill().map(() => Array(size - 1).fill(false));
                const vBonds = Array(size - 1).fill().map(() => Array(size).fill(false));

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size - 1; j++) {
                        if (Math.random() < p) hBonds[i][j] = true;
                    }
                }

                for (let i = 0; i < size - 1; i++) {
                    for (let j = 0; j < size; j++) {
                        if (Math.random() < p) vBonds[i][j] = true;
                    }
                }

                const uf = new UnionFind(size * size);

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size - 1; j++) {
                        if (hBonds[i][j]) uf.union(i * size + j, i * size + (j + 1));
                    }
                }

                for (let i = 0; i < size - 1; i++) {
                    for (let j = 0; j < size; j++) {
                        if (vBonds[i][j]) uf.union(i * size + j, (i + 1) * size + j);
                    }
                }

                const topNodes = Array.from({ length: size }, (_, j) => uf.find(j));
                const bottomNodes = Array.from({ length: size }, (_, j) => uf.find((size - 1) * size + j));

                const percolates = topNodes.some(t => bottomNodes.includes(t));

                let largestCluster = 0;
                for (let i = 0; i < size * size; i++) {
                    largestCluster = Math.max(largestCluster, uf.getSize(i));
                }

                return { percolates, largestCluster };
            }
        }

        function drawCriticalCurve() {
            const canvas = document.getElementById('criticalCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (sweepData.length === 0) return;

            const type = document.getElementById('sweepType').value;
            const pc = type === 'site' ? 0.5927 : 0.5;

            // Draw grid
            ctx.strokeStyle = 'rgba(224, 224, 255, 0.1)';
            ctx.lineWidth = 1;

            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();

                const x = (i / 10) * canvas.width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Draw critical threshold line
            const pc_x = pc * canvas.width;
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(pc_x, 0);
            ctx.lineTo(pc_x, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw pc label
            ctx.fillStyle = '#fbbf24';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(`pc = ${pc.toFixed(4)}`, pc_x + 5, 20);

            // Draw percolation probability curve
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i < sweepData.length; i++) {
                const x = sweepData[i].p * canvas.width;
                const y = canvas.height - (sweepData[i].percProb * canvas.height);

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            ctx.stroke();

            // Draw points
            ctx.fillStyle = '#667eea';
            for (let i = 0; i < sweepData.length; i++) {
                const x = sweepData[i].p * canvas.width;
                const y = canvas.height - (sweepData[i].percProb * canvas.height);
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Axis labels
            ctx.fillStyle = '#e0e0ff';
            ctx.font = '12px monospace';
            ctx.fillText('0', 5, canvas.height - 5);
            ctx.fillText('1.0', canvas.width - 25, canvas.height - 5);
            ctx.fillText('P(percolation)', 5, 15);
            ctx.fillText('Probability p', canvas.width / 2 - 40, canvas.height - 5);
        }

        // Cluster Analysis
        function generateClusterAnalysis() {
            const p = parseFloat(document.getElementById('clusterProbability').value);
            const type = document.getElementById('clusterType').value;
            const size = parseInt(document.getElementById('clusterGridSize').value);
            const canvas = document.getElementById('clusterCanvas');
            const ctx = canvas.getContext('2d');

            let uf, grid, percolates, largestClusterSize, spanningRoot;

            if (type === 'site') {
                grid = Array(size).fill().map(() => Array(size).fill(false));

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (Math.random() < p) grid[i][j] = true;
                    }
                }

                uf = new UnionFind(size * size);

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (!grid[i][j]) continue;
                        const idx = i * size + j;

                        if (j + 1 < size && grid[i][j + 1]) {
                            uf.union(idx, i * size + (j + 1));
                        }
                        if (i + 1 < size && grid[i + 1][j]) {
                            uf.union(idx, (i + 1) * size + j);
                        }
                    }
                }

                const topNodes = [];
                const bottomNodes = [];

                for (let j = 0; j < size; j++) {
                    if (grid[0][j]) topNodes.push(uf.find(j));
                    if (grid[size - 1][j]) bottomNodes.push(uf.find((size - 1) * size + j));
                }

                spanningRoot = topNodes.find(t => bottomNodes.includes(t));
                percolates = spanningRoot !== undefined;

                largestClusterSize = 0;
                for (let i = 0; i < size * size; i++) {
                    if (grid[Math.floor(i / size)][i % size]) {
                        largestClusterSize = Math.max(largestClusterSize, uf.getSize(i));
                    }
                }
            } else {
                // Bond percolation (simplified for visualization)
                grid = Array(size).fill().map(() => Array(size).fill(true));
                const hBonds = Array(size).fill().map(() => Array(size - 1).fill(false));
                const vBonds = Array(size - 1).fill().map(() => Array(size).fill(false));

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size - 1; j++) {
                        if (Math.random() < p) hBonds[i][j] = true;
                    }
                }

                for (let i = 0; i < size - 1; i++) {
                    for (let j = 0; j < size; j++) {
                        if (Math.random() < p) vBonds[i][j] = true;
                    }
                }

                uf = new UnionFind(size * size);

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size - 1; j++) {
                        if (hBonds[i][j]) uf.union(i * size + j, i * size + (j + 1));
                    }
                }

                for (let i = 0; i < size - 1; i++) {
                    for (let j = 0; j < size; j++) {
                        if (vBonds[i][j]) uf.union(i * size + j, (i + 1) * size + j);
                    }
                }

                const topNodes = Array.from({ length: size }, (_, j) => uf.find(j));
                const bottomNodes = Array.from({ length: size }, (_, j) => uf.find((size - 1) * size + j));

                spanningRoot = topNodes.find(t => bottomNodes.includes(t));
                percolates = spanningRoot !== undefined;

                largestClusterSize = 0;
                for (let i = 0; i < size * size; i++) {
                    largestClusterSize = Math.max(largestClusterSize, uf.getSize(i));
                }
            }

            // Get clusters
            const clusterMap = new Map();
            let totalCells = 0;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (type === 'site' && !grid[i][j]) continue;

                    totalCells++;
                    const idx = i * size + j;
                    const root = uf.find(idx);

                    if (!clusterMap.has(root)) {
                        clusterMap.set(root, { cells: [], color: null });
                    }
                    clusterMap.get(root).cells.push([i, j]);
                }
            }

            // Assign colors to clusters
            const clusters = Array.from(clusterMap.values());
            const colorPalette = generateDistinctColors(clusters.length);

            clusters.forEach((cluster, idx) => {
                cluster.color = colorPalette[idx];
            });

            // Draw
            const cellSize = canvas.width / size;
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (type === 'site' && !grid[i][j]) continue;

                    const idx = i * size + j;
                    const root = uf.find(idx);
                    const cluster = clusterMap.get(root);

                    // Highlight spanning cluster
                    const isSpanning = percolates && root === spanningRoot;

                    if (isSpanning) {
                        ctx.fillStyle = '#fbbf24';
                    } else {
                        ctx.fillStyle = cluster.color;
                    }

                    ctx.fillRect(j * cellSize, i * cellSize, cellSize - 0.5, cellSize - 0.5);
                }
            }

            // Update stats
            const avgClusterSize = totalCells / clusters.length;

            document.getElementById('clusterCount').textContent = clusters.length.toLocaleString();
            document.getElementById('clusterLargest').textContent = largestClusterSize.toLocaleString();
            document.getElementById('clusterAvgSize').textContent = avgClusterSize.toFixed(2);
            document.getElementById('clusterPercolates').innerHTML = percolates ?
                '<span class="percolates-yes">YES</span>' :
                '<span class="percolates-no">NO</span>';
        }

        function generateDistinctColors(n) {
            const colors = [];
            const goldenRatio = 0.618033988749895;
            let hue = Math.random();

            for (let i = 0; i < n; i++) {
                hue = (hue + goldenRatio) % 1;
                const saturation = 60 + Math.random() * 20;
                const lightness = 45 + Math.random() * 20;
                colors.push(`hsl(${hue * 360}, ${saturation}%, ${lightness}%)`);
            }

            return colors;
        }

        // Control handlers
        document.getElementById('siteProbability').addEventListener('input', (e) => {
            document.getElementById('siteProbVal').textContent = e.target.value;
        });

        document.getElementById('bondProbability').addEventListener('input', (e) => {
            document.getElementById('bondProbVal').textContent = e.target.value;
        });

        document.getElementById('clusterProbability').addEventListener('input', (e) => {
            document.getElementById('clusterProbVal').textContent = e.target.value;
        });

        function setSiteProbability(p) {
            document.getElementById('siteProbability').value = p;
            document.getElementById('siteProbVal').textContent = p.toFixed(3);
        }

        function setBondProbability(p) {
            document.getElementById('bondProbability').value = p;
            document.getElementById('bondProbVal').textContent = p.toFixed(3);
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.view).classList.add('active');
            });
        });

        // Initialize
        window.addEventListener('load', () => {
            initCanvases();
            generateSitePercolation();
            generateBondPercolation();
            generateClusterAnalysis();
        });

        window.addEventListener('resize', () => {
            initCanvases();
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
