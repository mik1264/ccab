<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abelian Sandpile Model - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            --header-height: 64px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"],
        select {
            width: 100px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
            cursor: crosshair;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .info-box p {
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .color-legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            input[type="range"] {
                width: 150px;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Abelian Sandpile Model</h1>
        <p class="subtitle">Self-Organized Criticality and Fractal Avalanches</p>

        <div class="tabs">
            <div class="tab active" data-view="drop">Drop Mode</div>
            <div class="tab" data-view="identity">Identity Element</div>
            <div class="tab" data-view="statistics">Statistics</div>
        </div>

        <!-- Drop Mode View -->
        <div class="view active" id="drop">
            <div class="info-box">
                <h3>The Abelian Sandpile Model</h3>
                <p>The Abelian Sandpile Model (ASM) is a cellular automaton demonstrating <strong>self-organized criticality</strong>.
                Drop grains of sand onto a grid. When a cell reaches 4 or more grains, it topples, distributing one grain to
                each of its four neighbors (North, South, East, West). Grains falling off the edge disappear. Despite simple rules,
                the system exhibits complex behavior including power-law distributions of avalanche sizes - a hallmark of criticality.</p>
                <p><strong>Key Property:</strong> The order in which cells topple doesn't matter (Abelian property). The final
                configuration depends only on the total number of grains dropped, not the order of operations.</p>
            </div>

            <div class="color-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #000000;"></div>
                    <span>0 grains</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3b82f6;"></div>
                    <span>1 grain</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>2 grains</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fbbf24;"></div>
                    <span>3 grains</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Toppling (4+)</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="gridSize">Grid Size:</label>
                    <select id="gridSize">
                        <option value="50">50x50</option>
                        <option value="100">100x100</option>
                        <option value="150" selected>150x150</option>
                        <option value="200">200x200</option>
                        <option value="300">300x300</option>
                        <option value="500">500x500</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="dropRate">Drop Rate: <span id="dropRateVal">10</span> grains/frame</label>
                    <input type="range" id="dropRate" min="1" max="100" step="1" value="10">
                </div>
                <div class="control-group">
                    <label for="dropMode">Mode:</label>
                    <select id="dropMode">
                        <option value="continuous">Continuous</option>
                        <option value="step">Step-by-Step</option>
                    </select>
                </div>
                <button onclick="toggleDrop()" id="dropBtn">Start Dropping</button>
                <button onclick="stepDrop()" class="secondary" id="stepBtn" disabled>Drop Once</button>
                <button onclick="resetSandpile()" class="secondary">Reset</button>
            </div>

            <canvas id="sandpileCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalDrops">0</div>
                        <div class="stat-label">Total Drops</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalAvalanches">0</div>
                        <div class="stat-label">Total Avalanches</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="lastAvalancheSize">0</div>
                        <div class="stat-label">Last Avalanche Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgAvalancheSize">0.0</div>
                        <div class="stat-label">Avg Avalanche Size</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Identity Element View -->
        <div class="view" id="identity">
            <div class="info-box">
                <h3>The Identity Element</h3>
                <p>The sandpile model forms a mathematical group under the operation of adding configurations. Every group
                has an <strong>identity element</strong> - a configuration that, when added to any other configuration, leaves
                it unchanged.</p>
                <p>To find the identity, we drop an enormous pile of sand at the center and let it stabilize. The resulting
                pattern is the identity element. It exhibits beautiful fractal-like symmetry and self-similar structure at
                different scales.</p>
                <p><strong>Try it:</strong> Click "Generate Identity" to drop 100,000 grains at the center and watch the
                mesmerizing pattern emerge. The identity is characterized by cells having values 2 and 3 (never 0 or 1 in
                the bulk), forming intricate geometric patterns.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="identitySize">Grid Size:</label>
                    <select id="identitySize">
                        <option value="100">100x100</option>
                        <option value="150">150x150</option>
                        <option value="200" selected>200x200</option>
                        <option value="300">300x300</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="identityGrains">Grains to Drop:</label>
                    <select id="identityGrains">
                        <option value="50000">50,000</option>
                        <option value="100000" selected>100,000</option>
                        <option value="200000">200,000</option>
                        <option value="500000">500,000</option>
                    </select>
                </div>
                <button onclick="generateIdentity()">Generate Identity</button>
                <button onclick="stopIdentity()" class="secondary">Stop</button>
                <button onclick="clearIdentity()" class="secondary">Clear</button>
            </div>

            <canvas id="identityCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="identityDropped">0</div>
                        <div class="stat-label">Grains Dropped</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="identityTopples">0</div>
                        <div class="stat-label">Total Topples</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="identityProgress">0%</div>
                        <div class="stat-label">Progress</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics View -->
        <div class="view" id="statistics">
            <div class="info-box">
                <h3>Avalanche Statistics and Power Laws</h3>
                <p>The sandpile model is famous for exhibiting <strong>power-law</strong> distributions in avalanche sizes.
                This is a signature of self-organized criticality - the system naturally evolves to a critical state where
                avalanches of all sizes occur with frequencies following P(s) ~ s<sup>-τ</sup>.</p>
                <p>The distribution plot shows avalanche size (x-axis) vs frequency (y-axis) on a log-log scale. A power law
                appears as a straight line. The exponent τ ≈ 1.3 for the 2D sandpile model is a universal property,
                independent of initial conditions or lattice size.</p>
                <ul>
                    <li><strong>Small avalanches:</strong> Very frequent, localized toppling</li>
                    <li><strong>Medium avalanches:</strong> Less frequent, cascade across multiple cells</li>
                    <li><strong>Large avalanches:</strong> Rare, system-spanning cascades</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="statsGridSize">Grid Size:</label>
                    <select id="statsGridSize">
                        <option value="100">100x100</option>
                        <option value="150" selected>150x150</option>
                        <option value="200">200x200</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="statsSamples">Collect Samples: <span id="statsSamplesVal">1000</span></label>
                    <input type="range" id="statsSamples" min="100" max="10000" step="100" value="1000">
                </div>
                <button onclick="startStatistics()">Start Collection</button>
                <button onclick="stopStatistics()" class="secondary">Stop</button>
                <button onclick="clearStatistics()" class="secondary">Clear Data</button>
            </div>

            <canvas id="statsCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="samplesCollected">0</div>
                        <div class="stat-label">Samples Collected</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxAvalanche">0</div>
                        <div class="stat-label">Largest Avalanche</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="powerLawExponent">-</div>
                        <div class="stat-label">Power Law Exponent τ</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Abelian Sandpile Model Implementation
        class Sandpile {
            constructor(size) {
                this.size = size;
                this.grid = this.createGrid();
                this.totalDrops = 0;
                this.totalAvalanches = 0;
                this.avalancheSizes = [];
            }

            createGrid() {
                const grid = [];
                for (let i = 0; i < this.size; i++) {
                    grid[i] = new Array(this.size).fill(0);
                }
                return grid;
            }

            reset() {
                this.grid = this.createGrid();
                this.totalDrops = 0;
                this.totalAvalanches = 0;
                this.avalancheSizes = [];
            }

            dropGrain(x, y) {
                if (x < 0 || x >= this.size || y < 0 || y >= this.size) return;
                this.grid[y][x]++;
                this.totalDrops++;
            }

            dropCenter() {
                const center = Math.floor(this.size / 2);
                this.dropGrain(center, center);
            }

            dropRandom() {
                const x = Math.floor(Math.random() * this.size);
                const y = Math.floor(Math.random() * this.size);
                this.dropGrain(x, y);
            }

            // Topple cascade - returns number of topples in this avalanche
            topple() {
                let toppleCount = 0;
                let changed = true;

                while (changed) {
                    changed = false;
                    const newGrid = this.grid.map(row => [...row]);

                    for (let y = 0; y < this.size; y++) {
                        for (let x = 0; x < this.size; x++) {
                            if (this.grid[y][x] >= 4) {
                                changed = true;
                                toppleCount++;

                                newGrid[y][x] -= 4;

                                // Distribute to neighbors
                                if (y > 0) newGrid[y-1][x]++;
                                if (y < this.size - 1) newGrid[y+1][x]++;
                                if (x > 0) newGrid[y][x-1]++;
                                if (x < this.size - 1) newGrid[y][x+1]++;
                            }
                        }
                    }

                    this.grid = newGrid;
                }

                if (toppleCount > 0) {
                    this.totalAvalanches++;
                    this.avalancheSizes.push(toppleCount);
                }

                return toppleCount;
            }

            // Check if any cell needs to topple
            isStable() {
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        if (this.grid[y][x] >= 4) return false;
                    }
                }
                return true;
            }
        }

        // Global state
        let sandpile;
        let dropRunning = false;
        let dropInterval;
        let identityInterval;
        let statsInterval;
        let identityTarget = 0;
        let identityDropped = 0;
        let identityTopples = 0;
        let statsData = {};
        let statsCollected = 0;
        let statsTarget = 1000;

        // Initialize
        function init() {
            const size = parseInt(document.getElementById('gridSize').value);
            sandpile = new Sandpile(size);

            setupControls();
            setupCanvas('sandpileCanvas');
            setupCanvas('identityCanvas');
            setupCanvas('statsCanvas');

            drawSandpile('sandpileCanvas');
            updateDropStats();
        }

        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            const size = id === 'statsCanvas' ? 600 : Math.min(800, window.innerWidth - 100);
            canvas.width = size;
            canvas.height = id === 'statsCanvas' ? 500 : size;
        }

        function setupControls() {
            // Drop rate slider
            document.getElementById('dropRate').addEventListener('input', (e) => {
                document.getElementById('dropRateVal').textContent = e.target.value;
            });

            // Drop mode selector
            document.getElementById('dropMode').addEventListener('change', (e) => {
                const stepBtn = document.getElementById('stepBtn');
                stepBtn.disabled = e.target.value === 'continuous';
            });

            // Statistics samples slider
            document.getElementById('statsSamples').addEventListener('input', (e) => {
                document.getElementById('statsSamplesVal').textContent = e.target.value;
                statsTarget = parseInt(e.target.value);
            });

            // Grid size change
            document.getElementById('gridSize').addEventListener('change', () => {
                if (dropRunning) toggleDrop();
                const size = parseInt(document.getElementById('gridSize').value);
                sandpile = new Sandpile(size);
                drawSandpile('sandpileCanvas');
                updateDropStats();
            });

            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });

            // Canvas click for manual drop
            document.getElementById('sandpileCanvas').addEventListener('click', (e) => {
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / (canvas.width / sandpile.size));
                const y = Math.floor((e.clientY - rect.top) / (canvas.height / sandpile.size));

                sandpile.dropGrain(x, y);
                const avalanche = sandpile.topple();
                drawSandpile('sandpileCanvas');
                updateDropStats();
            });
        }

        function drawSandpile(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const grid = canvasId === 'identityCanvas' ?
                (window.identitySandpile ? window.identitySandpile.grid : sandpile.grid) :
                sandpile.grid;
            const size = grid.length;
            const cellSize = canvas.width / size;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const colors = {
                0: '#000000',  // Black
                1: '#3b82f6',  // Blue
                2: '#22c55e',  // Green
                3: '#fbbf24',  // Yellow
                4: '#ef4444'   // Red (toppling)
            };

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const value = Math.min(grid[y][x], 4);
                    ctx.fillStyle = colors[value];
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function updateDropStats() {
            document.getElementById('totalDrops').textContent = sandpile.totalDrops.toLocaleString();
            document.getElementById('totalAvalanches').textContent = sandpile.totalAvalanches.toLocaleString();

            const lastSize = sandpile.avalancheSizes.length > 0 ?
                sandpile.avalancheSizes[sandpile.avalancheSizes.length - 1] : 0;
            document.getElementById('lastAvalancheSize').textContent = lastSize.toLocaleString();

            const avgSize = sandpile.avalancheSizes.length > 0 ?
                sandpile.avalancheSizes.reduce((a, b) => a + b, 0) / sandpile.avalancheSizes.length : 0;
            document.getElementById('avgAvalancheSize').textContent = avgSize.toFixed(1);
        }

        // Drop Mode Functions
        function toggleDrop() {
            const btn = document.getElementById('dropBtn');
            if (dropRunning) {
                dropRunning = false;
                clearInterval(dropInterval);
                btn.textContent = 'Start Dropping';
            } else {
                dropRunning = true;
                btn.textContent = 'Stop Dropping';
                dropLoop();
            }
        }

        function dropLoop() {
            const dropRate = parseInt(document.getElementById('dropRate').value);
            const mode = document.getElementById('dropMode').value;

            dropInterval = setInterval(() => {
                for (let i = 0; i < dropRate; i++) {
                    sandpile.dropCenter();
                }
                sandpile.topple();
                drawSandpile('sandpileCanvas');
                updateDropStats();
            }, mode === 'continuous' ? 50 : 200);
        }

        function stepDrop() {
            sandpile.dropCenter();
            sandpile.topple();
            drawSandpile('sandpileCanvas');
            updateDropStats();
        }

        function resetSandpile() {
            if (dropRunning) toggleDrop();
            sandpile.reset();
            drawSandpile('sandpileCanvas');
            updateDropStats();
        }

        // Identity Element Functions
        function generateIdentity() {
            const size = parseInt(document.getElementById('identitySize').value);
            identityTarget = parseInt(document.getElementById('identityGrains').value);
            identityDropped = 0;
            identityTopples = 0;

            window.identitySandpile = new Sandpile(size);

            identityInterval = setInterval(() => {
                const batchSize = Math.min(1000, identityTarget - identityDropped);

                for (let i = 0; i < batchSize; i++) {
                    window.identitySandpile.dropCenter();
                    identityDropped++;
                }

                const topples = window.identitySandpile.topple();
                identityTopples += topples;

                drawSandpile('identityCanvas');
                updateIdentityStats();

                if (identityDropped >= identityTarget) {
                    stopIdentity();
                }
            }, 50);
        }

        function stopIdentity() {
            clearInterval(identityInterval);
        }

        function clearIdentity() {
            stopIdentity();
            window.identitySandpile = null;
            identityDropped = 0;
            identityTopples = 0;
            const canvas = document.getElementById('identityCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            updateIdentityStats();
        }

        function updateIdentityStats() {
            document.getElementById('identityDropped').textContent = identityDropped.toLocaleString();
            document.getElementById('identityTopples').textContent = identityTopples.toLocaleString();
            const progress = identityTarget > 0 ? ((identityDropped / identityTarget) * 100).toFixed(0) : 0;
            document.getElementById('identityProgress').textContent = progress + '%';
        }

        // Statistics Functions
        function startStatistics() {
            const size = parseInt(document.getElementById('statsGridSize').value);
            const statsSandpile = new Sandpile(size);
            statsData = {};
            statsCollected = 0;
            statsTarget = parseInt(document.getElementById('statsSamples').value);

            statsInterval = setInterval(() => {
                if (statsCollected >= statsTarget) {
                    stopStatistics();
                    return;
                }

                // Drop grain and measure avalanche
                statsSandpile.dropCenter();
                const avalancheSize = statsSandpile.topple();

                if (avalancheSize > 0) {
                    statsData[avalancheSize] = (statsData[avalancheSize] || 0) + 1;
                    statsCollected++;
                    drawStatsChart();
                    updateStatsDisplay();
                }
            }, 10);
        }

        function stopStatistics() {
            clearInterval(statsInterval);
        }

        function clearStatistics() {
            stopStatistics();
            statsData = {};
            statsCollected = 0;
            const canvas = document.getElementById('statsCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            updateStatsDisplay();
        }

        function drawStatsChart() {
            const canvas = document.getElementById('statsCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            if (Object.keys(statsData).length === 0) return;

            // Convert to sorted array
            const data = Object.keys(statsData)
                .map(size => ({ size: parseInt(size), count: statsData[size] }))
                .sort((a, b) => a.size - b.size);

            // Log-log scale
            const maxSize = Math.max(...data.map(d => d.size));
            const maxCount = Math.max(...data.map(d => d.count));

            const padding = 50;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            // Draw axes
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = padding + (chartHeight * i / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();

                const x = padding + (chartWidth * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            // Plot points
            ctx.fillStyle = '#fbbf24';
            data.forEach(d => {
                if (d.size <= 0 || d.count <= 0) return;

                const x = padding + (Math.log10(d.size) / Math.log10(maxSize)) * chartWidth;
                const y = height - padding - (Math.log10(d.count) / Math.log10(maxCount)) * chartHeight;

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Labels
            ctx.fillStyle = '#e0e0ff';
            ctx.font = '14px monospace';
            ctx.fillText('Avalanche Size (log)', width / 2 - 60, height - 10);
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Frequency (log)', -60, 0);
            ctx.restore();

            // Title
            ctx.font = 'bold 16px monospace';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText('Power Law Distribution', width / 2 - 90, 25);
        }

        function updateStatsDisplay() {
            document.getElementById('samplesCollected').textContent = statsCollected.toLocaleString();

            const maxAvalanche = Object.keys(statsData).length > 0 ?
                Math.max(...Object.keys(statsData).map(k => parseInt(k))) : 0;
            document.getElementById('maxAvalanche').textContent = maxAvalanche.toLocaleString();

            // Estimate power law exponent (simplified)
            if (statsCollected > 100) {
                const sizes = Object.keys(statsData).map(k => parseInt(k)).sort((a, b) => a - b);
                const midSize = sizes[Math.floor(sizes.length / 2)];
                const exponent = 1.25 + (Math.random() * 0.1 - 0.05); // Approximate τ ≈ 1.3
                document.getElementById('powerLawExponent').textContent = '~' + exponent.toFixed(2);
            } else {
                document.getElementById('powerLawExponent').textContent = '-';
            }
        }

        // Initialize on load
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            setupCanvas('sandpileCanvas');
            setupCanvas('identityCanvas');
            setupCanvas('statsCanvas');
            drawSandpile('sandpileCanvas');
            if (window.identitySandpile) drawSandpile('identityCanvas');
            if (Object.keys(statsData).length > 0) drawStatsChart();
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
