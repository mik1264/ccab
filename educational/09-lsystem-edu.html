<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L-Systems - Educational Demo</title>
    <link rel="stylesheet" href="../assets/css/edu-panel.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a1a0a;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 220px;
        }
        .controls h3 {
            margin-bottom: 10px;
            color: #2ecc71;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-size: 11px;
            margin-bottom: 3px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group select, .control-group input[type="text"] {
            width: 100%;
            padding: 5px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-family: monospace;
        }
        .rule-box {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .buttons button {
            flex: 1;
            padding: 6px;
            background: #2ecc71;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .buttons button:hover { background: #27ae60; }
        .string-preview {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            font-size: 10px;
            color: #888;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #2ecc71;
            text-decoration: none;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(46,204,113,0.3); }
        /* Edu panel dark theme overrides */
        .edu-panel { background: rgba(10,26,10,0.95); }
        .edu-tab { background: #1a2a1a; color: #aaa; }
        .edu-tab.active { background: #2ecc71; color: #fff; }
        .edu-tab:hover:not(.active) { background: #2a4a2a; }
        .edu-content { color: #ccc; }
        .edu-content h4 { color: #2ecc71; }
        .concept-card { background: rgba(46,204,113,0.1); border-color: #2ecc71; }
        .step-number { background: #2ecc71; }
        code { background: rgba(46,204,113,0.2); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <div class="controls">
        <h3>L-Systems</h3>

        <div class="control-group">
            <label>Preset</label>
            <select id="preset">
                <option value="tree">Fractal Tree</option>
                <option value="koch">Koch Curve</option>
                <option value="sierpinski">Sierpinski Triangle</option>
                <option value="dragon">Dragon Curve</option>
                <option value="plant">Plant</option>
                <option value="bush">Bush</option>
                <option value="hilbert">Hilbert Curve</option>
                <option value="custom">Custom</option>
            </select>
        </div>

        <div class="control-group">
            <label>Iterations: <span id="iterVal">5</span></label>
            <input type="range" id="iterations" min="1" max="10" value="5">
        </div>

        <div class="control-group">
            <label>Angle: <span id="angleVal">25</span>¬∞</label>
            <input type="range" id="angle" min="1" max="90" value="25">
        </div>

        <div class="control-group">
            <label>Step Length: <span id="lengthVal">10</span></label>
            <input type="range" id="stepLength" min="1" max="30" value="10">
        </div>

        <div class="control-group">
            <label>Axiom</label>
            <input type="text" id="axiom" value="F">
        </div>

        <div class="control-group">
            <label>Rules</label>
            <div class="rule-box" id="rulesBox">F ‚Üí FF+[+F-F-F]-[-F+F+F]</div>
        </div>

        <div class="buttons">
            <button onclick="regenerate()">Regenerate</button>
            <button onclick="animate()">Animate</button>
        </div>

        <div class="string-preview">
            <strong>String length:</strong> <span id="stringLength">0</span><br>
            <span id="stringPreview"></span>
        </div>
    </div>

    <div id="edu-panel"></div>

    <script src="../assets/js/edu-panel.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // L-System state
        let axiom = 'F';
        let rules = { 'F': 'FF+[+F-F-F]-[-F+F+F]' };
        let angle = 25;
        let stepLength = 10;
        let iterations = 5;
        let currentString = '';
        let animating = false;
        let drawIndex = 0;

        // Presets
        const presets = {
            tree: {
                axiom: 'F',
                rules: { 'F': 'FF+[+F-F-F]-[-F+F+F]' },
                angle: 25,
                iterations: 4
            },
            koch: {
                axiom: 'F',
                rules: { 'F': 'F+F-F-F+F' },
                angle: 90,
                iterations: 4
            },
            sierpinski: {
                axiom: 'F-G-G',
                rules: { 'F': 'F-G+F+G-F', 'G': 'GG' },
                angle: 120,
                iterations: 6
            },
            dragon: {
                axiom: 'FX',
                rules: { 'X': 'X+YF+', 'Y': '-FX-Y' },
                angle: 90,
                iterations: 12
            },
            plant: {
                axiom: 'X',
                rules: { 'X': 'F+[[X]-X]-F[-FX]+X', 'F': 'FF' },
                angle: 25,
                iterations: 6
            },
            bush: {
                axiom: 'F',
                rules: { 'F': 'F[+F]F[-F][F]' },
                angle: 20,
                iterations: 5
            },
            hilbert: {
                axiom: 'A',
                rules: { 'A': '-BF+AFA+FB-', 'B': '+AF-BFB-FA+' },
                angle: 90,
                iterations: 6
            }
        };

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            regenerate();
        }

        function generate(axiom, rules, n) {
            let result = axiom;
            for (let i = 0; i < n; i++) {
                let next = '';
                for (const char of result) {
                    next += rules[char] || char;
                }
                result = next;
            }
            return result;
        }

        function computeBounds(str) {
            let x = 0, y = 0;
            let dir = -90; // Start pointing up
            const stack = [];
            let minX = 0, maxX = 0, minY = 0, maxY = 0;

            for (const char of str) {
                switch (char) {
                    case 'F':
                    case 'G':
                        x += Math.cos(dir * Math.PI / 180) * stepLength;
                        y += Math.sin(dir * Math.PI / 180) * stepLength;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        break;
                    case '+':
                        dir += angle;
                        break;
                    case '-':
                        dir -= angle;
                        break;
                    case '[':
                        stack.push({ x, y, dir });
                        break;
                    case ']':
                        const state = stack.pop();
                        x = state.x;
                        y = state.y;
                        dir = state.dir;
                        break;
                }
            }

            return { minX, maxX, minY, maxY };
        }

        function draw(str, animated = false, maxIndex = Infinity) {
            ctx.fillStyle = '#0a1a0a';
            ctx.fillRect(0, 0, width, height);

            const bounds = computeBounds(str);
            const drawWidth = bounds.maxX - bounds.minX;
            const drawHeight = bounds.maxY - bounds.minY;

            // Calculate scale and offset to center
            const scale = Math.min(
                (width * 0.8) / Math.max(drawWidth, 1),
                (height * 0.8) / Math.max(drawHeight, 1),
                1
            );

            const offsetX = width / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
            const offsetY = height / 2 - (bounds.minY + bounds.maxY) / 2 * scale;

            let x = 0, y = 0;
            let dir = -90;
            const stack = [];
            let index = 0;

            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 1;
            ctx.lineCap = 'round';

            for (const char of str) {
                if (index >= maxIndex) break;

                switch (char) {
                    case 'F':
                    case 'G':
                        const newX = x + Math.cos(dir * Math.PI / 180) * stepLength;
                        const newY = y + Math.sin(dir * Math.PI / 180) * stepLength;

                        // Color based on depth
                        const depth = stack.length;
                        const hue = 100 + depth * 20;
                        const lightness = Math.max(30, 60 - depth * 5);
                        ctx.strokeStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                        ctx.lineWidth = Math.max(0.5, 3 - depth * 0.3);

                        ctx.beginPath();
                        ctx.moveTo(x * scale + offsetX, y * scale + offsetY);
                        ctx.lineTo(newX * scale + offsetX, newY * scale + offsetY);
                        ctx.stroke();

                        x = newX;
                        y = newY;
                        index++;
                        break;
                    case '+':
                        dir += angle;
                        break;
                    case '-':
                        dir -= angle;
                        break;
                    case '[':
                        stack.push({ x, y, dir });
                        break;
                    case ']':
                        const state = stack.pop();
                        x = state.x;
                        y = state.y;
                        dir = state.dir;
                        break;
                }
            }
        }

        function regenerate() {
            animating = false;
            currentString = generate(axiom, rules, iterations);

            document.getElementById('stringLength').textContent = currentString.length;
            const preview = currentString.length > 100 ?
                currentString.substring(0, 100) + '...' : currentString;
            document.getElementById('stringPreview').textContent = preview;

            draw(currentString);
        }

        function animate() {
            animating = true;
            drawIndex = 0;

            function step() {
                if (!animating) return;

                draw(currentString, true, drawIndex);
                drawIndex += Math.ceil(currentString.length / 200);

                if (drawIndex < currentString.length) {
                    requestAnimationFrame(step);
                } else {
                    animating = false;
                }
            }

            step();
        }

        function loadPreset(name) {
            if (name === 'custom') return;

            const preset = presets[name];
            axiom = preset.axiom;
            rules = preset.rules;
            angle = preset.angle;
            iterations = preset.iterations;

            document.getElementById('axiom').value = axiom;
            document.getElementById('angle').value = angle;
            document.getElementById('angleVal').textContent = angle;
            document.getElementById('iterations').value = iterations;
            document.getElementById('iterVal').textContent = iterations;

            const rulesStr = Object.entries(rules)
                .map(([k, v]) => `${k} ‚Üí ${v}`)
                .join('\n');
            document.getElementById('rulesBox').textContent = rulesStr;

            regenerate();
        }

        // Event handlers
        document.getElementById('preset').addEventListener('change', (e) => {
            loadPreset(e.target.value);
        });

        document.getElementById('iterations').addEventListener('input', (e) => {
            iterations = parseInt(e.target.value);
            document.getElementById('iterVal').textContent = iterations;
            regenerate();
        });

        document.getElementById('angle').addEventListener('input', (e) => {
            angle = parseInt(e.target.value);
            document.getElementById('angleVal').textContent = angle;
            regenerate();
        });

        document.getElementById('stepLength').addEventListener('input', (e) => {
            stepLength = parseInt(e.target.value);
            document.getElementById('lengthVal').textContent = stepLength;
            regenerate();
        });

        document.getElementById('axiom').addEventListener('change', (e) => {
            axiom = e.target.value;
            regenerate();
        });

        window.addEventListener('resize', resize);

        // Initialize
        resize();

        // Educational Panel
        new EduPanel('#edu-panel', {
            title: 'L-Systems',
            startOpen: false,
            tabs: [
                {
                    id: 'theory',
                    label: 'Theory',
                    content: `
                        <h4>What are L-Systems?</h4>
                        <p>Lindenmayer Systems (L-systems) are parallel rewriting systems invented by biologist Aristid Lindenmayer in 1968 to model plant growth. They generate complex structures from simple rules.</p>

                        <div class="concept-card">
                            <h5>Components</h5>
                            <ul>
                                <li><strong>Axiom</strong>: Starting string (e.g., "F")</li>
                                <li><strong>Rules</strong>: Replacement rules (e.g., F ‚Üí F+F-F)</li>
                                <li><strong>Iterations</strong>: How many times to apply rules</li>
                            </ul>
                        </div>

                        <div class="concept-card">
                            <h5>Turtle Graphics</h5>
                            <p>The string is interpreted as turtle commands:</p>
                            <ul>
                                <li><code>F</code>: Move forward, drawing</li>
                                <li><code>+</code>: Turn right by angle</li>
                                <li><code>-</code>: Turn left by angle</li>
                                <li><code>[</code>: Save position (push)</li>
                                <li><code>]</code>: Restore position (pop)</li>
                            </ul>
                        </div>

                        <div class="concept-card">
                            <h5>Parallel Rewriting</h5>
                            <p>Unlike sequential grammars (Chomsky), L-systems apply ALL rules simultaneously. This models parallel growth in biology.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Self-Similarity</h5>
                            <p>L-systems naturally produce fractals: each part resembles the whole at different scales. This mirrors how plants grow (branches ‚Üí twigs ‚Üí leaves).</p>
                        </div>
                    `
                },
                {
                    id: 'algorithm',
                    label: 'Algorithm',
                    content: `
                        <h4>String Generation</h4>

                        <div class="steps">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Start with Axiom</strong>
                                    <p>Initial string, e.g., "F"</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Apply Rules</strong>
                                    <p>Replace each character according to rules</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Repeat</strong>
                                    <p>Apply rules n times (iterations)</p>
                                </div>
                            </div>
                        </div>

                        <h4>Example: Koch Curve</h4>
                        <pre><code>Axiom: F
Rule: F ‚Üí F+F-F-F+F
Angle: 90¬∞

n=0: F
n=1: F+F-F-F+F
n=2: F+F-F-F+F+F+F-F-F+F-F+F-F-F+F
     -F+F-F-F+F+F+F-F-F+F
...</code></pre>

                        <h4>Turtle Interpretation</h4>
                        <pre><code>x, y = start position
dir = initial direction
stack = []

for each char in string:
    if char == 'F':
        draw line from (x,y) in direction dir
        move to endpoint
    elif char == '+':
        dir += angle
    elif char == '-':
        dir -= angle
    elif char == '[':
        stack.push(x, y, dir)
    elif char == ']':
        x, y, dir = stack.pop()</code></pre>

                        <div class="concept-card">
                            <h5>Exponential Growth</h5>
                            <p>String length grows exponentially with iterations. If rule F‚ÜíFF, length doubles each step: 1‚Üí2‚Üí4‚Üí8‚Üí16... Be careful with high iterations!</p>
                        </div>
                    `
                },
                {
                    id: 'applications',
                    label: 'Applications',
                    content: `
                        <h4>Real-World Applications</h4>

                        <div class="application">
                            <h5>üå≥ Computer Graphics</h5>
                            <p>Procedural generation of trees, plants, and terrain in games and movies. Used in "Avatar", many games.</p>
                        </div>

                        <div class="application">
                            <h5>üß¨ Biology</h5>
                            <p>Modeling plant growth, cell division patterns, and development. Lindenmayer's original purpose!</p>
                        </div>

                        <div class="application">
                            <h5>üèõÔ∏è Architecture</h5>
                            <p>Generative design, facade patterns, and organic structural forms. Used by architects like Zaha Hadid.</p>
                        </div>

                        <div class="application">
                            <h5>üé® Generative Art</h5>
                            <p>Creating unique, mathematical art. Each rule set produces a distinctive aesthetic.</p>
                        </div>

                        <div class="application">
                            <h5>üîê Formal Languages</h5>
                            <p>L-systems are a formal grammar class. Used in theoretical computer science and compiler design.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Extensions</h5>
                            <ul>
                                <li><strong>Stochastic</strong>: Random rule selection</li>
                                <li><strong>Context-sensitive</strong>: Rules depend on neighbors</li>
                                <li><strong>Parametric</strong>: Variables with values</li>
                                <li><strong>3D</strong>: Full spatial turtle graphics</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'explore',
                    label: 'Explore',
                    content: `
                        <h4>Interactive Explorations</h4>

                        <div class="tutorial">
                            <h5>1. Fractal Tree</h5>
                            <p>Start with "Fractal Tree" preset. The brackets [] create branches:</p>
                            <ul>
                                <li><code>[</code> saves position & angle</li>
                                <li>Commands draw the branch</li>
                                <li><code>]</code> returns to saved state</li>
                            </ul>
                        </div>

                        <div class="tutorial">
                            <h5>2. Koch Curve</h5>
                            <p>Select "Koch Curve". Watch the famous fractal snowflake edge form. Try changing the angle!</p>
                        </div>

                        <div class="tutorial">
                            <h5>3. Dragon Curve</h5>
                            <p>Select "Dragon Curve". This space-filling curve never crosses itself. Increase iterations to see it emerge.</p>
                        </div>

                        <div class="tutorial">
                            <h5>4. Animate Growth</h5>
                            <p>Click "Animate" to watch the structure being drawn stroke by stroke. This shows the order of turtle commands.</p>
                        </div>

                        <div class="tutorial">
                            <h5>5. Angle Effects</h5>
                            <p>Vary the angle slider. Notice how it completely changes the shape's character while keeping the same topology.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Challenge: Create Your Own</h5>
                            <p>Select "Custom" and try creating rules:</p>
                            <ul>
                                <li>Simple: <code>F ‚Üí F+F</code> (angle=90)</li>
                                <li>Branching: <code>F ‚Üí F[+F]F[-F]F</code></li>
                                <li>Complex: Add multiple rules!</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'references',
                    label: 'References',
                    content: `
                        <h4>Learn More</h4>

                        <div class="reference-list">
                            <a href="https://en.wikipedia.org/wiki/L-system" target="_blank">Wikipedia: L-system</a>
                            <a href="http://paulbourke.net/fractals/lsys/" target="_blank">Paul Bourke: L-System Examples</a>
                            <a href="https://www.youtube.com/watch?v=E1B4UoSQMFw" target="_blank">Coding Train: L-Systems</a>
                            <a href="http://algorithmicbotany.org/papers/abop/abop.pdf" target="_blank">The Algorithmic Beauty of Plants (PDF)</a>
                        </div>

                        <h4>Key Work</h4>
                        <ul>
                            <li><strong>Aristid Lindenmayer</strong> (1968) - Invented L-systems for modeling algae growth</li>
                            <li><strong>Prusinkiewicz & Lindenmayer</strong> (1990) - "The Algorithmic Beauty of Plants" - the definitive book</li>
                        </ul>

                        <h4>Related Topics</h4>
                        <ul>
                            <li>Formal Grammars</li>
                            <li>Fractal Geometry</li>
                            <li>Procedural Generation</li>
                            <li>Turtle Graphics</li>
                            <li>Developmental Biology</li>
                        </ul>
                    `
                }
            ]
        });
    </script>
</body>
</html>
