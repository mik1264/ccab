<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids Flocking - Educational Demo</title>
    <link rel="stylesheet" href="../assets/css/edu-panel.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a1a;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 220px;
        }
        .controls h3 {
            margin-bottom: 15px;
            color: #3498db;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 3px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-row {
            display: flex;
            gap: 10px;
        }
        .control-row label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #aaa;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #3498db;
            text-decoration: none;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(52,152,219,0.3); }
        .stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            color: #888;
        }
        /* Edu panel dark theme overrides */
        .edu-panel { background: rgba(20,20,30,0.95); }
        .edu-tab { background: #1a1a2e; color: #aaa; }
        .edu-tab.active { background: #3498db; color: #fff; }
        .edu-tab:hover:not(.active) { background: #2a2a4e; }
        .edu-content { color: #ccc; }
        .edu-content h4 { color: #3498db; }
        .concept-card { background: rgba(52,152,219,0.1); border-color: #3498db; }
        .step-number { background: #3498db; }
        code { background: rgba(52,152,219,0.2); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <div class="controls">
        <h3>Boids Flocking</h3>

        <div class="control-group">
            <label>Boid Count: <span id="countVal">150</span></label>
            <input type="range" id="boidCount" min="10" max="500" value="150">
        </div>

        <div class="control-group">
            <label>Separation: <span id="sepVal">1.5</span></label>
            <input type="range" id="separation" min="0" max="5" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <label>Alignment: <span id="alignVal">1.0</span></label>
            <input type="range" id="alignment" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Cohesion: <span id="cohVal">1.0</span></label>
            <input type="range" id="cohesion" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Perception Radius: <span id="perceptVal">50</span></label>
            <input type="range" id="perception" min="20" max="150" value="50">
        </div>

        <div class="control-group">
            <label>Max Speed: <span id="speedVal">4</span></label>
            <input type="range" id="maxSpeed" min="1" max="10" value="4">
        </div>

        <div class="control-row" style="margin-top:15px;">
            <label><input type="checkbox" id="showForces"> Show Forces</label>
            <label><input type="checkbox" id="showRadius"> Show Radius</label>
        </div>

        <div class="control-row">
            <label><input type="checkbox" id="showTrails"> Trails</label>
            <label><input type="checkbox" id="pauseSim"> Pause</label>
        </div>
    </div>

    <div class="stats">
        <div>Average Speed: <span id="avgSpeed">0</span></div>
        <div>Avg Neighbors: <span id="avgNeighbors">0</span></div>
    </div>

    <div id="edu-panel"></div>

    <script src="../assets/js/edu-panel.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let boids = [];
        let trails = [];

        // Parameters
        let params = {
            count: 150,
            separation: 1.5,
            alignment: 1.0,
            cohesion: 1.0,
            perception: 50,
            maxSpeed: 4,
            maxForce: 0.2,
            showForces: false,
            showRadius: false,
            showTrails: false,
            paused: false
        };

        class Boid {
            constructor(x, y) {
                this.pos = { x, y };
                this.vel = {
                    x: (Math.random() - 0.5) * params.maxSpeed * 2,
                    y: (Math.random() - 0.5) * params.maxSpeed * 2
                };
                this.acc = { x: 0, y: 0 };
                this.forces = { sep: {x:0,y:0}, align: {x:0,y:0}, coh: {x:0,y:0} };
                this.neighbors = 0;
            }

            edges() {
                if (this.pos.x > width) this.pos.x = 0;
                if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.y > height) this.pos.y = 0;
                if (this.pos.y < 0) this.pos.y = height;
            }

            flock(boids) {
                let separation = { x: 0, y: 0 };
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let sepCount = 0;
                let total = 0;

                for (let other of boids) {
                    const dx = other.pos.x - this.pos.x;
                    const dy = other.pos.y - this.pos.y;
                    const d = Math.sqrt(dx * dx + dy * dy);

                    if (other !== this && d < params.perception) {
                        // Alignment: average velocity
                        alignment.x += other.vel.x;
                        alignment.y += other.vel.y;

                        // Cohesion: average position
                        cohesion.x += other.pos.x;
                        cohesion.y += other.pos.y;

                        total++;

                        // Separation: steer away from close neighbors
                        if (d < params.perception * 0.5 && d > 0) {
                            separation.x -= dx / d;
                            separation.y -= dy / d;
                            sepCount++;
                        }
                    }
                }

                this.neighbors = total;

                if (total > 0) {
                    // Alignment
                    alignment.x /= total;
                    alignment.y /= total;
                    const alignMag = Math.sqrt(alignment.x * alignment.x + alignment.y * alignment.y);
                    if (alignMag > 0) {
                        alignment.x = (alignment.x / alignMag) * params.maxSpeed - this.vel.x;
                        alignment.y = (alignment.y / alignMag) * params.maxSpeed - this.vel.y;
                    }
                    this.limitForce(alignment);

                    // Cohesion
                    cohesion.x = cohesion.x / total - this.pos.x;
                    cohesion.y = cohesion.y / total - this.pos.y;
                    const cohMag = Math.sqrt(cohesion.x * cohesion.x + cohesion.y * cohesion.y);
                    if (cohMag > 0) {
                        cohesion.x = (cohesion.x / cohMag) * params.maxSpeed - this.vel.x;
                        cohesion.y = (cohesion.y / cohMag) * params.maxSpeed - this.vel.y;
                    }
                    this.limitForce(cohesion);
                }

                if (sepCount > 0) {
                    separation.x /= sepCount;
                    separation.y /= sepCount;
                    const sepMag = Math.sqrt(separation.x * separation.x + separation.y * separation.y);
                    if (sepMag > 0) {
                        separation.x = (separation.x / sepMag) * params.maxSpeed - this.vel.x;
                        separation.y = (separation.y / sepMag) * params.maxSpeed - this.vel.y;
                    }
                    this.limitForce(separation);
                }

                // Store forces for visualization
                this.forces.sep = { x: separation.x * params.separation, y: separation.y * params.separation };
                this.forces.align = { x: alignment.x * params.alignment, y: alignment.y * params.alignment };
                this.forces.coh = { x: cohesion.x * params.cohesion, y: cohesion.y * params.cohesion };

                // Apply forces
                this.acc.x += this.forces.sep.x + this.forces.align.x + this.forces.coh.x;
                this.acc.y += this.forces.sep.y + this.forces.align.y + this.forces.coh.y;
            }

            limitForce(v) {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y);
                if (mag > params.maxForce) {
                    v.x = (v.x / mag) * params.maxForce;
                    v.y = (v.y / mag) * params.maxForce;
                }
            }

            update() {
                this.vel.x += this.acc.x;
                this.vel.y += this.acc.y;

                // Limit speed
                const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
                if (speed > params.maxSpeed) {
                    this.vel.x = (this.vel.x / speed) * params.maxSpeed;
                    this.vel.y = (this.vel.y / speed) * params.maxSpeed;
                }

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                this.acc = { x: 0, y: 0 };
            }

            draw() {
                const angle = Math.atan2(this.vel.y, this.vel.x);
                const size = 8;

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(angle);

                // Boid shape
                ctx.fillStyle = `hsl(${200 + this.neighbors * 5}, 70%, 60%)`;
                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(-size * 0.7, size * 0.5);
                ctx.lineTo(-size * 0.7, -size * 0.5);
                ctx.closePath();
                ctx.fill();

                ctx.restore();

                // Show perception radius
                if (params.showRadius) {
                    ctx.strokeStyle = 'rgba(52, 152, 219, 0.2)';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, params.perception, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Show force vectors
                if (params.showForces) {
                    const scale = 20;
                    // Separation (red)
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y);
                    ctx.lineTo(this.pos.x + this.forces.sep.x * scale, this.pos.y + this.forces.sep.y * scale);
                    ctx.stroke();

                    // Alignment (green)
                    ctx.strokeStyle = 'rgba(100, 255, 100, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y);
                    ctx.lineTo(this.pos.x + this.forces.align.x * scale, this.pos.y + this.forces.align.y * scale);
                    ctx.stroke();

                    // Cohesion (blue)
                    ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y);
                    ctx.lineTo(this.pos.x + this.forces.coh.x * scale, this.pos.y + this.forces.coh.y * scale);
                    ctx.stroke();
                }
            }
        }

        function init() {
            boids = [];
            trails = [];
            for (let i = 0; i < params.count; i++) {
                boids.push(new Boid(
                    Math.random() * width,
                    Math.random() * height
                ));
                trails.push([]);
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            init();
        }

        function animate() {
            if (!params.paused) {
                // Fade effect for trails
                ctx.fillStyle = params.showTrails ? 'rgba(10,10,26,0.1)' : 'rgba(10,10,26,1)';
                ctx.fillRect(0, 0, width, height);

                // Update boids
                for (let boid of boids) {
                    boid.flock(boids);
                }

                let totalSpeed = 0;
                let totalNeighbors = 0;

                for (let i = 0; i < boids.length; i++) {
                    boids[i].update();
                    boids[i].edges();
                    boids[i].draw();

                    totalSpeed += Math.sqrt(boids[i].vel.x ** 2 + boids[i].vel.y ** 2);
                    totalNeighbors += boids[i].neighbors;

                    // Update trails
                    if (params.showTrails) {
                        trails[i].push({ x: boids[i].pos.x, y: boids[i].pos.y });
                        if (trails[i].length > 30) trails[i].shift();
                    }
                }

                // Update stats
                document.getElementById('avgSpeed').textContent = (totalSpeed / boids.length).toFixed(2);
                document.getElementById('avgNeighbors').textContent = (totalNeighbors / boids.length).toFixed(1);
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resize);

        document.getElementById('boidCount').addEventListener('input', (e) => {
            params.count = parseInt(e.target.value);
            document.getElementById('countVal').textContent = params.count;
            init();
        });

        document.getElementById('separation').addEventListener('input', (e) => {
            params.separation = parseFloat(e.target.value);
            document.getElementById('sepVal').textContent = params.separation.toFixed(1);
        });

        document.getElementById('alignment').addEventListener('input', (e) => {
            params.alignment = parseFloat(e.target.value);
            document.getElementById('alignVal').textContent = params.alignment.toFixed(1);
        });

        document.getElementById('cohesion').addEventListener('input', (e) => {
            params.cohesion = parseFloat(e.target.value);
            document.getElementById('cohVal').textContent = params.cohesion.toFixed(1);
        });

        document.getElementById('perception').addEventListener('input', (e) => {
            params.perception = parseInt(e.target.value);
            document.getElementById('perceptVal').textContent = params.perception;
        });

        document.getElementById('maxSpeed').addEventListener('input', (e) => {
            params.maxSpeed = parseInt(e.target.value);
            document.getElementById('speedVal').textContent = params.maxSpeed;
        });

        document.getElementById('showForces').addEventListener('change', (e) => {
            params.showForces = e.target.checked;
        });

        document.getElementById('showRadius').addEventListener('change', (e) => {
            params.showRadius = e.target.checked;
        });

        document.getElementById('showTrails').addEventListener('change', (e) => {
            params.showTrails = e.target.checked;
        });

        document.getElementById('pauseSim').addEventListener('change', (e) => {
            params.paused = e.target.checked;
        });

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = init;

        // Initialize
        resize();
        animate();

        // Educational Panel
        new EduPanel('#edu-panel', {
            title: 'Boids Flocking',
            startOpen: false,
            tabs: [
                {
                    id: 'theory',
                    label: 'Theory',
                    content: `
                        <h4>What is Flocking?</h4>
                        <p>Boids (bird-oid objects) simulate flocking behavior using simple local rules. Created by Craig Reynolds in 1986, this demonstrates how complex group behavior emerges from simple individual rules.</p>

                        <div class="concept-card">
                            <h5>Emergence</h5>
                            <p>No boid knows about the flock's overall shape or direction. Global patterns emerge from local interactions - a hallmark of complex systems.</p>
                        </div>

                        <h4>The Three Rules</h4>

                        <div class="concept-card">
                            <h5>1. Separation</h5>
                            <p>Steer to avoid crowding local flockmates. Boids maintain a minimum distance from neighbors to prevent collisions.</p>
                            <code>Force ‚Üê away from close neighbors</code>
                        </div>

                        <div class="concept-card">
                            <h5>2. Alignment</h5>
                            <p>Steer towards the average heading of local flockmates. This creates coordinated movement direction.</p>
                            <code>Force ‚Üê (avg neighbor velocity) - self velocity</code>
                        </div>

                        <div class="concept-card">
                            <h5>3. Cohesion</h5>
                            <p>Steer to move toward the average position of local flockmates. This keeps the flock together.</p>
                            <code>Force ‚Üê (avg neighbor position) - self position</code>
                        </div>

                        <div class="concept-card">
                            <h5>Perception Radius</h5>
                            <p>Each boid only sees neighbors within a limited radius. This locality is key to emergence - global knowledge isn't required.</p>
                        </div>
                    `
                },
                {
                    id: 'algorithm',
                    label: 'Algorithm',
                    content: `
                        <h4>Boids Algorithm</h4>

                        <div class="steps">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Find Neighbors</strong>
                                    <p>For each boid, find all other boids within perception radius</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Calculate Forces</strong>
                                    <p>Compute separation, alignment, and cohesion steering forces</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Apply Weights</strong>
                                    <p>Multiply each force by its weight and sum them</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Update Velocity</strong>
                                    <p>Add acceleration to velocity, limit max speed</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Move</strong>
                                    <p>Update position by velocity, wrap at edges</p>
                                </div>
                            </div>
                        </div>

                        <h4>Pseudocode</h4>
                        <pre><code>function flock(boid, neighbors):
    sep = separation(boid, neighbors)
    align = alignment(boid, neighbors)
    coh = cohesion(boid, neighbors)

    # Weight and combine
    acceleration = sep * w_sep
                 + align * w_align
                 + coh * w_coh

    return acceleration

function separation(boid, neighbors):
    steer = (0, 0)
    for each neighbor too close:
        diff = boid.pos - neighbor.pos
        steer += diff / distance
    return normalize(steer) * maxSpeed - boid.vel

function alignment(boid, neighbors):
    avgVel = average of neighbor velocities
    return normalize(avgVel) * maxSpeed - boid.vel

function cohesion(boid, neighbors):
    center = average of neighbor positions
    return seek(center)</code></pre>

                        <div class="concept-card">
                            <h5>Steering Behaviors</h5>
                            <p>Forces are "steering" forces: they represent the desired change in velocity, not the desired velocity itself.</p>
                            <code>steering = desired_velocity - current_velocity</code>
                        </div>
                    `
                },
                {
                    id: 'applications',
                    label: 'Applications',
                    content: `
                        <h4>Real-World Applications</h4>

                        <div class="application">
                            <h5>üé¨ Visual Effects</h5>
                            <p>Used in movies for realistic crowd simulations: the stampede in "Lion King", bats in "Batman", and armies in "Lord of the Rings".</p>
                        </div>

                        <div class="application">
                            <h5>üéÆ Video Games</h5>
                            <p>NPC crowd behavior, enemy swarms, and ambient wildlife in games like "Half-Life 2", "Assassin's Creed", and most RTStrategies.</p>
                        </div>

                        <div class="application">
                            <h5>ü§ñ Robotics</h5>
                            <p>Drone swarm coordination, autonomous vehicle platoons, and warehouse robot navigation use boids-inspired algorithms.</p>
                        </div>

                        <div class="application">
                            <h5>üî¨ Biology Research</h5>
                            <p>Models help biologists understand fish schooling, bird flocking, and insect swarming. Used to test hypotheses about animal behavior.</p>
                        </div>

                        <div class="application">
                            <h5>üöó Traffic Flow</h5>
                            <p>Modified boids algorithms model traffic patterns, helping design highways and predict congestion.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Extensions</h5>
                            <ul>
                                <li><strong>Predators</strong>: Add flee behavior from threats</li>
                                <li><strong>Obstacles</strong>: Add avoidance steering</li>
                                <li><strong>Goals</strong>: Add seek/arrive behaviors</li>
                                <li><strong>3D</strong>: Same rules work in three dimensions</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'explore',
                    label: 'Explore',
                    content: `
                        <h4>Interactive Experiments</h4>

                        <div class="tutorial">
                            <h5>1. Separation Only</h5>
                            <p>Set Alignment and Cohesion to 0. Watch boids spread out and avoid each other like repelling magnets.</p>
                            <p><strong>Result:</strong> Dispersed, chaotic movement</p>
                        </div>

                        <div class="tutorial">
                            <h5>2. Alignment Only</h5>
                            <p>Set Separation and Cohesion to 0. Boids align their velocities but don't stay together.</p>
                            <p><strong>Result:</strong> Parallel streams that drift apart</p>
                        </div>

                        <div class="tutorial">
                            <h5>3. Cohesion Only</h5>
                            <p>Set Separation and Alignment to 0. Boids collapse toward group center.</p>
                            <p><strong>Result:</strong> Tight clump that rotates/oscillates</p>
                        </div>

                        <div class="tutorial">
                            <h5>4. Enable Force Visualization</h5>
                            <p>Check "Show Forces" to see the three steering forces on each boid:</p>
                            <ul>
                                <li>üî¥ Red = Separation</li>
                                <li>üü¢ Green = Alignment</li>
                                <li>üîµ Blue = Cohesion</li>
                            </ul>
                        </div>

                        <div class="tutorial">
                            <h5>5. Perception Radius</h5>
                            <p>Check "Show Radius" and adjust perception. Notice how larger radius creates more coordinated but slower-reacting flocks.</p>
                        </div>

                        <div class="tutorial">
                            <h5>6. High Separation + Low Cohesion</h5>
                            <p>Creates loose, spread-out formations like real bird flocks in flight.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Challenge</h5>
                            <p>Can you find parameter settings that create:</p>
                            <ul>
                                <li>A single tight school (like fish)?</li>
                                <li>Multiple separate groups?</li>
                                <li>A spinning vortex pattern?</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'references',
                    label: 'References',
                    content: `
                        <h4>Learn More</h4>

                        <div class="reference-list">
                            <a href="https://www.red3d.com/cwr/boids/" target="_blank">Craig Reynolds' Original Boids Page</a>
                            <a href="https://en.wikipedia.org/wiki/Boids" target="_blank">Wikipedia: Boids</a>
                            <a href="https://www.red3d.com/cwr/steer/" target="_blank">Steering Behaviors for Autonomous Characters</a>
                            <a href="https://natureofcode.com/book/chapter-6-autonomous-agents/" target="_blank">Nature of Code: Autonomous Agents</a>
                        </div>

                        <h4>Key Papers</h4>
                        <ul>
                            <li>Reynolds, C.W. (1987) - "Flocks, Herds, and Schools: A Distributed Behavioral Model"</li>
                            <li>Reynolds, C.W. (1999) - "Steering Behaviors For Autonomous Characters"</li>
                            <li>Vicsek et al. (1995) - "Novel Type of Phase Transition in a System of Self-Driven Particles"</li>
                        </ul>

                        <h4>Related Topics</h4>
                        <ul>
                            <li>Swarm Intelligence</li>
                            <li>Emergence & Self-Organization</li>
                            <li>Agent-Based Modeling</li>
                            <li>Collective Behavior</li>
                            <li>Particle Systems</li>
                        </ul>
                    `
                }
            ]
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
