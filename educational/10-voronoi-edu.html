<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Diagrams - Educational Demo</title>
    <link rel="stylesheet" href="../assets/css/edu-panel.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
            cursor: crosshair;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 200px;
        }
        .controls h3 {
            margin-bottom: 10px;
            color: #e74c3c;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-size: 11px;
            margin-bottom: 3px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group select {
            width: 100%;
            padding: 5px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #aaa;
        }
        .buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .buttons button {
            flex: 1;
            padding: 6px;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .buttons button:hover { background: #c0392b; }
        .stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            font-size: 10px;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #e74c3c;
            text-decoration: none;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(231,76,60,0.3); }
        .hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            color: #888;
        }
        /* Edu panel dark theme overrides */
        .edu-panel { background: rgba(20,20,35,0.95); }
        .edu-tab { background: #1a1a2e; color: #aaa; }
        .edu-tab.active { background: #e74c3c; color: #fff; }
        .edu-tab:hover:not(.active) { background: #2a2a4e; }
        .edu-content { color: #ccc; }
        .edu-content h4 { color: #e74c3c; }
        .concept-card { background: rgba(231,76,60,0.1); border-color: #e74c3c; }
        .step-number { background: #e74c3c; }
        code { background: rgba(231,76,60,0.2); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <div class="controls">
        <h3>Voronoi Diagrams</h3>

        <div class="control-group">
            <label>Number of Sites: <span id="countVal">50</span></label>
            <input type="range" id="siteCount" min="3" max="200" value="50">
        </div>

        <div class="control-group">
            <label>Distribution</label>
            <select id="distribution">
                <option value="random">Random</option>
                <option value="grid">Grid</option>
                <option value="poisson">Poisson Disc</option>
                <option value="clusters">Clusters</option>
                <option value="circle">Circle</option>
            </select>
        </div>

        <div class="control-group">
            <label>Coloring</label>
            <select id="coloring">
                <option value="random">Random Colors</option>
                <option value="distance">Distance Gradient</option>
                <option value="area">By Cell Area</option>
                <option value="neighbors">By Neighbor Count</option>
            </select>
        </div>

        <div class="checkbox-group">
            <label><input type="checkbox" id="showEdges" checked> Show edges</label>
            <label><input type="checkbox" id="showSites" checked> Show sites</label>
            <label><input type="checkbox" id="showDelaunay"> Show Delaunay</label>
            <label><input type="checkbox" id="animate"> Animate sites</label>
        </div>

        <div class="buttons">
            <button onclick="regenerate()">Regenerate</button>
            <button onclick="relaxLloyd()">Lloyd Relax</button>
        </div>

        <div class="stats">
            <div>Sites: <span id="siteStats">0</span></div>
            <div>Edges: <span id="edgeStats">0</span></div>
        </div>
    </div>

    <div class="hint">Click to add sites ‚Ä¢ Drag to move sites</div>

    <div id="edu-panel"></div>

    <script src="https://unpkg.com/d3-delaunay@6"></script>
    <script src="../assets/js/edu-panel.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let sites = [];
        let voronoi, delaunay;
        let colors = [];
        let siteCount = 50;
        let showEdges = true;
        let showSites = true;
        let showDelaunay = false;
        let animateSites = false;
        let colorMode = 'random';
        let velocities = [];

        // Dragging
        let dragIndex = -1;
        let isDragging = false;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            regenerate();
        }

        function generateSites(n, distribution) {
            sites = [];
            velocities = [];

            switch (distribution) {
                case 'random':
                    for (let i = 0; i < n; i++) {
                        sites.push([
                            Math.random() * width,
                            Math.random() * height
                        ]);
                    }
                    break;

                case 'grid':
                    const cols = Math.ceil(Math.sqrt(n * width / height));
                    const rows = Math.ceil(n / cols);
                    const cellW = width / cols;
                    const cellH = height / rows;
                    for (let y = 0; y < rows && sites.length < n; y++) {
                        for (let x = 0; x < cols && sites.length < n; x++) {
                            sites.push([
                                (x + 0.5) * cellW + (Math.random() - 0.5) * cellW * 0.3,
                                (y + 0.5) * cellH + (Math.random() - 0.5) * cellH * 0.3
                            ]);
                        }
                    }
                    break;

                case 'poisson':
                    // Simple Poisson disc sampling
                    const radius = Math.sqrt(width * height / n) * 0.8;
                    const grid = [];
                    const cellSize = radius / Math.sqrt(2);
                    const gridW = Math.ceil(width / cellSize);
                    const gridH = Math.ceil(height / cellSize);

                    sites.push([Math.random() * width, Math.random() * height]);
                    const active = [0];

                    while (active.length > 0 && sites.length < n) {
                        const idx = Math.floor(Math.random() * active.length);
                        const point = sites[active[idx]];
                        let found = false;

                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = radius + Math.random() * radius;
                            const newX = point[0] + Math.cos(angle) * dist;
                            const newY = point[1] + Math.sin(angle) * dist;

                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                let valid = true;
                                for (const s of sites) {
                                    const dx = s[0] - newX;
                                    const dy = s[1] - newY;
                                    if (dx * dx + dy * dy < radius * radius) {
                                        valid = false;
                                        break;
                                    }
                                }
                                if (valid) {
                                    sites.push([newX, newY]);
                                    active.push(sites.length - 1);
                                    found = true;
                                    break;
                                }
                            }
                        }

                        if (!found) {
                            active.splice(idx, 1);
                        }
                    }
                    break;

                case 'clusters':
                    const numClusters = Math.max(3, Math.floor(n / 10));
                    const centers = [];
                    for (let i = 0; i < numClusters; i++) {
                        centers.push([
                            width * 0.1 + Math.random() * width * 0.8,
                            height * 0.1 + Math.random() * height * 0.8
                        ]);
                    }
                    for (let i = 0; i < n; i++) {
                        const center = centers[Math.floor(Math.random() * numClusters)];
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * 100;
                        sites.push([
                            center[0] + Math.cos(angle) * r,
                            center[1] + Math.sin(angle) * r
                        ]);
                    }
                    break;

                case 'circle':
                    const cx = width / 2;
                    const cy = height / 2;
                    const maxR = Math.min(width, height) * 0.4;
                    for (let i = 0; i < n; i++) {
                        const angle = (i / n) * Math.PI * 2;
                        const r = maxR * (0.5 + Math.random() * 0.5);
                        sites.push([
                            cx + Math.cos(angle) * r,
                            cy + Math.sin(angle) * r
                        ]);
                    }
                    break;
            }

            // Initialize velocities for animation
            for (let i = 0; i < sites.length; i++) {
                velocities.push([
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ]);
            }

            // Generate colors
            generateColors();
        }

        function generateColors() {
            colors = sites.map((_, i) => {
                const hue = (i * 137.5) % 360; // Golden angle
                return `hsl(${hue}, 70%, 50%)`;
            });
        }

        function computeVoronoi() {
            if (sites.length < 3) return;

            const flatPoints = sites.flat();
            delaunay = new d3.Delaunay(flatPoints);
            voronoi = delaunay.voronoi([0, 0, width, height]);
        }

        function getCellColor(i) {
            if (!voronoi) return colors[i];

            switch (colorMode) {
                case 'random':
                    return colors[i];

                case 'distance': {
                    // Distance from center
                    const dx = sites[i][0] - width / 2;
                    const dy = sites[i][1] - height / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = Math.sqrt(width * width + height * height) / 2;
                    const hue = (dist / maxDist) * 240;
                    return `hsl(${hue}, 70%, 50%)`;
                }

                case 'area': {
                    // Cell area
                    const cell = voronoi.cellPolygon(i);
                    if (!cell) return colors[i];
                    let area = 0;
                    for (let j = 0; j < cell.length - 1; j++) {
                        area += cell[j][0] * cell[j + 1][1];
                        area -= cell[j + 1][0] * cell[j][1];
                    }
                    area = Math.abs(area) / 2;
                    const avgArea = (width * height) / sites.length;
                    const ratio = Math.min(2, area / avgArea);
                    const hue = (1 - ratio / 2) * 120;
                    return `hsl(${hue}, 70%, 50%)`;
                }

                case 'neighbors': {
                    // Number of neighbors
                    const neighbors = voronoi.neighbors(i);
                    let count = 0;
                    for (const _ of neighbors) count++;
                    const hue = (count - 3) * 40;
                    return `hsl(${hue}, 70%, 50%)`;
                }

                default:
                    return colors[i];
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            if (!voronoi || sites.length < 3) return;

            // Draw filled cells
            for (let i = 0; i < sites.length; i++) {
                const cell = voronoi.cellPolygon(i);
                if (!cell) continue;

                ctx.fillStyle = getCellColor(i);
                ctx.beginPath();
                ctx.moveTo(cell[0][0], cell[0][1]);
                for (let j = 1; j < cell.length; j++) {
                    ctx.lineTo(cell[j][0], cell[j][1]);
                }
                ctx.closePath();
                ctx.fill();
            }

            // Draw Delaunay triangulation
            if (showDelaunay) {
                ctx.strokeStyle = 'rgba(46, 204, 113, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                delaunay.render(ctx);
                ctx.stroke();
            }

            // Draw Voronoi edges
            if (showEdges) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                voronoi.render(ctx);
                ctx.stroke();
            }

            // Draw sites
            if (showSites) {
                ctx.fillStyle = '#fff';
                for (const site of sites) {
                    ctx.beginPath();
                    ctx.arc(site[0], site[1], 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Update stats
            document.getElementById('siteStats').textContent = sites.length;
            document.getElementById('edgeStats').textContent =
                voronoi ? Math.floor(delaunay.triangles.length / 3) : 0;
        }

        function regenerate() {
            const distribution = document.getElementById('distribution').value;
            generateSites(siteCount, distribution);
            computeVoronoi();
            draw();
        }

        function relaxLloyd() {
            // Lloyd's relaxation: move each site to centroid of its cell
            if (!voronoi) return;

            const newSites = [];
            for (let i = 0; i < sites.length; i++) {
                const cell = voronoi.cellPolygon(i);
                if (!cell || cell.length < 3) {
                    newSites.push(sites[i]);
                    continue;
                }

                // Compute centroid
                let cx = 0, cy = 0, area = 0;
                for (let j = 0; j < cell.length - 1; j++) {
                    const cross = cell[j][0] * cell[j + 1][1] - cell[j + 1][0] * cell[j][1];
                    area += cross;
                    cx += (cell[j][0] + cell[j + 1][0]) * cross;
                    cy += (cell[j][1] + cell[j + 1][1]) * cross;
                }
                area /= 2;
                cx /= (6 * area);
                cy /= (6 * area);

                newSites.push([cx, cy]);
            }

            sites = newSites;
            computeVoronoi();
            draw();
        }

        function animate() {
            if (animateSites) {
                // Move sites
                for (let i = 0; i < sites.length; i++) {
                    sites[i][0] += velocities[i][0];
                    sites[i][1] += velocities[i][1];

                    // Bounce off walls
                    if (sites[i][0] < 0 || sites[i][0] > width) velocities[i][0] *= -1;
                    if (sites[i][1] < 0 || sites[i][1] > height) velocities[i][1] *= -1;

                    sites[i][0] = Math.max(0, Math.min(width, sites[i][0]));
                    sites[i][1] = Math.max(0, Math.min(height, sites[i][1]));
                }

                computeVoronoi();
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Event handlers
        canvas.addEventListener('click', (e) => {
            if (!isDragging) {
                sites.push([e.clientX, e.clientY]);
                velocities.push([(Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2]);
                colors.push(`hsl(${Math.random() * 360}, 70%, 50%)`);
                computeVoronoi();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            for (let i = 0; i < sites.length; i++) {
                const dx = sites[i][0] - e.clientX;
                const dy = sites[i][1] - e.clientY;
                if (dx * dx + dy * dy < 100) {
                    dragIndex = i;
                    isDragging = true;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && dragIndex >= 0) {
                sites[dragIndex] = [e.clientX, e.clientY];
                computeVoronoi();
            }
        });

        canvas.addEventListener('mouseup', () => {
            setTimeout(() => { isDragging = false; }, 50);
            dragIndex = -1;
        });

        document.getElementById('siteCount').addEventListener('input', (e) => {
            siteCount = parseInt(e.target.value);
            document.getElementById('countVal').textContent = siteCount;
            regenerate();
        });

        document.getElementById('distribution').addEventListener('change', regenerate);

        document.getElementById('coloring').addEventListener('change', (e) => {
            colorMode = e.target.value;
        });

        document.getElementById('showEdges').addEventListener('change', (e) => {
            showEdges = e.target.checked;
        });

        document.getElementById('showSites').addEventListener('change', (e) => {
            showSites = e.target.checked;
        });

        document.getElementById('showDelaunay').addEventListener('change', (e) => {
            showDelaunay = e.target.checked;
        });

        document.getElementById('animate').addEventListener('change', (e) => {
            animateSites = e.target.checked;
        });

        window.addEventListener('resize', resize);

        // Initialize
        resize();
        animate();

        // Educational Panel
        new EduPanel('#edu-panel', {
            title: 'Voronoi Diagrams',
            startOpen: false,
            tabs: [
                {
                    id: 'theory',
                    label: 'Theory',
                    content: `
                        <h4>What is a Voronoi Diagram?</h4>
                        <p>A Voronoi diagram partitions space into regions based on distance to a set of points (sites). Each region contains all points closest to one particular site.</p>

                        <div class="concept-card">
                            <h5>Definition</h5>
                            <p>For a set of sites S = {s‚ÇÅ, s‚ÇÇ, ...}, the Voronoi cell of s·µ¢ is:</p>
                            <code>V(s·µ¢) = {x : d(x, s·µ¢) ‚â§ d(x, s‚±º) ‚àÄj}</code>
                            <p>All points x closer to s·µ¢ than to any other site.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Delaunay Triangulation</h5>
                            <p>The dual graph of a Voronoi diagram. Connect sites whose Voronoi cells share an edge. Forms a triangulation with special properties:</p>
                            <ul>
                                <li>Maximizes minimum angle (avoids skinny triangles)</li>
                                <li>Circumcircle of each triangle contains no other sites</li>
                            </ul>
                        </div>

                        <div class="concept-card">
                            <h5>Properties</h5>
                            <ul>
                                <li>Edges are perpendicular bisectors of site pairs</li>
                                <li>Vertices are equidistant from 3+ sites</li>
                                <li>Number of edges: O(n) for n sites</li>
                                <li>Average neighbors: ~6 (Euler's formula)</li>
                            </ul>
                        </div>

                        <div class="concept-card">
                            <h5>Lloyd's Relaxation</h5>
                            <p>Move each site to its cell's centroid, recompute. Produces more uniform distributions. Converges to centroidal Voronoi tessellation.</p>
                        </div>
                    `
                },
                {
                    id: 'algorithm',
                    label: 'Algorithm',
                    content: `
                        <h4>Fortune's Algorithm</h4>
                        <p>Efficient O(n log n) sweep line algorithm for Voronoi computation.</p>

                        <div class="steps">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Sweep Line</strong>
                                    <p>Move horizontal line from top to bottom</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Beach Line</strong>
                                    <p>Track parabolic arcs above sweep line</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Site Events</strong>
                                    <p>Add new arc when sweep reaches site</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Circle Events</strong>
                                    <p>Arc disappears when squeezed ‚Üí Voronoi vertex</p>
                                </div>
                            </div>
                        </div>

                        <h4>Delaunay via Convex Hull</h4>
                        <pre><code>// Lift to 3D paraboloid
for each point (x, y):
    lift to (x, y, x¬≤ + y¬≤)

// Compute 3D convex hull
hull = convex_hull_3d(lifted_points)

// Project lower hull faces back
for each downward-facing face:
    add triangle to Delaunay</code></pre>

                        <div class="concept-card">
                            <h5>Complexity</h5>
                            <ul>
                                <li><strong>Fortune's</strong>: O(n log n) time, O(n) space</li>
                                <li><strong>Incremental</strong>: O(n¬≤) worst, O(n log n) expected</li>
                                <li><strong>Divide & Conquer</strong>: O(n log n)</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'applications',
                    label: 'Applications',
                    content: `
                        <h4>Real-World Applications</h4>

                        <div class="application">
                            <h5>üìç Nearest Neighbor Queries</h5>
                            <p>Find closest facility: hospitals, stores, fire stations. Used in GIS and logistics.</p>
                        </div>

                        <div class="application">
                            <h5>üéÆ Game Development</h5>
                            <p>Procedural map generation, territory systems, AI pathfinding, and mesh generation.</p>
                        </div>

                        <div class="application">
                            <h5>üî¨ Materials Science</h5>
                            <p>Crystal grain boundaries, foam structures, and metallurgy analysis.</p>
                        </div>

                        <div class="application">
                            <h5>üåê Network Design</h5>
                            <p>Cell tower coverage, sensor networks, and service area optimization.</p>
                        </div>

                        <div class="application">
                            <h5>üé® Art & Design</h5>
                            <p>Stained glass patterns, mosaic generation, and generative art.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Nature's Voronoi</h5>
                            <ul>
                                <li>Giraffe skin patterns</li>
                                <li>Dragonfly wings</li>
                                <li>Honeycomb (hexagonal Voronoi)</li>
                                <li>Soap bubbles</li>
                                <li>Crack patterns in dried mud</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'explore',
                    label: 'Explore',
                    content: `
                        <h4>Interactive Experiments</h4>

                        <div class="tutorial">
                            <h5>1. Click to Add Sites</h5>
                            <p>Click anywhere to add new sites. Watch the diagram instantly reorganize. Each new site "claims" space from its neighbors.</p>
                        </div>

                        <div class="tutorial">
                            <h5>2. Drag to Move</h5>
                            <p>Click and drag sites to see how the diagram changes continuously.</p>
                        </div>

                        <div class="tutorial">
                            <h5>3. Delaunay Dual</h5>
                            <p>Enable "Show Delaunay". Notice how Delaunay edges connect sites whose Voronoi cells share an edge. They're mathematical duals!</p>
                        </div>

                        <div class="tutorial">
                            <h5>4. Lloyd's Relaxation</h5>
                            <p>Click "Lloyd Relax" repeatedly. Watch sites move to cell centroids, creating more regular hexagonal patterns.</p>
                        </div>

                        <div class="tutorial">
                            <h5>5. Distribution Effects</h5>
                            <p>Try different distributions:</p>
                            <ul>
                                <li><strong>Poisson</strong>: Even spacing, natural look</li>
                                <li><strong>Clusters</strong>: Uneven cell sizes</li>
                                <li><strong>Grid</strong>: Nearly square cells</li>
                            </ul>
                        </div>

                        <div class="concept-card">
                            <h5>Color By...</h5>
                            <ul>
                                <li><strong>Distance</strong>: Radial gradient from center</li>
                                <li><strong>Area</strong>: Large cells red, small cells green</li>
                                <li><strong>Neighbors</strong>: Count of adjacent cells</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'references',
                    label: 'References',
                    content: `
                        <h4>Learn More</h4>

                        <div class="reference-list">
                            <a href="https://en.wikipedia.org/wiki/Voronoi_diagram" target="_blank">Wikipedia: Voronoi Diagram</a>
                            <a href="https://www.youtube.com/watch?v=8tP4eS04Jig" target="_blank">Reducible: Voronoi Diagrams</a>
                            <a href="https://observablehq.com/@d3/voronoi" target="_blank">D3.js Voronoi Examples</a>
                            <a href="https://en.wikipedia.org/wiki/Fortune%27s_algorithm" target="_blank">Fortune's Algorithm</a>
                        </div>

                        <h4>Key Figures</h4>
                        <ul>
                            <li><strong>Georgy Voronoi</strong> (1908) - Formalized the diagram</li>
                            <li><strong>Boris Delaunay</strong> (1934) - Dual triangulation</li>
                            <li><strong>Steven Fortune</strong> (1987) - Efficient sweep algorithm</li>
                        </ul>

                        <h4>Related Topics</h4>
                        <ul>
                            <li>Computational Geometry</li>
                            <li>Delaunay Triangulation</li>
                            <li>Convex Hulls</li>
                            <li>Nearest Neighbor Search</li>
                            <li>Tessellation</li>
                        </ul>
                    `
                }
            ]
        });
    </script>
</body>
</html>
