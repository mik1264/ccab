<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Set - Educational Demo</title>
    <link rel="stylesheet" href="../assets/css/edu-panel.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
            cursor: crosshair;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 200px;
        }
        .controls h3 {
            margin-bottom: 10px;
            color: #9b59b6;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 3px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group select {
            width: 100%;
            padding: 5px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 11px;
            color: #888;
        }
        .info div { margin-bottom: 3px; }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #9b59b6;
            text-decoration: none;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(155,89,182,0.3); }
        .zoom-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            color: #888;
        }
        /* Edu panel dark theme overrides */
        .edu-panel { background: rgba(20,20,30,0.95); }
        .edu-tab { background: #1a1a2e; color: #aaa; }
        .edu-tab.active { background: #9b59b6; color: #fff; }
        .edu-tab:hover:not(.active) { background: #2a2a4e; }
        .edu-content { color: #ccc; }
        .edu-content h4 { color: #9b59b6; }
        .concept-card { background: rgba(155,89,182,0.1); border-color: #9b59b6; }
        .step-number { background: #9b59b6; }
        code { background: rgba(155,89,182,0.2); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <div class="controls">
        <h3>Mandelbrot Set</h3>
        <div class="control-group">
            <label>Max Iterations: <span id="iterVal">100</span></label>
            <input type="range" id="iterations" min="50" max="500" value="100">
        </div>
        <div class="control-group">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="classic">Classic</option>
                <option value="fire">Fire</option>
                <option value="ocean">Ocean</option>
                <option value="rainbow">Rainbow</option>
                <option value="grayscale">Grayscale</option>
            </select>
        </div>
        <div class="control-group">
            <label>
                <input type="checkbox" id="showOrbit"> Show orbit
            </label>
        </div>
        <button onclick="reset()" style="width:100%;padding:8px;margin-top:10px;background:#9b59b6;color:#fff;border:none;border-radius:4px;cursor:pointer;">Reset View</button>
        <div class="info">
            <div>Center: <span id="centerInfo">0, 0</span></div>
            <div>Zoom: <span id="zoomInfo">1x</span></div>
            <div>Click to zoom in, Shift+click to zoom out</div>
        </div>
    </div>

    <div class="zoom-hint">Click to zoom ‚Ä¢ Shift+Click to zoom out ‚Ä¢ Drag to pan</div>

    <div id="edu-panel"></div>

    <script src="../assets/js/edu-panel.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let imageData;

        // View parameters
        let centerX = -0.5;
        let centerY = 0;
        let zoom = 1;
        let maxIter = 100;
        let colorScheme = 'classic';
        let showOrbit = false;

        // Orbit tracking
        let orbitPoints = [];
        let hoverX = null, hoverY = null;

        // Drag state
        let isDragging = false;
        let dragStartX, dragStartY;
        let dragCenterX, dragCenterY;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            imageData = ctx.createImageData(width, height);
            render();
        }

        // Map pixel to complex plane
        function pixelToComplex(px, py) {
            const scale = 4 / (zoom * Math.min(width, height));
            return {
                re: centerX + (px - width/2) * scale,
                im: centerY + (py - height/2) * scale
            };
        }

        // Mandelbrot iteration
        function mandelbrot(cRe, cIm) {
            let zRe = 0, zIm = 0;
            let zRe2 = 0, zIm2 = 0;
            let iter = 0;

            while (zRe2 + zIm2 <= 4 && iter < maxIter) {
                zIm = 2 * zRe * zIm + cIm;
                zRe = zRe2 - zIm2 + cRe;
                zRe2 = zRe * zRe;
                zIm2 = zIm * zIm;
                iter++;
            }

            // Smooth coloring
            if (iter < maxIter) {
                const log_zn = Math.log(zRe2 + zIm2) / 2;
                const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                iter = iter + 1 - nu;
            }

            return iter;
        }

        // Compute orbit for educational visualization
        function computeOrbit(cRe, cIm, maxSteps = 50) {
            const orbit = [{re: 0, im: 0}];
            let zRe = 0, zIm = 0;

            for (let i = 0; i < maxSteps; i++) {
                const newRe = zRe * zRe - zIm * zIm + cRe;
                const newIm = 2 * zRe * zIm + cIm;
                zRe = newRe;
                zIm = newIm;
                orbit.push({re: zRe, im: zIm});
                if (zRe * zRe + zIm * zIm > 4) break;
            }

            return orbit;
        }

        // Color mapping
        function getColor(iter) {
            if (iter >= maxIter) return [0, 0, 0];

            const t = iter / maxIter;

            switch(colorScheme) {
                case 'fire':
                    return [
                        Math.floor(Math.min(255, iter * 5)),
                        Math.floor(Math.min(255, iter * 2)),
                        Math.floor(iter * 0.5)
                    ];
                case 'ocean':
                    return [
                        Math.floor(Math.sin(t * Math.PI) * 100),
                        Math.floor(Math.sin(t * Math.PI * 2) * 150 + 100),
                        Math.floor(200 + 55 * Math.sin(t * Math.PI))
                    ];
                case 'rainbow':
                    const h = t * 360;
                    return hslToRgb(h, 100, 50);
                case 'grayscale':
                    const g = Math.floor(255 * Math.sqrt(t));
                    return [g, g, g];
                default: // classic
                    return [
                        Math.floor(9 * (1-t) * t * t * t * 255),
                        Math.floor(15 * (1-t) * (1-t) * t * t * 255),
                        Math.floor(8.5 * (1-t) * (1-t) * (1-t) * t * 255)
                    ];
            }
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c/2;
            let r, g, b;

            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return [
                Math.floor((r + m) * 255),
                Math.floor((g + m) * 255),
                Math.floor((b + m) * 255)
            ];
        }

        function render() {
            const data = imageData.data;
            const scale = 4 / (zoom * Math.min(width, height));

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const cRe = centerX + (px - width/2) * scale;
                    const cIm = centerY + (py - height/2) * scale;

                    const iter = mandelbrot(cRe, cIm);
                    const [r, g, b] = getColor(iter);

                    const idx = (py * width + px) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw orbit if enabled
            if (showOrbit && orbitPoints.length > 0) {
                drawOrbit();
            }

            updateInfo();
        }

        function drawOrbit() {
            const scale = 4 / (zoom * Math.min(width, height));

            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < orbitPoints.length; i++) {
                const px = width/2 + (orbitPoints[i].re - centerX) / scale;
                const py = height/2 + (orbitPoints[i].im - centerY) / scale;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw points
            ctx.fillStyle = 'rgba(255, 255, 0, 1)';
            for (let i = 0; i < orbitPoints.length; i++) {
                const px = width/2 + (orbitPoints[i].re - centerX) / scale;
                const py = height/2 + (orbitPoints[i].im - centerY) / scale;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateInfo() {
            document.getElementById('centerInfo').textContent =
                `${centerX.toFixed(6)}, ${centerY.toFixed(6)}`;
            document.getElementById('zoomInfo').textContent =
                zoom >= 1000000 ? zoom.toExponential(2) + 'x' : Math.floor(zoom) + 'x';
        }

        function reset() {
            centerX = -0.5;
            centerY = 0;
            zoom = 1;
            render();
        }

        // Event handlers
        canvas.addEventListener('click', (e) => {
            const c = pixelToComplex(e.clientX, e.clientY);
            centerX = c.re;
            centerY = c.im;

            if (e.shiftKey) {
                zoom /= 2;
            } else {
                zoom *= 2;
            }
            render();
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !e.shiftKey) {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragCenterX = centerX;
                dragCenterY = centerY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const scale = 4 / (zoom * Math.min(width, height));
                centerX = dragCenterX - (e.clientX - dragStartX) * scale;
                centerY = dragCenterY - (e.clientY - dragStartY) * scale;
                render();
            } else if (showOrbit) {
                const c = pixelToComplex(e.clientX, e.clientY);
                orbitPoints = computeOrbit(c.re, c.im);
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const c = pixelToComplex(e.clientX, e.clientY);

            if (e.deltaY < 0) {
                zoom *= 1.5;
            } else {
                zoom /= 1.5;
            }

            // Zoom toward cursor
            const factor = e.deltaY < 0 ? 0.33 : -0.5;
            centerX += (c.re - centerX) * factor;
            centerY += (c.im - centerY) * factor;

            render();
        });

        // Controls
        document.getElementById('iterations').addEventListener('input', (e) => {
            maxIter = parseInt(e.target.value);
            document.getElementById('iterVal').textContent = maxIter;
            render();
        });

        document.getElementById('colorScheme').addEventListener('change', (e) => {
            colorScheme = e.target.value;
            render();
        });

        document.getElementById('showOrbit').addEventListener('change', (e) => {
            showOrbit = e.target.checked;
            if (!showOrbit) orbitPoints = [];
            render();
        });

        window.addEventListener('resize', resize);

        // Initialize
        resize();

        // Educational Panel
        new EduPanel('#edu-panel', {
            title: 'Mandelbrot Set',
            startOpen: false,
            tabs: [
                {
                    id: 'theory',
                    label: 'Theory',
                    content: `
                        <h4>What is the Mandelbrot Set?</h4>
                        <p>The Mandelbrot set is a famous fractal defined by a simple iteration in the complex plane. It reveals infinite complexity from a remarkably simple rule.</p>

                        <div class="concept-card">
                            <h5>The Iteration</h5>
                            <p>For each complex number c, we iterate:</p>
                            <code>z<sub>n+1</sub> = z<sub>n</sub>¬≤ + c</code>
                            <p>Starting with z‚ÇÄ = 0. The Mandelbrot set is all values of c for which z remains bounded (|z| ‚â§ 2).</p>
                        </div>

                        <div class="concept-card">
                            <h5>Complex Numbers</h5>
                            <p>A complex number c = a + bi has:</p>
                            <ul>
                                <li><strong>Real part (a)</strong>: horizontal axis</li>
                                <li><strong>Imaginary part (b)</strong>: vertical axis</li>
                            </ul>
                            <p>Squaring: (a + bi)¬≤ = a¬≤ - b¬≤ + 2abi</p>
                        </div>

                        <div class="concept-card">
                            <h5>Escape Time Algorithm</h5>
                            <p>Points outside the set "escape" to infinity. The color represents how quickly a point escapes (number of iterations before |z| > 2).</p>
                        </div>

                        <div class="concept-card">
                            <h5>Self-Similarity</h5>
                            <p>The Mandelbrot set contains infinitely many copies of itself at smaller scales. Each bulb and tendril contains miniature Mandelbrot sets when magnified.</p>
                        </div>
                    `
                },
                {
                    id: 'algorithm',
                    label: 'Algorithm',
                    content: `
                        <h4>Escape Time Algorithm</h4>

                        <div class="steps">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Map Pixel to Complex</strong>
                                    <p>Convert screen coordinates (px, py) to complex number c = (re, im)</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Initialize</strong>
                                    <p>Set z = 0 + 0i, iteration counter = 0</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Iterate</strong>
                                    <p>Compute z = z¬≤ + c until |z| > 2 or max iterations reached</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Color</strong>
                                    <p>Map iteration count to color (black = in set)</p>
                                </div>
                            </div>
                        </div>

                        <h4>Pseudocode</h4>
                        <pre><code>function mandelbrot(c_re, c_im, max_iter):
    z_re = 0
    z_im = 0
    iter = 0

    while z_re¬≤ + z_im¬≤ ‚â§ 4 and iter < max_iter:
        # z = z¬≤ + c
        new_re = z_re¬≤ - z_im¬≤ + c_re
        new_im = 2¬∑z_re¬∑z_im + c_im

        z_re = new_re
        z_im = new_im
        iter++

    return iter</code></pre>

                        <div class="concept-card">
                            <h5>Smooth Coloring</h5>
                            <p>Basic escape time creates color banding. Smooth coloring interpolates:</p>
                            <code>smooth = iter + 1 - log(log|z|)/log(2)</code>
                        </div>

                        <div class="concept-card">
                            <h5>Optimizations</h5>
                            <ul>
                                <li><strong>Cardioid check</strong>: Skip iteration for main cardioid</li>
                                <li><strong>Period checking</strong>: Detect cycles early</li>
                                <li><strong>GPU rendering</strong>: Parallelize per-pixel</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'applications',
                    label: 'Applications',
                    content: `
                        <h4>Real-World Applications</h4>

                        <div class="application">
                            <h5>üé® Art & Design</h5>
                            <p>Fractal art, album covers, architectural patterns, and procedural textures in games and movies.</p>
                        </div>

                        <div class="application">
                            <h5>üì° Antenna Design</h5>
                            <p>Fractal antennas (based on related fractals) provide wideband reception in compact form factors - used in cell phones.</p>
                        </div>

                        <div class="application">
                            <h5>üîê Encryption</h5>
                            <p>Fractal-based image encryption algorithms use the chaotic nature of iterations for secure encoding.</p>
                        </div>

                        <div class="application">
                            <h5>üìä Complex Analysis</h5>
                            <p>The Mandelbrot set is a key object in complex dynamics, connecting Julia sets, polynomial iteration, and holomorphic dynamics.</p>
                        </div>

                        <div class="application">
                            <h5>üß™ Physics Connections</h5>
                            <p>Related to phase transitions, bifurcation diagrams, and period-doubling routes to chaos in dynamical systems.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Mathematical Significance</h5>
                            <p>The Mandelbrot set is:</p>
                            <ul>
                                <li>Connected (proven in 1982)</li>
                                <li>Has fractal boundary dimension ‚âà 2</li>
                                <li>Contains all possible Julia set shapes</li>
                                <li>Universal object in complex dynamics</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'explore',
                    label: 'Explore',
                    content: `
                        <h4>Guided Explorations</h4>

                        <div class="tutorial">
                            <h5>1. The Main Cardioid</h5>
                            <p>The large heart-shaped region contains all c values where the iteration converges to a single fixed point. Points here are definitely in the set.</p>
                            <p><strong>Try:</strong> Enable "Show orbit" and hover over points inside the cardioid to see orbits converging.</p>
                        </div>

                        <div class="tutorial">
                            <h5>2. Period-2 Bulb</h5>
                            <p>The large circular bulb to the left contains points with period-2 cycles (alternating between two values).</p>
                            <p><strong>Try:</strong> Click to zoom into the junction between the cardioid and this bulb.</p>
                        </div>

                        <div class="tutorial">
                            <h5>3. Seahorse Valley</h5>
                            <p>Zoom to approximately (-0.75, 0.1). This region contains beautiful spiral structures resembling seahorse tails.</p>
                            <p><strong>Try:</strong> Increase iterations to 300+ for more detail.</p>
                        </div>

                        <div class="tutorial">
                            <h5>4. Mini Mandelbrots</h5>
                            <p>Zoom deep into any tendril or antenna. You'll find tiny copies of the entire Mandelbrot set!</p>
                            <p><strong>Try:</strong> Zoom into the spike at (-1.75, 0). Use high iterations.</p>
                        </div>

                        <div class="tutorial">
                            <h5>5. The Julia Connection</h5>
                            <p>Each point c in the complex plane has an associated Julia set. Points inside the Mandelbrot set produce connected Julia sets.</p>
                            <p><strong>Try:</strong> Enable orbit view and notice how orbits behave differently inside vs. outside the set.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Famous Coordinates</h5>
                            <ul>
                                <li><strong>Seahorse Valley:</strong> (-0.745, 0.113)</li>
                                <li><strong>Elephant Valley:</strong> (0.275, 0.006)</li>
                                <li><strong>Double Spiral:</strong> (-0.1015, 0.633)</li>
                                <li><strong>Mini Mandelbrot:</strong> (-1.768, 0.001)</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'references',
                    label: 'References',
                    content: `
                        <h4>Learn More</h4>

                        <div class="reference-list">
                            <a href="https://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank">Wikipedia: Mandelbrot Set</a>
                            <a href="https://www.youtube.com/watch?v=NGMRB4O922I" target="_blank">Numberphile: Mandelbrot Set</a>
                            <a href="https://mathworld.wolfram.com/MandelbrotSet.html" target="_blank">MathWorld: Mandelbrot Set</a>
                            <a href="https://www.shadertoy.com/results?query=mandelbrot" target="_blank">Shadertoy: Mandelbrot Shaders</a>
                        </div>

                        <h4>Key Papers</h4>
                        <ul>
                            <li>Mandelbrot, B.B. (1980) - "Fractal aspects of the iteration of z ‚Üí Œªz(1-z)"</li>
                            <li>Douady & Hubbard (1982) - Proving connectivity of the set</li>
                            <li>Shishikura (1998) - Boundary dimension = 2</li>
                        </ul>

                        <h4>Related Topics</h4>
                        <ul>
                            <li>Julia Sets</li>
                            <li>Complex Dynamics</li>
                            <li>Fractal Geometry</li>
                            <li>Chaos Theory</li>
                            <li>Renormalization</li>
                        </ul>
                    `
                }
            ]
        });
    </script>
</body>
</html>
