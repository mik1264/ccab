<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life - Educational Demo</title>
    <link rel="stylesheet" href="../assets/css/edu-panel.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0f0f23;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            display: block;
            cursor: crosshair;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 200px;
        }
        .controls h3 {
            margin-bottom: 10px;
            color: #2ecc71;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 3px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group select {
            width: 100%;
            padding: 5px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .buttons button {
            flex: 1;
            padding: 8px;
            background: #2ecc71;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .buttons button:hover { background: #27ae60; }
        .buttons button.pause { background: #e74c3c; }
        .buttons button.pause:hover { background: #c0392b; }
        .stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            font-size: 11px;
            color: #888;
        }
        .stats div { margin-bottom: 3px; }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #2ecc71;
            text-decoration: none;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(46,204,113,0.3); }
        /* Edu panel dark theme overrides */
        .edu-panel { background: rgba(15,15,35,0.95); }
        .edu-tab { background: #1a1a2e; color: #aaa; }
        .edu-tab.active { background: #2ecc71; color: #fff; }
        .edu-tab:hover:not(.active) { background: #2a2a4e; }
        .edu-content { color: #ccc; }
        .edu-content h4 { color: #2ecc71; }
        .concept-card { background: rgba(46,204,113,0.1); border-color: #2ecc71; }
        .step-number { background: #2ecc71; }
        code { background: rgba(46,204,113,0.2); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <div class="controls">
        <h3>Game of Life</h3>

        <div class="control-group">
            <label>Speed: <span id="speedVal">10</span> gen/s</label>
            <input type="range" id="speed" min="1" max="60" value="10">
        </div>

        <div class="control-group">
            <label>Cell Size: <span id="sizeVal">8</span>px</label>
            <input type="range" id="cellSize" min="2" max="20" value="8">
        </div>

        <div class="control-group">
            <label>Initial Pattern</label>
            <select id="pattern">
                <option value="random">Random (25%)</option>
                <option value="glider">Glider</option>
                <option value="glider-gun">Gosper Glider Gun</option>
                <option value="pulsar">Pulsar</option>
                <option value="pentadecathlon">Pentadecathlon</option>
                <option value="acorn">Acorn (Methuselah)</option>
                <option value="r-pentomino">R-Pentomino</option>
                <option value="empty">Empty Grid</option>
            </select>
        </div>

        <div class="buttons">
            <button id="playPause">‚è∏ Pause</button>
            <button onclick="step()">Step</button>
        </div>
        <div class="buttons">
            <button onclick="resetGrid()">Reset</button>
            <button onclick="clearGrid()">Clear</button>
        </div>

        <div class="stats">
            <div>Generation: <span id="generation">0</span></div>
            <div>Population: <span id="population">0</span></div>
            <div>Density: <span id="density">0</span>%</div>
        </div>
    </div>

    <div id="edu-panel"></div>

    <script src="../assets/js/edu-panel.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let cols, rows;
        let grid, nextGrid;
        let cellSize = 8;
        let running = true;
        let generation = 0;
        let lastUpdate = 0;
        let updateInterval = 100;

        // Patterns
        const patterns = {
            glider: [[0,1,0],[0,0,1],[1,1,1]],
            pulsar: [
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0]
            ],
            pentadecathlon: [
                [0,1,0],
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [0,1,0],
                [0,1,0],
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [0,1,0]
            ],
            acorn: [[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[1,1,0,0,1,1,1]],
            'r-pentomino': [[0,1,1],[1,1,0],[0,1,0]],
            'glider-gun': [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ]
        };

        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            cols = Math.floor(width / cellSize);
            rows = Math.floor(height / cellSize);

            resetGrid();
        }

        function createGrid() {
            return new Uint8Array(cols * rows);
        }

        function resetGrid() {
            grid = createGrid();
            nextGrid = createGrid();
            generation = 0;

            const patternName = document.getElementById('pattern').value;
            if (patternName === 'random') {
                for (let i = 0; i < grid.length; i++) {
                    grid[i] = Math.random() < 0.25 ? 1 : 0;
                }
            } else if (patternName === 'empty') {
                // Leave empty
            } else if (patterns[patternName]) {
                placePattern(patterns[patternName], Math.floor(cols/2), Math.floor(rows/2));
            }
        }

        function clearGrid() {
            grid = createGrid();
            nextGrid = createGrid();
            generation = 0;
        }

        function placePattern(pattern, cx, cy) {
            const ph = pattern.length;
            const pw = pattern[0].length;
            const startX = cx - Math.floor(pw / 2);
            const startY = cy - Math.floor(ph / 2);

            for (let y = 0; y < ph; y++) {
                for (let x = 0; x < pw; x++) {
                    const gx = startX + x;
                    const gy = startY + y;
                    if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                        grid[gy * cols + gx] = pattern[y][x];
                    }
                }
            }
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    count += grid[ny * cols + nx];
                }
            }
            return count;
        }

        function step() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const idx = y * cols + x;
                    const neighbors = countNeighbors(x, y);
                    const alive = grid[idx];

                    // Conway's rules
                    if (alive) {
                        nextGrid[idx] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        nextGrid[idx] = (neighbors === 3) ? 1 : 0;
                    }
                }
            }

            [grid, nextGrid] = [nextGrid, grid];
            generation++;
        }

        function render() {
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, width, height);

            let population = 0;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y * cols + x]) {
                        population++;
                        // Color based on neighbor count for visual interest
                        const neighbors = countNeighbors(x, y);
                        const hue = 120 + neighbors * 10;
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                    }
                }
            }

            // Update stats
            document.getElementById('generation').textContent = generation;
            document.getElementById('population').textContent = population;
            document.getElementById('density').textContent = ((population / (cols * rows)) * 100).toFixed(1);
        }

        function animate(time) {
            if (running && time - lastUpdate >= updateInterval) {
                step();
                lastUpdate = time;
            }
            render();
            requestAnimationFrame(animate);
        }

        // Drawing
        let isDrawing = false;
        let drawValue = 1;

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const x = Math.floor(e.clientX / cellSize);
            const y = Math.floor(e.clientY / cellSize);
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                drawValue = grid[y * cols + x] ? 0 : 1;
                grid[y * cols + x] = drawValue;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const x = Math.floor(e.clientX / cellSize);
                const y = Math.floor(e.clientY / cellSize);
                if (x >= 0 && x < cols && y >= 0 && y < rows) {
                    grid[y * cols + x] = drawValue;
                }
            }
        });

        canvas.addEventListener('mouseup', () => { isDrawing = false; });
        canvas.addEventListener('mouseleave', () => { isDrawing = false; });

        // Controls
        document.getElementById('speed').addEventListener('input', (e) => {
            const fps = parseInt(e.target.value);
            updateInterval = 1000 / fps;
            document.getElementById('speedVal').textContent = fps;
        });

        document.getElementById('cellSize').addEventListener('input', (e) => {
            cellSize = parseInt(e.target.value);
            document.getElementById('sizeVal').textContent = cellSize;
            init();
        });

        document.getElementById('pattern').addEventListener('change', () => {
            resetGrid();
        });

        document.getElementById('playPause').addEventListener('click', (e) => {
            running = !running;
            e.target.textContent = running ? '‚è∏ Pause' : '‚ñ∂ Play';
            e.target.classList.toggle('pause', running);
        });

        window.addEventListener('resize', init);

        // Initialize
        init();
        requestAnimationFrame(animate);

        // Educational Panel
        new EduPanel('#edu-panel', {
            title: "Conway's Game of Life",
            startOpen: false,
            tabs: [
                {
                    id: 'theory',
                    label: 'Theory',
                    content: `
                        <h4>What is the Game of Life?</h4>
                        <p>Created by mathematician John Conway in 1970, the Game of Life is a zero-player game - a cellular automaton where the initial state completely determines all future states.</p>

                        <div class="concept-card">
                            <h5>The Rules</h5>
                            <p>Each cell is alive or dead. On each step:</p>
                            <ol>
                                <li><strong>Underpopulation</strong>: Alive cell with <2 neighbors dies</li>
                                <li><strong>Survival</strong>: Alive cell with 2-3 neighbors lives</li>
                                <li><strong>Overpopulation</strong>: Alive cell with >3 neighbors dies</li>
                                <li><strong>Reproduction</strong>: Dead cell with exactly 3 neighbors becomes alive</li>
                            </ol>
                        </div>

                        <div class="concept-card">
                            <h5>Cellular Automaton</h5>
                            <p>A cellular automaton is a grid of cells, each with a state, that evolves according to rules based on neighboring cells. Life uses the Moore neighborhood (8 surrounding cells).</p>
                        </div>

                        <h4>Pattern Types</h4>

                        <div class="concept-card">
                            <h5>Still Lifes</h5>
                            <p>Patterns that don't change: Block (2√ó2 square), Beehive, Loaf, Boat</p>
                        </div>

                        <div class="concept-card">
                            <h5>Oscillators</h5>
                            <p>Patterns that repeat: Blinker (period 2), Pulsar (period 3), Pentadecathlon (period 15)</p>
                        </div>

                        <div class="concept-card">
                            <h5>Spaceships</h5>
                            <p>Patterns that move: Glider, Lightweight/Middleweight/Heavyweight Spaceships</p>
                        </div>

                        <div class="concept-card">
                            <h5>Turing Completeness</h5>
                            <p>Life can simulate any Turing machine - it's theoretically capable of any computation! Glider guns + logic gates = universal computer.</p>
                        </div>
                    `
                },
                {
                    id: 'algorithm',
                    label: 'Algorithm',
                    content: `
                        <h4>Simulation Algorithm</h4>

                        <div class="steps">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Initialize Grid</strong>
                                    <p>Create 2D array of cells (0 = dead, 1 = alive)</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Count Neighbors</strong>
                                    <p>For each cell, count alive cells in 8 surrounding positions</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Apply Rules</strong>
                                    <p>Determine next state based on current state + neighbor count</p>
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Update Grid</strong>
                                    <p>Copy next state to current state (double buffering)</p>
                                </div>
                            </div>
                        </div>

                        <h4>Pseudocode</h4>
                        <pre><code>function step():
    for each cell (x, y):
        neighbors = count_alive_neighbors(x, y)
        alive = grid[x][y]

        if alive:
            # Survival: 2-3 neighbors
            next[x][y] = (neighbors == 2 or
                          neighbors == 3)
        else:
            # Birth: exactly 3 neighbors
            next[x][y] = (neighbors == 3)

    grid = next  # Swap buffers

function count_neighbors(x, y):
    count = 0
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0: continue
            count += grid[x+dx][y+dy]
    return count</code></pre>

                        <div class="concept-card">
                            <h5>Optimization: HashLife</h5>
                            <p>For large-scale simulations, the HashLife algorithm uses memoization to skip computation on repeated patterns, achieving exponential speedup.</p>
                        </div>
                    `
                },
                {
                    id: 'applications',
                    label: 'Applications',
                    content: `
                        <h4>Real-World Applications</h4>

                        <div class="application">
                            <h5>üß¨ Biology</h5>
                            <p>Models population dynamics, bacterial colony growth, and neural firing patterns. The rules mirror biological birth/death thresholds.</p>
                        </div>

                        <div class="application">
                            <h5>üíª Computer Science</h5>
                            <p>Demonstrates computation theory, parallel algorithms, and complexity. Used to teach automata theory and emergent behavior.</p>
                        </div>

                        <div class="application">
                            <h5>üîê Cryptography</h5>
                            <p>Cellular automata (like Rule 30) are used in random number generation and stream ciphers.</p>
                        </div>

                        <div class="application">
                            <h5>üèôÔ∏è Urban Planning</h5>
                            <p>Models urban sprawl, land use changes, and city growth patterns using CA-based simulations.</p>
                        </div>

                        <div class="application">
                            <h5>üî¨ Physics</h5>
                            <p>Lattice gas automata simulate fluid dynamics. Related CA model crystal growth and phase transitions.</p>
                        </div>

                        <div class="concept-card">
                            <h5>Famous Patterns</h5>
                            <ul>
                                <li><strong>Glider Gun</strong>: Creates infinite gliders (Bill Gosper, 1970)</li>
                                <li><strong>Acorn</strong>: 7 cells that create 633 cells over 5206 generations</li>
                                <li><strong>Turing Machine</strong>: Full computer built in Life</li>
                            </ul>
                        </div>
                    `
                },
                {
                    id: 'explore',
                    label: 'Explore',
                    content: `
                        <h4>Interactive Explorations</h4>

                        <div class="tutorial">
                            <h5>1. The Glider</h5>
                            <p>Select "Glider" pattern. Watch the smallest spaceship travel diagonally across the grid.</p>
                            <p><strong>Challenge:</strong> Draw your own glider from scratch (5 cells)</p>
                        </div>

                        <div class="tutorial">
                            <h5>2. Gosper Glider Gun</h5>
                            <p>Select "Gosper Glider Gun". This was the first known gun - a pattern that produces gliders indefinitely!</p>
                            <p><strong>Note:</strong> This proved Life patterns can grow without bound</p>
                        </div>

                        <div class="tutorial">
                            <h5>3. Oscillators</h5>
                            <p>Select "Pulsar" or "Pentadecathlon". These patterns return to their original state after a fixed period.</p>
                            <p><strong>Pulsar:</strong> Period 3 | <strong>Pentadecathlon:</strong> Period 15</p>
                        </div>

                        <div class="tutorial">
                            <h5>4. Methuselahs</h5>
                            <p>Select "Acorn" or "R-Pentomino". These small patterns take many generations to stabilize.</p>
                            <p><strong>R-Pentomino:</strong> 5 cells ‚Üí 1103 generations to stabilize</p>
                        </div>

                        <div class="tutorial">
                            <h5>5. Draw Mode</h5>
                            <p>Pause the simulation and click to toggle cells. Try creating:</p>
                            <ul>
                                <li>A 2√ó2 block (stable still life)</li>
                                <li>A 3-cell line (blinker oscillator)</li>
                                <li>Your own patterns!</li>
                            </ul>
                        </div>

                        <div class="concept-card">
                            <h5>Garden of Eden</h5>
                            <p>Some patterns can never be reached from any previous state - they can only exist as initial conditions. These are called "Gardens of Eden."</p>
                        </div>
                    `
                },
                {
                    id: 'references',
                    label: 'References',
                    content: `
                        <h4>Learn More</h4>

                        <div class="reference-list">
                            <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank">Wikipedia: Conway's Game of Life</a>
                            <a href="https://conwaylife.com/" target="_blank">LifeWiki - Pattern Encyclopedia</a>
                            <a href="https://www.youtube.com/watch?v=R9Plq-D1gEk" target="_blank">Numberphile: Game of Life</a>
                            <a href="https://golly.sourceforge.net/" target="_blank">Golly - Advanced Life Simulator</a>
                        </div>

                        <h4>Historical Note</h4>
                        <p>John Conway (1937-2020) initially regretted Life's fame overshadowing his other mathematical work. He called it his "love-hate relationship." The game was published in Scientific American by Martin Gardner in October 1970.</p>

                        <h4>Related Topics</h4>
                        <ul>
                            <li>Cellular Automata (Wolfram's Rules)</li>
                            <li>Emergence & Complexity</li>
                            <li>Turing Completeness</li>
                            <li>Artificial Life</li>
                            <li>Self-Organization</li>
                        </ul>
                    `
                }
            ]
        });
    </script>
</body>
</html>
