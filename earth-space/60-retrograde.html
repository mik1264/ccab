<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retrograde Motion - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #000;
            color: #ddd;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; display: flex; gap: 40px; justify-content: center; }
        
        .view-box {
            width: 400px;
            height: 400px;
            border: 1px solid #333;
            background: #111;
            border-radius: 8px;
            position: relative;
        }
        
        canvas {
            position: absolute;
            top: 0; left: 0;
        }
        
        .sky-canvas {
            background: #0f172a;
        }
        
    </style>
</head>
<body>

<a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
<h1>Retrograde Motion (Mars)</h1>
<p>Mars appears to move backwards in the sky when Earth overtakes it in orbit.</p>

<div class="container">
    <div>
        <h3>Heliocentric View</h3>
        <div class="view-box">
            <canvas id="helio" width="400" height="400"></canvas>
        </div>
    </div>
    
    <div>
        <h3>Geocentric Sky View</h3>
        <div class="view-box">
            <canvas id="geo" width="400" height="400" class="sky-canvas"></canvas>
        </div>
    </div>
</div>

<script>
    const ctx1 = document.getElementById('helio').getContext('2d');
    const ctx2 = document.getElementById('geo').getContext('2d');
    
    // Config
    // Earth: r=1, T=1 yr
    // Mars: r=1.52, T=1.88 yr
    const Re = 100;
    const Rm = 152;
    const we = 0.02; // Omega Earth
    const wm = we / 1.88; // Omega Mars
    
    let ae = 0;
    let am = 0;
    let trace = []; // Mars position in sky relative to Earth
    
    function loop() {
        ae += we;
        am += wm;
        
        // 1. Heliocentric
        ctx1.clearRect(0, 0, 400, 400);
        
        // Sun
        ctx1.fillStyle = '#fcd34d';
        ctx1.beginPath(); ctx1.arc(200, 200, 10, 0, Math.PI*2); ctx1.fill();
        
        // Orbits
        ctx1.strokeStyle = '#333';
        ctx1.beginPath(); ctx1.arc(200, 200, Re, 0, Math.PI*2); ctx1.stroke();
        ctx1.beginPath(); ctx1.arc(200, 200, Rm, 0, Math.PI*2); ctx1.stroke();
        
        // Earth
        const ex = 200 + Re * Math.cos(ae);
        const ey = 200 + Re * Math.sin(ae);
        ctx1.fillStyle = '#3b82f6';
        ctx1.beginPath(); ctx1.arc(ex, ey, 6, 0, Math.PI*2); ctx1.fill();
        
        // Mars
        const mx = 200 + Rm * Math.cos(am);
        const my = 200 + Rm * Math.sin(am);
        ctx1.fillStyle = '#ef4444';
        ctx1.beginPath(); ctx1.arc(mx, my, 5, 0, Math.PI*2); ctx1.fill();
        
        // Line of sight
        ctx1.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx1.beginPath(); ctx1.moveTo(ex, ey); ctx1.lineTo(mx, my); ctx1.stroke();
        
        // 2. Geocentric (Sky View)
        // Project Mars position onto celestial sphere background
        // Relative vector
        const dx = mx - ex;
        const dy = my - ey;
        const dist = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        
        // We need to visualize the loop in the sky.
        // Sky view is angle vs time? Or Path in 2D sky?
        // Usually shown as path relative to background stars.
        // Background stars are fixed at Infinity.
        // Let's hold Earth fixed at center of view 2?
        // No, let's fix the stars. View from Earth looking out.
        // Angle changes.
        // Let's plot angle on X axis (RA), and time on Y?
        // Or simplified: Plot (angle, declination). But this is 2D planar orbit.
        // Declination is 0. So it just moves back and forth on a line?
        // To see loop, we need inclination.
        
        // Add slight inclination to Mars orbit for visual loop
        const inc = 0.1; // rad
        const mz = Rm * Math.sin(am) * inc; // Z component
        // Earth z=0
        const dz = mz - 0;
        
        // Project onto sky plane
        // View direction? Let's say we look towards a fixed star direction (angle 0).
        // Then X on screen is angle deviation from 0?
        // Let's map Angle (RA) to X, and Angle (Dec) to Y.
        
        // RA = atan2(dy, dx)
        // Dec = atan2(dz, dist_xy)
        
        // Center view on current average angle? Or fixed frame?
        // Let's fix frame relative to stars.
        
        // Just raw angle creates 360 wrap.
        // Retrograde is when d(angle)/dt < 0.
        // Let's simply draw the path relative to a rotating frame that moves with Earth's average speed?
        // No, standard viz is background stars fixed.
        
        // Let's center the view on "Opposition" (when Earth passes Mars)
        // This happens periodically.
        // Let's just scroll the sky.
        
        // Trace logic
        // We plot (angle, declination)
        // Angle needs to be unwrapped to avoid jumps
        // Or just draw current Mars position.
        
        ctx2.clearRect(0, 0, 400, 400);
        
        // Draw Stars
        ctx2.fillStyle = '#fff';
        for(let i=0; i<50; i++) {
            // Fixed background
            // Move opposite to Earth? 
            // In geocentric frame, stars rotate?
            // Let's stick to simple "Apparent Path against Stars"
            // We draw trace.
        }
        
        // We need to accumulate points.
        // Coordinate system: X = angle, Y = declination.
        // To keep it on screen, we shift X by Earth's mean orbital motion?
        // No, we just want the loop.
        // The loop happens over a few months.
        // Let's keep the view centered on Mars's average motion?
        
        // Center view on Mars mean longitude?
        const meanLong = am;
        let viewAngle = angle - meanLong; // Relative to mean mars
        
        // Adjust for Earth moving faster
        // The loop happens when Earth passes.
        
        // Let's accumulate trace points in a buffer relative to a reference
        // Just track (angle, declination).
        // Since angle increases 0..2PI, we map it to X with wrap.
        // If we want a loop, we need to show the reversal.
        
        // Use a scrolling window.
        // X = (angle - ae) ? No.
        // X = angle.
        // Scroll offset = center angle on screen.
        
        // Let's just fix the view direction to angle 0 (Right).
        // If planet is at angle PI, it's off screen?
        // Let's rotate the whole sky so Mars is roughly center.
        
        const centerAngle = am; // Follow Mars average
        
        // Calculate relative position for trace
        // We want the Apparent Angle relative to the fixed stars.
        // Theta = atan2(dy, dx).
        
        // To fit on screen, we subtract a linear term?
        // Or just wrap.
        
        // Let's draw traces for last 100 frames
        // But shift them so current Mars is near center?
        
        // Better: X = (Theta - am) * scale?
        // This shows motion relative to mean motion.
        
        const theta = Math.atan2(dy, dx);
        const dec = Math.atan2(dz, Math.hypot(dx, dy));
        
        // Unwrap theta
        // (Not implemented, assumes simple loop)
        
        // Let's store raw theta.
        // When drawing, shift by current am.
        
        trace.push({t: theta, d: dec, am_ref: am});
        if (trace.length > 200) trace.shift();
        
        ctx2.strokeStyle = '#ef4444';
        ctx2.lineWidth = 2;
        ctx2.beginPath();
        
        trace.forEach((p, i) => {
            // Relative angle
            let diff = p.t - p.am_ref;
            // Normalize
            while (diff > Math.PI) diff -= Math.PI*2;
            while (diff < -Math.PI) diff += Math.PI*2;
            
            // However, p.am_ref is the mean mars position at that time.
            // If we plot diff, we see retrograde loop relative to Mars' orbit.
            // This works well.
            
            const x = 200 + diff * 300; // Scale up
            const y = 200 - p.d * 1000;
            
            if (i===0) ctx2.moveTo(x, y);
            else ctx2.lineTo(x, y);
        });
        ctx2.stroke();
        
        // Current Mars
        const currDiff = 0; // since t ~ am roughly? No.
        // Re-calc current
        let diff = theta - am;
        while (diff > Math.PI) diff -= Math.PI*2;
        while (diff < -Math.PI) diff += Math.PI*2;
        
        const cx = 200 + diff * 300;
        const cy = 200 - dec * 1000;
        
        ctx2.fillStyle = '#ef4444';
        ctx2.beginPath(); ctx2.arc(cx, cy, 6, 0, Math.PI*2); ctx2.fill();
        ctx2.fillStyle = '#fff'; ctx2.fillText("Mars", cx+10, cy);
        
        requestAnimationFrame(loop);
    }
    
    requestAnimationFrame(loop);

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
