<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parking Search - Traffic/Urban Simulations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e2e8f0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #facc15;
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 20px;
            transition: gap 0.3s ease;
        }

        .back-link:hover {
            gap: 12px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #facc15;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
        }

        .simulation-container {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(250, 204, 21, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            height: 500px;
            border-radius: 8px;
            background: #0f172a;
        }

        .controls-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(250, 204, 21, 0.2);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #facc15;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1e293b;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #facc15;
            cursor: pointer;
        }

        .control-value {
            text-align: right;
            color: #facc15;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .mode-btn {
            padding: 10px;
            border: 1px solid rgba(250, 204, 21, 0.3);
            background: transparent;
            color: #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .mode-btn:hover {
            background: rgba(250, 204, 21, 0.1);
        }

        .mode-btn.active {
            background: #facc15;
            color: #1a1a2e;
            font-weight: 600;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: rgba(250, 204, 21, 0.1);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #facc15;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 4px;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #facc15;
            color: #1a1a2e;
        }

        .btn-secondary {
            background: rgba(250, 204, 21, 0.2);
            color: #facc15;
        }

        .info-box {
            background: rgba(250, 204, 21, 0.1);
            border: 1px solid rgba(250, 204, 21, 0.3);
            border-radius: 12px;
            padding: 20px;
        }

        .info-box h3 {
            color: #facc15;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #94a3b8;
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #94a3b8;
        }

        .legend-color {
            width: 16px;
            height: 12px;
            border-radius: 3px;
        }

        @media (max-width: 900px) {
            .simulation-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">
                <span>‚Üê</span>
                <span>Back to Traffic/Urban</span>
            </a>
            <h1>Parking Search</h1>
            <p class="subtitle">Optimal parking spot finding strategies</p>
        </header>

        <div class="simulation-container">
            <div class="canvas-wrapper">
                <canvas id="simCanvas"></canvas>
            </div>

            <div class="controls-panel">
                <div class="control-section">
                    <h3>Search Strategy</h3>
                    <div class="mode-buttons">
                        <button class="mode-btn active" data-mode="nearest">Nearest First</button>
                        <button class="mode-btn" data-mode="optimal">Optimal Walk</button>
                        <button class="mode-btn" data-mode="first">First Available</button>
                        <button class="mode-btn" data-mode="random">Random</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Parameters</h3>
                    <div class="control-group">
                        <label>Parking Occupancy</label>
                        <input type="range" id="occupancy" min="50" max="95" value="80">
                        <div class="control-value"><span id="occupancyVal">80</span>%</div>
                    </div>
                    <div class="control-group">
                        <label>Turnover Rate</label>
                        <input type="range" id="turnover" min="1" max="20" value="8">
                        <div class="control-value"><span id="turnoverVal">8</span>/min</div>
                    </div>
                    <div class="control-group">
                        <label>Car Arrival Rate</label>
                        <input type="range" id="arrival" min="1" max="20" value="10">
                        <div class="control-value"><span id="arrivalVal">10</span>/min</div>
                    </div>
                    <div class="control-group">
                        <label>Walk Tolerance</label>
                        <input type="range" id="walkTolerance" min="1" max="10" value="5">
                        <div class="control-value"><span id="walkToleranceVal">5</span> spots</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="avgSearch">0</div>
                            <div class="stat-label">Avg Search Time</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avgWalk">0</div>
                            <div class="stat-label">Avg Walk Dist</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="carsSearching">0</div>
                            <div class="stat-label">Searching</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="parked">0</div>
                            <div class="stat-label">Parked</div>
                        </div>
                    </div>
                </div>

                <div class="btn-row">
                    <button class="btn btn-primary" id="resetBtn">Reset</button>
                    <button class="btn btn-secondary" id="pauseBtn">Pause</button>
                </div>
            </div>
        </div>

        <div class="info-box">
            <h3>Parking Search Strategies</h3>
            <p>
                This simulation explores different parking search strategies. The "optimal walk" strategy
                balances search time against walking distance, often outperforming simple "nearest first"
                in congested lots. The destination (yellow star) is where drivers want to go after parking.
            </p>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>Available Spot</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Occupied Spot</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3b82f6;"></div>
                    <span>Searching Car</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #facc15;"></div>
                    <span>Destination</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let paused = false;
        let searchMode = 'nearest';
        let parkingSpots = [];
        let searchingCars = [];
        let destination = { x: 0, y: 0 };

        // Stats
        let stats = {
            searchTimes: [],
            walkDistances: [],
            parkedCount: 0
        };

        // Parameters
        const params = {
            occupancy: 80,
            turnover: 8,
            arrival: 10,
            walkTolerance: 5
        };

        // Grid configuration
        const grid = {
            rows: 4,
            spotsPerRow: 12,
            spotWidth: 40,
            spotHeight: 70,
            aisleWidth: 60,
            marginTop: 80,
            marginLeft: 50
        };

        class ParkingSpot {
            constructor(row, col, x, y) {
                this.row = row;
                this.col = col;
                this.x = x;
                this.y = y;
                this.occupied = false;
                this.occupiedSince = 0;
            }

            distanceTo(point) {
                return Math.sqrt(
                    Math.pow(this.x + grid.spotWidth / 2 - point.x, 2) +
                    Math.pow(this.y + grid.spotHeight / 2 - point.y, 2)
                );
            }

            draw(ctx) {
                // Spot outline
                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, grid.spotWidth, grid.spotHeight);

                // Fill based on occupancy
                if (this.occupied) {
                    // Draw car
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.roundRect(this.x + 5, this.y + 10, grid.spotWidth - 10, grid.spotHeight - 20, 5);
                    ctx.fill();
                } else {
                    // Available indicator
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                    ctx.fillRect(this.x + 2, this.y + 2, grid.spotWidth - 4, grid.spotHeight - 4);
                }
            }
        }

        class SearchingCar {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetSpot = null;
                this.speed = 3;
                this.startTime = Date.now();
                this.state = 'searching'; // searching, approaching, parked
                this.path = [];
                this.pathIndex = 0;
            }

            findSpot() {
                const available = parkingSpots.filter(s => !s.occupied && !this.isTargeted(s));

                if (available.length === 0) return null;

                switch (searchMode) {
                    case 'nearest':
                        // Find spot nearest to current position
                        return available.reduce((best, spot) => {
                            const dist = spot.distanceTo({ x: this.x, y: this.y });
                            return dist < spot.distanceTo({ x: best.x, y: best.y }) ? spot : best;
                        });

                    case 'optimal':
                        // Balance search time and walk distance
                        return available.reduce((best, spot) => {
                            const searchDist = spot.distanceTo({ x: this.x, y: this.y });
                            const walkDist = spot.distanceTo(destination);
                            const score = searchDist * 0.3 + walkDist * 0.7;
                            const bestScore = best.distanceTo({ x: this.x, y: this.y }) * 0.3 +
                                            best.distanceTo(destination) * 0.7;
                            return score < bestScore ? spot : best;
                        });

                    case 'first':
                        // First spot encountered (by row)
                        return available.sort((a, b) => {
                            const aDist = Math.abs(a.y - this.y);
                            const bDist = Math.abs(b.y - this.y);
                            return aDist - bDist;
                        })[0];

                    case 'random':
                        return available[Math.floor(Math.random() * available.length)];
                }
            }

            isTargeted(spot) {
                return searchingCars.some(c => c !== this && c.targetSpot === spot);
            }

            update() {
                if (this.state === 'parked') return false;

                if (!this.targetSpot || this.targetSpot.occupied) {
                    this.targetSpot = this.findSpot();
                    if (!this.targetSpot) {
                        // No spots available, circle around
                        return true;
                    }
                    this.calculatePath();
                }

                // Move along path
                if (this.path.length > 0) {
                    const target = this.path[this.pathIndex];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.speed) {
                        this.x = target.x;
                        this.y = target.y;
                        this.pathIndex++;

                        if (this.pathIndex >= this.path.length) {
                            // Arrived at spot
                            this.park();
                            return false;
                        }
                    } else {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                }

                return true;
            }

            calculatePath() {
                this.path = [];
                this.pathIndex = 0;

                if (!this.targetSpot) return;

                // Simple path: go to aisle, then to spot
                const aisleY = this.targetSpot.row % 2 === 0 ?
                    this.targetSpot.y + grid.spotHeight + grid.aisleWidth / 2 :
                    this.targetSpot.y - grid.aisleWidth / 2;

                this.path.push({ x: this.x, y: aisleY });
                this.path.push({ x: this.targetSpot.x + grid.spotWidth / 2, y: aisleY });
                this.path.push({
                    x: this.targetSpot.x + grid.spotWidth / 2,
                    y: this.targetSpot.y + grid.spotHeight / 2
                });
            }

            park() {
                if (this.targetSpot && !this.targetSpot.occupied) {
                    this.targetSpot.occupied = true;
                    this.targetSpot.occupiedSince = Date.now();
                    this.state = 'parked';

                    const searchTime = (Date.now() - this.startTime) / 1000;
                    const walkDist = this.targetSpot.distanceTo(destination) / grid.spotWidth;

                    stats.searchTimes.push(searchTime);
                    stats.walkDistances.push(walkDist);
                    stats.parkedCount++;
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.roundRect(this.x - 15, this.y - 10, 30, 20, 5);
                ctx.fill();

                // Direction indicator
                if (this.path.length > this.pathIndex) {
                    const target = this.path[this.pathIndex];
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + Math.cos(angle) * 12,
                        this.y + Math.sin(angle) * 12,
                        3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }

        function initializeParkingLot() {
            parkingSpots = [];
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Set destination (store entrance)
            destination = {
                x: width / 2,
                y: grid.marginTop - 40
            };

            // Create parking spots
            for (let row = 0; row < grid.rows; row++) {
                const rowY = grid.marginTop + Math.floor(row / 2) * (grid.spotHeight * 2 + grid.aisleWidth);
                const isTopRow = row % 2 === 0;

                for (let col = 0; col < grid.spotsPerRow; col++) {
                    const x = grid.marginLeft + col * (grid.spotWidth + 5);
                    const y = isTopRow ? rowY : rowY + grid.spotHeight;

                    parkingSpots.push(new ParkingSpot(row, col, x, y));
                }
            }

            // Set initial occupancy
            const numOccupied = Math.floor(parkingSpots.length * params.occupancy / 100);
            const shuffled = [...parkingSpots].sort(() => Math.random() - 0.5);
            for (let i = 0; i < numOccupied; i++) {
                shuffled[i].occupied = true;
                shuffled[i].occupiedSince = Date.now() - Math.random() * 60000;
            }
        }

        function spawnCar() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Spawn at entrance
            const car = new SearchingCar(
                width - 50,
                height - 30
            );
            searchingCars.push(car);
        }

        function handleTurnover() {
            // Random cars leave
            if (Math.random() < params.turnover / 60 / 60) {
                const occupied = parkingSpots.filter(s => s.occupied);
                if (occupied.length > 0) {
                    const spot = occupied[Math.floor(Math.random() * occupied.length)];
                    // Only leave if parked for a while
                    if (Date.now() - spot.occupiedSince > 10000) {
                        spot.occupied = false;
                    }
                }
            }
        }

        function drawLot(ctx, width, height) {
            // Entrance/exit
            ctx.fillStyle = '#facc15';
            ctx.beginPath();
            ctx.moveTo(destination.x, destination.y - 10);
            ctx.lineTo(destination.x - 15, destination.y + 15);
            ctx.lineTo(destination.x + 15, destination.y + 15);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#facc15';
            ctx.font = '12px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText('ENTRANCE', destination.x, destination.y - 15);

            // Aisles
            ctx.fillStyle = '#1e293b';
            for (let i = 0; i < Math.ceil(grid.rows / 2); i++) {
                const y = grid.marginTop + i * (grid.spotHeight * 2 + grid.aisleWidth) + grid.spotHeight;
                ctx.fillRect(0, y, width, grid.aisleWidth);

                // Arrows
                ctx.fillStyle = '#4b5563';
                for (let x = 50; x < width - 50; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, y + grid.aisleWidth / 2);
                    ctx.lineTo(x + 20, y + grid.aisleWidth / 2 - 10);
                    ctx.lineTo(x + 20, y + grid.aisleWidth / 2 + 10);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.fillStyle = '#1e293b';
            }

            // Draw all spots
            parkingSpots.forEach(spot => spot.draw(ctx));
        }

        function updateStats() {
            const avgSearch = stats.searchTimes.length > 0 ?
                (stats.searchTimes.reduce((a, b) => a + b, 0) / stats.searchTimes.length).toFixed(1) : 0;
            const avgWalk = stats.walkDistances.length > 0 ?
                (stats.walkDistances.reduce((a, b) => a + b, 0) / stats.walkDistances.length).toFixed(1) : 0;

            document.getElementById('avgSearch').textContent = avgSearch + 's';
            document.getElementById('avgWalk').textContent = avgWalk;
            document.getElementById('carsSearching').textContent = searchingCars.filter(c => c.state === 'searching').length;
            document.getElementById('parked').textContent = stats.parkedCount;

            // Limit history
            if (stats.searchTimes.length > 50) {
                stats.searchTimes = stats.searchTimes.slice(-30);
                stats.walkDistances = stats.walkDistances.slice(-30);
            }
        }

        let lastSpawn = 0;
        function animate(timestamp) {
            if (paused) {
                requestAnimationFrame(animate);
                return;
            }

            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            ctx.clearRect(0, 0, width, height);

            drawLot(ctx, width, height);

            // Spawn new cars
            if (timestamp - lastSpawn > 60000 / params.arrival) {
                spawnCar();
                lastSpawn = timestamp;
            }

            // Handle turnover
            handleTurnover();

            // Update and draw searching cars
            searchingCars = searchingCars.filter(car => {
                const active = car.update();
                if (car.state !== 'parked') {
                    car.draw(ctx);
                }
                return active || car.state !== 'parked';
            });

            updateStats();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                searchMode = btn.dataset.mode;
            });
        });

        document.getElementById('occupancy').addEventListener('input', (e) => {
            params.occupancy = parseInt(e.target.value);
            document.getElementById('occupancyVal').textContent = params.occupancy;
        });

        document.getElementById('turnover').addEventListener('input', (e) => {
            params.turnover = parseInt(e.target.value);
            document.getElementById('turnoverVal').textContent = params.turnover;
        });

        document.getElementById('arrival').addEventListener('input', (e) => {
            params.arrival = parseInt(e.target.value);
            document.getElementById('arrivalVal').textContent = params.arrival;
        });

        document.getElementById('walkTolerance').addEventListener('input', (e) => {
            params.walkTolerance = parseInt(e.target.value);
            document.getElementById('walkToleranceVal').textContent = params.walkTolerance;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            searchingCars = [];
            stats = { searchTimes: [], walkDistances: [], parkedCount: 0 };
            initializeParkingLot();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        // Initialize and start
        initializeParkingLot();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
