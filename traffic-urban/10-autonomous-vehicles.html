<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Vehicles - Traffic/Urban Simulations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e2e8f0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #facc15;
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 20px;
            transition: gap 0.3s ease;
        }

        .back-link:hover {
            gap: 12px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #facc15;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
        }

        .simulation-container {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(250, 204, 21, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            height: 500px;
            border-radius: 8px;
            background: #0f172a;
        }

        .controls-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(250, 204, 21, 0.2);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #facc15;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1e293b;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #facc15;
            cursor: pointer;
        }

        .control-value {
            text-align: right;
            color: #facc15;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .av-ratio {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .ratio-bar {
            flex: 1;
            height: 20px;
            background: #4b5563;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
        }

        .ratio-av {
            background: #3b82f6;
            transition: width 0.3s ease;
        }

        .ratio-human {
            background: #ef4444;
        }

        .ratio-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: rgba(250, 204, 21, 0.1);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #facc15;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 4px;
        }

        .feature-toggles {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .feature-toggle input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .feature-name {
            color: #e2e8f0;
            font-size: 0.85rem;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #facc15;
            color: #1a1a2e;
        }

        .btn-secondary {
            background: rgba(250, 204, 21, 0.2);
            color: #facc15;
        }

        .info-box {
            background: rgba(250, 204, 21, 0.1);
            border: 1px solid rgba(250, 204, 21, 0.3);
            border-radius: 12px;
            padding: 20px;
        }

        .info-box h3 {
            color: #facc15;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #94a3b8;
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #94a3b8;
        }

        .legend-color {
            width: 16px;
            height: 12px;
            border-radius: 3px;
        }

        @media (max-width: 900px) {
            .simulation-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">
                <span>‚Üê</span>
                <span>Back to Traffic/Urban</span>
            </a>
            <h1>Autonomous Vehicles</h1>
            <p class="subtitle">Self-driving car coordination and mixed traffic</p>
        </header>

        <div class="simulation-container">
            <div class="canvas-wrapper">
                <canvas id="simCanvas"></canvas>
            </div>

            <div class="controls-panel">
                <div class="control-section">
                    <h3>AV Penetration</h3>
                    <div class="av-ratio">
                        <div class="ratio-bar">
                            <div class="ratio-av" id="ratioAV" style="width: 50%;"></div>
                            <div class="ratio-human" style="flex: 1;"></div>
                        </div>
                    </div>
                    <div class="control-group">
                        <input type="range" id="avRatio" min="0" max="100" value="50">
                        <div class="ratio-labels">
                            <span>0% AV</span>
                            <span id="avRatioVal">50%</span>
                            <span>100% AV</span>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>AV Features</h3>
                    <div class="feature-toggles">
                        <label class="feature-toggle">
                            <input type="checkbox" id="v2v" checked>
                            <span class="feature-name">V2V Communication</span>
                        </label>
                        <label class="feature-toggle">
                            <input type="checkbox" id="platooning" checked>
                            <span class="feature-name">Platooning</span>
                        </label>
                        <label class="feature-toggle">
                            <input type="checkbox" id="cooperative" checked>
                            <span class="feature-name">Cooperative Merging</span>
                        </label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Parameters</h3>
                    <div class="control-group">
                        <label>Traffic Density</label>
                        <input type="range" id="density" min="10" max="60" value="35">
                        <div class="control-value"><span id="densityVal">35</span>%</div>
                    </div>
                    <div class="control-group">
                        <label>Human Reaction Time</label>
                        <input type="range" id="humanReaction" min="500" max="2000" value="1000">
                        <div class="control-value"><span id="humanReactionVal">1000</span>ms</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="throughput">0</div>
                            <div class="stat-label">Throughput/min</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avgSpeed">0</div>
                            <div class="stat-label">Avg Speed</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="nearMisses">0</div>
                            <div class="stat-label">Near Misses</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="platoons">0</div>
                            <div class="stat-label">Platoons</div>
                        </div>
                    </div>
                </div>

                <div class="btn-row">
                    <button class="btn btn-primary" id="resetBtn">Reset</button>
                    <button class="btn btn-secondary" id="pauseBtn">Pause</button>
                </div>
            </div>
        </div>

        <div class="info-box">
            <h3>Autonomous Vehicle Coordination</h3>
            <p>
                This simulation explores how autonomous vehicles (AVs) can improve traffic flow through
                V2V communication, platooning, and cooperative behavior. Compare traffic efficiency at
                different AV penetration rates. Watch how AVs form platoons (convoys) with reduced
                following distances when V2V is enabled.
            </p>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #3b82f6;"></div>
                    <span>Autonomous</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Human-driven</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>Platoon</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(59, 130, 246, 0.3);"></div>
                    <span>V2V Range</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Parameters
        const params = {
            avRatio: 50,
            density: 35,
            humanReaction: 1000
        };

        const features = {
            v2v: true,
            platooning: true,
            cooperative: true
        };

        // State
        let paused = false;
        let vehicles = [];
        let stats = {
            throughput: 0,
            nearMisses: 0,
            platoonCount: 0
        };
        let vehiclesExited = 0;
        let lastMinute = Date.now();

        // Road configuration
        const road = {
            lanes: 3,
            laneWidth: 50,
            length: 0
        };

        class Vehicle {
            constructor(lane, x, isAV) {
                this.lane = lane;
                this.x = x;
                this.isAV = isAV;
                this.speed = 3 + Math.random() * 2;
                this.maxSpeed = isAV ? 5.5 : 5;
                this.targetSpeed = this.maxSpeed;
                this.width = 35;
                this.height = 20;

                // AV-specific properties
                this.inPlatoon = false;
                this.platoonLeader = null;
                this.v2vRange = 100;
                this.followDistance = isAV ? 25 : 50;

                // Human driver properties
                this.reactionDelay = isAV ? 50 : params.humanReaction;
                this.lastReaction = Date.now();
                this.targetLane = lane;
                this.laneChangeProgress = 0;
            }

            get y() {
                const canvasH = canvas.height / window.devicePixelRatio;
                const roadTop = (canvasH - road.lanes * road.laneWidth) / 2;
                const baseY = roadTop + this.lane * road.laneWidth + road.laneWidth / 2;

                if (this.laneChangeProgress > 0 && this.targetLane !== this.lane) {
                    const targetY = roadTop + this.targetLane * road.laneWidth + road.laneWidth / 2;
                    return baseY + (targetY - baseY) * this.laneChangeProgress;
                }
                return baseY;
            }

            getNearbyVehicles(vehicles, range) {
                return vehicles.filter(v =>
                    v !== this &&
                    Math.abs(v.x - this.x) < range &&
                    Math.abs(v.lane - this.lane) <= 1
                );
            }

            getVehicleAhead(vehicles) {
                const inLane = vehicles.filter(v =>
                    v !== this &&
                    v.lane === this.lane &&
                    v.x > this.x
                );
                if (inLane.length === 0) return null;
                return inLane.reduce((closest, v) =>
                    v.x < closest.x ? v : closest
                );
            }

            update(vehicles, dt) {
                const now = Date.now();

                // Check reaction time
                if (now - this.lastReaction < this.reactionDelay) {
                    this.x += this.speed * dt;
                    return;
                }
                this.lastReaction = now;

                const ahead = this.getVehicleAhead(vehicles);
                const nearby = this.getNearbyVehicles(vehicles, this.v2vRange);

                // AV-specific behaviors
                if (this.isAV) {
                    this.updateAV(vehicles, ahead, nearby, dt);
                } else {
                    this.updateHuman(vehicles, ahead, dt);
                }

                // Lane change progress
                if (this.laneChangeProgress > 0) {
                    this.laneChangeProgress += 0.05;
                    if (this.laneChangeProgress >= 1) {
                        this.lane = this.targetLane;
                        this.laneChangeProgress = 0;
                    }
                }

                this.x += this.speed * dt;
            }

            updateAV(vehicles, ahead, nearby, dt) {
                // V2V Communication - detect vehicles further ahead
                if (features.v2v) {
                    const v2vAhead = nearby.filter(v =>
                        v.isAV && v.x > this.x && v.lane === this.lane
                    );

                    // Get speed info from ahead (anticipate slowdowns)
                    if (v2vAhead.length > 0) {
                        const leadSpeed = Math.min(...v2vAhead.map(v => v.speed));
                        if (leadSpeed < this.speed) {
                            this.targetSpeed = leadSpeed * 0.95;
                        }
                    }
                }

                // Platooning
                if (features.platooning) {
                    const avAhead = ahead && ahead.isAV ? ahead : null;
                    if (avAhead && avAhead.x - this.x < 60) {
                        this.inPlatoon = true;
                        this.platoonLeader = avAhead;
                        this.followDistance = 20; // Reduced in platoon
                        this.targetSpeed = avAhead.speed;
                    } else {
                        this.inPlatoon = false;
                        this.platoonLeader = null;
                        this.followDistance = 25;
                    }
                }

                // Cooperative merging
                if (features.cooperative) {
                    // Check if human driver needs space to merge
                    const humanNearby = nearby.filter(v => !v.isAV);
                    for (const human of humanNearby) {
                        if (Math.abs(human.lane - this.lane) === 1 &&
                            Math.abs(human.x - this.x) < 50) {
                            // Slow down to create gap
                            this.targetSpeed = Math.min(this.targetSpeed, human.speed - 0.5);
                        }
                    }
                }

                // Standard following behavior
                if (ahead) {
                    const gap = ahead.x - this.x - this.width;
                    if (gap < this.followDistance) {
                        this.targetSpeed = Math.min(this.targetSpeed, ahead.speed * 0.9);
                        if (gap < 15) {
                            stats.nearMisses++;
                        }
                    } else if (gap > this.followDistance * 2) {
                        this.targetSpeed = this.maxSpeed;
                    }
                } else {
                    this.targetSpeed = this.maxSpeed;
                }

                // Smooth speed adjustment
                this.speed += (this.targetSpeed - this.speed) * 0.15;

                // Consider lane change
                if (!this.laneChangeProgress && Math.random() < 0.01) {
                    this.considerLaneChange(vehicles);
                }
            }

            updateHuman(vehicles, ahead, dt) {
                // Simple car-following
                if (ahead) {
                    const gap = ahead.x - this.x - this.width;
                    if (gap < this.followDistance) {
                        this.targetSpeed = ahead.speed * 0.85;
                        if (gap < 20) {
                            stats.nearMisses++;
                        }
                    } else if (gap > this.followDistance * 1.5) {
                        this.targetSpeed = this.maxSpeed;
                    }
                } else {
                    this.targetSpeed = this.maxSpeed;
                }

                // Slower speed adjustment for humans
                this.speed += (this.targetSpeed - this.speed) * 0.08;

                // Occasional lane changes
                if (!this.laneChangeProgress && Math.random() < 0.005) {
                    this.considerLaneChange(vehicles);
                }
            }

            considerLaneChange(vehicles) {
                const currentLaneSpeed = this.speed;

                for (let targetLane of [this.lane - 1, this.lane + 1]) {
                    if (targetLane < 0 || targetLane >= road.lanes) continue;

                    // Check if lane is clear
                    const inTarget = vehicles.filter(v =>
                        v !== this &&
                        v.lane === targetLane &&
                        Math.abs(v.x - this.x) < 60
                    );

                    if (inTarget.length === 0) {
                        // Check if target lane is faster
                        const targetAhead = vehicles.filter(v =>
                            v.lane === targetLane && v.x > this.x
                        ).sort((a, b) => a.x - b.x)[0];

                        const targetGap = targetAhead ?
                            targetAhead.x - this.x : Infinity;

                        if (targetGap > 80 || (targetAhead && targetAhead.speed > this.speed)) {
                            this.targetLane = targetLane;
                            this.laneChangeProgress = 0.01;
                            return;
                        }
                    }
                }
            }

            draw(ctx) {
                const canvasW = canvas.width / window.devicePixelRatio;

                // V2V communication range (only for selected AV)
                if (this.isAV && features.v2v && this.x > canvasW * 0.4 && this.x < canvasW * 0.6) {
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.v2vRange, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Vehicle body
                let color;
                if (this.inPlatoon) {
                    color = '#22c55e';
                } else if (this.isAV) {
                    color = '#3b82f6';
                } else {
                    color = '#ef4444';
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.roundRect(
                    this.x - this.width / 2,
                    this.y - this.height / 2,
                    this.width,
                    this.height,
                    5
                );
                ctx.fill();

                // AV indicator
                if (this.isAV) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Headlights
                ctx.fillStyle = '#facc15';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 3, this.y - 5, 2, 0, Math.PI * 2);
                ctx.arc(this.x + this.width / 2 - 3, this.y + 5, 2, 0, Math.PI * 2);
                ctx.fill();

                // Platoon connection line
                if (this.inPlatoon && this.platoonLeader) {
                    ctx.strokeStyle = 'rgba(34, 197, 94, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.platoonLeader.x - this.platoonLeader.width / 2, this.platoonLeader.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        function spawnVehicle() {
            const isAV = Math.random() * 100 < params.avRatio;
            const lane = Math.floor(Math.random() * road.lanes);

            // Check if spawn position is clear
            const canSpawn = !vehicles.some(v =>
                v.lane === lane && v.x < 80
            );

            if (canSpawn) {
                vehicles.push(new Vehicle(lane, -30, isAV));
            }
        }

        function drawRoad(ctx, width, height) {
            const roadTop = (height - road.lanes * road.laneWidth) / 2;

            // Road surface
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, roadTop, width, road.lanes * road.laneWidth);

            // Lane markings
            ctx.strokeStyle = '#fff';
            ctx.setLineDash([30, 20]);
            ctx.lineWidth = 2;

            for (let i = 1; i < road.lanes; i++) {
                const y = roadTop + i * road.laneWidth;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            ctx.setLineDash([]);

            // Road edges
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, roadTop);
            ctx.lineTo(width, roadTop);
            ctx.moveTo(0, roadTop + road.lanes * road.laneWidth);
            ctx.lineTo(width, roadTop + road.lanes * road.laneWidth);
            ctx.stroke();
        }

        function countPlatoons() {
            const avs = vehicles.filter(v => v.isAV && v.inPlatoon);
            const leaders = new Set(avs.map(v => v.platoonLeader || v));
            return leaders.size;
        }

        function updateStats() {
            const now = Date.now();
            if (now - lastMinute >= 60000) {
                stats.throughput = vehiclesExited;
                vehiclesExited = 0;
                lastMinute = now;
            }

            document.getElementById('throughput').textContent = stats.throughput;

            const avgSpeed = vehicles.length > 0 ?
                (vehicles.reduce((sum, v) => sum + v.speed, 0) / vehicles.length * 10).toFixed(0) : 0;
            document.getElementById('avgSpeed').textContent = avgSpeed + ' mph';

            document.getElementById('nearMisses').textContent = stats.nearMisses;
            document.getElementById('platoons').textContent = countPlatoons();
        }

        function animate() {
            if (paused) {
                requestAnimationFrame(animate);
                return;
            }

            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            road.length = width;

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            drawRoad(ctx, width, height);

            // Spawn vehicles
            if (Math.random() < params.density / 500) {
                spawnVehicle();
            }

            // Update vehicles
            for (const v of vehicles) {
                v.update(vehicles, 1);
            }

            // Remove exited vehicles
            const before = vehicles.length;
            vehicles = vehicles.filter(v => v.x < width + 50);
            vehiclesExited += before - vehicles.length;

            // Draw vehicles
            for (const v of vehicles) {
                v.draw(ctx);
            }

            // Draw legend/info
            ctx.fillStyle = '#fff';
            ctx.font = '12px system-ui';
            ctx.textAlign = 'left';
            const avCount = vehicles.filter(v => v.isAV).length;
            const humanCount = vehicles.length - avCount;
            ctx.fillText(`AV: ${avCount}  Human: ${humanCount}`, 10, 20);

            updateStats();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('avRatio').addEventListener('input', (e) => {
            params.avRatio = parseInt(e.target.value);
            document.getElementById('avRatioVal').textContent = params.avRatio + '%';
            document.getElementById('ratioAV').style.width = params.avRatio + '%';
        });

        document.getElementById('density').addEventListener('input', (e) => {
            params.density = parseInt(e.target.value);
            document.getElementById('densityVal').textContent = params.density;
        });

        document.getElementById('humanReaction').addEventListener('input', (e) => {
            params.humanReaction = parseInt(e.target.value);
            document.getElementById('humanReactionVal').textContent = params.humanReaction;
        });

        document.getElementById('v2v').addEventListener('change', (e) => {
            features.v2v = e.target.checked;
        });

        document.getElementById('platooning').addEventListener('change', (e) => {
            features.platooning = e.target.checked;
        });

        document.getElementById('cooperative').addEventListener('change', (e) => {
            features.cooperative = e.target.checked;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            vehicles = [];
            stats = { throughput: 0, nearMisses: 0, platoonCount: 0 };
            vehiclesExited = 0;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        // Initialize
        requestAnimationFrame(animate);
    </script>
</body>
</html>
