<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Flow - Traffic & Urban</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #facc15; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #facc15; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(250, 204, 21, 0.1); border: 1px solid rgba(250, 204, 21, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #facc15; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #1a1a1a; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #facc15; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #facc15; color: #1a1a2e; }
        .btn-danger { background: #f87171; color: #fff; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .flow-indicator { display: flex; gap: 5px; margin: 15px 0; }
        .flow-bar { flex: 1; height: 20px; border-radius: 4px; transition: background 0.3s; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Traffic Flow</h1>
    <p class="subtitle">Nagel-Schreckenberg cellular automaton model</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="400"></canvas>
            <canvas id="chartCanvas" width="800" height="150" style="margin-top: 15px;"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Nagel-Schreckenberg Model:</strong>
                A cellular automaton for traffic flow simulation.
                Cars accelerate, slow for cars ahead, and randomly brake
                (modeling human behavior). Shows how jams emerge.
            </div>

            <h3>Traffic Flow</h3>
            <div class="flow-indicator" id="flowIndicator">
                <!-- Dynamic flow bars -->
            </div>

            <div class="control-group">
                <label>Car Density: <span class="value-display" id="densityVal">30%</span></label>
                <input type="range" id="densitySlider" min="5" max="80" value="30" oninput="updateParams()">
            </div>

            <div class="control-group">
                <label>Max Speed: <span class="value-display" id="speedVal">5</span> cells/step</label>
                <input type="range" id="speedSlider" min="2" max="10" value="5" oninput="updateParams()">
            </div>

            <div class="control-group">
                <label>Random Braking: <span class="value-display" id="brakeVal">20%</span></label>
                <input type="range" id="brakeSlider" min="0" max="50" value="20" oninput="updateParams()">
            </div>

            <div class="control-group">
                <label>Number of Lanes: <span class="value-display" id="laneVal">3</span></label>
                <input type="range" id="laneSlider" min="1" max="5" value="3" oninput="updateParams()">
            </div>

            <button class="btn-primary" onclick="toggleSim()">Start/Stop</button>
            <button class="btn-danger" onclick="createJam()">Create Traffic Jam</button>
            <button class="btn-secondary" onclick="resetSim()">Reset</button>

            <h3 style="margin-top: 15px;">Statistics</h3>
            <div style="font-size: 0.9em;">
                <div style="display: flex; justify-content: space-between; padding: 3px 0;">
                    <span>Avg Speed:</span><span class="value-display" id="avgSpeedVal">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 3px 0;">
                    <span>Flow Rate:</span><span class="value-display" id="flowVal">0 cars/min</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 3px 0;">
                    <span>Jams Detected:</span><span class="value-display" id="jamVal">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 3px 0;">
                    <span>Time:</span><span class="value-display" id="timeVal">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        const roadLength = 200;
        let lanes = [];
        let numLanes = 3;
        let density = 0.3;
        let maxSpeed = 5;
        let brakeProb = 0.2;
        let running = false;
        let time = 0;
        let flowHistory = [];
        let carsPassedPerLane = [];

        function updateParams() {
            density = parseInt(document.getElementById('densitySlider').value) / 100;
            maxSpeed = parseInt(document.getElementById('speedSlider').value);
            brakeProb = parseInt(document.getElementById('brakeSlider').value) / 100;
            const newLanes = parseInt(document.getElementById('laneSlider').value);

            document.getElementById('densityVal').textContent = Math.round(density * 100) + '%';
            document.getElementById('speedVal').textContent = maxSpeed;
            document.getElementById('brakeVal').textContent = Math.round(brakeProb * 100) + '%';
            document.getElementById('laneVal').textContent = newLanes;

            if (newLanes !== numLanes) {
                numLanes = newLanes;
                initRoad();
            }

            updateFlowIndicator();
        }

        function updateFlowIndicator() {
            const indicator = document.getElementById('flowIndicator');
            indicator.innerHTML = '';
            for (let i = 0; i < numLanes; i++) {
                const bar = document.createElement('div');
                bar.className = 'flow-bar';
                const laneFlow = carsPassedPerLane[i] || 0;
                const hue = Math.max(0, 120 - laneFlow * 2);
                bar.style.background = `hsl(${hue}, 70%, 50%)`;
                indicator.appendChild(bar);
            }
        }

        function initRoad() {
            lanes = [];
            carsPassedPerLane = new Array(numLanes).fill(0);

            for (let lane = 0; lane < numLanes; lane++) {
                const road = new Array(roadLength).fill(null);
                const numCars = Math.floor(roadLength * density);

                for (let i = 0; i < numCars; i++) {
                    let pos;
                    do {
                        pos = Math.floor(Math.random() * roadLength);
                    } while (road[pos] !== null);

                    road[pos] = {
                        speed: Math.floor(Math.random() * maxSpeed),
                        color: `hsl(${Math.random() * 60 + 180}, 70%, 50%)`
                    };
                }

                lanes.push(road);
            }
        }

        function updateTraffic() {
            time++;

            for (let laneIdx = 0; laneIdx < lanes.length; laneIdx++) {
                const road = lanes[laneIdx];
                const newRoad = new Array(roadLength).fill(null);

                for (let i = 0; i < roadLength; i++) {
                    if (road[i] !== null) {
                        const car = road[i];

                        // Rule 1: Acceleration
                        if (car.speed < maxSpeed) {
                            car.speed++;
                        }

                        // Rule 2: Slowing down
                        let gap = 1;
                        while (road[(i + gap) % roadLength] === null && gap <= maxSpeed) {
                            gap++;
                        }
                        gap--;
                        if (car.speed > gap) {
                            car.speed = gap;
                        }

                        // Rule 3: Randomization (random braking)
                        if (car.speed > 0 && Math.random() < brakeProb) {
                            car.speed--;
                        }

                        // Rule 4: Car motion
                        const newPos = (i + car.speed) % roadLength;

                        // Track cars passing the end
                        if (i + car.speed >= roadLength) {
                            carsPassedPerLane[laneIdx]++;
                        }

                        if (newRoad[newPos] === null) {
                            newRoad[newPos] = car;
                        } else {
                            // Collision avoidance - stay in place
                            newRoad[i] = car;
                        }
                    }
                }

                lanes[laneIdx] = newRoad;
            }

            updateStats();
        }

        function updateStats() {
            let totalSpeed = 0;
            let carCount = 0;
            let jams = 0;
            let consecutiveStopped = 0;

            for (const road of lanes) {
                for (let i = 0; i < roadLength; i++) {
                    if (road[i] !== null) {
                        totalSpeed += road[i].speed;
                        carCount++;

                        if (road[i].speed === 0) {
                            consecutiveStopped++;
                            if (consecutiveStopped >= 3) jams++;
                        } else {
                            consecutiveStopped = 0;
                        }
                    }
                }
            }

            const avgSpeed = carCount > 0 ? (totalSpeed / carCount).toFixed(2) : 0;
            const totalFlow = carsPassedPerLane.reduce((a, b) => a + b, 0);
            const flowRate = time > 0 ? (totalFlow / time * 60).toFixed(1) : 0;

            document.getElementById('avgSpeedVal').textContent = avgSpeed + ' cells/step';
            document.getElementById('flowVal').textContent = flowRate + ' cars/min';
            document.getElementById('jamVal').textContent = Math.floor(jams / 3);
            document.getElementById('timeVal').textContent = time;

            // Record history
            flowHistory.push({ t: time, flow: parseFloat(flowRate), speed: parseFloat(avgSpeed) });
            if (flowHistory.length > 200) flowHistory.shift();

            updateFlowIndicator();
        }

        function createJam() {
            // Stop some cars to create a jam
            for (const road of lanes) {
                const jamStart = Math.floor(roadLength / 2);
                for (let i = jamStart; i < jamStart + 20 && i < roadLength; i++) {
                    if (road[i] !== null) {
                        road[i].speed = 0;
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const laneHeight = (canvas.height - 40) / numLanes;
            const cellWidth = (canvas.width - 40) / roadLength;

            for (let laneIdx = 0; laneIdx < lanes.length; laneIdx++) {
                const road = lanes[laneIdx];
                const y = 20 + laneIdx * laneHeight;

                // Road surface
                ctx.fillStyle = '#333';
                ctx.fillRect(20, y + 10, canvas.width - 40, laneHeight - 20);

                // Lane markings
                ctx.strokeStyle = '#facc15';
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(20, y + laneHeight / 2);
                ctx.lineTo(canvas.width - 20, y + laneHeight / 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw cars
                for (let i = 0; i < roadLength; i++) {
                    if (road[i] !== null) {
                        const car = road[i];
                        const x = 20 + i * cellWidth;
                        const carY = y + laneHeight / 2 - 8;

                        // Color based on speed
                        const speedRatio = car.speed / maxSpeed;
                        const hue = speedRatio * 120; // Red (stopped) to green (fast)
                        ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;

                        // Car body
                        ctx.fillRect(x, carY, cellWidth * 0.8, 16);

                        // Windows
                        ctx.fillStyle = '#333';
                        ctx.fillRect(x + cellWidth * 0.15, carY + 2, cellWidth * 0.2, 5);
                        ctx.fillRect(x + cellWidth * 0.5, carY + 2, cellWidth * 0.2, 5);
                    }
                }

                // Lane label
                ctx.fillStyle = '#aaa';
                ctx.font = '12px sans-serif';
                ctx.fillText(`Lane ${laneIdx + 1}`, 25, y + 25);
            }

            // Road edges
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(20, 15);
            ctx.lineTo(canvas.width - 20, 15);
            ctx.moveTo(20, canvas.height - 15);
            ctx.lineTo(canvas.width - 20, canvas.height - 15);
            ctx.stroke();
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a14';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (flowHistory.length < 2) return;

            const maxFlow = Math.max(...flowHistory.map(h => h.flow), 100);
            const scaleX = (chartCanvas.width - 60) / 200;
            const scaleY = (chartCanvas.height - 40) / maxFlow;

            // Flow rate line
            cctx.strokeStyle = '#4ade80';
            cctx.lineWidth = 2;
            cctx.beginPath();
            flowHistory.forEach((h, i) => {
                const x = 50 + (h.t - flowHistory[0].t) * scaleX;
                const y = chartCanvas.height - 25 - h.flow * scaleY;
                if (i === 0) cctx.moveTo(x, y);
                else cctx.lineTo(x, y);
            });
            cctx.stroke();

            // Axes
            cctx.strokeStyle = 'rgba(255,255,255,0.3)';
            cctx.lineWidth = 1;
            cctx.beginPath();
            cctx.moveTo(50, 10);
            cctx.lineTo(50, chartCanvas.height - 25);
            cctx.lineTo(chartCanvas.width - 10, chartCanvas.height - 25);
            cctx.stroke();

            // Labels
            cctx.fillStyle = '#aaa';
            cctx.font = '11px sans-serif';
            cctx.textAlign = 'center';
            cctx.fillText('Time', chartCanvas.width / 2, chartCanvas.height - 5);
            cctx.textAlign = 'right';
            cctx.fillText('Flow', 45, 20);
        }

        function toggleSim() {
            running = !running;
            if (running) animate();
        }

        function resetSim() {
            running = false;
            time = 0;
            flowHistory = [];
            carsPassedPerLane = new Array(numLanes).fill(0);
            initRoad();
            updateStats();
            draw();
            drawChart();
        }

        function animate() {
            if (!running) return;
            updateTraffic();
            draw();
            drawChart();
            setTimeout(() => requestAnimationFrame(animate), 100);
        }

        updateParams();
        resetSim();
    </script>
</body>
</html>
