<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Sorting Particles - Collective Intelligence - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 15px; left: 15px; z-index: 100;
            color: #8A9A5B; text-decoration: none;
            background: rgba(10,14,26,0.8); border: 2px solid #8A9A5B;
            border-radius: 25px; padding: 10px 20px;
            font-size: 14px; font-weight: 500;
            transition: background 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 15px; right: 15px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h3 {
            font-size: 14px; color: #8A9A5B; margin-bottom: 12px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .control-group { margin-bottom: 12px; }
        .control-group label {
            display: block; font-size: 12px; color: #999; margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%; accent-color: #8A9A5B;
        }
        .control-group .value {
            float: right; color: #8A9A5B; font-size: 12px; font-weight: 600;
        }
        .metrics {
            margin-top: 15px; padding-top: 12px;
            border-top: 1px solid rgba(138,154,91,0.2);
        }
        .metric {
            display: flex; justify-content: space-between;
            font-size: 12px; margin-bottom: 6px;
        }
        .metric-label { color: #888; }
        .metric-value { color: #DDA15E; font-weight: 600; }
        .btn {
            width: 100%; padding: 8px; margin-top: 8px;
            background: rgba(138,154,91,0.3); border: 1px solid #8A9A5B;
            color: #8A9A5B; border-radius: 6px; cursor: pointer;
            font-size: 12px; font-weight: 600;
            transition: background 0.3s;
        }
        .btn:hover { background: rgba(138,154,91,0.5); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Collective Intelligence</a>
    <div class="controls">
        <h3>Self-Sorting Particles</h3>
        <div class="control-group">
            <label>Tolerance Threshold <span class="value" id="toleranceVal">40%</span></label>
            <input type="range" id="tolerance" min="10" max="80" value="40">
        </div>
        <div class="control-group">
            <label>Particle Count <span class="value" id="countVal">500</span></label>
            <input type="range" id="particleCount" min="200" max="1200" value="500" step="50">
        </div>
        <div class="control-group">
            <label>Colors <span class="value" id="colorsVal">4</span></label>
            <input type="range" id="numColors" min="2" max="6" value="4">
        </div>
        <div class="control-group">
            <label>Sensing Radius <span class="value" id="radiusVal">40</span></label>
            <input type="range" id="sensingRadius" min="15" max="80" value="40">
        </div>
        <div class="metrics">
            <div class="metric">
                <span class="metric-label">Segregation Index</span>
                <span class="metric-value" id="segregationIdx">0%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Frame</span>
                <span class="metric-value" id="frameCount">0</span>
            </div>
        </div>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        let particles = [];
        let animId;
        let paused = false;
        let frame = 0;

        const COLORS = [
            '#ff4466', '#4488ff', '#44dd66', '#ffcc33',
            '#cc66ff', '#ff8844'
        ];

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        function getParams() {
            return {
                tolerance: parseInt(document.getElementById('tolerance').value) / 100,
                count: parseInt(document.getElementById('particleCount').value),
                numColors: parseInt(document.getElementById('numColors').value),
                radius: parseInt(document.getElementById('sensingRadius').value)
            };
        }

        function initParticles() {
            const p = getParams();
            particles = [];
            frame = 0;
            for (let i = 0; i < p.count; i++) {
                particles.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    color: Math.floor(Math.random() * p.numColors),
                    vx: 0, vy: 0,
                    satisfied: false
                });
            }
        }

        // Spatial grid for neighbor queries
        function buildGrid(radius) {
            const cellSize = radius;
            const cols = Math.ceil(W / cellSize);
            const rows = Math.ceil(H / cellSize);
            const grid = new Array(cols * rows);
            for (let i = 0; i < grid.length; i++) grid[i] = [];
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const gx = Math.min(Math.floor(p.x / cellSize), cols - 1);
                const gy = Math.min(Math.floor(p.y / cellSize), rows - 1);
                if (gx >= 0 && gy >= 0) {
                    grid[gy * cols + gx].push(i);
                }
            }
            return { grid, cols, rows, cellSize };
        }

        function getNeighbors(idx, spatial, radius) {
            const p = particles[idx];
            const { grid, cols, rows, cellSize } = spatial;
            const gx = Math.floor(p.x / cellSize);
            const gy = Math.floor(p.y / cellSize);
            const r2 = radius * radius;
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = gx + dx;
                    const ny = gy + dy;
                    if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
                    const cell = grid[ny * cols + nx];
                    for (let j = 0; j < cell.length; j++) {
                        const other = cell[j];
                        if (other === idx) continue;
                        const op = particles[other];
                        const ddx = p.x - op.x;
                        const ddy = p.y - op.y;
                        if (ddx * ddx + ddy * ddy <= r2) {
                            neighbors.push(other);
                        }
                    }
                }
            }
            return neighbors;
        }

        function update() {
            const params = getParams();
            const radius = params.radius;
            const tolerance = params.tolerance;
            const spatial = buildGrid(radius);
            let totalSameRatio = 0;
            let counted = 0;

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const neighbors = getNeighbors(i, spatial, radius);
                if (neighbors.length === 0) {
                    p.satisfied = true;
                    continue;
                }
                let same = 0;
                for (let j = 0; j < neighbors.length; j++) {
                    if (particles[neighbors[j]].color === p.color) same++;
                }
                const ratio = same / neighbors.length;
                totalSameRatio += ratio;
                counted++;

                if (ratio < tolerance) {
                    // Unhappy: move randomly
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.satisfied = false;
                } else {
                    // Happy: tiny jitter
                    p.vx = (Math.random() - 0.5) * 0.3;
                    p.vy = (Math.random() - 0.5) * 0.3;
                    p.satisfied = true;
                }
            }

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                // Wrap around
                if (p.x < 0) p.x += W;
                if (p.x >= W) p.x -= W;
                if (p.y < 0) p.y += H;
                if (p.y >= H) p.y -= H;
            }

            const segregation = counted > 0 ? totalSameRatio / counted : 0;
            document.getElementById('segregationIdx').textContent =
                (segregation * 100).toFixed(1) + '%';
            document.getElementById('frameCount').textContent = frame;
            frame++;
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 14, 26, 0.15)';
            ctx.fillRect(0, 0, W, H);

            const numColors = getParams().numColors;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const color = COLORS[p.color % COLORS.length];
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.satisfied ? 2.5 : 3.5, 0, Math.PI * 2);
                ctx.fillStyle = p.satisfied ? color : color + 'aa';
                ctx.fill();
                if (!p.satisfied) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.strokeStyle = color + '30';
                    ctx.stroke();
                }
            }
        }

        function animate() {
            if (!paused) {
                update();
            }
            draw();
            animId = requestAnimationFrame(animate);
        }

        function reset() {
            cancelAnimationFrame(animId);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);
            initParticles();
            animate();
        }
        window.reset = reset;

        // UI bindings
        document.getElementById('tolerance').oninput = function() {
            document.getElementById('toleranceVal').textContent = this.value + '%';
        };
        document.getElementById('particleCount').oninput = function() {
            document.getElementById('countVal').textContent = this.value;
        };
        document.getElementById('numColors').oninput = function() {
            document.getElementById('colorsVal').textContent = this.value;
        };
        document.getElementById('sensingRadius').oninput = function() {
            document.getElementById('radiusVal').textContent = this.value;
        };
        document.getElementById('resetBtn').onclick = reset;

        // Reset on count/colors change
        document.getElementById('particleCount').onchange = reset;
        document.getElementById('numColors').onchange = reset;

        initParticles();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
