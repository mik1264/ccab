<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Army Ant Living Bridges</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8); border-radius: 25px;
            border: 2px solid #8A9A5B; padding: 10px 20px; text-decoration: none;
            font-size: 14px; transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            color: #c0c8e0; font-size: 13px;
        }
        .controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 4px; color: #9aa0b8; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group .value { float: right; color: #8A9A5B; font-weight: bold; }
        .metric { margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1); border-radius: 6px; }
        .metric .label { color: #9aa0b8; font-size: 11px; }
        .metric .val { color: #DDA15E; font-size: 16px; font-weight: bold; }
        .btn { background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid #8A9A5B;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 8px; }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .desc { color: #777; font-size: 11px; margin-top: 10px; line-height: 1.4; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Collective Intelligence</a>
    <div class="controls">
        <h3>Army Ant Living Bridges</h3>
        <div class="control-group">
            <label>Ant Count <span class="value" id="antVal">200</span></label>
            <input type="range" id="antCount" min="50" max="400" value="200" step="10">
        </div>
        <div class="control-group">
            <label>Bridge Threshold <span class="value" id="threshVal">0.5</span></label>
            <input type="range" id="bridgeThresh" min="0.1" max="1.0" value="0.5" step="0.05">
        </div>
        <div class="control-group">
            <label>Gap Width <span class="value" id="gapVal">200</span></label>
            <input type="range" id="gapWidth" min="80" max="350" value="200" step="10">
        </div>
        <div class="control-group">
            <label>Ant Speed <span class="value" id="speedVal">2.0</span></label>
            <input type="range" id="antSpeed" min="1.0" max="4.0" value="2.0" step="0.2">
        </div>
        <button class="btn" id="resetBtn">Reset</button>
        <div class="metrics-grid">
            <div class="metric">
                <div class="label">Bridge Ants</div>
                <div class="val" id="bridgeCount">0</div>
            </div>
            <div class="metric">
                <div class="label">Walking Ants</div>
                <div class="val" id="walkerCount">0</div>
            </div>
            <div class="metric">
                <div class="label">Crossings/sec</div>
                <div class="val" id="throughput">0</div>
            </div>
            <div class="metric">
                <div class="label">Trips Completed</div>
                <div class="val" id="totalTrips">0</div>
            </div>
        </div>
        <p class="desc">Ants self-organize a living bridge across the gap. Too many bridge ants means not enough walkers -- the system self-regulates.</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();

        let paused = false;
        let totalTrips = 0;
        let crossingsInWindow = [];

        // Terrain geometry
        let pathY, gapLeft, gapRight, gapBottom;
        let bridgeAnts = []; // ants forming the bridge
        let walkerAnts = [];

        function computeTerrain() {
            const gapW = parseInt(document.getElementById('gapWidth').value);
            pathY = H * 0.45; // path surface level
            gapLeft = W / 2 - gapW / 2;
            gapRight = W / 2 + gapW / 2;
            gapBottom = pathY + Math.min(gapW * 0.8, H * 0.35);
        }

        // The bridge is a catenary-like chain of ant positions from left edge to right edge
        function computeBridgePath() {
            if (bridgeAnts.length < 2) return [];
            const n = bridgeAnts.length;
            const points = [];
            for (let i = 0; i < n; i++) {
                const t = i / (n - 1);
                const x = gapLeft + t * (gapRight - gapLeft);
                // Catenary sag
                const sag = Math.sin(t * Math.PI) * Math.min(n * 0.5, (gapBottom - pathY) * 0.6);
                const y = pathY + sag;
                points.push({ x, y });
            }
            return points;
        }

        class WalkerAnt {
            constructor() {
                this.reset();
            }
            reset() {
                // Start from left or right
                this.goingRight = Math.random() < 0.5;
                this.x = this.goingRight ? 30 + Math.random() * 50 : W - 30 - Math.random() * 50;
                this.y = pathY - 2 - Math.random() * 4;
                this.onBridge = false;
                this.bridgeProgress = 0;
                this.speed = parseFloat(document.getElementById('antSpeed').value) * (0.8 + Math.random() * 0.4);
                this.wobble = Math.random() * Math.PI * 2;
            }
        }

        function initAnts() {
            const count = parseInt(document.getElementById('antCount').value);
            walkerAnts = [];
            bridgeAnts = [];
            for (let i = 0; i < count; i++) {
                walkerAnts.push(new WalkerAnt());
            }
            totalTrips = 0;
            crossingsInWindow = [];
        }

        function updateWalkers() {
            const threshold = parseFloat(document.getElementById('bridgeThresh').value);
            const gapW = gapRight - gapLeft;
            const bridgePoints = computeBridgePath();
            const bridgeComplete = bridgeAnts.length >= Math.ceil(gapW / 10);

            // How many walkers are near the gap waiting?
            let waitingAtGap = 0;
            for (const a of walkerAnts) {
                if (!a.onBridge) {
                    const edgeDist = a.goingRight ? (gapLeft - a.x) : (a.x - gapRight);
                    if (edgeDist > -20 && edgeDist < 30) {
                        waitingAtGap++;
                    }
                }
            }

            // Traffic pressure determines bridge building
            const trafficPressure = waitingAtGap / Math.max(walkerAnts.length, 1);

            for (let i = walkerAnts.length - 1; i >= 0; i--) {
                const a = walkerAnts[i];

                if (a.onBridge) {
                    // Walk along bridge
                    if (bridgePoints.length < 2) {
                        a.onBridge = false;
                        continue;
                    }
                    a.bridgeProgress += a.speed * 0.8 / (gapRight - gapLeft);
                    if (a.bridgeProgress >= 1) {
                        // Crossed the bridge
                        a.onBridge = false;
                        a.x = a.goingRight ? gapRight + 5 : gapLeft - 5;
                        a.y = pathY - 2;
                        totalTrips++;
                        crossingsInWindow.push(Date.now());
                    }
                } else {
                    // Walk along path
                    const dir = a.goingRight ? 1 : -1;
                    a.x += dir * a.speed;
                    a.wobble += 0.1;
                    a.y = pathY - 2 + Math.sin(a.wobble) * 1.5;

                    // Check if reached the gap edge
                    if (a.goingRight && a.x >= gapLeft - 5) {
                        if (bridgeComplete) {
                            // Use the bridge
                            a.onBridge = true;
                            a.bridgeProgress = 0;
                        } else if (trafficPressure > threshold && bridgeAnts.length < Math.ceil(gapW / 10)) {
                            // Become a bridge ant
                            bridgeAnts.push({ fromWalker: true });
                            walkerAnts.splice(i, 1);
                            continue;
                        } else {
                            // Wait / walk the long way (bounce back and wander, then try again)
                            a.x = gapLeft - 8;
                            if (Math.random() < 0.05) {
                                // Some go around the long way (teleport with delay)
                                a.x = a.goingRight ? gapRight + 10 : gapLeft - 10;
                                totalTrips++;
                                crossingsInWindow.push(Date.now());
                                // simulate long path time
                            }
                        }
                    } else if (!a.goingRight && a.x <= gapRight + 5) {
                        if (bridgeComplete) {
                            a.onBridge = true;
                            a.bridgeProgress = 1;
                            a.speed = -Math.abs(a.speed);
                            // Actually, let's handle reverse properly
                            a.bridgeProgress = 1;
                            a.onBridge = true;
                        } else if (trafficPressure > threshold && bridgeAnts.length < Math.ceil(gapW / 10)) {
                            bridgeAnts.push({ fromWalker: true });
                            walkerAnts.splice(i, 1);
                            continue;
                        } else {
                            a.x = gapRight + 8;
                            if (Math.random() < 0.05) {
                                a.x = a.goingRight ? gapRight + 10 : gapLeft - 10;
                                totalTrips++;
                                crossingsInWindow.push(Date.now());
                            }
                        }
                    }

                    // Wrap around (go back and forth)
                    if (a.x < 10) {
                        a.goingRight = true;
                        a.x = 10;
                    }
                    if (a.x > W - 10) {
                        a.goingRight = false;
                        a.x = W - 10;
                    }
                }
            }

            // Bridge regulation: if too many bridge ants and low traffic, some leave
            const maxBridge = Math.ceil(gapW / 10);
            if (bridgeAnts.length > maxBridge) {
                const excess = bridgeAnts.length - maxBridge;
                for (let i = 0; i < excess; i++) {
                    bridgeAnts.pop();
                    const newAnt = new WalkerAnt();
                    newAnt.x = gapLeft - 20 - Math.random() * 30;
                    walkerAnts.push(newAnt);
                }
            }

            // If traffic is very low and bridge is complete, some bridge ants leave
            if (bridgeAnts.length > 3 && trafficPressure < threshold * 0.3 && Math.random() < 0.02) {
                bridgeAnts.pop();
                const newAnt = new WalkerAnt();
                newAnt.x = gapLeft - 20;
                walkerAnts.push(newAnt);
            }

            // Handle reverse direction on bridge
            for (const a of walkerAnts) {
                if (a.onBridge && !a.goingRight) {
                    a.bridgeProgress -= Math.abs(a.speed) * 0.8 / (gapRight - gapLeft);
                    if (a.bridgeProgress <= 0) {
                        a.onBridge = false;
                        a.x = gapLeft - 5;
                        a.y = pathY - 2;
                        totalTrips++;
                        crossingsInWindow.push(Date.now());
                    }
                }
            }

            // Clean old crossings from window
            const now = Date.now();
            crossingsInWindow = crossingsInWindow.filter(t => now - t < 5000);
        }

        function drawTerrain() {
            const gapW = gapRight - gapLeft;

            // Sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, pathY);
            skyGrad.addColorStop(0, '#0a0e1a');
            skyGrad.addColorStop(1, '#0d1225');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, W, pathY);

            // Ground / path surface
            ctx.fillStyle = '#1a1e30';
            ctx.fillRect(0, pathY, W, H - pathY);

            // Path surface highlight
            ctx.fillStyle = '#252a40';
            ctx.fillRect(0, pathY - 3, gapLeft, 6);
            ctx.fillRect(gapRight, pathY - 3, W - gapRight, 6);

            // Gap (ravine)
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(gapLeft, pathY);
            ctx.lineTo(gapLeft, gapBottom);
            ctx.quadraticCurveTo(W / 2, gapBottom + 20, gapRight, gapBottom);
            ctx.lineTo(gapRight, pathY);
            ctx.closePath();

            const ravineGrad = ctx.createLinearGradient(0, pathY, 0, gapBottom + 20);
            ravineGrad.addColorStop(0, '#0a0c18');
            ravineGrad.addColorStop(1, '#050710');
            ctx.fillStyle = ravineGrad;
            ctx.fill();
            ctx.restore();

            // Ravine edges
            ctx.strokeStyle = '#2a3050';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(gapLeft, pathY - 3);
            ctx.lineTo(gapLeft, gapBottom);
            ctx.quadraticCurveTo(W / 2, gapBottom + 20, gapRight, gapBottom);
            ctx.lineTo(gapRight, pathY - 3);
            ctx.stroke();

            // Edge highlights
            ctx.strokeStyle = '#3a4060';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(gapLeft + 1, pathY);
            ctx.lineTo(gapLeft + 1, pathY + 30);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(gapRight - 1, pathY);
            ctx.lineTo(gapRight - 1, pathY + 30);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#556';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('RAVINE', W / 2, gapBottom - 10);

            // Direction arrows
            ctx.fillStyle = '#445';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('>>> path >>>',  gapLeft / 2 - 40, pathY - 15);
            ctx.textAlign = 'right';
            ctx.fillText('>>> path >>>', W - (W - gapRight) / 2 + 40, pathY - 15);
        }

        function drawBridge() {
            const points = computeBridgePath();
            if (points.length < 2) return;

            // Draw bridge chain
            ctx.strokeStyle = '#e08030';
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                if (i === 0) ctx.moveTo(points[i].x, points[i].y);
                else ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();

            // Bridge ant nodes
            ctx.fillStyle = '#e0a050';
            for (const p of points) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow
            ctx.save();
            ctx.shadowColor = '#e0803080';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = 'rgba(224,128,48,0.3)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                if (i === 0) ctx.moveTo(points[i].x, points[i].y);
                else ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawWalkers() {
            const bridgePoints = computeBridgePath();

            for (const a of walkerAnts) {
                let ax, ay;
                if (a.onBridge && bridgePoints.length >= 2) {
                    const t = Math.max(0, Math.min(1, a.bridgeProgress));
                    const idx = t * (bridgePoints.length - 1);
                    const i0 = Math.floor(idx);
                    const i1 = Math.min(i0 + 1, bridgePoints.length - 1);
                    const frac = idx - i0;
                    ax = bridgePoints[i0].x + (bridgePoints[i1].x - bridgePoints[i0].x) * frac;
                    ay = bridgePoints[i0].y + (bridgePoints[i1].y - bridgePoints[i0].y) * frac - 6;
                } else {
                    ax = a.x;
                    ay = a.y;
                }

                ctx.beginPath();
                ctx.arc(ax, ay, 3, 0, Math.PI * 2);
                ctx.fillStyle = a.onBridge ? '#ffcc60' : '#e08840';
                ctx.fill();
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            drawTerrain();
            drawBridge();
            drawWalkers();

            // Update metrics
            document.getElementById('bridgeCount').textContent = bridgeAnts.length;
            document.getElementById('walkerCount').textContent = walkerAnts.length;
            document.getElementById('totalTrips').textContent = totalTrips;
            const throughput = crossingsInWindow.length / 5;
            document.getElementById('throughput').textContent = throughput.toFixed(1);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (paused) return;

            computeTerrain();
            updateWalkers();
            draw();
        }

        function fullReset() {
            computeTerrain();
            initAnts();
        }

        fullReset();
        animate();

        // Controls
        document.getElementById('antCount').oninput = function() {
            document.getElementById('antVal').textContent = this.value;
        };
        document.getElementById('bridgeThresh').oninput = function() {
            document.getElementById('threshVal').textContent = parseFloat(this.value).toFixed(2);
        };
        document.getElementById('gapWidth').oninput = function() {
            document.getElementById('gapVal').textContent = this.value;
            computeTerrain();
            // Reset bridge when gap changes significantly
            bridgeAnts = [];
        };
        document.getElementById('antSpeed').oninput = function() {
            document.getElementById('speedVal').textContent = parseFloat(this.value).toFixed(1);
        };

        document.getElementById('resetBtn').onclick = fullReset;
        window.reset = fullReset;

        window.addEventListener('resize', function() {
            resize();
            fullReset();
        });

        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && e.target === document.body) {
                paused = !paused;
            }
        });
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
