<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School vs Predator - Collective Intelligence - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        canvas { display: block; cursor: crosshair; }
        .back-link {
            position: fixed; top: 15px; left: 15px; z-index: 100;
            color: #8A9A5B; text-decoration: none;
            background: rgba(10,14,26,0.8); border: 2px solid #8A9A5B;
            border-radius: 25px; padding: 10px 20px;
            font-size: 14px; font-weight: 500;
            transition: background 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 15px; right: 15px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h3 {
            font-size: 14px; color: #8A9A5B; margin-bottom: 12px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .control-group { margin-bottom: 10px; }
        .control-group label {
            display: block; font-size: 12px; color: #999; margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%; accent-color: #8A9A5B;
        }
        .control-group .value {
            float: right; color: #8A9A5B; font-size: 12px; font-weight: 600;
        }
        .toggle-row {
            display: flex; align-items: center; gap: 8px;
            margin-bottom: 10px; font-size: 12px;
        }
        .toggle-row input { accent-color: #8A9A5B; }
        .metrics {
            margin-top: 12px; padding-top: 10px;
            border-top: 1px solid rgba(138,154,91,0.2);
        }
        .metric {
            display: flex; justify-content: space-between;
            font-size: 12px; margin-bottom: 5px;
        }
        .metric-label { color: #888; }
        .metric-value { color: #DDA15E; font-weight: 600; }
        .btn {
            width: 100%; padding: 8px; margin-top: 8px;
            background: rgba(138,154,91,0.3); border: 1px solid #8A9A5B;
            color: #8A9A5B; border-radius: 6px; cursor: pointer;
            font-size: 12px; font-weight: 600;
            transition: background 0.3s;
        }
        .btn:hover { background: rgba(138,154,91,0.5); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Collective Intelligence</a>
    <div class="controls">
        <h3>School vs Predator</h3>
        <div class="control-group">
            <label>Fish Count <span class="value" id="fishCountVal">300</span></label>
            <input type="range" id="fishCount" min="100" max="600" value="300" step="25">
        </div>
        <div class="control-group">
            <label>Predator Speed <span class="value" id="predSpeedVal">3.5</span></label>
            <input type="range" id="predSpeed" min="15" max="50" value="35">
        </div>
        <div class="control-group">
            <label>Flee Radius <span class="value" id="fleeRadVal">120</span></label>
            <input type="range" id="fleeRadius" min="50" max="250" value="120">
        </div>
        <div class="control-group">
            <label>Cohesion <span class="value" id="cohesionVal">1.0</span></label>
            <input type="range" id="cohesion" min="1" max="30" value="10">
        </div>
        <div class="control-group">
            <label>Alignment <span class="value" id="alignVal">1.0</span></label>
            <input type="range" id="alignment" min="1" max="30" value="10">
        </div>
        <div class="control-group">
            <label>Separation <span class="value" id="sepVal">1.5</span></label>
            <input type="range" id="separation" min="5" max="40" value="15">
        </div>
        <div class="toggle-row">
            <input type="checkbox" id="autoPredator" checked>
            <label for="autoPredator" style="color:#999;">Auto Predator (uncheck for mouse)</label>
        </div>
        <div class="metrics">
            <div class="metric">
                <span class="metric-label">Captures</span>
                <span class="metric-value" id="captures">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">School Cohesion</span>
                <span class="metric-value" id="cohesionMetric">0%</span>
            </div>
        </div>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        let fish = [];
        let predator;
        let captures = 0;
        let animId;
        let paused = false;
        let mouseX, mouseY;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        canvas.addEventListener('mousemove', function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function getParams() {
            return {
                count: parseInt(document.getElementById('fishCount').value),
                predSpeed: parseInt(document.getElementById('predSpeed').value) / 10,
                fleeRadius: parseInt(document.getElementById('fleeRadius').value),
                cohesion: parseInt(document.getElementById('cohesion').value) / 10,
                alignment: parseInt(document.getElementById('alignment').value) / 10,
                separation: parseInt(document.getElementById('separation').value) / 10,
                autoPredator: document.getElementById('autoPredator').checked
            };
        }

        function initSim() {
            const p = getParams();
            fish = [];
            captures = 0;
            document.getElementById('captures').textContent = '0';
            const cx = W / 2, cy = H / 2;
            for (let i = 0; i < p.count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 150;
                fish.push({
                    x: cx + Math.cos(angle) * r,
                    y: cy + Math.sin(angle) * r,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    alive: true
                });
            }
            predator = {
                x: W * 0.1,
                y: H * 0.1,
                vx: 1, vy: 1,
                targetIdx: -1,
                cooldown: 0
            };
        }

        function update() {
            const p = getParams();
            const maxSpeed = 2.5;
            const perceptionRadius = 50;
            const sepDist = 18;
            const alive = fish.filter(f => f.alive);

            // Boids rules for each fish
            for (let i = 0; i < fish.length; i++) {
                const f = fish[i];
                if (!f.alive) continue;

                let cohX = 0, cohY = 0, cohCount = 0;
                let aliVx = 0, aliVy = 0, aliCount = 0;
                let sepX = 0, sepY = 0;

                for (let j = 0; j < fish.length; j++) {
                    if (i === j || !fish[j].alive) continue;
                    const dx = fish[j].x - f.x;
                    const dy = fish[j].y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < perceptionRadius) {
                        cohX += fish[j].x;
                        cohY += fish[j].y;
                        cohCount++;
                        aliVx += fish[j].vx;
                        aliVy += fish[j].vy;
                        aliCount++;
                    }
                    if (dist < sepDist && dist > 0) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                    }
                }

                let ax = 0, ay = 0;
                if (cohCount > 0) {
                    ax += (cohX / cohCount - f.x) * p.cohesion * 0.01;
                    ay += (cohY / cohCount - f.y) * p.cohesion * 0.01;
                }
                if (aliCount > 0) {
                    ax += (aliVx / aliCount - f.vx) * p.alignment * 0.1;
                    ay += (aliVy / aliCount - f.vy) * p.alignment * 0.1;
                }
                ax += sepX * p.separation * 0.3;
                ay += sepY * p.separation * 0.3;

                // Flee from predator
                const pdx = f.x - predator.x;
                const pdy = f.y - predator.y;
                const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                if (pdist < p.fleeRadius && pdist > 0) {
                    const fleeStr = (p.fleeRadius - pdist) / p.fleeRadius;
                    ax += (pdx / pdist) * fleeStr * 4;
                    ay += (pdy / pdist) * fleeStr * 4;
                }

                // Edge avoidance
                const margin = 60;
                if (f.x < margin) ax += (margin - f.x) * 0.02;
                if (f.x > W - margin) ax -= (f.x - (W - margin)) * 0.02;
                if (f.y < margin) ay += (margin - f.y) * 0.02;
                if (f.y > H - margin) ay -= (f.y - (H - margin)) * 0.02;

                f.vx += ax;
                f.vy += ay;
                const spd = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
                if (spd > maxSpeed) {
                    f.vx = f.vx / spd * maxSpeed;
                    f.vy = f.vy / spd * maxSpeed;
                }
                f.x += f.vx;
                f.y += f.vy;
            }

            // Predator logic
            if (predator.cooldown > 0) predator.cooldown--;

            if (p.autoPredator) {
                // Hunt the most isolated fish
                if (predator.targetIdx < 0 || !fish[predator.targetIdx] ||
                    !fish[predator.targetIdx].alive || Math.random() < 0.01) {
                    let bestIsolation = -1;
                    let bestIdx = -1;
                    for (let i = 0; i < fish.length; i++) {
                        if (!fish[i].alive) continue;
                        let nearCount = 0;
                        for (let j = 0; j < fish.length; j++) {
                            if (i === j || !fish[j].alive) continue;
                            const dx = fish[i].x - fish[j].x;
                            const dy = fish[i].y - fish[j].y;
                            if (dx * dx + dy * dy < 60 * 60) nearCount++;
                        }
                        const isolation = 1 / (nearCount + 1);
                        if (isolation > bestIsolation) {
                            bestIsolation = isolation;
                            bestIdx = i;
                        }
                    }
                    predator.targetIdx = bestIdx;
                }
                if (predator.targetIdx >= 0 && fish[predator.targetIdx]) {
                    const target = fish[predator.targetIdx];
                    const dx = target.x - predator.x;
                    const dy = target.y - predator.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        predator.vx += (dx / dist) * 0.3;
                        predator.vy += (dy / dist) * 0.3;
                    }
                }
            } else {
                // Follow mouse
                if (mouseX !== undefined) {
                    const dx = mouseX - predator.x;
                    const dy = mouseY - predator.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        predator.vx += (dx / dist) * 0.4;
                        predator.vy += (dy / dist) * 0.4;
                    }
                }
            }

            const pspd = Math.sqrt(predator.vx * predator.vx + predator.vy * predator.vy);
            if (pspd > p.predSpeed) {
                predator.vx = predator.vx / pspd * p.predSpeed;
                predator.vy = predator.vy / pspd * p.predSpeed;
            }
            predator.x += predator.vx;
            predator.y += predator.vy;

            // Wrap predator
            if (predator.x < -20) predator.x = W + 20;
            if (predator.x > W + 20) predator.x = -20;
            if (predator.y < -20) predator.y = H + 20;
            if (predator.y > H + 20) predator.y = -20;

            // Capture check
            if (predator.cooldown <= 0) {
                for (let i = 0; i < fish.length; i++) {
                    if (!fish[i].alive) continue;
                    const dx = fish[i].x - predator.x;
                    const dy = fish[i].y - predator.y;
                    if (dx * dx + dy * dy < 12 * 12) {
                        fish[i].alive = false;
                        captures++;
                        document.getElementById('captures').textContent = captures;
                        predator.cooldown = 30;
                        break;
                    }
                }
            }

            // School cohesion metric
            let cx = 0, cy = 0, ac = 0;
            for (let i = 0; i < fish.length; i++) {
                if (!fish[i].alive) continue;
                cx += fish[i].x; cy += fish[i].y; ac++;
            }
            if (ac > 0) {
                cx /= ac; cy /= ac;
                let avgDist = 0;
                for (let i = 0; i < fish.length; i++) {
                    if (!fish[i].alive) continue;
                    const dx = fish[i].x - cx;
                    const dy = fish[i].y - cy;
                    avgDist += Math.sqrt(dx * dx + dy * dy);
                }
                avgDist /= ac;
                const cohesion = Math.max(0, 100 - avgDist * 0.5);
                document.getElementById('cohesionMetric').textContent = cohesion.toFixed(0) + '%';
            }
        }

        function drawTriangle(x, y, vx, vy, size, color) {
            const angle = Math.atan2(vy, vx);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(size, 0);
            ctx.lineTo(-size * 0.6, -size * 0.4);
            ctx.lineTo(-size * 0.6, size * 0.4);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
        }

        function draw() {
            // Semi-transparent clear for trails
            ctx.fillStyle = 'rgba(10, 14, 26, 0.2)';
            ctx.fillRect(0, 0, W, H);

            // Draw subtle water effect
            const p = getParams();

            // Fish
            for (let i = 0; i < fish.length; i++) {
                const f = fish[i];
                if (!f.alive) continue;

                // Distance to predator for color intensity
                const pdx = f.x - predator.x;
                const pdy = f.y - predator.y;
                const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                const fear = Math.max(0, 1 - pdist / p.fleeRadius);

                // Blend from calm blue to panicked cyan
                const r = Math.floor(40 + fear * 100);
                const g = Math.floor(140 + fear * 80);
                const b = Math.floor(220 - fear * 40);
                const color = 'rgb(' + r + ',' + g + ',' + b + ')';

                drawTriangle(f.x, f.y, f.vx, f.vy, 5, color);
            }

            // Predator
            const predAngle = Math.atan2(predator.vy, predator.vx);
            ctx.save();
            ctx.translate(predator.x, predator.y);
            ctx.rotate(predAngle);

            // Danger glow
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 50, 50, 0.1)';
            ctx.fill();

            // Body
            ctx.beginPath();
            ctx.moveTo(18, 0);
            ctx.lineTo(-12, -10);
            ctx.lineTo(-6, 0);
            ctx.lineTo(-12, 10);
            ctx.closePath();
            ctx.fillStyle = '#ff3344';
            ctx.fill();
            ctx.strokeStyle = '#ff6677';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();

            // Flee radius indicator
            ctx.beginPath();
            ctx.arc(predator.x, predator.y, p.fleeRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.08)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function animate() {
            if (!paused) update();
            draw();
            animId = requestAnimationFrame(animate);
        }

        function reset() {
            cancelAnimationFrame(animId);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);
            initSim();
            animate();
        }
        window.reset = reset;

        // UI bindings
        document.getElementById('fishCount').oninput = function() {
            document.getElementById('fishCountVal').textContent = this.value;
        };
        document.getElementById('predSpeed').oninput = function() {
            document.getElementById('predSpeedVal').textContent = (this.value / 10).toFixed(1);
        };
        document.getElementById('fleeRadius').oninput = function() {
            document.getElementById('fleeRadVal').textContent = this.value;
        };
        document.getElementById('cohesion').oninput = function() {
            document.getElementById('cohesionVal').textContent = (this.value / 10).toFixed(1);
        };
        document.getElementById('alignment').oninput = function() {
            document.getElementById('alignVal').textContent = (this.value / 10).toFixed(1);
        };
        document.getElementById('separation').oninput = function() {
            document.getElementById('sepVal').textContent = (this.value / 10).toFixed(1);
        };
        document.getElementById('resetBtn').onclick = reset;
        document.getElementById('fishCount').onchange = reset;

        initSim();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
