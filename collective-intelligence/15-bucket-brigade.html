<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Organized Assembly Line - Collective Intelligence - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            color: #ccc;
        }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 15px; left: 15px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8);
            border-radius: 25px; border: 2px solid #8A9A5B;
            padding: 10px 20px; text-decoration: none; font-size: 14px;
            transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.2); transform: translateX(-4px); }
        #controls {
            position: fixed; top: 15px; right: 15px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            border: 1px solid rgba(138,154,91,0.3);
        }
        #controls h3 { color: #fff; margin-bottom: 12px; font-size: 15px; }
        .control-row { margin: 8px 0; }
        .control-row label { display: block; font-size: 11px; color: #8A9A5B; margin-bottom: 3px; }
        .control-row input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-row .val { float: right; color: #aaa; font-size: 11px; }
        .stat { margin: 4px 0; font-size: 12px; }
        .stat-label { color: #888; font-size: 11px; }
        .stat-value { color: #8A9A5B; font-weight: bold; }
        button {
            background: rgba(138,154,91,0.15); border: 1px solid rgba(138,154,91,0.4);
            color: #8A9A5B; padding: 6px 14px; border-radius: 6px; cursor: pointer;
            font-size: 12px; margin-top: 6px; transition: all 0.3s;
        }
        button:hover { background: rgba(138,154,91,0.3); }
        hr { border: none; border-top: 1px solid rgba(138,154,91,0.2); margin: 10px 0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Collective Intelligence</a>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Self-Organized Assembly Line</h3>
        <div class="control-row">
            <label>Item Arrival Rate <span class="val" id="arrivalVal">5</span></label>
            <input type="range" id="arrivalRate" min="1" max="15" value="5">
        </div>
        <div class="control-row">
            <label>Learning Rate <span class="val" id="learnVal">30</span></label>
            <input type="range" id="learnRate" min="5" max="80" value="30">
        </div>
        <div class="control-row">
            <label>Worker Count <span class="val" id="workerVal">20</span></label>
            <input type="range" id="workerCount" min="10" max="30" value="20">
        </div>
        <div class="control-row">
            <label>Worker Mobility <span class="val" id="mobilityVal">50</span></label>
            <input type="range" id="mobility" min="10" max="100" value="50">
        </div>
        <hr>
        <div class="stat"><span class="stat-label">Items Completed:</span> <span class="stat-value" id="completed">0</span></div>
        <div class="stat"><span class="stat-label">Throughput:</span> <span class="stat-value" id="throughput">0/s</span></div>
        <div class="stat"><span class="stat-label">Stage 1 Workers:</span> <span class="stat-value" id="s1Workers">-</span></div>
        <div class="stat"><span class="stat-label">Stage 2 Workers:</span> <span class="stat-value" id="s2Workers">-</span></div>
        <div class="stat"><span class="stat-label">Stage 3 Workers:</span> <span class="stat-value" id="s3Workers">-</span></div>
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
        resize();
        window.addEventListener('resize', resize);

        const STAGE_COLORS = ['#dc5050', '#DDA15E', '#4CAF50'];
        const STAGE_NAMES = ['CUT', 'ASSEMBLE', 'FINISH'];

        let workers = [], items = [], completedCount = 0;
        let completeTimes = [];
        let flowLines = []; // visual connections

        // Belt layout
        function getBelt() {
            const beltY = H * 0.22;
            const beltH = 40;
            const margin = 80;
            return { x: margin, y: beltY, w: W - margin * 2 - 300, h: beltH };
        }

        function init() {
            const n = parseInt(document.getElementById('workerCount').value);
            const belt = getBelt();
            workers = [];
            items = [];
            completedCount = 0;
            completeTimes = [];
            flowLines = [];

            for (let i = 0; i < n; i++) {
                // Random initial position along belt
                const x = belt.x + Math.random() * belt.w;
                workers.push({
                    x: x,
                    y: belt.y + belt.h + 50 + Math.random() * 120,
                    vx: 0,
                    // Specialization scores for each stage (start roughly equal)
                    skills: [1 + Math.random() * 0.5, 1 + Math.random() * 0.5, 1 + Math.random() * 0.5],
                    currentStage: Math.floor(Math.random() * 3), // which stage they prefer
                    busy: 0, // countdown while processing
                    processItem: null,
                    successCounts: [0, 0, 0]
                });
            }
        }

        let frameCount = 0;
        function update() {
            frameCount++;
            const arrivalRate = parseInt(document.getElementById('arrivalRate').value);
            const learnRate = parseInt(document.getElementById('learnRate').value) / 1000;
            const mobility = parseInt(document.getElementById('mobility').value) / 100;
            const belt = getBelt();

            // Spawn items
            if (frameCount % Math.max(2, 20 - arrivalRate * 2) === 0) {
                items.push({
                    x: belt.x - 10,
                    y: belt.y + belt.h / 2,
                    stage: 0, // 0=red, 1=yellow, 2=green (needs processing)
                    processed: false,
                    speed: 0.4 + Math.random() * 0.3,
                    assignedWorker: null,
                    done: false
                });
            }

            // Move items on belt
            items.forEach(item => {
                if (!item.assignedWorker && !item.done) {
                    item.x += item.speed;
                }
            });

            // Workers pick up items
            workers.forEach(worker => {
                if (worker.busy > 0) {
                    worker.busy--;
                    if (worker.busy === 0 && worker.processItem) {
                        // Done processing - advance item stage
                        const item = worker.processItem;
                        item.stage++;
                        item.assignedWorker = null;
                        item.processed = false;

                        // Learning: reinforce this stage skill
                        const stage = item.stage - 1;
                        worker.successCounts[stage]++;
                        worker.skills[stage] += learnRate * 5;
                        // Decay other skills slightly
                        for (let s = 0; s < 3; s++) {
                            if (s !== stage) worker.skills[s] *= (1 - learnRate * 0.5);
                        }
                        // Determine current specialization
                        worker.currentStage = worker.skills.indexOf(Math.max(...worker.skills));

                        if (item.stage >= 3) {
                            item.done = true;
                            completedCount++;
                            completeTimes.push(Date.now());
                        }
                        worker.processItem = null;
                    }
                    return;
                }

                // Look for items to process (nearby, matching current stage preference)
                let bestItem = null, bestDist = 120;
                items.forEach(item => {
                    if (item.done || item.assignedWorker || item.stage >= 3) return;
                    // Worker can process item if item.stage matches worker's best skill
                    if (item.stage !== worker.currentStage) return;
                    const dx = item.x - worker.x;
                    const dy = item.y - worker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestItem = item;
                    }
                });

                // If no matching item, try any stage (generalist behavior)
                if (!bestItem) {
                    items.forEach(item => {
                        if (item.done || item.assignedWorker || item.stage >= 3) return;
                        const dx = item.x - worker.x;
                        const dy = item.y - worker.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < bestDist * 0.6) {
                            bestDist = dist;
                            bestItem = item;
                        }
                    });
                }

                if (bestItem && bestDist < 60) {
                    bestItem.assignedWorker = worker;
                    worker.processItem = bestItem;
                    worker.busy = 30 + Math.floor(20 / (1 + worker.skills[bestItem.stage] * 0.2));

                    // Flow line
                    flowLines.push({
                        x1: worker.x, y1: worker.y,
                        x2: bestItem.x, y2: bestItem.y,
                        stage: bestItem.stage,
                        alpha: 0.6
                    });
                }
            });

            // Worker movement: drift toward region matching specialization
            workers.forEach(worker => {
                if (worker.busy > 0) return;
                // Target position: stage 0 = left, stage 1 = middle, stage 2 = right
                const targetX = belt.x + (worker.currentStage / 2) * belt.w;
                const dx = targetX - worker.x;
                worker.vx += dx * 0.001 * mobility;
                worker.vx *= 0.95;
                worker.x += worker.vx;
                // Some wander
                worker.x += (Math.random() - 0.5) * mobility * 0.3;
                worker.x = Math.max(belt.x - 20, Math.min(belt.x + belt.w + 20, worker.x));
                // Vertical jitter
                const targetY = belt.y + belt.h + 60 + (worker.currentStage % 2) * 30;
                worker.y += (targetY - worker.y) * 0.02;
                worker.y += (Math.random() - 0.5) * 1;
            });

            // Remove offscreen / completed items
            items = items.filter(item => {
                if (item.done) return item.x < belt.x + belt.w + 100;
                if (item.x > belt.x + belt.w + 50 && !item.assignedWorker) return false;
                return true;
            });

            // Decay flow lines
            flowLines.forEach(f => f.alpha -= 0.02);
            flowLines = flowLines.filter(f => f.alpha > 0);

            // Throughput
            const now = Date.now();
            completeTimes = completeTimes.filter(t => now - t < 5000);
            const throughput = completeTimes.length / 5;
            document.getElementById('completed').textContent = completedCount;
            document.getElementById('throughput').textContent = throughput.toFixed(1) + '/s';

            // Stage worker counts
            const stageCounts = [0, 0, 0];
            workers.forEach(w => stageCounts[w.currentStage]++);
            document.getElementById('s1Workers').textContent = stageCounts[0] + ' (CUT)';
            document.getElementById('s2Workers').textContent = stageCounts[1] + ' (ASSEMBLE)';
            document.getElementById('s3Workers').textContent = stageCounts[2] + ' (FINISH)';
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            const belt = getBelt();

            // Belt background
            ctx.fillStyle = 'rgba(40,45,60,0.8)';
            ctx.fillRect(belt.x - 5, belt.y, belt.w + 10, belt.h);
            ctx.strokeStyle = 'rgba(138,154,91,0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(belt.x - 5, belt.y, belt.w + 10, belt.h);

            // Belt arrows (conveyor direction)
            for (let ax = belt.x + 30; ax < belt.x + belt.w; ax += 60) {
                ctx.beginPath();
                ctx.moveTo(ax, belt.y + belt.h / 2);
                ctx.lineTo(ax - 8, belt.y + belt.h / 2 - 5);
                ctx.lineTo(ax - 8, belt.y + belt.h / 2 + 5);
                ctx.closePath();
                ctx.fillStyle = 'rgba(138,154,91,0.15)';
                ctx.fill();
            }

            // Stage zone labels
            const zoneW = belt.w / 3;
            for (let s = 0; s < 3; s++) {
                const zx = belt.x + s * zoneW;
                // Zone background hint
                ctx.fillStyle = STAGE_COLORS[s] + '08';
                ctx.fillRect(zx, belt.y - 25, zoneW, belt.h + 220);
                // Dotted separator
                if (s > 0) {
                    ctx.beginPath();
                    ctx.setLineDash([4, 4]);
                    ctx.moveTo(zx, belt.y - 25);
                    ctx.lineTo(zx, belt.y + belt.h + 195);
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                // Label
                ctx.fillStyle = STAGE_COLORS[s];
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Stage ' + (s + 1) + ': ' + STAGE_NAMES[s], zx + zoneW / 2, belt.y - 8);
            }

            // Belt labels
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('IN →', belt.x - 5, belt.y - 30);
            ctx.textAlign = 'right';
            ctx.fillText('→ OUT', belt.x + belt.w + 5, belt.y - 30);

            // Flow lines
            flowLines.forEach(f => {
                ctx.beginPath();
                ctx.moveTo(f.x1, f.y1);
                ctx.lineTo(f.x2, f.y2);
                ctx.strokeStyle = STAGE_COLORS[f.stage] + Math.floor(f.alpha * 80).toString(16).padStart(2, '0');
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Items on belt
            items.forEach(item => {
                if (item.stage >= 3) {
                    // Completed - bright green
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('OK', item.x, item.y);
                } else {
                    // Draw as colored square showing current stage
                    const size = 12;
                    ctx.fillStyle = STAGE_COLORS[item.stage];
                    ctx.fillRect(item.x - size / 2, item.y - size / 2, size, size);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(item.x - size / 2, item.y - size / 2, size, size);

                    // Progress dots
                    for (let s = 0; s < 3; s++) {
                        ctx.beginPath();
                        ctx.arc(item.x - 5 + s * 5, item.y + size / 2 + 5, 2, 0, Math.PI * 2);
                        ctx.fillStyle = s < item.stage ? STAGE_COLORS[s] : 'rgba(255,255,255,0.2)';
                        ctx.fill();
                    }

                    // Processing indicator
                    if (item.assignedWorker) {
                        ctx.beginPath();
                        ctx.arc(item.x, item.y, size / 2 + 4, 0, Math.PI * 2);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([3, 3]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            });

            // Workers
            workers.forEach(worker => {
                // Determine dominant color
                const maxSkill = Math.max(...worker.skills);
                const totalSkill = worker.skills.reduce((a, b) => a + b, 0);
                const r = Math.floor(
                    (worker.skills[0] / totalSkill) * parseInt(STAGE_COLORS[0].slice(1, 3), 16) +
                    (worker.skills[1] / totalSkill) * parseInt(STAGE_COLORS[1].slice(1, 3), 16) +
                    (worker.skills[2] / totalSkill) * parseInt(STAGE_COLORS[2].slice(1, 3), 16)
                );
                const g = Math.floor(
                    (worker.skills[0] / totalSkill) * parseInt(STAGE_COLORS[0].slice(3, 5), 16) +
                    (worker.skills[1] / totalSkill) * parseInt(STAGE_COLORS[1].slice(3, 5), 16) +
                    (worker.skills[2] / totalSkill) * parseInt(STAGE_COLORS[2].slice(3, 5), 16)
                );
                const b2 = Math.floor(
                    (worker.skills[0] / totalSkill) * parseInt(STAGE_COLORS[0].slice(5, 7), 16) +
                    (worker.skills[1] / totalSkill) * parseInt(STAGE_COLORS[1].slice(5, 7), 16) +
                    (worker.skills[2] / totalSkill) * parseInt(STAGE_COLORS[2].slice(5, 7), 16)
                );
                const color = `rgb(${r},${g},${b2})`;

                const radius = 10;

                // Glow if busy
                if (worker.busy > 0) {
                    const glow = ctx.createRadialGradient(worker.x, worker.y, 0, worker.x, worker.y, radius + 10);
                    glow.addColorStop(0, color + '40');
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(worker.x, worker.y, radius + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Worker circle
                ctx.beginPath();
                ctx.arc(worker.x, worker.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = worker.busy > 0 ? color : color + 'aa';
                ctx.fill();
                ctx.strokeStyle = STAGE_COLORS[worker.currentStage];
                ctx.lineWidth = 2;
                ctx.stroke();

                // Skill bar (tiny stacked bar below worker)
                const barW = 20, barH = 3;
                const bx = worker.x - barW / 2;
                const by = worker.y + radius + 4;
                for (let s = 0; s < 3; s++) {
                    const frac = worker.skills[s] / totalSkill;
                    ctx.fillStyle = STAGE_COLORS[s];
                    const sx = bx + (s === 0 ? 0 : (worker.skills.slice(0, s).reduce((a, b) => a + b, 0) / totalSkill) * barW);
                    ctx.fillRect(sx, by, frac * barW, barH);
                }

                // Connection to item being processed
                if (worker.processItem) {
                    ctx.beginPath();
                    ctx.moveTo(worker.x, worker.y - radius);
                    ctx.lineTo(worker.processItem.x, worker.processItem.y);
                    ctx.strokeStyle = STAGE_COLORS[worker.processItem.stage] + '60';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Legend
            const lx = 20, ly = H - 80;
            ctx.fillStyle = 'rgba(10,14,26,0.85)';
            ctx.fillRect(lx, ly, 250, 60);
            ctx.strokeStyle = 'rgba(138,154,91,0.2)';
            ctx.strokeRect(lx, ly, 250, 60);
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#888';
            ctx.fillText('Workers self-organize by specializing:', lx + 10, ly + 16);
            for (let s = 0; s < 3; s++) {
                ctx.fillStyle = STAGE_COLORS[s];
                ctx.fillRect(lx + 10 + s * 80, ly + 26, 12, 12);
                ctx.fillStyle = '#aaa';
                ctx.fillText(STAGE_NAMES[s], lx + 26 + s * 80, ly + 36);
            }
            ctx.fillStyle = '#666';
            ctx.fillText('Workers drift toward their specialized zone', lx + 10, ly + 52);
        }

        let paused = false;
        function animate() {
            if (!paused) update();
            draw();
            requestAnimationFrame(animate);
        }

        function reset() { init(); }
        window.reset = reset;

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Slider labels
        document.getElementById('arrivalRate').oninput = function() {
            document.getElementById('arrivalVal').textContent = this.value;
        };
        document.getElementById('learnRate').oninput = function() {
            document.getElementById('learnVal').textContent = this.value;
        };
        document.getElementById('workerCount').oninput = function() {
            document.getElementById('workerVal').textContent = this.value;
        };
        document.getElementById('mobility').oninput = function() {
            document.getElementById('mobilityVal').textContent = this.value;
        };
        document.getElementById('workerCount').addEventListener('change', reset);

        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
