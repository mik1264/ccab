<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Termite Mound Construction</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8); border-radius: 25px;
            border: 2px solid #8A9A5B; padding: 10px 20px; text-decoration: none;
            font-size: 14px; transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            color: #c0c8e0; font-size: 13px;
        }
        .controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 4px; color: #9aa0b8; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group .value { float: right; color: #8A9A5B; font-weight: bold; }
        .metric { margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1); border-radius: 6px; }
        .metric .label { color: #9aa0b8; font-size: 11px; }
        .metric .val { color: #DDA15E; font-size: 16px; font-weight: bold; }
        .btn { background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid #8A9A5B;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 8px; }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .legend { margin-top: 10px; font-size: 11px; }
        .legend-item { display: flex; align-items: center; gap: 6px; margin: 3px 0; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Collective Intelligence</a>
    <div class="controls">
        <h3>Termite Construction</h3>
        <div class="control-group">
            <label>Termites <span class="value" id="termiteVal">500</span></label>
            <input type="range" id="termiteCount" min="100" max="1000" value="500" step="50">
        </div>
        <div class="control-group">
            <label>Dirt Density <span class="value" id="densityVal">15%</span></label>
            <input type="range" id="dirtDensity" min="5" max="30" value="15" step="1">
        </div>
        <div class="control-group">
            <label>Sensing Radius <span class="value" id="senseVal">3</span></label>
            <input type="range" id="senseRadius" min="1" max="6" value="3" step="1">
        </div>
        <div class="control-group">
            <label>Speed <span class="value" id="speedVal">1x</span></label>
            <input type="range" id="simSpeed" min="1" max="5" value="1" step="1">
        </div>
        <button class="btn" id="resetBtn">Reset</button>
        <div class="metric">
            <div class="label">Clusters Formed</div>
            <div class="val" id="clusterCount">0</div>
        </div>
        <div class="metric">
            <div class="label">Steps Elapsed</div>
            <div class="val" id="stepCount">0</div>
        </div>
        <div class="legend">
            <div class="legend-item"><div class="legend-dot" style="background:#e0e0e0"></div> Termite (empty)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#e8c840"></div> Termite (carrying)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#8B6914"></div> Dirt particle</div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();

        const CELL = 4;
        let cols, rows, dirt;
        let termites = [];
        let steps = 0;
        let paused = false;

        function initGrid() {
            cols = Math.floor(W / CELL);
            rows = Math.floor(H / CELL);
            dirt = new Uint8Array(cols * rows);
        }

        function placeDirt() {
            const density = parseInt(document.getElementById('dirtDensity').value) / 100;
            dirt.fill(0);
            for (let i = 0; i < dirt.length; i++) {
                if (Math.random() < density) {
                    dirt[i] = 1;
                }
            }
        }

        class Termite {
            constructor() {
                this.x = Math.floor(Math.random() * cols);
                this.y = Math.floor(Math.random() * rows);
                this.carrying = false;
                this.angle = Math.random() * Math.PI * 2;
            }
        }

        function initTermites() {
            const count = parseInt(document.getElementById('termiteCount').value);
            termites = [];
            for (let i = 0; i < count; i++) {
                termites.push(new Termite());
            }
            steps = 0;
        }

        function hasDirtNearby(x, y, radius) {
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    if (dirt[ny * cols + nx]) count++;
                }
            }
            return count;
        }

        function updateTermite(t) {
            const senseR = parseInt(document.getElementById('senseRadius').value);

            // Random walk with slight persistence
            t.angle += (Math.random() - 0.5) * 1.2;
            const dx = Math.round(Math.cos(t.angle));
            const dy = Math.round(Math.sin(t.angle));
            t.x = (t.x + dx + cols) % cols;
            t.y = (t.y + dy + rows) % rows;

            const idx = t.y * cols + t.x;

            if (!t.carrying) {
                // Not carrying: if on dirt and dirt has neighbors, pick it up
                if (dirt[idx]) {
                    dirt[idx] = 0;
                    t.carrying = true;
                }
            } else {
                // Carrying: if near other dirt (but not on it), drop it
                if (!dirt[idx]) {
                    const nearby = hasDirtNearby(t.x, t.y, senseR);
                    if (nearby >= 1) {
                        dirt[idx] = 1;
                        t.carrying = false;
                        // Turn around after dropping
                        t.angle += Math.PI + (Math.random() - 0.5) * 0.5;
                    }
                }
            }
        }

        function countClusters() {
            // Simple: count connected components of dirt
            const visited = new Uint8Array(cols * rows);
            let clusters = 0;
            const minSize = 5; // Only count clusters with >= 5 particles

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const idx = y * cols + x;
                    if (!dirt[idx] || visited[idx]) continue;

                    // BFS flood fill
                    let size = 0;
                    const queue = [[x, y]];
                    visited[idx] = 1;
                    let head = 0;

                    while (head < queue.length) {
                        const [cx, cy] = queue[head++];
                        size++;
                        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                        for (const [ddx, ddy] of dirs) {
                            const nx = (cx + ddx + cols) % cols;
                            const ny = (cy + ddy + rows) % rows;
                            const ni = ny * cols + nx;
                            if (dirt[ni] && !visited[ni]) {
                                visited[ni] = 1;
                                queue.push([nx, ny]);
                            }
                        }
                    }

                    if (size >= minSize) clusters++;
                }
            }
            return clusters;
        }

        // Render using ImageData for performance
        let imgData;

        function draw() {
            if (!imgData || imgData.width !== W || imgData.height !== H) {
                imgData = ctx.createImageData(W, H);
            }
            const data = imgData.data;

            // Background
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 10; data[i + 1] = 14; data[i + 2] = 26; data[i + 3] = 255;
            }

            // Dirt
            for (let gy = 0; gy < rows; gy++) {
                for (let gx = 0; gx < cols; gx++) {
                    if (!dirt[gy * cols + gx]) continue;
                    const px0 = gx * CELL;
                    const py0 = gy * CELL;
                    for (let py = py0; py < py0 + CELL && py < H; py++) {
                        for (let px = px0; px < px0 + CELL && px < W; px++) {
                            const idx = (py * W + px) * 4;
                            data[idx] = 139;     // brown
                            data[idx + 1] = 105;
                            data[idx + 2] = 20;
                        }
                    }
                }
            }

            // Termites
            for (let i = 0; i < termites.length; i++) {
                const t = termites[i];
                const px0 = t.x * CELL;
                const py0 = t.y * CELL;
                const r = t.carrying ? 232 : 224;
                const g = t.carrying ? 200 : 224;
                const b = t.carrying ? 64 : 224;
                for (let py = py0; py < py0 + CELL && py < H; py++) {
                    for (let px = px0; px < px0 + CELL && px < W; px++) {
                        const idx = (py * W + px) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                    }
                }
            }

            ctx.putImageData(imgData, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (paused) return;

            const speed = parseInt(document.getElementById('simSpeed').value);

            // Adjust termite count
            const target = parseInt(document.getElementById('termiteCount').value);
            while (termites.length < target) termites.push(new Termite());
            while (termites.length > target) termites.pop();

            for (let s = 0; s < speed; s++) {
                for (let i = 0; i < termites.length; i++) {
                    updateTermite(termites[i]);
                }
                steps++;
            }

            draw();

            // Update metrics every 30 frames
            if (steps % 30 === 0) {
                document.getElementById('clusterCount').textContent = countClusters();
            }
            document.getElementById('stepCount').textContent = steps;
        }

        function fullReset() {
            initGrid();
            placeDirt();
            initTermites();
        }

        fullReset();
        animate();

        // Controls
        document.getElementById('termiteCount').oninput = function() {
            document.getElementById('termiteVal').textContent = this.value;
        };
        document.getElementById('dirtDensity').oninput = function() {
            document.getElementById('densityVal').textContent = this.value + '%';
        };
        document.getElementById('senseRadius').oninput = function() {
            document.getElementById('senseVal').textContent = this.value;
        };
        document.getElementById('simSpeed').oninput = function() {
            document.getElementById('speedVal').textContent = this.value + 'x';
        };

        document.getElementById('resetBtn').onclick = fullReset;
        window.reset = fullReset;

        window.addEventListener('resize', function() {
            resize();
            fullReset();
        });

        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && e.target === document.body) {
                paused = !paused;
            }
        });
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
