<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chemotaxis Maze Solving</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8); border-radius: 25px;
            border: 2px solid #8A9A5B; padding: 10px 20px; text-decoration: none;
            font-size: 14px; transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            color: #c0c8e0; font-size: 13px;
        }
        .controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 4px; color: #9aa0b8; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group .value { float: right; color: #8A9A5B; font-weight: bold; }
        .btn { background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid #8A9A5B;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; margin-right: 4px; margin-top: 4px; }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn.active { background: rgba(138,154,91,0.5); }
        .metric { margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1); border-radius: 6px; }
        .metric .label { color: #9aa0b8; font-size: 11px; }
        .metric .val { color: #DDA15E; font-size: 16px; font-weight: bold; }
        .btn-row { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Collective Intelligence</a>
    <div class="controls">
        <h3>Chemotaxis Maze Solving</h3>
        <div class="control-group">
            <label>Bacteria Count <span class="value" id="bCountVal">150</span></label>
            <input type="range" id="bCount" min="20" max="400" value="150" step="10">
        </div>
        <div class="control-group">
            <label>Gradient Sensitivity <span class="value" id="sensVal">0.8</span></label>
            <input type="range" id="sensitivity" min="0.1" max="2.0" value="0.8" step="0.1">
        </div>
        <div class="control-group">
            <label>Tumble Frequency <span class="value" id="tumbleVal">0.10</span></label>
            <input type="range" id="tumbleFreq" min="0.02" max="0.30" value="0.10" step="0.01">
        </div>
        <div>
            <label style="color:#9aa0b8; margin-bottom:6px; display:block;">Maze Preset</label>
            <div class="btn-row">
                <button class="btn active" data-maze="simple">Simple</button>
                <button class="btn" data-maze="medium">Medium</button>
                <button class="btn" data-maze="complex">Complex</button>
            </div>
        </div>
        <button class="btn" id="resetBtn" style="margin-top:10px;">Reset</button>
        <div class="metric">
            <div class="label">Bacteria at Food</div>
            <div class="val" id="arrivedCount">0</div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();

        const CELL = 10;
        let cols, rows, walls, gradient;
        let bacteria = [];
        let entrance, exit;
        let currentMaze = 'simple';
        let paused = false;

        function initGrid() {
            cols = Math.floor(W / CELL);
            rows = Math.floor(H / CELL);
            walls = new Uint8Array(cols * rows);
            gradient = new Float32Array(cols * rows);
        }

        // Maze generation using recursive backtracker on a grid
        function generateMaze(complexity) {
            walls.fill(1); // all walls

            // Maze cell size (bigger = simpler maze)
            let cellSize;
            if (complexity === 'simple') cellSize = 6;
            else if (complexity === 'medium') cellSize = 4;
            else cellSize = 3;

            const mcols = Math.floor((cols - 2) / cellSize);
            const mrows = Math.floor((rows - 2) / cellSize);

            // Carve out cells and passages
            const visited = new Uint8Array(mcols * mrows);
            const stack = [];

            function carveCell(mx, my) {
                const gx = 1 + mx * cellSize;
                const gy = 1 + my * cellSize;
                for (let dy = 0; dy < cellSize - 1 && gy + dy < rows - 1; dy++) {
                    for (let dx = 0; dx < cellSize - 1 && gx + dx < cols - 1; dx++) {
                        walls[(gy + dy) * cols + (gx + dx)] = 0;
                    }
                }
            }

            function carvePassage(mx1, my1, mx2, my2) {
                const gx1 = 1 + mx1 * cellSize;
                const gy1 = 1 + my1 * cellSize;
                const gx2 = 1 + mx2 * cellSize;
                const gy2 = 1 + my2 * cellSize;
                const minGx = Math.min(gx1, gx2);
                const minGy = Math.min(gy1, gy2);
                const maxGx = Math.max(gx1, gx2) + cellSize - 2;
                const maxGy = Math.max(gy1, gy2) + cellSize - 2;
                for (let y = minGy; y <= maxGy && y < rows - 1; y++) {
                    for (let x = minGx; x <= maxGx && x < cols - 1; x++) {
                        walls[y * cols + x] = 0;
                    }
                }
            }

            // Start from top-left
            let cx = 0, cy = 0;
            visited[0] = 1;
            carveCell(0, 0);
            stack.push([0, 0]);

            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];

            while (stack.length > 0) {
                const [mx, my] = stack[stack.length - 1];
                // Shuffle neighbors
                const shuffled = dirs.slice().sort(() => Math.random() - 0.5);
                let found = false;
                for (const [dx, dy] of shuffled) {
                    const nx = mx + dx, ny = my + dy;
                    if (nx >= 0 && nx < mcols && ny >= 0 && ny < mrows && !visited[ny * mcols + nx]) {
                        visited[ny * mcols + nx] = 1;
                        carveCell(nx, ny);
                        carvePassage(mx, my, nx, ny);
                        stack.push([nx, ny]);
                        found = true;
                        break;
                    }
                }
                if (!found) stack.pop();
            }

            // Set entrance (left side) and exit (right side)
            const entryMy = Math.floor(mrows / 2);
            const exitMy = Math.floor(mrows / 2);
            entrance = { gx: 1, gy: 1 + entryMy * cellSize + Math.floor(cellSize / 2) - 1 };
            exit = { gx: cols - 2, gy: 1 + exitMy * cellSize + Math.floor(cellSize / 2) - 1 };

            // Clear entrance and exit areas
            for (let dy = -1; dy <= 1; dy++) {
                const ey = entrance.gy + dy;
                if (ey >= 0 && ey < rows) {
                    walls[ey * cols + 0] = 0;
                    walls[ey * cols + 1] = 0;
                }
                const xy = exit.gy + dy;
                if (xy >= 0 && xy < rows) {
                    walls[xy * cols + (cols - 1)] = 0;
                    walls[xy * cols + (cols - 2)] = 0;
                }
            }
        }

        // Diffuse gradient from food source through corridors
        function computeGradient() {
            gradient.fill(0);
            // BFS from exit
            const queue = [];
            const dist = new Float32Array(cols * rows);
            dist.fill(Infinity);

            const ex = exit.gx, ey = exit.gy;
            dist[ey * cols + ex] = 0;
            gradient[ey * cols + ex] = 1;
            queue.push([ex, ey]);

            let head = 0;
            while (head < queue.length) {
                const [cx, cy] = queue[head++];
                const d = dist[cy * cols + cx];
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const [dx, dy] of dirs) {
                    const nx = cx + dx, ny = cy + dy;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !walls[ny * cols + nx]) {
                        const nd = d + 1;
                        if (nd < dist[ny * cols + nx]) {
                            dist[ny * cols + nx] = nd;
                            queue.push([nx, ny]);
                        }
                    }
                }
            }

            // Convert distance to gradient (closer = higher)
            let maxDist = 0;
            for (let i = 0; i < dist.length; i++) {
                if (dist[i] < Infinity && dist[i] > maxDist) maxDist = dist[i];
            }
            if (maxDist > 0) {
                for (let i = 0; i < dist.length; i++) {
                    if (dist[i] < Infinity) {
                        gradient[i] = 1 - dist[i] / maxDist;
                    }
                }
            }
        }

        // Bacteria
        class Bacterium {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = entrance.gx * CELL + CELL / 2 + (Math.random() - 0.5) * CELL * 2;
                this.y = entrance.gy * CELL + CELL / 2 + (Math.random() - 0.5) * CELL * 3;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 1.2 + Math.random() * 0.6;
                this.runTimer = 0;
                this.arrived = false;
                this.prevGrad = 0;
            }
        }

        function initBacteria() {
            const count = parseInt(document.getElementById('bCount').value);
            bacteria = [];
            for (let i = 0; i < count; i++) {
                bacteria.push(new Bacterium());
            }
        }

        function isWall(px, py) {
            const gx = Math.floor(px / CELL);
            const gy = Math.floor(py / CELL);
            if (gx < 0 || gx >= cols || gy < 0 || gy >= rows) return true;
            return walls[gy * cols + gx] === 1;
        }

        function getGradient(px, py) {
            const gx = Math.floor(px / CELL);
            const gy = Math.floor(py / CELL);
            if (gx < 0 || gx >= cols || gy < 0 || gy >= rows) return 0;
            return gradient[gy * cols + gx];
        }

        function updateBacterium(b) {
            if (b.arrived) return;

            const sensitivity = parseFloat(document.getElementById('sensitivity').value);
            const tumbleBase = parseFloat(document.getElementById('tumbleFreq').value);

            // Check if arrived at food
            const dx = b.x - exit.gx * CELL;
            const dy = b.y - exit.gy * CELL;
            if (Math.hypot(dx, dy) < CELL * 2) {
                b.arrived = true;
                return;
            }

            // Sense current gradient
            const currentGrad = getGradient(b.x, b.y);
            const gradDiff = currentGrad - b.prevGrad;

            // Run-and-tumble: if gradient is increasing, less likely to tumble
            let tumbleProb = tumbleBase;
            if (gradDiff > 0) {
                tumbleProb *= Math.max(0.05, 1 - sensitivity * gradDiff * 20);
            } else {
                tumbleProb *= 1.2;
            }

            if (Math.random() < tumbleProb) {
                // Tumble: random new direction
                b.angle = Math.random() * Math.PI * 2;
            }

            b.prevGrad = currentGrad;

            // Move
            const nx = b.x + Math.cos(b.angle) * b.speed;
            const ny = b.y + Math.sin(b.angle) * b.speed;

            if (!isWall(nx, ny)) {
                b.x = nx;
                b.y = ny;
            } else {
                // Hit wall - tumble
                b.angle = Math.random() * Math.PI * 2;
                // Try to slide along wall
                const nx2 = b.x + Math.cos(b.angle) * b.speed;
                const ny2 = b.y + Math.sin(b.angle) * b.speed;
                if (!isWall(nx2, ny2)) {
                    b.x = nx2;
                    b.y = ny2;
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Draw gradient overlay
            for (let gy = 0; gy < rows; gy++) {
                for (let gx = 0; gx < cols; gx++) {
                    const idx = gy * cols + gx;
                    if (walls[idx]) continue;
                    const g = gradient[idx];
                    if (g > 0.01) {
                        const alpha = g * 0.3;
                        const r = Math.floor(20 + g * 80);
                        const gr = Math.floor(40 + g * 160);
                        const b = Math.floor(80 + g * 100);
                        ctx.fillStyle = `rgba(${r},${gr},${b},${alpha})`;
                        ctx.fillRect(gx * CELL, gy * CELL, CELL, CELL);
                    }
                }
            }

            // Draw walls
            ctx.fillStyle = '#151a30';
            for (let gy = 0; gy < rows; gy++) {
                for (let gx = 0; gx < cols; gx++) {
                    if (walls[gy * cols + gx]) {
                        ctx.fillRect(gx * CELL, gy * CELL, CELL, CELL);
                    }
                }
            }

            // Wall edges for depth
            ctx.strokeStyle = '#1f2648';
            ctx.lineWidth = 0.5;
            for (let gy = 0; gy < rows; gy++) {
                for (let gx = 0; gx < cols; gx++) {
                    if (!walls[gy * cols + gx]) continue;
                    // Only stroke edges adjacent to open space
                    if (gx > 0 && !walls[gy * cols + gx - 1]) {
                        ctx.beginPath(); ctx.moveTo(gx * CELL, gy * CELL); ctx.lineTo(gx * CELL, (gy + 1) * CELL); ctx.stroke();
                    }
                    if (gx < cols - 1 && !walls[gy * cols + gx + 1]) {
                        ctx.beginPath(); ctx.moveTo((gx + 1) * CELL, gy * CELL); ctx.lineTo((gx + 1) * CELL, (gy + 1) * CELL); ctx.stroke();
                    }
                    if (gy > 0 && !walls[(gy - 1) * cols + gx]) {
                        ctx.beginPath(); ctx.moveTo(gx * CELL, gy * CELL); ctx.lineTo((gx + 1) * CELL, gy * CELL); ctx.stroke();
                    }
                    if (gy < rows - 1 && !walls[(gy + 1) * cols + gx]) {
                        ctx.beginPath(); ctx.moveTo(gx * CELL, (gy + 1) * CELL); ctx.lineTo((gx + 1) * CELL, (gy + 1) * CELL); ctx.stroke();
                    }
                }
            }

            // Entrance marker
            ctx.save();
            ctx.shadowColor = '#4a8a3a';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#4a8a3a';
            ctx.beginPath();
            ctx.arc(entrance.gx * CELL + CELL / 2, entrance.gy * CELL + CELL / 2, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.fillStyle = '#fff';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('START', entrance.gx * CELL + CELL / 2, entrance.gy * CELL + CELL / 2 + 3);

            // Food marker at exit
            ctx.save();
            ctx.shadowColor = '#DDA15E';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#DDA15E';
            ctx.beginPath();
            ctx.arc(exit.gx * CELL + CELL / 2, exit.gy * CELL + CELL / 2, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.fillStyle = '#fff';
            ctx.fillText('FOOD', exit.gx * CELL + CELL / 2, exit.gy * CELL + CELL / 2 + 3);

            // Bacteria
            let arrivedCount = 0;
            for (let i = 0; i < bacteria.length; i++) {
                const b = bacteria[i];
                if (b.arrived) {
                    arrivedCount++;
                    continue;
                }
                ctx.beginPath();
                ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
                ctx.fillStyle = '#80e0ff';
                ctx.fill();
            }

            // Arrived bacteria cluster around food
            if (arrivedCount > 0) {
                ctx.save();
                ctx.shadowColor = '#80e0ff';
                ctx.shadowBlur = 8;
                for (let i = 0; i < Math.min(arrivedCount, 60); i++) {
                    const angle = (i / Math.min(arrivedCount, 60)) * Math.PI * 2 + Math.sin(Date.now() * 0.001 + i) * 0.2;
                    const r = 14 + (i % 3) * 5;
                    ctx.beginPath();
                    ctx.arc(exit.gx * CELL + CELL / 2 + Math.cos(angle) * r,
                            exit.gy * CELL + CELL / 2 + Math.sin(angle) * r, 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#80e0ff';
                    ctx.fill();
                }
                ctx.restore();
            }

            document.getElementById('arrivedCount').textContent = arrivedCount + ' / ' + bacteria.length;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (paused) return;

            // Adjust bacteria count
            const target = parseInt(document.getElementById('bCount').value);
            while (bacteria.length < target) bacteria.push(new Bacterium());
            while (bacteria.length > target) bacteria.pop();

            for (let step = 0; step < 3; step++) {
                for (let i = 0; i < bacteria.length; i++) {
                    updateBacterium(bacteria[i]);
                }
            }
            draw();
        }

        function fullReset() {
            initGrid();
            generateMaze(currentMaze);
            computeGradient();
            initBacteria();
        }

        fullReset();
        animate();

        // Controls
        document.getElementById('bCount').oninput = function() {
            document.getElementById('bCountVal').textContent = this.value;
        };
        document.getElementById('sensitivity').oninput = function() {
            document.getElementById('sensVal').textContent = parseFloat(this.value).toFixed(1);
        };
        document.getElementById('tumbleFreq').oninput = function() {
            document.getElementById('tumbleVal').textContent = parseFloat(this.value).toFixed(2);
        };

        document.querySelectorAll('[data-maze]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-maze]').forEach(function(b) { b.classList.remove('active'); });
                this.classList.add('active');
                currentMaze = this.dataset.maze;
                fullReset();
            });
        });

        document.getElementById('resetBtn').onclick = fullReset;
        window.reset = fullReset;

        window.addEventListener('resize', function() {
            resize();
            fullReset();
        });

        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && e.target === document.body) {
                paused = !paused;
            }
        });
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
