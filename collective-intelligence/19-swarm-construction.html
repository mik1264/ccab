<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stigmergic Swarm Construction</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8); border-radius: 25px;
            border: 2px solid #8A9A5B; padding: 10px 20px; text-decoration: none;
            font-size: 14px; transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            color: #c0c8e0; font-size: 13px;
        }
        .controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 4px; color: #9aa0b8; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group .value { float: right; color: #8A9A5B; font-weight: bold; }
        .control-group select { width: 100%; background: rgba(10,14,26,0.8); color: #c0c8e0;
            border: 1px solid #8A9A5B; padding: 4px; border-radius: 4px; }
        .metric { margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1); border-radius: 6px; }
        .metric .label { color: #9aa0b8; font-size: 11px; }
        .metric .val { color: #DDA15E; font-size: 18px; font-weight: bold; }
        .btn { background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid #8A9A5B;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 8px; }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .hint { color: #666; font-size: 11px; margin-top: 8px; font-style: italic; }
        .legend { margin-top: 10px; font-size: 11px; }
        .legend-item { display: flex; align-items: center; margin: 3px 0; }
        .legend-swatch { width: 12px; height: 12px; border-radius: 2px; margin-right: 6px; display: inline-block; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Collective Intelligence</a>
    <div class="controls">
        <h3>Stigmergic Building</h3>
        <div class="control-group">
            <label>Robots <span class="value" id="robotVal">60</span></label>
            <input type="range" id="robotSlider" min="10" max="150" value="60" step="5">
        </div>
        <div class="control-group">
            <label>Structure</label>
            <select id="structSelect">
                <option value="wall">Wall</option>
                <option value="arch">Arch</option>
                <option value="enclosure">Enclosure</option>
            </select>
        </div>
        <div class="control-group">
            <label>Build Speed <span class="value" id="speedVal">1.0</span>x</label>
            <input type="range" id="speedSlider" min="0.5" max="5.0" value="1.0" step="0.5">
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="showRules"> Show Placement Rules</label>
        </div>
        <button class="btn" id="resetBtn">Reset</button>
        <div class="metric">
            <div class="label">Blocks Placed</div>
            <div class="val" id="blocksVal">0</div>
        </div>
        <div class="metric">
            <div class="label">Completion</div>
            <div class="val" id="completionVal">0%</div>
        </div>
        <div class="legend">
            <div class="legend-item"><span class="legend-swatch" style="background:#8B6914"></span> Foundation</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#7a7a8a"></span> Wall</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#c8a82e"></span> Cap</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#e05050"></span> Robot (carrying)</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#50a0e0"></span> Robot (empty)</div>
        </div>
        <p class="hint">Robots build using local rules only - no blueprint</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        const robotSlider = document.getElementById('robotSlider');
        const structSelect = document.getElementById('structSelect');
        const speedSlider = document.getElementById('speedSlider');
        const showRulesCheck = document.getElementById('showRules');

        let robotCount = +robotSlider.value;
        let structType = structSelect.value;
        let buildSpeed = +speedSlider.value;
        let showRules = showRulesCheck.checked;

        robotSlider.oninput = function() { document.getElementById('robotVal').textContent = this.value; robotCount = +this.value; init(); };
        structSelect.onchange = function() { structType = this.value; init(); };
        speedSlider.oninput = function() { document.getElementById('speedVal').textContent = this.value; buildSpeed = +this.value; };
        showRulesCheck.onchange = function() { showRules = this.checked; };

        // Grid
        const CELL = 12;
        let gridCols, gridRows;
        let grid; // 0=empty, 1=foundation, 2=wall, 3=cap
        let targetCells; // set of cells that should eventually be filled
        let groundRow; // the ground level row
        let robots = [];
        let blockSupply; // coordinates where robots pick up blocks

        function getCell(gx, gy) {
            if (gx < 0 || gx >= gridCols || gy < 0 || gy >= gridRows) return -1;
            return grid[gy * gridCols + gx];
        }

        function setCell(gx, gy, val) {
            if (gx >= 0 && gx < gridCols && gy >= 0 && gy < gridRows) {
                grid[gy * gridCols + gx] = val;
            }
        }

        function generateTarget() {
            targetCells = new Set();
            const midX = Math.floor(gridCols / 2);
            groundRow = gridRows - 4;

            if (structType === 'wall') {
                const wallWidth = 20;
                const wallHeight = 12;
                const startX = midX - Math.floor(wallWidth / 2);
                // Foundation
                for (let x = startX; x < startX + wallWidth; x++) {
                    targetCells.add(groundRow + ',' + x);
                }
                // Wall
                for (let y = groundRow - wallHeight; y < groundRow; y++) {
                    for (let x = startX; x < startX + wallWidth; x++) {
                        targetCells.add(y + ',' + x);
                    }
                }
                // Cap
                for (let x = startX - 1; x <= startX + wallWidth; x++) {
                    targetCells.add((groundRow - wallHeight - 1) + ',' + x);
                }
            } else if (structType === 'arch') {
                const archWidth = 24;
                const archHeight = 14;
                const startX = midX - Math.floor(archWidth / 2);
                // Two pillars
                const pillarWidth = 4;
                for (let y = groundRow - archHeight; y <= groundRow; y++) {
                    for (let x = startX; x < startX + pillarWidth; x++) {
                        targetCells.add(y + ',' + x);
                    }
                    for (let x = startX + archWidth - pillarWidth; x < startX + archWidth; x++) {
                        targetCells.add(y + ',' + x);
                    }
                }
                // Arch top (semicircle)
                const arcCx = startX + archWidth / 2;
                const arcCy = groundRow - archHeight;
                const arcR = archWidth / 2;
                for (let x = startX; x < startX + archWidth; x++) {
                    const dx = x - arcCx;
                    const maxY = arcCy - Math.sqrt(Math.max(0, arcR * arcR - dx * dx)) * 0.5;
                    for (let y = Math.floor(maxY); y <= arcCy; y++) {
                        if (y >= 0) targetCells.add(y + ',' + x);
                    }
                }
            } else if (structType === 'enclosure') {
                const eWidth = 22;
                const eHeight = 10;
                const startX = midX - Math.floor(eWidth / 2);
                const wallThick = 3;
                const doorWidth = 4;
                const doorStart = midX - Math.floor(doorWidth / 2);

                for (let y = groundRow - eHeight; y <= groundRow; y++) {
                    for (let x = startX; x < startX + eWidth; x++) {
                        // Is this part of the wall?
                        const isLeftWall = x >= startX && x < startX + wallThick;
                        const isRightWall = x >= startX + eWidth - wallThick && x < startX + eWidth;
                        const isBottom = y >= groundRow - wallThick && y <= groundRow;
                        const isTop = y >= groundRow - eHeight && y < groundRow - eHeight + wallThick;

                        // Door gap in bottom wall
                        const isDoor = isBottom && x >= doorStart && x < doorStart + doorWidth && y > groundRow - wallThick + 1;

                        if ((isLeftWall || isRightWall || isBottom || isTop) && !isDoor) {
                            targetCells.add(y + ',' + x);
                        }
                    }
                }
            }
        }

        function init() {
            gridCols = Math.floor(W / CELL);
            gridRows = Math.floor(H / CELL);
            grid = new Uint8Array(gridCols * gridRows);

            generateTarget();

            // Block supply piles (left and right)
            blockSupply = [
                { x: 5, y: groundRow },
                { x: gridCols - 6, y: groundRow }
            ];

            robots = [];
            for (let i = 0; i < robotCount; i++) {
                robots.push({
                    x: 10 + Math.random() * (gridCols - 20),
                    y: groundRow - Math.random() * 5,
                    carrying: 0, // 0=nothing, 1=foundation, 2=wall, 3=cap
                    targetX: -1,
                    targetY: -1,
                    state: 'wander', // wander, pickup, place
                    timer: 0
                });
            }
        }

        init();

        document.getElementById('resetBtn').onclick = init;
        window.reset = init;

        function determineBlockType(gx, gy) {
            // Foundation: on ground row
            if (gy === groundRow) return 1;
            // Cap: check if high enough (at top of target)
            let hasAboveTarget = false;
            for (let dy = -1; dy >= -3; dy--) {
                if (targetCells.has((gy + dy) + ',' + gx)) { hasAboveTarget = true; break; }
            }
            if (!hasAboveTarget && getCell(gx, gy + 1) > 0) return 3; // Cap if nothing above in target
            // Wall: default
            return 2;
        }

        function canPlace(gx, gy) {
            if (gx < 0 || gx >= gridCols || gy < 0 || gy >= gridRows) return false;
            if (getCell(gx, gy) !== 0) return false;
            if (!targetCells.has(gy + ',' + gx)) return false;

            // Must have support below (or be on ground)
            if (gy >= groundRow) return true;
            if (getCell(gx, gy + 1) > 0) return true;
            // Or have blocks on both sides (for arches)
            if (getCell(gx - 1, gy) > 0 && getCell(gx + 1, gy) > 0) return true;
            // Adjacent below-diagonal support
            if (getCell(gx - 1, gy + 1) > 0 || getCell(gx + 1, gy + 1) > 0) return true;

            return false;
        }

        function findPlaceableSpot(rx, ry) {
            // Look nearby for a target cell that can be placed
            let bestDist = Infinity;
            let bestX = -1, bestY = -1;
            const searchR = 15;

            for (let dy = -searchR; dy <= searchR; dy++) {
                for (let dx = -searchR; dx <= searchR; dx++) {
                    const gx = Math.floor(rx) + dx;
                    const gy = Math.floor(ry) + dy;
                    if (canPlace(gx, gy)) {
                        const d = dx * dx + dy * dy;
                        if (d < bestDist) {
                            bestDist = d;
                            bestX = gx;
                            bestY = gy;
                        }
                    }
                }
            }
            return bestX >= 0 ? { x: bestX, y: bestY } : null;
        }

        let lastTime = 0;
        let placedCount = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            const rawDt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;
            const dt = rawDt * buildSpeed;

            // Background
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Ground
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(0, (groundRow + 1) * CELL, W, H - (groundRow + 1) * CELL);

            // Draw target outline if showRules
            if (showRules) {
                ctx.save();
                ctx.globalAlpha = 0.15;
                targetCells.forEach(function(key) {
                    const parts = key.split(',');
                    const ty = parseInt(parts[0]);
                    const tx = parseInt(parts[1]);
                    ctx.fillStyle = getCell(tx, ty) > 0 ? '#4a4' : '#666';
                    ctx.fillRect(tx * CELL, ty * CELL, CELL - 1, CELL - 1);
                });
                ctx.restore();
            }

            // Draw placed blocks
            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    const v = getCell(x, y);
                    if (v === 0) continue;
                    let color;
                    if (v === 1) color = '#8B6914'; // Foundation brown
                    else if (v === 2) color = '#6a6a7a'; // Wall gray
                    else color = '#c8a82e'; // Cap gold

                    ctx.fillStyle = color;
                    ctx.fillRect(x * CELL + 0.5, y * CELL + 0.5, CELL - 1, CELL - 1);

                    // Highlight edge
                    ctx.fillStyle = 'rgba(255,255,255,0.08)';
                    ctx.fillRect(x * CELL + 0.5, y * CELL + 0.5, CELL - 1, 1);
                    ctx.fillRect(x * CELL + 0.5, y * CELL + 0.5, 1, CELL - 1);
                }
            }

            // Draw supply piles
            for (let i = 0; i < blockSupply.length; i++) {
                const s = blockSupply[i];
                for (let dy = -2; dy <= 0; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        ctx.fillStyle = '#5a4a2a';
                        ctx.fillRect((s.x + dx) * CELL, (s.y + dy) * CELL, CELL - 1, CELL - 1);
                    }
                }
                ctx.fillStyle = 'rgba(221,161,94,0.3)';
                ctx.fillText('SUPPLY', s.x * CELL - 10, (s.y - 3) * CELL);
            }

            // Update robots
            placedCount = 0;
            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    if (getCell(x, y) > 0) placedCount++;
                }
            }

            for (let i = 0; i < robots.length; i++) {
                const r = robots[i];
                const speed = 12 * dt; // cells per second * dt

                if (r.state === 'wander') {
                    if (r.carrying === 0) {
                        // Go pick up a block
                        const nearest = blockSupply.reduce(function(a, b) {
                            const da = Math.abs(a.x - r.x) + Math.abs(a.y - r.y);
                            const db = Math.abs(b.x - r.x) + Math.abs(b.y - r.y);
                            return da < db ? a : b;
                        });
                        r.targetX = nearest.x + (Math.random() - 0.5) * 2;
                        r.targetY = nearest.y - 1;
                        r.state = 'pickup';
                    } else {
                        // Find a place to put the block
                        const spot = findPlaceableSpot(r.x, r.y);
                        if (spot) {
                            r.targetX = spot.x;
                            r.targetY = spot.y - 1; // stand above
                            r.state = 'place';
                        } else {
                            // Random walk to find spots
                            r.x += (Math.random() - 0.5) * speed * 3;
                            r.y += (Math.random() - 0.5) * speed;
                            r.y = Math.min(r.y, groundRow);
                            r.x = Math.max(2, Math.min(gridCols - 2, r.x));
                        }
                    }
                } else if (r.state === 'pickup') {
                    // Move toward supply
                    const dx = r.targetX - r.x;
                    const dy = r.targetY - r.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 1) {
                        r.carrying = 1 + Math.floor(Math.random() * 3); // random block type (will be corrected on place)
                        r.state = 'wander';
                    } else {
                        r.x += (dx / dist) * speed;
                        r.y += (dy / dist) * speed;
                    }
                } else if (r.state === 'place') {
                    const dx = r.targetX - r.x;
                    const dy = r.targetY - r.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 1.5) {
                        const gx = Math.round(r.targetX);
                        const gy = Math.round(r.targetY + 1);
                        if (canPlace(gx, gy)) {
                            const blockType = determineBlockType(gx, gy);
                            setCell(gx, gy, blockType);
                            r.carrying = 0;
                            r.state = 'wander';
                        } else {
                            r.state = 'wander';
                        }
                    } else {
                        r.x += (dx / dist) * speed;
                        r.y += (dy / dist) * speed;
                    }
                }

                // Gravity: robots walk on ground or on blocks
                if (r.y < groundRow) {
                    const below = getCell(Math.floor(r.x), Math.floor(r.y) + 1);
                    if (below === 0 && r.state !== 'place') {
                        r.y += speed * 2; // fall
                    }
                }
                r.y = Math.min(r.y, groundRow);
                r.x = Math.max(1, Math.min(gridCols - 2, r.x));

                // Draw robot
                const rx = r.x * CELL;
                const ry = r.y * CELL;
                ctx.fillStyle = r.carrying > 0 ? '#e05050' : '#50a0e0';
                // Triangle robot
                ctx.beginPath();
                ctx.moveTo(rx, ry - 6);
                ctx.lineTo(rx - 4, ry + 3);
                ctx.lineTo(rx + 4, ry + 3);
                ctx.closePath();
                ctx.fill();

                // Show carried block
                if (r.carrying > 0) {
                    let blockColor = r.carrying === 1 ? '#8B6914' : r.carrying === 2 ? '#7a7a8a' : '#c8a82e';
                    ctx.fillStyle = blockColor;
                    ctx.fillRect(rx - 3, ry - 10, 6, 4);
                }
            }

            // Completion
            const totalTarget = targetCells.size;
            const completion = totalTarget > 0 ? Math.round(placedCount / totalTarget * 100) : 0;
            document.getElementById('blocksVal').textContent = placedCount;
            document.getElementById('completionVal').textContent = Math.min(100, completion) + '%';
        }

        requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>