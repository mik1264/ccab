<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergent Pedestrian Lanes - Collective Intelligence - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 15px; left: 15px; z-index: 100;
            color: #8A9A5B; text-decoration: none;
            background: rgba(10,14,26,0.8); border: 2px solid #8A9A5B;
            border-radius: 25px; padding: 10px 20px;
            font-size: 14px; font-weight: 500;
            transition: background 0.3s;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 15px; right: 15px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h3 {
            font-size: 14px; color: #8A9A5B; margin-bottom: 12px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .control-group { margin-bottom: 12px; }
        .control-group label {
            display: block; font-size: 12px; color: #999; margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%; accent-color: #8A9A5B;
        }
        .control-group .value {
            float: right; color: #8A9A5B; font-size: 12px; font-weight: 600;
        }
        .metrics {
            margin-top: 15px; padding-top: 12px;
            border-top: 1px solid rgba(138,154,91,0.2);
        }
        .metric {
            display: flex; justify-content: space-between;
            font-size: 12px; margin-bottom: 6px;
        }
        .metric-label { color: #888; }
        .metric-value { color: #DDA15E; font-weight: 600; }
        .btn {
            width: 100%; padding: 8px; margin-top: 8px;
            background: rgba(138,154,91,0.3); border: 1px solid #8A9A5B;
            color: #8A9A5B; border-radius: 6px; cursor: pointer;
            font-size: 12px; font-weight: 600;
            transition: background 0.3s;
        }
        .btn:hover { background: rgba(138,154,91,0.5); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Collective Intelligence</a>
    <div class="controls">
        <h3>Pedestrian Lanes</h3>
        <div class="control-group">
            <label>Agents Per Side <span class="value" id="agentCountVal">150</span></label>
            <input type="range" id="agentCount" min="50" max="300" value="150" step="10">
        </div>
        <div class="control-group">
            <label>Corridor Width <span class="value" id="corridorVal">60%</span></label>
            <input type="range" id="corridorWidth" min="30" max="90" value="60">
        </div>
        <div class="control-group">
            <label>Avoidance Strength <span class="value" id="avoidanceVal">1.5</span></label>
            <input type="range" id="avoidance" min="5" max="30" value="15">
        </div>
        <div class="control-group">
            <label>Desired Speed <span class="value" id="speedVal">2.0</span></label>
            <input type="range" id="desiredSpeed" min="5" max="40" value="20">
        </div>
        <div class="metrics">
            <div class="metric">
                <span class="metric-label">Lanes Formed</span>
                <span class="metric-value" id="laneCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Avg Speed</span>
                <span class="metric-value" id="avgSpeed">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Flow Efficiency</span>
                <span class="metric-value" id="flowEff">0%</span>
            </div>
        </div>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        let agents = [];
        let animId;
        let paused = false;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        function getParams() {
            return {
                count: parseInt(document.getElementById('agentCount').value),
                corridorFrac: parseInt(document.getElementById('corridorWidth').value) / 100,
                avoidance: parseInt(document.getElementById('avoidance').value) / 10,
                desiredSpeed: parseInt(document.getElementById('desiredSpeed').value) / 10
            };
        }

        function corridorBounds() {
            const p = getParams();
            const ch = H * p.corridorFrac;
            const top = (H - ch) / 2;
            return { top: top, bottom: top + ch, height: ch };
        }

        function initAgents() {
            const p = getParams();
            const cb = corridorBounds();
            agents = [];
            for (let i = 0; i < p.count * 2; i++) {
                const goingRight = i < p.count;
                agents.push({
                    x: goingRight ? Math.random() * W * 0.3 : W * 0.7 + Math.random() * W * 0.3,
                    y: cb.top + Math.random() * cb.height,
                    vx: 0, vy: 0,
                    dir: goingRight ? 1 : -1,
                    radius: 4
                });
            }
        }

        function update() {
            const p = getParams();
            const cb = corridorBounds();
            const avoidRadius = 25;
            const avoidStr = p.avoidance;
            const speed = p.desiredSpeed;
            let totalSpeed = 0;

            for (let i = 0; i < agents.length; i++) {
                const a = agents[i];
                // Desired velocity
                let fx = a.dir * speed;
                let fy = 0;

                // Social forces from other agents
                for (let j = 0; j < agents.length; j++) {
                    if (i === j) continue;
                    const b = agents[j];
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < avoidRadius && dist > 0.1) {
                        const overlap = avoidRadius - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        // Stronger repulsion for oncoming agents
                        const oncoming = a.dir !== b.dir ? 2.0 : 0.8;
                        fx += nx * overlap * avoidStr * oncoming * 0.1;
                        fy += ny * overlap * avoidStr * oncoming * 0.1;
                    }
                }

                // Wall repulsion (corridor boundaries)
                const wallDist = 20;
                if (a.y - cb.top < wallDist) {
                    fy += (wallDist - (a.y - cb.top)) * 0.5;
                }
                if (cb.bottom - a.y < wallDist) {
                    fy -= (wallDist - (cb.bottom - a.y)) * 0.5;
                }

                // Limit force magnitude
                const fMag = Math.sqrt(fx * fx + fy * fy);
                const maxForce = speed * 1.5;
                if (fMag > maxForce) {
                    fx = fx / fMag * maxForce;
                    fy = fy / fMag * maxForce;
                }

                // Smooth velocity update
                a.vx = a.vx * 0.7 + fx * 0.3;
                a.vy = a.vy * 0.7 + fy * 0.3;
            }

            for (let i = 0; i < agents.length; i++) {
                const a = agents[i];
                a.x += a.vx;
                a.y += a.vy;

                // Clamp to corridor
                a.y = Math.max(cb.top + a.radius, Math.min(cb.bottom - a.radius, a.y));

                // Wrap horizontally
                if (a.dir === 1 && a.x > W + 10) a.x = -10;
                if (a.dir === -1 && a.x < -10) a.x = W + 10;

                totalSpeed += Math.abs(a.vx);
            }

            // Metrics
            const avgSpd = agents.length > 0 ? totalSpeed / agents.length : 0;
            document.getElementById('avgSpeed').textContent = avgSpd.toFixed(2);
            document.getElementById('flowEff').textContent =
                (avgSpd / speed * 100).toFixed(0) + '%';

            // Lane detection: slice corridor into horizontal bands, check homogeneity
            const bandCount = 10;
            const bandH = cb.height / bandCount;
            let lanes = 0;
            for (let b = 0; b < bandCount; b++) {
                const bandTop = cb.top + b * bandH;
                const bandBot = bandTop + bandH;
                let leftCount = 0, rightCount = 0;
                for (let i = 0; i < agents.length; i++) {
                    if (agents[i].y >= bandTop && agents[i].y < bandBot) {
                        if (agents[i].dir === 1) rightCount++;
                        else leftCount++;
                    }
                }
                const total = leftCount + rightCount;
                if (total > 2) {
                    const dominant = Math.max(leftCount, rightCount) / total;
                    if (dominant > 0.75) lanes++;
                }
            }
            document.getElementById('laneCount').textContent = lanes;
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            const cb = corridorBounds();

            // Draw corridor
            ctx.fillStyle = 'rgba(138,154,91,0.05)';
            ctx.fillRect(0, cb.top, W, cb.height);
            ctx.strokeStyle = 'rgba(138,154,91,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cb.top); ctx.lineTo(W, cb.top);
            ctx.moveTo(0, cb.bottom); ctx.lineTo(W, cb.bottom);
            ctx.stroke();

            // Draw agents
            for (let i = 0; i < agents.length; i++) {
                const a = agents[i];
                const color = a.dir === 1 ? '#4488ff' : '#ff4466';
                const alpha = 0.8;

                // Trail dot
                ctx.beginPath();
                ctx.arc(a.x - a.vx * 2, a.y - a.vy * 2, 2, 0, Math.PI * 2);
                ctx.fillStyle = color + '30';
                ctx.fill();

                // Agent body
                ctx.beginPath();
                ctx.arc(a.x, a.y, a.radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Direction indicator
                ctx.beginPath();
                ctx.moveTo(a.x + a.dir * 6, a.y);
                ctx.lineTo(a.x - a.dir * 2, a.y - 3);
                ctx.lineTo(a.x - a.dir * 2, a.y + 3);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.5;
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Direction labels
            ctx.font = '12px sans-serif';
            ctx.fillStyle = '#4488ff88';
            ctx.textAlign = 'left';
            ctx.fillText('RIGHT-MOVERS', 10, cb.top - 8);
            ctx.fillStyle = '#ff446688';
            ctx.textAlign = 'right';
            ctx.fillText('LEFT-MOVERS', W - 10, cb.top - 8);
        }

        function animate() {
            if (!paused) update();
            draw();
            animId = requestAnimationFrame(animate);
        }

        function reset() {
            cancelAnimationFrame(animId);
            initAgents();
            animate();
        }
        window.reset = reset;

        // UI bindings
        document.getElementById('agentCount').oninput = function() {
            document.getElementById('agentCountVal').textContent = this.value;
        };
        document.getElementById('corridorWidth').oninput = function() {
            document.getElementById('corridorVal').textContent = this.value + '%';
        };
        document.getElementById('avoidance').oninput = function() {
            document.getElementById('avoidanceVal').textContent = (this.value / 10).toFixed(1);
        };
        document.getElementById('desiredSpeed').oninput = function() {
            document.getElementById('speedVal').textContent = (this.value / 10).toFixed(1);
        };
        document.getElementById('resetBtn').onclick = reset;
        document.getElementById('agentCount').onchange = reset;

        initAgents();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
