<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Shape Assembly - Collective Intelligence - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            color: #ccc;
        }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 15px; left: 15px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8);
            border-radius: 25px; border: 2px solid #8A9A5B;
            padding: 10px 20px; text-decoration: none; font-size: 14px;
            transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.2); transform: translateX(-4px); }
        #controls {
            position: fixed; top: 15px; right: 15px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            border: 1px solid rgba(138,154,91,0.3);
        }
        #controls h3 { color: #fff; margin-bottom: 12px; font-size: 15px; }
        .control-row { margin: 8px 0; }
        .control-row label { display: block; font-size: 11px; color: #8A9A5B; margin-bottom: 3px; }
        .control-row input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-row .val { float: right; color: #aaa; font-size: 11px; }
        .control-row select {
            width: 100%; background: rgba(10,14,26,0.9); color: #8A9A5B;
            border: 1px solid rgba(138,154,91,0.4); border-radius: 4px;
            padding: 4px; font-size: 12px;
        }
        .stat { margin: 4px 0; font-size: 12px; }
        .stat-label { color: #888; font-size: 11px; }
        .stat-value { color: #8A9A5B; font-weight: bold; }
        button {
            background: rgba(138,154,91,0.15); border: 1px solid rgba(138,154,91,0.4);
            color: #8A9A5B; padding: 6px 14px; border-radius: 6px; cursor: pointer;
            font-size: 12px; margin-top: 6px; transition: all 0.3s;
        }
        button:hover { background: rgba(138,154,91,0.3); }
        hr { border: none; border-top: 1px solid rgba(138,154,91,0.2); margin: 10px 0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Collective Intelligence</a>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Swarm Shape Assembly</h3>
        <div class="control-row">
            <label>Target Shape</label>
            <select id="shapeSelect">
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="star">Star</option>
                <option value="heart">Heart</option>
                <option value="letterA">Letter A</option>
            </select>
        </div>
        <div class="control-row">
            <label>Robot Count <span class="val" id="robotVal">300</span></label>
            <input type="range" id="robotCount" min="100" max="600" value="300" step="10">
        </div>
        <div class="control-row">
            <label>Noise Level <span class="val" id="noiseVal">30</span></label>
            <input type="range" id="noise" min="5" max="80" value="30">
        </div>
        <div class="control-row">
            <label>Attraction Strength <span class="val" id="attrVal">50</span></label>
            <input type="range" id="attraction" min="10" max="100" value="50">
        </div>
        <hr>
        <div class="stat"><span class="stat-label">In Formation:</span> <span class="stat-value" id="inFormation">0%</span></div>
        <div class="stat"><span class="stat-label">Avg Distance:</span> <span class="stat-value" id="avgDist">-</span></div>
        <button id="resetBtn">Reset</button>
        <button id="scrambleBtn">Scramble</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
        resize();
        window.addEventListener('resize', resize);

        // Shape definitions (return points on boundary, normalized -1 to 1)
        function getShapePoints(name, numPoints) {
            const pts = [];
            switch (name) {
                case 'circle':
                    for (let i = 0; i < numPoints; i++) {
                        const a = (i / numPoints) * Math.PI * 2;
                        pts.push({ x: Math.cos(a), y: Math.sin(a) });
                    }
                    break;
                case 'square':
                    for (let i = 0; i < numPoints; i++) {
                        const t = i / numPoints;
                        if (t < 0.25) pts.push({ x: -1 + 8 * t, y: -1 });
                        else if (t < 0.5) pts.push({ x: 1, y: -1 + 8 * (t - 0.25) });
                        else if (t < 0.75) pts.push({ x: 1 - 8 * (t - 0.5), y: 1 });
                        else pts.push({ x: -1, y: 1 - 8 * (t - 0.75) });
                    }
                    break;
                case 'star': {
                    const spikes = 5;
                    for (let i = 0; i < numPoints; i++) {
                        const a = (i / numPoints) * Math.PI * 2 - Math.PI / 2;
                        const spikeIdx = (i / numPoints) * spikes * 2;
                        const r = (Math.floor(spikeIdx) % 2 === 0) ? 1 : 0.45;
                        const nextR = (Math.floor(spikeIdx + 1) % 2 === 0) ? 1 : 0.45;
                        const frac = spikeIdx - Math.floor(spikeIdx);
                        const radius = r + (nextR - r) * frac;
                        pts.push({ x: Math.cos(a) * radius, y: Math.sin(a) * radius });
                    }
                    break;
                }
                case 'heart':
                    for (let i = 0; i < numPoints; i++) {
                        const t = (i / numPoints) * Math.PI * 2;
                        const x = 16 * Math.sin(t) ** 3;
                        const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                        pts.push({ x: x / 17, y: y / 17 });
                    }
                    break;
                case 'letterA':
                    // A shape with outline points
                    const segments = [
                        // Left leg
                        ...Array.from({ length: Math.floor(numPoints * 0.3) }, (_, i) => {
                            const t = i / Math.floor(numPoints * 0.3);
                            return { x: -0.6 + 0.6 * t, y: 1 - 2 * t };
                        }),
                        // Right leg
                        ...Array.from({ length: Math.floor(numPoints * 0.3) }, (_, i) => {
                            const t = i / Math.floor(numPoints * 0.3);
                            return { x: 0 + 0.6 * t, y: -1 + 2 * t };
                        }),
                        // Crossbar
                        ...Array.from({ length: Math.floor(numPoints * 0.2) }, (_, i) => {
                            const t = i / Math.floor(numPoints * 0.2);
                            return { x: -0.35 + 0.7 * t, y: 0.15 };
                        }),
                        // Left serif
                        ...Array.from({ length: Math.floor(numPoints * 0.1) }, (_, i) => {
                            const t = i / Math.floor(numPoints * 0.1);
                            return { x: -0.8 + 0.4 * t, y: 1 };
                        }),
                        // Right serif
                        ...Array.from({ length: Math.floor(numPoints * 0.1) }, (_, i) => {
                            const t = i / Math.floor(numPoints * 0.1);
                            return { x: 0.4 + 0.4 * t, y: 1 };
                        })
                    ];
                    pts.push(...segments);
                    break;
            }
            return pts;
        }

        // Distance from point to nearest shape boundary point
        function distToShape(px, py, shapePts, cx, cy, scale) {
            let minDist = Infinity;
            for (const pt of shapePts) {
                const sx = cx + pt.x * scale;
                const sy = cy + pt.y * scale;
                const dx = px - sx;
                const dy = py - sy;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < minDist) minDist = d;
            }
            return minDist;
        }

        // Nearest point on shape
        function nearestShapePoint(px, py, shapePts, cx, cy, scale) {
            let minDist = Infinity, best = { x: cx, y: cy };
            for (const pt of shapePts) {
                const sx = cx + pt.x * scale;
                const sy = cy + pt.y * scale;
                const dx = px - sx;
                const dy = py - sy;
                const d = dx * dx + dy * dy;
                if (d < minDist) { minDist = d; best = { x: sx, y: sy }; }
            }
            return best;
        }

        let robots = [];
        let shapePts = [];
        let shapeName = 'circle';
        let shapeScale, shapeCX, shapeCY;

        function init() {
            const n = parseInt(document.getElementById('robotCount').value);
            shapeName = document.getElementById('shapeSelect').value;
            shapeScale = Math.min(W * 0.55, H * 0.55) * 0.4;
            shapeCX = W / 2 - 80;
            shapeCY = H / 2;
            shapePts = getShapePoints(shapeName, 200);

            robots = [];
            for (let i = 0; i < n; i++) {
                robots.push({
                    x: shapeCX + (Math.random() - 0.5) * W * 0.8,
                    y: shapeCY + (Math.random() - 0.5) * H * 0.8,
                    vx: 0, vy: 0
                });
            }
        }

        function update() {
            const noiseLevel = parseInt(document.getElementById('noise').value) / 100;
            const attraction = parseInt(document.getElementById('attraction').value) / 100;
            const threshold = 15; // "in formation" distance

            let inCount = 0;
            let totalDist = 0;

            robots.forEach(robot => {
                const nearest = nearestShapePoint(robot.x, robot.y, shapePts, shapeCX, shapeCY, shapeScale);
                const dx = nearest.x - robot.x;
                const dy = nearest.y - robot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                totalDist += dist;

                if (dist > threshold) {
                    // Move toward shape
                    const force = attraction * 0.15;
                    robot.vx += (dx / dist) * force;
                    robot.vy += (dy / dist) * force;
                } else {
                    inCount++;
                    // Gentle settling - reduce velocity
                    robot.vx *= 0.85;
                    robot.vy *= 0.85;
                    // Tiny attraction to stay on boundary
                    robot.vx += (dx / Math.max(dist, 1)) * 0.02;
                    robot.vy += (dy / Math.max(dist, 1)) * 0.02;
                }

                // Noise
                robot.vx += (Math.random() - 0.5) * noiseLevel * 2;
                robot.vy += (Math.random() - 0.5) * noiseLevel * 2;

                // Separation from nearby robots
                robots.forEach(other => {
                    if (other === robot) return;
                    const sdx = robot.x - other.x;
                    const sdy = robot.y - other.y;
                    const sd = sdx * sdx + sdy * sdy;
                    if (sd < 100 && sd > 0) {
                        const sf = 0.5 / Math.sqrt(sd);
                        robot.vx += sdx * sf;
                        robot.vy += sdy * sf;
                    }
                });

                // Damping
                robot.vx *= 0.92;
                robot.vy *= 0.92;

                // Speed limit
                const speed = Math.sqrt(robot.vx * robot.vx + robot.vy * robot.vy);
                if (speed > 4) {
                    robot.vx = (robot.vx / speed) * 4;
                    robot.vy = (robot.vy / speed) * 4;
                }

                robot.x += robot.vx;
                robot.y += robot.vy;

                // Bounds
                robot.x = Math.max(5, Math.min(W - 5, robot.x));
                robot.y = Math.max(5, Math.min(H - 5, robot.y));
            });

            // For performance: only do separation on subset if too many robots
            const pct = robots.length > 0 ? Math.round((inCount / robots.length) * 100) : 0;
            document.getElementById('inFormation').textContent = pct + '%';
            document.getElementById('avgDist').textContent = (totalDist / Math.max(robots.length, 1)).toFixed(1) + 'px';
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Draw target shape outline (faint)
            if (shapePts.length > 1) {
                ctx.beginPath();
                shapePts.forEach((pt, i) => {
                    const x = shapeCX + pt.x * shapeScale;
                    const y = shapeCY + pt.y * shapeScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.strokeStyle = 'rgba(138,154,91,0.12)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Faint fill
                ctx.fillStyle = 'rgba(138,154,91,0.03)';
                ctx.fill();
            }

            // Draw robots
            const threshold = 15;
            robots.forEach(robot => {
                const dist = distToShape(robot.x, robot.y, shapePts, shapeCX, shapeCY, shapeScale);
                const closeness = Math.max(0, 1 - dist / 150);

                ctx.beginPath();
                ctx.arc(robot.x, robot.y, 2.5, 0, Math.PI * 2);

                if (dist < threshold) {
                    // On target - bright
                    ctx.fillStyle = `rgba(255,255,255,${0.7 + closeness * 0.3})`;
                } else {
                    // Far - dim, with color hinting direction
                    ctx.fillStyle = `rgba(138,154,91,${0.15 + closeness * 0.6})`;
                }
                ctx.fill();

                // Faint trail showing velocity
                if (dist > threshold) {
                    const speed = Math.sqrt(robot.vx * robot.vx + robot.vy * robot.vy);
                    if (speed > 0.5) {
                        ctx.beginPath();
                        ctx.moveTo(robot.x, robot.y);
                        ctx.lineTo(robot.x - robot.vx * 3, robot.y - robot.vy * 3);
                        ctx.strokeStyle = `rgba(138,154,91,${closeness * 0.2})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            });

            // Shape name label
            ctx.fillStyle = 'rgba(138,154,91,0.5)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Target: ' + shapeName.toUpperCase(), shapeCX, H - 25);
        }

        let paused = false;
        function animate() {
            if (!paused) update();
            draw();
            requestAnimationFrame(animate);
        }

        function reset() {
            init();
        }
        window.reset = reset;

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('scrambleBtn').addEventListener('click', () => {
            robots.forEach(r => {
                r.x = shapeCX + (Math.random() - 0.5) * W * 0.8;
                r.y = shapeCY + (Math.random() - 0.5) * H * 0.8;
                r.vx = (Math.random() - 0.5) * 5;
                r.vy = (Math.random() - 0.5) * 5;
            });
        });
        document.getElementById('shapeSelect').addEventListener('change', () => {
            shapeName = document.getElementById('shapeSelect').value;
            shapePts = getShapePoints(shapeName, 200);
        });
        document.getElementById('robotCount').oninput = function() {
            document.getElementById('robotVal').textContent = this.value;
        };
        document.getElementById('noise').oninput = function() {
            document.getElementById('noiseVal').textContent = this.value;
        };
        document.getElementById('attraction').oninput = function() {
            document.getElementById('attrVal').textContent = this.value;
        };
        document.getElementById('robotCount').addEventListener('change', reset);

        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
