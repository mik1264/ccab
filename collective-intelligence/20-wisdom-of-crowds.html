<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wisdom of Crowds - Estimation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8); border-radius: 25px;
            border: 2px solid #8A9A5B; padding: 10px 20px; text-decoration: none;
            font-size: 14px; transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            color: #c0c8e0; font-size: 13px;
        }
        .controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 4px; color: #9aa0b8; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group .value { float: right; color: #8A9A5B; font-weight: bold; }
        .metric { margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1); border-radius: 6px; }
        .metric .label { color: #9aa0b8; font-size: 11px; }
        .metric .val { color: #DDA15E; font-size: 18px; font-weight: bold; }
        .metric .sub { color: #6a7090; font-size: 11px; }
        .btn { background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid #8A9A5B;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 8px; }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-primary { background: rgba(221,161,94,0.3); color: #DDA15E; border-color: #DDA15E; }
        .btn-primary:hover { background: rgba(221,161,94,0.5); }
        .hint { color: #666; font-size: 11px; margin-top: 8px; font-style: italic; }
        .guess-input { display: flex; gap: 6px; margin-top: 8px; }
        .guess-input input { flex: 1; background: rgba(10,14,26,0.8); color: #c0c8e0;
            border: 1px solid #8A9A5B; padding: 6px; border-radius: 4px; font-size: 13px; }
        .revealed { color: #50e664; font-weight: bold; font-size: 22px; }
        .hidden-label { color: #888; font-size: 12px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Collective Intelligence</a>
    <div class="controls">
        <h3>Wisdom of Crowds</h3>
        <div class="control-group">
            <label>Crowd Size <span class="value" id="crowdVal">200</span></label>
            <input type="range" id="crowdSlider" min="20" max="1000" value="200" step="10">
        </div>
        <div class="control-group">
            <label>Individual Error (&#963;) <span class="value" id="errorVal">80</span></label>
            <input type="range" id="errorSlider" min="20" max="200" value="80" step="5">
        </div>
        <div class="control-group">
            <label>Add Rate <span class="value" id="rateVal">3</span>/sec</label>
            <input type="range" id="rateSlider" min="1" max="20" value="3" step="1">
        </div>
        <button class="btn" id="resetBtn">Reset (New Count)</button>
        <button class="btn btn-primary" id="revealBtn">Reveal True Count</button>
        <div class="guess-input">
            <input type="number" id="guessInput" placeholder="Your guess...">
            <button class="btn" id="guessBtn">Guess</button>
        </div>
        <div class="metric">
            <div class="label">True Count</div>
            <div class="val" id="trueVal"><span class="hidden-label">??? (hidden)</span></div>
        </div>
        <div class="metric">
            <div class="label">Crowd Estimates</div>
            <div class="val" id="estCount">0</div>
        </div>
        <div class="metric">
            <div class="label">Crowd Average</div>
            <div class="val" id="avgVal">--</div>
            <div class="sub" id="avgError">Error: --</div>
        </div>
        <div class="metric">
            <div class="label">Avg Individual Error</div>
            <div class="val" id="indError">--</div>
        </div>
        <div class="metric">
            <div class="label">Your Guess</div>
            <div class="val" id="yourGuess">--</div>
        </div>
        <p class="hint">The crowd mean converges to truth via the Law of Large Numbers</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        const crowdSlider = document.getElementById('crowdSlider');
        const errorSlider = document.getElementById('errorSlider');
        const rateSlider = document.getElementById('rateSlider');

        let maxCrowd = +crowdSlider.value;
        let errorStd = +errorSlider.value;
        let addRate = +rateSlider.value;

        crowdSlider.oninput = function() { document.getElementById('crowdVal').textContent = this.value; maxCrowd = +this.value; };
        errorSlider.oninput = function() { document.getElementById('errorVal').textContent = this.value; errorStd = +this.value; };
        rateSlider.oninput = function() { document.getElementById('rateVal').textContent = this.value; addRate = +this.value; };

        // State
        let trueCount = 0;
        let dots = [];
        let estimates = [];
        let runningAvgs = []; // {n, avg}
        let userGuess = null;
        let revealed = false;
        let addAccum = 0;

        // Jar position/size
        let jarX, jarY, jarW, jarH;

        function gaussRandom() {
            // Box-Muller transform
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function init() {
            // Random true count between 100 and 600
            trueCount = 100 + Math.floor(Math.random() * 500);

            // Generate jar dots
            jarX = 60;
            jarY = H * 0.15;
            jarW = Math.min(W * 0.3, 300);
            jarH = H * 0.65;

            dots = [];
            for (let i = 0; i < trueCount; i++) {
                // Pack dots in jar shape
                let x, y;
                const maxAttempts = 50;
                for (let a = 0; a < maxAttempts; a++) {
                    x = jarX + 15 + Math.random() * (jarW - 30);
                    y = jarY + 15 + Math.random() * (jarH - 30);
                    break;
                }
                dots.push({
                    x: x, y: y,
                    color: 'hsl(' + (Math.random() * 360) + ', 70%, 60%)',
                    r: 3 + Math.random() * 2
                });
            }

            estimates = [];
            runningAvgs = [];
            userGuess = null;
            revealed = false;
            addAccum = 0;
            document.getElementById('trueVal').innerHTML = '<span class="hidden-label">??? (hidden)</span>';
            document.getElementById('yourGuess').textContent = '--';
        }

        init();

        document.getElementById('resetBtn').onclick = init;
        window.reset = init;

        document.getElementById('revealBtn').onclick = function() {
            revealed = true;
            document.getElementById('trueVal').innerHTML = '<span class="revealed">' + trueCount + '</span>';
        };

        document.getElementById('guessBtn').onclick = function() {
            const val = parseInt(document.getElementById('guessInput').value);
            if (!isNaN(val) && val > 0) {
                userGuess = val;
                document.getElementById('yourGuess').textContent = val;
                document.getElementById('guessInput').value = '';
            }
        };

        document.getElementById('guessInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') document.getElementById('guessBtn').click();
        });

        let lastTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            // Add estimates over time
            if (estimates.length < maxCrowd) {
                addAccum += addRate * dt;
                while (addAccum >= 1 && estimates.length < maxCrowd) {
                    addAccum -= 1;
                    const estimate = Math.max(1, Math.round(trueCount + gaussRandom() * errorStd));
                    estimates.push(estimate);

                    // Running average
                    const sum = estimates.reduce(function(a, b) { return a + b; }, 0);
                    const avg = sum / estimates.length;
                    runningAvgs.push({ n: estimates.length, avg: avg });
                }
            }

            // Background
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Draw the jar
            ctx.save();
            const jx = jarX, jy = jarY, jw = jarW, jh = jarH;

            // Jar body
            ctx.fillStyle = 'rgba(200, 220, 240, 0.05)';
            ctx.strokeStyle = 'rgba(200, 220, 240, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(jx, jy, jw, jh, 15);
            ctx.fill();
            ctx.stroke();

            // Jar lid
            ctx.fillStyle = 'rgba(160, 140, 120, 0.3)';
            ctx.fillRect(jx - 5, jy - 12, jw + 10, 14);
            ctx.strokeStyle = 'rgba(160, 140, 120, 0.5)';
            ctx.strokeRect(jx - 5, jy - 12, jw + 10, 14);

            // Glass reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.fillRect(jx + 5, jy + 10, 8, jh - 30);

            // Draw dots (jelly beans)
            for (let i = 0; i < dots.length; i++) {
                const d = dots[i];
                ctx.fillStyle = d.color;
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Label
            ctx.fillStyle = '#9aa0b8';
            ctx.font = '14px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('How many dots?', jx + jw / 2, jy + jh + 25);
            if (revealed) {
                ctx.fillStyle = '#50e664';
                ctx.font = 'bold 20px Segoe UI, sans-serif';
                ctx.fillText('True count: ' + trueCount, jx + jw / 2, jy + jh + 50);
            }
            ctx.restore();

            // ---- Right side: Charts ----
            const chartLeft = jarX + jarW + 60;
            const chartRight = W - 340;
            const chartW = chartRight - chartLeft;

            if (chartW < 100) { updateMetrics(); return; } // too narrow

            // 1) Histogram of estimates
            const histY = 40;
            const histH = H * 0.35;

            ctx.fillStyle = '#9aa0b8';
            ctx.font = '13px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Distribution of Individual Estimates', chartLeft, histY);

            if (estimates.length > 0) {
                // Build histogram bins
                const minE = Math.min.apply(null, estimates);
                const maxE = Math.max.apply(null, estimates);
                const range = Math.max(maxE - minE, 1);
                const numBins = Math.min(50, Math.max(10, Math.floor(chartW / 8)));
                const binW = range / numBins;
                const bins = new Array(numBins).fill(0);

                for (let i = 0; i < estimates.length; i++) {
                    const bin = Math.min(numBins - 1, Math.floor((estimates[i] - minE) / binW));
                    bins[bin]++;
                }

                const maxBin = Math.max.apply(null, bins);
                const barW = chartW / numBins;

                for (let i = 0; i < numBins; i++) {
                    const barH = maxBin > 0 ? (bins[i] / maxBin) * (histH - 30) : 0;
                    const x = chartLeft + i * barW;
                    const y = histY + histH - barH;

                    ctx.fillStyle = 'rgba(80, 140, 220, 0.6)';
                    ctx.fillRect(x, y, barW - 1, barH);
                }

                // True count line
                if (revealed) {
                    const tcX = chartLeft + ((trueCount - minE) / range) * chartW;
                    ctx.strokeStyle = '#50e664';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(tcX, histY + 10);
                    ctx.lineTo(tcX, histY + histH);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#50e664';
                    ctx.font = '11px Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('True: ' + trueCount, tcX, histY + 10);
                }

                // Crowd average line
                const avgEst = estimates.reduce(function(a, b) { return a + b; }, 0) / estimates.length;
                const avgX = chartLeft + ((avgEst - minE) / range) * chartW;
                ctx.strokeStyle = '#DDA15E';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(avgX, histY + 10);
                ctx.lineTo(avgX, histY + histH);
                ctx.stroke();
                ctx.fillStyle = '#DDA15E';
                ctx.font = '11px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Mean: ' + Math.round(avgEst), avgX, histY + histH + 14);

                // User guess line
                if (userGuess !== null) {
                    const ugX = chartLeft + ((userGuess - minE) / range) * chartW;
                    if (ugX >= chartLeft && ugX <= chartRight) {
                        ctx.strokeStyle = '#e05050';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([2, 3]);
                        ctx.beginPath();
                        ctx.moveTo(ugX, histY + 10);
                        ctx.lineTo(ugX, histY + histH);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#e05050';
                        ctx.fillText('You: ' + userGuess, ugX, histY + histH + 26);
                    }
                }

                // Axis labels
                ctx.fillStyle = '#6a7090';
                ctx.font = '10px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(Math.round(minE).toString(), chartLeft, histY + histH + 14);
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(maxE).toString(), chartRight, histY + histH + 14);
            }

            // 2) Running average convergence plot
            const convY = histY + histH + 55;
            const convH = H * 0.35;

            ctx.fillStyle = '#9aa0b8';
            ctx.font = '13px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Running Average vs True Count', chartLeft, convY);

            if (runningAvgs.length > 1) {
                // Y-axis range
                let minAvg = Infinity, maxAvg = -Infinity;
                for (let i = 0; i < runningAvgs.length; i++) {
                    if (runningAvgs[i].avg < minAvg) minAvg = runningAvgs[i].avg;
                    if (runningAvgs[i].avg > maxAvg) maxAvg = runningAvgs[i].avg;
                }
                minAvg = Math.min(minAvg, trueCount - 20);
                maxAvg = Math.max(maxAvg, trueCount + 20);
                const yRange = maxAvg - minAvg || 1;

                // True count horizontal line
                const trueY = convY + convH - ((trueCount - minAvg) / yRange) * (convH - 20);
                ctx.strokeStyle = revealed ? 'rgba(80, 230, 100, 0.5)' : 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(chartLeft, trueY);
                ctx.lineTo(chartRight, trueY);
                ctx.stroke();
                ctx.setLineDash([]);

                if (revealed) {
                    ctx.fillStyle = '#50e664';
                    ctx.font = '10px Segoe UI, sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText('True: ' + trueCount, chartLeft - 5, trueY + 4);
                }

                // Plot running average
                ctx.strokeStyle = '#DDA15E';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const maxN = runningAvgs[runningAvgs.length - 1].n;
                for (let i = 0; i < runningAvgs.length; i++) {
                    const px = chartLeft + (runningAvgs[i].n / maxN) * chartW;
                    const py = convY + convH - ((runningAvgs[i].avg - minAvg) / yRange) * (convH - 20);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Confidence interval (approx: +/- errorStd / sqrt(n))
                ctx.fillStyle = 'rgba(221, 161, 94, 0.1)';
                ctx.beginPath();
                for (let i = 0; i < runningAvgs.length; i++) {
                    const n = runningAvgs[i].n;
                    const ci = errorStd / Math.sqrt(n);
                    const px = chartLeft + (n / maxN) * chartW;
                    const py = convY + convH - ((runningAvgs[i].avg + ci - minAvg) / yRange) * (convH - 20);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                for (let i = runningAvgs.length - 1; i >= 0; i--) {
                    const n = runningAvgs[i].n;
                    const ci = errorStd / Math.sqrt(n);
                    const px = chartLeft + (n / maxN) * chartW;
                    const py = convY + convH - ((runningAvgs[i].avg - ci - minAvg) / yRange) * (convH - 20);
                    ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();

                // X-axis
                ctx.fillStyle = '#6a7090';
                ctx.font = '10px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('1', chartLeft, convY + convH + 14);
                ctx.textAlign = 'right';
                ctx.fillText('n=' + maxN, chartRight, convY + convH + 14);
                ctx.textAlign = 'center';
                ctx.fillText('Number of estimates', chartLeft + chartW / 2, convY + convH + 28);
            }

            // Box: convergence formula
            ctx.fillStyle = 'rgba(138, 154, 91, 0.1)';
            const formulaY = convY + convH + 40;
            ctx.fillRect(chartLeft, formulaY, chartW, 30);
            ctx.fillStyle = '#8A9A5B';
            ctx.font = '12px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Crowd error ~ sigma / sqrt(N)  |  Individual errors cancel out', chartLeft + chartW / 2, formulaY + 19);

            updateMetrics();
        }

        function updateMetrics() {
            document.getElementById('estCount').textContent = estimates.length;
            if (estimates.length > 0) {
                const avg = estimates.reduce(function(a, b) { return a + b; }, 0) / estimates.length;
                document.getElementById('avgVal').textContent = Math.round(avg);
                const crowdErr = Math.abs(avg - trueCount);
                document.getElementById('avgError').textContent = 'Error: ' + crowdErr.toFixed(1) + (revealed ? '' : ' (from hidden truth)');

                // Average individual error
                let totalIndErr = 0;
                for (let i = 0; i < estimates.length; i++) {
                    totalIndErr += Math.abs(estimates[i] - trueCount);
                }
                document.getElementById('indError').textContent = (totalIndErr / estimates.length).toFixed(1);
            } else {
                document.getElementById('avgVal').textContent = '--';
                document.getElementById('avgError').textContent = 'Error: --';
                document.getElementById('indError').textContent = '--';
            }
        }

        requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>