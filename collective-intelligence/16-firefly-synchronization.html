<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firefly Synchronization - Kuramoto Model</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            color: #8A9A5B; background: rgba(10,14,26,0.8); border-radius: 25px;
            border: 2px solid #8A9A5B; padding: 10px 20px; text-decoration: none;
            font-size: 14px; transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(138,154,91,0.3); }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; max-width: 300px;
            color: #c0c8e0; font-size: 13px;
        }
        .controls h3 { color: #8A9A5B; margin-bottom: 12px; font-size: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 4px; color: #9aa0b8; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group .value { float: right; color: #8A9A5B; font-weight: bold; }
        .metric { margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1); border-radius: 6px; }
        .metric .label { color: #9aa0b8; font-size: 11px; }
        .metric .val { color: #DDA15E; font-size: 18px; font-weight: bold; }
        .btn { background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid #8A9A5B;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 8px; }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .hint { color: #666; font-size: 11px; margin-top: 8px; font-style: italic; }
        .order-bar { margin-top: 8px; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .order-fill { height: 100%; background: linear-gradient(90deg, #DDA15E, #f0e060); border-radius: 4px; transition: width 0.1s; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Collective Intelligence</a>
    <div class="controls">
        <h3>Firefly Synchronization</h3>
        <div class="control-group">
            <label>Fireflies <span class="value" id="countVal">500</span></label>
            <input type="range" id="countSlider" min="100" max="1000" value="500" step="50">
        </div>
        <div class="control-group">
            <label>Coupling Strength (&#949;) <span class="value" id="couplingVal">0.05</span></label>
            <input type="range" id="couplingSlider" min="0.01" max="0.20" value="0.05" step="0.01">
        </div>
        <div class="control-group">
            <label>Sensing Radius <span class="value" id="radiusVal">80</span></label>
            <input type="range" id="radiusSlider" min="30" max="200" value="80" step="10">
        </div>
        <div class="control-group">
            <label>Flash Speed <span class="value" id="speedVal">1.0</span></label>
            <input type="range" id="speedSlider" min="0.3" max="3.0" value="1.0" step="0.1">
        </div>
        <button class="btn" id="resetBtn">Reset</button>
        <div class="metric">
            <div class="label">Order Parameter (Synchrony)</div>
            <div class="val" id="orderVal">0.00</div>
            <div class="order-bar"><div class="order-fill" id="orderBar" style="width:0%"></div></div>
        </div>
        <div class="metric">
            <div class="label">Total Flashes</div>
            <div class="val" id="flashCount">0</div>
        </div>
        <p class="hint">Watch random flashing converge to synchrony</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Controls
        const countSlider = document.getElementById('countSlider');
        const couplingSlider = document.getElementById('couplingSlider');
        const radiusSlider = document.getElementById('radiusSlider');
        const speedSlider = document.getElementById('speedSlider');

        let fireflyCount = +countSlider.value;
        let coupling = +couplingSlider.value;
        let sensingRadius = +radiusSlider.value;
        let flashSpeed = +speedSlider.value;
        let totalFlashes = 0;

        countSlider.oninput = function() {
            document.getElementById('countVal').textContent = this.value;
            fireflyCount = +this.value;
            init();
        };
        couplingSlider.oninput = function() {
            document.getElementById('couplingVal').textContent = this.value;
            coupling = +this.value;
        };
        radiusSlider.oninput = function() {
            document.getElementById('radiusVal').textContent = this.value;
            sensingRadius = +this.value;
        };
        speedSlider.oninput = function() {
            document.getElementById('speedVal').textContent = this.value;
            flashSpeed = +this.value;
        };

        // Spatial grid for neighbor lookup
        let gridCellSize, gridCols, gridRows, grid;

        function buildGrid() {
            gridCellSize = Math.max(sensingRadius, 30);
            gridCols = Math.ceil(W / gridCellSize);
            gridRows = Math.ceil(H / gridCellSize);
            grid = new Array(gridCols * gridRows);
            for (let i = 0; i < grid.length; i++) grid[i] = [];
            for (let i = 0; i < fireflies.length; i++) {
                const f = fireflies[i];
                const gx = Math.floor(f.x / gridCellSize);
                const gy = Math.floor(f.y / gridCellSize);
                if (gx >= 0 && gx < gridCols && gy >= 0 && gy < gridRows) {
                    grid[gy * gridCols + gx].push(i);
                }
            }
        }

        function getNeighborIndices(fx, fy) {
            const gx = Math.floor(fx / gridCellSize);
            const gy = Math.floor(fy / gridCellSize);
            const r = Math.ceil(sensingRadius / gridCellSize);
            const result = [];
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    const cx = gx + dx;
                    const cy = gy + dy;
                    if (cx >= 0 && cx < gridCols && cy >= 0 && cy < gridRows) {
                        const cell = grid[cy * gridCols + cx];
                        for (let k = 0; k < cell.length; k++) result.push(cell[k]);
                    }
                }
            }
            return result;
        }

        // Fireflies
        let fireflies = [];
        let flashes = []; // visual flash effects

        // Trees for forest background
        let trees = [];

        function generateTrees() {
            trees = [];
            const numTrees = Math.floor(W * H / 8000);
            for (let i = 0; i < numTrees; i++) {
                trees.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    height: 20 + Math.random() * 50,
                    width: 10 + Math.random() * 20,
                    shade: Math.random() * 0.3
                });
            }
            trees.sort((a, b) => a.y - b.y);
        }

        function init() {
            fireflies = [];
            flashes = [];
            totalFlashes = 0;
            for (let i = 0; i < fireflyCount; i++) {
                fireflies.push({
                    x: 40 + Math.random() * (W - 80),
                    y: 40 + Math.random() * (H - 80),
                    phase: Math.random(), // 0 to 1
                    naturalFreq: 0.8 + Math.random() * 0.4, // slight variation
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3
                });
            }
            generateTrees();
        }

        init();

        document.getElementById('resetBtn').onclick = init;
        window.reset = init;

        function computeOrderParameter() {
            // Kuramoto order parameter: R = |1/N * sum(e^(i*2pi*phase))|
            let sumCos = 0, sumSin = 0;
            for (let i = 0; i < fireflies.length; i++) {
                const theta = fireflies[i].phase * Math.PI * 2;
                sumCos += Math.cos(theta);
                sumSin += Math.sin(theta);
            }
            const N = fireflies.length;
            return Math.sqrt(sumCos * sumCos + sumSin * sumSin) / N;
        }

        let lastTime = 0;
        let paused = false;

        function animate(time) {
            requestAnimationFrame(animate);
            if (paused) return;

            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            // Draw forest background
            ctx.fillStyle = '#050a08';
            ctx.fillRect(0, 0, W, H);

            // Subtle gradient for depth
            const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
            grad.addColorStop(0, 'rgba(10, 25, 15, 0.3)');
            grad.addColorStop(1, 'rgba(2, 5, 3, 0.0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Draw trees (subtle dark silhouettes)
            for (let i = 0; i < trees.length; i++) {
                const t = trees[i];
                const g = 8 + Math.floor(t.shade * 12);
                ctx.fillStyle = 'rgb(' + g + ',' + (g + 5) + ',' + g + ')';
                // Trunk
                ctx.fillRect(t.x - 2, t.y - t.height * 0.3, 4, t.height * 0.3);
                // Canopy
                ctx.beginPath();
                ctx.moveTo(t.x, t.y - t.height);
                ctx.lineTo(t.x - t.width / 2, t.y - t.height * 0.2);
                ctx.lineTo(t.x + t.width / 2, t.y - t.height * 0.2);
                ctx.closePath();
                ctx.fill();
            }

            // Build spatial grid
            buildGrid();

            // Find which fireflies just flashed (before phase update)
            const flashedThisFrame = [];

            // Update firefly phases
            const r2 = sensingRadius * sensingRadius;
            for (let i = 0; i < fireflies.length; i++) {
                const f = fireflies[i];

                // Advance phase based on natural frequency
                f.phase += f.naturalFreq * flashSpeed * dt;

                // Check neighbors for coupling
                const neighbors = getNeighborIndices(f.x, f.y);
                for (let k = 0; k < neighbors.length; k++) {
                    const j = neighbors[k];
                    if (j === i) continue;
                    const o = fireflies[j];
                    const dx = o.x - f.x;
                    const dy = o.y - f.y;
                    const d2 = dx * dx + dy * dy;
                    if (d2 < r2) {
                        // Kuramoto coupling: phase advances when neighbor is ahead
                        const phaseDiff = o.phase - f.phase;
                        f.phase += coupling * Math.sin(phaseDiff * Math.PI * 2) * dt;
                    }
                }

                // Flash if phase >= 1
                if (f.phase >= 1.0) {
                    f.phase -= 1.0;
                    flashedThisFrame.push(i);
                    totalFlashes++;
                    flashes.push({ x: f.x, y: f.y, life: 1.0 });
                }

                // Gentle drift
                f.x += f.vx;
                f.y += f.vy;

                // Bounce off edges
                if (f.x < 10 || f.x > W - 10) f.vx *= -1;
                if (f.y < 10 || f.y > H - 10) f.vy *= -1;
                f.x = Math.max(5, Math.min(W - 5, f.x));
                f.y = Math.max(5, Math.min(H - 5, f.y));

                // Random walk component
                f.vx += (Math.random() - 0.5) * 0.02;
                f.vy += (Math.random() - 0.5) * 0.02;
                f.vx *= 0.99;
                f.vy *= 0.99;
            }

            // Draw flash effects (expanding glowing rings)
            for (let i = flashes.length - 1; i >= 0; i--) {
                const fl = flashes[i];
                fl.life -= dt * 2.5;
                if (fl.life <= 0) {
                    flashes.splice(i, 1);
                    continue;
                }
                const r = (1.0 - fl.life) * 30;
                const alpha = fl.life * 0.6;
                const grd = ctx.createRadialGradient(fl.x, fl.y, 0, fl.x, fl.y, r);
                grd.addColorStop(0, 'rgba(255, 255, 100, ' + alpha + ')');
                grd.addColorStop(0.5, 'rgba(255, 220, 50, ' + (alpha * 0.4) + ')');
                grd.addColorStop(1, 'rgba(255, 200, 0, 0)');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(fl.x, fl.y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw fireflies
            for (let i = 0; i < fireflies.length; i++) {
                const f = fireflies[i];
                // Brightness based on phase (peaks near 1.0)
                const brightness = Math.pow(Math.max(0, Math.sin(f.phase * Math.PI)), 2);
                const baseR = 2 + brightness * 3;

                // Glow
                if (brightness > 0.1) {
                    const glowR = baseR + brightness * 10;
                    const grd = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, glowR);
                    grd.addColorStop(0, 'rgba(255, 255, 80, ' + (brightness * 0.4) + ')');
                    grd.addColorStop(0.5, 'rgba(200, 200, 30, ' + (brightness * 0.15) + ')');
                    grd.addColorStop(1, 'rgba(150, 150, 0, 0)');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, glowR, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Core
                const r = Math.floor(100 + brightness * 155);
                const g = Math.floor(100 + brightness * 155);
                const b = Math.floor(20 + brightness * 30);
                ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                ctx.beginPath();
                ctx.arc(f.x, f.y, baseR, 0, Math.PI * 2);
                ctx.fill();
            }

            // Order parameter
            const order = computeOrderParameter();
            document.getElementById('orderVal').textContent = order.toFixed(3);
            document.getElementById('orderBar').style.width = (order * 100) + '%';
            document.getElementById('flashCount').textContent = totalFlashes.toLocaleString();
        }

        requestAnimationFrame(animate);

        // Pause support
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) paused = true;
            else { paused = false; lastTime = performance.now(); }
        });
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>