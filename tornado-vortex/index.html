<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tornado Vortex Simulation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Nunito', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 1.4rem; font-weight: 600;
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center;
}
.title-overlay .subtitle {
    font-size: 0.8rem; opacity: 0.7; margin-top: 4px; font-weight: 300;
}
.organic-back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    display: flex; align-items: center; gap: 8px;
    padding: 8px 16px; border-radius: 20px;
    background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
    color: #fff; text-decoration: none; font-size: 0.9rem;
    transition: background 0.3s;
}
.organic-back-link:hover { background: rgba(255,255,255,0.2); }
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
    padding: 12px 24px; border-radius: 20px; color: #fff; font-size: 0.85rem;
}
.controls label { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.controls input[type="range"] { width: 100px; }
.info-panel {
    position: fixed; top: 80px; right: 20px; z-index: 10;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(10px);
    padding: 12px 16px; border-radius: 12px; color: #fff; font-size: 0.75rem;
    line-height: 1.6;
}
.ef-scale {
    font-size: 1.1rem; font-weight: bold; margin-top: 4px;
}
</style>
</head>
<body>
<a href="../index.html" class="organic-back-link">
    <span class="back-arrow">&larr;</span>
    <span class="back-text">Gallery</span>
</a>
<div class="title-overlay">
    Tornado Vortex Simulation
    <div class="subtitle">Rotating updraft funnel with debris field</div>
</div>
<div class="info-panel">
    <div>Max Wind: <span id="maxWind">0</span> mph</div>
    <div>Particles: <span id="pCount">0</span></div>
    <div class="ef-scale">EF Scale: <span id="efScale">EF0</span></div>
</div>
<div class="controls">
    <label>Wind Speed: <input type="range" id="windSlider" min="0.5" max="5" step="0.1" value="2.5"> <span id="windVal">2.5</span></label>
    <label>Particle Density: <input type="range" id="densitySlider" min="500" max="5000" step="100" value="3000"> <span id="densityVal">3000</span></label>
    <label>Funnel Width: <input type="range" id="widthSlider" min="0.3" max="2" step="0.1" value="1"> <span id="widthVal">1.0</span></label>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H, cx;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
}
resize();
window.addEventListener('resize', resize);

const particles = [];
const debris = [];
const MAX_DEBRIS = 200;

class TornadoParticle {
    constructor() {
        this.reset();
    }
    reset() {
        // Start at ground level or in the funnel
        const startFromGround = Math.random() < 0.6;
        if (startFromGround) {
            this.y = H * 0.85 + Math.random() * H * 0.05;
            const angle = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 200;
            this.x = cx + Math.cos(angle) * dist;
        } else {
            this.y = H * 0.3 + Math.random() * H * 0.55;
            const angle = Math.random() * Math.PI * 2;
            const heightFrac = (H * 0.85 - this.y) / (H * 0.55);
            const dist = 20 + heightFrac * 100 + Math.random() * 50;
            this.x = cx + Math.cos(angle) * dist;
        }
        this.vx = 0;
        this.vy = 0;
        this.angle = Math.atan2(this.y - H * 0.5, this.x - cx);
        this.size = 1 + Math.random() * 2;
        this.life = 0.7 + Math.random() * 0.3;
        this.brightness = 0.3 + Math.random() * 0.7;
    }
    update(windSpeed, funnelWidth) {
        const groundY = H * 0.85;
        const topY = H * 0.15;
        const heightFrac = Math.max(0, Math.min(1, (groundY - this.y) / (groundY - topY)));

        // Funnel radius narrows as we go up
        const baseRadius = 80 * funnelWidth;
        const topRadius = 15 * funnelWidth;
        const targetRadius = baseRadius * (1 - heightFrac * 0.7) + topRadius * heightFrac;

        const dx = this.x - cx;
        const dist = Math.abs(dx);

        // Tangential velocity (rotation)
        const tangentialSpeed = windSpeed * 4 * (1 + heightFrac * 0.5);
        const direction = dx > 0 ? -1 : 1;

        // Radial: pull toward funnel wall
        const radialTarget = dist > targetRadius ? -windSpeed * 0.8 : windSpeed * 0.3;

        // Updraft
        const updraftSpeed = windSpeed * 1.5 * (1 - heightFrac * 0.3);
        const inFunnel = dist < targetRadius * 2;

        if (inFunnel) {
            this.vy += (-updraftSpeed * 0.1);
        }

        // Apply forces
        this.vx += (direction * tangentialSpeed * 0.02 + (targetRadius - dist) * 0.001 * windSpeed);
        this.vy *= 0.97;
        this.vx *= 0.97;

        this.x += this.vx;
        this.y += this.vy;

        // Swirl motion
        const swirlAngle = Math.atan2(0, dx) + Math.PI / 2;
        this.x += Math.cos(swirlAngle) * tangentialSpeed * 0.1;

        this.life -= 0.003;

        if (this.y < topY || this.y > H || this.life <= 0 || Math.abs(this.x - cx) > W * 0.4) {
            this.reset();
        }
    }
    draw() {
        const groundY = H * 0.85;
        const heightFrac = Math.max(0, (groundY - this.y) / (groundY - H * 0.15));

        // Color: dark gray/brown at base, lighter higher up
        const gray = Math.floor(80 + heightFrac * 100);
        const alpha = this.life * (0.3 + this.brightness * 0.4);
        ctx.fillStyle = `rgba(${gray}, ${gray - 10}, ${gray - 20}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * (1 + heightFrac * 0.5), 0, Math.PI * 2);
        ctx.fill();
    }
}

class Debris {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = cx + (Math.random() - 0.5) * 300;
        this.y = H * 0.83 + Math.random() * H * 0.05;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = -Math.random() * 3;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.2;
        this.size = 2 + Math.random() * 5;
        this.type = Math.floor(Math.random() * 3); // 0: square, 1: line, 2: triangle
        this.life = 0.5 + Math.random() * 0.5;
        this.color = Math.random() < 0.5 ? '#6a5030' : '#504030';
    }
    update(windSpeed) {
        const dx = this.x - cx;
        const dist = Math.abs(dx);

        // Sucked toward tornado
        if (dist < 200) {
            this.vx += (cx - this.x) * 0.002 * windSpeed;
            this.vy -= windSpeed * 0.15;
        }

        this.vx *= 0.99;
        this.vy += 0.05; // gravity
        this.vy *= 0.99;

        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotSpeed;

        this.life -= 0.005;

        if (this.y > H || this.life <= 0 || this.y < H * 0.1) {
            this.reset();
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;

        if (this.type === 0) {
            ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        } else if (this.type === 1) {
            ctx.fillRect(-this.size, -1, this.size * 2, 2);
        } else {
            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(-this.size, this.size);
            ctx.lineTo(this.size, this.size);
            ctx.closePath();
            ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }
}

function initParticles(count) {
    while (particles.length < count) {
        particles.push(new TornadoParticle());
    }
    while (particles.length > count) {
        particles.pop();
    }
}

for (let i = 0; i < MAX_DEBRIS; i++) {
    debris.push(new Debris());
}

function drawBackground(windSpeed) {
    // Storm sky
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    const darkness = Math.min(1, windSpeed / 4);
    grad.addColorStop(0, `rgba(${15 - darkness * 10}, ${20 - darkness * 10}, ${30 - darkness * 10}, 1)`);
    grad.addColorStop(0.3, `rgba(${25 - darkness * 10}, ${30 - darkness * 10}, ${40 - darkness * 10}, 1)`);
    grad.addColorStop(0.7, `rgba(${30}, ${35 - darkness * 5}, ${35}, 1)`);
    grad.addColorStop(1, `rgba(40, 35, 25, 1)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Ground
    const groundGrad = ctx.createLinearGradient(0, H * 0.83, 0, H);
    groundGrad.addColorStop(0, '#3a3520');
    groundGrad.addColorStop(0.3, '#2a2515');
    groundGrad.addColorStop(1, '#1a1a10');
    ctx.fillStyle = groundGrad;
    ctx.fillRect(0, H * 0.85, W, H * 0.15);

    // Dust cloud at base
    const dustAlpha = 0.1 + windSpeed * 0.05;
    const dustGrad = ctx.createRadialGradient(cx, H * 0.85, 10, cx, H * 0.85, 200 * windSpeed * 0.5);
    dustGrad.addColorStop(0, `rgba(120, 100, 70, ${dustAlpha})`);
    dustGrad.addColorStop(0.5, `rgba(100, 80, 50, ${dustAlpha * 0.5})`);
    dustGrad.addColorStop(1, 'rgba(80, 60, 30, 0)');
    ctx.fillStyle = dustGrad;
    ctx.fillRect(cx - 300, H * 0.75, 600, H * 0.2);

    // Storm clouds at top
    drawStormClouds(windSpeed);
}

function drawStormClouds(windSpeed) {
    const time = Date.now() * 0.0003;
    const cloudY = H * 0.12;

    for (let i = 0; i < 8; i++) {
        const x = cx + Math.sin(time + i * 0.8) * 200 + (i - 4) * 80;
        const y = cloudY + Math.cos(time * 0.7 + i) * 15;
        const r = 60 + Math.sin(i * 1.3) * 30;
        ctx.fillStyle = `rgba(30, 35, 40, 0.5)`;
        ctx.beginPath();
        ctx.ellipse(x, y, r, r * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Mesocyclone rotation indicator
    ctx.strokeStyle = 'rgba(60, 70, 80, 0.15)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cloudY, 80, time, time + Math.PI * 1.5);
    ctx.stroke();
}

function drawFunnelOutline(windSpeed, funnelWidth) {
    const groundY = H * 0.85;
    const topY = H * 0.15;
    const time = Date.now() * 0.002;

    // Funnel silhouette
    ctx.strokeStyle = 'rgba(100, 90, 80, 0.1)';
    ctx.lineWidth = 2;

    for (let side = -1; side <= 1; side += 2) {
        ctx.beginPath();
        for (let y = topY; y <= groundY; y += 3) {
            const frac = (y - topY) / (groundY - topY);
            const baseR = 80 * funnelWidth;
            const topR = 15 * funnelWidth;
            const r = topR + (baseR - topR) * Math.pow(frac, 0.7);
            const wobble = Math.sin(y * 0.02 + time) * 5 * windSpeed * 0.3;
            const x = cx + side * (r + wobble);
            if (y === topY) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
}

let time = 0;

function animate() {
    const windSpeed = parseFloat(document.getElementById('windSlider').value);
    const density = parseInt(document.getElementById('densitySlider').value);
    const funnelWidth = parseFloat(document.getElementById('widthSlider').value);
    document.getElementById('windVal').textContent = windSpeed.toFixed(1);
    document.getElementById('densityVal').textContent = density;
    document.getElementById('widthVal').textContent = funnelWidth.toFixed(1);

    initParticles(density);

    drawBackground(windSpeed);
    drawFunnelOutline(windSpeed, funnelWidth);

    // Update and draw particles
    for (const p of particles) {
        p.update(windSpeed, funnelWidth);
        p.draw();
    }

    // Update and draw debris
    for (const d of debris) {
        d.update(windSpeed);
        d.draw();
    }

    // Lightning flash (rare)
    if (Math.random() < 0.002 * windSpeed) {
        ctx.fillStyle = 'rgba(200, 210, 255, 0.05)';
        ctx.fillRect(0, 0, W, H);
    }

    // Info
    const mph = Math.floor(windSpeed * 65);
    document.getElementById('maxWind').textContent = mph;
    document.getElementById('pCount').textContent = particles.length + debris.length;

    let ef = 'EF0';
    if (mph > 200) ef = 'EF5';
    else if (mph > 165) ef = 'EF4';
    else if (mph > 136) ef = 'EF3';
    else if (mph > 111) ef = 'EF2';
    else if (mph > 86) ef = 'EF1';
    document.getElementById('efScale').textContent = ef;

    time += 0.016;
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
