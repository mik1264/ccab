<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fingerprint Ridge Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 260px; max-width: 300px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        select {
            width: 100%; background: #1a2035; color: #c8d0e0; border: 1px solid rgba(138,154,91,0.3);
            padding: 6px 8px; border-radius: 6px; font-size: 12px; outline: none;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Fingerprint Ridges</h2>
        <p class="desc">Generate fingerprint-like patterns using an orientation field with singularities. Ridges form perpendicular to the local flow direction, creating whorls, loops, and arches.</p>
        <div class="control-row">
            <label>Pattern Type</label>
            <select id="patternType">
                <option value="whorl">Whorl</option>
                <option value="loop">Loop</option>
                <option value="arch">Arch</option>
            </select>
        </div>
        <div class="control-row">
            <label>Ridge Frequency <span id="freqVal">12.0</span></label>
            <input type="range" id="frequency" min="6.0" max="25.0" step="0.5" value="12.0">
        </div>
        <div class="control-row">
            <label>Noise <span id="noiseVal">0.15</span></label>
            <input type="range" id="noise" min="0.0" max="0.5" step="0.01" value="0.15">
        </div>
        <div class="control-row">
            <label>Rotation <span id="rotVal">0</span>&deg;</label>
            <input type="range" id="rotation" min="0" max="360" step="5" value="0">
        </div>
        <div class="control-row">
            <label>Style</label>
            <select id="colorMode">
                <option value="ink">Ink on Paper</option>
                <option value="inverted">Inverted (Light Ridges)</option>
                <option value="forensic">Forensic Green</option>
            </select>
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">Reset</button>
            <button class="btn" onclick="regenerate()">Regenerate</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            generate();
        }

        // Parameters
        let patternType = 'whorl';
        let frequency = 12.0;
        let noiseAmount = 0.15;
        let rotation = 0;
        let colorMode = 'ink';

        // Noise function (simple value noise)
        const NOISE_SIZE = 256;
        let noiseTable = new Float32Array(NOISE_SIZE * NOISE_SIZE);

        function initNoise() {
            for (let i = 0; i < NOISE_SIZE * NOISE_SIZE; i++) {
                noiseTable[i] = Math.random();
            }
        }

        function smoothNoise(x, y) {
            const ix = Math.floor(x) & (NOISE_SIZE - 1);
            const iy = Math.floor(y) & (NOISE_SIZE - 1);
            const fx = x - Math.floor(x);
            const fy = y - Math.floor(y);

            const ix1 = (ix + 1) & (NOISE_SIZE - 1);
            const iy1 = (iy + 1) & (NOISE_SIZE - 1);

            // Smoothstep
            const sx = fx * fx * (3 - 2 * fx);
            const sy = fy * fy * (3 - 2 * fy);

            const v00 = noiseTable[iy * NOISE_SIZE + ix];
            const v10 = noiseTable[iy * NOISE_SIZE + ix1];
            const v01 = noiseTable[iy1 * NOISE_SIZE + ix];
            const v11 = noiseTable[iy1 * NOISE_SIZE + ix1];

            const a = v00 + sx * (v10 - v00);
            const b = v01 + sx * (v11 - v01);
            return a + sy * (b - a);
        }

        function fbmNoise(x, y, octaves) {
            let val = 0, amp = 1, freq = 1, totalAmp = 0;
            for (let i = 0; i < octaves; i++) {
                val += smoothNoise(x * freq, y * freq) * amp;
                totalAmp += amp;
                amp *= 0.5;
                freq *= 2;
            }
            return val / totalAmp;
        }

        // Orientation field for different fingerprint types
        function getOrientation(nx, ny) {
            // nx, ny in [-1, 1] range from center
            // Apply rotation
            const rad = rotation * Math.PI / 180;
            const rx = nx * Math.cos(rad) - ny * Math.sin(rad);
            const ry = nx * Math.sin(rad) + ny * Math.cos(rad);

            let angle;

            if (patternType === 'whorl') {
                // Whorl: circular pattern around a center point
                // Two singularities close together create a whorl
                const cx1 = 0.0, cy1 = -0.05;
                const dx1 = rx - cx1, dy1 = ry - cy1;
                const a1 = Math.atan2(dy1, dx1);

                // Add a second singularity for more complexity
                const cx2 = 0.0, cy2 = 0.05;
                const dx2 = rx - cx2, dy2 = ry - cy2;
                const a2 = Math.atan2(dy2, dx2);

                // Combine: whorl is (a1 + a2) / 2 shifted
                angle = (a1 + a2) / 2 + Math.PI / 2;

                // Add radial influence to create concentric-like ridges near center
                const dist = Math.sqrt(rx * rx + ry * ry);
                if (dist < 0.3) {
                    const blend = dist / 0.3;
                    const circularAngle = Math.atan2(ry, rx) + Math.PI / 2;
                    angle = circularAngle * (1 - blend) + angle * blend;
                }
            } else if (patternType === 'loop') {
                // Loop: one delta point, ridges curve around a core
                const cx = 0.0, cy = 0.0;
                const dx = rx - cx, dy = ry - cy;
                const a = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Horizontal baseline field
                const baseAngle = 0;

                // Delta singularity below the core
                const dcx = 0.0, dcy = 0.35;
                const ddx = rx - dcx, ddy = ry - dcy;
                const deltaAngle = Math.atan2(ddy, ddx);

                // Blend: near center = looping, far = horizontal
                const blend = Math.min(1, dist / 0.6);
                const loopAngle = a + Math.PI / 2;

                // Above center: ridges curve around
                if (ry < 0.1) {
                    angle = loopAngle * (1 - blend * 0.7) + baseAngle * blend * 0.7;
                } else {
                    // Below: influenced by delta
                    angle = deltaAngle * 0.5 + baseAngle * 0.5;
                }
            } else {
                // Arch: smooth, no singularities
                // Ridges follow parabolic arches
                const archHeight = 0.4;
                const curvature = 2.5;

                // Direction perpendicular to parabola y = archHeight - curvature * x^2
                // Tangent to parabola: dy/dx = -2*curvature*x
                const tangentSlope = -2 * curvature * rx;
                angle = Math.atan2(1, tangentSlope);

                // Vertical stretch near the sides
                const sideBlend = Math.abs(rx);
                if (sideBlend > 0.5) {
                    const vertAngle = Math.PI / 2;
                    const f = (sideBlend - 0.5) / 0.5;
                    angle = angle * (1 - f) + vertAngle * f;
                }
            }

            // Add noise perturbation
            if (noiseAmount > 0) {
                const nv = fbmNoise((rx + 1) * 8, (ry + 1) * 8, 3);
                angle += (nv - 0.5) * noiseAmount * Math.PI;
            }

            return angle;
        }

        function generate() {
            if (!W || !H) return;

            const imageData = ctx.createImageData(W, H);
            const data = imageData.data;

            const cx = W / 2;
            const cy = H / 2;
            const scale = Math.min(W, H) * 0.45;

            // Precompute orientation field at a lower resolution, then interpolate
            const fieldRes = 4;
            const fieldW = Math.ceil(W / fieldRes);
            const fieldH = Math.ceil(H / fieldRes);
            const orientField = new Float32Array(fieldW * fieldH);

            for (let fy = 0; fy < fieldH; fy++) {
                for (let fx = 0; fx < fieldW; fx++) {
                    const px = fx * fieldRes + fieldRes / 2;
                    const py = fy * fieldRes + fieldRes / 2;
                    const nx = (px - cx) / scale;
                    const ny = (py - cy) / scale;
                    orientField[fy * fieldW + fx] = getOrientation(nx, ny);
                }
            }

            // For each pixel, compute ridge value using the orientation field
            for (let py = 0; py < H; py++) {
                for (let px = 0; px < W; px++) {
                    const nx = (px - cx) / scale;
                    const ny = (py - cy) / scale;

                    // Distance from center (for fingerprint oval boundary)
                    const dist = Math.sqrt(nx * nx * 0.8 + ny * ny * 1.2);

                    // Only render within fingerprint shape (oval)
                    if (dist > 1.05) {
                        // Background
                        setPixel(data, px, py, W, getBgColor());
                        continue;
                    }

                    // Get orientation by bilinear interpolation of the field
                    const fx = px / fieldRes;
                    const fy = py / fieldRes;
                    const fix = Math.floor(fx);
                    const fiy = Math.floor(fy);
                    const ffx = fx - fix;
                    const ffy = fy - fiy;

                    const fix1 = Math.min(fix + 1, fieldW - 1);
                    const fiy1 = Math.min(fiy + 1, fieldH - 1);
                    const fic = Math.max(0, Math.min(fix, fieldW - 1));
                    const fir = Math.max(0, Math.min(fiy, fieldH - 1));

                    // Use vector interpolation (cos/sin) to avoid angle wrapping issues
                    const a00 = orientField[fir * fieldW + fic];
                    const a10 = orientField[fir * fieldW + fix1];
                    const a01 = orientField[fiy1 * fieldW + fic];
                    const a11 = orientField[fiy1 * fieldW + fix1];

                    const cx00 = Math.cos(2 * a00), sx00 = Math.sin(2 * a00);
                    const cx10 = Math.cos(2 * a10), sx10 = Math.sin(2 * a10);
                    const cx01 = Math.cos(2 * a01), sx01 = Math.sin(2 * a01);
                    const cx11 = Math.cos(2 * a11), sx11 = Math.sin(2 * a11);

                    const ic = cx00 * (1 - ffx) * (1 - ffy) + cx10 * ffx * (1 - ffy) +
                               cx01 * (1 - ffx) * ffy + cx11 * ffx * ffy;
                    const is = sx00 * (1 - ffx) * (1 - ffy) + sx10 * ffx * (1 - ffy) +
                               sx01 * (1 - ffx) * ffy + sx11 * ffx * ffy;

                    const angle = Math.atan2(is, ic) / 2;

                    // Perpendicular direction
                    const perpX = -Math.sin(angle);
                    const perpY = Math.cos(angle);

                    // Compute phase along perpendicular direction
                    const phase = (px * perpX + py * perpY) * frequency / scale * 0.15;

                    // Add subtle noise to ridge phase for naturalness
                    const noisePhase = noiseAmount > 0 ? fbmNoise(px * 0.02, py * 0.02, 2) * noiseAmount * 3 : 0;

                    // Ridge value: cosine creates ridges and valleys
                    let ridgeVal = Math.cos((phase + noisePhase) * Math.PI * 2);

                    // Sharpen ridges slightly (more like real fingerprints)
                    ridgeVal = ridgeVal > 0 ? Math.pow(ridgeVal, 0.6) : -Math.pow(-ridgeVal, 0.6);

                    // Map to 0-1 (0 = valley, 1 = ridge)
                    ridgeVal = (ridgeVal + 1) * 0.5;

                    // Fade at edges of fingerprint
                    if (dist > 0.85) {
                        const fade = 1 - (dist - 0.85) / 0.2;
                        ridgeVal = ridgeVal * fade + (1 - fade) * 0.5;
                    }

                    // Apply color based on mode
                    const color = getRidgeColor(ridgeVal);
                    setPixel(data, px, py, W, color);
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw subtle oval border
            ctx.strokeStyle = colorMode === 'inverted' ? 'rgba(40,40,40,0.3)' : 'rgba(200,200,200,0.15)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(cx, cy, scale * 1.12, scale * 0.92, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        function setPixel(data, x, y, w, color) {
            const offset = (y * w + x) * 4;
            data[offset] = color[0];
            data[offset + 1] = color[1];
            data[offset + 2] = color[2];
            data[offset + 3] = 255;
        }

        function getBgColor() {
            if (colorMode === 'ink') return [240, 230, 215];
            if (colorMode === 'inverted') return [15, 15, 20];
            return [10, 20, 15];
        }

        function getRidgeColor(val) {
            if (colorMode === 'ink') {
                // Dark ridges on light paper
                const ridge = Math.floor(val * 200 + 30);
                return [ridge, ridge - 5, ridge - 10];
            } else if (colorMode === 'inverted') {
                // Light ridges on dark background
                const ridge = Math.floor(val * 220 + 20);
                return [ridge, ridge, ridge + 10];
            } else {
                // Forensic green
                const ridge = Math.floor(val * 180 + 20);
                return [Math.floor(ridge * 0.3), ridge, Math.floor(ridge * 0.5)];
            }
        }

        function regenerate() {
            initNoise();
            generate();
        }

        window.reset = function() {
            patternType = 'whorl';
            frequency = 12.0;
            noiseAmount = 0.15;
            rotation = 0;
            colorMode = 'ink';
            document.getElementById('patternType').value = 'whorl';
            document.getElementById('frequency').value = 12.0;
            document.getElementById('noise').value = 0.15;
            document.getElementById('rotation').value = 0;
            document.getElementById('colorMode').value = 'ink';
            document.getElementById('freqVal').textContent = '12.0';
            document.getElementById('noiseVal').textContent = '0.15';
            document.getElementById('rotVal').textContent = '0';
            initNoise();
            generate();
        };

        // Controls
        document.getElementById('patternType').addEventListener('change', function() {
            patternType = this.value;
            generate();
        });
        document.getElementById('frequency').addEventListener('input', function() {
            frequency = parseFloat(this.value);
            document.getElementById('freqVal').textContent = frequency.toFixed(1);
            generate();
        });
        document.getElementById('noise').addEventListener('input', function() {
            noiseAmount = parseFloat(this.value);
            document.getElementById('noiseVal').textContent = noiseAmount.toFixed(2);
            generate();
        });
        document.getElementById('rotation').addEventListener('input', function() {
            rotation = parseInt(this.value);
            document.getElementById('rotVal').textContent = rotation;
            generate();
        });
        document.getElementById('colorMode').addEventListener('change', function() {
            colorMode = this.value;
            generate();
        });

        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        window.addEventListener('resize', function() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            generate();
        });

        initNoise();
        generate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>