<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giraffe Voronoi Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 260px; max-width: 300px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        select {
            width: 100%; background: #1a2035; color: #c8d0e0; border: 1px solid rgba(138,154,91,0.3);
            padding: 6px 8px; border-radius: 6px; font-size: 12px; outline: none;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Giraffe Voronoi Patterns</h2>
        <p class="desc">Voronoi tessellation models giraffe coat patterns. Each cell grows from a seed point; borders form where cells meet. Click to add new cells.</p>
        <div class="control-row">
            <label>Preset</label>
            <select id="preset">
                <option value="giraffe">Giraffe</option>
                <option value="snake">Snake Scales</option>
                <option value="turtle">Turtle Shell</option>
            </select>
        </div>
        <div class="control-row">
            <label>Cells <span id="cellsVal">200</span></label>
            <input type="range" id="numCells" min="50" max="500" step="10" value="200">
        </div>
        <div class="control-row">
            <label>Border Width <span id="borderVal">3.0</span></label>
            <input type="range" id="borderWidth" min="1.0" max="8.0" step="0.5" value="3.0">
        </div>
        <div class="control-row">
            <label>Irregularity <span id="irregVal">0.5</span></label>
            <input type="range" id="irregularity" min="0.0" max="1.0" step="0.05" value="0.5">
        </div>
        <div class="control-row">
            <label>Animation Speed <span id="speedVal">1.0</span></label>
            <input type="range" id="animSpeed" min="0.0" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">Reset</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;

        // Render at lower resolution for performance
        const SCALE = 2; // render at 1/2 resolution

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            canvas.width = Math.floor(W / SCALE);
            canvas.height = Math.floor(H / SCALE);
        }
        resize();
        window.addEventListener('resize', function() {
            resize();
        });

        // Seed points
        let seeds = [];
        let seedColors = [];
        let seedVelocities = [];
        let numCells = 200;
        let borderWidth = 3.0;
        let irregularity = 0.5;
        let animSpeed = 1.0;
        let currentPreset = 'giraffe';

        const presets = {
            giraffe: {
                cellColors: function() {
                    // Random browns
                    const browns = [
                        [139, 90, 43], [160, 100, 50], [130, 75, 35],
                        [150, 95, 45], [120, 70, 30], [170, 110, 55],
                        [145, 85, 40], [155, 105, 48], [125, 78, 38],
                        [165, 108, 52]
                    ];
                    return browns[Math.floor(Math.random() * browns.length)];
                },
                borderColor: [245, 230, 200],
                bgColor: [245, 230, 200]
            },
            snake: {
                cellColors: function() {
                    const greens = [
                        [45, 60, 30], [55, 70, 35], [40, 55, 28],
                        [50, 65, 32], [60, 75, 38], [35, 50, 25],
                        [65, 80, 40], [48, 62, 30], [52, 68, 34]
                    ];
                    return greens[Math.floor(Math.random() * greens.length)];
                },
                borderColor: [20, 25, 12],
                bgColor: [20, 25, 12]
            },
            turtle: {
                cellColors: function() {
                    const olives = [
                        [85, 100, 50], [95, 110, 55], [80, 95, 48],
                        [90, 105, 52], [75, 90, 45], [100, 115, 58],
                        [88, 102, 50], [92, 108, 54]
                    ];
                    return olives[Math.floor(Math.random() * olives.length)];
                },
                borderColor: [50, 60, 30],
                bgColor: [50, 60, 30]
            }
        };

        function generateSeeds(n) {
            seeds = [];
            seedColors = [];
            seedVelocities = [];
            const preset = presets[currentPreset];
            const cw = canvas.width, ch = canvas.height;

            // Use relaxation for more even distribution
            for (let i = 0; i < n; i++) {
                seeds.push([
                    Math.random() * cw,
                    Math.random() * ch
                ]);
                seedColors.push(preset.cellColors());
                const angle = Math.random() * Math.PI * 2;
                const speed = (0.2 + Math.random() * 0.5) * (1 - irregularity * 0.5);
                seedVelocities.push([
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                ]);
            }

            // Lloyd relaxation for better spacing (a few iterations)
            for (let iter = 0; iter < 3; iter++) {
                relaxSeeds();
            }
        }

        function relaxSeeds() {
            // Approximate Lloyd relaxation by pushing seeds apart
            const cw = canvas.width, ch = canvas.height;
            const idealDist = Math.sqrt((cw * ch) / seeds.length) * 0.8;

            for (let i = 0; i < seeds.length; i++) {
                let fx = 0, fy = 0;
                for (let j = 0; j < seeds.length; j++) {
                    if (i === j) continue;
                    let dx = seeds[i][0] - seeds[j][0];
                    let dy = seeds[i][1] - seeds[j][1];
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < idealDist && dist > 0.1) {
                        const force = (idealDist - dist) / idealDist * 0.3;
                        fx += (dx / dist) * force * idealDist;
                        fy += (dy / dist) * force * idealDist;
                    }
                }
                seeds[i][0] = Math.max(0, Math.min(cw, seeds[i][0] + fx));
                seeds[i][1] = Math.max(0, Math.min(ch, seeds[i][1] + fy));
            }
        }

        function updateSeeds() {
            const cw = canvas.width, ch = canvas.height;
            for (let i = 0; i < seeds.length; i++) {
                seeds[i][0] += seedVelocities[i][0] * animSpeed;
                seeds[i][1] += seedVelocities[i][1] * animSpeed;

                // Wrap around edges
                if (seeds[i][0] < -10) seeds[i][0] += cw + 20;
                if (seeds[i][0] > cw + 10) seeds[i][0] -= cw + 20;
                if (seeds[i][1] < -10) seeds[i][1] += ch + 20;
                if (seeds[i][1] > ch + 10) seeds[i][1] -= ch + 20;

                // Add slight random drift
                seedVelocities[i][0] += (Math.random() - 0.5) * 0.02;
                seedVelocities[i][1] += (Math.random() - 0.5) * 0.02;

                // Dampen
                seedVelocities[i][0] *= 0.999;
                seedVelocities[i][1] *= 0.999;

                // Keep speed reasonable
                const spd = Math.sqrt(seedVelocities[i][0] ** 2 + seedVelocities[i][1] ** 2);
                if (spd > 1.5) {
                    seedVelocities[i][0] *= 1.5 / spd;
                    seedVelocities[i][1] *= 1.5 / spd;
                }
            }
        }

        function renderVoronoi() {
            const cw = canvas.width, ch = canvas.height;
            const imageData = ctx.createImageData(cw, ch);
            const data = imageData.data;
            const preset = presets[currentPreset];
            const borderCol = preset.borderColor;

            // Scaled border threshold
            const borderThreshold = borderWidth / SCALE;

            // Build a grid for acceleration
            const gridSize = Math.max(10, Math.floor(Math.sqrt(cw * ch / seeds.length) * 0.5));
            const gridCols = Math.ceil(cw / gridSize);
            const gridRows = Math.ceil(ch / gridSize);
            const grid = new Array(gridCols * gridRows);
            for (let i = 0; i < grid.length; i++) grid[i] = [];

            for (let i = 0; i < seeds.length; i++) {
                const gc = Math.floor(seeds[i][0] / gridSize);
                const gr = Math.floor(seeds[i][1] / gridSize);
                if (gc >= 0 && gc < gridCols && gr >= 0 && gr < gridRows) {
                    grid[gr * gridCols + gc].push(i);
                }
            }

            for (let py = 0; py < ch; py++) {
                for (let px = 0; px < cw; px++) {
                    let minDist = Infinity, minIdx = 0;
                    let secondDist = Infinity;

                    // Check surrounding grid cells
                    const gc = Math.floor(px / gridSize);
                    const gr = Math.floor(py / gridSize);
                    const searchRadius = 3;

                    for (let dgy = -searchRadius; dgy <= searchRadius; dgy++) {
                        for (let dgx = -searchRadius; dgx <= searchRadius; dgx++) {
                            const ngc = gc + dgx, ngr = gr + dgy;
                            if (ngc < 0 || ngc >= gridCols || ngr < 0 || ngr >= gridRows) continue;
                            const cell = grid[ngr * gridCols + ngc];
                            for (let k = 0; k < cell.length; k++) {
                                const i = cell[k];
                                const dx = px - seeds[i][0];
                                const dy = py - seeds[i][1];
                                const d = dx * dx + dy * dy;
                                if (d < minDist) {
                                    secondDist = minDist;
                                    minDist = d;
                                    minIdx = i;
                                } else if (d < secondDist) {
                                    secondDist = d;
                                }
                            }
                        }
                    }

                    // If grid search didn't find enough, brute force nearest 2
                    if (secondDist === Infinity) {
                        minDist = Infinity;
                        secondDist = Infinity;
                        for (let i = 0; i < seeds.length; i++) {
                            const dx = px - seeds[i][0];
                            const dy = py - seeds[i][1];
                            const d = dx * dx + dy * dy;
                            if (d < minDist) {
                                secondDist = minDist;
                                minDist = d;
                                minIdx = i;
                            } else if (d < secondDist) {
                                secondDist = d;
                            }
                        }
                    }

                    const d1 = Math.sqrt(minDist);
                    const d2 = Math.sqrt(secondDist);
                    const borderDist = d2 - d1;

                    const offset = (py * cw + px) * 4;

                    if (borderDist < borderThreshold) {
                        // Border pixel - blend
                        const t = borderDist / borderThreshold;
                        const col = seedColors[minIdx];
                        data[offset] = Math.floor(borderCol[0] * (1 - t) + col[0] * t);
                        data[offset + 1] = Math.floor(borderCol[1] * (1 - t) + col[1] * t);
                        data[offset + 2] = Math.floor(borderCol[2] * (1 - t) + col[2] * t);
                    } else {
                        // Cell interior
                        const col = seedColors[minIdx];
                        data[offset] = col[0];
                        data[offset + 1] = col[1];
                        data[offset + 2] = col[2];
                    }
                    data[offset + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        let running = true;

        function animate() {
            if (running) {
                updateSeeds();
            }
            renderVoronoi();
            requestAnimationFrame(animate);
        }

        // Click to add seeds
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / SCALE;
            const y = (e.clientY - rect.top) / SCALE;
            const preset = presets[currentPreset];
            seeds.push([x, y]);
            seedColors.push(preset.cellColors());
            const angle = Math.random() * Math.PI * 2;
            seedVelocities.push([Math.cos(angle) * 0.3, Math.sin(angle) * 0.3]);
            numCells = seeds.length;
            document.getElementById('cellsVal').textContent = numCells;
        });

        window.reset = function() {
            running = true;
            numCells = 200;
            borderWidth = 3.0;
            irregularity = 0.5;
            animSpeed = 1.0;
            currentPreset = 'giraffe';
            document.getElementById('numCells').value = 200;
            document.getElementById('borderWidth').value = 3.0;
            document.getElementById('irregularity').value = 0.5;
            document.getElementById('animSpeed').value = 1.0;
            document.getElementById('preset').value = 'giraffe';
            document.getElementById('cellsVal').textContent = '200';
            document.getElementById('borderVal').textContent = '3.0';
            document.getElementById('irregVal').textContent = '0.5';
            document.getElementById('speedVal').textContent = '1.0';
            generateSeeds(numCells);
        };

        // Wire up controls
        document.getElementById('numCells').addEventListener('input', function() {
            numCells = parseInt(this.value);
            document.getElementById('cellsVal').textContent = numCells;
            generateSeeds(numCells);
        });
        document.getElementById('borderWidth').addEventListener('input', function() {
            borderWidth = parseFloat(this.value);
            document.getElementById('borderVal').textContent = borderWidth.toFixed(1);
        });
        document.getElementById('irregularity').addEventListener('input', function() {
            irregularity = parseFloat(this.value);
            document.getElementById('irregVal').textContent = irregularity.toFixed(2);
        });
        document.getElementById('animSpeed').addEventListener('input', function() {
            animSpeed = parseFloat(this.value);
            document.getElementById('speedVal').textContent = animSpeed.toFixed(1);
        });
        document.getElementById('preset').addEventListener('change', function() {
            currentPreset = this.value;
            generateSeeds(numCells);
        });

        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space') { e.preventDefault(); running = !running; }
        });

        generateSeeds(numCells);
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>