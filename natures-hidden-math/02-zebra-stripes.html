<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zebra Stripes - Reaction-Diffusion Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 270px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn.active { background: rgba(138,154,91,0.5); border-color: #8A9A5B; }
        .btn-row { display: flex; gap: 6px; margin-top: 8px; flex-wrap: wrap; }
        .section-label { font-size: 11px; color: #667; margin-top: 10px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Zebra Stripes</h2>
        <p class="desc">Same Gray-Scott model with stripe-producing parameters. Labyrinths and stripe patterns emerge from chemical interactions. Click to perturb.</p>
        <div class="control-row">
            <label>Feed rate (F) <span id="fVal">0.040</span></label>
            <input type="range" id="feedRate" min="0.01" max="0.08" step="0.001" value="0.040">
        </div>
        <div class="control-row">
            <label>Kill rate (k) <span id="kVal">0.060</span></label>
            <input type="range" id="killRate" min="0.03" max="0.08" step="0.001" value="0.060">
        </div>
        <div class="control-row">
            <label>Steps/frame <span id="stepsVal">12</span></label>
            <input type="range" id="stepsPerFrame" min="1" max="30" step="1" value="12">
        </div>
        <div class="section-label">Presets</div>
        <div class="btn-row">
            <button class="btn" id="presetSpots">Spots</button>
            <button class="btn active" id="presetStripes">Stripes</button>
            <button class="btn" id="presetMaze">Maze</button>
            <button class="btn" id="presetMitosis">Mitosis</button>
        </div>
        <div class="section-label">Color Scheme</div>
        <div class="btn-row">
            <button class="btn active" id="colorCool">Cool</button>
            <button class="btn" id="colorWarm">Warm</button>
            <button class="btn" id="colorMono">Mono</button>
            <button class="btn" id="colorNeon">Neon</button>
        </div>
        <div class="btn-row" style="margin-top: 12px;">
            <button class="btn" onclick="window.reset()">Reset</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const SIM_W = 256;
        const SIM_H = 256;

        let F = 0.040;
        let k = 0.060;
        const Du = 0.16;
        const Dv = 0.08;
        let stepsPerFrame = 12;
        const dt = 1.0;
        let colorScheme = 'cool';

        let U0 = new Float32Array(SIM_W * SIM_H);
        let V0 = new Float32Array(SIM_W * SIM_H);
        let U1 = new Float32Array(SIM_W * SIM_H);
        let V1 = new Float32Array(SIM_W * SIM_H);

        let imageData;

        function initGrid() {
            for (let i = 0; i < SIM_W * SIM_H; i++) {
                U0[i] = 1.0;
                V0[i] = 0.0;
            }
            // Seed several regions
            const numSeeds = 15;
            for (let s = 0; s < numSeeds; s++) {
                const cx = Math.floor(Math.random() * (SIM_W - 20)) + 10;
                const cy = Math.floor(Math.random() * (SIM_H - 20)) + 10;
                const size = Math.floor(Math.random() * 5) + 3;
                for (let dy = -size; dy <= size; dy++) {
                    for (let dx = -size; dx <= size; dx++) {
                        const x = cx + dx;
                        const y = cy + dy;
                        if (x >= 0 && x < SIM_W && y >= 0 && y < SIM_H) {
                            const idx = y * SIM_W + x;
                            U0[idx] = 0.5 + Math.random() * 0.1;
                            V0[idx] = 0.25 + Math.random() * 0.1;
                        }
                    }
                }
            }
        }

        function simulationStep() {
            for (let y = 0; y < SIM_H; y++) {
                for (let x = 0; x < SIM_W; x++) {
                    const idx = y * SIM_W + x;
                    const xm = ((x - 1) + SIM_W) % SIM_W;
                    const xp = (x + 1) % SIM_W;
                    const ym = ((y - 1) + SIM_H) % SIM_H;
                    const yp = (y + 1) % SIM_H;

                    const lapU = U0[ym * SIM_W + x] + U0[yp * SIM_W + x]
                               + U0[y * SIM_W + xm] + U0[y * SIM_W + xp]
                               - 4.0 * U0[idx];
                    const lapV = V0[ym * SIM_W + x] + V0[yp * SIM_W + x]
                               + V0[y * SIM_W + xm] + V0[y * SIM_W + xp]
                               - 4.0 * V0[idx];

                    const u = U0[idx];
                    const v = V0[idx];
                    const uvv = u * v * v;

                    U1[idx] = u + dt * (Du * lapU - uvv + F * (1.0 - u));
                    V1[idx] = v + dt * (Dv * lapV + uvv - (F + k) * v);

                    if (U1[idx] < 0) U1[idx] = 0;
                    if (U1[idx] > 1) U1[idx] = 1;
                    if (V1[idx] < 0) V1[idx] = 0;
                    if (V1[idx] > 1) V1[idx] = 1;
                }
            }
            const tmpU = U0; U0 = U1; U1 = tmpU;
            const tmpV = V0; V0 = V1; V1 = tmpV;
        }

        const colorFunctions = {
            cool: function(v) {
                const t = Math.min(v * 3.0, 1.0);
                return [
                    Math.floor(8 + t * 40),
                    Math.floor(12 + t * 80),
                    Math.floor(30 + t * 225),
                ];
            },
            warm: function(v) {
                const t = Math.min(v * 3.0, 1.0);
                return [
                    Math.floor(15 + t * 240),
                    Math.floor(8 + t * 140),
                    Math.floor(5 + t * 30),
                ];
            },
            mono: function(v) {
                const t = Math.min(v * 3.0, 1.0);
                const c = Math.floor(10 + t * 245);
                return [c, c, c];
            },
            neon: function(v) {
                const t = Math.min(v * 3.0, 1.0);
                if (t < 0.5) {
                    const s = t / 0.5;
                    return [Math.floor(s * 20), Math.floor(s * 255), Math.floor(80 + s * 100)];
                } else {
                    const s = (t - 0.5) / 0.5;
                    return [Math.floor(20 + s * 200), Math.floor(255 - s * 100), Math.floor(180 - s * 100)];
                }
            }
        };

        function render() {
            if (!imageData || imageData.width !== SIM_W || imageData.height !== SIM_H) {
                imageData = ctx.createImageData(SIM_W, SIM_H);
            }
            const data = imageData.data;
            const colorFn = colorFunctions[colorScheme] || colorFunctions.cool;
            for (let i = 0; i < SIM_W * SIM_H; i++) {
                const [r, g, b] = colorFn(V0[i]);
                const p = i * 4;
                data[p] = r;
                data[p + 1] = g;
                data[p + 2] = b;
                data[p + 3] = 255;
            }
            ctx.imageSmoothingEnabled = false;
            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = SIM_W;
            tmpCanvas.height = SIM_H;
            tmpCanvas.getContext('2d').putImageData(imageData, 0, 0);
            ctx.drawImage(tmpCanvas, 0, 0, canvas.width, canvas.height);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Interaction
        function addChemical(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mx = (clientX - rect.left) / rect.width;
            const my = (clientY - rect.top) / rect.height;
            const gx = Math.floor(mx * SIM_W);
            const gy = Math.floor(my * SIM_H);
            const radius = 5;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy > radius * radius) continue;
                    const x = ((gx + dx) + SIM_W) % SIM_W;
                    const y = ((gy + dy) + SIM_H) % SIM_H;
                    const idx = y * SIM_W + x;
                    U0[idx] = 0.5;
                    V0[idx] = 0.5;
                }
            }
        }

        let isMouseDown = false;
        canvas.addEventListener('mousedown', (e) => { isMouseDown = true; addChemical(e.clientX, e.clientY); });
        canvas.addEventListener('mousemove', (e) => { if (isMouseDown) addChemical(e.clientX, e.clientY); });
        window.addEventListener('mouseup', () => { isMouseDown = false; });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); addChemical(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); addChemical(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

        // Controls
        const feedSlider = document.getElementById('feedRate');
        const killSlider = document.getElementById('killRate');
        const stepsSlider = document.getElementById('stepsPerFrame');
        const fValEl = document.getElementById('fVal');
        const kValEl = document.getElementById('kVal');
        const stepsValEl = document.getElementById('stepsVal');

        feedSlider.addEventListener('input', () => { F = parseFloat(feedSlider.value); fValEl.textContent = F.toFixed(3); });
        killSlider.addEventListener('input', () => { k = parseFloat(killSlider.value); kValEl.textContent = k.toFixed(3); });
        stepsSlider.addEventListener('input', () => { stepsPerFrame = parseInt(stepsSlider.value); stepsValEl.textContent = stepsPerFrame; });

        // Presets
        function setPreset(name) {
            const presets = {
                spots:   { F: 0.035, k: 0.065 },
                stripes: { F: 0.040, k: 0.060 },
                maze:    { F: 0.029, k: 0.057 },
                mitosis: { F: 0.028, k: 0.062 },
            };
            const p = presets[name];
            if (!p) return;
            F = p.F; k = p.k;
            feedSlider.value = F; killSlider.value = k;
            fValEl.textContent = F.toFixed(3);
            kValEl.textContent = k.toFixed(3);
            // Update button active state
            document.querySelectorAll('#presetSpots,#presetStripes,#presetMaze,#presetMitosis').forEach(b => b.classList.remove('active'));
            document.getElementById('preset' + name.charAt(0).toUpperCase() + name.slice(1)).classList.add('active');
            initGrid();
        }

        document.getElementById('presetSpots').addEventListener('click', () => setPreset('spots'));
        document.getElementById('presetStripes').addEventListener('click', () => setPreset('stripes'));
        document.getElementById('presetMaze').addEventListener('click', () => setPreset('maze'));
        document.getElementById('presetMitosis').addEventListener('click', () => setPreset('mitosis'));

        // Color scheme
        function setColor(name) {
            colorScheme = name;
            document.querySelectorAll('#colorCool,#colorWarm,#colorMono,#colorNeon').forEach(b => b.classList.remove('active'));
            const id = 'color' + name.charAt(0).toUpperCase() + name.slice(1);
            document.getElementById(id).classList.add('active');
        }
        document.getElementById('colorCool').addEventListener('click', () => setColor('cool'));
        document.getElementById('colorWarm').addEventListener('click', () => setColor('warm'));
        document.getElementById('colorMono').addEventListener('click', () => setColor('mono'));
        document.getElementById('colorNeon').addEventListener('click', () => setColor('neon'));

        // Reset
        window.reset = function() {
            initGrid();
        };

        window.addEventListener('resize', resizeCanvas);

        resizeCanvas();
        initGrid();

        function animate() {
            for (let i = 0; i < stepsPerFrame; i++) {
                simulationStep();
            }
            render();
            requestAnimationFrame(animate);
        }
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
