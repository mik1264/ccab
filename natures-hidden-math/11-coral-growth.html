<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coral Growth - Diffusion-Limited Aggregation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #030a18; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 260px; max-width: 300px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .stat { font-size: 11px; color: #6688aa; margin-top: 8px; }
        .stat strong { color: #DDA15E; }
        input[type="checkbox"] { accent-color: #8A9A5B; }
        .check-row { display: flex; align-items: center; gap: 8px; font-size: 12px; color: #a0b0c0; margin-bottom: 8px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Coral Growth (DLA)</h2>
        <p class="desc">Diffusion-Limited Aggregation: random walkers stick on contact, building branching structures like coral, lightning, or mineral deposits.</p>
        <div class="control-row">
            <label>Stickiness <span id="stickVal">0.6</span></label>
            <input type="range" id="stickiness" min="0.1" max="1.0" step="0.05" value="0.6">
        </div>
        <div class="control-row">
            <label>Walkers/frame <span id="rateVal">8</span></label>
            <input type="range" id="releaseRate" min="1" max="20" step="1" value="8">
        </div>
        <div class="check-row">
            <input type="checkbox" id="showWalkers" checked>
            <label for="showWalkers">Show active walkers</label>
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">Reset</button>
        </div>
        <div class="stat">Particles: <strong id="particleCount">1</strong></div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H, CX, CY;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            CX = Math.floor(W / 2);
            CY = Math.floor(H / 2);
        }
        resize();
        window.addEventListener('resize', resize);

        // DLA grid
        const CELL = 2;
        let gridW, gridH;
        let grid;
        let particleCount = 0;
        let maxRadius = 0;
        let releaseRadius = 30;

        // Active walkers
        let walkers = [];
        const MAX_WALKERS = 200;

        // Parameters
        let stickiness = 0.6;
        let releaseRate = 8;
        let showWalkers = true;

        function initGrid() {
            gridW = Math.ceil(W / CELL);
            gridH = Math.ceil(H / CELL);
            grid = new Uint32Array(gridW * gridH);
            particleCount = 0;
            maxRadius = 0;
            releaseRadius = 30;
            walkers = [];

            // Seed particle at center
            const cx = Math.floor(gridW / 2);
            const cy = Math.floor(gridH / 2);
            addParticle(cx, cy);
        }

        function addParticle(gx, gy) {
            if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) return;
            particleCount++;
            grid[gy * gridW + gx] = particleCount;

            const cx = Math.floor(gridW / 2);
            const cy = Math.floor(gridH / 2);
            const dist = Math.sqrt((gx - cx) ** 2 + (gy - cy) ** 2);
            if (dist > maxRadius) {
                maxRadius = dist;
                releaseRadius = maxRadius + 20;
            }
        }

        function getParticleColor(order) {
            const maxP = Math.max(particleCount, 3000);
            const t = Math.min(1, order / maxP);

            let r, g, b;
            if (t < 0.15) {
                const f = t / 0.15;
                r = 30 + f * 20;
                g = 5 + f * 15;
                b = 80 + f * 50;
            } else if (t < 0.4) {
                const f = (t - 0.15) / 0.25;
                r = 50 - f * 20;
                g = 20 + f * 100;
                b = 130 + f * 60;
            } else if (t < 0.7) {
                const f = (t - 0.4) / 0.3;
                r = 30 + f * 60;
                g = 120 + f * 80;
                b = 190 + f * 40;
            } else {
                const f = (t - 0.7) / 0.3;
                r = 90 + f * 165;
                g = 200 + f * 55;
                b = 230 + f * 25;
            }
            return [Math.floor(r), Math.floor(g), Math.floor(b)];
        }

        function hasNeighbor(gx, gy) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = gx + dx, ny = gy + dy;
                    if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                        if (grid[ny * gridW + nx] > 0) return true;
                    }
                }
            }
            return false;
        }

        function releaseWalker() {
            const cx = Math.floor(gridW / 2);
            const cy = Math.floor(gridH / 2);
            const angle = Math.random() * Math.PI * 2;
            const r = releaseRadius;
            const gx = Math.floor(cx + Math.cos(angle) * r);
            const gy = Math.floor(cy + Math.sin(angle) * r);
            if (gx >= 1 && gx < gridW - 1 && gy >= 1 && gy < gridH - 1 && grid[gy * gridW + gx] === 0) {
                walkers.push({ x: gx, y: gy, steps: 0 });
            }
        }

        function stepWalkers() {
            const cx = Math.floor(gridW / 2);
            const cy = Math.floor(gridH / 2);
            const killRadius = releaseRadius + 40;
            const maxSteps = 15000;
            const stepsPerWalker = 30;

            for (let w = walkers.length - 1; w >= 0; w--) {
                const walker = walkers[w];
                let removed = false;

                for (let s = 0; s < stepsPerWalker; s++) {
                    const dir = Math.floor(Math.random() * 4);
                    if (dir === 0) walker.x++;
                    else if (dir === 1) walker.x--;
                    else if (dir === 2) walker.y++;
                    else walker.y--;
                    walker.steps++;

                    if (walker.x < 1 || walker.x >= gridW - 1 || walker.y < 1 || walker.y >= gridH - 1) {
                        walkers.splice(w, 1);
                        removed = true;
                        break;
                    }

                    const dist = Math.sqrt((walker.x - cx) ** 2 + (walker.y - cy) ** 2);
                    if (dist > killRadius || walker.steps > maxSteps) {
                        walkers.splice(w, 1);
                        removed = true;
                        break;
                    }

                    if (hasNeighbor(walker.x, walker.y)) {
                        if (Math.random() < stickiness) {
                            addParticle(walker.x, walker.y);
                            walkers.splice(w, 1);
                            removed = true;
                            break;
                        }
                    }
                }
            }
        }

        let running = true;
        let frameCount = 0;

        function render() {
            // Background: deep ocean gradient
            const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
            bgGrad.addColorStop(0, '#030a18');
            bgGrad.addColorStop(0.5, '#051525');
            bgGrad.addColorStop(1, '#081830');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // Subtle underwater light rays
            const time = frameCount * 0.008;
            ctx.save();
            ctx.globalAlpha = 0.025;
            for (let i = 0; i < 4; i++) {
                const x = W * 0.3 + Math.sin(time * 0.5 + i * 1.7) * W * 0.3;
                const y = H * 0.2 + Math.cos(time * 0.3 + i * 1.1) * H * 0.15;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, 250);
                grad.addColorStop(0, 'rgba(60, 160, 210, 0.6)');
                grad.addColorStop(1, 'rgba(60, 160, 210, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(x - 250, y - 250, 500, 500);
            }
            ctx.restore();

            // Draw aggregate
            const imageData = ctx.getImageData(0, 0, W, H);
            const data = imageData.data;

            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const order = grid[gy * gridW + gx];
                    if (order === 0) continue;

                    const color = getParticleColor(order);
                    const px = gx * CELL;
                    const py = gy * CELL;

                    for (let dy = 0; dy < CELL && py + dy < H; dy++) {
                        for (let dx = 0; dx < CELL && px + dx < W; dx++) {
                            const offset = ((py + dy) * W + (px + dx)) * 4;
                            data[offset] = color[0];
                            data[offset + 1] = color[1];
                            data[offset + 2] = color[2];
                            data[offset + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Glow around the coral
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.12;
            const glowGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, maxRadius * CELL + 40);
            glowGrad.addColorStop(0, 'rgba(50, 130, 200, 0.4)');
            glowGrad.addColorStop(0.5, 'rgba(40, 100, 180, 0.15)');
            glowGrad.addColorStop(1, 'rgba(20, 60, 120, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();

            // Active walkers
            if (showWalkers) {
                ctx.fillStyle = 'rgba(100, 200, 255, 0.35)';
                for (const w of walkers) {
                    ctx.fillRect(w.x * CELL, w.y * CELL, CELL, CELL);
                }
            }

            document.getElementById('particleCount').textContent = particleCount;
        }

        function animate() {
            if (running) {
                // Release new walkers
                for (let i = 0; i < releaseRate; i++) {
                    if (walkers.length < MAX_WALKERS) releaseWalker();
                }
                stepWalkers();
                frameCount++;
            }

            render();
            requestAnimationFrame(animate);
        }

        window.reset = function() {
            running = true;
            stickiness = 0.6;
            releaseRate = 8;
            showWalkers = true;
            document.getElementById('stickiness').value = 0.6;
            document.getElementById('releaseRate').value = 8;
            document.getElementById('showWalkers').checked = true;
            document.getElementById('stickVal').textContent = '0.6';
            document.getElementById('rateVal').textContent = '8';
            initGrid();
        };

        document.getElementById('stickiness').addEventListener('input', function() {
            stickiness = parseFloat(this.value);
            document.getElementById('stickVal').textContent = stickiness.toFixed(2);
        });
        document.getElementById('releaseRate').addEventListener('input', function() {
            releaseRate = parseInt(this.value);
            document.getElementById('rateVal').textContent = releaseRate;
        });
        document.getElementById('showWalkers').addEventListener('change', function() {
            showWalkers = this.checked;
        });

        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space') { e.preventDefault(); running = !running; }
        });

        initGrid();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>