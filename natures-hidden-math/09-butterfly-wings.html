<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Butterfly Wing Patterns - Reaction-Diffusion</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 260px; max-width: 300px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        select {
            width: 100%; background: #1a2035; color: #c8d0e0; border: 1px solid rgba(138,154,91,0.3);
            padding: 6px 8px; border-radius: 6px; font-size: 12px; outline: none;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Butterfly Wing Patterns</h2>
        <p class="desc">Reaction-diffusion creates organic patterns within butterfly wing shapes. Bilateral symmetry mirrors one wing to the other.</p>
        <div class="control-row">
            <label>Palette</label>
            <select id="palette">
                <option value="monarch">Monarch</option>
                <option value="morpho">Blue Morpho</option>
                <option value="painted">Painted Lady</option>
                <option value="swallowtail">Swallowtail</option>
            </select>
        </div>
        <div class="control-row">
            <label>Pattern Scale <span id="scaleVal">1.0</span></label>
            <input type="range" id="patternScale" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="control-row">
            <label>Perturbation <span id="pertVal">0.04</span></label>
            <input type="range" id="perturbation" min="0.01" max="0.10" step="0.005" value="0.04">
        </div>
        <div class="control-row">
            <label>Flap Speed <span id="flapVal">1.0</span></label>
            <input type="range" id="flapSpeed" min="0.0" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">Reset</button>
            <button class="btn" onclick="regenerate()">Regenerate</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // RD simulation grid
        const GW = 120, GH = 120;
        let U = new Float32Array(GW * GH);
        let V = new Float32Array(GW * GH);
        let U2 = new Float32Array(GW * GH);
        let V2 = new Float32Array(GW * GH);

        // Wing shape mask (1 = inside wing, 0 = outside)
        let wingMask = new Float32Array(GW * GH);

        // Precomputed pattern texture for the wing
        let patternR = new Uint8Array(GW * GH);
        let patternG = new Uint8Array(GW * GH);
        let patternB = new Uint8Array(GW * GH);

        let patternReady = false;
        let rdIterations = 0;
        const RD_TARGET = 3000;

        // Parameters
        let patternScale = 1.0;
        let perturbation = 0.04;
        let flapSpeed = 1.0;
        let currentPalette = 'monarch';

        // Color palettes
        const palettes = {
            monarch: {
                bg: [20, 12, 5],
                colors: [
                    { v: 0.0, r: 10, g: 5, b: 0 },
                    { v: 0.2, r: 30, g: 15, b: 5 },
                    { v: 0.35, r: 200, g: 80, b: 10 },
                    { v: 0.5, r: 240, g: 130, b: 20 },
                    { v: 0.65, r: 255, g: 160, b: 30 },
                    { v: 0.8, r: 20, g: 10, b: 5 },
                    { v: 0.9, r: 240, g: 230, b: 220 },
                    { v: 1.0, r: 255, g: 255, b: 250 }
                ]
            },
            morpho: {
                bg: [5, 10, 30],
                colors: [
                    { v: 0.0, r: 5, g: 5, b: 20 },
                    { v: 0.15, r: 10, g: 20, b: 80 },
                    { v: 0.3, r: 20, g: 80, b: 200 },
                    { v: 0.5, r: 40, g: 140, b: 255 },
                    { v: 0.65, r: 80, g: 180, b: 255 },
                    { v: 0.8, r: 150, g: 220, b: 255 },
                    { v: 0.9, r: 200, g: 240, b: 255 },
                    { v: 1.0, r: 240, g: 250, b: 255 }
                ]
            },
            painted: {
                bg: [20, 12, 5],
                colors: [
                    { v: 0.0, r: 40, g: 20, b: 10 },
                    { v: 0.2, r: 120, g: 60, b: 20 },
                    { v: 0.35, r: 200, g: 100, b: 30 },
                    { v: 0.5, r: 220, g: 130, b: 50 },
                    { v: 0.65, r: 180, g: 90, b: 40 },
                    { v: 0.8, r: 240, g: 210, b: 170 },
                    { v: 0.9, r: 60, g: 30, b: 15 },
                    { v: 1.0, r: 250, g: 240, b: 220 }
                ]
            },
            swallowtail: {
                bg: [10, 10, 5],
                colors: [
                    { v: 0.0, r: 10, g: 10, b: 5 },
                    { v: 0.2, r: 20, g: 15, b: 5 },
                    { v: 0.35, r: 50, g: 40, b: 10 },
                    { v: 0.5, r: 220, g: 200, b: 40 },
                    { v: 0.65, r: 250, g: 230, b: 60 },
                    { v: 0.8, r: 15, g: 10, b: 5 },
                    { v: 0.9, r: 240, g: 220, b: 50 },
                    { v: 1.0, r: 30, g: 25, b: 10 }
                ]
            }
        };

        function samplePalette(t, pal) {
            const colors = pal.colors;
            t = Math.max(0, Math.min(1, t));
            for (let i = 0; i < colors.length - 1; i++) {
                if (t >= colors[i].v && t <= colors[i + 1].v) {
                    const f = (t - colors[i].v) / (colors[i + 1].v - colors[i].v);
                    return [
                        colors[i].r + (colors[i + 1].r - colors[i].r) * f,
                        colors[i].g + (colors[i + 1].g - colors[i].g) * f,
                        colors[i].b + (colors[i + 1].b - colors[i].b) * f
                    ];
                }
            }
            const last = colors[colors.length - 1];
            return [last.r, last.g, last.b];
        }

        // Build wing shape mask using parametric wing outline
        function buildWingMask() {
            wingMask.fill(0);
            // Wing shape: upper and lower wing lobes for one wing (right half of grid)
            // Grid coords: x=0..GW-1, y=0..GH-1
            // Wing occupies roughly the right half, centered vertically
            for (let gy = 0; gy < GH; gy++) {
                for (let gx = 0; gx < GW; gx++) {
                    // Normalize to [-1,1] range, but wing on right side
                    const nx = (gx / GW) * 2 - 1; // -1 to 1
                    const ny = (gy / GH) * 2 - 1; // -1 to 1

                    // Only compute right wing (nx > 0), will mirror
                    const wx = Math.abs(nx);
                    const wy = ny;

                    // Upper wing (forewing): wider, more triangular
                    const upperLobe = isInUpperWing(wx, wy);
                    // Lower wing (hindwing): rounder, below
                    const lowerLobe = isInLowerWing(wx, wy);

                    if (upperLobe || lowerLobe) {
                        wingMask[gy * GW + gx] = 1;
                    }
                }
            }
        }

        function isInUpperWing(x, y) {
            // Upper wing: extends from body (x~0) outward and upward
            // Roughly bounded by bezier-like curves
            if (x < 0.02 || x > 0.95) return false;
            if (y > 0.1 || y < -0.85) return false;

            // Upper edge curve
            const upperEdge = -0.85 * Math.sin(x * Math.PI * 0.9) * (1 - x * 0.3);
            // Lower edge curve
            const lowerEdge = 0.1 * (1 - x * 0.8) - 0.05 * Math.sin(x * Math.PI);
            // Trailing edge tapering
            const trailTaper = 0.02 + 0.93 * (1 - Math.pow(y / (-0.85), 4));

            if (y > lowerEdge || y < upperEdge) return false;
            if (x > trailTaper) return false;

            return true;
        }

        function isInLowerWing(x, y) {
            if (x < 0.02 || x > 0.75) return false;
            if (y < 0.0 || y > 0.8) return false;

            // Shape: rounded lobe below the body
            const cx = 0.35, cy = 0.35, rx = 0.38, ry = 0.38;
            const dx = (x - cx) / rx;
            const dy = (y - cy) / ry;
            // Elliptical with scalloped edge
            const angle = Math.atan2(dy, dx);
            const scallop = 1.0 + 0.08 * Math.sin(angle * 5);
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > scallop) return false;
            if (x < 0.03) return false;

            return true;
        }

        function initRD() {
            // Fill with U=1, V=0
            for (let i = 0; i < GW * GH; i++) {
                U[i] = 1.0;
                V[i] = 0.0;
            }
            // Seed perturbations within wing mask
            const numSeeds = 20;
            for (let s = 0; s < numSeeds; s++) {
                const cx = Math.floor(Math.random() * GW);
                const cy = Math.floor(Math.random() * GH);
                const size = Math.floor(Math.random() * 4) + 2;
                for (let dy = -size; dy <= size; dy++) {
                    for (let dx = -size; dx <= size; dx++) {
                        const x = cx + dx, y = cy + dy;
                        if (x >= 0 && x < GW && y >= 0 && y < GH) {
                            const idx = y * GW + x;
                            if (wingMask[idx] > 0) {
                                U[idx] = 0.5 + Math.random() * 0.1;
                                V[idx] = 0.25 + Math.random() * 0.1;
                            }
                        }
                    }
                }
            }
            // Add eyespot seeds at specific locations
            addEyespot(0.55, -0.3, 5);
            addEyespot(0.35, -0.55, 4);
            addEyespot(0.65, -0.15, 3);
            addEyespot(0.3, 0.35, 4);

            rdIterations = 0;
            patternReady = false;
        }

        function addEyespot(nx, ny, radius) {
            const gx = Math.floor((nx + 1) / 2 * GW);
            const gy = Math.floor((ny + 1) / 2 * GH);
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const x = gx + dx, y = gy + dy;
                        if (x >= 0 && x < GW && y >= 0 && y < GH) {
                            const idx = y * GW + x;
                            if (wingMask[idx] > 0) {
                                U[idx] = 0.5;
                                V[idx] = 0.25;
                            }
                        }
                    }
                }
            }
        }

        function stepRD() {
            const F = perturbation;
            const k = perturbation + 0.025;
            const Du = 0.16 * patternScale;
            const Dv = 0.08 * patternScale;

            for (let y = 0; y < GH; y++) {
                for (let x = 0; x < GW; x++) {
                    const idx = y * GW + x;
                    if (wingMask[idx] < 0.5) {
                        U2[idx] = 1.0;
                        V2[idx] = 0.0;
                        continue;
                    }

                    const u = U[idx], v = V[idx];

                    // Laplacian with boundary handling
                    const xm = x > 0 ? x - 1 : x;
                    const xp = x < GW - 1 ? x + 1 : x;
                    const ym = y > 0 ? y - 1 : y;
                    const yp = y < GH - 1 ? y + 1 : y;

                    const lapU = U[y * GW + xm] + U[y * GW + xp] + U[ym * GW + x] + U[yp * GW + x] - 4 * u;
                    const lapV = V[y * GW + xm] + V[y * GW + xp] + V[ym * GW + x] + V[yp * GW + x] - 4 * v;

                    const uvv = u * v * v;
                    U2[idx] = u + Du * lapU - uvv + F * (1 - u);
                    V2[idx] = v + Dv * lapV + uvv - (F + k) * v;

                    U2[idx] = Math.max(0, Math.min(1, U2[idx]));
                    V2[idx] = Math.max(0, Math.min(1, V2[idx]));
                }
            }

            const tmpU = U; U = U2; U2 = tmpU;
            const tmpV = V; V = V2; V2 = tmpV;
        }

        function bakePatternTexture() {
            const pal = palettes[currentPalette];
            for (let i = 0; i < GW * GH; i++) {
                if (wingMask[i] > 0) {
                    const v = V[i];
                    const rgb = samplePalette(v * 3.0, pal);
                    patternR[i] = Math.floor(rgb[0]);
                    patternG[i] = Math.floor(rgb[1]);
                    patternB[i] = Math.floor(rgb[2]);
                } else {
                    patternR[i] = 0;
                    patternG[i] = 0;
                    patternB[i] = 0;
                }
            }
        }

        // Wing drawing with bezier curves
        function drawWingOutline(ctx, cx, cy, scale, side, flapAngle) {
            ctx.save();
            ctx.translate(cx, cy);

            // Flap: scale x based on angle to simulate 3D rotation
            const flapScale = Math.cos(flapAngle);
            if (side === 'left') {
                ctx.scale(-flapScale, 1);
            } else {
                ctx.scale(flapScale, 1);
            }

            const s = scale;

            // Draw upper wing (forewing)
            ctx.beginPath();
            ctx.moveTo(0.02 * s, 0);
            // Top edge - sweeping curve upward and outward
            ctx.bezierCurveTo(0.15 * s, -0.6 * s, 0.5 * s, -0.85 * s, 0.85 * s, -0.55 * s);
            // Outer edge - curve down
            ctx.bezierCurveTo(0.9 * s, -0.3 * s, 0.8 * s, -0.05 * s, 0.6 * s, 0.05 * s);
            // Bottom edge back to body
            ctx.bezierCurveTo(0.35 * s, 0.08 * s, 0.15 * s, 0.05 * s, 0.02 * s, 0);
            ctx.closePath();

            // Use the pattern as a fill
            ctx.clip();
            drawPatternOnWing(ctx, cx, cy, scale, side, flapAngle);
            ctx.restore();

            // Lower wing
            ctx.save();
            ctx.translate(cx, cy);
            if (side === 'left') {
                ctx.scale(-flapScale, 1);
            } else {
                ctx.scale(flapScale, 1);
            }

            ctx.beginPath();
            ctx.moveTo(0.02 * s, 0.02 * s);
            ctx.bezierCurveTo(0.15 * s, 0.05 * s, 0.45 * s, 0.05 * s, 0.65 * s, 0.2 * s);
            // Scalloped outer edge
            ctx.bezierCurveTo(0.72 * s, 0.35 * s, 0.7 * s, 0.55 * s, 0.55 * s, 0.65 * s);
            ctx.bezierCurveTo(0.4 * s, 0.72 * s, 0.2 * s, 0.65 * s, 0.08 * s, 0.45 * s);
            ctx.bezierCurveTo(0.04 * s, 0.3 * s, 0.02 * s, 0.15 * s, 0.02 * s, 0.02 * s);
            ctx.closePath();

            ctx.clip();
            drawPatternOnWing(ctx, cx, cy, scale, side, flapAngle);
            ctx.restore();
        }

        // Draw the RD pattern texture mapped onto the wing
        function drawPatternOnWing(ctx, cx, cy, scale, side, flapAngle) {
            const s = scale;
            const pixW = s * 2 / GW;
            const pixH = s * 2 / GH;

            for (let gy = 0; gy < GH; gy++) {
                for (let gx = 0; gx < GW; gx++) {
                    const idx = gy * GW + gx;
                    if (wingMask[idx] < 0.5) continue;

                    const r = patternR[idx], g = patternG[idx], b = patternB[idx];
                    if (r === 0 && g === 0 && b === 0) continue;

                    // Map grid coords to wing coords
                    // Grid: gx 0..GW maps to normalized -1..1
                    const nx = (gx / GW) * 2 - 1;
                    const ny = (gy / GH) * 2 - 1;

                    // Only draw right-half grid points (wing is in right half of grid)
                    if (nx < 0) continue;

                    const wx = nx * s;
                    const wy = ny * s;

                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(wx - pixW * 0.5, wy - pixH * 0.5, pixW + 0.5, pixH + 0.5);
                }
            }
        }

        // Draw butterfly body and antennae
        function drawBody(ctx, cx, cy, scale) {
            const s = scale;
            ctx.save();
            ctx.translate(cx, cy);

            // Body - elongated oval
            ctx.fillStyle = '#1a1008';
            ctx.beginPath();
            ctx.ellipse(0, -0.05 * s, 0.025 * s, 0.25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Thorax segments
            ctx.fillStyle = '#2a1808';
            ctx.beginPath();
            ctx.ellipse(0, -0.1 * s, 0.03 * s, 0.08 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#1a1008';
            ctx.beginPath();
            ctx.arc(0, -0.22 * s, 0.022 * s, 0, Math.PI * 2);
            ctx.fill();

            // Antennae
            ctx.strokeStyle = '#1a1008';
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.moveTo(-0.01 * s, -0.24 * s);
            ctx.quadraticCurveTo(-0.08 * s, -0.5 * s, -0.12 * s, -0.55 * s);
            ctx.stroke();
            // Antenna tip
            ctx.beginPath();
            ctx.arc(-0.12 * s, -0.55 * s, 2.5, 0, Math.PI * 2);
            ctx.fillStyle = '#1a1008';
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0.01 * s, -0.24 * s);
            ctx.quadraticCurveTo(0.08 * s, -0.5 * s, 0.12 * s, -0.55 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0.12 * s, -0.55 * s, 2.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw wing veins
        function drawVeins(ctx, cx, cy, scale, side, flapAngle) {
            ctx.save();
            ctx.translate(cx, cy);
            const flapScale = Math.cos(flapAngle);
            if (side === 'left') {
                ctx.scale(-flapScale, 1);
            } else {
                ctx.scale(flapScale, 1);
            }

            const s = scale;
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 1;

            // Main veins radiating from body
            const veins = [
                [[0.02, -0.02], [0.3, -0.3], [0.6, -0.45], [0.8, -0.5]],
                [[0.02, -0.01], [0.25, -0.15], [0.5, -0.25], [0.75, -0.3]],
                [[0.02, 0], [0.3, -0.05], [0.6, -0.1], [0.8, -0.05]],
                [[0.02, 0.02], [0.2, 0.08], [0.4, 0.15], [0.6, 0.25]],
                [[0.02, 0.05], [0.15, 0.2], [0.3, 0.4], [0.45, 0.55]]
            ];

            for (const vein of veins) {
                ctx.beginPath();
                ctx.moveTo(vein[0][0] * s, vein[0][1] * s);
                for (let i = 1; i < vein.length; i++) {
                    ctx.lineTo(vein[i][0] * s, vein[i][1] * s);
                }
                ctx.stroke();
            }

            ctx.restore();
        }

        let time = 0;
        let running = true;

        function animate() {
            if (!running) { requestAnimationFrame(animate); return; }

            // Run RD steps
            if (!patternReady) {
                const stepsPerFrame = 40;
                for (let i = 0; i < stepsPerFrame; i++) {
                    stepRD();
                    rdIterations++;
                }
                if (rdIterations >= RD_TARGET) {
                    patternReady = true;
                    bakePatternTexture();
                }
            }

            time += 0.016;

            // Clear
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Subtle background gradient
            const bgGrad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.6);
            bgGrad.addColorStop(0, 'rgba(20, 25, 40, 1)');
            bgGrad.addColorStop(1, 'rgba(10, 14, 26, 1)');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            const cx = W / 2;
            const cy = H / 2 + 30;
            const scale = Math.min(W, H) * 0.4;

            const flapAngle = Math.sin(time * flapSpeed * 2) * 0.25;

            if (patternReady) {
                // Draw wings with pattern
                drawWingOutline(ctx, cx, cy, scale, 'right', flapAngle);
                drawWingOutline(ctx, cx, cy, scale, 'left', flapAngle);

                // Draw veins
                drawVeins(ctx, cx, cy, scale, 'right', flapAngle);
                drawVeins(ctx, cx, cy, scale, 'left', flapAngle);
            } else {
                // Loading indicator - draw wing outlines
                ctx.save();
                ctx.translate(cx, cy);
                ctx.strokeStyle = 'rgba(138, 154, 91, 0.3)';
                ctx.lineWidth = 2;

                for (const side of [-1, 1]) {
                    ctx.save();
                    ctx.scale(side, 1);
                    const s = scale;
                    ctx.beginPath();
                    ctx.moveTo(0.02 * s, 0);
                    ctx.bezierCurveTo(0.15 * s, -0.6 * s, 0.5 * s, -0.85 * s, 0.85 * s, -0.55 * s);
                    ctx.bezierCurveTo(0.9 * s, -0.3 * s, 0.8 * s, -0.05 * s, 0.6 * s, 0.05 * s);
                    ctx.bezierCurveTo(0.35 * s, 0.08 * s, 0.15 * s, 0.05 * s, 0.02 * s, 0);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0.02 * s, 0.02 * s);
                    ctx.bezierCurveTo(0.15 * s, 0.05 * s, 0.45 * s, 0.05 * s, 0.65 * s, 0.2 * s);
                    ctx.bezierCurveTo(0.72 * s, 0.35 * s, 0.7 * s, 0.55 * s, 0.55 * s, 0.65 * s);
                    ctx.bezierCurveTo(0.4 * s, 0.72 * s, 0.2 * s, 0.65 * s, 0.08 * s, 0.45 * s);
                    ctx.bezierCurveTo(0.04 * s, 0.3 * s, 0.02 * s, 0.15 * s, 0.02 * s, 0.02 * s);
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();

                // Progress text
                const pct = Math.floor((rdIterations / RD_TARGET) * 100);
                ctx.fillStyle = '#DDA15E';
                ctx.font = '16px "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`Computing pattern... ${pct}%`, cx, cy + scale * 0.85);
            }

            // Draw body on top
            drawBody(ctx, cx, cy, scale);

            requestAnimationFrame(animate);
        }

        function regenerate() {
            buildWingMask();
            initRD();
        }

        window.reset = function() {
            running = true;
            patternScale = 1.0;
            perturbation = 0.04;
            flapSpeed = 1.0;
            currentPalette = 'monarch';
            document.getElementById('patternScale').value = 1.0;
            document.getElementById('perturbation').value = 0.04;
            document.getElementById('flapSpeed').value = 1.0;
            document.getElementById('palette').value = 'monarch';
            document.getElementById('scaleVal').textContent = '1.0';
            document.getElementById('pertVal').textContent = '0.04';
            document.getElementById('flapVal').textContent = '1.0';
            buildWingMask();
            initRD();
        };

        // Wire up controls
        document.getElementById('patternScale').addEventListener('input', function() {
            patternScale = parseFloat(this.value);
            document.getElementById('scaleVal').textContent = patternScale.toFixed(1);
        });
        document.getElementById('perturbation').addEventListener('input', function() {
            perturbation = parseFloat(this.value);
            document.getElementById('pertVal').textContent = perturbation.toFixed(3);
        });
        document.getElementById('flapSpeed').addEventListener('input', function() {
            flapSpeed = parseFloat(this.value);
            document.getElementById('flapVal').textContent = flapSpeed.toFixed(1);
        });
        document.getElementById('palette').addEventListener('change', function() {
            currentPalette = this.value;
            if (patternReady) bakePatternTexture();
        });

        // Pause/unpause
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space') { e.preventDefault(); running = !running; }
        });

        buildWingMask();
        initRD();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>