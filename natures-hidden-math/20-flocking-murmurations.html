<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starling Murmuration - Flocking Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 10px 20px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; color: #c8d0e0;
            max-width: 300px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn.active { background: rgba(221,161,94,0.3); color: #DDA15E; border-color: rgba(221,161,94,0.5); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Murmuration</h2>
        <p class="desc">Thousands of starlings follow three simple rules -- separate, align, cohere -- creating mesmerizing swirling flocks. Enable the predator (follows mouse) to trigger dramatic splitting and reforming.</p>
        <div class="control-row">
            <label>Flock Size <span id="flockVal">2000</span></label>
            <input type="range" id="flockSize" min="500" max="3000" step="100" value="2000">
        </div>
        <div class="control-row">
            <label>Separation <span id="sepVal">1.8</span></label>
            <input type="range" id="separation" min="0.5" max="4" step="0.1" value="1.8">
        </div>
        <div class="control-row">
            <label>Alignment <span id="aliVal">1.0</span></label>
            <input type="range" id="alignment" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-row">
            <label>Cohesion <span id="cohVal">1.0</span></label>
            <input type="range" id="cohesion" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-row">
            <label>Speed <span id="spdVal">3.0</span></label>
            <input type="range" id="speed" min="1" max="6" step="0.1" value="3.0">
        </div>
        <div class="btn-row">
            <button class="btn" id="predatorBtn" onclick="togglePredator()">Predator: OFF</button>
            <button class="btn" onclick="window.reset()">Reset</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        // Boid parameters
        let flockSize = 2000;
        let sepWeight = 1.8;
        let aliWeight = 1.0;
        let cohWeight = 1.0;
        let maxSpeed = 3.0;
        let predatorOn = false;
        let mouseX = -1000, mouseY = -1000;
        let paused = false;

        const sepRadius = 15;
        const aliRadius = 50;
        const cohRadius = 50;
        const predatorFleeRadius = 120;
        const predatorFleeWeight = 8;
        const edgeMargin = 80;
        const edgeForce = 0.3;

        // Spatial hash
        const cellSize = 55; // slightly larger than aliRadius
        let grid = {};
        let boids = [];

        // Trail canvas for fading effect
        let trailCanvas, trailCtx;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            trailCanvas = document.createElement('canvas');
            trailCanvas.width = W;
            trailCanvas.height = H;
            trailCtx = trailCanvas.getContext('2d');
            drawBackground(trailCtx);
        }

        function drawBackground(context) {
            // Evening sky gradient
            const grd = context.createLinearGradient(0, 0, 0, H);
            grd.addColorStop(0, '#0a0e2a');
            grd.addColorStop(0.3, '#1a1040');
            grd.addColorStop(0.55, '#3a1845');
            grd.addColorStop(0.7, '#7a3045');
            grd.addColorStop(0.85, '#c06030');
            grd.addColorStop(0.95, '#e8a040');
            grd.addColorStop(1.0, '#f0c060');
            context.fillStyle = grd;
            context.fillRect(0, 0, W, H);
        }

        function drawCityscape(context) {
            context.fillStyle = '#0a0a15';
            const baseY = H - 30;
            // Random buildings
            const seed = 42;
            let rng = seed;
            function seededRandom() {
                rng = (rng * 1103515245 + 12345) & 0x7fffffff;
                return (rng % 1000) / 1000;
            }

            for (let x = 0; x < W; x += 15 + seededRandom() * 20) {
                const bw = 12 + seededRandom() * 25;
                const bh = 20 + seededRandom() * 80;
                context.fillRect(x, baseY - bh, bw, bh + 30);

                // Windows
                context.fillStyle = 'rgba(255, 200, 100, 0.15)';
                for (let wy = baseY - bh + 5; wy < baseY - 3; wy += 8) {
                    for (let wx = x + 3; wx < x + bw - 3; wx += 7) {
                        if (seededRandom() > 0.4) {
                            context.fillRect(wx, wy, 3, 4);
                        }
                    }
                }
                context.fillStyle = '#0a0a15';
            }

            // Ground
            context.fillRect(0, baseY, W, 30);
        }

        function initBoids() {
            boids = [];
            const cx = W / 2, cy = H * 0.4;
            for (let i = 0; i < flockSize; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spd = 1 + Math.random() * 2;
                boids.push({
                    x: cx + (Math.random() - 0.5) * 300,
                    y: cy + (Math.random() - 0.5) * 200,
                    vx: Math.cos(angle) * spd,
                    vy: Math.sin(angle) * spd
                });
            }
        }

        function buildGrid() {
            grid = {};
            for (let i = 0; i < boids.length; i++) {
                const b = boids[i];
                const cx = Math.floor(b.x / cellSize);
                const cy = Math.floor(b.y / cellSize);
                const key = cx + '|' + cy;
                if (!grid[key]) grid[key] = [];
                grid[key].push(i);
            }
        }

        function getNeighbors(b, radius) {
            const result = [];
            const cr = Math.ceil(radius / cellSize);
            const cx = Math.floor(b.x / cellSize);
            const cy = Math.floor(b.y / cellSize);

            for (let dy = -cr; dy <= cr; dy++) {
                for (let dx = -cr; dx <= cr; dx++) {
                    const key = (cx + dx) + '|' + (cy + dy);
                    const bucket = grid[key];
                    if (bucket) {
                        for (let k = 0; k < bucket.length; k++) {
                            result.push(bucket[k]);
                        }
                    }
                }
            }
            return result;
        }

        function update() {
            buildGrid();

            for (let i = 0; i < boids.length; i++) {
                const b = boids[i];
                let sepX = 0, sepY = 0, sepCount = 0;
                let aliVX = 0, aliVY = 0, aliCount = 0;
                let cohX = 0, cohY = 0, cohCount = 0;

                const neighbors = getNeighbors(b, cohRadius);

                for (let n = 0; n < neighbors.length; n++) {
                    const j = neighbors[n];
                    if (j === i) continue;
                    const other = boids[j];
                    const dx = other.x - b.x;
                    const dy = other.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < sepRadius && dist > 0) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepCount++;
                    }
                    if (dist < aliRadius) {
                        aliVX += other.vx;
                        aliVY += other.vy;
                        aliCount++;
                    }
                    if (dist < cohRadius) {
                        cohX += other.x;
                        cohY += other.y;
                        cohCount++;
                    }
                }

                let ax = 0, ay = 0;

                // Separation
                if (sepCount > 0) {
                    ax += (sepX / sepCount) * sepWeight;
                    ay += (sepY / sepCount) * sepWeight;
                }

                // Alignment
                if (aliCount > 0) {
                    const avgVX = aliVX / aliCount;
                    const avgVY = aliVY / aliCount;
                    ax += (avgVX - b.vx) * aliWeight * 0.05;
                    ay += (avgVY - b.vy) * aliWeight * 0.05;
                }

                // Cohesion
                if (cohCount > 0) {
                    const avgX = cohX / cohCount;
                    const avgY = cohY / cohCount;
                    ax += (avgX - b.x) * cohWeight * 0.001;
                    ay += (avgY - b.y) * cohWeight * 0.001;
                }

                // Edge avoidance
                if (b.x < edgeMargin) ax += edgeForce;
                if (b.x > W - edgeMargin) ax -= edgeForce;
                if (b.y < edgeMargin) ay += edgeForce;
                if (b.y > H - edgeMargin - 60) ay -= edgeForce;

                // Predator avoidance
                if (predatorOn) {
                    const dx = b.x - mouseX;
                    const dy = b.y - mouseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < predatorFleeRadius && dist > 0) {
                        const strength = (1 - dist / predatorFleeRadius) * predatorFleeWeight;
                        ax += (dx / dist) * strength;
                        ay += (dy / dist) * strength;
                    }
                }

                // Apply acceleration
                b.vx += ax;
                b.vy += ay;

                // Limit speed
                const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                if (speed > maxSpeed) {
                    b.vx = (b.vx / speed) * maxSpeed;
                    b.vy = (b.vy / speed) * maxSpeed;
                }
                // Minimum speed
                if (speed < maxSpeed * 0.3) {
                    b.vx = (b.vx / (speed + 0.01)) * maxSpeed * 0.3;
                    b.vy = (b.vy / (speed + 0.01)) * maxSpeed * 0.3;
                }

                b.x += b.vx;
                b.y += b.vy;

                // Wrap with soft boundary
                if (b.x < -20) b.x = W + 20;
                if (b.x > W + 20) b.x = -20;
                if (b.y < -20) b.y = H + 20;
                if (b.y > H + 20) b.y = -20;
            }
        }

        function render() {
            // Fade trail effect: draw background with slight alpha
            drawBackground(ctx);
            ctx.globalAlpha = 0.92;
            ctx.drawImage(trailCanvas, 0, 0);
            ctx.globalAlpha = 1.0;

            // Draw birds on trail canvas
            trailCtx.globalAlpha = 0.93;
            drawBackground(trailCtx);
            trailCtx.globalAlpha = 1.0;

            // Draw cityscape
            drawCityscape(ctx);

            // Draw birds as small dark silhouettes
            for (let i = 0; i < boids.length; i++) {
                const b = boids[i];
                const angle = Math.atan2(b.vy, b.vx);
                const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);

                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(angle);

                // Bird silhouette - small triangle
                const size = 2.5 + speed * 0.3;
                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(-size * 0.6, -size * 0.5);
                ctx.lineTo(-size * 0.3, 0);
                ctx.lineTo(-size * 0.6, size * 0.5);
                ctx.closePath();

                // Dark silhouette with slight variation
                const brightness = Math.floor(15 + (b.y / H) * 15);
                ctx.fillStyle = 'rgb(' + brightness + ',' + brightness + ',' + (brightness + 5) + ')';
                ctx.fill();

                ctx.restore();
            }

            // Draw predator
            if (predatorOn && mouseX > 0) {
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#cc3030';
                ctx.fill();

                // Predator glow
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, predatorFleeRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(200, 50, 50, 0.15)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Predator wings
                ctx.save();
                ctx.translate(mouseX, mouseY);
                const t = Date.now() * 0.01;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-12, -6 + Math.sin(t) * 3);
                ctx.lineTo(-4, 0);
                ctx.lineTo(-12, 6 - Math.sin(t) * 3);
                ctx.closePath();
                ctx.fillStyle = '#881818';
                ctx.fill();
                ctx.restore();
            }
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        window.reset = function() {
            resize();
            initBoids();
        };

        window.togglePredator = function() {
            predatorOn = !predatorOn;
            var btn = document.getElementById('predatorBtn');
            btn.textContent = 'Predator: ' + (predatorOn ? 'ON' : 'OFF');
            if (predatorOn) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        };

        // Mouse tracking for predator
        canvas.addEventListener('mousemove', function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        canvas.addEventListener('mouseleave', function() {
            mouseX = -1000;
            mouseY = -1000;
        });

        // Controls
        document.getElementById('flockSize').addEventListener('input', function() {
            flockSize = parseInt(this.value);
            document.getElementById('flockVal').textContent = flockSize;
            initBoids();
        });
        document.getElementById('separation').addEventListener('input', function() {
            sepWeight = parseFloat(this.value);
            document.getElementById('sepVal').textContent = sepWeight.toFixed(1);
        });
        document.getElementById('alignment').addEventListener('input', function() {
            aliWeight = parseFloat(this.value);
            document.getElementById('aliVal').textContent = aliWeight.toFixed(1);
        });
        document.getElementById('cohesion').addEventListener('input', function() {
            cohWeight = parseFloat(this.value);
            document.getElementById('cohVal').textContent = cohWeight.toFixed(1);
        });
        document.getElementById('speed').addEventListener('input', function() {
            maxSpeed = parseFloat(this.value);
            document.getElementById('spdVal').textContent = maxSpeed.toFixed(1);
        });

        window.addEventListener('resize', resize);

        resize();
        initBoids();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
