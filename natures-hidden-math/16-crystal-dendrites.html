<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dendritic Crystal Growth - Frost Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 10px 20px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(10,14,26,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 20px; color: #c8d0e0;
            max-width: 300px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        select {
            width: 100%; padding: 4px 8px; background: #1a2035; color: #c8d0e0;
            border: 1px solid rgba(138,154,91,0.3); border-radius: 4px; font-size: 12px;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .stat-line { font-size: 11px; color: #6688aa; margin-top: 8px; font-family: monospace; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Nature's Hidden Math</a>
    <div class="controls">
        <h2>Crystal Dendrites</h2>
        <p class="desc">Frost-like dendritic growth using diffusion-limited aggregation with crystallographic anisotropy. Random walkers attach to the crystal, biased along preferred crystal axes, creating stunning frost patterns on a cold window.</p>
        <div class="control-row">
            <label>Symmetry order</label>
            <select id="symmetry">
                <option value="4">4-fold (cubic)</option>
                <option value="6" selected>6-fold (hexagonal)</option>
            </select>
        </div>
        <div class="control-row">
            <label>Anisotropy <span id="anisoVal">0.60</span></label>
            <input type="range" id="anisotropy" min="0.0" max="1.0" step="0.05" value="0.60">
        </div>
        <div class="control-row">
            <label>Growth rate <span id="rateVal">50</span></label>
            <input type="range" id="growthRate" min="10" max="200" step="5" value="50">
        </div>
        <div class="control-row">
            <label>Noise <span id="noiseVal">0.30</span></label>
            <input type="range" id="noise" min="0.0" max="1.0" step="0.05" value="0.30">
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">New Crystal</button>
        </div>
        <div class="stat-line" id="stats">Particles: 1</div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid for DLA
        const CELL = 2; // pixels per cell
        let cols, rows;
        let grid; // 0 = empty, >0 = crystal (value = order of attachment for coloring)
        let particleCount = 0;
        let running = true;
        let maxRadius = 5; // tracks max crystal extent for spawning walkers

        let symmetryOrder = 6;
        let anisotropy = 0.6;
        let walkersPerFrame = 50;
        let noiseParam = 0.3;

        // Offscreen buffer for the crystal image
        let crystalImg;

        function init() {
            cols = Math.ceil(canvas.width / CELL);
            rows = Math.ceil(canvas.height / CELL);
            grid = new Uint32Array(cols * rows);
            particleCount = 0;
            maxRadius = 5;

            // Seed at center
            const cx = Math.floor(cols / 2);
            const cy = Math.floor(rows / 2);
            grid[cy * cols + cx] = 1;
            particleCount = 1;

            crystalImg = ctx.createImageData(canvas.width, canvas.height);
            drawBackground();
            plotCrystalPixel(cx, cy, 1);
        }

        function drawBackground() {
            // Cold window pane gradient in the imageData
            const W = canvas.width;
            const H = canvas.height;
            const px = crystalImg.data;
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = (y * W + x) * 4;
                    // Subtle blue-gray gradient from top-left to bottom-right
                    const t = (x / W * 0.3 + y / H * 0.7);
                    const r = Math.floor(15 + t * 12);
                    const g = Math.floor(20 + t * 18);
                    const b = Math.floor(35 + t * 25);
                    px[i] = r;
                    px[i + 1] = g;
                    px[i + 2] = b;
                    px[i + 3] = 255;
                }
            }
        }

        function plotCrystalPixel(gx, gy, order) {
            const W = canvas.width;
            const px = crystalImg.data;
            // Color based on attachment order (distance from center effectively)
            const t = Math.min(order / 5000, 1);
            // White-blue crystalline colors
            const r = Math.floor(180 + 75 * (1 - t));
            const g = Math.floor(200 + 55 * (1 - t * 0.5));
            const b = 255;
            const glowAlpha = 0.3;

            for (let dy = 0; dy < CELL; dy++) {
                for (let dx = 0; dx < CELL; dx++) {
                    const px0 = gx * CELL + dx;
                    const py0 = gy * CELL + dy;
                    if (px0 >= 0 && px0 < W && py0 >= 0 && py0 < canvas.height) {
                        const i = (py0 * W + px0) * 4;
                        px[i] = r;
                        px[i + 1] = g;
                        px[i + 2] = b;
                        px[i + 3] = 255;
                    }
                }
            }

            // Subtle glow around the pixel
            const glowR = 3;
            for (let dy = -glowR; dy <= glowR; dy++) {
                for (let dx = -glowR; dx <= glowR; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > glowR) continue;
                    const px0 = gx * CELL + CELL / 2 + dx;
                    const py0 = gy * CELL + CELL / 2 + dy;
                    if (px0 >= 0 && px0 < W && py0 >= 0 && py0 < canvas.height) {
                        const i = (py0 * W + Math.floor(px0)) * 4;
                        const fade = (1 - dist / glowR) * glowAlpha;
                        px[i] = Math.min(255, px[i] + Math.floor(r * fade * 0.3));
                        px[i + 1] = Math.min(255, px[i + 1] + Math.floor(g * fade * 0.3));
                        px[i + 2] = Math.min(255, px[i + 2] + Math.floor(b * fade * 0.4));
                    }
                }
            }
        }

        function hasNeighbor(x, y) {
            // Check 8-connected neighbors for crystal
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                        if (grid[ny * cols + nx] > 0) return true;
                    }
                }
            }
            return false;
        }

        function stickingProbability(x, y) {
            // Anisotropic sticking based on angle to crystal axes
            const cx = cols / 2;
            const cy = rows / 2;
            const dx = x - cx;
            const dy = y - cy;
            const angle = Math.atan2(dy, dx);

            // Compute alignment with crystal axes
            const n = symmetryOrder;
            const axisAngle = angle * n / 2;
            const alignment = Math.pow(Math.abs(Math.cos(axisAngle)), 1.5);

            // Base probability + anisotropy bonus
            const base = 1 - anisotropy;
            const prob = base + anisotropy * alignment;

            // Add noise
            const noiseFactor = 1 + (Math.random() - 0.5) * noiseParam;
            return Math.min(prob * noiseFactor, 1);
        }

        function step() {
            const cx = Math.floor(cols / 2);
            const cy = Math.floor(rows / 2);

            for (let w = 0; w < walkersPerFrame; w++) {
                // Spawn walker on a circle just outside the crystal
                const spawnR = maxRadius + 10;
                const killR = maxRadius + 50;
                const angle = Math.random() * Math.PI * 2;
                let wx = Math.round(cx + Math.cos(angle) * spawnR);
                let wy = Math.round(cy + Math.sin(angle) * spawnR);

                // Random walk
                const maxSteps = 5000;
                for (let s = 0; s < maxSteps; s++) {
                    // Biased random walk: slight drift toward center
                    let ddx = Math.random() < 0.5 ? -1 : 1;
                    let ddy = Math.random() < 0.5 ? -1 : 1;

                    // Add anisotropic bias in walk direction
                    if (anisotropy > 0.1) {
                        const toCenter = Math.atan2(cy - wy, cx - wx);
                        const n = symmetryOrder;
                        const axisAlignment = Math.cos(toCenter * n / 2);
                        if (Math.abs(axisAlignment) > 0.5 && Math.random() < anisotropy * 0.2) {
                            // Bias walk along crystal axis toward center
                            ddx = Math.sign(cx - wx) || ddx;
                            ddy = Math.sign(cy - wy) || ddy;
                        }
                    }

                    // Sometimes only move in one direction (4-connected walk mixed with 8-connected)
                    if (Math.random() < 0.5) {
                        if (Math.random() < 0.5) ddx = 0;
                        else ddy = 0;
                    }

                    wx += ddx;
                    wy += ddy;

                    // Kill if too far
                    const dist = Math.sqrt((wx - cx) * (wx - cx) + (wy - cy) * (wy - cy));
                    if (dist > killR || wx < 1 || wx >= cols - 1 || wy < 1 || wy >= rows - 1) break;

                    // Check if adjacent to crystal
                    if (hasNeighbor(wx, wy) && grid[wy * cols + wx] === 0) {
                        // Sticking probability based on anisotropy
                        if (Math.random() < stickingProbability(wx, wy)) {
                            particleCount++;
                            grid[wy * cols + wx] = particleCount;
                            plotCrystalPixel(wx, wy, particleCount);

                            // Update max radius
                            const r = Math.sqrt((wx - cx) * (wx - cx) + (wy - cy) * (wy - cy));
                            if (r > maxRadius) maxRadius = r;
                        }
                        break;
                    }
                }
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function draw() {
            ctx.putImageData(crystalImg, 0, 0);
            document.getElementById('stats').textContent = 'Particles: ' + particleCount + ' | Radius: ' + Math.round(maxRadius);
        }

        // Controls
        document.getElementById('symmetry').addEventListener('change', function() {
            symmetryOrder = parseInt(this.value);
        });
        document.getElementById('anisotropy').addEventListener('input', function() {
            anisotropy = parseFloat(this.value);
            document.getElementById('anisoVal').textContent = anisotropy.toFixed(2);
        });
        document.getElementById('growthRate').addEventListener('input', function() {
            walkersPerFrame = parseInt(this.value);
            document.getElementById('rateVal').textContent = walkersPerFrame;
        });
        document.getElementById('noise').addEventListener('input', function() {
            noiseParam = parseFloat(this.value);
            document.getElementById('noiseVal').textContent = noiseParam.toFixed(2);
        });

        window.reset = function() {
            symmetryOrder = parseInt(document.getElementById('symmetry').value);
            anisotropy = parseFloat(document.getElementById('anisotropy').value);
            walkersPerFrame = parseInt(document.getElementById('growthRate').value);
            noiseParam = parseFloat(document.getElementById('noise').value);
            init();
        };

        function animate() {
            if (running) {
                step();
                draw();
            }
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', function() {
            resize();
            init();
        });

        resize();
        init();
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
