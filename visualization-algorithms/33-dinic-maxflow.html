<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dinic Max-Flow Visualizer - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px; margin-bottom: 20px; }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #0984e3, #00cec9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #0984e3; text-decoration: none; }
        .main-content { display: grid; grid-template-columns: 1fr 350px; gap: 20px; }
        .canvas-container { background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; }
        canvas { display: block; margin: 0 auto; background: #0a0a1a; border-radius: 8px; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; }
        .panel h3 { color: #0984e3; font-size: 1rem; margin-bottom: 10px; border-bottom: 1px solid rgba(9,132,227,0.3); padding-bottom: 5px; }
        button {
            padding: 10px 15px; background: rgba(9,132,227,0.2);
            border: 1px solid rgba(9,132,227,0.5); border-radius: 6px;
            color: #0984e3; cursor: pointer; width: 100%; margin-bottom: 8px;
        }
        button:hover { background: rgba(9,132,227,0.3); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; color: #0984e3; font-size: 0.85rem; margin-bottom: 5px; }
        select {
            width: 100%; padding: 8px; background: rgba(0,0,0,0.3);
            border: 1px solid rgba(9,132,227,0.3); border-radius: 6px;
            color: #e8e8e8; font-size: 0.85rem;
        }
        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .stat { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; text-align: center; }
        .stat-value { font-size: 1.1rem; color: #0984e3; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
        .info-text { font-size: 0.85rem; color: #aaa; line-height: 1.6; }
        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .legend-color { width: 20px; height: 4px; }
        .phase-indicator { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; text-align: center; margin-top: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Dinic Max-Flow Algorithm</h1>
            <p class="subtitle">Level graph construction and blocking flow augmentation</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="550"></canvas>
            </div>
            <div class="controls">
                <div class="panel">
                    <h3>Graph</h3>
                    <div class="control-group">
                        <label>Preset Graph:</label>
                        <select id="preset" onchange="loadPreset()">
                            <option value="simple">Simple (5 nodes)</option>
                            <option value="medium">Medium (7 nodes)</option>
                            <option value="complex">Complex (9 nodes)</option>
                        </select>
                    </div>
                    <button onclick="generateRandom()">Generate Random</button>
                </div>
                <div class="panel">
                    <h3>Algorithm</h3>
                    <button onclick="runDinic()">Run Full Algorithm</button>
                    <button onclick="stepBFS()">Step: Build Level Graph</button>
                    <button onclick="stepDFS()">Step: Find Blocking Flow</button>
                    <button onclick="reset()">Reset</button>
                    <div class="phase-indicator">
                        <div style="font-size: 0.8rem; color: #888;">Current Phase:</div>
                        <div id="phase" style="color: #0984e3; font-weight: bold;">Ready</div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="max-flow">0</div>
                            <div class="stat-label">Max Flow</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="iterations">0</div>
                            <div class="stat-label">BFS Iterations</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="aug-paths">0</div>
                            <div class="stat-label">Aug. Paths</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="current-level">-</div>
                            <div class="stat-label">Sink Level</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Legend</h3>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background: #2ecc71;"></div>Flow / Capacity</div>
                        <div class="legend-item"><div class="legend-color" style="background: #e74c3c;"></div>Saturated Edge</div>
                        <div class="legend-item"><div class="legend-color" style="background: #0984e3;"></div>Level Graph Edge</div>
                        <div class="legend-item"><div class="legend-color" style="background: #f39c12;"></div>Augmenting Path</div>
                    </div>
                </div>
                <div class="panel">
                    <h3>About</h3>
                    <p class="info-text">
                        Dinic's algorithm finds max-flow in O(V²E). Each iteration:
                        1) BFS builds a level graph from source
                        2) DFS finds blocking flows until no path exists
                        Repeat until sink is unreachable.
                    </p>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let source = 0;
        let sink = 0;
        let levels = [];
        let maxFlow = 0;
        let iterations = 0;
        let augPaths = 0;
        let currentPath = [];
        let phase = 'ready';

        function loadPreset() {
            const preset = document.getElementById('preset').value;

            if (preset === 'simple') {
                nodes = [
                    { x: 100, y: 275, label: 'S' },
                    { x: 300, y: 150, label: 'A' },
                    { x: 300, y: 400, label: 'B' },
                    { x: 600, y: 275, label: 'C' },
                    { x: 800, y: 275, label: 'T' }
                ];
                edges = [
                    { u: 0, v: 1, cap: 10, flow: 0 },
                    { u: 0, v: 2, cap: 10, flow: 0 },
                    { u: 1, v: 2, cap: 2, flow: 0 },
                    { u: 1, v: 3, cap: 4, flow: 0 },
                    { u: 2, v: 3, cap: 8, flow: 0 },
                    { u: 3, v: 4, cap: 10, flow: 0 }
                ];
                source = 0; sink = 4;
            } else if (preset === 'medium') {
                nodes = [
                    { x: 100, y: 275, label: 'S' },
                    { x: 250, y: 120, label: 'A' },
                    { x: 250, y: 275, label: 'B' },
                    { x: 250, y: 430, label: 'C' },
                    { x: 550, y: 120, label: 'D' },
                    { x: 550, y: 430, label: 'E' },
                    { x: 800, y: 275, label: 'T' }
                ];
                edges = [
                    { u: 0, v: 1, cap: 10, flow: 0 },
                    { u: 0, v: 2, cap: 8, flow: 0 },
                    { u: 0, v: 3, cap: 5, flow: 0 },
                    { u: 1, v: 4, cap: 5, flow: 0 },
                    { u: 2, v: 1, cap: 3, flow: 0 },
                    { u: 2, v: 4, cap: 4, flow: 0 },
                    { u: 2, v: 5, cap: 6, flow: 0 },
                    { u: 3, v: 5, cap: 5, flow: 0 },
                    { u: 4, v: 6, cap: 13, flow: 0 },
                    { u: 5, v: 6, cap: 8, flow: 0 }
                ];
                source = 0; sink = 6;
            } else {
                nodes = [
                    { x: 80, y: 275, label: 'S' },
                    { x: 220, y: 100, label: 'A' },
                    { x: 220, y: 275, label: 'B' },
                    { x: 220, y: 450, label: 'C' },
                    { x: 450, y: 100, label: 'D' },
                    { x: 450, y: 275, label: 'E' },
                    { x: 450, y: 450, label: 'F' },
                    { x: 680, y: 187, label: 'G' },
                    { x: 820, y: 275, label: 'T' }
                ];
                edges = [
                    { u: 0, v: 1, cap: 7, flow: 0 },
                    { u: 0, v: 2, cap: 6, flow: 0 },
                    { u: 0, v: 3, cap: 5, flow: 0 },
                    { u: 1, v: 4, cap: 3, flow: 0 },
                    { u: 1, v: 5, cap: 4, flow: 0 },
                    { u: 2, v: 4, cap: 2, flow: 0 },
                    { u: 2, v: 5, cap: 5, flow: 0 },
                    { u: 2, v: 6, cap: 3, flow: 0 },
                    { u: 3, v: 5, cap: 2, flow: 0 },
                    { u: 3, v: 6, cap: 4, flow: 0 },
                    { u: 4, v: 7, cap: 6, flow: 0 },
                    { u: 5, v: 7, cap: 5, flow: 0 },
                    { u: 5, v: 8, cap: 4, flow: 0 },
                    { u: 6, v: 8, cap: 6, flow: 0 },
                    { u: 7, v: 8, cap: 8, flow: 0 }
                ];
                source = 0; sink = 8;
            }

            reset();
        }

        function generateRandom() {
            const n = 6 + Math.floor(Math.random() * 4);
            nodes = [];

            // Place nodes in layers
            const layers = 3;
            const nodesPerLayer = Math.ceil((n - 2) / layers);

            nodes.push({ x: 80, y: 275, label: 'S' });

            for (let layer = 0; layer < layers; layer++) {
                const x = 200 + layer * 250;
                const count = Math.min(nodesPerLayer, n - 2 - layer * nodesPerLayer);
                for (let i = 0; i < count && nodes.length < n - 1; i++) {
                    const y = 100 + (i + 0.5) * (350 / count);
                    nodes.push({ x, y, label: String.fromCharCode(65 + nodes.length - 1) });
                }
            }

            nodes.push({ x: 820, y: 275, label: 'T' });
            source = 0;
            sink = nodes.length - 1;

            // Generate edges
            edges = [];
            for (let u = 0; u < nodes.length - 1; u++) {
                for (let v = u + 1; v < nodes.length; v++) {
                    if (nodes[v].x > nodes[u].x && Math.random() < 0.4) {
                        edges.push({
                            u, v,
                            cap: 2 + Math.floor(Math.random() * 10),
                            flow: 0
                        });
                    }
                }
            }

            reset();
        }

        function reset() {
            edges.forEach(e => e.flow = 0);
            levels = new Array(nodes.length).fill(-1);
            maxFlow = 0;
            iterations = 0;
            augPaths = 0;
            currentPath = [];
            phase = 'ready';
            updateStats();
            draw();
        }

        function bfs() {
            levels = new Array(nodes.length).fill(-1);
            levels[source] = 0;
            const queue = [source];

            while (queue.length > 0) {
                const u = queue.shift();
                for (const edge of edges) {
                    if (edge.u === u && edge.flow < edge.cap && levels[edge.v] === -1) {
                        levels[edge.v] = levels[u] + 1;
                        queue.push(edge.v);
                    }
                    // Reverse edge for residual
                    if (edge.v === u && edge.flow > 0 && levels[edge.u] === -1) {
                        levels[edge.u] = levels[u] + 1;
                        queue.push(edge.u);
                    }
                }
            }

            return levels[sink] !== -1;
        }

        function dfs(u, pushed) {
            if (u === sink) return pushed;

            for (const edge of edges) {
                let residual = 0, nextNode = -1, isReverse = false;

                if (edge.u === u && levels[edge.v] === levels[u] + 1) {
                    residual = edge.cap - edge.flow;
                    nextNode = edge.v;
                } else if (edge.v === u && levels[edge.u] === levels[u] + 1) {
                    residual = edge.flow;
                    nextNode = edge.u;
                    isReverse = true;
                }

                if (residual > 0 && nextNode !== -1) {
                    const flow = dfs(nextNode, Math.min(pushed, residual));
                    if (flow > 0) {
                        if (isReverse) {
                            edge.flow -= flow;
                        } else {
                            edge.flow += flow;
                        }
                        return flow;
                    }
                }
            }

            return 0;
        }

        function stepBFS() {
            if (bfs()) {
                iterations++;
                phase = 'Level graph built';
                document.getElementById('current-level').textContent = levels[sink];
            } else {
                phase = 'No path to sink - Done!';
            }
            updateStats();
            draw();
        }

        function stepDFS() {
            if (levels[sink] === -1) {
                if (!bfs()) {
                    phase = 'No path - Algorithm complete';
                    updateStats();
                    draw();
                    return;
                }
                iterations++;
            }

            const flow = dfs(source, Infinity);
            if (flow > 0) {
                maxFlow += flow;
                augPaths++;
                phase = `Found path with flow ${flow}`;
            } else {
                // Need new level graph
                if (bfs()) {
                    iterations++;
                    phase = 'New level graph built';
                } else {
                    phase = 'Algorithm complete!';
                }
            }

            updateStats();
            draw();
        }

        function runDinic() {
            reset();

            while (bfs()) {
                iterations++;
                let flow;
                while ((flow = dfs(source, Infinity)) > 0) {
                    maxFlow += flow;
                    augPaths++;
                }
            }

            phase = 'Complete!';
            updateStats();
            draw();
        }

        function updateStats() {
            document.getElementById('max-flow').textContent = maxFlow;
            document.getElementById('iterations').textContent = iterations;
            document.getElementById('aug-paths').textContent = augPaths;
            document.getElementById('current-level').textContent = levels[sink] >= 0 ? levels[sink] : '-';
            document.getElementById('phase').textContent = phase;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            for (const edge of edges) {
                const u = nodes[edge.u];
                const v = nodes[edge.v];

                const dx = v.x - u.x;
                const dy = v.y - u.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / len;
                const ny = dy / len;

                const startX = u.x + nx * 25;
                const startY = u.y + ny * 25;
                const endX = v.x - nx * 25;
                const endY = v.y - ny * 25;

                // Determine edge color
                const isSaturated = edge.flow >= edge.cap;
                const isLevelEdge = levels[edge.u] >= 0 && levels[edge.v] === levels[edge.u] + 1 && edge.flow < edge.cap;

                if (isSaturated) {
                    ctx.strokeStyle = '#e74c3c';
                } else if (isLevelEdge) {
                    ctx.strokeStyle = '#0984e3';
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                }

                // Edge thickness based on flow
                ctx.lineWidth = 1 + (edge.flow / edge.cap) * 3;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Arrow
                const arrowLen = 10;
                const angle = Math.atan2(endY - startY, endX - startX);
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - arrowLen * Math.cos(angle - 0.3), endY - arrowLen * Math.sin(angle - 0.3));
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - arrowLen * Math.cos(angle + 0.3), endY - arrowLen * Math.sin(angle + 0.3));
                ctx.stroke();

                // Flow/Capacity label
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                const offsetX = -ny * 15;
                const offsetY = nx * 15;

                ctx.fillStyle = edge.flow > 0 ? '#2ecc71' : '#888';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${edge.flow}/${edge.cap}`, midX + offsetX, midY + offsetY);
            }

            // Draw nodes
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                const isSource = i === source;
                const isSink = i === sink;

                // Node circle
                ctx.fillStyle = isSource ? '#2ecc71' : (isSink ? '#e74c3c' : '#0984e3');
                ctx.beginPath();
                ctx.arc(node.x, node.y, 22, 0, Math.PI * 2);
                ctx.fill();

                // Level indicator
                if (levels[i] >= 0) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, node.x, node.y);

                // Level number
                if (levels[i] >= 0) {
                    ctx.fillStyle = '#f39c12';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillText(`L${levels[i]}`, node.x, node.y + 35);
                }
            }
        }

        loadPreset();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
