<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laguerre / Power Diagram (Weighted Voronoi) - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fbbf24;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .back-link:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: translateX(-5px);
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            padding: 0;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 12px;
            color: #ccc;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #fbbf24;
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            margin-top: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(251, 191, 36, 0.4);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .info-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 1000;
            max-width: 450px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h3 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .info-panel p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin: 10px 0;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
        }

        .stat-item .label {
            font-size: 10px;
            color: #888;
        }

        .stat-item .value {
            font-size: 13px;
            color: #fbbf24;
            font-family: 'Courier New', monospace;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #aaa;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .instructions {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .controls {
                max-width: 260px;
                padding: 15px;
            }

            .info-panel {
                max-width: calc(100% - 30px);
                bottom: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Power Diagram Controls</h2>

        <div class="control-group">
            <label>Weight Brush Size: <span id="brushVal">50</span></label>
            <input type="range" id="brush" min="10" max="150" value="50">
        </div>

        <div class="control-group">
            <label>Animation Speed: <span id="speedVal">1.0</span>x</label>
            <input type="range" id="speed" min="0" max="20" value="10">
        </div>

        <div class="control-group checkbox-group">
            <label>
                <input type="checkbox" id="showWeights" checked>
                Show Weight Circles
            </label>
            <label>
                <input type="checkbox" id="showDelaunay">
                Show Weighted Delaunay
            </label>
            <label>
                <input type="checkbox" id="animateWeights">
                Animate Weights
            </label>
            <label>
                <input type="checkbox" id="fillCells" checked>
                Fill Cells
            </label>
        </div>

        <button id="randomize">Randomize Sites</button>
        <button id="equalWeights" class="secondary">Equalize Weights</button>
        <button id="clear" class="secondary">Clear All</button>
    </div>

    <div class="info-panel">
        <h3>Laguerre / Power Diagram (Weighted Voronoi)</h3>
        <p>
            A power diagram generalizes Voronoi diagrams by assigning weights to sites.
            The "power distance" determines cell boundaries, allowing larger weights
            to claim more territory.
        </p>
        <div class="formula">
            pow(p, site) = ||p - site||² - weight²
        </div>
        <p>
            <strong>Interaction:</strong> Click to add sites. Drag on a site to adjust its weight.
            Sites with larger weights (circles) dominate neighboring cells.
        </p>

        <div class="stats">
            <div class="stat-item">
                <div class="label">Sites</div>
                <div class="value" id="siteCount">0</div>
            </div>
            <div class="stat-item">
                <div class="label">Selected Weight</div>
                <div class="value" id="selectedWeight">-</div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #fbbf24;"></div>
                Site center
            </div>
            <div class="legend-item">
                <div class="legend-color" style="border: 2px dashed #888; background: transparent;"></div>
                Weight radius
            </div>
        </div>

        <div class="instructions">
            Click: Add site | Drag site: Adjust weight | Double-click: Remove site
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let width, height;
        let dpr = window.devicePixelRatio || 1;
        let sites = [];
        let selectedSite = null;
        let isDragging = false;
        let brushSize = 50;
        let animSpeed = 1.0;
        let showWeights = true;
        let showDelaunay = false;
        let animateWeights = false;
        let fillCells = true;
        let time = 0;

        // Color palette for cells
        const cellColors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7',
            '#dfe6e9', '#a29bfe', '#fd79a8', '#00b894', '#e17055',
            '#74b9ff', '#00cec9', '#fdcb6e', '#6c5ce7', '#e84393'
        ];

        // Resize handler
        function resize() {
            const rect = canvas.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }

        window.addEventListener('resize', () => {
            resize();
            render();
        });
        resize();

        // Initialize with some random sites
        function initSites() {
            sites = [];
            const numSites = 8;
            const margin = 100;

            for (let i = 0; i < numSites; i++) {
                sites.push({
                    x: margin + Math.random() * (width - 2 * margin),
                    y: margin + Math.random() * (height - 2 * margin),
                    weight: 30 + Math.random() * 60,
                    baseWeight: 30 + Math.random() * 60,
                    color: cellColors[i % cellColors.length],
                    phase: Math.random() * Math.PI * 2
                });
            }

            updateStats();
        }

        // Power distance from point to weighted site
        function powerDistance(px, py, site) {
            const dx = px - site.x;
            const dy = py - site.y;
            const distSq = dx * dx + dy * dy;
            return distSq - site.weight * site.weight;
        }

        // Find which site "owns" a point based on power distance
        function findClosestSite(px, py) {
            let minPower = Infinity;
            let closestIdx = -1;

            for (let i = 0; i < sites.length; i++) {
                const power = powerDistance(px, py, sites[i]);
                if (power < minPower) {
                    minPower = power;
                    closestIdx = i;
                }
            }

            return closestIdx;
        }

        // Render the power diagram using pixel-based approach (for simplicity and visual accuracy)
        function renderPowerDiagram() {
            if (sites.length === 0) return;

            const resolution = 4; // Pixels per sample

            if (fillCells) {
                // Fill cells
                for (let y = 0; y < height; y += resolution) {
                    for (let x = 0; x < width; x += resolution) {
                        const siteIdx = findClosestSite(x, y);
                        if (siteIdx >= 0) {
                            ctx.fillStyle = sites[siteIdx].color + '40'; // Semi-transparent
                            ctx.fillRect(x, y, resolution, resolution);
                        }
                    }
                }
            }

            // Draw cell boundaries
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1;

            const edgeResolution = 2;
            for (let y = 0; y < height; y += edgeResolution) {
                for (let x = 0; x < width; x += edgeResolution) {
                    const current = findClosestSite(x, y);
                    const right = findClosestSite(x + edgeResolution, y);
                    const bottom = findClosestSite(x, y + edgeResolution);

                    // Draw edge if crossing a boundary
                    if (current !== right || current !== bottom) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillRect(x, y, 2, 2);
                    }
                }
            }
        }

        // Draw weighted Delaunay triangulation (dual of power diagram)
        function renderWeightedDelaunay() {
            if (sites.length < 2) return;

            ctx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
            ctx.lineWidth = 1;

            // Simple approach: connect sites that share a power diagram edge
            // This is an approximation - proper implementation would compute actual triangulation
            for (let i = 0; i < sites.length; i++) {
                for (let j = i + 1; j < sites.length; j++) {
                    const s1 = sites[i];
                    const s2 = sites[j];

                    // Check if sites are "neighbors" by sampling points between them
                    const mx = (s1.x + s2.x) / 2;
                    const my = (s1.y + s2.y) / 2;

                    // Sample along perpendicular
                    const dx = s2.x - s1.x;
                    const dy = s2.y - s1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const nx = -dy / len * 50;
                    const ny = dx / len * 50;

                    const c1 = findClosestSite(mx + nx, my + ny);
                    const c2 = findClosestSite(mx - nx, my - ny);

                    // If the midpoint region involves both sites, they share an edge
                    if ((c1 === i && c2 === j) || (c1 === j && c2 === i) ||
                        (c1 === i || c1 === j) && (c2 === i || c2 === j)) {
                        ctx.beginPath();
                        ctx.moveTo(s1.x, s1.y);
                        ctx.lineTo(s2.x, s2.y);
                        ctx.stroke();
                    }
                }
            }
        }

        // Draw sites with weight circles
        function renderSites() {
            sites.forEach((site, idx) => {
                // Weight circle
                if (showWeights) {
                    ctx.strokeStyle = site === selectedSite ? '#fbbf24' : 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = site === selectedSite ? 2 : 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(site.x, site.y, site.weight, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Site center
                ctx.fillStyle = site.color;
                ctx.shadowColor = site.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(site.x, site.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Site index
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(idx + 1, site.x, site.y);
            });
        }

        // Main render function
        function render() {
            // Clear
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, width, height);

            // Update weights if animating
            if (animateWeights) {
                sites.forEach(site => {
                    site.weight = site.baseWeight + Math.sin(time * animSpeed + site.phase) * 20;
                    site.weight = Math.max(10, site.weight);
                });
            }

            // Draw components
            renderPowerDiagram();

            if (showDelaunay) {
                renderWeightedDelaunay();
            }

            renderSites();

            // Title
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.font = 'bold 60px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('POWER DIAGRAM', width / 2, height / 2);

            time += 0.02;
            requestAnimationFrame(render);
        }

        // Find site under cursor
        function findSiteAt(x, y) {
            for (let i = sites.length - 1; i >= 0; i--) {
                const site = sites[i];
                const dx = x - site.x;
                const dy = y - site.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < Math.max(20, site.weight)) {
                    return site;
                }
            }
            return null;
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('siteCount').textContent = sites.length;
            if (selectedSite) {
                document.getElementById('selectedWeight').textContent = Math.round(selectedSite.weight);
            } else {
                document.getElementById('selectedWeight').textContent = '-';
            }
        }

        // Mouse events
        let lastClick = 0;

        canvas.addEventListener('mousedown', (e) => {
            const x = e.clientX;
            const y = e.clientY;
            const now = Date.now();

            // Double-click detection for removal
            if (now - lastClick < 300) {
                const site = findSiteAt(x, y);
                if (site) {
                    sites = sites.filter(s => s !== site);
                    selectedSite = null;
                    updateStats();
                    return;
                }
            }
            lastClick = now;

            const site = findSiteAt(x, y);
            if (site) {
                selectedSite = site;
                isDragging = true;
            } else {
                // Add new site
                const newSite = {
                    x: x,
                    y: y,
                    weight: brushSize,
                    baseWeight: brushSize,
                    color: cellColors[sites.length % cellColors.length],
                    phase: Math.random() * Math.PI * 2
                };
                sites.push(newSite);
                selectedSite = newSite;
            }
            updateStats();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && selectedSite) {
                const dx = e.clientX - selectedSite.x;
                const dy = e.clientY - selectedSite.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Adjust weight based on distance from center
                selectedSite.weight = Math.max(10, Math.min(200, dist));
                selectedSite.baseWeight = selectedSite.weight;
                updateStats();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;

            const site = findSiteAt(x, y);
            if (site) {
                selectedSite = site;
                isDragging = true;
            } else {
                const newSite = {
                    x: x,
                    y: y,
                    weight: brushSize,
                    baseWeight: brushSize,
                    color: cellColors[sites.length % cellColors.length],
                    phase: Math.random() * Math.PI * 2
                };
                sites.push(newSite);
                selectedSite = newSite;
            }
            updateStats();
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && selectedSite) {
                const touch = e.touches[0];
                const dx = touch.clientX - selectedSite.x;
                const dy = touch.clientY - selectedSite.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                selectedSite.weight = Math.max(10, Math.min(200, dist));
                selectedSite.baseWeight = selectedSite.weight;
                updateStats();
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Controls
        document.getElementById('brush').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushVal').textContent = brushSize;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            animSpeed = e.target.value / 10;
            document.getElementById('speedVal').textContent = animSpeed.toFixed(1);
        });

        document.getElementById('showWeights').addEventListener('change', (e) => {
            showWeights = e.target.checked;
        });

        document.getElementById('showDelaunay').addEventListener('change', (e) => {
            showDelaunay = e.target.checked;
        });

        document.getElementById('animateWeights').addEventListener('change', (e) => {
            animateWeights = e.target.checked;
        });

        document.getElementById('fillCells').addEventListener('change', (e) => {
            fillCells = e.target.checked;
        });

        document.getElementById('randomize').addEventListener('click', () => {
            initSites();
        });

        document.getElementById('equalWeights').addEventListener('click', () => {
            const avgWeight = sites.reduce((sum, s) => sum + s.weight, 0) / sites.length || 50;
            sites.forEach(s => {
                s.weight = avgWeight;
                s.baseWeight = avgWeight;
            });
        });

        document.getElementById('clear').addEventListener('click', () => {
            sites = [];
            selectedSite = null;
            updateStats();
        });

        // Initialize
        initSites();
        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
