<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rössler Attractor - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .info h1 {
            font-size: 24px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .info p {
            margin: 4px 0;
            opacity: 0.9;
        }

        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            text-align: center;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            min-width: 200px;
            z-index: 10;
        }

        .controls label {
            display: block;
            margin: 8px 0 4px 0;
            opacity: 0.8;
        }

        .controls input[type="range"] {
            width: 100%;
        }

        .controls .value {
            float: right;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Rössler Attractor</h1>
        <p>Continuous-time dynamical system (Otto Rössler, 1976)</p>
        <p>Drag to rotate • Scroll to zoom</p>
    </div>

    <div class="controls">
        <label>a: <span class="value" id="a-val">0.20</span></label>
        <input type="range" id="a" min="0.1" max="0.5" step="0.01" value="0.2">

        <label>b: <span class="value" id="b-val">0.20</span></label>
        <input type="range" id="b" min="0.1" max="0.5" step="0.01" value="0.2">

        <label>c: <span class="value" id="c-val">5.70</span></label>
        <input type="range" id="c" min="4" max="8" step="0.1" value="5.7">

        <label>Speed: <span class="value" id="speed-val">1.0</span></label>
        <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
    </div>

    <div class="tech-badge">
        GPU-Accelerated • Three.js TSL • Chaotic Dynamics
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
            "three/webgpu": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/tsl": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three/webgpu';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 30, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 20, 25);

        const renderer = await new THREE.WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 15;
        controls.maxDistance = 150;

        // Parameters
        let params = {
            a: 0.2,
            b: 0.2,
            c: 5.7,
            dt: 0.05,
            speed: 1.0
        };

        // Storage for particle trails
        const numParticles = 8;
        const trailLength = 1500;

        const lines = [];
        for (let i = 0; i < numParticles; i++) {
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = new Float32Array(trailLength * 3);
            const lineColors = new Float32Array(trailLength * 3);

            // Gradient colors: cyan -> magenta -> yellow
            for (let j = 0; j < trailLength; j++) {
                const t = j / trailLength;
                const idx = j * 3;

                if (t < 0.33) {
                    const localT = t / 0.33;
                    lineColors[idx] = 0.0 * (1 - localT) + 1.0 * localT;     // R: 0->1
                    lineColors[idx + 1] = 1.0 * (1 - localT) + 0.0 * localT; // G: 1->0
                    lineColors[idx + 2] = 1.0;                                 // B: 1
                } else if (t < 0.67) {
                    const localT = (t - 0.33) / 0.33;
                    lineColors[idx] = 1.0;                                     // R: 1
                    lineColors[idx + 1] = 0.0 * (1 - localT) + 1.0 * localT; // G: 0->1
                    lineColors[idx + 2] = 1.0 * (1 - localT) + 0.0 * localT; // B: 1->0
                } else {
                    lineColors[idx] = 1.0;     // R: 1
                    lineColors[idx + 1] = 1.0; // G: 1
                    lineColors[idx + 2] = 0.0; // B: 0
                }
            }

            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));

            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                linewidth: 2
            });

            const line = new THREE.Line(lineGeometry, material);
            scene.add(line);

            lines.push({
                geometry: lineGeometry,
                positions: linePositions,
                currentPos: [
                    1 + (Math.random() - 0.5) * 0.2,
                    1 + (Math.random() - 0.5) * 0.2,
                    1 + (Math.random() - 0.5) * 0.2
                ],
                index: 0
            });
        }

        // Add atmospheric lighting
        const light1 = new THREE.PointLight(0x00ffff, 2, 80);
        light1.position.set(20, 20, 20);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xff00ff, 2, 80);
        light2.position.set(-20, -20, -20);
        scene.add(light2);

        const light3 = new THREE.PointLight(0xffff00, 2, 80);
        light3.position.set(0, 0, 30);
        scene.add(light3);

        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);

        // Rössler attractor computation
        function rosslerStep(pos, dt) {
            const [x, y, z] = pos;
            const dx = -y - z;
            const dy = x + params.a * y;
            const dz = params.b + z * (x - params.c);

            return [
                x + dx * dt,
                y + dy * dt,
                z + dz * dt
            ];
        }

        // Animation loop
        function animate() {
            const stepsPerFrame = Math.floor(3 * params.speed);

            for (let step = 0; step < stepsPerFrame; step++) {
                lines.forEach((line) => {
                    // Compute next position
                    line.currentPos = rosslerStep(line.currentPos, params.dt);

                    // Add to trail
                    const idx = (line.index % trailLength) * 3;
                    line.positions[idx] = line.currentPos[0];
                    line.positions[idx + 1] = line.currentPos[1];
                    line.positions[idx + 2] = line.currentPos[2];

                    line.index++;

                    if (step % 3 === 0 && line.index > 2) {
                        line.geometry.attributes.position.needsUpdate = true;
                        line.geometry.setDrawRange(0, Math.min(line.index, trailLength));
                    }
                });
            }

            // Animate lights
            const time = Date.now() * 0.001;
            light1.position.x = Math.sin(time * 0.3) * 20;
            light1.position.y = Math.cos(time * 0.4) * 20;

            controls.update();
            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        // Controls
        document.getElementById('a').addEventListener('input', (e) => {
            params.a = parseFloat(e.target.value);
            document.getElementById('a-val').textContent = params.a.toFixed(2);
        });

        document.getElementById('b').addEventListener('input', (e) => {
            params.b = parseFloat(e.target.value);
            document.getElementById('b-val').textContent = params.b.toFixed(2);
        });

        document.getElementById('c').addEventListener('input', (e) => {
            params.c = parseFloat(e.target.value);
            document.getElementById('c-val').textContent = params.c.toFixed(2);
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speed-val').textContent = params.speed.toFixed(1);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
