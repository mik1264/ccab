<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Golden Spiral - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 1;
        }

        #tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #667eea;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #667eea;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 1;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Animated Golden Spiral</strong><br>
        Rotating phyllotaxis pattern<br>
        <span id="particleCount">0</span> particles
    </div>
    <div id="controls">
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button><br>
        <label>Speed: <span id="speedValue">1.0x</span></label><br>
        <input type="range" id="speedSlider" min="0" max="3" value="1" step="0.1">
    </div>
    <div id="tech-badge">GPU-Accelerated • Three.js TSL • Mathematical Patterns</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { instanceIndex, float, vec3, sin, uniform } from 'three/tsl';
        import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2,
            window.innerHeight / 2, window.innerHeight / -2,
            0.1, 1000
        );
        camera.position.z = 500;

        const renderer = new WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Constants
        const phi = (1 + Math.sqrt(5)) / 2;
        const goldenAngle = 2 * Math.PI * (phi - 1);
        const numParticles = 2000;

        // Create particle instances
        const particleGeometry = new THREE.CircleGeometry(1, 16);
        const instancedMesh = new THREE.InstancedMesh(
            particleGeometry,
            new THREE.MeshBasicNodeMaterial(),
            numParticles
        );

        // Generate particle data
        const particleData = [];
        for (let i = 0; i < numParticles; i++) {
            const angle = i * goldenAngle;
            const radius = 3 * Math.sqrt(i);
            const size = 1 + (i / numParticles) * 4;

            particleData.push({ angle, radius, size });
        }

        // TSL material with pulsing colors
        const timeUniform = uniform(0);
        const instanceHue = instanceIndex.div(numParticles);

        // Animated hue shifting
        const hue = instanceHue.mul(360).add(timeUniform.mul(20));
        const saturation = float(0.85);
        const lightness = float(0.6).add(sin(timeUniform.add(instanceHue.mul(10))).mul(0.1));

        // HSL to RGB conversion
        const c = saturation.mul(lightness.oneMinus().mul(2).min(1));
        const x = c.mul(hue.div(60).mod(2).sub(1).abs().oneMinus());
        const m = lightness.sub(c.div(2));

        const hueSegment = hue.div(60).floor().mod(6);
        const r = hueSegment.equal(0).select(c,
                  hueSegment.equal(1).select(x,
                  hueSegment.equal(2).select(0,
                  hueSegment.equal(3).select(0,
                  hueSegment.equal(4).select(x, c))))).add(m);
        const g = hueSegment.equal(0).select(x,
                  hueSegment.equal(1).select(c,
                  hueSegment.equal(2).select(c,
                  hueSegment.equal(3).select(x,
                  hueSegment.equal(4).select(0, 0))))).add(m);
        const b = hueSegment.equal(0).select(0,
                  hueSegment.equal(1).select(0,
                  hueSegment.equal(2).select(x,
                  hueSegment.equal(3).select(c,
                  hueSegment.equal(4).select(c, x))))).add(m);

        instancedMesh.material.colorNode = vec3(r, g, b);
        instancedMesh.material.transparent = true;
        instancedMesh.material.opacity = 0.85;

        scene.add(instancedMesh);

        // Create connecting lines
        const linePoints = [];
        for (let i = 0; i < numParticles; i++) {
            const particle = particleData[i];
            const px = particle.radius * Math.cos(particle.angle);
            const py = particle.radius * Math.sin(particle.angle);
            linePoints.push(new THREE.Vector3(px, py, -1));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x667eea,
            transparent: true,
            opacity: 0.3
        });
        const spiralLine = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(spiralLine);

        document.getElementById('particleCount').textContent = numParticles.toLocaleString();

        // Animation state
        let rotation = 0;
        let isPaused = false;
        let speed = 1.0;

        function updateParticles() {
            const matrix = new THREE.Matrix4();
            const rotationMatrix = new THREE.Matrix4().makeRotationZ(rotation);

            for (let i = 0; i < numParticles; i++) {
                const particle = particleData[i];
                const px = particle.radius * Math.cos(particle.angle);
                const py = particle.radius * Math.sin(particle.angle);

                const pos = new THREE.Vector3(px, py, 0);
                pos.applyMatrix4(rotationMatrix);

                matrix.makeTranslation(pos.x, pos.y, 0);
                matrix.scale(new THREE.Vector3(particle.size, particle.size, 1));
                instancedMesh.setMatrixAt(i, matrix);
            }

            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        // Initial update
        updateParticles();

        // Animation
        let time = 0;

        function animate() {
            if (!isPaused) {
                time += 0.016 * speed;
                rotation += 0.005 * speed;
                timeUniform.value = time;

                updateParticles();
                spiralLine.rotation.z = rotation;
            }

            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        // Controls
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            rotation = 0;
            time = 0;
            updateParticles();
        });

        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        speedSlider.addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            speedValue.textContent = speed.toFixed(1) + 'x';
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
