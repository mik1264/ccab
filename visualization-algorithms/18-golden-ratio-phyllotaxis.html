<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Ratio Phyllotaxis - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 1;
        }

        #tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #667eea;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #667eea;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Golden Ratio Phyllotaxis</strong><br>
        Interactive GPU particle system<br>
        <span id="particleCount">0</span> / 10,000 particles
    </div>
    <div id="tech-badge">GPU-Accelerated • Three.js TSL • Mathematical Patterns</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { instanceIndex, float, vec3, uniform } from 'three/tsl';
        import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2,
            window.innerHeight / 2, window.innerHeight / -2,
            0.1, 1000
        );
        camera.position.z = 500;

        const renderer = new WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Constants
        const phi = (1 + Math.sqrt(5)) / 2;
        const goldenAngle = 2 * Math.PI / (phi * phi);
        const maxParticles = 10000;

        // Create instanced mesh for particles
        const particleGeometry = new THREE.CircleGeometry(1, 16);
        const instancedMesh = new THREE.InstancedMesh(
            particleGeometry,
            new THREE.MeshBasicNodeMaterial(),
            maxParticles
        );

        // Pre-compute all particle data
        const particleData = [];
        for (let i = 0; i < maxParticles; i++) {
            const angle = i * goldenAngle;
            const radius = 8 * Math.sqrt(i);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const size = 1.5 + (i / maxParticles) * 4;
            const hue = i / maxParticles;

            particleData.push({ x, y, size, hue });
        }

        let currentCount = 0;
        const growthRate = 50; // particles per frame

        // TSL material with animated per-instance coloring
        const timeUniform = uniform(0);
        const instanceHue = instanceIndex.div(maxParticles);

        // Enhanced HSL to RGB with brightness pulsing
        const hue = instanceHue.mul(360);
        const saturation = float(0.85);
        const lightness = float(0.6).add(instanceHue.mul(0.1));

        const c = saturation.mul(lightness.oneMinus().mul(2).min(1));
        const x = c.mul(hue.div(60).mod(2).sub(1).abs().oneMinus());
        const m = lightness.sub(c.div(2));

        const hueSegment = hue.div(60).floor();
        const r = hueSegment.equal(0).select(c,
                  hueSegment.equal(1).select(x,
                  hueSegment.equal(2).select(0,
                  hueSegment.equal(3).select(0,
                  hueSegment.equal(4).select(x, c))))).add(m);
        const g = hueSegment.equal(0).select(x,
                  hueSegment.equal(1).select(c,
                  hueSegment.equal(2).select(c,
                  hueSegment.equal(3).select(x,
                  hueSegment.equal(4).select(0, 0))))).add(m);
        const b = hueSegment.equal(0).select(0,
                  hueSegment.equal(1).select(0,
                  hueSegment.equal(2).select(x,
                  hueSegment.equal(3).select(c,
                  hueSegment.equal(4).select(c, x))))).add(m);

        instancedMesh.material.colorNode = vec3(r, g, b);
        instancedMesh.material.transparent = true;
        instancedMesh.material.opacity = 0.9;

        scene.add(instancedMesh);

        // Animation
        let time = 0;
        const matrix = new THREE.Matrix4();

        function animate() {
            time += 0.016;
            timeUniform.value = time;

            // Grow particle system
            if (currentCount < maxParticles) {
                const newCount = Math.min(currentCount + growthRate, maxParticles);

                for (let i = currentCount; i < newCount; i++) {
                    const particle = particleData[i];
                    matrix.makeTranslation(particle.x, particle.y, 0);
                    matrix.scale(new THREE.Vector3(particle.size, particle.size, 1));
                    instancedMesh.setMatrixAt(i, matrix);
                }

                currentCount = newCount;
                instancedMesh.count = currentCount;
                instancedMesh.instanceMatrix.needsUpdate = true;

                document.getElementById('particleCount').textContent = currentCount.toLocaleString();
            }

            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Click to reset
        window.addEventListener('click', () => {
            currentCount = 0;
            instancedMesh.count = 0;
        });
    </script>
</body>
</html>
