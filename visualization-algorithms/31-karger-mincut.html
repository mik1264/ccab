<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karger Min-Cut Algorithm - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px; margin-bottom: 20px; }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #e74c3c; text-decoration: none; }
        .main-content { display: grid; grid-template-columns: 1fr 350px; gap: 20px; }
        .canvas-container { background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; }
        canvas { display: block; margin: 0 auto; background: #0a0a1a; border-radius: 8px; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; }
        .panel h3 { color: #e74c3c; font-size: 1rem; margin-bottom: 10px; border-bottom: 1px solid rgba(231,76,60,0.3); padding-bottom: 5px; }
        button {
            padding: 10px 15px; background: rgba(231,76,60,0.2);
            border: 1px solid rgba(231,76,60,0.5); border-radius: 6px;
            color: #e74c3c; cursor: pointer; width: 100%; margin-bottom: 8px;
        }
        button:hover { background: rgba(231,76,60,0.3); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; color: #e74c3c; font-size: 0.85rem; margin-bottom: 5px; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: rgba(231,76,60,0.2); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #e74c3c; border-radius: 50%; cursor: pointer;
        }
        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .stat { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; text-align: center; }
        .stat-value { font-size: 1.1rem; color: #e74c3c; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
        .info-text { font-size: 0.85rem; color: #aaa; line-height: 1.6; }
        .history { max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 6px; padding: 10px; font-size: 0.75rem; }
        .history-item { padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Karger Random Contraction</h1>
            <p class="subtitle">Randomized algorithm for minimum graph cut</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="550"></canvas>
            </div>
            <div class="controls">
                <div class="panel">
                    <h3>Graph</h3>
                    <div class="control-group">
                        <label>Nodes: <span id="node-val">8</span></label>
                        <input type="range" id="nodes" min="4" max="15" value="8">
                    </div>
                    <div class="control-group">
                        <label>Edge Density: <span id="density-val">0.4</span></label>
                        <input type="range" id="density" min="0.2" max="0.8" step="0.1" value="0.4">
                    </div>
                    <button onclick="generateGraph()">Generate New Graph</button>
                </div>
                <div class="panel">
                    <h3>Algorithm</h3>
                    <button onclick="stepContraction()">Step (Contract One Edge)</button>
                    <button onclick="runToCompletion()">Run to Completion</button>
                    <button onclick="runMultipleTrials()">Run 20 Trials</button>
                    <button onclick="resetGraph()">Reset Graph</button>
                </div>
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="current-nodes">8</div>
                            <div class="stat-label">Nodes Left</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="current-edges">0</div>
                            <div class="stat-label">Edges</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="current-cut">-</div>
                            <div class="stat-label">Cut Size</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="best-cut">∞</div>
                            <div class="stat-label">Best Found</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Trial History</h3>
                    <div class="history" id="history"></div>
                </div>
                <div class="panel">
                    <h3>About</h3>
                    <p class="info-text">
                        Karger's algorithm randomly contracts edges until only 2 nodes remain.
                        The edges between them form a cut. Running O(n²log n) trials gives
                        high probability of finding the minimum cut.
                    </p>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let originalNodes = [];
        let originalEdges = [];
        let nodes = [];
        let edges = [];
        let superNodes = [];
        let bestCut = Infinity;
        let trialCount = 0;

        function generateGraph() {
            const n = parseInt(document.getElementById('nodes').value);
            const density = parseFloat(document.getElementById('density').value);

            originalNodes = [];
            originalEdges = [];

            // Generate nodes in a circle
            const cx = canvas.width / 2, cy = canvas.height / 2, r = 200;
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2 - Math.PI / 2;
                originalNodes.push({
                    id: i,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    label: String.fromCharCode(65 + i)
                });
            }

            // Generate edges
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < density) {
                        originalEdges.push({ u: i, v: j });
                    }
                }
            }

            // Ensure connected graph
            for (let i = 1; i < n; i++) {
                const hasConnection = originalEdges.some(e =>
                    (e.u === i || e.v === i) && (e.u < i || e.v < i)
                );
                if (!hasConnection) {
                    const j = Math.floor(Math.random() * i);
                    originalEdges.push({ u: j, v: i });
                }
            }

            bestCut = Infinity;
            trialCount = 0;
            document.getElementById('best-cut').textContent = '∞';
            document.getElementById('history').innerHTML = '';
            resetGraph();
        }

        function resetGraph() {
            nodes = originalNodes.map(n => ({ ...n, members: [n.id] }));
            edges = originalEdges.map(e => ({ ...e }));
            superNodes = nodes.map((_, i) => i);
            document.getElementById('current-cut').textContent = '-';
            updateStats();
            draw();
        }

        function findSuperNode(id) {
            while (superNodes[id] !== id) {
                superNodes[id] = superNodes[superNodes[id]];
                id = superNodes[id];
            }
            return id;
        }

        function contractEdge(edgeIdx) {
            const edge = edges[edgeIdx];
            const u = findSuperNode(edge.u);
            const v = findSuperNode(edge.v);

            if (u === v) return false;

            // Merge v into u
            superNodes[v] = u;
            nodes[u].members = nodes[u].members.concat(nodes[v].members);
            nodes[u].x = (nodes[u].x + nodes[v].x) / 2;
            nodes[u].y = (nodes[u].y + nodes[v].y) / 2;

            // Remove self-loops
            edges = edges.filter(e => {
                const eu = findSuperNode(e.u);
                const ev = findSuperNode(e.v);
                return eu !== ev;
            });

            return true;
        }

        function getActiveNodes() {
            const active = new Set();
            for (let i = 0; i < nodes.length; i++) {
                active.add(findSuperNode(i));
            }
            return [...active];
        }

        function stepContraction() {
            const activeNodes = getActiveNodes();
            if (activeNodes.length <= 2) {
                finishTrial();
                return;
            }

            if (edges.length === 0) {
                finishTrial();
                return;
            }

            const edgeIdx = Math.floor(Math.random() * edges.length);
            contractEdge(edgeIdx);
            updateStats();
            draw();

            if (getActiveNodes().length <= 2) {
                finishTrial();
            }
        }

        function runToCompletion() {
            while (getActiveNodes().length > 2 && edges.length > 0) {
                const edgeIdx = Math.floor(Math.random() * edges.length);
                contractEdge(edgeIdx);
            }
            finishTrial();
            updateStats();
            draw();
        }

        function finishTrial() {
            const cutSize = edges.length;
            document.getElementById('current-cut').textContent = cutSize;

            trialCount++;
            if (cutSize < bestCut) {
                bestCut = cutSize;
                document.getElementById('best-cut').textContent = bestCut;
            }

            const activeNodes = getActiveNodes();
            const partition = activeNodes.length >= 2 ?
                `{${nodes[activeNodes[0]].members.map(i => originalNodes[i].label).join(',')}} | {${nodes[activeNodes[1]]?.members.map(i => originalNodes[i].label).join(',') || ''}}` :
                'N/A';

            const history = document.getElementById('history');
            const item = document.createElement('div');
            item.className = 'history-item';
            item.innerHTML = `Trial ${trialCount}: Cut = <span style="color: ${cutSize <= bestCut ? '#2ecc71' : '#888'}">${cutSize}</span> ${partition}`;
            history.insertBefore(item, history.firstChild);
        }

        function runMultipleTrials() {
            for (let i = 0; i < 20; i++) {
                resetGraph();
                while (getActiveNodes().length > 2 && edges.length > 0) {
                    const edgeIdx = Math.floor(Math.random() * edges.length);
                    contractEdge(edgeIdx);
                }
                finishTrial();
            }
            updateStats();
            draw();
        }

        function updateStats() {
            document.getElementById('current-nodes').textContent = getActiveNodes().length;
            document.getElementById('current-edges').textContent = edges.length;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const activeNodes = getActiveNodes();

            // Draw edges
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            ctx.lineWidth = 2;
            for (const edge of edges) {
                const u = findSuperNode(edge.u);
                const v = findSuperNode(edge.v);
                ctx.beginPath();
                ctx.moveTo(nodes[u].x, nodes[u].y);
                ctx.lineTo(nodes[v].x, nodes[v].y);
                ctx.stroke();
            }

            // Draw nodes
            for (const nodeId of activeNodes) {
                const node = nodes[nodeId];
                const size = 15 + node.members.length * 3;

                // Node circle
                ctx.fillStyle = activeNodes.length === 2 ?
                    (nodeId === activeNodes[0] ? '#e74c3c' : '#3498db') :
                    '#e74c3c';
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.min(14, 10 + node.members.length)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const label = node.members.map(i => originalNodes[i].label).join('');
                ctx.fillText(label, node.x, node.y);
            }

            // Draw original graph faintly
            ctx.globalAlpha = 0.15;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            for (const edge of originalEdges) {
                ctx.beginPath();
                ctx.moveTo(originalNodes[edge.u].x, originalNodes[edge.u].y);
                ctx.lineTo(originalNodes[edge.v].x, originalNodes[edge.v].y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        // Event listeners
        document.getElementById('nodes').addEventListener('input', e => {
            document.getElementById('node-val').textContent = e.target.value;
        });
        document.getElementById('density').addEventListener('input', e => {
            document.getElementById('density-val').textContent = e.target.value;
        });

        generateGraph();
    </script>
</body>
</html>
