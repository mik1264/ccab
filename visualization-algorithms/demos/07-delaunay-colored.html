<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colored Delaunay Triangulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const points = [];
        const numPoints = 40;

        for (let i = 0; i < numPoints; i++) {
            points.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            });
        }

        function delaunay(points) {
            if (points.length < 3) return [];

            const maxX = Math.max(...points.map(p => p.x));
            const maxY = Math.max(...points.map(p => p.y));
            const minX = Math.min(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));

            const dx = maxX - minX;
            const dy = maxY - minY;
            const deltaMax = Math.max(dx, dy);
            const midx = (minX + maxX) / 2;
            const midy = (minY + maxY) / 2;

            const p1 = { x: midx - 20 * deltaMax, y: midy - deltaMax };
            const p2 = { x: midx, y: midy + 20 * deltaMax };
            const p3 = { x: midx + 20 * deltaMax, y: midy - deltaMax };

            let triangles = [{ p1, p2, p3 }];

            points.forEach(point => {
                let badTriangles = [];

                triangles.forEach(triangle => {
                    if (inCircumcircle(point, triangle)) {
                        badTriangles.push(triangle);
                    }
                });

                let polygon = [];

                badTriangles.forEach(triangle => {
                    const edges = [
                        [triangle.p1, triangle.p2],
                        [triangle.p2, triangle.p3],
                        [triangle.p3, triangle.p1]
                    ];

                    edges.forEach(edge => {
                        let isShared = false;
                        badTriangles.forEach(other => {
                            if (other === triangle) return;
                            const otherEdges = [
                                [other.p1, other.p2],
                                [other.p2, other.p3],
                                [other.p3, other.p1]
                            ];
                            otherEdges.forEach(otherEdge => {
                                if (edgeEqual(edge, otherEdge)) {
                                    isShared = true;
                                }
                            });
                        });
                        if (!isShared) {
                            polygon.push(edge);
                        }
                    });
                });

                triangles = triangles.filter(t => !badTriangles.includes(t));

                polygon.forEach(edge => {
                    triangles.push({
                        p1: edge[0],
                        p2: edge[1],
                        p3: point
                    });
                });
            });

            triangles = triangles.filter(triangle => {
                return triangle.p1 !== p1 && triangle.p1 !== p2 && triangle.p1 !== p3 &&
                       triangle.p2 !== p1 && triangle.p2 !== p2 && triangle.p2 !== p3 &&
                       triangle.p3 !== p1 && triangle.p3 !== p2 && triangle.p3 !== p3;
            });

            return triangles;
        }

        function inCircumcircle(point, triangle) {
            const { p1, p2, p3 } = triangle;

            const ax = p1.x - point.x;
            const ay = p1.y - point.y;
            const bx = p2.x - point.x;
            const by = p2.y - point.y;
            const cx = p3.x - point.x;
            const cy = p3.y - point.y;

            const det =
                (ax * ax + ay * ay) * (bx * cy - cx * by) -
                (bx * bx + by * by) * (ax * cy - cx * ay) +
                (cx * cx + cy * cy) * (ax * by - bx * ay);

            return det > 0;
        }

        function edgeEqual(edge1, edge2) {
            return (edge1[0] === edge2[0] && edge1[1] === edge2[1]) ||
                   (edge1[0] === edge2[1] && edge1[1] === edge2[0]);
        }

        function getTriangleCenter(triangle) {
            return {
                x: (triangle.p1.x + triangle.p2.x + triangle.p3.x) / 3,
                y: (triangle.p1.y + triangle.p2.y + triangle.p3.y) / 3
            };
        }

        function render() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const triangles = delaunay(points);

            triangles.forEach((triangle, i) => {
                const center = getTriangleCenter(triangle);
                const hue = (center.x / canvas.width) * 180 + (center.y / canvas.height) * 180;

                ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                ctx.strokeStyle = `hsl(${hue}, 80%, 40%)`;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(triangle.p1.x, triangle.p1.y);
                ctx.lineTo(triangle.p2.x, triangle.p2.y);
                ctx.lineTo(triangle.p3.x, triangle.p3.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });

            points.forEach(point => {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        });

        render();
    </script>
</body>
</html>
