<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thomas Attractor - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .info h1 {
            font-size: 24px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .info p {
            margin: 4px 0;
            opacity: 0.9;
        }

        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            text-align: center;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            min-width: 200px;
            z-index: 10;
        }

        .controls label {
            display: block;
            margin: 8px 0 4px 0;
            opacity: 0.8;
        }

        .controls input[type="range"] {
            width: 100%;
        }

        .controls .value {
            float: right;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Thomas Attractor</h1>
        <p>Cyclically symmetric attractor with trigonometric functions</p>
        <p>Drag to rotate • Scroll to zoom</p>
    </div>

    <div class="controls">
        <label>b: <span class="value" id="b-val">0.208</span></label>
        <input type="range" id="b" min="0.15" max="0.25" step="0.001" value="0.208186">

        <label>Speed: <span class="value" id="speed-val">1.0</span></label>
        <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
    </div>

    <div class="tech-badge">
        GPU-Accelerated • Three.js TSL • Chaotic Dynamics
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
            "three/webgpu": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/tsl": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three/webgpu';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 15, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 8, 10);

        const renderer = await new THREE.WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 100;

        // Parameters
        let params = {
            b: 0.208186,
            dt: 0.1,
            speed: 1.0
        };

        // Storage for particle trails
        const numParticles = 10;
        const trailLength = 2000;

        const lines = [];
        for (let i = 0; i < numParticles; i++) {
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = new Float32Array(trailLength * 3);
            const lineColors = new Float32Array(trailLength * 3);

            // Radial gradient: pink -> blue -> green
            for (let j = 0; j < trailLength; j++) {
                const t = j / trailLength;
                const idx = j * 3;
                const angle = t * Math.PI * 2;

                if (t < 0.33) {
                    const localT = t / 0.33;
                    lineColors[idx] = 1.0 * (1 - localT) + 0.0 * localT;     // R: 1->0
                    lineColors[idx + 1] = 0.0 * (1 - localT) + 0.5 * localT; // G: 0->0.5
                    lineColors[idx + 2] = 0.5 * (1 - localT) + 1.0 * localT; // B: 0.5->1
                } else if (t < 0.67) {
                    const localT = (t - 0.33) / 0.33;
                    lineColors[idx] = 0.0 * (1 - localT) + 0.0 * localT;     // R: 0->0
                    lineColors[idx + 1] = 0.5 * (1 - localT) + 1.0 * localT; // G: 0.5->1
                    lineColors[idx + 2] = 1.0 * (1 - localT) + 0.5 * localT; // B: 1->0.5
                } else {
                    const localT = (t - 0.67) / 0.33;
                    lineColors[idx] = 0.0;                                    // R: 0
                    lineColors[idx + 1] = 1.0;                                // G: 1
                    lineColors[idx + 2] = 0.5 * (1 - localT) + 0.0 * localT; // B: 0.5->0
                }
            }

            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));

            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const line = new THREE.Line(lineGeometry, material);
            scene.add(line);

            lines.push({
                geometry: lineGeometry,
                positions: linePositions,
                currentPos: [
                    0.1 + (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                ],
                index: 0
            });
        }

        // Add rotating colored lights
        const light1 = new THREE.PointLight(0xff0080, 2, 50);
        light1.position.set(5, 5, 5);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x0080ff, 2, 50);
        light2.position.set(-5, -5, -5);
        scene.add(light2);

        const light3 = new THREE.PointLight(0x00ff80, 2, 50);
        light3.position.set(5, -5, 0);
        scene.add(light3);

        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);

        // Thomas attractor computation
        function thomasStep(pos, dt) {
            const [x, y, z] = pos;
            const b = params.b;

            const dx = Math.sin(y) - b * x;
            const dy = Math.sin(z) - b * y;
            const dz = Math.sin(x) - b * z;

            return [
                x + dx * dt,
                y + dy * dt,
                z + dz * dt
            ];
        }

        // Animation loop
        function animate() {
            const stepsPerFrame = Math.floor(5 * params.speed);

            for (let step = 0; step < stepsPerFrame; step++) {
                lines.forEach((line) => {
                    // Compute next position
                    line.currentPos = thomasStep(line.currentPos, params.dt);

                    // Add to trail
                    const idx = (line.index % trailLength) * 3;
                    line.positions[idx] = line.currentPos[0];
                    line.positions[idx + 1] = line.currentPos[1];
                    line.positions[idx + 2] = line.currentPos[2];

                    line.index++;

                    if (step % 5 === 0 && line.index > 2) {
                        line.geometry.attributes.position.needsUpdate = true;
                        line.geometry.setDrawRange(0, Math.min(line.index, trailLength));
                    }
                });
            }

            // Animate lights in circular patterns
            const time = Date.now() * 0.001;
            light1.position.x = Math.cos(time * 0.5) * 8;
            light1.position.z = Math.sin(time * 0.5) * 8;

            light2.position.x = Math.cos(time * 0.7 + Math.PI) * 8;
            light2.position.y = Math.sin(time * 0.6) * 8;

            light3.position.y = Math.cos(time * 0.4) * 8;
            light3.position.z = Math.sin(time * 0.4 + Math.PI / 2) * 8;

            controls.update();
            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        // Controls
        document.getElementById('b').addEventListener('input', (e) => {
            params.b = parseFloat(e.target.value);
            document.getElementById('b-val').textContent = params.b.toFixed(3);
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speed-val').textContent = params.speed.toFixed(1);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
