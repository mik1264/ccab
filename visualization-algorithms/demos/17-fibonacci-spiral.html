<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fibonacci Spiral - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 1;
        }

        #tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #667eea;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #667eea;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Fibonacci Spiral</strong><br>
        GPU-accelerated golden ratio visualization<br>
        <span id="particleCount">0</span> particles
    </div>
    <div id="tech-badge">GPU-Accelerated • Three.js TSL • Mathematical Patterns</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { color, instanceIndex, float, vec3, vec4 } from 'three/tsl';
        import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2,
            window.innerHeight / 2, window.innerHeight / -2,
            0.1, 1000
        );
        camera.position.z = 500;

        const renderer = new WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Constants
        const phi = (1 + Math.sqrt(5)) / 2;
        const goldenAngle = 2 * Math.PI / (phi * phi);
        const numParticles = 5000;

        // Create instanced mesh for particles
        const particleGeometry = new THREE.CircleGeometry(1, 16);

        // Generate particle positions and attributes
        const positions = new Float32Array(numParticles * 3);
        const scales = new Float32Array(numParticles);
        const hues = new Float32Array(numParticles);

        for (let i = 0; i < numParticles; i++) {
            const angle = i * goldenAngle;
            const radius = 5 * Math.sqrt(i);

            positions[i * 3] = radius * Math.cos(angle);
            positions[i * 3 + 1] = radius * Math.sin(angle);
            positions[i * 3 + 2] = 0;

            scales[i] = 1.5 + (i / numParticles) * 2.5;
            hues[i] = (i / numParticles);
        }

        const instancedMesh = new THREE.InstancedMesh(
            particleGeometry,
            new THREE.MeshBasicNodeMaterial(),
            numParticles
        );

        // Set instance matrices
        const matrix = new THREE.Matrix4();
        for (let i = 0; i < numParticles; i++) {
            matrix.makeTranslation(
                positions[i * 3],
                positions[i * 3 + 1],
                positions[i * 3 + 2]
            );
            matrix.scale(new THREE.Vector3(scales[i], scales[i], 1));
            instancedMesh.setMatrixAt(i, matrix);
        }

        // TSL material with per-instance coloring
        const hueAttribute = new THREE.InstancedBufferAttribute(hues, 1);
        instancedMesh.geometry.setAttribute('instanceHue', hueAttribute);

        const instanceHue = instanceIndex.div(numParticles).toVar();

        // HSL to RGB conversion in TSL
        const hue = instanceHue.mul(360);
        const saturation = float(0.8);
        const lightness = float(0.6);

        const c = saturation.mul(lightness.oneMinus().mul(2).min(1));
        const x = c.mul(hue.div(60).mod(2).sub(1).abs().oneMinus());
        const m = lightness.sub(c.div(2));

        const hueSegment = hue.div(60).floor();
        const r = hueSegment.equal(0).select(c,
                  hueSegment.equal(1).select(x,
                  hueSegment.equal(2).select(0,
                  hueSegment.equal(3).select(0,
                  hueSegment.equal(4).select(x, c))))).add(m);
        const g = hueSegment.equal(0).select(x,
                  hueSegment.equal(1).select(c,
                  hueSegment.equal(2).select(c,
                  hueSegment.equal(3).select(x,
                  hueSegment.equal(4).select(0, 0))))).add(m);
        const b = hueSegment.equal(0).select(0,
                  hueSegment.equal(1).select(0,
                  hueSegment.equal(2).select(x,
                  hueSegment.equal(3).select(c,
                  hueSegment.equal(4).select(c, x))))).add(m);

        instancedMesh.material.colorNode = vec3(r, g, b);

        scene.add(instancedMesh);

        // Add Fibonacci squares as line segments
        function fibonacci(n) {
            const fib = [0, 1];
            for (let i = 2; i <= n; i++) {
                fib[i] = fib[i - 1] + fib[i - 2];
            }
            return fib;
        }

        const fib = fibonacci(15);
        const scale = 3;
        let x = 0, y = 0;
        let direction = 0;

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x667eea });

        for (let i = 2; i < fib.length; i++) {
            const size = fib[i] * scale;

            // Draw square
            const squarePoints = [
                new THREE.Vector3(x, y, 0),
                new THREE.Vector3(x + size, y, 0),
                new THREE.Vector3(x + size, y + size, 0),
                new THREE.Vector3(x, y + size, 0),
                new THREE.Vector3(x, y, 0)
            ];
            const squareGeometry = new THREE.BufferGeometry().setFromPoints(squarePoints);
            const square = new THREE.Line(squareGeometry, lineMaterial);
            scene.add(square);

            // Calculate next position
            switch (direction) {
                case 0: // right
                    x += size;
                    y -= fib[i - 1] * scale;
                    break;
                case 1: // up
                    break;
                case 2: // left
                    x -= fib[i - 1] * scale;
                    break;
                case 3: // down
                    y += size;
                    break;
            }

            direction = (direction + 1) % 4;
        }

        // Update particle count
        document.getElementById('particleCount').textContent = numParticles.toLocaleString();

        // Animation
        function animate() {
            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
