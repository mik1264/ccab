<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Delaunay Triangulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const points = [];
        const numPoints = 25;

        for (let i = 0; i < numPoints; i++) {
            points.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3
            });
        }

        function updatePoints() {
            points.forEach(point => {
                point.x += point.vx;
                point.y += point.vy;

                if (point.x < 0 || point.x > canvas.width) point.vx *= -1;
                if (point.y < 0 || point.y > canvas.height) point.vy *= -1;

                point.x = Math.max(0, Math.min(canvas.width, point.x));
                point.y = Math.max(0, Math.min(canvas.height, point.y));
            });
        }

        function delaunay(points) {
            if (points.length < 3) return [];

            const maxX = Math.max(...points.map(p => p.x));
            const maxY = Math.max(...points.map(p => p.y));
            const minX = Math.min(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));

            const dx = maxX - minX;
            const dy = maxY - minY;
            const deltaMax = Math.max(dx, dy);
            const midx = (minX + maxX) / 2;
            const midy = (minY + maxY) / 2;

            const p1 = { x: midx - 20 * deltaMax, y: midy - deltaMax };
            const p2 = { x: midx, y: midy + 20 * deltaMax };
            const p3 = { x: midx + 20 * deltaMax, y: midy - deltaMax };

            let triangles = [{ p1, p2, p3 }];

            points.forEach(point => {
                let badTriangles = [];

                triangles.forEach(triangle => {
                    if (inCircumcircle(point, triangle)) {
                        badTriangles.push(triangle);
                    }
                });

                let polygon = [];

                badTriangles.forEach(triangle => {
                    const edges = [
                        [triangle.p1, triangle.p2],
                        [triangle.p2, triangle.p3],
                        [triangle.p3, triangle.p1]
                    ];

                    edges.forEach(edge => {
                        let isShared = false;
                        badTriangles.forEach(other => {
                            if (other === triangle) return;
                            const otherEdges = [
                                [other.p1, other.p2],
                                [other.p2, other.p3],
                                [other.p3, other.p1]
                            ];
                            otherEdges.forEach(otherEdge => {
                                if (edgeEqual(edge, otherEdge)) {
                                    isShared = true;
                                }
                            });
                        });
                        if (!isShared) {
                            polygon.push(edge);
                        }
                    });
                });

                triangles = triangles.filter(t => !badTriangles.includes(t));

                polygon.forEach(edge => {
                    triangles.push({
                        p1: edge[0],
                        p2: edge[1],
                        p3: point
                    });
                });
            });

            triangles = triangles.filter(triangle => {
                return triangle.p1 !== p1 && triangle.p1 !== p2 && triangle.p1 !== p3 &&
                       triangle.p2 !== p1 && triangle.p2 !== p2 && triangle.p2 !== p3 &&
                       triangle.p3 !== p1 && triangle.p3 !== p2 && triangle.p3 !== p3;
            });

            return triangles;
        }

        function inCircumcircle(point, triangle) {
            const { p1, p2, p3 } = triangle;

            const ax = p1.x - point.x;
            const ay = p1.y - point.y;
            const bx = p2.x - point.x;
            const by = p2.y - point.y;
            const cx = p3.x - point.x;
            const cy = p3.y - point.y;

            const det =
                (ax * ax + ay * ay) * (bx * cy - cx * by) -
                (bx * bx + by * by) * (ax * cy - cx * ay) +
                (cx * cx + cy * cy) * (ax * by - bx * ay);

            return det > 0;
        }

        function edgeEqual(edge1, edge2) {
            return (edge1[0] === edge2[0] && edge1[1] === edge2[1]) ||
                   (edge1[0] === edge2[1] && edge1[1] === edge2[0]);
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            updatePoints();

            const triangles = delaunay(points);

            triangles.forEach((triangle, i) => {
                const gradient = ctx.createLinearGradient(
                    triangle.p1.x, triangle.p1.y,
                    triangle.p2.x, triangle.p2.y
                );
                gradient.addColorStop(0, `hsla(${(i / triangles.length) * 360}, 70%, 60%, 0.3)`);
                gradient.addColorStop(1, `hsla(${((i + 1) / triangles.length) * 360}, 70%, 60%, 0.3)`);

                ctx.fillStyle = gradient;
                ctx.strokeStyle = `hsl(${(i / triangles.length) * 360}, 70%, 60%)`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(triangle.p1.x, triangle.p1.y);
                ctx.lineTo(triangle.p2.x, triangle.p2.y);
                ctx.lineTo(triangle.p3.x, triangle.p3.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });

            points.forEach(point => {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        animate();
    </script>
</body>
</html>
