<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Delaunay Triangulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <strong>Delaunay Triangulation</strong><br>
        Click to add points<br>
        Press 'C' to clear<br>
        Press 'R' to randomize<br>
        Triangles: <span id="count">0</span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let points = [];

        function initializePoints(count) {
            points = [];
            for (let i = 0; i < count; i++) {
                points.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50
                });
            }
        }

        // Delaunay triangulation using Bowyer-Watson algorithm
        function delaunay(points) {
            if (points.length < 3) return [];

            // Create super triangle
            const maxX = Math.max(...points.map(p => p.x));
            const maxY = Math.max(...points.map(p => p.y));
            const minX = Math.min(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));

            const dx = maxX - minX;
            const dy = maxY - minY;
            const deltaMax = Math.max(dx, dy);
            const midx = (minX + maxX) / 2;
            const midy = (minY + maxY) / 2;

            const p1 = { x: midx - 20 * deltaMax, y: midy - deltaMax };
            const p2 = { x: midx, y: midy + 20 * deltaMax };
            const p3 = { x: midx + 20 * deltaMax, y: midy - deltaMax };

            let triangles = [{ p1, p2, p3 }];

            // Add each point
            points.forEach(point => {
                let badTriangles = [];

                // Find triangles whose circumcircle contains the point
                triangles.forEach(triangle => {
                    if (inCircumcircle(point, triangle)) {
                        badTriangles.push(triangle);
                    }
                });

                let polygon = [];

                // Find boundary of polygonal hole
                badTriangles.forEach(triangle => {
                    const edges = [
                        [triangle.p1, triangle.p2],
                        [triangle.p2, triangle.p3],
                        [triangle.p3, triangle.p1]
                    ];

                    edges.forEach(edge => {
                        let isShared = false;
                        badTriangles.forEach(other => {
                            if (other === triangle) return;
                            const otherEdges = [
                                [other.p1, other.p2],
                                [other.p2, other.p3],
                                [other.p3, other.p1]
                            ];
                            otherEdges.forEach(otherEdge => {
                                if (edgeEqual(edge, otherEdge)) {
                                    isShared = true;
                                }
                            });
                        });
                        if (!isShared) {
                            polygon.push(edge);
                        }
                    });
                });

                // Remove bad triangles
                triangles = triangles.filter(t => !badTriangles.includes(t));

                // Create new triangles from point to polygon edges
                polygon.forEach(edge => {
                    triangles.push({
                        p1: edge[0],
                        p2: edge[1],
                        p3: point
                    });
                });
            });

            // Remove triangles that share vertices with super triangle
            triangles = triangles.filter(triangle => {
                return triangle.p1 !== p1 && triangle.p1 !== p2 && triangle.p1 !== p3 &&
                       triangle.p2 !== p1 && triangle.p2 !== p2 && triangle.p2 !== p3 &&
                       triangle.p3 !== p1 && triangle.p3 !== p2 && triangle.p3 !== p3;
            });

            return triangles;
        }

        function inCircumcircle(point, triangle) {
            const { p1, p2, p3 } = triangle;

            const ax = p1.x - point.x;
            const ay = p1.y - point.y;
            const bx = p2.x - point.x;
            const by = p2.y - point.y;
            const cx = p3.x - point.x;
            const cy = p3.y - point.y;

            const det =
                (ax * ax + ay * ay) * (bx * cy - cx * by) -
                (bx * bx + by * by) * (ax * cy - cx * ay) +
                (cx * cx + cy * cy) * (ax * by - bx * ay);

            return det > 0;
        }

        function edgeEqual(edge1, edge2) {
            return (edge1[0] === edge2[0] && edge1[1] === edge2[1]) ||
                   (edge1[0] === edge2[1] && edge1[1] === edge2[0]);
        }

        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (points.length > 0) {
                const triangles = delaunay(points);
                document.getElementById('count').textContent = triangles.length;

                // Draw triangles
                triangles.forEach((triangle, i) => {
                    ctx.strokeStyle = `hsl(${(i / triangles.length) * 360}, 70%, 60%)`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(triangle.p1.x, triangle.p1.y);
                    ctx.lineTo(triangle.p2.x, triangle.p2.y);
                    ctx.lineTo(triangle.p3.x, triangle.p3.y);
                    ctx.closePath();
                    ctx.stroke();
                });

                // Draw points
                points.forEach(point => {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            points.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
            render();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c') {
                points = [];
                render();
            } else if (e.key.toLowerCase() === 'r') {
                initializePoints(30);
                render();
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        });

        initializePoints(30);
        render();
    </script>
</body>
</html>
