<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU-Accelerated Quadtree Spatial Partitioning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }

        #tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>GPU-Accelerated Quadtree</strong><br>
        Click to add points<br>
        Press 'C' to clear<br>
        Points: <span id="count">0</span>
    </div>
    <div id="tech-badge">GPU-Accelerated • Three.js TSL • Spatial Partitioning</div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
        const { Scene, PerspectiveCamera, WebGLRenderer, BufferGeometry, LineSegments, LineBasicMaterial,
                Points, PointsMaterial, BufferAttribute, Vector3, Color } = THREE;

        // Scene setup
        const scene = new Scene();
        scene.background = new Color(0x000000);

        const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 500;

        const renderer = new WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Quadtree data structure (CPU-side)
        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }

            contains(point) {
                return (point.x >= this.x - this.w &&
                        point.x < this.x + this.w &&
                        point.y >= this.y - this.h &&
                        point.y < this.y + this.h);
            }
        }

        class Quadtree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.points = [];
                this.divided = false;
            }

            subdivide() {
                const x = this.boundary.x;
                const y = this.boundary.y;
                const w = this.boundary.w / 2;
                const h = this.boundary.h / 2;

                const ne = new Rectangle(x + w, y - h, w, h);
                const nw = new Rectangle(x - w, y - h, w, h);
                const se = new Rectangle(x + w, y + h, w, h);
                const sw = new Rectangle(x - w, y + h, w, h);

                this.northeast = new Quadtree(ne, this.capacity);
                this.northwest = new Quadtree(nw, this.capacity);
                this.southeast = new Quadtree(se, this.capacity);
                this.southwest = new Quadtree(sw, this.capacity);

                this.divided = true;
            }

            insert(point) {
                if (!this.boundary.contains(point)) {
                    return false;
                }

                if (this.points.length < this.capacity) {
                    this.points.push(point);
                    return true;
                } else {
                    if (!this.divided) {
                        this.subdivide();
                    }

                    if (this.northeast.insert(point)) return true;
                    if (this.northwest.insert(point)) return true;
                    if (this.southeast.insert(point)) return true;
                    if (this.southwest.insert(point)) return true;
                }
            }

            // Extract all boundaries for GPU rendering
            getAllBoundaries(boundaries = []) {
                const b = this.boundary;
                boundaries.push({
                    x: b.x - b.w,
                    y: b.y - b.h,
                    w: b.w * 2,
                    h: b.h * 2
                });

                if (this.divided) {
                    this.northeast.getAllBoundaries(boundaries);
                    this.northwest.getAllBoundaries(boundaries);
                    this.southeast.getAllBoundaries(boundaries);
                    this.southwest.getAllBoundaries(boundaries);
                }

                return boundaries;
            }
        }

        // Convert screen to world coordinates
        const WIDTH = window.innerWidth;
        const HEIGHT = window.innerHeight;
        const boundary = new Rectangle(0, 0, WIDTH / 2, HEIGHT / 2);
        let qtree = new Quadtree(boundary, 4);
        let points = [];

        // GPU rendering objects
        let quadtreeLines = null;
        let pointsObj = null;

        function screenToWorld(x, y) {
            return {
                x: x - WIDTH / 2,
                y: HEIGHT / 2 - y
            };
        }

        function createQuadtreeLines() {
            const boundaries = qtree.getAllBoundaries();
            const vertices = [];

            boundaries.forEach(b => {
                const x1 = b.x;
                const y1 = b.y;
                const x2 = b.x + b.w;
                const y2 = b.y + b.h;

                // Four lines for rectangle
                vertices.push(x1, y1, 0, x2, y1, 0);
                vertices.push(x2, y1, 0, x2, y2, 0);
                vertices.push(x2, y2, 0, x1, y2, 0);
                vertices.push(x1, y2, 0, x1, y1, 0);
            });

            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));

            const material = new LineBasicMaterial({
                color: 0x00ff66,
                opacity: 0.5,
                transparent: true
            });

            return new LineSegments(geometry, material);
        }

        function createPointsObject() {
            const vertices = [];
            const colors = [];

            points.forEach((point, i) => {
                vertices.push(point.x, point.y, 0);

                const hue = (i / points.length) * 360;
                const color = new Color().setHSL(hue / 360, 0.8, 0.6);
                colors.push(color.r, color.g, color.b);
            });

            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));
            geometry.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));

            const material = new PointsMaterial({
                size: 6,
                vertexColors: true,
                sizeAttenuation: false
            });

            return new Points(geometry, material);
        }

        function updateScene() {
            // Remove old objects
            if (quadtreeLines) scene.remove(quadtreeLines);
            if (pointsObj) scene.remove(pointsObj);

            // Create new objects
            quadtreeLines = createQuadtreeLines();
            pointsObj = createPointsObject();

            scene.add(quadtreeLines);
            scene.add(pointsObj);

            document.getElementById('count').textContent = points.length;
        }

        // Mouse interaction
        renderer.domElement.addEventListener('click', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const worldPos = screenToWorld(x, y);
            points.push(worldPos);

            qtree = new Quadtree(boundary, 4);
            points.forEach(p => qtree.insert(p));

            updateScene();
        });

        // Keyboard interaction
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c') {
                points = [];
                qtree = new Quadtree(boundary, 4);
                updateScene();
            }
        });

        // Initialize with random points
        for (let i = 0; i < 100; i++) {
            const point = screenToWorld(
                Math.random() * WIDTH,
                Math.random() * HEIGHT
            );
            points.push(point);
            qtree.insert(point);
        }

        updateScene();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
