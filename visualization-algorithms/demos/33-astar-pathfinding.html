<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Algorithm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <strong>A* Pathfinding</strong><br>
        Click to place obstacles<br>
        Green: Start | Red: End<br>
        Blue: Path | Cyan: Explored
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const cols = 40;
        const rows = 30;
        const cellWidth = window.innerWidth / cols;
        const cellHeight = window.innerHeight / rows;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Node {
            constructor(i, j) {
                this.i = i;
                this.j = j;
                this.f = 0;
                this.g = 0;
                this.h = 0;
                this.neighbors = [];
                this.previous = null;
                this.wall = false;
            }

            addNeighbors(grid) {
                if (this.i > 0) this.neighbors.push(grid[this.i - 1][this.j]);
                if (this.i < cols - 1) this.neighbors.push(grid[this.i + 1][this.j]);
                if (this.j > 0) this.neighbors.push(grid[this.i][this.j - 1]);
                if (this.j < rows - 1) this.neighbors.push(grid[this.i][this.j + 1]);

                // Diagonals
                if (this.i > 0 && this.j > 0) this.neighbors.push(grid[this.i - 1][this.j - 1]);
                if (this.i < cols - 1 && this.j > 0) this.neighbors.push(grid[this.i + 1][this.j - 1]);
                if (this.i > 0 && this.j < rows - 1) this.neighbors.push(grid[this.i - 1][this.j + 1]);
                if (this.i < cols - 1 && this.j < rows - 1) this.neighbors.push(grid[this.i + 1][this.j + 1]);
            }

            show(color) {
                ctx.fillStyle = color;
                ctx.fillRect(this.i * cellWidth, this.j * cellHeight, cellWidth - 1, cellHeight - 1);
            }
        }

        function heuristic(a, b) {
            return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
        }

        const grid = [];
        for (let i = 0; i < cols; i++) {
            grid[i] = [];
            for (let j = 0; j < rows; j++) {
                grid[i][j] = new Node(i, j);
            }
        }

        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j].addNeighbors(grid);
            }
        }

        // Add random walls
        for (let i = 0; i < cols * rows * 0.3; i++) {
            const x = Math.floor(Math.random() * cols);
            const y = Math.floor(Math.random() * rows);
            grid[x][y].wall = true;
        }

        let start = grid[0][0];
        let end = grid[cols - 1][rows - 1];
        start.wall = false;
        end.wall = false;

        let openSet = [start];
        let closedSet = [];
        let path = [];

        function findPath() {
            if (openSet.length > 0) {
                let winner = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[winner].f) {
                        winner = i;
                    }
                }

                const current = openSet[winner];

                if (current === end) {
                    // Found the path
                    let temp = current;
                    path = [];
                    while (temp.previous) {
                        path.push(temp);
                        temp = temp.previous;
                    }
                    return true;
                }

                openSet = openSet.filter((_, i) => i !== winner);
                closedSet.push(current);

                const neighbors = current.neighbors;
                for (let i = 0; i < neighbors.length; i++) {
                    const neighbor = neighbors[i];

                    if (!closedSet.includes(neighbor) && !neighbor.wall) {
                        const tempG = current.g + 1;

                        let newPath = false;
                        if (openSet.includes(neighbor)) {
                            if (tempG < neighbor.g) {
                                neighbor.g = tempG;
                                newPath = true;
                            }
                        } else {
                            neighbor.g = tempG;
                            newPath = true;
                            openSet.push(neighbor);
                        }

                        if (newPath) {
                            neighbor.h = heuristic(neighbor, end);
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.previous = current;
                        }
                    }
                }
            }
            return false;
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    grid[i][j].show('#16213e');
                }
            }

            for (let i = 0; i < closedSet.length; i++) {
                closedSet[i].show('#0f3460');
            }

            for (let i = 0; i < openSet.length; i++) {
                openSet[i].show('#533483');
            }

            for (let i = 0; i < path.length; i++) {
                path[i].show('#00d9ff');
            }

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j].wall) {
                        grid[i][j].show('#000');
                    }
                }
            }

            start.show('#00ff00');
            end.show('#ff0066');
        }

        let finished = false;

        function animate() {
            if (!finished) {
                for (let i = 0; i < 5; i++) {
                    finished = findPath();
                    if (finished) break;
                }
            }
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellWidth);
            const y = Math.floor((e.clientY - rect.top) / cellHeight);

            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                if (grid[x][y] !== start && grid[x][y] !== end) {
                    grid[x][y].wall = !grid[x][y].wall;
                }
            }
        });

        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
