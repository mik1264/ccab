<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorenz Attractor - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .info h1 {
            font-size: 24px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .info p {
            margin: 4px 0;
            opacity: 0.9;
        }

        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            text-align: center;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            min-width: 200px;
            z-index: 10;
        }

        .controls label {
            display: block;
            margin: 8px 0 4px 0;
            opacity: 0.8;
        }

        .controls input[type="range"] {
            width: 100%;
        }

        .controls .value {
            float: right;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Lorenz Attractor</h1>
        <p>Chaotic system discovered by Edward Lorenz (1963)</p>
        <p>Drag to rotate • Scroll to zoom</p>
    </div>

    <div class="controls">
        <label>σ (Sigma): <span class="value" id="sigma-val">10.0</span></label>
        <input type="range" id="sigma" min="5" max="15" step="0.1" value="10">

        <label>ρ (Rho): <span class="value" id="rho-val">28.0</span></label>
        <input type="range" id="rho" min="20" max="35" step="0.1" value="28">

        <label>β (Beta): <span class="value" id="beta-val">2.67</span></label>
        <input type="range" id="beta" min="1" max="4" step="0.01" value="2.67">

        <label>Speed: <span class="value" id="speed-val">1.0</span></label>
        <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
    </div>

    <div class="tech-badge">
        GPU-Accelerated • Three.js TSL • Chaotic Dynamics
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
            "three/webgpu": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/tsl": "https://unpkg.com/three@0.169.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three/webgpu';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { uniform, vec3, vec4, color, storage, instanceIndex, float, Fn,
                 Loop, If, sin, cos, length, normalize, mix } from 'three/tsl';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 30, 50);

        const renderer = await new THREE.WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 200;

        // Parameters
        let params = {
            sigma: 10.0,
            rho: 28.0,
            beta: 8.0 / 3.0,
            dt: 0.01,
            speed: 1.0
        };

        // Storage for particle positions and trails
        const numParticles = 10;
        const trailLength = 2000;
        const totalPoints = numParticles * trailLength;

        // Initialize positions
        const positions = new Float32Array(totalPoints * 3);
        const colors = new Float32Array(totalPoints * 3);

        for (let i = 0; i < numParticles; i++) {
            const offset = i * trailLength * 3;
            // Initial position with slight variation for each particle
            positions[offset] = 0.1 + (Math.random() - 0.5) * 0.1;
            positions[offset + 1] = (Math.random() - 0.5) * 0.1;
            positions[offset + 2] = (Math.random() - 0.5) * 0.1;

            // Color variation per particle
            const hue = i / numParticles;
            const col = new THREE.Color().setHSL(hue, 1.0, 0.5);
            for (let j = 0; j < trailLength; j++) {
                const idx = (i * trailLength + j) * 3;
                colors[idx] = col.r;
                colors[idx + 1] = col.g;
                colors[idx + 2] = col.b;
            }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create line segments for trails
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const lines = [];
        for (let i = 0; i < numParticles; i++) {
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = new Float32Array(trailLength * 3);
            const lineColors = new Float32Array(trailLength * 3);

            const hue = i / numParticles;
            const col = new THREE.Color().setHSL(hue, 1.0, 0.5);

            for (let j = 0; j < trailLength; j++) {
                const idx = j * 3;
                lineColors[idx] = col.r;
                lineColors[idx + 1] = col.g;
                lineColors[idx + 2] = col.b;
            }

            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));

            const line = new THREE.Line(lineGeometry, material);
            scene.add(line);
            lines.push({
                geometry: lineGeometry,
                positions: linePositions,
                currentPos: [0.1 + (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1],
                index: 0
            });
        }

        // Add point lights for atmosphere
        const light1 = new THREE.PointLight(0x667eea, 2, 100);
        light1.position.set(30, 30, 30);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xf093fb, 2, 100);
        light2.position.set(-30, -30, -30);
        scene.add(light2);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Lorenz attractor CPU computation (for simplicity, could be done in compute shader)
        function lorenzStep(pos, dt) {
            const [x, y, z] = pos;
            const dx = params.sigma * (y - x);
            const dy = x * (params.rho - z) - y;
            const dz = x * y - params.beta * z;

            return [
                x + dx * dt,
                y + dy * dt,
                z + dz * dt
            ];
        }

        // Animation loop
        let frameCount = 0;
        function animate() {
            frameCount++;

            // Update particles multiple times per frame for smooth trails
            const stepsPerFrame = Math.floor(5 * params.speed);
            for (let step = 0; step < stepsPerFrame; step++) {
                lines.forEach((line) => {
                    // Compute next position
                    line.currentPos = lorenzStep(line.currentPos, params.dt);

                    // Add to trail (circular buffer)
                    const idx = (line.index % trailLength) * 3;
                    line.positions[idx] = line.currentPos[0];
                    line.positions[idx + 1] = line.currentPos[1];
                    line.positions[idx + 2] = line.currentPos[2];

                    line.index++;

                    // Update geometry every 5 steps for performance
                    if (step % 5 === 0 && line.index > 2) {
                        line.geometry.attributes.position.needsUpdate = true;
                        line.geometry.setDrawRange(0, Math.min(line.index, trailLength));
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        // Controls
        document.getElementById('sigma').addEventListener('input', (e) => {
            params.sigma = parseFloat(e.target.value);
            document.getElementById('sigma-val').textContent = params.sigma.toFixed(1);
        });

        document.getElementById('rho').addEventListener('input', (e) => {
            params.rho = parseFloat(e.target.value);
            document.getElementById('rho-val').textContent = params.rho.toFixed(1);
        });

        document.getElementById('beta').addEventListener('input', (e) => {
            params.beta = parseFloat(e.target.value);
            document.getElementById('beta-val').textContent = params.beta.toFixed(2);
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speed-val').textContent = params.speed.toFixed(1);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
