<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seam Carving Content-Aware Resize - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e6e1;
            min-height: 100vh;
            padding: 60px 20px 20px;
        }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: #a78bfa;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover { background: rgba(167, 139, 250, 0.2); }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #a78bfa;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .canvas-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .canvas-container h3 {
            color: #a78bfa;
            font-size: 14px;
            margin-bottom: 10px;
        }
        canvas {
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            max-width: 100%;
        }

        .controls {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        label { font-size: 13px; color: #888; }
        input[type="range"] { width: 120px; accent-color: #a78bfa; }
        select, input[type="file"] {
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: white;
        }
        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #a78bfa, #8b5cf6);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(167, 139, 250, 0.4); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        button.secondary { background: linear-gradient(135deg, #64748b, #475569); }

        .info-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .info-panel h3 { color: #a78bfa; margin-bottom: 10px; font-size: 14px; }
        .info-panel p { color: #aaa; font-size: 13px; line-height: 1.6; }

        .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #a78bfa, #8b5cf6);
            width: 0%;
            transition: width 0.1s;
        }

        .size-display {
            font-family: monospace;
            color: #a78bfa;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Visualization Algorithms</a>

    <div class="container">
        <h1>Seam Carving Content-Aware Resize</h1>

        <div class="info-panel">
            <h3>How It Works</h3>
            <p>Seam carving removes paths of lowest "energy" (importance) to resize images without distorting key features.
            The algorithm computes pixel energy using gradient magnitude, then finds minimum-energy vertical or horizontal seams
            using dynamic programming. Watch as seams are removed one by one!</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Sample Image:</label>
                <select id="sampleImage">
                    <option value="gradient">Color Gradient</option>
                    <option value="circles">Circles</option>
                    <option value="landscape">Simple Landscape</option>
                    <option value="face">Face Pattern</option>
                </select>
            </div>
            <div class="control-group">
                <label>Or upload:</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            <div class="control-group">
                <label>Seams to remove:</label>
                <input type="range" id="seamCount" min="10" max="200" value="50">
                <span id="seamValue">50</span>
            </div>
            <button id="carveBtn" onclick="startCarving()">Carve Seams</button>
            <button class="secondary" onclick="resetImage()">Reset</button>
            <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
        </div>

        <div class="canvas-row">
            <div class="canvas-container">
                <h3>Original Image</h3>
                <canvas id="originalCanvas" width="400" height="300"></canvas>
                <div class="size-display" id="origSize">400 x 300</div>
            </div>
            <div class="canvas-container">
                <h3>Energy Map</h3>
                <canvas id="energyCanvas" width="400" height="300"></canvas>
            </div>
            <div class="canvas-container">
                <h3>Result (Content-Aware)</h3>
                <canvas id="resultCanvas" width="400" height="300"></canvas>
                <div class="size-display" id="resultSize">400 x 300</div>
            </div>
        </div>

        <div class="canvas-row">
            <div class="canvas-container">
                <h3>Seams Visualization</h3>
                <canvas id="seamsCanvas" width="400" height="300"></canvas>
                <p style="font-size:11px; color:#666; margin-top:8px;">Red lines show removed seams</p>
            </div>
            <div class="canvas-container">
                <h3>Standard Resize (for comparison)</h3>
                <canvas id="standardCanvas" width="400" height="300"></canvas>
                <div class="size-display" id="stdSize">400 x 300</div>
            </div>
        </div>
    </div>

    <script>
        const originalCanvas = document.getElementById('originalCanvas');
        const energyCanvas = document.getElementById('energyCanvas');
        const resultCanvas = document.getElementById('resultCanvas');
        const seamsCanvas = document.getElementById('seamsCanvas');
        const standardCanvas = document.getElementById('standardCanvas');

        const origCtx = originalCanvas.getContext('2d');
        const energyCtx = energyCanvas.getContext('2d');
        const resultCtx = resultCanvas.getContext('2d');
        const seamsCtx = seamsCanvas.getContext('2d');
        const stdCtx = standardCanvas.getContext('2d');

        let originalImageData = null;
        let currentImageData = null;
        let width = 400;
        let height = 300;
        let removedSeams = [];

        // Generate sample images
        function generateSampleImage(type) {
            origCtx.fillStyle = '#333';
            origCtx.fillRect(0, 0, width, height);

            if (type === 'gradient') {
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        const r = Math.floor((x / width) * 255);
                        const g = Math.floor((y / height) * 255);
                        const b = 128;
                        origCtx.fillStyle = `rgb(${r},${g},${b})`;
                        origCtx.fillRect(x, y, 1, 1);
                    }
                }
                // Add some circles as features
                origCtx.fillStyle = '#ff6b6b';
                origCtx.beginPath();
                origCtx.arc(100, 150, 50, 0, Math.PI * 2);
                origCtx.fill();
                origCtx.fillStyle = '#4ecdc4';
                origCtx.beginPath();
                origCtx.arc(300, 150, 40, 0, Math.PI * 2);
                origCtx.fill();
            } else if (type === 'circles') {
                origCtx.fillStyle = '#1a1a2e';
                origCtx.fillRect(0, 0, width, height);
                const colors = ['#ff6b6b', '#4ecdc4', '#ffd93d', '#6bcb77', '#a78bfa'];
                for (let i = 0; i < 8; i++) {
                    origCtx.fillStyle = colors[i % colors.length];
                    origCtx.beginPath();
                    origCtx.arc(
                        50 + Math.random() * (width - 100),
                        50 + Math.random() * (height - 100),
                        20 + Math.random() * 30,
                        0, Math.PI * 2
                    );
                    origCtx.fill();
                }
            } else if (type === 'landscape') {
                // Sky
                const skyGrad = origCtx.createLinearGradient(0, 0, 0, height * 0.6);
                skyGrad.addColorStop(0, '#1e3a5f');
                skyGrad.addColorStop(1, '#ff7e5f');
                origCtx.fillStyle = skyGrad;
                origCtx.fillRect(0, 0, width, height * 0.6);

                // Sun
                origCtx.fillStyle = '#ffd93d';
                origCtx.beginPath();
                origCtx.arc(width * 0.7, height * 0.3, 30, 0, Math.PI * 2);
                origCtx.fill();

                // Ground
                origCtx.fillStyle = '#2d5016';
                origCtx.fillRect(0, height * 0.6, width, height * 0.4);

                // Tree
                origCtx.fillStyle = '#3d2914';
                origCtx.fillRect(80, height * 0.4, 20, height * 0.3);
                origCtx.fillStyle = '#228b22';
                origCtx.beginPath();
                origCtx.arc(90, height * 0.35, 50, 0, Math.PI * 2);
                origCtx.fill();
            } else if (type === 'face') {
                origCtx.fillStyle = '#f4d9c6';
                origCtx.fillRect(0, 0, width, height);
                // Simple face
                origCtx.fillStyle = '#ffe0bd';
                origCtx.beginPath();
                origCtx.arc(width/2, height/2, 80, 0, Math.PI * 2);
                origCtx.fill();
                // Eyes
                origCtx.fillStyle = '#333';
                origCtx.beginPath();
                origCtx.arc(width/2 - 25, height/2 - 15, 10, 0, Math.PI * 2);
                origCtx.fill();
                origCtx.beginPath();
                origCtx.arc(width/2 + 25, height/2 - 15, 10, 0, Math.PI * 2);
                origCtx.fill();
                // Mouth
                origCtx.strokeStyle = '#333';
                origCtx.lineWidth = 3;
                origCtx.beginPath();
                origCtx.arc(width/2, height/2 + 20, 25, 0.2, Math.PI - 0.2);
                origCtx.stroke();
            }

            originalImageData = origCtx.getImageData(0, 0, width, height);
            currentImageData = origCtx.getImageData(0, 0, width, height);
            updateEnergy();
            updateSizeDisplays();
        }

        // Compute energy (gradient magnitude)
        function computeEnergy(imageData) {
            const w = imageData.width;
            const h = imageData.height;
            const data = imageData.data;
            const energy = new Float32Array(w * h);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;

                    // Get neighbors
                    const left = x > 0 ? (y * w + x - 1) * 4 : idx;
                    const right = x < w - 1 ? (y * w + x + 1) * 4 : idx;
                    const up = y > 0 ? ((y - 1) * w + x) * 4 : idx;
                    const down = y < h - 1 ? ((y + 1) * w + x) * 4 : idx;

                    // Gradient in x
                    const gx = Math.abs(data[right] - data[left]) +
                               Math.abs(data[right + 1] - data[left + 1]) +
                               Math.abs(data[right + 2] - data[left + 2]);

                    // Gradient in y
                    const gy = Math.abs(data[down] - data[up]) +
                               Math.abs(data[down + 1] - data[up + 1]) +
                               Math.abs(data[down + 2] - data[up + 2]);

                    energy[y * w + x] = Math.sqrt(gx * gx + gy * gy);
                }
            }

            return energy;
        }

        // Find minimum seam using dynamic programming
        function findMinSeam(energy, w, h) {
            // Cumulative energy
            const dp = new Float32Array(w * h);
            const path = new Int32Array(w * h);

            // First row
            for (let x = 0; x < w; x++) {
                dp[x] = energy[x];
            }

            // Fill DP table
            for (let y = 1; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    const above = (y - 1) * w + x;

                    let minE = dp[above];
                    let minX = x;

                    if (x > 0 && dp[above - 1] < minE) {
                        minE = dp[above - 1];
                        minX = x - 1;
                    }
                    if (x < w - 1 && dp[above + 1] < minE) {
                        minE = dp[above + 1];
                        minX = x + 1;
                    }

                    dp[idx] = energy[idx] + minE;
                    path[idx] = minX;
                }
            }

            // Find minimum in last row
            let minX = 0;
            let minVal = dp[(h - 1) * w];
            for (let x = 1; x < w; x++) {
                if (dp[(h - 1) * w + x] < minVal) {
                    minVal = dp[(h - 1) * w + x];
                    minX = x;
                }
            }

            // Backtrack to find seam
            const seam = new Int32Array(h);
            seam[h - 1] = minX;
            for (let y = h - 2; y >= 0; y--) {
                seam[y] = path[(y + 1) * w + seam[y + 1]];
            }

            return seam;
        }

        // Remove seam from image
        function removeSeam(imageData, seam) {
            const w = imageData.width;
            const h = imageData.height;
            const newW = w - 1;
            const newData = new Uint8ClampedArray(newW * h * 4);

            for (let y = 0; y < h; y++) {
                let newX = 0;
                for (let x = 0; x < w; x++) {
                    if (x !== seam[y]) {
                        const oldIdx = (y * w + x) * 4;
                        const newIdx = (y * newW + newX) * 4;
                        newData[newIdx] = imageData.data[oldIdx];
                        newData[newIdx + 1] = imageData.data[oldIdx + 1];
                        newData[newIdx + 2] = imageData.data[oldIdx + 2];
                        newData[newIdx + 3] = imageData.data[oldIdx + 3];
                        newX++;
                    }
                }
            }

            return new ImageData(newData, newW, h);
        }

        function updateEnergy() {
            if (!currentImageData) return;
            const energy = computeEnergy(currentImageData);
            const w = currentImageData.width;
            const h = currentImageData.height;

            // Normalize and display
            let maxE = 0;
            for (let i = 0; i < energy.length; i++) {
                maxE = Math.max(maxE, energy[i]);
            }

            const energyImageData = energyCtx.createImageData(w, h);
            for (let i = 0; i < energy.length; i++) {
                const val = Math.floor((energy[i] / maxE) * 255);
                energyImageData.data[i * 4] = val;
                energyImageData.data[i * 4 + 1] = val;
                energyImageData.data[i * 4 + 2] = val;
                energyImageData.data[i * 4 + 3] = 255;
            }

            energyCanvas.width = w;
            energyCanvas.height = h;
            energyCtx.putImageData(energyImageData, 0, 0);
        }

        function updateSizeDisplays() {
            const origW = originalImageData ? originalImageData.width : 0;
            const origH = originalImageData ? originalImageData.height : 0;
            const currW = currentImageData ? currentImageData.width : 0;

            document.getElementById('origSize').textContent = `${origW} x ${origH}`;
            document.getElementById('resultSize').textContent = `${currW} x ${origH}`;
            document.getElementById('stdSize').textContent = `${currW} x ${origH}`;
        }

        async function startCarving() {
            if (!originalImageData) return;

            const seamCount = parseInt(document.getElementById('seamCount').value);
            const btn = document.getElementById('carveBtn');
            btn.disabled = true;

            // Reset
            currentImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            removedSeams = [];

            // Copy original to seams canvas
            seamsCanvas.width = originalImageData.width;
            seamsCanvas.height = originalImageData.height;
            seamsCtx.putImageData(originalImageData, 0, 0);

            for (let i = 0; i < seamCount && currentImageData.width > 50; i++) {
                // Compute energy
                const energy = computeEnergy(currentImageData);

                // Find seam
                const seam = findMinSeam(energy, currentImageData.width, currentImageData.height);

                // Store seam (offset by removed seams)
                removedSeams.push([...seam]);

                // Draw seam on visualization
                seamsCtx.fillStyle = 'rgba(255, 50, 50, 0.5)';
                for (let y = 0; y < seam.length; y++) {
                    let offsetX = seam[y];
                    // Account for previously removed seams
                    for (let j = 0; j < i; j++) {
                        if (removedSeams[j][y] <= offsetX) offsetX++;
                    }
                    seamsCtx.fillRect(offsetX, y, 1, 1);
                }

                // Remove seam
                currentImageData = removeSeam(currentImageData, seam);

                // Update progress
                document.getElementById('progress').style.width = ((i + 1) / seamCount * 100) + '%';

                // Update displays periodically
                if (i % 5 === 0 || i === seamCount - 1) {
                    resultCanvas.width = currentImageData.width;
                    resultCanvas.height = currentImageData.height;
                    resultCtx.putImageData(currentImageData, 0, 0);
                    updateEnergy();
                    updateSizeDisplays();

                    // Standard resize for comparison
                    standardCanvas.width = currentImageData.width;
                    standardCanvas.height = originalImageData.height;
                    stdCtx.drawImage(originalCanvas, 0, 0, currentImageData.width, originalImageData.height);

                    await new Promise(r => setTimeout(r, 10));
                }
            }

            btn.disabled = false;
        }

        function resetImage() {
            if (!originalImageData) return;

            currentImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            removedSeams = [];

            resultCanvas.width = originalImageData.width;
            resultCanvas.height = originalImageData.height;
            resultCtx.putImageData(originalImageData, 0, 0);

            seamsCanvas.width = originalImageData.width;
            seamsCanvas.height = originalImageData.height;
            seamsCtx.putImageData(originalImageData, 0, 0);

            standardCanvas.width = originalImageData.width;
            standardCanvas.height = originalImageData.height;
            stdCtx.putImageData(originalImageData, 0, 0);

            updateEnergy();
            updateSizeDisplays();
            document.getElementById('progress').style.width = '0%';
        }

        // Event listeners
        document.getElementById('sampleImage').addEventListener('change', (e) => {
            generateSampleImage(e.target.value);
            resetImage();
        });

        document.getElementById('seamCount').addEventListener('input', (e) => {
            document.getElementById('seamValue').textContent = e.target.value;
        });

        document.getElementById('imageInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.onload = () => {
                    width = Math.min(img.width, 500);
                    height = Math.min(img.height, 400);

                    originalCanvas.width = width;
                    originalCanvas.height = height;
                    origCtx.drawImage(img, 0, 0, width, height);

                    originalImageData = origCtx.getImageData(0, 0, width, height);
                    currentImageData = origCtx.getImageData(0, 0, width, height);

                    resetImage();
                };
                img.src = URL.createObjectURL(file);
            }
        });

        // Initialize
        generateSampleImage('gradient');
        resetImage();
    </script>
</body>
</html>
