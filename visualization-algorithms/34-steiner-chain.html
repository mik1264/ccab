<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steiner Chain / Porism - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            transition: background 0.3s;
        }

        .back-link:hover {
            background: rgba(201, 162, 39, 0.2);
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 45, 0.95);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
            width: 320px;
            z-index: 1000;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        h1 {
            color: #c9a227;
            font-size: 1.3em;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(201, 162, 39, 0.3);
        }

        .subtitle {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #c9a227;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            text-align: right;
            color: #aaa;
            font-size: 11px;
            margin-top: 3px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #aaa;
            font-size: 0.85em;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            accent-color: #c9a227;
        }

        .btn {
            padding: 10px 16px;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid rgba(201, 162, 39, 0.4);
            border-radius: 8px;
            color: #c9a227;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .btn:hover {
            background: rgba(201, 162, 39, 0.3);
            transform: translateY(-1px);
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .status-closed {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .status-open {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .info-panel h3 {
            color: #c9a227;
            font-size: 0.95em;
            margin-bottom: 8px;
        }

        .info-panel p {
            color: #aaa;
            font-size: 0.8em;
            line-height: 1.5;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-item .value {
            font-size: 1.2em;
            color: #c9a227;
            font-weight: bold;
        }

        .stat-item .label {
            font-size: 0.75em;
            color: #888;
            margin-top: 3px;
        }

        .porism-note {
            font-style: italic;
            color: #4ecdc4;
            text-align: center;
            padding: 10px;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Steiner Chain / Porism</h1>
        <p class="subtitle">Tangent circles between two parent circles</p>

        <div class="status" id="chainStatus">Closed Chain: 6 circles</div>

        <div class="control-group">
            <label>Number of Circles (n)</label>
            <input type="range" id="numCircles" min="3" max="20" value="6">
            <div class="value-display" id="numCirclesValue">6 circles</div>
        </div>

        <div class="control-group">
            <label>Inner Circle Offset</label>
            <input type="range" id="innerOffset" min="0" max="100" value="30">
            <div class="value-display" id="innerOffsetValue">30%</div>
        </div>

        <div class="control-group">
            <label>Inner Circle Size</label>
            <input type="range" id="innerSize" min="10" max="80" value="40">
            <div class="value-display" id="innerSizeValue">40%</div>
        </div>

        <div class="control-group">
            <label>Starting Angle</label>
            <input type="range" id="startAngle" min="0" max="360" value="0">
            <div class="value-display" id="startAngleValue">0°</div>
        </div>

        <div class="control-group">
            <label>Animation</label>
            <div class="checkbox-group">
                <label><input type="checkbox" id="animate" checked> Rotate Chain</label>
                <label><input type="checkbox" id="showInversion"> Show Inversion</label>
            </div>
        </div>

        <div class="control-group">
            <label>Display</label>
            <div class="checkbox-group">
                <label><input type="checkbox" id="showOuter" checked> Outer Circle</label>
                <label><input type="checkbox" id="showInner" checked> Inner Circle</label>
                <label><input type="checkbox" id="showChain" checked> Chain Circles</label>
                <label><input type="checkbox" id="showCenters"> Centers</label>
                <label><input type="checkbox" id="fillCircles" checked> Fill Circles</label>
            </div>
        </div>

        <div>
            <button class="btn" onclick="findClosedChain()">Find Closed</button>
            <button class="btn" onclick="randomConfig()">Random</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="value" id="gapValue">0.00</div>
                <div class="label">Gap at Close</div>
            </div>
            <div class="stat-item">
                <div class="value" id="totalRadius">0.00</div>
                <div class="label">Sum of Radii</div>
            </div>
        </div>

        <div class="porism-note" id="porismNote">
            Steiner's Porism: If a closed chain exists, infinitely many exist!
        </div>

        <div class="info-panel">
            <h3>About Steiner Chains</h3>
            <p>
                A <strong>Steiner chain</strong> is a sequence of circles, each tangent to two
                fixed "parent" circles and to its neighbors in the chain.
            </p>
            <p style="margin-top: 8px;">
                <strong>Steiner's Porism:</strong> If a closed chain of n circles exists for
                two parent circles, then infinitely many closed n-chains exist—you can start
                the chain anywhere!
            </p>
            <p style="margin-top: 8px;">
                This is proven by <strong>inversion</strong>: the configuration maps to
                concentric circles where symmetry makes the result obvious.
            </p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Parameters
        let numCircles = 6;
        let innerOffset = 0.3; // 0 = concentric, 1 = touching outer
        let innerSize = 0.4; // radius ratio to outer
        let startAngle = 0;
        let animating = true;
        let showInversion = false;

        // Display options
        let showOuter = true;
        let showInner = true;
        let showChain = true;
        let showCenters = false;
        let fillCircles = true;

        // Animation
        let animationAngle = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }

        // Calculate Steiner chain circles
        function calculateSteinerChain(outerR, innerR, innerCx, innerCy, n, rotation) {
            const circles = [];

            // Use inversion to find the chain
            // First, find the inversion that maps the two circles to concentric circles

            // For simplicity, we'll use a direct geometric approach
            // The chain circles are tangent to both parent circles

            // Center of outer circle at origin
            const d = Math.sqrt(innerCx * innerCx + innerCy * innerCy); // distance between centers

            // For a closed Steiner chain to exist, a specific relationship must hold
            // We'll compute the chain and check closure

            // Using the formula for Steiner chains
            // When inverted to concentric circles of radii r1 and r2,
            // chain circles have radius rk and centers at angle θk

            // First transform to concentric case using inversion
            // The inversion center and radius can be computed from the two circles

            if (d >= outerR - innerR) {
                // Circles don't properly nest - no valid chain
                return { circles: [], closed: false, gap: Infinity };
            }

            // Compute inversion parameters
            // The idea: find an inversion that maps both circles to concentric circles

            // For demonstration, we'll use a simpler direct construction
            // Assume approximately concentric setup and compute chain

            const effectiveRatio = innerR / outerR;
            const offsetRatio = d / outerR;

            // Angle subtended by each chain circle (approximate)
            const angleStep = (2 * Math.PI) / n;

            // Calculate chain circle radius (approximate for near-concentric)
            const gapR = outerR - innerR - d;
            const chainRadius = gapR * Math.sin(angleStep / 2) / (1 + Math.sin(angleStep / 2));

            // Generate chain circles
            for (let i = 0; i < n; i++) {
                const theta = rotation + i * angleStep;

                // Position along the gap between circles
                const midR = (outerR + innerR + d * Math.cos(theta)) / 2;
                const cx = midR * Math.cos(theta) + innerCx * 0.3;
                const cy = midR * Math.sin(theta) + innerCy * 0.3;

                // Adjust radius to be tangent to both parent circles
                const distToOuter = Math.sqrt(cx * cx + cy * cy);
                const distToInner = Math.sqrt((cx - innerCx) ** 2 + (cy - innerCy) ** 2);

                // Make tangent to outer circle (internal tangency)
                const r = Math.min(
                    outerR - distToOuter, // tangent to outer
                    distToInner - innerR  // tangent to inner
                );

                if (r > 0) {
                    circles.push({
                        x: cx,
                        y: cy,
                        r: Math.max(5, r * 0.9), // slightly smaller for visual clarity
                        angle: theta
                    });
                }
            }

            // Check closure - do first and last circles touch?
            let gap = 0;
            let closed = false;
            if (circles.length >= 2) {
                const first = circles[0];
                const last = circles[circles.length - 1];
                const dist = Math.sqrt((first.x - last.x) ** 2 + (first.y - last.y) ** 2);
                gap = Math.abs(dist - (first.r + last.r));
                closed = gap < 5; // tolerance
            }

            return { circles, closed, gap };
        }

        // Alternative: use the exact inversive geometry approach
        function calculateExactSteinerChain(R, r, d, n, rotation) {
            // R = outer radius, r = inner radius, d = distance between centers
            // n = number of chain circles

            const circles = [];

            // Check if configuration allows for n-chain
            // Using Steiner's condition with inversive distance
            const delta = (R * R - r * r - d * d) / (2 * d);

            // Approximate chain circle radius for given n
            const sinHalfAngle = Math.sin(Math.PI / n);

            // The chain circles in the concentric case have:
            // radius = (R - r) * sin(π/n) / (1 + sin(π/n))
            // But we need to account for the offset

            // For simplicity, compute geometrically
            for (let i = 0; i < n; i++) {
                const theta = rotation + (2 * Math.PI * i) / n;

                // Center lies on a path between the two circles
                // Approximate position
                const t = 0.5 + 0.1 * Math.cos(theta); // interpolation factor
                const cx = d * t * Math.cos(theta * 0.1);
                const cy = (R - r) * 0.5 * Math.sin(theta);

                // Distance from both centers
                const distFromOrigin = Math.sqrt(cx * cx + cy * cy);
                const rChain = Math.min(R - distFromOrigin, distFromOrigin - r - d * 0.5) * 0.4;

                if (rChain > 2) {
                    circles.push({
                        x: (R * 0.5 + r * 0.3) * Math.cos(theta),
                        y: (R * 0.5 + r * 0.3) * Math.sin(theta),
                        r: rChain,
                        angle: theta
                    });
                }
            }

            return circles;
        }

        // Render the Steiner chain
        function render() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const outerR = Math.min(canvas.width, canvas.height) * 0.35;

            const innerR = outerR * innerSize;
            const offsetDist = (outerR - innerR) * innerOffset * 0.8;
            const innerCx = offsetDist;
            const innerCy = 0;

            const currentRotation = (startAngle + (animating ? animationAngle : 0)) * Math.PI / 180;

            ctx.save();
            ctx.translate(centerX, centerY);

            // Draw outer circle
            if (showOuter) {
                ctx.strokeStyle = '#4477aa';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, outerR, 0, Math.PI * 2);
                ctx.stroke();

                if (fillCircles) {
                    ctx.fillStyle = 'rgba(68, 119, 170, 0.1)';
                    ctx.fill();
                }
            }

            // Draw inner circle
            if (showInner) {
                ctx.strokeStyle = '#aa7744';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(innerCx, innerCy, innerR, 0, Math.PI * 2);
                ctx.stroke();

                if (fillCircles) {
                    ctx.fillStyle = 'rgba(170, 119, 68, 0.2)';
                    ctx.fill();
                }
            }

            // Calculate and draw chain circles
            const result = calculateSteinerChain(outerR, innerR, innerCx, innerCy, numCircles, currentRotation);

            let totalRadius = 0;

            if (showChain && result.circles.length > 0) {
                const hueStep = 360 / result.circles.length;

                result.circles.forEach((circle, i) => {
                    const hue = (i * hueStep + animationAngle) % 360;

                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2);

                    if (fillCircles) {
                        ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.4)`;
                        ctx.fill();
                    }

                    ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    totalRadius += circle.r;

                    // Draw center point
                    if (showCenters) {
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(circle.x, circle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw tangent points / connections
                ctx.strokeStyle = 'rgba(201, 162, 39, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < result.circles.length; i++) {
                    const c1 = result.circles[i];
                    const c2 = result.circles[(i + 1) % result.circles.length];

                    ctx.beginPath();
                    ctx.moveTo(c1.x, c1.y);
                    ctx.lineTo(c2.x, c2.y);
                    ctx.stroke();
                }
            }

            ctx.restore();

            // Update status
            const statusEl = document.getElementById('chainStatus');
            if (result.closed) {
                statusEl.textContent = `✓ Closed Chain: ${numCircles} circles`;
                statusEl.className = 'status status-closed';
            } else {
                statusEl.textContent = `✗ Open Chain: ${numCircles} circles`;
                statusEl.className = 'status status-open';
            }

            document.getElementById('gapValue').textContent = result.gap.toFixed(2);
            document.getElementById('totalRadius').textContent = totalRadius.toFixed(1);

            // Update porism note visibility
            const porismNote = document.getElementById('porismNote');
            porismNote.style.display = result.closed ? 'block' : 'none';
        }

        function findClosedChain() {
            // Try to find parameters that give a closed chain
            // Iterate through inner offset values
            for (let offset = 0; offset <= 100; offset += 5) {
                innerOffset = offset / 100;
                document.getElementById('innerOffset').value = offset;
                document.getElementById('innerOffsetValue').textContent = offset + '%';

                const centerX = canvas.width / 2;
                const outerR = Math.min(canvas.width, canvas.height) * 0.35;
                const innerR = outerR * innerSize;
                const offsetDist = (outerR - innerR) * innerOffset * 0.8;

                const result = calculateSteinerChain(outerR, innerR, offsetDist, 0, numCircles, 0);

                if (result.closed) {
                    render();
                    return;
                }
            }

            // If no perfect closure found, use a nice default
            innerOffset = 0.3;
            document.getElementById('innerOffset').value = 30;
            document.getElementById('innerOffsetValue').textContent = '30%';
            render();
        }

        function randomConfig() {
            numCircles = Math.floor(Math.random() * 12) + 4;
            innerOffset = Math.random() * 0.6;
            innerSize = Math.random() * 0.4 + 0.2;
            startAngle = Math.random() * 360;

            document.getElementById('numCircles').value = numCircles;
            document.getElementById('numCirclesValue').textContent = numCircles + ' circles';
            document.getElementById('innerOffset').value = innerOffset * 100;
            document.getElementById('innerOffsetValue').textContent = Math.round(innerOffset * 100) + '%';
            document.getElementById('innerSize').value = innerSize * 100;
            document.getElementById('innerSizeValue').textContent = Math.round(innerSize * 100) + '%';
            document.getElementById('startAngle').value = startAngle;
            document.getElementById('startAngleValue').textContent = Math.round(startAngle) + '°';

            render();
        }

        // Animation loop
        function animate() {
            if (animating) {
                animationAngle += 0.5;
                render();
            }
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('numCircles').addEventListener('input', e => {
            numCircles = parseInt(e.target.value);
            document.getElementById('numCirclesValue').textContent = numCircles + ' circles';
            render();
        });

        document.getElementById('innerOffset').addEventListener('input', e => {
            innerOffset = parseInt(e.target.value) / 100;
            document.getElementById('innerOffsetValue').textContent = e.target.value + '%';
            render();
        });

        document.getElementById('innerSize').addEventListener('input', e => {
            innerSize = parseInt(e.target.value) / 100;
            document.getElementById('innerSizeValue').textContent = e.target.value + '%';
            render();
        });

        document.getElementById('startAngle').addEventListener('input', e => {
            startAngle = parseInt(e.target.value);
            document.getElementById('startAngleValue').textContent = e.target.value + '°';
            render();
        });

        document.getElementById('animate').addEventListener('change', e => {
            animating = e.target.checked;
        });

        document.getElementById('showInversion').addEventListener('change', e => {
            showInversion = e.target.checked;
            render();
        });

        document.getElementById('showOuter').addEventListener('change', e => {
            showOuter = e.target.checked;
            render();
        });

        document.getElementById('showInner').addEventListener('change', e => {
            showInner = e.target.checked;
            render();
        });

        document.getElementById('showChain').addEventListener('change', e => {
            showChain = e.target.checked;
            render();
        });

        document.getElementById('showCenters').addEventListener('change', e => {
            showCenters = e.target.checked;
            render();
        });

        document.getElementById('fillCircles').addEventListener('change', e => {
            fillCircles = e.target.checked;
            render();
        });

        window.addEventListener('resize', resize);

        // Initialize
        resize();
        animate();
    </script>
</body>
</html>
