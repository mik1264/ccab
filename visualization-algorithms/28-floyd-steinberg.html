<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floyd-Steinberg Dithering - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #fd79a8, #a29bfe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .subtitle { color: #888; font-size: 1rem; }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fd79a8;
            text-decoration: none;
            font-weight: 500;
            transition: transform 0.3s;
        }
        .back-link:hover { transform: translateX(-5px); }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
        }
        .canvas-container h3 {
            color: #fd79a8;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            background: #1a1a2e;
            image-rendering: pixelated;
        }
        .controls {
            grid-column: span 2;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .panel h3 {
            color: #fd79a8;
            font-size: 1rem;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(253, 121, 168, 0.3);
            padding-bottom: 5px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            color: #fd79a8;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(253, 121, 168, 0.2);
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fd79a8;
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            min-width: 40px;
            text-align: right;
            color: #888;
            font-family: monospace;
        }
        button {
            padding: 10px 15px;
            background: rgba(253, 121, 168, 0.2);
            border: 1px solid rgba(253, 121, 168, 0.5);
            border-radius: 6px;
            color: #fd79a8;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        button:hover {
            background: rgba(253, 121, 168, 0.3);
            border-color: #fd79a8;
        }
        .method-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .method-buttons button {
            margin: 0;
        }
        .method-buttons button.active {
            background: rgba(253, 121, 168, 0.4);
            border-color: #fd79a8;
        }
        .info-text {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.6;
        }
        .kernel-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            text-align: center;
            margin-top: 10px;
        }
        .kernel-display table {
            margin: 0 auto;
            border-collapse: collapse;
        }
        .kernel-display td {
            padding: 5px 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .kernel-display .current {
            color: #fd79a8;
            font-weight: bold;
        }
        input[type="file"] {
            display: none;
        }
        .file-label {
            display: inline-block;
            padding: 10px 15px;
            background: rgba(253, 121, 168, 0.2);
            border: 1px solid rgba(253, 121, 168, 0.5);
            border-radius: 6px;
            color: #fd79a8;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }
        .file-label:hover {
            background: rgba(253, 121, 168, 0.3);
        }
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
            .controls { grid-column: span 1; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Floyd-Steinberg Dithering</h1>
            <p class="subtitle">Error diffusion algorithm for image quantization</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <h3>Original Image</h3>
                <canvas id="original" width="400" height="400"></canvas>
            </div>

            <div class="canvas-container">
                <h3>Dithered Result</h3>
                <canvas id="dithered" width="400" height="400"></canvas>
            </div>

            <div class="controls">
                <div class="panel">
                    <h3>Input Image</h3>
                    <label class="file-label">
                        <input type="file" id="file-input" accept="image/*">
                        Upload Image
                    </label>
                    <button onclick="generateGradient()">Gradient</button>
                    <button onclick="generatePhoto()">Sample Photo</button>
                    <button onclick="generateShapes()">Shapes</button>
                </div>

                <div class="panel">
                    <h3>Dithering Method</h3>
                    <div class="method-buttons">
                        <button onclick="setMethod('floyd')" class="active" id="btn-floyd">Floyd-Steinberg</button>
                        <button onclick="setMethod('atkinson')" id="btn-atkinson">Atkinson</button>
                        <button onclick="setMethod('stucki')" id="btn-stucki">Stucki</button>
                        <button onclick="setMethod('sierra')" id="btn-sierra">Sierra</button>
                        <button onclick="setMethod('ordered')" id="btn-ordered">Ordered (Bayer)</button>
                        <button onclick="setMethod('none')" id="btn-none">None (Threshold)</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Settings</h3>
                    <div class="control-group">
                        <label>Color Levels (per channel)</label>
                        <div class="control-row">
                            <input type="range" id="levels" min="2" max="16" value="2">
                            <span class="value-display" id="levels-val">2</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Threshold Bias</label>
                        <div class="control-row">
                            <input type="range" id="threshold" min="0" max="255" value="128">
                            <span class="value-display" id="threshold-val">128</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Serpentine Scanning</label>
                        <div class="control-row">
                            <input type="checkbox" id="serpentine" checked>
                            <span style="color: #888; font-size: 0.85rem;">Alternate row direction</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Error Diffusion Kernel</h3>
                    <div class="kernel-display" id="kernel-display">
                        <table>
                            <tr><td></td><td class="current">*</td><td>7/16</td></tr>
                            <tr><td>3/16</td><td>5/16</td><td>1/16</td></tr>
                        </table>
                    </div>
                    <p class="info-text" style="margin-top: 10px;">
                        The error from quantizing each pixel is distributed to neighboring pixels according to these weights.
                    </p>
                </div>

                <div class="panel">
                    <h3>About</h3>
                    <p class="info-text">
                        Floyd-Steinberg dithering diffuses quantization error to neighboring pixels,
                        creating the illusion of more colors using only a limited palette. The serpentine
                        scan alternates direction each row to prevent diagonal artifacts.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const originalCanvas = document.getElementById('original');
        const ditheredCanvas = document.getElementById('dithered');
        const origCtx = originalCanvas.getContext('2d');
        const dithCtx = ditheredCanvas.getContext('2d');

        let originalImageData = null;
        let currentMethod = 'floyd';
        let levels = 2;
        let threshold = 128;
        let serpentine = true;

        // Error diffusion kernels
        const kernels = {
            floyd: {
                matrix: [[0, 0, 7], [3, 5, 1]],
                divisor: 16,
                offsetY: 0
            },
            atkinson: {
                matrix: [[0, 0, 1, 1], [1, 1, 1, 0], [0, 1, 0, 0]],
                divisor: 8,
                offsetY: 0
            },
            stucki: {
                matrix: [[0, 0, 0, 8, 4], [2, 4, 8, 4, 2], [1, 2, 4, 2, 1]],
                divisor: 42,
                offsetY: 0
            },
            sierra: {
                matrix: [[0, 0, 0, 5, 3], [2, 4, 5, 4, 2], [0, 2, 3, 2, 0]],
                divisor: 32,
                offsetY: 0
            }
        };

        // Bayer matrix for ordered dithering
        const bayer4x4 = [
            [0, 8, 2, 10],
            [12, 4, 14, 6],
            [3, 11, 1, 9],
            [15, 7, 13, 5]
        ];

        function quantize(value, levels) {
            const step = 255 / (levels - 1);
            return Math.round(Math.round(value / step) * step);
        }

        function applyDithering() {
            if (!originalImageData) return;

            const width = originalCanvas.width;
            const height = originalCanvas.height;

            // Create a copy of image data as float array for error accumulation
            const pixels = new Float32Array(width * height * 4);
            for (let i = 0; i < originalImageData.data.length; i++) {
                pixels[i] = originalImageData.data[i];
            }

            const output = dithCtx.createImageData(width, height);

            if (currentMethod === 'none') {
                // Simple threshold
                for (let i = 0; i < pixels.length; i += 4) {
                    for (let c = 0; c < 3; c++) {
                        output.data[i + c] = quantize(pixels[i + c], levels);
                    }
                    output.data[i + 3] = 255;
                }
            } else if (currentMethod === 'ordered') {
                // Ordered (Bayer) dithering
                const matrixSize = 4;
                const scale = 255 / 16;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const bayerValue = bayer4x4[y % matrixSize][x % matrixSize] * scale - 128;

                        for (let c = 0; c < 3; c++) {
                            const adjusted = pixels[idx + c] + bayerValue * (256 / levels / 2);
                            output.data[idx + c] = quantize(Math.max(0, Math.min(255, adjusted)), levels);
                        }
                        output.data[idx + 3] = 255;
                    }
                }
            } else {
                // Error diffusion dithering
                const kernel = kernels[currentMethod];
                const kWidth = kernel.matrix[0].length;
                const kHeight = kernel.matrix.length;
                const kOffsetX = Math.floor(kWidth / 2);

                for (let y = 0; y < height; y++) {
                    const leftToRight = !serpentine || (y % 2 === 0);
                    const xStart = leftToRight ? 0 : width - 1;
                    const xEnd = leftToRight ? width : -1;
                    const xStep = leftToRight ? 1 : -1;

                    for (let x = xStart; x !== xEnd; x += xStep) {
                        const idx = (y * width + x) * 4;

                        for (let c = 0; c < 3; c++) {
                            const oldPixel = Math.max(0, Math.min(255, pixels[idx + c]));
                            const newPixel = quantize(oldPixel, levels);
                            const error = oldPixel - newPixel;

                            output.data[idx + c] = newPixel;

                            // Distribute error
                            for (let ky = 0; ky < kHeight; ky++) {
                                for (let kx = 0; kx < kWidth; kx++) {
                                    const weight = kernel.matrix[ky][kx];
                                    if (weight === 0) continue;

                                    const nx = leftToRight ?
                                        x + kx - kOffsetX :
                                        x - (kx - kOffsetX);
                                    const ny = y + ky;

                                    if (nx >= 0 && nx < width && ny < height) {
                                        const nIdx = (ny * width + nx) * 4;
                                        pixels[nIdx + c] += error * weight / kernel.divisor;
                                    }
                                }
                            }
                        }
                        output.data[idx + 3] = 255;
                    }
                }
            }

            dithCtx.putImageData(output, 0, 0);
        }

        function setMethod(method) {
            currentMethod = method;
            document.querySelectorAll('.method-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('btn-' + method).classList.add('active');
            updateKernelDisplay();
            applyDithering();
        }

        function updateKernelDisplay() {
            const display = document.getElementById('kernel-display');

            if (currentMethod === 'none') {
                display.innerHTML = '<p>No error diffusion<br>(simple threshold)</p>';
            } else if (currentMethod === 'ordered') {
                display.innerHTML = `
                    <table>
                        <tr><td>0</td><td>8</td><td>2</td><td>10</td></tr>
                        <tr><td>12</td><td>4</td><td>14</td><td>6</td></tr>
                        <tr><td>3</td><td>11</td><td>1</td><td>9</td></tr>
                        <tr><td>15</td><td>7</td><td>13</td><td>5</td></tr>
                    </table>
                    <p style="margin-top: 8px; font-size: 0.7rem;">4×4 Bayer Matrix</p>
                `;
            } else {
                const kernel = kernels[currentMethod];
                let html = '<table>';
                for (let y = 0; y < kernel.matrix.length; y++) {
                    html += '<tr>';
                    for (let x = 0; x < kernel.matrix[y].length; x++) {
                        const val = kernel.matrix[y][x];
                        if (y === 0 && x === Math.floor(kernel.matrix[0].length / 2)) {
                            html += '<td class="current">*</td>';
                        } else if (val === 0) {
                            html += '<td></td>';
                        } else {
                            html += `<td>${val}/${kernel.divisor}</td>`;
                        }
                    }
                    html += '</tr>';
                }
                html += '</table>';
                display.innerHTML = html;
            }
        }

        function generateGradient() {
            const width = originalCanvas.width;
            const height = originalCanvas.height;

            origCtx.clearRect(0, 0, width, height);

            // Horizontal gradient
            const gradient = origCtx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, '#fff');
            origCtx.fillStyle = gradient;
            origCtx.fillRect(0, 0, width, height);

            originalImageData = origCtx.getImageData(0, 0, width, height);
            applyDithering();
        }

        function generatePhoto() {
            const width = originalCanvas.width;
            const height = originalCanvas.height;

            origCtx.clearRect(0, 0, width, height);

            // Generate a simple "photo-like" image with gradients and shapes
            // Sky gradient
            const skyGrad = origCtx.createLinearGradient(0, 0, 0, height * 0.6);
            skyGrad.addColorStop(0, '#87CEEB');
            skyGrad.addColorStop(1, '#E0F6FF');
            origCtx.fillStyle = skyGrad;
            origCtx.fillRect(0, 0, width, height * 0.6);

            // Ground
            const groundGrad = origCtx.createLinearGradient(0, height * 0.6, 0, height);
            groundGrad.addColorStop(0, '#228B22');
            groundGrad.addColorStop(1, '#1a6b1a');
            origCtx.fillStyle = groundGrad;
            origCtx.fillRect(0, height * 0.6, width, height * 0.4);

            // Sun
            const sunGrad = origCtx.createRadialGradient(320, 80, 0, 320, 80, 60);
            sunGrad.addColorStop(0, '#FFD700');
            sunGrad.addColorStop(0.7, '#FFA500');
            sunGrad.addColorStop(1, 'rgba(255, 165, 0, 0)');
            origCtx.fillStyle = sunGrad;
            origCtx.beginPath();
            origCtx.arc(320, 80, 60, 0, Math.PI * 2);
            origCtx.fill();

            // Mountains
            origCtx.fillStyle = '#4a7c4a';
            origCtx.beginPath();
            origCtx.moveTo(0, height * 0.6);
            origCtx.lineTo(100, height * 0.35);
            origCtx.lineTo(200, height * 0.6);
            origCtx.fill();

            origCtx.fillStyle = '#3d6b3d';
            origCtx.beginPath();
            origCtx.moveTo(150, height * 0.6);
            origCtx.lineTo(280, height * 0.25);
            origCtx.lineTo(400, height * 0.6);
            origCtx.fill();

            // Tree
            origCtx.fillStyle = '#8B4513';
            origCtx.fillRect(80, height * 0.55, 20, height * 0.15);
            origCtx.fillStyle = '#228B22';
            origCtx.beginPath();
            origCtx.arc(90, height * 0.45, 40, 0, Math.PI * 2);
            origCtx.fill();

            originalImageData = origCtx.getImageData(0, 0, width, height);
            applyDithering();
        }

        function generateShapes() {
            const width = originalCanvas.width;
            const height = originalCanvas.height;

            origCtx.clearRect(0, 0, width, height);
            origCtx.fillStyle = '#fff';
            origCtx.fillRect(0, 0, width, height);

            // Various grayscale shapes
            for (let i = 0; i < 8; i++) {
                const gray = Math.floor((i / 7) * 255);
                origCtx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                origCtx.beginPath();
                origCtx.arc(50 + i * 45, 100, 20, 0, Math.PI * 2);
                origCtx.fill();
            }

            // Gradient circle
            const grad = origCtx.createRadialGradient(200, 250, 0, 200, 250, 80);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(1, '#000');
            origCtx.fillStyle = grad;
            origCtx.beginPath();
            origCtx.arc(200, 250, 80, 0, Math.PI * 2);
            origCtx.fill();

            // Color spectrum
            for (let x = 50; x < 350; x++) {
                const hue = (x - 50) / 300 * 360;
                origCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                origCtx.fillRect(x, 320, 1, 60);
            }

            originalImageData = origCtx.getImageData(0, 0, width, height);
            applyDithering();
        }

        // Event listeners
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = () => {
                const width = originalCanvas.width;
                const height = originalCanvas.height;

                origCtx.clearRect(0, 0, width, height);

                // Scale image to fit
                const scale = Math.min(width / img.width, height / img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                const x = (width - w) / 2;
                const y = (height - h) / 2;

                origCtx.fillStyle = '#888';
                origCtx.fillRect(0, 0, width, height);
                origCtx.drawImage(img, x, y, w, h);

                originalImageData = origCtx.getImageData(0, 0, width, height);
                applyDithering();
            };
            img.src = URL.createObjectURL(file);
        });

        document.getElementById('levels').addEventListener('input', (e) => {
            levels = parseInt(e.target.value);
            document.getElementById('levels-val').textContent = levels;
            applyDithering();
        });

        document.getElementById('threshold').addEventListener('input', (e) => {
            threshold = parseInt(e.target.value);
            document.getElementById('threshold-val').textContent = threshold;
            applyDithering();
        });

        document.getElementById('serpentine').addEventListener('change', (e) => {
            serpentine = e.target.checked;
            applyDithering();
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { generateGradient(); setMethod('floyd'); };

        // Initialize
        updateKernelDisplay();
        generateGradient();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
