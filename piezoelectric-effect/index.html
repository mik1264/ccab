<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Piezoelectric Effect</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #22d3ee; font-size: 20px; font-weight: bold; z-index: 10;
    text-shadow: 0 0 20px rgba(34,211,238,0.5);
    pointer-events: none;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 15px; align-items: center; z-index: 10;
    background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 10px;
    flex-wrap: wrap; justify-content: center;
}
#controls label { color: #22d3ee; font-size: 13px; }
#controls input[type=range] { width: 100px; cursor: pointer; }
#controls button {
    background: rgba(34,211,238,0.2); color: #22d3ee; border: 1px solid #22d3ee;
    padding: 5px 12px; border-radius: 5px; cursor: pointer; font-size: 13px;
}
#controls button:hover { background: rgba(34,211,238,0.4); }
#controls button.active { background: rgba(34,211,238,0.5); }
#info {
    position: fixed; top: 80px; right: 20px; color: #94a3b8; font-size: 12px;
    z-index: 10; text-align: right; line-height: 1.8;
    background: rgba(0,0,0,0.5); padding: 10px 15px; border-radius: 8px;
}
.info-val { color: #22d3ee; font-weight: bold; }
#legend {
    position: fixed; top: 80px; left: 20px; color: #94a3b8; font-size: 11px;
    z-index: 10; line-height: 2;
    background: rgba(0,0,0,0.5); padding: 10px 15px; border-radius: 8px;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title">Piezoelectric Effect Simulation</div>
<div id="info">
    Mode: <span class="info-val" id="modeVal">Direct</span><br>
    Voltage: <span class="info-val" id="voltageVal">0.0</span> V<br>
    Strain: <span class="info-val" id="strainVal">0.0</span>%<br>
    Polarization: <span class="info-val" id="polarVal">0.0</span>
</div>
<div id="legend">
    <span style="color:#ef4444">&#9679;</span> Positive ions (Zr/Ti)<br>
    <span style="color:#3b82f6">&#9679;</span> Negative ions (O)<br>
    <span style="color:#a855f7">&#9679;</span> Central cation<br>
    <span style="color:#fbbf24">&#8594;</span> Electric field<br>
    <span style="color:#22d3ee">&#8594;</span> Dipole moment
</div>
<div id="controls">
    <button id="directBtn" class="active">Direct Effect (Force)</button>
    <button id="inverseBtn">Inverse Effect (Voltage)</button>
    <label>Force/Voltage: <input type="range" id="forceSlider" min="-100" max="100" value="0" step="1"></label>
    <label>Crystal Size: <input type="range" id="sizeSlider" min="3" max="8" value="5" step="1"></label>
    <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
let mode = 'direct'; // 'direct' or 'inverse'
let appliedForce = 0;  // -100 to 100
let crystalSize = 5;
let voltage = 0;
let strain = 0;
let polarization = 0;
let time = 0;

// Crystal unit cell data
let unitCells = [];
let cellSpacing;
let crystalX, crystalY, crystalW, crystalH;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

function buildCrystal() {
    unitCells = [];
    const rows = crystalSize;
    const cols = crystalSize;
    cellSpacing = Math.min((W - 200) / (cols + 2), (H - 250) / (rows + 2));
    cellSpacing = Math.min(cellSpacing, 80);

    crystalW = cols * cellSpacing;
    crystalH = rows * cellSpacing;
    crystalX = (W - crystalW) / 2;
    crystalY = (H - crystalH) / 2 + 10;

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cx = crystalX + (c + 0.5) * cellSpacing;
            const cy = crystalY + (r + 0.5) * cellSpacing;
            unitCells.push({
                cx: cx, cy: cy,
                row: r, col: c,
                // Corner ions (positive - Pb/Ba)
                corners: [
                    { rx: -0.5, ry: -0.5, charge: +1 },
                    { rx: 0.5, ry: -0.5, charge: +1 },
                    { rx: -0.5, ry: 0.5, charge: +1 },
                    { rx: 0.5, ry: 0.5, charge: +1 }
                ],
                // Face-center ions (negative - O)
                faces: [
                    { rx: 0, ry: -0.5, charge: -1 },
                    { rx: 0, ry: 0.5, charge: -1 },
                    { rx: -0.5, ry: 0, charge: -1 },
                    { rx: 0.5, ry: 0, charge: -1 }
                ],
                // Central cation (Ti/Zr) - this shifts to create dipole
                center: { rx: 0, ry: 0, charge: +1, shift: 0 }
            });
        }
    }
}

function updatePhysics() {
    time += 0.016;

    if (mode === 'direct') {
        // Direct piezoelectric: force -> strain -> voltage
        strain = appliedForce * 0.002;
        polarization = strain * 50;
        voltage = polarization * 0.5;
    } else {
        // Inverse piezoelectric: voltage -> strain
        voltage = appliedForce * 0.5;
        polarization = voltage * 2;
        strain = voltage * 0.004;
    }

    // Update central cation displacement
    const shift = strain * 15; // Exaggerated for visibility
    for (const cell of unitCells) {
        cell.center.shift = shift;
    }
}

function drawCrystal() {
    const s = cellSpacing;
    const strainFactor = strain;

    // Draw electrode plates
    const plateWidth = crystalW + 40;
    const plateHeight = 12;

    // Top electrode
    ctx.fillStyle = '#475569';
    ctx.fillRect(crystalX - 20, crystalY - 30 + strainFactor * 500, plateWidth, plateHeight);
    ctx.fillStyle = '#64748b';
    ctx.fillRect(crystalX - 20, crystalY - 30 + strainFactor * 500, plateWidth, 3);

    // Bottom electrode
    ctx.fillStyle = '#475569';
    ctx.fillRect(crystalX - 20, crystalY + crystalH + 18 - strainFactor * 500, plateWidth, plateHeight);
    ctx.fillStyle = '#64748b';
    ctx.fillRect(crystalX - 20, crystalY + crystalH + 27 - strainFactor * 500, plateWidth, 3);

    // Electrode labels
    if (Math.abs(voltage) > 0.5) {
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = voltage > 0 ? '#ef4444' : '#3b82f6';
        ctx.fillText(voltage > 0 ? '+' : '-', crystalX + crystalW / 2,
            crystalY - 35 + strainFactor * 500);
        ctx.fillStyle = voltage > 0 ? '#3b82f6' : '#ef4444';
        ctx.fillText(voltage > 0 ? '-' : '+', crystalX + crystalW / 2,
            crystalY + crystalH + 45 - strainFactor * 500);
    }

    // Wire connections
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 2;
    const wireTop = crystalY - 30 + strainFactor * 500;
    const wireBot = crystalY + crystalH + 30 - strainFactor * 500;

    ctx.beginPath();
    ctx.moveTo(crystalX + crystalW + 20, wireTop + plateHeight / 2);
    ctx.lineTo(crystalX + crystalW + 60, wireTop + plateHeight / 2);
    ctx.lineTo(crystalX + crystalW + 60, wireBot - plateHeight / 2);
    ctx.lineTo(crystalX + crystalW + 20, wireBot - plateHeight / 2);
    ctx.stroke();

    // Voltmeter circle
    if (mode === 'direct') {
        const vmX = crystalX + crystalW + 60;
        const vmY = (wireTop + wireBot) / 2;
        ctx.beginPath();
        ctx.arc(vmX, vmY, 18, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(15,20,40,0.9)';
        ctx.fill();
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.fillStyle = '#22d3ee';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('V', vmX, vmY + 4);

        // Voltage reading
        ctx.font = '12px sans-serif';
        ctx.fillText(voltage.toFixed(1) + 'V', vmX, vmY + 30);
    }

    // Draw unit cells
    for (const cell of unitCells) {
        const cx = cell.cx;
        const cy = cell.cy + strainFactor * (cell.row - crystalSize / 2) * 100;
        const halfS = s / 2;

        // Cell border
        ctx.strokeStyle = 'rgba(100,116,139,0.2)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(cx - halfS, cy - halfS, s, s);

        // Corner ions (positive - larger)
        for (const corner of cell.corners) {
            const ix = cx + corner.rx * s;
            const iy = cy + corner.ry * s;
            const r = s * 0.12;

            ctx.beginPath();
            ctx.arc(ix, iy, r, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(ix - r * 0.2, iy - r * 0.2, 0, ix, iy, r);
            grad.addColorStop(0, '#fca5a5');
            grad.addColorStop(1, '#dc2626');
            ctx.fillStyle = grad;
            ctx.fill();

            // Charge label
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '8px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('+', ix, iy + 3);
        }

        // Face-center ions (negative - medium)
        for (const face of cell.faces) {
            const ix = cx + face.rx * s;
            const iy = cy + face.ry * s;
            const r = s * 0.1;

            ctx.beginPath();
            ctx.arc(ix, iy, r, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(ix - r * 0.2, iy - r * 0.2, 0, ix, iy, r);
            grad.addColorStop(0, '#93c5fd');
            grad.addColorStop(1, '#2563eb');
            ctx.fillStyle = grad;
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '8px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('-', ix, iy + 3);
        }

        // Central cation (shifted by piezoelectric effect)
        const centerShift = cell.center.shift;
        const ccx = cx;
        const ccy = cy + centerShift;
        const cr = s * 0.08;

        // Dipole arrow from center to displaced position
        if (Math.abs(centerShift) > 0.5) {
            ctx.strokeStyle = 'rgba(34,211,238,0.6)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(ccx, ccy);
            ctx.stroke();

            // Arrow head
            const angle = Math.atan2(ccy - cy, ccx - cx);
            ctx.beginPath();
            ctx.moveTo(ccx, ccy);
            ctx.lineTo(ccx - 5 * Math.cos(angle - 0.5), ccy - 5 * Math.sin(angle - 0.5));
            ctx.moveTo(ccx, ccy);
            ctx.lineTo(ccx - 5 * Math.cos(angle + 0.5), ccy - 5 * Math.sin(angle + 0.5));
            ctx.stroke();
        }

        ctx.beginPath();
        ctx.arc(ccx, ccy, cr, 0, Math.PI * 2);
        const cgrad = ctx.createRadialGradient(ccx - cr * 0.2, ccy - cr * 0.2, 0, ccx, ccy, cr);
        cgrad.addColorStop(0, '#d8b4fe');
        cgrad.addColorStop(1, '#9333ea');
        ctx.fillStyle = cgrad;
        ctx.fill();
    }

    // Force arrows (direct mode)
    if (mode === 'direct' && Math.abs(appliedForce) > 5) {
        const arrowLen = Math.abs(appliedForce) * 0.3;
        ctx.strokeStyle = '#f97316';
        ctx.fillStyle = '#f97316';
        ctx.lineWidth = 3;

        if (appliedForce > 0) {
            // Compression: arrows pointing inward
            for (let i = 0; i < 3; i++) {
                const ax = crystalX + (i + 0.5) * crystalW / 3;
                drawArrow(ax, crystalY - 55, ax, crystalY - 55 + arrowLen);
                drawArrow(ax, crystalY + crystalH + 55, ax, crystalY + crystalH + 55 - arrowLen);
            }
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Compression', crystalX + crystalW / 2, crystalY - 65);
        } else {
            // Tension: arrows pointing outward
            for (let i = 0; i < 3; i++) {
                const ax = crystalX + (i + 0.5) * crystalW / 3;
                drawArrow(ax, crystalY - 55 + arrowLen, ax, crystalY - 55);
                drawArrow(ax, crystalY + crystalH + 55 - arrowLen, ax, crystalY + crystalH + 55);
            }
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Tension', crystalX + crystalW / 2, crystalY - 65);
        }
    }

    // Electric field lines (inverse mode)
    if (mode === 'inverse' && Math.abs(appliedForce) > 5) {
        ctx.strokeStyle = 'rgba(251,191,36,0.3)';
        ctx.lineWidth = 1;
        const fieldDir = appliedForce > 0 ? 1 : -1;

        for (let c = 0; c < crystalSize; c++) {
            const fx = crystalX + (c + 0.5) * cellSpacing;
            ctx.setLineDash([4, 6]);
            ctx.beginPath();
            ctx.moveTo(fx, crystalY - 15);
            ctx.lineTo(fx, crystalY + crystalH + 15);
            ctx.stroke();
            ctx.setLineDash([]);

            // Arrow markers
            for (let r = 0; r < crystalSize; r++) {
                const fy = crystalY + (r + 0.5) * cellSpacing;
                ctx.fillStyle = 'rgba(251,191,36,0.4)';
                ctx.beginPath();
                const ay = fy;
                ctx.moveTo(fx - 3, ay + fieldDir * 5);
                ctx.lineTo(fx + 3, ay + fieldDir * 5);
                ctx.lineTo(fx, ay - fieldDir * 5);
                ctx.closePath();
                ctx.fill();
            }
        }

        ctx.font = '12px sans-serif';
        ctx.fillStyle = '#fbbf24';
        ctx.textAlign = 'center';
        ctx.fillText('E-field', crystalX - 35, crystalY + crystalH / 2);
    }

    // Net polarization arrow
    if (Math.abs(polarization) > 0.5) {
        const pArrowX = crystalX - 60;
        const pArrowCY = crystalY + crystalH / 2;
        const pLen = Math.min(Math.abs(polarization) * 2, crystalH * 0.4);
        const pDir = polarization > 0 ? -1 : 1;

        ctx.strokeStyle = '#22d3ee';
        ctx.fillStyle = '#22d3ee';
        ctx.lineWidth = 3;
        drawArrow(pArrowX, pArrowCY, pArrowX, pArrowCY + pDir * pLen);

        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('P', pArrowX, pArrowCY + pDir * pLen + pDir * 15);
    }
}

function drawArrow(x1, y1, x2, y2) {
    const headLen = 8;
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(angle - 0.4), y2 - headLen * Math.sin(angle - 0.4));
    ctx.lineTo(x2 - headLen * Math.cos(angle + 0.4), y2 - headLen * Math.sin(angle + 0.4));
    ctx.closePath();
    ctx.fill();
}

function drawExplanation() {
    const ex = 30;
    const ey = H - 100;
    const ew = W - 60;

    ctx.fillStyle = 'rgba(15,20,40,0.7)';
    ctx.beginPath();
    ctx.roundRect(ex, ey, ew, 40, 8);
    ctx.fill();

    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'center';

    if (mode === 'direct') {
        ctx.fillText(
            'Direct Piezoelectric Effect: Mechanical stress shifts the central cation, creating a net dipole moment and generating voltage across the crystal.',
            W / 2, ey + 17
        );
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('Force \u2192 Lattice Distortion \u2192 Charge Separation \u2192 Voltage', W / 2, ey + 33);
    } else {
        ctx.fillText(
            'Inverse Piezoelectric Effect: Applied voltage creates an electric field that displaces ions, causing the crystal to deform (expand or contract).',
            W / 2, ey + 17
        );
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('Voltage \u2192 Electric Field \u2192 Ion Displacement \u2192 Mechanical Strain', W / 2, ey + 33);
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    updatePhysics();
    drawCrystal();
    drawExplanation();

    document.getElementById('modeVal').textContent =
        mode === 'direct' ? 'Direct (Force\u2192Voltage)' : 'Inverse (Voltage\u2192Strain)';
    document.getElementById('voltageVal').textContent = voltage.toFixed(1);
    document.getElementById('strainVal').textContent = (strain * 100).toFixed(2);
    document.getElementById('polarVal').textContent = polarization.toFixed(1);

    requestAnimationFrame(draw);
}

document.getElementById('directBtn').addEventListener('click', () => {
    mode = 'direct';
    document.getElementById('directBtn').classList.add('active');
    document.getElementById('inverseBtn').classList.remove('active');
    document.getElementById('forceSlider').value = 0;
    appliedForce = 0;
});

document.getElementById('inverseBtn').addEventListener('click', () => {
    mode = 'inverse';
    document.getElementById('inverseBtn').classList.add('active');
    document.getElementById('directBtn').classList.remove('active');
    document.getElementById('forceSlider').value = 0;
    appliedForce = 0;
});

document.getElementById('forceSlider').addEventListener('input', (e) => {
    appliedForce = parseInt(e.target.value);
});

document.getElementById('sizeSlider').addEventListener('input', (e) => {
    crystalSize = parseInt(e.target.value);
    buildCrystal();
});

document.getElementById('resetBtn').addEventListener('click', () => {
    appliedForce = 0;
    document.getElementById('forceSlider').value = 0;
    buildCrystal();
});

window.addEventListener('resize', () => { resize(); buildCrystal(); });

resize();
buildCrystal();
draw();
</script>
</body>
</html>
