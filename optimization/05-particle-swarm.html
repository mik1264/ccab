<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Swarm Optimization - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 350px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Particle Swarm Optimization</h3>

        <div class="control-group">
            <label>Swarm Size: <span class="value" id="swarmValue">50</span></label>
            <input type="range" id="swarmSize" min="10" max="100" step="10" value="50" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Inertia (w): <span class="value" id="inertiaValue">0.7</span></label>
            <input type="range" id="inertia" min="0.4" max="0.9" step="0.1" value="0.7" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Cognitive (c1): <span class="value" id="c1Value">1.5</span></label>
            <input type="range" id="c1" min="0.5" max="3" step="0.1" value="1.5" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Social (c2): <span class="value" id="c2Value">1.5</span></label>
            <input type="range" id="c2" min="0.5" max="3" step="0.1" value="1.5" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Landscape: <span class="value" id="landscapeValue">Rastrigin</span></label>
            <select id="landscape" style="width: 100%; padding: 8px; border-radius: 4px; background: #1a1f2e; color: #e0e0e0; border: 1px solid #8A9A5B;">
                <option value="rastrigin">Rastrigin (Many Minima)</option>
                <option value="sphere">Sphere (Convex)</option>
                <option value="ackley">Ackley (Deceptive)</option>
                <option value="rosenbrock">Rosenbrock (Valley)</option>
            </select>
        </div>

        <button id="reset">Reset Swarm</button>
    </div>

    <div class="info">
        <h4>Algorithm: Particle Swarm</h4>
        <p>Particles move based on their own best position (cognitive) and the swarm's best position (social), creating emergent intelligence.</p>
        <p><strong>Global Best:</strong> <span class="stat" id="gbestInfo">-</span></p>
        <p><strong>Iterations:</strong> <span class="stat" id="iterInfo">0</span></p>
        <p><strong>Avg Velocity:</strong> <span class="stat" id="velInfo">-</span></p>
        <p><em>Green = personal best, Gold = global best</em></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let swarmSize = 50;
        let w = 0.7; // Inertia
        let c1 = 1.5; // Cognitive coefficient
        let c2 = 1.5; // Social coefficient
        let landscapeType = 'rastrigin';

        // State
        let particles = [];
        let globalBest = { x: 0, y: 0, fitness: Infinity };
        let iteration = 0;

        // Fitness functions (we minimize these)
        function fitness(x, y) {
            // Normalize to [-5, 5] range
            const nx = (x / width - 0.5) * 10;
            const ny = (y / height - 0.5) * 10;

            switch(landscapeType) {
                case 'rastrigin':
                    const A = 10;
                    return 2 * A + (nx * nx - A * Math.cos(2 * Math.PI * nx)) +
                           (ny * ny - A * Math.cos(2 * Math.PI * ny));

                case 'sphere':
                    return nx * nx + ny * ny;

                case 'ackley':
                    const a = 20, b = 0.2, c = 2 * Math.PI;
                    return -a * Math.exp(-b * Math.sqrt(0.5 * (nx * nx + ny * ny))) -
                           Math.exp(0.5 * (Math.cos(c * nx) + Math.cos(c * ny))) + a + Math.E;

                case 'rosenbrock':
                    const a2 = 1, b2 = 100;
                    return (a2 - nx) * (a2 - nx) + b2 * (ny - nx * nx) * (ny - nx * nx);
            }
        }

        function initParticles() {
            particles = [];
            globalBest = { x: width / 2, y: height / 2, fitness: Infinity };

            for (let i = 0; i < swarmSize; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const f = fitness(x, y);

                const particle = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    bestX: x,
                    bestY: y,
                    bestFitness: f
                };

                particles.push(particle);

                if (f < globalBest.fitness) {
                    globalBest = { x, y, fitness: f };
                }
            }

            iteration = 0;
        }

        function reset() {
            initParticles();
        }

        reset();

        // Controls
        document.getElementById('swarmSize').addEventListener('input', (e) => {
            swarmSize = parseInt(e.target.value);
            document.getElementById('swarmValue').textContent = swarmSize;
            reset();
        });

        document.getElementById('inertia').addEventListener('input', (e) => {
            w = parseFloat(e.target.value);
            document.getElementById('inertiaValue').textContent = w.toFixed(1);
        });

        document.getElementById('c1').addEventListener('input', (e) => {
            c1 = parseFloat(e.target.value);
            document.getElementById('c1Value').textContent = c1.toFixed(1);
        });

        document.getElementById('c2').addEventListener('input', (e) => {
            c2 = parseFloat(e.target.value);
            document.getElementById('c2Value').textContent = c2.toFixed(1);
        });

        document.getElementById('landscape').addEventListener('change', (e) => {
            landscapeType = e.target.value;
            document.getElementById('landscapeValue').textContent = e.target.options[e.target.selectedIndex].text;
            reset();
        });

        document.getElementById('reset').addEventListener('click', reset);

        // Update
        function update() {
            particles.forEach(p => {
                // PSO velocity update
                const r1 = Math.random();
                const r2 = Math.random();

                p.vx = w * p.vx +
                       c1 * r1 * (p.bestX - p.x) +
                       c2 * r2 * (globalBest.x - p.x);

                p.vy = w * p.vy +
                       c1 * r1 * (p.bestY - p.y) +
                       c2 * r2 * (globalBest.y - p.y);

                // Limit velocity
                const maxV = 20;
                const v = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                if (v > maxV) {
                    p.vx = (p.vx / v) * maxV;
                    p.vy = (p.vy / v) * maxV;
                }

                // Update position
                p.x += p.vx;
                p.y += p.vy;

                // Boundary handling (bounce)
                if (p.x < 0) { p.x = 0; p.vx = -p.vx; }
                if (p.x > width) { p.x = width; p.vx = -p.vx; }
                if (p.y < 0) { p.y = 0; p.vy = -p.vy; }
                if (p.y > height) { p.y = height; p.vy = -p.vy; }

                // Evaluate fitness
                const f = fitness(p.x, p.y);

                // Update personal best
                if (f < p.bestFitness) {
                    p.bestX = p.x;
                    p.bestY = p.y;
                    p.bestFitness = f;
                }

                // Update global best
                if (f < globalBest.fitness) {
                    globalBest = { x: p.x, y: p.y, fitness: f };
                }
            });

            iteration++;

            // Update info
            document.getElementById('gbestInfo').textContent = globalBest.fitness.toFixed(4);
            document.getElementById('iterInfo').textContent = iteration;

            const avgVel = particles.reduce((sum, p) =>
                sum + Math.sqrt(p.vx * p.vx + p.vy * p.vy), 0) / particles.length;
            document.getElementById('velInfo').textContent = avgVel.toFixed(2);
        }

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw fitness landscape
            const gridSize = 25;
            for (let x = 0; x < width; x += gridSize) {
                for (let y = 0; y < height; y += gridSize) {
                    const f = fitness(x, y);
                    // Normalize for visualization
                    const maxF = landscapeType === 'rastrigin' ? 100 : 30;
                    const intensity = Math.max(0, 1 - f / maxF);

                    const r = Math.floor(138 * intensity);
                    const g = Math.floor(154 * intensity);
                    const b = Math.floor(91 * intensity);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + intensity * 0.3})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }

            // Draw particle trails (personal bests)
            particles.forEach((p, idx) => {
                // Line to personal best
                ctx.strokeStyle = 'rgba(138, 154, 91, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.bestX, p.bestY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Personal best marker
                ctx.fillStyle = 'rgba(138, 154, 91, 0.3)';
                ctx.beginPath();
                ctx.arc(p.bestX, p.bestY, 3, 0, Math.PI * 2);
                ctx.fill();

                // Velocity vector
                ctx.strokeStyle = 'rgba(221, 161, 94, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.vx * 3, p.y + p.vy * 3);
                ctx.stroke();
            });

            // Draw particles
            particles.forEach(p => {
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 10);
                gradient.addColorStop(0, 'rgba(221, 161, 94, 0.8)');
                gradient.addColorStop(1, 'rgba(221, 161, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(p.x - 10, p.y - 10, 20, 20);

                ctx.fillStyle = '#DDA15E';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw global best
            const glow = ctx.createRadialGradient(
                globalBest.x, globalBest.y, 0,
                globalBest.x, globalBest.y, 30
            );
            glow.addColorStop(0, 'rgba(138, 154, 91, 0.8)');
            glow.addColorStop(1, 'rgba(138, 154, 91, 0)');
            ctx.fillStyle = glow;
            ctx.fillRect(globalBest.x - 30, globalBest.y - 30, 60, 60);

            ctx.fillStyle = '#8A9A5B';
            ctx.beginPath();
            ctx.arc(globalBest.x, globalBest.y, 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#FEFAE0';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GLOBAL BEST', globalBest.x, globalBest.y - 25);
        }

        // Animation loop
        function animate() {
            update();
            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
