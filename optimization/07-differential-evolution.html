<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Differential Evolution - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 350px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Differential Evolution</h3>

        <div class="control-group">
            <label>Population Size: <span class="value" id="popValue">40</span></label>
            <input type="range" id="popSize" min="20" max="100" step="10" value="40" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Mutation Factor (F): <span class="value" id="fValue">0.8</span></label>
            <input type="range" id="mutationFactor" min="0.3" max="2.0" step="0.1" value="0.8" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Crossover Rate (CR): <span class="value" id="crValue">0.7</span></label>
            <input type="range" id="crossoverRate" min="0.1" max="1.0" step="0.1" value="0.7" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Landscape: <span class="value" id="landscapeValue">Schwefel</span></label>
            <select id="landscape" style="width: 100%; padding: 8px; border-radius: 4px; background: #1a1f2e; color: #e0e0e0; border: 1px solid #8A9A5B;">
                <option value="schwefel">Schwefel (Complex)</option>
                <option value="sphere">Sphere (Simple)</option>
                <option value="rastrigin">Rastrigin (Many Minima)</option>
                <option value="griewank">Griewank (Multimodal)</option>
            </select>
        </div>

        <button id="reset">Reset Population</button>
    </div>

    <div class="info">
        <h4>Algorithm: Differential Evolution</h4>
        <p>Uses vector differences between population members to create mutations, then selects better individuals. Excellent for continuous optimization.</p>
        <p><strong>Generation:</strong> <span class="stat" id="genInfo">0</span></p>
        <p><strong>Best Fitness:</strong> <span class="stat" id="bestInfo">-</span></p>
        <p><strong>Avg Fitness:</strong> <span class="stat" id="avgInfo">-</span></p>
        <p><strong>Population Spread:</strong> <span class="stat" id="spreadInfo">-</span></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let popSize = 40;
        let F = 0.8; // Mutation factor
        let CR = 0.7; // Crossover rate
        let landscapeType = 'schwefel';

        // State
        let population = [];
        let generation = 0;
        let trialVectors = [];

        // Fitness functions (minimize)
        function fitness(x, y) {
            // Normalize to appropriate range
            const nx = (x / width - 0.5) * 10;
            const ny = (y / height - 0.5) * 10;

            switch(landscapeType) {
                case 'schwefel':
                    const s = 418.9829;
                    return 2 * s - (nx * Math.sin(Math.sqrt(Math.abs(nx))) +
                                    ny * Math.sin(Math.sqrt(Math.abs(ny))));

                case 'sphere':
                    return nx * nx + ny * ny;

                case 'rastrigin':
                    const A = 10;
                    return 2 * A + (nx * nx - A * Math.cos(2 * Math.PI * nx)) +
                           (ny * ny - A * Math.cos(2 * Math.PI * ny));

                case 'griewank':
                    return 1 + (nx * nx + ny * ny) / 4000 -
                           Math.cos(nx / Math.sqrt(1)) * Math.cos(ny / Math.sqrt(2));
            }
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                const individual = {
                    x: Math.random() * width,
                    y: Math.random() * height,
                    fitness: 0
                };
                individual.fitness = fitness(individual.x, individual.y);
                population.push(individual);
            }
            population.sort((a, b) => a.fitness - b.fitness);
            generation = 0;
        }

        function reset() {
            initPopulation();
        }

        reset();

        // Controls
        document.getElementById('popSize').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
            reset();
        });

        document.getElementById('mutationFactor').addEventListener('input', (e) => {
            F = parseFloat(e.target.value);
            document.getElementById('fValue').textContent = F.toFixed(1);
        });

        document.getElementById('crossoverRate').addEventListener('input', (e) => {
            CR = parseFloat(e.target.value);
            document.getElementById('crValue').textContent = CR.toFixed(1);
        });

        document.getElementById('landscape').addEventListener('change', (e) => {
            landscapeType = e.target.value;
            document.getElementById('landscapeValue').textContent = e.target.options[e.target.selectedIndex].text;
            reset();
        });

        document.getElementById('reset').addEventListener('click', reset);

        // DE evolution step
        function evolve() {
            trialVectors = [];
            const newPopulation = [];

            for (let i = 0; i < population.length; i++) {
                const target = population[i];

                // Select three random distinct individuals (different from target)
                let indices = [];
                while (indices.length < 3) {
                    const r = Math.floor(Math.random() * population.length);
                    if (r !== i && !indices.includes(r)) {
                        indices.push(r);
                    }
                }

                const [a, b, c] = indices.map(idx => population[idx]);

                // Mutation: v = a + F * (b - c)
                let mutant = {
                    x: a.x + F * (b.x - c.x),
                    y: a.y + F * (b.y - c.y)
                };

                // Boundary handling
                mutant.x = Math.max(0, Math.min(width, mutant.x));
                mutant.y = Math.max(0, Math.min(height, mutant.y));

                // Crossover
                const trial = { x: target.x, y: target.y };

                if (Math.random() < CR || Math.random() < CR) {
                    // At least one dimension from mutant
                    if (Math.random() < 0.5) {
                        trial.x = mutant.x;
                    } else {
                        trial.y = mutant.y;
                    }

                    // Additional dimensions with probability CR
                    if (Math.random() < CR) {
                        trial.x = mutant.x;
                        trial.y = mutant.y;
                    }
                }

                trial.fitness = fitness(trial.x, trial.y);
                trialVectors.push({ ...trial, targetIndex: i });

                // Selection: keep better individual
                if (trial.fitness < target.fitness) {
                    newPopulation.push(trial);
                } else {
                    newPopulation.push({ ...target });
                }
            }

            population = newPopulation;
            population.sort((a, b) => a.fitness - b.fitness);
            generation++;

            // Update info
            const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;

            // Calculate spread (diversity)
            const avgX = population.reduce((sum, ind) => sum + ind.x, 0) / population.length;
            const avgY = population.reduce((sum, ind) => sum + ind.y, 0) / population.length;
            const spread = Math.sqrt(
                population.reduce((sum, ind) => {
                    const dx = ind.x - avgX;
                    const dy = ind.y - avgY;
                    return sum + dx * dx + dy * dy;
                }, 0) / population.length
            );

            document.getElementById('genInfo').textContent = generation;
            document.getElementById('bestInfo').textContent = population[0].fitness.toFixed(4);
            document.getElementById('avgInfo').textContent = avgFitness.toFixed(4);
            document.getElementById('spreadInfo').textContent = spread.toFixed(1);
        }

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw fitness landscape
            const gridSize = 30;
            for (let x = 0; x < width; x += gridSize) {
                for (let y = 0; y < height; y += gridSize) {
                    const f = fitness(x, y);
                    const maxF = landscapeType === 'schwefel' ? 1000 : 50;
                    const intensity = Math.max(0, 1 - f / maxF);

                    const r = Math.floor(138 * intensity);
                    const g = Math.floor(154 * intensity);
                    const b = Math.floor(91 * intensity);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + intensity * 0.3})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }

            // Draw mutation vectors (show a few)
            trialVectors.slice(0, 10).forEach(trial => {
                const target = population[trial.targetIndex];

                // Line from target to trial
                ctx.strokeStyle = 'rgba(221, 161, 94, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(target.x, target.y);
                ctx.lineTo(trial.x, trial.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Trial point
                const color = trial.fitness < target.fitness
                    ? 'rgba(138, 154, 91, 0.6)'
                    : 'rgba(188, 108, 37, 0.4)';
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(trial.x, trial.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw population
            population.forEach((ind, idx) => {
                // Glow
                const isElite = idx < 5;
                const glowColor = isElite ? '138, 154, 91' : '221, 161, 94';

                const gradient = ctx.createRadialGradient(ind.x, ind.y, 0, ind.x, ind.y, 12);
                gradient.addColorStop(0, `rgba(${glowColor}, 0.7)`);
                gradient.addColorStop(1, `rgba(${glowColor}, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(ind.x - 12, ind.y - 12, 24, 24);

                // Individual
                ctx.fillStyle = isElite ? '#8A9A5B' : '#DDA15E';
                ctx.beginPath();
                ctx.arc(ind.x, ind.y, isElite ? 5 : 4, 0, Math.PI * 2);
                ctx.fill();

                if (isElite) {
                    ctx.strokeStyle = '#FEFAE0';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Highlight best individual
            const best = population[0];
            const glow = ctx.createRadialGradient(best.x, best.y, 0, best.x, best.y, 25);
            glow.addColorStop(0, 'rgba(138, 154, 91, 0.9)');
            glow.addColorStop(1, 'rgba(138, 154, 91, 0)');
            ctx.fillStyle = glow;
            ctx.fillRect(best.x - 25, best.y - 25, 50, 50);

            ctx.strokeStyle = '#8A9A5B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(best.x, best.y, 12, 0, Math.PI * 2);
            ctx.stroke();

            // Label
            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('BEST', best.x, best.y - 22);
        }

        // Animation loop
        let frameCount = 0;
        function animate() {
            frameCount++;

            if (frameCount % 5 === 0) {
                evolve();
            }

            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
