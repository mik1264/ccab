<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Objective Optimization - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 400px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="controls">
        <h3>Multi-Objective Optimization</h3>

        <div class="control-group">
            <label>Population Size: <span class="value" id="popValue">100</span></label>
            <input type="range" id="popSize" min="50" max="200" step="25" value="100" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Mutation Rate: <span class="value" id="mutationValue">0.1</span></label>
            <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.05" value="0.1" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Problem: <span class="value" id="problemValue">Cost vs Quality</span></label>
            <select id="problem" style="width: 100%; padding: 8px; border-radius: 4px; background: #1a1f2e; color: #e0e0e0; border: 1px solid #8A9A5B;">
                <option value="cost-quality">Cost vs Quality</option>
                <option value="speed-accuracy">Speed vs Accuracy</option>
                <option value="risk-return">Risk vs Return</option>
            </select>
        </div>

        <button id="evolve">Evolve Generation</button>
        <button id="auto">Auto Evolve</button>
        <button id="reset">Reset Population</button>
    </div>

    <div class="info">
        <h4>Multi-Objective Optimization</h4>
        <p>Finding solutions where improving one objective requires sacrificing another. The Pareto frontier contains all optimal trade-offs.</p>
        <p><strong>Generation:</strong> <span class="stat" id="genInfo">0</span></p>
        <p><strong>Pareto Front Size:</strong> <span class="stat" id="paretoInfo">0</span></p>
        <p><strong>Dominated Solutions:</strong> <span class="stat" id="dominatedInfo">0</span></p>
        <p><em>Green = Pareto optimal, Gray = dominated</em></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let popSize = 100;
        let mutationRate = 0.1;
        let problemType = 'cost-quality';
        let autoEvolve = false;

        // State
        let population = [];
        let generation = 0;

        // Problem definitions
        const problems = {
            'cost-quality': {
                name: 'Cost vs Quality',
                obj1Name: 'Cost',
                obj2Name: 'Quality',
                // Both minimize (we'll negate quality for display)
                evaluate: (x) => {
                    const cost = x * x / 2 + Math.sin(x * 3) * 0.5;
                    const quality = -(x - 5) * (x - 5) / 10 - Math.cos(x * 2) * 0.3;
                    return { cost, quality: -quality }; // Minimize both
                }
            },
            'speed-accuracy': {
                name: 'Speed vs Accuracy',
                obj1Name: 'Time (lower better)',
                obj2Name: 'Error (lower better)',
                evaluate: (x) => {
                    const time = 1 / (x + 0.5);
                    const error = x * x / 20 + Math.sin(x * 2) * 0.2;
                    return { cost: time, quality: error };
                }
            },
            'risk-return': {
                name: 'Risk vs Return',
                obj1Name: 'Risk',
                obj2Name: 'Return',
                evaluate: (x) => {
                    const risk = Math.abs(x - 5) / 5 + Math.random() * 0.1;
                    const returnValue = -(x * (10 - x) / 15 + Math.sin(x) * 0.3);
                    return { cost: risk, quality: -returnValue };
                }
            }
        };

        // Pareto dominance: a dominates b if a is better in all objectives
        function dominates(a, b) {
            return a.obj1 <= b.obj1 && a.obj2 <= b.obj2 &&
                   (a.obj1 < b.obj1 || a.obj2 < b.obj2);
        }

        function findParetoFront(pop) {
            const front = [];

            for (const individual of pop) {
                let isDominated = false;

                for (const other of pop) {
                    if (other !== individual && dominates(other, individual)) {
                        isDominated = true;
                        break;
                    }
                }

                if (!isDominated) {
                    front.push(individual);
                }
            }

            return front;
        }

        function crowdingDistance(front) {
            if (front.length <= 2) {
                front.forEach(ind => ind.crowdingDist = Infinity);
                return;
            }

            front.forEach(ind => ind.crowdingDist = 0);

            // Sort by each objective
            for (const objective of ['obj1', 'obj2']) {
                front.sort((a, b) => a[objective] - b[objective]);

                const minVal = front[0][objective];
                const maxVal = front[front.length - 1][objective];
                const range = maxVal - minVal || 1;

                front[0].crowdingDist = Infinity;
                front[front.length - 1].crowdingDist = Infinity;

                for (let i = 1; i < front.length - 1; i++) {
                    if (front[i].crowdingDist !== Infinity) {
                        front[i].crowdingDist +=
                            (front[i + 1][objective] - front[i - 1][objective]) / range;
                    }
                }
            }
        }

        function initPopulation() {
            population = [];

            for (let i = 0; i < popSize; i++) {
                const x = Math.random() * 10;
                const { cost, quality } = problems[problemType].evaluate(x);

                population.push({
                    x: x,
                    obj1: cost,
                    obj2: quality,
                    rank: 0,
                    crowdingDist: 0
                });
            }

            generation = 0;
        }

        function evolvePopulation() {
            // NSGA-II style evolution

            // Non-dominated sorting
            const fronts = [];
            let remaining = [...population];

            while (remaining.length > 0) {
                const front = findParetoFront(remaining);
                fronts.push(front);

                front.forEach(ind => ind.rank = fronts.length - 1);

                remaining = remaining.filter(ind => !front.includes(ind));
            }

            // Calculate crowding distance for each front
            fronts.forEach(front => crowdingDistance(front));

            // Selection and reproduction
            const offspring = [];

            while (offspring.length < popSize) {
                // Tournament selection
                const tournament = [];
                for (let i = 0; i < 2; i++) {
                    tournament.push(population[Math.floor(Math.random() * population.length)]);
                }

                tournament.sort((a, b) => {
                    if (a.rank !== b.rank) return a.rank - b.rank;
                    return b.crowdingDist - a.crowdingDist; // Higher crowding distance is better
                });

                const parent = tournament[0];

                // Create offspring with mutation
                let childX = parent.x;

                if (Math.random() < mutationRate) {
                    childX += (Math.random() - 0.5) * 2;
                    childX = Math.max(0, Math.min(10, childX));
                }

                const { cost, quality } = problems[problemType].evaluate(childX);

                offspring.push({
                    x: childX,
                    obj1: cost,
                    obj2: quality,
                    rank: 0,
                    crowdingDist: 0
                });
            }

            population = offspring;
            generation++;

            updateStats();
        }

        function updateStats() {
            const paretoFront = findParetoFront(population);
            const dominated = population.length - paretoFront.length;

            document.getElementById('genInfo').textContent = generation;
            document.getElementById('paretoInfo').textContent = paretoFront.length;
            document.getElementById('dominatedInfo').textContent = dominated;
        }

        function reset() {
            initPopulation();
            updateStats();
        }

        reset();

        // Controls
        document.getElementById('popSize').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
            reset();
        });

        document.getElementById('mutationRate').addEventListener('input', (e) => {
            mutationRate = parseFloat(e.target.value);
            document.getElementById('mutationValue').textContent = mutationRate.toFixed(2);
        });

        document.getElementById('problem').addEventListener('change', (e) => {
            problemType = e.target.value;
            document.getElementById('problemValue').textContent = e.target.options[e.target.selectedIndex].text;
            reset();
        });

        document.getElementById('evolve').addEventListener('click', evolvePopulation);

        document.getElementById('auto').addEventListener('click', () => {
            autoEvolve = !autoEvolve;
            document.getElementById('auto').textContent = autoEvolve ? 'Stop Auto' : 'Auto Evolve';
        });

        document.getElementById('reset').addEventListener('click', reset);

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Setup coordinate system
            const margin = 120;
            const plotWidth = width - margin * 2;
            const plotHeight = height - margin * 2;

            // Find ranges
            let minObj1 = Infinity, maxObj1 = -Infinity;
            let minObj2 = Infinity, maxObj2 = -Infinity;

            population.forEach(ind => {
                minObj1 = Math.min(minObj1, ind.obj1);
                maxObj1 = Math.max(maxObj1, ind.obj1);
                minObj2 = Math.min(minObj2, ind.obj2);
                maxObj2 = Math.max(maxObj2, ind.obj2);
            });

            const rangeObj1 = maxObj1 - minObj1 || 1;
            const rangeObj2 = maxObj2 - minObj2 || 1;

            function mapToScreen(obj1, obj2) {
                const x = margin + ((obj1 - minObj1) / rangeObj1) * plotWidth;
                const y = height - margin - ((obj2 - minObj2) / rangeObj2) * plotHeight;
                return { x, y };
            }

            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(margin, margin);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(problems[problemType].obj1Name + ' →', width / 2, height - 50);

            ctx.save();
            ctx.translate(50, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(problems[problemType].obj2Name + ' →', 0, 0);
            ctx.restore();

            // Title
            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(problems[problemType].name, width / 2, 50);

            // Find Pareto front
            const paretoFront = findParetoFront(population);
            const paretoSet = new Set(paretoFront);

            // Draw Pareto front line
            const sortedFront = [...paretoFront].sort((a, b) => a.obj1 - b.obj1);
            if (sortedFront.length > 1) {
                ctx.strokeStyle = 'rgba(138, 154, 91, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();

                sortedFront.forEach((ind, i) => {
                    const pos = mapToScreen(ind.obj1, ind.obj2);
                    if (i === 0) ctx.moveTo(pos.x, pos.y);
                    else ctx.lineTo(pos.x, pos.y);
                });

                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw dominated solutions
            population.forEach(ind => {
                if (!paretoSet.has(ind)) {
                    const pos = mapToScreen(ind.obj1, ind.obj2);

                    ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw Pareto optimal solutions
            paretoFront.forEach(ind => {
                const pos = mapToScreen(ind.obj1, ind.obj2);

                // Glow
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 15);
                gradient.addColorStop(0, 'rgba(138, 154, 91, 0.8)');
                gradient.addColorStop(1, 'rgba(138, 154, 91, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(pos.x - 15, pos.y - 15, 30, 30);

                // Point
                ctx.fillStyle = '#8A9A5B';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FEFAE0';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw ideal point (if it existed - minimize both)
            const idealPos = mapToScreen(minObj1, minObj2);
            ctx.strokeStyle = '#DDA15E';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(idealPos.x, idealPos.y, 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#DDA15E';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Ideal', idealPos.x, idealPos.y - 20);
            ctx.fillText('(impossible)', idealPos.x, idealPos.y - 8);

            // Legend
            ctx.fillStyle = 'rgba(20, 25, 35, 0.9)';
            ctx.fillRect(width - 250, 80, 230, 110);
            ctx.strokeStyle = 'rgba(138, 154, 91, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(width - 250, 80, 230, 110);

            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('Legend:', width - 240, 100);

            ctx.fillStyle = '#8A9A5B';
            ctx.beginPath();
            ctx.arc(width - 240, 120, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px monospace';
            ctx.fillText('Pareto Optimal', width - 225, 124);

            ctx.fillStyle = 'rgba(128, 128, 128, 0.6)';
            ctx.beginPath();
            ctx.arc(width - 240, 145, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#b0b0b0';
            ctx.fillText('Dominated', width - 225, 149);

            ctx.strokeStyle = 'rgba(138, 154, 91, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(width - 245, 170);
            ctx.lineTo(width - 225, 170);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#b0b0b0';
            ctx.fillText('Pareto Frontier', width - 220, 174);
        }

        // Animation loop
        let frameCount = 0;
        function animate() {
            frameCount++;

            if (autoEvolve && frameCount % 30 === 0) {
                evolvePopulation();
            }

            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
