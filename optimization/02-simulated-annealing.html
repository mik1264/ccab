<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulated Annealing - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 350px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }

        .temperature-bar {
            width: 100%;
            height: 20px;
            background: #1a1f2e;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            border: 1px solid rgba(138, 154, 91, 0.3);
        }

        .temperature-fill {
            height: 100%;
            background: linear-gradient(90deg, #BC6C25, #DDA15E, #8A9A5B);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Simulated Annealing</h3>

        <div class="control-group">
            <label>Initial Temperature: <span class="value" id="tempValue">100</span></label>
            <input type="range" id="temperature" min="10" max="200" step="10" value="100" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Cooling Rate: <span class="value" id="coolingValue">0.95</span></label>
            <input type="range" id="cooling" min="0.9" max="0.99" step="0.01" value="0.95" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Number of Cities: <span class="value" id="citiesValue">15</span></label>
            <input type="range" id="numCities" min="5" max="30" step="1" value="15" style="width: 100%;">
        </div>

        <button id="reset">Reset & Generate New Cities</button>
        <button id="pause">Pause</button>

        <div class="control-group" style="margin-top: 15px;">
            <label>Temperature</label>
            <div class="temperature-bar">
                <div class="temperature-fill" id="tempBar"></div>
            </div>
        </div>
    </div>

    <div class="info">
        <h4>Algorithm: Simulated Annealing</h4>
        <p>Probabilistic technique that accepts worse solutions early (high temperature) to escape local optima, gradually becoming more greedy as it cools.</p>
        <p><strong>Current Distance:</strong> <span class="stat" id="distanceInfo">-</span></p>
        <p><strong>Best Distance:</strong> <span class="stat" id="bestInfo">-</span></p>
        <p><strong>Temperature:</strong> <span class="stat" id="tempInfo">-</span></p>
        <p><strong>Iteration:</strong> <span class="stat" id="iterInfo">0</span></p>
        <p><strong>Acceptance Rate:</strong> <span class="stat" id="acceptInfo">-</span></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let initialTemp = 100;
        let coolingRate = 0.95;
        let numCities = 15;

        // State
        let cities = [];
        let currentRoute = [];
        let bestRoute = [];
        let temperature = initialTemp;
        let iteration = 0;
        let paused = false;
        let acceptedMoves = 0;
        let totalMoves = 0;

        // Generate cities
        function generateCities() {
            cities = [];
            const margin = 100;
            for (let i = 0; i < numCities; i++) {
                cities.push({
                    x: margin + Math.random() * (width - margin * 2),
                    y: margin + Math.random() * (height - margin * 2)
                });
            }
        }

        function distance(city1, city2) {
            const dx = city1.x - city2.x;
            const dy = city1.y - city2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function totalDistance(route) {
            let sum = 0;
            for (let i = 0; i < route.length; i++) {
                const city1 = cities[route[i]];
                const city2 = cities[route[(i + 1) % route.length]];
                sum += distance(city1, city2);
            }
            return sum;
        }

        function reset() {
            generateCities();
            currentRoute = Array.from({ length: numCities }, (_, i) => i);
            // Shuffle
            for (let i = currentRoute.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentRoute[i], currentRoute[j]] = [currentRoute[j], currentRoute[i]];
            }
            bestRoute = [...currentRoute];
            temperature = initialTemp;
            iteration = 0;
            acceptedMoves = 0;
            totalMoves = 0;
        }

        reset();

        // Controls
        document.getElementById('temperature').addEventListener('input', (e) => {
            initialTemp = parseFloat(e.target.value);
            document.getElementById('tempValue').textContent = initialTemp;
        });

        document.getElementById('cooling').addEventListener('input', (e) => {
            coolingRate = parseFloat(e.target.value);
            document.getElementById('coolingValue').textContent = coolingRate.toFixed(2);
        });

        document.getElementById('numCities').addEventListener('input', (e) => {
            numCities = parseInt(e.target.value);
            document.getElementById('citiesValue').textContent = numCities;
            reset();
        });

        document.getElementById('reset').addEventListener('click', reset);
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });

        // Simulated Annealing step
        function step() {
            if (paused || temperature < 0.1) return;

            // Perform multiple iterations per frame for faster convergence
            for (let k = 0; k < 10; k++) {
                // Random swap
                const i = Math.floor(Math.random() * currentRoute.length);
                const j = Math.floor(Math.random() * currentRoute.length);

                if (i === j) continue;

                // Swap
                const newRoute = [...currentRoute];
                [newRoute[i], newRoute[j]] = [newRoute[j], newRoute[i]];

                const currentDist = totalDistance(currentRoute);
                const newDist = totalDistance(newRoute);
                const delta = newDist - currentDist;

                totalMoves++;

                // Accept if better, or with probability based on temperature
                if (delta < 0 || Math.random() < Math.exp(-delta / temperature)) {
                    currentRoute = newRoute;
                    acceptedMoves++;

                    // Update best
                    if (newDist < totalDistance(bestRoute)) {
                        bestRoute = [...newRoute];
                    }
                }

                iteration++;
            }

            // Cool down
            temperature *= coolingRate;

            // Update UI
            const currentDist = totalDistance(currentRoute);
            const bestDist = totalDistance(bestRoute);

            document.getElementById('distanceInfo').textContent = currentDist.toFixed(1);
            document.getElementById('bestInfo').textContent = bestDist.toFixed(1);
            document.getElementById('tempInfo').textContent = temperature.toFixed(2);
            document.getElementById('iterInfo').textContent = iteration;
            document.getElementById('acceptInfo').textContent =
                ((acceptedMoves / totalMoves) * 100).toFixed(1) + '%';

            // Update temperature bar
            const tempPercent = Math.min(100, (temperature / initialTemp) * 100);
            document.getElementById('tempBar').style.width = tempPercent + '%';
        }

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw best route (faint)
            ctx.strokeStyle = 'rgba(138, 154, 91, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i < bestRoute.length; i++) {
                const city = cities[bestRoute[i]];
                if (i === 0) ctx.moveTo(city.x, city.y);
                else ctx.lineTo(city.x, city.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw current route
            const tempRatio = Math.min(1, temperature / initialTemp);
            const r = Math.floor(221 + (138 - 221) * (1 - tempRatio));
            const g = Math.floor(161 + (154 - 161) * (1 - tempRatio));
            const b = Math.floor(94 + (91 - 94) * (1 - tempRatio));

            ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < currentRoute.length; i++) {
                const city = cities[currentRoute[i]];
                if (i === 0) ctx.moveTo(city.x, city.y);
                else ctx.lineTo(city.x, city.y);
            }
            ctx.closePath();
            ctx.stroke();

            // Draw cities
            cities.forEach((city, idx) => {
                // Glow
                const gradient = ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, 15);
                gradient.addColorStop(0, 'rgba(221, 161, 94, 0.6)');
                gradient.addColorStop(1, 'rgba(221, 161, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(city.x - 15, city.y - 15, 30, 30);

                // City
                ctx.fillStyle = '#DDA15E';
                ctx.beginPath();
                ctx.arc(city.x, city.y, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FEFAE0';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(idx.toString(), city.x, city.y - 15);
            });

            // Highlight start city
            const startCity = cities[currentRoute[0]];
            ctx.strokeStyle = '#8A9A5B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(startCity.x, startCity.y, 10, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Animation loop
        function animate() {
            step();
            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
