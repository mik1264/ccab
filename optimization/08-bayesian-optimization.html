<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Optimization - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 350px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Bayesian Optimization</h3>

        <div class="control-group">
            <label>Acquisition: <span class="value" id="acqValue">EI</span></label>
            <select id="acquisition" style="width: 100%; padding: 8px; border-radius: 4px; background: #1a1f2e; color: #e0e0e0; border: 1px solid #8A9A5B;">
                <option value="ei">Expected Improvement (EI)</option>
                <option value="ucb">Upper Confidence Bound (UCB)</option>
                <option value="pi">Probability of Improvement (PI)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Exploration Weight: <span class="value" id="xiValue">0.01</span></label>
            <input type="range" id="xi" min="0.001" max="0.1" step="0.001" value="0.01" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>View Mode: <span class="value" id="viewValue">True Function</span></label>
            <select id="viewMode" style="width: 100%; padding: 8px; border-radius: 4px; background: #1a1f2e; color: #e0e0e0; border: 1px solid #8A9A5B;">
                <option value="true">True Function</option>
                <option value="surrogate">Surrogate Model</option>
                <option value="acquisition">Acquisition Function</option>
                <option value="uncertainty">Uncertainty</option>
            </select>
        </div>

        <button id="step">Take One Sample</button>
        <button id="auto">Auto Sample (slow)</button>
        <button id="reset">Reset</button>
    </div>

    <div class="info">
        <h4>Algorithm: Bayesian Optimization</h4>
        <p>Builds probabilistic surrogate model (Gaussian Process) to predict promising areas. Balances exploration vs exploitation.</p>
        <p><strong>Samples Taken:</strong> <span class="stat" id="samplesInfo">3</span></p>
        <p><strong>Best Value Found:</strong> <span class="stat" id="bestInfo">-</span></p>
        <p><strong>True Optimum:</strong> <span class="stat" id="optInfo">-</span></p>
        <p><em>Green dots = samples, Gold = best found</em></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let acquisitionType = 'ei';
        let xi = 0.01;
        let viewMode = 'true';
        let autoSample = false;

        // State
        let samples = [];
        let bestSample = null;

        // True objective function (1D for visualization)
        function trueFunction(x) {
            const nx = (x / width) * 10 - 5;
            // Mixture of Gaussians with noise
            return Math.sin(nx) * 3 + Math.exp(-((nx - 1) * (nx - 1)) / 2) * 2 +
                   Math.exp(-((nx + 2) * (nx + 2)) / 4) * 1.5 -
                   Math.cos(nx * 2) * 0.5;
        }

        // Kernel function for Gaussian Process
        function rbfKernel(x1, x2, lengthscale = width * 0.15) {
            const diff = x1 - x2;
            return Math.exp(-(diff * diff) / (2 * lengthscale * lengthscale));
        }

        // GP prediction
        function gpPredict(x) {
            if (samples.length === 0) {
                return { mean: 0, std: 1 };
            }

            // Compute kernel matrix K
            const n = samples.length;
            const K = [];
            for (let i = 0; i < n; i++) {
                K[i] = [];
                for (let j = 0; j < n; j++) {
                    K[i][j] = rbfKernel(samples[i].x, samples[j].x);
                    if (i === j) K[i][j] += 0.01; // Add noise
                }
            }

            // Compute k* (kernel between x and all samples)
            const kStar = samples.map(s => rbfKernel(x, s.x));

            // Solve K * alpha = y for alpha (simplified - using direct inversion approximation)
            // For simplicity, we'll use a weighted average based on kernel values
            let mean = 0;
            let weightSum = 0;

            for (let i = 0; i < n; i++) {
                const weight = kStar[i];
                mean += weight * samples[i].y;
                weightSum += weight;
            }

            if (weightSum > 0) {
                mean /= weightSum;
            }

            // Compute variance (simplified)
            let variance = 1.0;
            for (let i = 0; i < n; i++) {
                variance -= kStar[i] * kStar[i] / (1 + weightSum);
            }
            variance = Math.max(0.01, variance);

            return { mean, std: Math.sqrt(variance) };
        }

        // Acquisition functions
        function expectedImprovement(x) {
            if (samples.length === 0) return 1;

            const { mean, std } = gpPredict(x);
            const bestY = bestSample ? bestSample.y : -Infinity;

            const z = (mean - bestY - xi) / (std + 1e-9);
            const phi = (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * z * z);
            const Phi = 0.5 * (1 + erf(z / Math.sqrt(2)));

            return (mean - bestY - xi) * Phi + std * phi;
        }

        function upperConfidenceBound(x) {
            const { mean, std } = gpPredict(x);
            const kappa = 2.0;
            return mean + kappa * std;
        }

        function probabilityImprovement(x) {
            if (samples.length === 0) return 1;

            const { mean, std } = gpPredict(x);
            const bestY = bestSample ? bestSample.y : -Infinity;

            const z = (mean - bestY - xi) / (std + 1e-9);
            return 0.5 * (1 + erf(z / Math.sqrt(2)));
        }

        // Error function approximation
        function erf(x) {
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);

            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;

            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

            return sign * y;
        }

        function getAcquisition(x) {
            switch(acquisitionType) {
                case 'ei': return expectedImprovement(x);
                case 'ucb': return upperConfidenceBound(x);
                case 'pi': return probabilityImprovement(x);
            }
        }

        function initialize() {
            samples = [];
            // Random initialization with 3 samples
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * width;
                const y = trueFunction(x);
                samples.push({ x, y });

                if (!bestSample || y > bestSample.y) {
                    bestSample = { x, y };
                }
            }
        }

        function takeSample() {
            // Find x that maximizes acquisition function
            let bestX = 0;
            let bestAcq = -Infinity;

            for (let x = 0; x < width; x += 5) {
                const acq = getAcquisition(x);
                if (acq > bestAcq) {
                    bestAcq = acq;
                    bestX = x;
                }
            }

            // Sample at that point
            const y = trueFunction(bestX);
            samples.push({ x: bestX, y });

            if (y > bestSample.y) {
                bestSample = { x: bestX, y };
            }

            // Update info
            const trueOptimum = Math.max(...Array.from({ length: width }, (_, i) => trueFunction(i)));
            document.getElementById('samplesInfo').textContent = samples.length;
            document.getElementById('bestInfo').textContent = bestSample.y.toFixed(3);
            document.getElementById('optInfo').textContent = trueOptimum.toFixed(3);
        }

        initialize();

        // Controls
        document.getElementById('acquisition').addEventListener('change', (e) => {
            acquisitionType = e.target.value;
            document.getElementById('acqValue').textContent = e.target.options[e.target.selectedIndex].text;
        });

        document.getElementById('xi').addEventListener('input', (e) => {
            xi = parseFloat(e.target.value);
            document.getElementById('xiValue').textContent = xi.toFixed(3);
        });

        document.getElementById('viewMode').addEventListener('change', (e) => {
            viewMode = e.target.value;
            document.getElementById('viewValue').textContent = e.target.options[e.target.selectedIndex].text;
        });

        document.getElementById('step').addEventListener('click', takeSample);

        document.getElementById('auto').addEventListener('click', () => {
            autoSample = !autoSample;
            document.getElementById('auto').textContent = autoSample ? 'Stop Auto' : 'Auto Sample (slow)';
        });

        document.getElementById('reset').addEventListener('click', () => {
            initialize();
            autoSample = false;
            document.getElementById('auto').textContent = 'Auto Sample (slow)';
        });

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            const centerY = height / 2;
            const scale = 40;

            // Draw function based on view mode
            ctx.strokeStyle = '#8A9A5B';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let x = 0; x < width; x++) {
                let y;

                switch(viewMode) {
                    case 'true':
                        y = centerY - trueFunction(x) * scale;
                        break;

                    case 'surrogate':
                        const { mean } = gpPredict(x);
                        y = centerY - mean * scale;
                        break;

                    case 'acquisition':
                        const acq = getAcquisition(x);
                        y = centerY - acq * scale * 10;
                        break;

                    case 'uncertainty':
                        const pred = gpPredict(x);
                        y = centerY - pred.std * scale * 20;
                        break;
                }

                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw uncertainty band for surrogate view
            if (viewMode === 'surrogate') {
                ctx.fillStyle = 'rgba(138, 154, 91, 0.2)';
                ctx.beginPath();

                for (let x = 0; x < width; x++) {
                    const { mean, std } = gpPredict(x);
                    const y = centerY - (mean + std) * scale;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }

                for (let x = width - 1; x >= 0; x--) {
                    const { mean, std } = gpPredict(x);
                    const y = centerY - (mean - std) * scale;
                    ctx.lineTo(x, y);
                }

                ctx.closePath();
                ctx.fill();
            }

            // Draw center line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();

            // Draw samples
            samples.forEach((sample, idx) => {
                const y = centerY - sample.y * scale;

                // Line to function
                ctx.strokeStyle = 'rgba(138, 154, 91, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(sample.x, centerY);
                ctx.lineTo(sample.x, y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Sample point
                const gradient = ctx.createRadialGradient(sample.x, y, 0, sample.x, y, 10);
                gradient.addColorStop(0, 'rgba(138, 154, 91, 0.8)');
                gradient.addColorStop(1, 'rgba(138, 154, 91, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(sample.x - 10, y - 10, 20, 20);

                ctx.fillStyle = '#8A9A5B';
                ctx.beginPath();
                ctx.arc(sample.x, y, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FEFAE0';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(idx + 1, sample.x, y + 20);
            });

            // Highlight best sample
            if (bestSample) {
                const y = centerY - bestSample.y * scale;

                const glow = ctx.createRadialGradient(bestSample.x, y, 0, bestSample.x, y, 20);
                glow.addColorStop(0, 'rgba(221, 161, 94, 0.9)');
                glow.addColorStop(1, 'rgba(221, 161, 94, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(bestSample.x - 20, y - 20, 40, 40);

                ctx.fillStyle = '#DDA15E';
                ctx.beginPath();
                ctx.arc(bestSample.x, y, 7, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FEFAE0';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#DDA15E';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('BEST', bestSample.x, y - 25);
            }

            // Labels
            ctx.fillStyle = '#8A9A5B';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`View: ${viewMode}`, 20, height - 20);
        }

        // Animation loop
        let frameCount = 0;
        function animate() {
            frameCount++;

            // Auto sample every 120 frames (slower)
            if (autoSample && frameCount % 120 === 0) {
                takeSample();
            }

            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
