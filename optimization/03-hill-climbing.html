<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hill Climbing - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 280px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 350px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }

        .warning {
            color: #BC6C25;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Hill Climbing</h3>

        <div class="control-group">
            <label>Step Size: <span class="value" id="stepValue">20</span></label>
            <input type="range" id="stepSize" min="5" max="50" step="5" value="20" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Number of Attempts: <span class="value" id="attemptsValue">5</span></label>
            <input type="range" id="attempts" min="1" max="20" step="1" value="5" style="width: 100%;">
        </div>

        <button id="reset">New Random Starts</button>
        <button id="singleStep">Single Step Mode</button>
    </div>

    <div class="info">
        <h4>Algorithm: Hill Climbing</h4>
        <p>Greedy local search that always moves to the best neighboring position. Gets stuck at local maxima!</p>
        <p><strong>Active Climbers:</strong> <span class="stat" id="activeInfo">0</span></p>
        <p><strong>Stuck at Local Max:</strong> <span class="warning" id="stuckInfo">0</span></p>
        <p><strong>Global Maximum:</strong> <span class="stat" id="globalInfo">-</span></p>
        <p><strong>Best Found:</strong> <span class="stat" id="bestInfo">-</span></p>
        <p><em>Watch multiple climbers get trapped in different local maxima!</em></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let stepSize = 20;
        let numAttempts = 5;
        let singleStepMode = false;

        // Fitness landscape - multiple peaks of different heights
        const peaks = [];

        function generatePeaks() {
            peaks.length = 0;
            // Create 5-10 random peaks
            const numPeaks = 5 + Math.floor(Math.random() * 6);
            for (let i = 0; i < numPeaks; i++) {
                peaks.push({
                    x: 200 + Math.random() * (width - 400),
                    y: 200 + Math.random() * (height - 400),
                    height: 3 + Math.random() * 7,
                    radius: 80 + Math.random() * 120
                });
            }

            // Ensure there's one clear global maximum
            const globalPeak = peaks[Math.floor(Math.random() * peaks.length)];
            globalPeak.height = 10;
            globalPeak.isGlobal = true;
        }

        function fitness(x, y) {
            let maxFitness = 0;
            peaks.forEach(peak => {
                const dx = x - peak.x;
                const dy = y - peak.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const f = peak.height * Math.exp(-(dist * dist) / (2 * peak.radius * peak.radius));
                maxFitness = Math.max(maxFitness, f);
            });
            return maxFitness;
        }

        // Climbers
        let climbers = [];

        function createClimbers() {
            climbers = [];
            for (let i = 0; i < numAttempts; i++) {
                climbers.push({
                    x: 100 + Math.random() * (width - 200),
                    y: 100 + Math.random() * (height - 200),
                    history: [],
                    stuck: false,
                    stuckCounter: 0
                });
            }
            climbers.forEach(c => {
                c.history.push({ x: c.x, y: c.y, fitness: fitness(c.x, c.y) });
            });
        }

        function reset() {
            generatePeaks();
            createClimbers();
        }

        reset();

        // Controls
        document.getElementById('stepSize').addEventListener('input', (e) => {
            stepSize = parseFloat(e.target.value);
            document.getElementById('stepValue').textContent = stepSize;
        });

        document.getElementById('attempts').addEventListener('input', (e) => {
            numAttempts = parseInt(e.target.value);
            document.getElementById('attemptsValue').textContent = numAttempts;
            reset();
        });

        document.getElementById('reset').addEventListener('click', reset);
        document.getElementById('singleStep').addEventListener('click', () => {
            singleStepMode = !singleStepMode;
            document.getElementById('singleStep').textContent =
                singleStepMode ? 'Continuous Mode' : 'Single Step Mode';
        });

        // Hill climbing step
        function step() {
            climbers.forEach(climber => {
                if (climber.stuck) return;

                const currentFitness = fitness(climber.x, climber.y);

                // Check 8 neighbors
                const neighbors = [
                    { dx: -stepSize, dy: 0 },
                    { dx: stepSize, dy: 0 },
                    { dx: 0, dy: -stepSize },
                    { dx: 0, dy: stepSize },
                    { dx: -stepSize, dy: -stepSize },
                    { dx: stepSize, dy: -stepSize },
                    { dx: -stepSize, dy: stepSize },
                    { dx: stepSize, dy: stepSize }
                ];

                let bestNeighbor = null;
                let bestFitness = currentFitness;

                neighbors.forEach(n => {
                    const nx = climber.x + n.dx;
                    const ny = climber.y + n.dy;

                    // Keep in bounds
                    if (nx < 50 || nx > width - 50 || ny < 50 || ny > height - 50) return;

                    const nf = fitness(nx, ny);
                    if (nf > bestFitness) {
                        bestFitness = nf;
                        bestNeighbor = { x: nx, y: ny };
                    }
                });

                if (bestNeighbor) {
                    climber.x = bestNeighbor.x;
                    climber.y = bestNeighbor.y;
                    climber.history.push({ x: climber.x, y: climber.y, fitness: bestFitness });
                    climber.stuckCounter = 0;
                } else {
                    // No better neighbor found - stuck at local maximum!
                    climber.stuckCounter++;
                    if (climber.stuckCounter > 5) {
                        climber.stuck = true;
                    }
                }
            });

            // Update stats
            const active = climbers.filter(c => !c.stuck).length;
            const stuck = climbers.filter(c => c.stuck).length;
            const globalMax = Math.max(...peaks.map(p => p.height));
            const bestFound = Math.max(...climbers.map(c =>
                c.history.length > 0 ? c.history[c.history.length - 1].fitness : 0
            ));

            document.getElementById('activeInfo').textContent = active;
            document.getElementById('stuckInfo').textContent = stuck;
            document.getElementById('globalInfo').textContent = globalMax.toFixed(2);
            document.getElementById('bestInfo').textContent = bestFound.toFixed(2);
        }

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw fitness landscape contours
            const gridSize = 20;
            for (let x = 0; x < width; x += gridSize) {
                for (let y = 0; y < height; y += gridSize) {
                    const f = fitness(x, y);
                    const intensity = Math.min(1, f / 10);

                    const r = Math.floor(138 * intensity);
                    const g = Math.floor(154 * intensity);
                    const b = Math.floor(91 * intensity);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + intensity * 0.4})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }

            // Draw peak markers
            peaks.forEach(peak => {
                if (peak.isGlobal) {
                    // Global maximum - special marker
                    ctx.strokeStyle = '#DDA15E';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(peak.x, peak.y, peak.radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.fillStyle = '#DDA15E';
                    ctx.font = 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('GLOBAL MAX', peak.x, peak.y - peak.radius * 0.8);
                }
            });

            // Draw climber paths
            climbers.forEach((climber, idx) => {
                const hue = (idx / numAttempts) * 360;

                // Path
                if (climber.history.length > 1) {
                    ctx.strokeStyle = climber.stuck
                        ? 'rgba(188, 108, 37, 0.6)'
                        : `hsla(${hue}, 70%, 60%, 0.6)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    climber.history.forEach((pos, i) => {
                        if (i === 0) ctx.moveTo(pos.x, pos.y);
                        else ctx.lineTo(pos.x, pos.y);
                    });
                    ctx.stroke();
                }

                // Current position
                const currentPos = climber.history[climber.history.length - 1];

                // Glow
                const gradient = ctx.createRadialGradient(
                    currentPos.x, currentPos.y, 0,
                    currentPos.x, currentPos.y, 20
                );
                gradient.addColorStop(0, climber.stuck
                    ? 'rgba(188, 108, 37, 0.8)'
                    : `hsla(${hue}, 70%, 60%, 0.8)`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(currentPos.x - 20, currentPos.y - 20, 40, 40);

                // Climber
                ctx.fillStyle = climber.stuck ? '#BC6C25' : `hsl(${hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(currentPos.x, currentPos.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FEFAE0';
                ctx.lineWidth = 2;
                ctx.stroke();

                // "STUCK" label
                if (climber.stuck) {
                    ctx.fillStyle = '#BC6C25';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('STUCK', currentPos.x, currentPos.y - 20);
                }

                // Start marker
                if (climber.history.length > 0) {
                    const start = climber.history[0];
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.5)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(start.x, start.y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
        }

        // Animation loop
        let frameCount = 0;
        function animate() {
            frameCount++;

            // Update every 10 frames (slower animation)
            if (!singleStepMode && frameCount % 10 === 0) {
                step();
            } else if (singleStepMode && frameCount % 60 === 0) {
                step();
            }

            render();
            requestAnimationFrame(animate);
        }

        window.reset = reset;
        animate();

        // Allow clicking to manually step in single-step mode
        canvas.addEventListener('click', () => {
            if (singleStepMode) {
                step();
            }
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
