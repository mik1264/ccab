<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convex vs Non-Convex - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 380px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }

        .warning {
            color: #BC6C25;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Convex vs Non-Convex</h3>

        <div class="control-group">
            <label>Algorithm: <span class="value" id="algoValue">Gradient Descent</span></label>
            <select id="algorithm" style="width: 100%; padding: 8px; border-radius: 4px; background: #1a1f2e; color: #e0e0e0; border: 1px solid #8A9A5B;">
                <option value="gd">Gradient Descent</option>
                <option value="momentum">Momentum</option>
                <option value="adam">Adam</option>
            </select>
        </div>

        <div class="control-group">
            <label>Learning Rate: <span class="value" id="lrValue">0.02</span></label>
            <input type="range" id="learningRate" min="0.005" max="0.1" step="0.005" value="0.02" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Number of Runs: <span class="value" id="runsValue">10</span></label>
            <input type="range" id="numRuns" min="5" max="30" step="5" value="10" style="width: 100%;">
        </div>

        <button id="runConvex">Run on Convex (Left)</button>
        <button id="runNonConvex">Run on Non-Convex (Right)</button>
        <button id="runBoth">Run on Both</button>
        <button id="clear">Clear All</button>
    </div>

    <div class="info">
        <h4>Convex vs Non-Convex Optimization</h4>
        <p><strong>Convex (Left):</strong> Bowl-shaped, any local minimum is the global minimum. Gradient descent always finds the optimum.</p>
        <p><strong>Non-Convex (Right):</strong> Multiple peaks and valleys. Gradient descent gets trapped in local minima depending on starting point.</p>
        <p><span class="stat">Green = global minimum</span><br>
        <span class="warning">Red = local minima (traps)</span></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let algorithm = 'gd';
        let learningRate = 0.02;
        let numRuns = 10;

        // State
        let convexRuns = [];
        let nonConvexRuns = [];

        // Fitness functions (minimize)
        function convexFitness(x, y) {
            // Simple quadratic bowl
            const cx = width * 0.25;
            const cy = height * 0.5;
            const dx = (x - cx) / 100;
            const dy = (y - cy) / 100;
            return dx * dx + dy * dy;
        }

        function nonConvexFitness(x, y) {
            // Multiple local minima
            const cx = width * 0.75;
            const cy = height * 0.5;
            const dx = (x - cx) / 50;
            const dy = (y - cy) / 50;

            // Base quadratic with oscillations
            return (dx * dx + dy * dy) / 2 +
                   Math.sin(dx * 3) * Math.cos(dy * 3) * 2 +
                   Math.sin(dx * 1.5) * 1.5 +
                   Math.cos(dy * 1.5) * 1.5;
        }

        function gradient(x, y, isConvex) {
            const h = 0.5;
            const fitness = isConvex ? convexFitness : nonConvexFitness;

            const dx = (fitness(x + h, y) - fitness(x - h, y)) / (2 * h);
            const dy = (fitness(x, y + h) - fitness(x, y - h)) / (2 * h);

            return { dx, dy };
        }

        function optimize(startX, startY, isConvex) {
            const history = [];
            let x = startX, y = startY;
            let vx = 0, vy = 0;
            let mx = 0, my = 0; // For Adam
            let vx2 = 0, vy2 = 0; // For Adam
            let t = 0;

            const fitness = isConvex ? convexFitness : nonConvexFitness;

            for (let step = 0; step < 500; step++) {
                const grad = gradient(x, y, isConvex);

                switch(algorithm) {
                    case 'gd':
                        vx = -learningRate * grad.dx * 100;
                        vy = -learningRate * grad.dy * 100;
                        break;

                    case 'momentum':
                        const beta = 0.9;
                        vx = beta * vx - learningRate * grad.dx * 100;
                        vy = beta * vy - learningRate * grad.dy * 100;
                        break;

                    case 'adam':
                        t++;
                        const beta1 = 0.9, beta2 = 0.999, eps = 1e-8;
                        mx = beta1 * mx + (1 - beta1) * grad.dx;
                        my = beta1 * my + (1 - beta1) * grad.dy;
                        vx2 = beta2 * vx2 + (1 - beta2) * grad.dx * grad.dx;
                        vy2 = beta2 * vy2 + (1 - beta2) * grad.dy * grad.dy;

                        const mxHat = mx / (1 - Math.pow(beta1, t));
                        const myHat = my / (1 - Math.pow(beta1, t));
                        const vx2Hat = vx2 / (1 - Math.pow(beta2, t));
                        const vy2Hat = vy2 / (1 - Math.pow(beta2, t));

                        vx = -learningRate * mxHat / (Math.sqrt(vx2Hat) + eps) * 100;
                        vy = -learningRate * myHat / (Math.sqrt(vy2Hat) + eps) * 100;
                        break;
                }

                x += vx;
                y += vy;

                // Keep in bounds
                const leftSide = isConvex;
                const minX = leftSide ? 0 : width / 2;
                const maxX = leftSide ? width / 2 : width;

                x = Math.max(minX, Math.min(maxX, x));
                y = Math.max(0, Math.min(height, y));

                if (step % 3 === 0) {
                    history.push({ x, y, fitness: fitness(x, y) });
                }

                // Early stop if converged
                if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) break;
            }

            return history;
        }

        function runOnLandscape(isConvex) {
            const runs = [];
            const leftSide = isConvex;
            const minX = leftSide ? 50 : width / 2 + 50;
            const maxX = leftSide ? width / 2 - 50 : width - 50;

            for (let i = 0; i < numRuns; i++) {
                const startX = minX + Math.random() * (maxX - minX);
                const startY = 50 + Math.random() * (height - 100);

                const history = optimize(startX, startY, isConvex);
                runs.push({
                    start: { x: startX, y: startY },
                    history,
                    final: history[history.length - 1]
                });
            }

            if (isConvex) {
                convexRuns = runs;
            } else {
                nonConvexRuns = runs;
            }
        }

        // Controls
        document.getElementById('algorithm').addEventListener('change', (e) => {
            algorithm = e.target.value;
            document.getElementById('algoValue').textContent = e.target.options[e.target.selectedIndex].text;
        });

        document.getElementById('learningRate').addEventListener('input', (e) => {
            learningRate = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = learningRate.toFixed(3);
        });

        document.getElementById('numRuns').addEventListener('input', (e) => {
            numRuns = parseInt(e.target.value);
            document.getElementById('runsValue').textContent = numRuns;
        });

        document.getElementById('runConvex').addEventListener('click', () => runOnLandscape(true));
        document.getElementById('runNonConvex').addEventListener('click', () => runOnLandscape(false));
        document.getElementById('runBoth').addEventListener('click', () => {
            runOnLandscape(true);
            runOnLandscape(false);
        });

        document.getElementById('clear').addEventListener('click', () => {
            convexRuns = [];
            nonConvexRuns = [];
        });

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw divider
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('CONVEX', width * 0.25, 60);
            ctx.fillText('NON-CONVEX', width * 0.75, 60);

            const gridSize = 25;

            // Draw convex landscape (left)
            for (let x = 0; x < width / 2; x += gridSize) {
                for (let y = 80; y < height; y += gridSize) {
                    const f = convexFitness(x, y);
                    const intensity = Math.max(0, 1 - f / 10);

                    const r = Math.floor(138 * intensity);
                    const g = Math.floor(154 * intensity);
                    const b = Math.floor(91 * intensity);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + intensity * 0.4})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }

            // Draw non-convex landscape (right)
            for (let x = width / 2; x < width; x += gridSize) {
                for (let y = 80; y < height; y += gridSize) {
                    const f = nonConvexFitness(x, y);
                    const maxF = 15;
                    const intensity = Math.max(0, 1 - (f + 5) / maxF);

                    const r = Math.floor(138 * intensity);
                    const g = Math.floor(154 * intensity);
                    const b = Math.floor(91 * intensity);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + intensity * 0.4})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }

            // Draw global minima markers
            // Convex global minimum
            const convexMin = { x: width * 0.25, y: height * 0.5 };
            ctx.strokeStyle = '#8A9A5B';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(convexMin.x, convexMin.y, 25, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#8A9A5B';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GLOBAL MIN', convexMin.x, convexMin.y + 45);

            // Non-convex has multiple local minima
            // Mark a few
            const localMinima = [
                { x: width * 0.75, y: height * 0.5 },
                { x: width * 0.75 - 80, y: height * 0.5 - 80 },
                { x: width * 0.75 + 90, y: height * 0.5 + 70 }
            ];

            localMinima.forEach((min, idx) => {
                const isGlobal = idx === 0;
                ctx.strokeStyle = isGlobal ? '#8A9A5B' : '#BC6C25';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(min.x, min.y, 15, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = isGlobal ? '#8A9A5B' : '#BC6C25';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(isGlobal ? 'GLOBAL' : 'LOCAL', min.x, min.y + 30);
            });

            // Draw runs
            function drawRuns(runs) {
                runs.forEach((run, idx) => {
                    const hue = (idx / numRuns) * 60 + 180;

                    // Path
                    ctx.strokeStyle = `hsla(${hue}, 60%, 60%, 0.5)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    run.history.forEach((pos, i) => {
                        if (i === 0) ctx.moveTo(pos.x, pos.y);
                        else ctx.lineTo(pos.x, pos.y);
                    });
                    ctx.stroke();

                    // Final position
                    const final = run.final;
                    ctx.fillStyle = `hsla(${hue}, 60%, 60%, 0.7)`;
                    ctx.beginPath();
                    ctx.arc(final.x, final.y, 5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#FEFAE0';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Start marker
                    ctx.strokeStyle = `hsla(${hue}, 60%, 60%, 0.5)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(run.start.x, run.start.y, 4, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            drawRuns(convexRuns);
            drawRuns(nonConvexRuns);
        }

        // Animation loop
        function animate() {
            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
