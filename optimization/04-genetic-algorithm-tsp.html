<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm - TSP - Optimization Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(138, 154, 91, 0.9);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(138, 154, 91, 1);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #8A9A5B;
            font-size: 18px;
            border-bottom: 2px solid rgba(138, 154, 91, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 13px;
        }

        .value {
            color: #DDA15E;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #8A9A5B, #606C38);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 154, 91, 0.4);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            max-width: 350px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .info h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat {
            color: #DDA15E;
            font-weight: 600;
        }

        .chart {
            margin-top: 15px;
            height: 100px;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas#convergence {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="controls">
        <h3>Genetic Algorithm (TSP)</h3>

        <div class="control-group">
            <label>Population Size: <span class="value" id="popValue">100</span></label>
            <input type="range" id="popSize" min="20" max="200" step="20" value="100" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Mutation Rate: <span class="value" id="mutationValue">0.02</span></label>
            <input type="range" id="mutationRate" min="0.01" max="0.2" step="0.01" value="0.02" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Elite Count: <span class="value" id="eliteValue">10</span></label>
            <input type="range" id="eliteCount" min="0" max="50" step="5" value="10" style="width: 100%;">
        </div>

        <div class="control-group">
            <label>Cities: <span class="value" id="citiesValue">20</span></label>
            <input type="range" id="numCities" min="10" max="40" step="5" value="20" style="width: 100%;">
        </div>

        <button id="reset">Reset & New Cities</button>
        <button id="pause">Pause</button>

        <div class="chart">
            <canvas id="convergence"></canvas>
        </div>
    </div>

    <div class="info">
        <h4>Algorithm: Genetic Algorithm</h4>
        <p>Evolves population of solutions through selection, crossover, and mutation inspired by natural evolution.</p>
        <p><strong>Generation:</strong> <span class="stat" id="genInfo">0</span></p>
        <p><strong>Best Distance:</strong> <span class="stat" id="bestInfo">-</span></p>
        <p><strong>Average Distance:</strong> <span class="stat" id="avgInfo">-</span></p>
        <p><strong>Improvement:</strong> <span class="stat" id="improvementInfo">-</span></p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const convCanvas = document.getElementById('convergence');
        const convCtx = convCanvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            convCanvas.width = convCanvas.offsetWidth * window.devicePixelRatio;
            convCanvas.height = convCanvas.offsetHeight * window.devicePixelRatio;
            convCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let popSize = 100;
        let mutationRate = 0.02;
        let eliteCount = 10;
        let numCities = 20;

        // State
        let cities = [];
        let population = [];
        let generation = 0;
        let paused = false;
        let convergenceHistory = [];
        let initialBest = null;

        function distance(city1, city2) {
            const dx = city1.x - city2.x;
            const dy = city1.y - city2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function totalDistance(route) {
            let sum = 0;
            for (let i = 0; i < route.length; i++) {
                const city1 = cities[route[i]];
                const city2 = cities[route[(i + 1) % route.length]];
                sum += distance(city1, city2);
            }
            return sum;
        }

        function generateCities() {
            cities = [];
            const margin = 150;
            for (let i = 0; i < numCities; i++) {
                cities.push({
                    x: margin + Math.random() * (width - margin * 2),
                    y: margin + Math.random() * (height - margin * 2)
                });
            }
        }

        function createRandomRoute() {
            const route = Array.from({ length: numCities }, (_, i) => i);
            for (let i = route.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [route[i], route[j]] = [route[j], route[i]];
            }
            return route;
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                population.push({
                    route: createRandomRoute(),
                    fitness: 0
                });
            }
            evaluateFitness();
        }

        function evaluateFitness() {
            population.forEach(individual => {
                const dist = totalDistance(individual.route);
                individual.fitness = 1 / (dist + 1); // Higher fitness = shorter distance
                individual.distance = dist;
            });
            population.sort((a, b) => b.fitness - a.fitness);
        }

        function selection() {
            // Tournament selection
            const tournamentSize = 5;
            const tournament = [];
            for (let i = 0; i < tournamentSize; i++) {
                tournament.push(population[Math.floor(Math.random() * population.length)]);
            }
            tournament.sort((a, b) => b.fitness - a.fitness);
            return tournament[0];
        }

        function crossover(parent1, parent2) {
            // Order crossover (OX)
            const start = Math.floor(Math.random() * numCities);
            const end = start + Math.floor(Math.random() * (numCities - start));

            const child = new Array(numCities).fill(-1);

            // Copy segment from parent1
            for (let i = start; i <= end; i++) {
                child[i] = parent1.route[i];
            }

            // Fill remaining from parent2
            let childIdx = (end + 1) % numCities;
            let parent2Idx = (end + 1) % numCities;

            while (childIdx !== start) {
                const gene = parent2.route[parent2Idx];
                if (!child.includes(gene)) {
                    child[childIdx] = gene;
                    childIdx = (childIdx + 1) % numCities;
                }
                parent2Idx = (parent2Idx + 1) % numCities;
            }

            return { route: child, fitness: 0 };
        }

        function mutate(individual) {
            if (Math.random() < mutationRate) {
                // Swap mutation
                const i = Math.floor(Math.random() * numCities);
                const j = Math.floor(Math.random() * numCities);
                [individual.route[i], individual.route[j]] = [individual.route[j], individual.route[i]];
            }
        }

        function evolve() {
            const newPopulation = [];

            // Elitism - keep best individuals
            for (let i = 0; i < eliteCount; i++) {
                newPopulation.push({ ...population[i], route: [...population[i].route] });
            }

            // Generate rest through crossover and mutation
            while (newPopulation.length < popSize) {
                const parent1 = selection();
                const parent2 = selection();
                const child = crossover(parent1, parent2);
                mutate(child);
                newPopulation.push(child);
            }

            population = newPopulation;
            evaluateFitness();
        }

        function reset() {
            generateCities();
            initPopulation();
            generation = 0;
            convergenceHistory = [];
            initialBest = population[0].distance;
        }

        reset();

        // Controls
        document.getElementById('popSize').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
            reset();
        });

        document.getElementById('mutationRate').addEventListener('input', (e) => {
            mutationRate = parseFloat(e.target.value);
            document.getElementById('mutationValue').textContent = mutationRate.toFixed(2);
        });

        document.getElementById('eliteCount').addEventListener('input', (e) => {
            eliteCount = parseInt(e.target.value);
            document.getElementById('eliteValue').textContent = eliteCount;
        });

        document.getElementById('numCities').addEventListener('input', (e) => {
            numCities = parseInt(e.target.value);
            document.getElementById('citiesValue').textContent = numCities;
            reset();
        });

        document.getElementById('reset').addEventListener('click', reset);
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });

        // Update
        function update() {
            if (paused) return;

            evolve();
            generation++;

            const best = population[0];
            const avgDist = population.reduce((sum, ind) => sum + ind.distance, 0) / population.length;

            convergenceHistory.push(best.distance);
            if (convergenceHistory.length > 200) {
                convergenceHistory.shift();
            }

            // Update info
            document.getElementById('genInfo').textContent = generation;
            document.getElementById('bestInfo').textContent = best.distance.toFixed(1);
            document.getElementById('avgInfo').textContent = avgDist.toFixed(1);
            if (initialBest) {
                const improvement = ((initialBest - best.distance) / initialBest * 100).toFixed(1);
                document.getElementById('improvementInfo').textContent = improvement + '%';
            }
        }

        // Render convergence chart
        function renderConvergence() {
            const w = convCanvas.offsetWidth;
            const h = convCanvas.offsetHeight;

            convCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            convCtx.fillRect(0, 0, w, h);

            if (convergenceHistory.length < 2) return;

            const maxDist = Math.max(...convergenceHistory);
            const minDist = Math.min(...convergenceHistory);
            const range = maxDist - minDist || 1;

            convCtx.strokeStyle = '#8A9A5B';
            convCtx.lineWidth = 2;
            convCtx.beginPath();

            convergenceHistory.forEach((dist, i) => {
                const x = (i / convergenceHistory.length) * w;
                const y = h - ((dist - minDist) / range) * h * 0.9 - h * 0.05;

                if (i === 0) convCtx.moveTo(x, y);
                else convCtx.lineTo(x, y);
            });

            convCtx.stroke();

            // Labels
            convCtx.fillStyle = '#b0b0b0';
            convCtx.font = '10px monospace';
            convCtx.fillText(`Max: ${maxDist.toFixed(0)}`, 5, 15);
            convCtx.fillText(`Min: ${minDist.toFixed(0)}`, 5, h - 5);
        }

        // Render
        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw some population members (faint)
            for (let i = 5; i < Math.min(15, population.length); i++) {
                const individual = population[i];
                ctx.strokeStyle = 'rgba(96, 108, 56, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let j = 0; j < individual.route.length; j++) {
                    const city = cities[individual.route[j]];
                    if (j === 0) ctx.moveTo(city.x, city.y);
                    else ctx.lineTo(city.x, city.y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            // Draw best route
            const best = population[0];
            ctx.strokeStyle = '#8A9A5B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < best.route.length; i++) {
                const city = cities[best.route[i]];
                if (i === 0) ctx.moveTo(city.x, city.y);
                else ctx.lineTo(city.x, city.y);
            }
            ctx.closePath();
            ctx.stroke();

            // Draw cities
            cities.forEach((city, idx) => {
                // Glow
                const gradient = ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, 15);
                gradient.addColorStop(0, 'rgba(221, 161, 94, 0.6)');
                gradient.addColorStop(1, 'rgba(221, 161, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(city.x - 15, city.y - 15, 30, 30);

                // City
                ctx.fillStyle = '#DDA15E';
                ctx.beginPath();
                ctx.arc(city.x, city.y, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FEFAE0';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            renderConvergence();
        }

        // Animation loop
        let frameCount = 0;
        function animate() {
            frameCount++;

            if (frameCount % 3 === 0) {
                update();
            }

            render();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
