<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmoothLife - Continuous Game of Life - CCAB</title>
    <meta name="description" content="SmoothLife: Stephan Rafler's continuous generalization of Conway's Game of Life. Watch organic gliders, pulsating blobs, and connective ribbons emerge from mathematical rules.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #7fdbff;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(127, 219, 255, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(127, 219, 255, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            color: #7fdbff;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(127, 219, 255, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 140px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(127, 219, 255, 0.15);
            border: 1px solid rgba(127, 219, 255, 0.4);
            color: #7fdbff;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(127, 219, 255, 0.3);
        }

        button.active {
            background: rgba(127, 219, 255, 0.4);
            border-color: #7fdbff;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(127, 219, 255, 0.2);
        }

        .control-group label {
            color: #7fdbff;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #7fdbff;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: #7fdbff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #7fdbff;
            font-size: 18px;
            z-index: 2000;
        }

        #error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2000;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            display: none;
        }

        #legend {
            position: fixed;
            bottom: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 11px;
            z-index: 1000;
        }

        #legend .gradient {
            width: 150px;
            height: 15px;
            background: linear-gradient(to right, #000033, #003366, #0066cc, #00ccff, #66ffff, #ffffff);
            border-radius: 4px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="info">
        <h3>SmoothLife</h3>
        <div>Preset: <span id="preset-name">Classic</span></div>
        <p>Stephan Rafler's continuous generalization of Conway's Game of Life. Instead of discrete cells, states smoothly transition between 0.0 and 1.0. The rules use disk/annulus integrals with sigmoid transition functions.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="classic">Classic</button>
        <button data-preset="gliders">Glider Factory</button>
        <button data-preset="smooth">Ultra Smooth</button>
        <button data-preset="unstable">Unstable</button>
        <button data-preset="coral">Coral Growth</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Outer Radius: <span id="ra-val">6</span></label>
            <input type="range" id="ra" min="4" max="10" value="6" step="1">
        </div>
        <div class="control-group">
            <label>Inner Radius: <span id="ri-val">2</span></label>
            <input type="range" id="ri" min="1" max="5" value="2" step="0.5">
        </div>
        <div class="control-group">
            <label>dt: <span id="dt-val">0.5</span></label>
            <input type="range" id="dt" min="0.1" max="1.0" value="0.5" step="0.05">
        </div>
        <button id="reset">Reset</button>
        <button id="pause">Pause</button>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <div id="legend">
        <div>Cell State (0.0 → 1.0)</div>
        <div class="gradient"></div>
    </div>

    <div id="loading">Initializing SmoothLife...</div>
    <div id="error"></div>

    <canvas id="canvas"></canvas>

    <script>
        // SmoothLife - Continuous Game of Life by Stephan Rafler
        // Based on paper: "Generalization of Conway's 'Game of Life' to a continuous domain"

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');

        if (!gl) {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.textContent = 'WebGL2 is not supported in your browser';
            throw new Error('WebGL2 not supported');
        }

        // Simulation parameters - Game of Life-like but continuous
        // Birth: neighbor density in [b1, b2] -> cell becomes alive
        // Survival: neighbor density in [d1, d2] -> cell stays alive
        let params = {
            ra: 6,        // Outer radius (annulus outer)
            ri: 2,        // Inner radius (disk)
            b1: 0.20,     // Birth threshold low (~3/8 neighbors in GoL)
            b2: 0.35,     // Birth threshold high
            d1: 0.15,     // Survival threshold low (~2/8 neighbors)
            d2: 0.45,     // Survival threshold high (~4/8 neighbors)
            alphaM: 0.147, // Unused
            alphaN: 0.028, // Unused
            dt: 0.5       // Faster time step for visible changes
        };

        // Presets - various SmoothLife behaviors
        const presets = {
            classic: {
                // Game of Life-like continuous behavior
                ra: 6, ri: 2, b1: 0.20, b2: 0.35, d1: 0.15, d2: 0.45,
                alphaM: 0.147, alphaN: 0.028, dt: 0.5
            },
            gliders: {
                // Tighter thresholds for glider-like motion
                ra: 5, ri: 1.5, b1: 0.25, b2: 0.32, d1: 0.20, d2: 0.38,
                alphaM: 0.147, alphaN: 0.028, dt: 0.4
            },
            smooth: {
                // Slow, smooth transitions
                ra: 7, ri: 2.33, b1: 0.18, b2: 0.30, d1: 0.12, d2: 0.40,
                alphaM: 0.3, alphaN: 0.1, dt: 0.2
            },
            unstable: {
                // Chaotic, constantly changing
                ra: 5, ri: 1.5, b1: 0.15, b2: 0.45, d1: 0.10, d2: 0.50,
                alphaM: 0.1, alphaN: 0.03, dt: 0.8
            },
            coral: {
                // Growth-focused
                ra: 6, ri: 2, b1: 0.15, b2: 0.40, d1: 0.20, d2: 0.55,
                alphaM: 0.12, alphaN: 0.03, dt: 0.3
            }
        };

        let width, height;
        let paused = false;

        // Resize canvas
        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            width = Math.floor(window.innerWidth * 0.5);  // Lower resolution for performance
            height = Math.floor(window.innerHeight * 0.5);
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, width, height);
        }

        // Shader sources
        const quadVert = `#version 300 es
            in vec2 position;
            out vec2 vUv;
            void main() {
                vUv = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // SmoothLife simulation fragment shader
        // Simplified implementation focusing on stability
        const smoothLifeFrag = `#version 300 es
            precision highp float;

            uniform sampler2D uState;
            uniform vec2 uResolution;
            uniform float uRa;      // Outer radius
            uniform float uRi;      // Inner radius
            uniform float uB1;      // Birth low
            uniform float uB2;      // Birth high
            uniform float uD1;      // Survival low
            uniform float uD2;      // Survival high
            uniform float uAlphaM;  // Unused but kept for compatibility
            uniform float uAlphaN;  // Sigmoid sharpness
            uniform float uDt;      // Time step

            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                vec2 pixel = 1.0 / uResolution;

                // Compute disk integral (m) and annulus integral (n)
                float m = 0.0;
                float mCount = 0.0;
                float n = 0.0;
                float nCount = 0.0;

                int ra = int(ceil(uRa));

                // Sample neighborhoods
                for (int dy = -ra; dy <= ra; dy++) {
                    for (int dx = -ra; dx <= ra; dx++) {
                        float d = sqrt(float(dx * dx + dy * dy));

                        // Skip if outside outer radius
                        if (d > uRa) continue;

                        vec2 offset = vec2(float(dx), float(dy)) * pixel;
                        float val = texture(uState, fract(vUv + offset)).r;

                        if (d <= uRi) {
                            // Inner disk
                            m += val;
                            mCount += 1.0;
                        } else {
                            // Outer annulus
                            n += val;
                            nCount += 1.0;
                        }
                    }
                }

                // Normalize to get averages
                m = mCount > 0.0 ? m / mCount : 0.0;
                n = nCount > 0.0 ? n / nCount : 0.0;

                // SmoothLife transition function
                // If cell is alive (m > 0.5), use survival thresholds
                // If cell is dead (m <= 0.5), use birth thresholds
                float alive = step(0.5, m);

                // Determine target state based on neighbor density n
                float birthOK = step(uB1, n) * step(n, uB2);    // n in [b1, b2]
                float surviveOK = step(uD1, n) * step(n, uD2);  // n in [d1, d2]

                // Target is 1 if (dead and birth) or (alive and survive)
                float target = (1.0 - alive) * birthOK + alive * surviveOK;

                // Smooth transition
                float current = texture(uState, vUv).r;
                float newState = current + uDt * (target - current);
                newState = clamp(newState, 0.0, 1.0);

                fragColor = vec4(newState, newState, newState, 1.0);
            }
        `;

        // Render fragment shader - visualizes the state with color mapping
        const renderFrag = `#version 300 es
            precision highp float;

            uniform sampler2D uState;

            in vec2 vUv;
            out vec4 fragColor;

            vec3 colorMap(float t) {
                // Ocean/biological color scheme
                vec3 c0 = vec3(0.0, 0.02, 0.1);     // Deep blue
                vec3 c1 = vec3(0.0, 0.2, 0.4);      // Ocean blue
                vec3 c2 = vec3(0.0, 0.5, 0.8);      // Bright blue
                vec3 c3 = vec3(0.2, 0.8, 0.9);      // Cyan
                vec3 c4 = vec3(0.6, 1.0, 1.0);      // Light cyan
                vec3 c5 = vec3(1.0, 1.0, 1.0);      // White

                if (t < 0.2) return mix(c0, c1, t * 5.0);
                if (t < 0.4) return mix(c1, c2, (t - 0.2) * 5.0);
                if (t < 0.6) return mix(c2, c3, (t - 0.4) * 5.0);
                if (t < 0.8) return mix(c3, c4, (t - 0.6) * 5.0);
                return mix(c4, c5, (t - 0.8) * 5.0);
            }

            void main() {
                float state = texture(uState, vUv).r;
                vec3 color = colorMap(state);
                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(vertSrc, fragSrc) {
            const vert = compileShader(vertSrc, gl.VERTEX_SHADER);
            const frag = compileShader(fragSrc, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vert);
            gl.attachShader(program, frag);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Create texture
        function createTexture(w, h, data = null) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, w, h, 0, gl.RED, gl.FLOAT, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return tex;
        }

        // Create framebuffer
        function createFramebuffer(texture) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            return fb;
        }

        // Initialize state with random blobs
        function initState() {
            const data = new Float32Array(width * height);

            // Create multiple overlapping blobs with partial fill
            // This ensures cells have neighbors in their annulus
            const numBlobs = 20 + Math.floor(Math.random() * 15);
            const baseRadius = params.ra * 2.5; // Larger blobs for better neighbor density

            for (let i = 0; i < numBlobs; i++) {
                const cx = Math.random() * width;
                const cy = Math.random() * height;
                const r = baseRadius * (0.5 + Math.random() * 1.0);

                for (let y = Math.max(0, Math.floor(cy - r)); y < Math.min(height, Math.ceil(cy + r)); y++) {
                    for (let x = Math.max(0, Math.floor(cx - r)); x < Math.min(width, Math.ceil(cx + r)); x++) {
                        const dx = x - cx;
                        const dy = y - cy;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d < r) {
                            // Fill with value based on distance + randomness
                            // This creates a noisy blob that isn't solid
                            const baseFill = 0.6 + 0.4 * (1.0 - d / r);
                            const noise = Math.random() * 0.4;
                            const val = baseFill * (0.7 + noise);
                            data[y * width + x] = Math.max(data[y * width + x], val);
                        }
                    }
                }
            }

            // Add scattered random cells throughout
            for (let i = 0; i < width * height * 0.1; i++) {
                const x = Math.floor(Math.random() * width);
                const y = Math.floor(Math.random() * height);
                if (data[y * width + x] < 0.3) {
                    data[y * width + x] = 0.5 + Math.random() * 0.5;
                }
            }

            return data;
        }

        // Setup
        resize();

        // Check for float texture support
        const ext = gl.getExtension('EXT_color_buffer_float');
        if (!ext) {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.textContent = 'EXT_color_buffer_float not supported';
            throw new Error('Float textures not supported');
        }

        // Create programs
        const simProgram = createProgram(quadVert, smoothLifeFrag);
        const renderProgram = createProgram(quadVert, renderFrag);

        // Get uniform locations
        const simUniforms = {
            uState: gl.getUniformLocation(simProgram, 'uState'),
            uResolution: gl.getUniformLocation(simProgram, 'uResolution'),
            uRa: gl.getUniformLocation(simProgram, 'uRa'),
            uRi: gl.getUniformLocation(simProgram, 'uRi'),
            uB1: gl.getUniformLocation(simProgram, 'uB1'),
            uB2: gl.getUniformLocation(simProgram, 'uB2'),
            uD1: gl.getUniformLocation(simProgram, 'uD1'),
            uD2: gl.getUniformLocation(simProgram, 'uD2'),
            uAlphaM: gl.getUniformLocation(simProgram, 'uAlphaM'),
            uAlphaN: gl.getUniformLocation(simProgram, 'uAlphaN'),
            uDt: gl.getUniformLocation(simProgram, 'uDt')
        };

        const renderUniforms = {
            uState: gl.getUniformLocation(renderProgram, 'uState')
        };

        // Create quad geometry
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Create textures and framebuffers (ping-pong)
        let textures = [
            createTexture(width, height, initState()),
            createTexture(width, height)
        ];
        let framebuffers = [
            createFramebuffer(textures[0]),
            createFramebuffer(textures[1])
        ];
        let currentTex = 0;

        // Setup vertex attributes
        function setupAttribs(program) {
            const posLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        }

        // Reset simulation
        function reset() {
            const data = initState();
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, width, height, 0, gl.RED, gl.FLOAT, data);
            gl.bindTexture(gl.TEXTURE_2D, textures[1]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, width, height, 0, gl.RED, gl.FLOAT, null);
            currentTex = 0;
        }

        // Apply preset
        function applyPreset(name) {
            const preset = presets[name];
            if (!preset) return;

            params = { ...preset };

            document.getElementById('ra').value = params.ra;
            document.getElementById('ri').value = params.ri;
            document.getElementById('dt').value = params.dt;
            document.getElementById('ra-val').textContent = params.ra;
            document.getElementById('ri-val').textContent = params.ri;
            document.getElementById('dt-val').textContent = params.dt;
            document.getElementById('preset-name').textContent = name.charAt(0).toUpperCase() + name.slice(1);

            document.querySelectorAll('#presets button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === name);
            });

            reset();
        }

        // Event listeners
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => applyPreset(btn.dataset.preset));
        });

        document.getElementById('ra').addEventListener('input', e => {
            params.ra = parseFloat(e.target.value);
            document.getElementById('ra-val').textContent = params.ra;
        });

        document.getElementById('ri').addEventListener('input', e => {
            params.ri = parseFloat(e.target.value);
            document.getElementById('ri-val').textContent = params.ri;
        });

        document.getElementById('dt').addEventListener('input', e => {
            params.dt = parseFloat(e.target.value);
            document.getElementById('dt-val').textContent = params.dt;
        });

        document.getElementById('reset').addEventListener('click', reset);

        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });

        // FPS counter
        let frameCount = 0;
        let lastFpsTime = performance.now();

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }
        }

        // Animation loop
        function animate() {
            updateFPS();

            if (!paused) {
                // Simulation step
                gl.useProgram(simProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
                setupAttribs(simProgram);

                // Set uniforms
                gl.uniform1i(simUniforms.uState, 0);
                gl.uniform2f(simUniforms.uResolution, width, height);
                gl.uniform1f(simUniforms.uRa, params.ra);
                gl.uniform1f(simUniforms.uRi, params.ri);
                gl.uniform1f(simUniforms.uB1, params.b1);
                gl.uniform1f(simUniforms.uB2, params.b2);
                gl.uniform1f(simUniforms.uD1, params.d1);
                gl.uniform1f(simUniforms.uD2, params.d2);
                gl.uniform1f(simUniforms.uAlphaM, params.alphaM);
                gl.uniform1f(simUniforms.uAlphaN, params.alphaN);
                gl.uniform1f(simUniforms.uDt, params.dt);

                // Read from current, write to next
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, textures[currentTex]);
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1 - currentTex]);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Swap
                currentTex = 1 - currentTex;
            }

            // Render to screen
            gl.useProgram(renderProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            setupAttribs(renderProgram);

            gl.uniform1i(renderUniforms.uState, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentTex]);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            resize();
            // Recreate textures and framebuffers
            textures = [
                createTexture(width, height, initState()),
                createTexture(width, height)
            ];
            framebuffers = [
                createFramebuffer(textures[0]),
                createFramebuffer(textures[1])
            ];
            currentTex = 0;
        });

        // Start
        loadingEl.style.display = 'none';
        animate();
    </script>
</body>
</html>
