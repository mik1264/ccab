<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cloud Formation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Nunito', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 1.4rem; font-weight: 600;
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center;
}
.title-overlay .subtitle {
    font-size: 0.8rem; opacity: 0.7; margin-top: 4px; font-weight: 300;
}
.organic-back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    display: flex; align-items: center; gap: 8px;
    padding: 8px 16px; border-radius: 20px;
    background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
    color: #fff; text-decoration: none; font-size: 0.9rem;
    transition: background 0.3s;
}
.organic-back-link:hover { background: rgba(255,255,255,0.2); }
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
    padding: 12px 24px; border-radius: 20px; color: #fff; font-size: 0.85rem;
}
.controls label { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.controls input[type="range"] { width: 100px; }
.info-panel {
    position: fixed; top: 80px; right: 20px; z-index: 10;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(10px);
    padding: 12px 16px; border-radius: 12px; color: #fff; font-size: 0.75rem;
    line-height: 1.6;
}
</style>
</head>
<body>
<a href="../index.html" class="organic-back-link">
    <span class="back-arrow">&larr;</span>
    <span class="back-text">Gallery</span>
</a>
<div class="title-overlay">
    Cloud Formation
    <div class="subtitle">Adiabatic cooling, condensation, and thermal convection</div>
</div>
<div class="info-panel">
    <div>Cloud Base: <span id="cloudBase">0</span>m</div>
    <div>Ground Temp: <span id="groundTemp">0</span>&deg;C</div>
    <div>Dew Point: <span id="dewPoint">0</span>&deg;C</div>
    <div>Active Thermals: <span id="thermalCount">0</span></div>
</div>
<div class="controls">
    <label>Ground Heat: <input type="range" id="heatSlider" min="0.5" max="4" step="0.1" value="2"> <span id="heatVal">2.0</span></label>
    <label>Humidity: <input type="range" id="humidSlider" min="0.2" max="1" step="0.05" value="0.6"> <span id="humidVal">0.60</span></label>
    <label>Wind: <input type="range" id="windSlider" min="0" max="3" step="0.1" value="0.5"> <span id="windVal">0.5</span></label>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Temperature lapse rate: ~6.5C per 1000m
// Simulated altitude: ground at bottom, ~5000m at top
const MAX_ALT = 5000; // meters
const LAPSE_RATE = 6.5; // C per 1000m

function altToY(alt) {
    const groundY = H * 0.9;
    const topY = H * 0.05;
    return groundY - (alt / MAX_ALT) * (groundY - topY);
}

function yToAlt(y) {
    const groundY = H * 0.9;
    const topY = H * 0.05;
    return ((groundY - y) / (groundY - topY)) * MAX_ALT;
}

function tempAtAlt(groundTemp, alt) {
    return groundTemp - (alt / 1000) * LAPSE_RATE;
}

function dewPointAlt(groundTemp, humidity) {
    // Simplified: dew point decreases less with altitude
    const dewPointGround = groundTemp - ((1 - humidity) * 20);
    // Cloud base where temp = dew point
    const cloudBaseAlt = (groundTemp - dewPointGround) / (LAPSE_RATE / 1000 - 2 / 1000) * 1;
    return Math.max(500, Math.min(4000, cloudBaseAlt * 300));
}

// Thermal sources on the ground
const thermals = [];
const NUM_THERMALS = 8;
for (let i = 0; i < NUM_THERMALS; i++) {
    thermals.push({
        x: W * 0.1 + Math.random() * W * 0.8,
        strength: 0.5 + Math.random() * 1.5,
        phase: Math.random() * Math.PI * 2,
        width: 40 + Math.random() * 60
    });
}

// Air parcels
const NUM_PARCELS = 2000;
const parcels = [];

class AirParcel {
    constructor() {
        this.reset();
    }
    reset() {
        const thermal = thermals[Math.floor(Math.random() * thermals.length)];
        this.x = thermal.x + (Math.random() - 0.5) * thermal.width;
        this.y = H * 0.9 - Math.random() * 20;
        this.vx = 0;
        this.vy = 0;
        this.temp = 25 + Math.random() * 5;
        this.moisture = 0.3 + Math.random() * 0.5;
        this.condensed = false;
        this.size = 1.5 + Math.random() * 1;
        this.life = 1;
        this.cloudSize = 0;
    }
    update(groundHeat, humidity, wind, time) {
        const alt = yToAlt(this.y);
        const groundTemp = 20 + groundHeat * 5;
        const envTemp = tempAtAlt(groundTemp, alt);
        const cloudBaseAltitude = dewPointAlt(groundTemp, humidity);
        const cloudBaseY = altToY(cloudBaseAltitude);

        // Find nearest thermal
        let thermalForce = 0;
        for (const t of thermals) {
            const dx = this.x - t.x;
            const dist = Math.abs(dx);
            if (dist < t.width * 2) {
                const pulse = 0.7 + 0.3 * Math.sin(time * 2 + t.phase);
                thermalForce += Math.exp(-(dist * dist) / (t.width * t.width)) * t.strength * pulse * groundHeat;
            }
        }

        // Buoyancy
        const buoyancy = (this.temp - envTemp) * 0.003 * groundHeat;

        // Adiabatic cooling as parcel rises
        if (this.vy < 0) { // rising
            this.temp -= 0.01 * LAPSE_RATE;
        } else {
            this.temp += 0.005 * LAPSE_RATE;
        }

        // Condensation check
        if (this.y < cloudBaseY && this.moisture > 0.4 * (1 - humidity + 0.3)) {
            this.condensed = true;
            this.cloudSize = Math.min(this.cloudSize + 0.1, 8);
            // Latent heat release
            this.temp += 0.02;
        } else {
            this.condensed = false;
            this.cloudSize = Math.max(this.cloudSize - 0.05, 0);
        }

        this.vy += (-thermalForce * 0.5 - buoyancy) * 0.1;
        this.vx += wind * 0.01;
        this.vy *= 0.98;
        this.vx *= 0.99;

        // Gravity for non-buoyant air
        if (this.temp < envTemp && !this.condensed) {
            this.vy += 0.02;
        }

        this.x += this.vx;
        this.y += this.vy;

        this.life -= 0.001;

        // Bounds
        if (this.y > H * 0.9) { this.y = H * 0.9; this.vy = 0; }
        if (this.y < H * 0.05) { this.vy = Math.abs(this.vy) * 0.5; }
        if (this.x < -20) this.x = W + 20;
        if (this.x > W + 20) this.x = -20;

        if (this.life <= 0 || (this.y >= H * 0.89 && Math.abs(this.vy) < 0.1 && Math.random() < 0.02)) {
            this.reset();
        }
    }
    draw() {
        if (this.condensed) {
            // Cloud droplet - white/gray
            const alpha = 0.3 + this.cloudSize * 0.05;
            ctx.fillStyle = `rgba(220, 230, 240, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.cloudSize, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Air parcel - color by temperature
            const t = (this.temp - 5) / 35;
            const clamped = Math.max(0, Math.min(1, t));
            let r, g, b;
            if (clamped < 0.5) {
                r = 80 + clamped * 200;
                g = 120 + clamped * 100;
                b = 220;
            } else {
                r = 180 + (clamped - 0.5) * 150;
                g = 170 - (clamped - 0.5) * 100;
                b = 220 - (clamped - 0.5) * 200;
            }
            ctx.fillStyle = `rgba(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)},0.5)`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

for (let i = 0; i < NUM_PARCELS; i++) {
    parcels.push(new AirParcel());
}

function drawBackground(groundHeat, humidity) {
    // Sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#050820');
    grad.addColorStop(0.5, '#0a1030');
    grad.addColorStop(0.9, '#1a1510');
    grad.addColorStop(1, '#2a1a08');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Ground
    const groundGrad = ctx.createLinearGradient(0, H * 0.88, 0, H);
    groundGrad.addColorStop(0, '#2a3520');
    groundGrad.addColorStop(1, '#1a2510');
    ctx.fillStyle = groundGrad;
    ctx.fillRect(0, H * 0.9, W, H * 0.1);

    // Heat shimmer on ground
    ctx.fillStyle = `rgba(255, 100, 30, ${0.02 * groundHeat})`;
    ctx.fillRect(0, H * 0.87, W, H * 0.05);

    // Cloud base line
    const groundTemp = 20 + groundHeat * 5;
    const cloudBaseAlt = dewPointAlt(groundTemp, humidity);
    const cloudBaseY = altToY(cloudBaseAlt);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.setLineDash([8, 12]);
    ctx.beginPath();
    ctx.moveTo(0, cloudBaseY);
    ctx.lineTo(W, cloudBaseY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.font = '11px sans-serif';
    ctx.fillText('Cloud Base (Dew Point)', 10, cloudBaseY - 5);

    // Altitude scale
    for (let alt = 1000; alt <= 4000; alt += 1000) {
        const y = altToY(alt);
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.beginPath();
        ctx.moveTo(W - 60, y);
        ctx.lineTo(W - 10, y);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillText(alt + 'm', W - 55, y - 3);
    }

    // Temperature lapse rate visualization
    drawTempProfile(groundTemp, cloudBaseAlt);
}

function drawTempProfile(groundTemp, cloudBaseAlt) {
    const x0 = 70;
    const graphW = 60;
    const y0 = altToY(0);
    const y1 = altToY(MAX_ALT);

    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.roundRect(x0 - 15, y1 - 10, graphW + 30, y0 - y1 + 20, 8);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,100,50,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let alt = 0; alt <= MAX_ALT; alt += 100) {
        const y = altToY(alt);
        const t = tempAtAlt(groundTemp, alt);
        const tx = x0 + (t / groundTemp) * graphW;
        if (alt === 0) ctx.moveTo(tx, y);
        else ctx.lineTo(tx, y);
    }
    ctx.stroke();
    ctx.lineWidth = 1;

    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.font = '9px sans-serif';
    ctx.fillText('Temp \u2192', x0, y1 - 15);
}

function drawThermalIndicators() {
    for (const t of thermals) {
        ctx.strokeStyle = 'rgba(255, 150, 50, 0.08)';
        ctx.lineWidth = t.width * 0.5;
        ctx.beginPath();
        ctx.moveTo(t.x, H * 0.9);
        ctx.lineTo(t.x, H * 0.3);
        ctx.stroke();
        ctx.lineWidth = 1;

        // Small upward arrows
        ctx.fillStyle = 'rgba(255, 150, 50, 0.15)';
        ctx.beginPath();
        ctx.moveTo(t.x, H * 0.85);
        ctx.lineTo(t.x - 5, H * 0.87);
        ctx.lineTo(t.x + 5, H * 0.87);
        ctx.closePath();
        ctx.fill();
    }
}

let time = 0;

function animate() {
    const groundHeat = parseFloat(document.getElementById('heatSlider').value);
    const humidity = parseFloat(document.getElementById('humidSlider').value);
    const wind = parseFloat(document.getElementById('windSlider').value);
    document.getElementById('heatVal').textContent = groundHeat.toFixed(1);
    document.getElementById('humidVal').textContent = humidity.toFixed(2);
    document.getElementById('windVal').textContent = wind.toFixed(1);

    const groundTemp = 20 + groundHeat * 5;
    const cloudBaseAlt = dewPointAlt(groundTemp, humidity);

    document.getElementById('cloudBase').textContent = Math.floor(cloudBaseAlt);
    document.getElementById('groundTemp').textContent = groundTemp.toFixed(1);
    document.getElementById('dewPoint').textContent = (groundTemp - (cloudBaseAlt / 1000) * LAPSE_RATE).toFixed(1);

    let activeCount = 0;
    for (const p of parcels) {
        if (p.vy < -0.5) activeCount++;
    }
    document.getElementById('thermalCount').textContent = activeCount;

    drawBackground(groundHeat, humidity);
    drawThermalIndicators();

    for (const p of parcels) {
        p.update(groundHeat, humidity, wind, time);
        p.draw();
    }

    time += 0.016;
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
