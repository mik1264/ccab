<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Traffic Light Synchronization</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 18px; font-family: sans-serif; z-index: 999; text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 999; }
.panel { background: rgba(0,0,0,0.75); color: #e0e0e0; padding: 12px 16px; border-radius: 8px; font-size: 13px; min-width: 210px; }
.panel label { display: block; margin: 6px 0 2px; color: #fbbf24; }
.panel input[type=range] { width: 100%; }
.panel button { background: #fbbf24; color: #0a0e1a; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 6px; width: 100%; }
.panel button:hover { background: #f59e0b; }
#stats { color: #aaa; margin-top: 8px; line-height: 1.6; }
.btn-group { display: flex; gap: 4px; margin-top: 6px; }
.btn-group button { flex: 1; font-size: 11px; }
.btn-active { background: #f59e0b !important; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Traffic Light Synchronization (Green Wave)</div>
<div id="ui">
    <div class="panel">
        <label>Green Phase Duration: <span id="gpVal">60</span></label>
        <input type="range" id="greenPhase" min="20" max="120" value="60">
        <label>Phase Offset: <span id="poVal">15</span></label>
        <input type="range" id="phaseOffset" min="0" max="60" value="15">
        <label>Car Spawn Rate: <span id="csVal">3</span></label>
        <input type="range" id="carSpawn" min="1" max="10" value="3">
        <label>Simulation Speed: <span id="ssVal">1</span>x</label>
        <input type="range" id="simSpeed" min="1" max="5" value="1">
        <div class="btn-group">
            <button id="btnSync" class="btn-active">Green Wave</button>
            <button id="btnRandom">Random</button>
            <button id="btnAll">All Sync</button>
        </div>
        <button id="resetBtn">Reset</button>
        <div id="stats"></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;

    const GRID_COLS = 6;
    const GRID_ROWS = 5;
    let intersections = [];
    let cars = [];
    let greenPhase = 60;
    let phaseOffset = 15;
    let carSpawnRate = 3;
    let simSpeed = 1;
    let syncMode = 'wave';
    let frame = 0;
    let totalWait = 0, totalCars = 0, carsThrough = 0;
    let roadWidth, spacingX, spacingY, startX, startY;

    document.getElementById('greenPhase').addEventListener('input', function() {
        greenPhase = parseInt(this.value);
        document.getElementById('gpVal').textContent = greenPhase;
        updateTimings();
    });
    document.getElementById('phaseOffset').addEventListener('input', function() {
        phaseOffset = parseInt(this.value);
        document.getElementById('poVal').textContent = phaseOffset;
        updateTimings();
    });
    document.getElementById('carSpawn').addEventListener('input', function() {
        carSpawnRate = parseInt(this.value);
        document.getElementById('csVal').textContent = carSpawnRate;
    });
    document.getElementById('simSpeed').addEventListener('input', function() {
        simSpeed = parseInt(this.value);
        document.getElementById('ssVal').textContent = simSpeed;
    });
    document.getElementById('btnSync').addEventListener('click', function() {
        syncMode = 'wave'; updateActive(this);
        updateTimings();
    });
    document.getElementById('btnRandom').addEventListener('click', function() {
        syncMode = 'random'; updateActive(this);
        updateTimings();
    });
    document.getElementById('btnAll').addEventListener('click', function() {
        syncMode = 'all'; updateActive(this);
        updateTimings();
    });
    document.getElementById('resetBtn').addEventListener('click', init);

    function updateActive(btn) {
        document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('btn-active'));
        btn.classList.add('btn-active');
    }

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        roadWidth = 28;
        spacingX = (W - 100) / (GRID_COLS + 1);
        spacingY = (H - 80) / (GRID_ROWS + 1);
        startX = 50 + spacingX;
        startY = 40 + spacingY;
    }

    function updateTimings() {
        for (let r = 0; r < GRID_ROWS; r++) {
            for (let c = 0; c < GRID_COLS; c++) {
                const inter = intersections[r * GRID_COLS + c];
                if (!inter) continue;
                if (syncMode === 'wave') {
                    inter.offset = c * phaseOffset;
                } else if (syncMode === 'random') {
                    inter.offset = Math.floor(Math.random() * greenPhase * 2);
                } else {
                    inter.offset = 0;
                }
            }
        }
    }

    function init() {
        resize();
        intersections = [];
        cars = [];
        frame = 0;
        totalWait = 0;
        totalCars = 0;
        carsThrough = 0;

        for (let r = 0; r < GRID_ROWS; r++) {
            for (let c = 0; c < GRID_COLS; c++) {
                intersections.push({
                    x: startX + c * spacingX,
                    y: startY + r * spacingY,
                    offset: syncMode === 'wave' ? c * phaseOffset : 0,
                    row: r, col: c
                });
            }
        }
        updateTimings();
    }

    function isGreenHorizontal(inter) {
        const cycle = greenPhase * 2;
        const t = (frame + inter.offset) % cycle;
        return t < greenPhase;
    }

    function spawnCars() {
        if (Math.random() * 10 > carSpawnRate) return;

        // Spawn horizontal cars
        if (Math.random() < 0.6) {
            const row = Math.floor(Math.random() * GRID_ROWS);
            const y = startY + row * spacingY;
            const goRight = Math.random() < 0.5;
            cars.push({
                x: goRight ? -20 : W + 20,
                y: y + (Math.random() < 0.5 ? -4 : 4),
                vx: goRight ? 2 : -2,
                vy: 0,
                horizontal: true,
                waiting: 0,
                color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`
            });
            totalCars++;
        } else {
            // Spawn vertical cars
            const col = Math.floor(Math.random() * GRID_COLS);
            const x = startX + col * spacingX;
            const goDown = Math.random() < 0.5;
            cars.push({
                x: x + (Math.random() < 0.5 ? -4 : 4),
                y: goDown ? -20 : H + 20,
                vx: 0,
                vy: goDown ? 2 : -2,
                horizontal: false,
                waiting: 0,
                color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`
            });
            totalCars++;
        }
    }

    function updateCars() {
        for (const car of cars) {
            let shouldStop = false;

            // Check intersections
            for (const inter of intersections) {
                const dx = car.x - inter.x;
                const dy = car.y - inter.y;
                const stopDist = roadWidth + 5;

                if (car.horizontal) {
                    if (Math.abs(dy) < roadWidth && !isGreenHorizontal(inter)) {
                        if ((car.vx > 0 && dx > -stopDist && dx < -5) ||
                            (car.vx < 0 && dx < stopDist && dx > 5)) {
                            shouldStop = true;
                        }
                    }
                } else {
                    if (Math.abs(dx) < roadWidth && isGreenHorizontal(inter)) {
                        if ((car.vy > 0 && dy > -stopDist && dy < -5) ||
                            (car.vy < 0 && dy < stopDist && dy > 5)) {
                            shouldStop = true;
                        }
                    }
                }
            }

            // Check car ahead
            for (const other of cars) {
                if (other === car) continue;
                if (car.horizontal && other.horizontal) {
                    if (Math.abs(car.y - other.y) < 6) {
                        const dist = car.vx > 0 ? other.x - car.x : car.x - other.x;
                        if (dist > 0 && dist < 18) shouldStop = true;
                    }
                } else if (!car.horizontal && !other.horizontal) {
                    if (Math.abs(car.x - other.x) < 6) {
                        const dist = car.vy > 0 ? other.y - car.y : car.y - other.y;
                        if (dist > 0 && dist < 18) shouldStop = true;
                    }
                }
            }

            if (shouldStop) {
                car.waiting++;
                totalWait++;
            } else {
                car.x += car.vx;
                car.y += car.vy;
            }
        }

        // Remove off-screen cars
        const prevLen = cars.length;
        cars = cars.filter(c => c.x > -50 && c.x < W + 50 && c.y > -50 && c.y < H + 50);
        carsThrough += prevLen - cars.length;
    }

    function draw() {
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, W, H);

        // Draw roads
        ctx.fillStyle = '#1e293b';
        // Horizontal roads
        for (let r = 0; r < GRID_ROWS; r++) {
            const y = startY + r * spacingY;
            ctx.fillRect(0, y - roadWidth / 2, W, roadWidth);

            // Road markings
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.setLineDash([10, 10]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        // Vertical roads
        for (let c = 0; c < GRID_COLS; c++) {
            const x = startX + c * spacingX;
            ctx.fillRect(x - roadWidth / 2, 0, roadWidth, H);

            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, H);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw intersections and traffic lights
        for (const inter of intersections) {
            const green = isGreenHorizontal(inter);

            // Intersection box
            ctx.fillStyle = '#1a2332';
            ctx.fillRect(inter.x - roadWidth / 2, inter.y - roadWidth / 2, roadWidth, roadWidth);

            // Traffic lights - horizontal
            const lightSize = 5;
            // Left side
            ctx.fillStyle = green ? '#22c55e' : '#ef4444';
            ctx.shadowColor = green ? '#22c55e' : '#ef4444';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(inter.x - roadWidth / 2 - 5, inter.y - 5, lightSize, 0, Math.PI * 2);
            ctx.fill();
            // Right side
            ctx.beginPath();
            ctx.arc(inter.x + roadWidth / 2 + 5, inter.y + 5, lightSize, 0, Math.PI * 2);
            ctx.fill();

            // Traffic lights - vertical
            ctx.fillStyle = !green ? '#22c55e' : '#ef4444';
            ctx.shadowColor = !green ? '#22c55e' : '#ef4444';
            // Top
            ctx.beginPath();
            ctx.arc(inter.x + 5, inter.y - roadWidth / 2 - 5, lightSize, 0, Math.PI * 2);
            ctx.fill();
            // Bottom
            ctx.beginPath();
            ctx.arc(inter.x - 5, inter.y + roadWidth / 2 + 5, lightSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Green wave indicator (glow on road when green)
            if (green) {
                ctx.fillStyle = 'rgba(34, 197, 94, 0.05)';
                ctx.fillRect(inter.x - spacingX / 2, inter.y - roadWidth / 2, spacingX, roadWidth);
            }
        }

        // Draw cars
        for (const car of cars) {
            ctx.fillStyle = car.color;
            ctx.shadowColor = car.color;
            ctx.shadowBlur = car.waiting > 0 ? 3 : 6;

            if (car.horizontal) {
                ctx.fillRect(car.x - 6, car.y - 3, 12, 6);
                // Headlights
                ctx.fillStyle = '#fef9c3';
                if (car.vx > 0) {
                    ctx.fillRect(car.x + 5, car.y - 2, 2, 1.5);
                    ctx.fillRect(car.x + 5, car.y + 0.5, 2, 1.5);
                } else {
                    ctx.fillRect(car.x - 7, car.y - 2, 2, 1.5);
                    ctx.fillRect(car.x - 7, car.y + 0.5, 2, 1.5);
                }
            } else {
                ctx.fillRect(car.x - 3, car.y - 6, 6, 12);
                ctx.fillStyle = '#fef9c3';
                if (car.vy > 0) {
                    ctx.fillRect(car.x - 2, car.y + 5, 1.5, 2);
                    ctx.fillRect(car.x + 0.5, car.y + 5, 1.5, 2);
                } else {
                    ctx.fillRect(car.x - 2, car.y - 7, 1.5, 2);
                    ctx.fillRect(car.x + 0.5, car.y - 7, 1.5, 2);
                }
            }
            ctx.shadowBlur = 0;
        }

        // Stats
        const avgWait = totalCars > 0 ? (totalWait / totalCars).toFixed(1) : '0.0';
        const currentWaiting = cars.filter(c => c.waiting > 0).length;

        document.getElementById('stats').innerHTML =
            `Cars Active: ${cars.length}<br>` +
            `Cars Through: ${carsThrough}<br>` +
            `Currently Waiting: ${currentWaiting}<br>` +
            `Avg Wait: ${avgWait} frames<br>` +
            `Mode: ${syncMode === 'wave' ? 'Green Wave' : syncMode === 'random' ? 'Random' : 'All Synced'}`;
    }

    window.addEventListener('resize', function() { resize(); init(); });

    function animate() {
        for (let i = 0; i < simSpeed; i++) {
            frame++;
            spawnCars();
            updateCars();
        }
        draw();
        requestAnimationFrame(animate);
    }

    init();
    animate();
})();
</script>
</body>
</html>
