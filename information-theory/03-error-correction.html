<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Correction | Information Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }
        h1 { color: #ec4899; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #ec4899; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ec4899; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #f472b6; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ec4899; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ec4899; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .bit-input {
            display: flex; gap: 5px; justify-content: center;
            margin: 10px 0;
        }
        .bit-btn {
            width: 40px; height: 40px;
            background: #333; border: 2px solid #ec4899;
            border-radius: 8px; color: white;
            font-size: 1.2em; font-weight: bold;
            cursor: pointer;
        }
        .bit-btn.active { background: #ec4899; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Information Theory</a>

    <div class="controls">
        <h1>Hamming Code</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Error detection & correction</p>

        <div class="control-group">
            <label>Code Type</label>
            <select id="codeType">
                <option value="hamming74">Hamming(7,4)</option>
                <option value="hamming1511">Hamming(15,11)</option>
                <option value="parity">Simple Parity</option>
            </select>
        </div>

        <div class="control-group">
            <label>Data Bits (click to toggle)</label>
            <div class="bit-input" id="dataBits"></div>
        </div>

        <button id="encodeBtn">Encode</button>
        <button id="introduceErrorBtn" style="background:#ef4444">Introduce Error</button>
        <button id="correctBtn" style="background:#22c55e">Detect & Correct</button>
        <button id="resetBtn" style="background:#444">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Data Bits</span>
                <span class="stat-value" id="dataBitsCount">4</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Bits</span>
                <span class="stat-value" id="totalBits">7</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Parity Bits</span>
                <span class="stat-value" id="parityBits">3</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Code Rate</span>
                <span class="stat-value" id="codeRate">0.57</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Error Position</span>
                <span class="stat-value" id="errorPos">None</span>
            </div>
        </div>

        <div class="info">
            <strong>Hamming Code:</strong> Single-error correcting code.<br>
            <strong>Parity bits:</strong> At positions 1, 2, 4, 8...<br>
            <strong>Syndrome:</strong> XOR of parity checks reveals error.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let dataBits = [1, 0, 1, 1];
        let encodedBits = [];
        let receivedBits = [];
        let errorPosition = -1;
        let correctedPosition = -1;
        let codeType = 'hamming74';

        function initDataBits() {
            const container = document.getElementById('dataBits');
            container.innerHTML = '';

            const numDataBits = codeType === 'hamming74' ? 4 : (codeType === 'hamming1511' ? 11 : 4);
            while (dataBits.length < numDataBits) dataBits.push(0);
            dataBits = dataBits.slice(0, numDataBits);

            for (let i = 0; i < numDataBits; i++) {
                const btn = document.createElement('button');
                btn.className = 'bit-btn' + (dataBits[i] ? ' active' : '');
                btn.textContent = dataBits[i];
                btn.onclick = () => {
                    dataBits[i] = 1 - dataBits[i];
                    btn.textContent = dataBits[i];
                    btn.classList.toggle('active');
                };
                container.appendChild(btn);
            }

            updateStats();
        }

        function updateStats() {
            let totalBits, parityBits;
            if (codeType === 'hamming74') {
                totalBits = 7; parityBits = 3;
            } else if (codeType === 'hamming1511') {
                totalBits = 15; parityBits = 4;
            } else {
                totalBits = dataBits.length + 1; parityBits = 1;
            }

            document.getElementById('dataBitsCount').textContent = dataBits.length;
            document.getElementById('totalBits').textContent = totalBits;
            document.getElementById('parityBits').textContent = parityBits;
            document.getElementById('codeRate').textContent = (dataBits.length / totalBits).toFixed(2);
        }

        function isPowerOf2(n) {
            return n > 0 && (n & (n - 1)) === 0;
        }

        function encodeHamming(data) {
            const n = data.length;
            let r = 0;
            while ((1 << r) < n + r + 1) r++;

            const totalBits = n + r;
            const encoded = new Array(totalBits + 1).fill(0);

            // Place data bits
            let dataIndex = 0;
            for (let i = 1; i <= totalBits; i++) {
                if (!isPowerOf2(i)) {
                    encoded[i] = data[dataIndex++];
                }
            }

            // Calculate parity bits
            for (let i = 0; i < r; i++) {
                const parityPos = 1 << i;
                let parity = 0;
                for (let j = parityPos; j <= totalBits; j++) {
                    if (j & parityPos) {
                        parity ^= encoded[j];
                    }
                }
                encoded[parityPos] = parity;
            }

            return encoded.slice(1);
        }

        function encodeParity(data) {
            let parity = 0;
            for (const bit of data) parity ^= bit;
            return [...data, parity];
        }

        function calculateSyndrome(received) {
            const n = received.length;
            let r = 0;
            while ((1 << r) <= n) r++;

            let syndrome = 0;
            for (let i = 0; i < r; i++) {
                const parityPos = 1 << i;
                let parity = 0;
                for (let j = parityPos; j <= n; j++) {
                    if (j & parityPos) {
                        parity ^= received[j - 1];
                    }
                }
                if (parity) syndrome |= parityPos;
            }

            return syndrome;
        }

        function encode() {
            if (codeType === 'parity') {
                encodedBits = encodeParity(dataBits);
            } else {
                encodedBits = encodeHamming(dataBits);
            }
            receivedBits = [...encodedBits];
            errorPosition = -1;
            correctedPosition = -1;
            document.getElementById('errorPos').textContent = 'None';
        }

        function introduceError() {
            if (receivedBits.length === 0) {
                encode();
            }
            errorPosition = Math.floor(Math.random() * receivedBits.length);
            receivedBits[errorPosition] = 1 - receivedBits[errorPosition];
            document.getElementById('errorPos').textContent = `Position ${errorPosition + 1}`;
            correctedPosition = -1;
        }

        function detectAndCorrect() {
            if (receivedBits.length === 0) return;

            if (codeType === 'parity') {
                // Simple parity can only detect, not correct
                let parity = 0;
                for (const bit of receivedBits) parity ^= bit;
                if (parity !== 0) {
                    document.getElementById('errorPos').textContent = 'Error detected (cannot correct)';
                } else {
                    document.getElementById('errorPos').textContent = 'No error';
                }
            } else {
                const syndrome = calculateSyndrome(receivedBits);
                if (syndrome > 0 && syndrome <= receivedBits.length) {
                    correctedPosition = syndrome - 1;
                    receivedBits[correctedPosition] = 1 - receivedBits[correctedPosition];
                    document.getElementById('errorPos').textContent = `Corrected at ${syndrome}`;
                } else if (syndrome === 0) {
                    document.getElementById('errorPos').textContent = 'No error';
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 - 100;

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Hamming Code Error Correction', centerX, 50);

            // Draw encoded bits
            if (encodedBits.length > 0) {
                const startX = centerX - (encodedBits.length * 50) / 2;
                const y = 150;

                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.fillText('Encoded Codeword:', centerX, y - 40);

                for (let i = 0; i < encodedBits.length; i++) {
                    const x = startX + i * 50;
                    const isParity = codeType !== 'parity' && isPowerOf2(i + 1);

                    ctx.fillStyle = isParity ? 'rgba(34, 197, 94, 0.3)' : 'rgba(236, 72, 153, 0.3)';
                    ctx.fillRect(x, y, 45, 45);

                    ctx.strokeStyle = isParity ? '#22c55e' : '#ec4899';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, 45, 45);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px sans-serif';
                    ctx.fillText(encodedBits[i], x + 22, y + 30);

                    ctx.fillStyle = '#666';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(isParity ? 'P' + Math.log2(i + 1) : 'D', x + 22, y + 55);
                    ctx.fillText(i + 1, x + 22, y - 5);
                }
            }

            // Draw received bits with potential error
            if (receivedBits.length > 0) {
                const startX = centerX - (receivedBits.length * 50) / 2;
                const y = 300;

                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.fillText('Received (potentially corrupted):', centerX, y - 40);

                for (let i = 0; i < receivedBits.length; i++) {
                    const x = startX + i * 50;
                    const isError = i === errorPosition;
                    const isCorrected = i === correctedPosition;

                    if (isError && !isCorrected) {
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
                        ctx.strokeStyle = '#ef4444';
                    } else if (isCorrected) {
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                        ctx.strokeStyle = '#22c55e';
                    } else {
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                        ctx.strokeStyle = '#666';
                    }

                    ctx.fillRect(x, y, 45, 45);
                    ctx.lineWidth = isError || isCorrected ? 3 : 2;
                    ctx.strokeRect(x, y, 45, 45);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px sans-serif';
                    ctx.fillText(receivedBits[i], x + 22, y + 30);
                }
            }

            // Draw parity check visualization for Hamming codes
            if (codeType !== 'parity' && receivedBits.length > 0) {
                const checkY = 450;
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.fillText('Parity Check Groups:', centerX, checkY - 20);

                const numParityBits = codeType === 'hamming74' ? 3 : 4;
                const colors = ['#ec4899', '#8b5cf6', '#06b6d4', '#22c55e'];

                for (let p = 0; p < numParityBits; p++) {
                    const parityPos = 1 << p;
                    const groupX = centerX - 200 + p * 120;

                    ctx.fillStyle = colors[p];
                    ctx.font = '12px sans-serif';
                    ctx.fillText(`P${p + 1} checks:`, groupX, checkY + 10);

                    let positions = [];
                    for (let j = parityPos; j <= receivedBits.length; j++) {
                        if (j & parityPos) positions.push(j);
                    }
                    ctx.fillText(positions.join(', '), groupX, checkY + 30);

                    let parity = 0;
                    for (const pos of positions) {
                        parity ^= receivedBits[pos - 1];
                    }
                    ctx.fillStyle = parity ? '#ef4444' : '#22c55e';
                    ctx.fillText(parity ? '✗ Error' : '✓ OK', groupX, checkY + 50);
                }

                // Draw syndrome
                const syndrome = calculateSyndrome(receivedBits);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText(`Syndrome: ${syndrome.toString(2).padStart(numParityBits, '0')} = ${syndrome}`, centerX, checkY + 90);

                if (syndrome > 0) {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText(`Error at position ${syndrome}`, centerX, checkY + 115);
                } else {
                    ctx.fillStyle = '#22c55e';
                    ctx.fillText('No errors detected', centerX, checkY + 115);
                }
            }

            // Draw explanation
            const infoY = canvas.height - 100;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(20, infoY - 20, canvas.width - 350, 80);

            ctx.fillStyle = '#22c55e';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('█ Parity bits (power of 2 positions)', 30, infoY);
            ctx.fillStyle = '#ec4899';
            ctx.fillText('█ Data bits', 30, infoY + 20);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('█ Error position', 250, infoY);
            ctx.fillStyle = '#fff';
            ctx.fillText('Hamming codes can detect and correct single-bit errors by using parity bits at power-of-2 positions.', 30, infoY + 50);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('codeType').onchange = (e) => {
            codeType = e.target.value;
            encodedBits = [];
            receivedBits = [];
            errorPosition = -1;
            correctedPosition = -1;
            initDataBits();
        };

        document.getElementById('encodeBtn').onclick = encode;
        document.getElementById('introduceErrorBtn').onclick = introduceError;
        document.getElementById('correctBtn').onclick = detectAndCorrect;
        document.getElementById('resetBtn').onclick = () => {
            encodedBits = [];
            receivedBits = [];
            errorPosition = -1;
            correctedPosition = -1;
            document.getElementById('errorPos').textContent = 'None';
        };

        // Initialize
        initDataBits();
        draw();
    </script>
</body>
</html>
