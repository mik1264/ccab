<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptographic Entropy - Information Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4fc3f7;
            text-decoration: none;
            font-size: 18px;
            z-index: 1000;
            padding: 10px 20px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 8px;
            border: 1px solid #4fc3f7;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(79, 195, 247, 0.2);
            transform: translateX(-5px);
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 30, 50, 0.95);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #4fc3f7;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .controls h2 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 22px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4fc3f7;
            color: #0a0e1a;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        button:hover {
            background: #29b6f6;
            transform: scale(1.02);
        }

        .info-box {
            background: rgba(79, 195, 247, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 3px solid #4fc3f7;
        }

        .info-box h3 {
            color: #4fc3f7;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .info-box p {
            color: #b0bec5;
            font-size: 13px;
            line-height: 1.5;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(79, 195, 247, 0.1);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            color: #b0bec5;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #66bb6a;
            font-size: 16px;
            font-weight: bold;
        }

        .quality-indicator {
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }

        .quality-good {
            background: rgba(102, 187, 106, 0.2);
            color: #66bb6a;
            border: 1px solid #66bb6a;
        }

        .quality-bad {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }

        .quality-medium {
            background: rgba(255, 167, 38, 0.2);
            color: #ffa726;
            border: 1px solid #ffa726;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Cryptographic Entropy</h2>

        <button onclick="generatePseudoRandom()">Pseudo-Random (Math.random)</button>
        <button onclick="generateCryptoRandom()">Crypto-Random (crypto.getRandomValues)</button>
        <button onclick="generateWeakRandom()">Weak Random (timestamp-based)</button>

        <div id="statsDisplay"></div>

        <div class="info-box">
            <h3>About Random Quality</h3>
            <p>Cryptographic entropy measures the unpredictability of random number generators.</p>
            <p style="margin-top: 8px;"><strong>Pseudo-random:</strong> Deterministic, predictable given seed. Not secure for cryptography.</p>
            <p style="margin-top: 8px;"><strong>Crypto-random:</strong> Uses OS entropy sources. Suitable for security applications.</p>
        </div>

        <div class="info-box">
            <h3>Tests Performed</h3>
            <p>• Chi-square: Distribution uniformity</p>
            <p>• Autocorrelation: Independence test</p>
            <p>• Runs: Sequence randomness</p>
            <p>• Entropy: Information content</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let randomBytes = new Uint8Array(1024);
        let currentSource = 'none';

        function generatePseudoRandom() {
            for (let i = 0; i < randomBytes.length; i++) {
                randomBytes[i] = Math.floor(Math.random() * 256);
            }
            currentSource = 'Pseudo-Random (Math.random)';
            analyzeRandomness();
        }

        function generateCryptoRandom() {
            crypto.getRandomValues(randomBytes);
            currentSource = 'Crypto-Random (secure)';
            analyzeRandomness();
        }

        function generateWeakRandom() {
            // Weak PRNG based on timestamp
            let seed = Date.now();
            for (let i = 0; i < randomBytes.length; i++) {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                randomBytes[i] = (seed >> 16) & 0xff;
            }
            currentSource = 'Weak Random (timestamp)';
            analyzeRandomness();
        }

        function analyzeRandomness() {
            const entropy = calculateEntropy();
            const chiSquare = chiSquareTest();
            const autocorr = autocorrelationTest();
            const runs = runsTest();

            // Determine quality
            let quality = 'good';
            if (entropy < 7.5 || chiSquare > 300 || autocorr > 0.1 || runs < 0.3) {
                quality = 'bad';
            } else if (entropy < 7.8 || chiSquare > 270 || autocorr > 0.05) {
                quality = 'medium';
            }

            updateStats(entropy, chiSquare, autocorr, runs, quality);
        }

        function calculateEntropy() {
            const freq = new Array(256).fill(0);
            for (let byte of randomBytes) {
                freq[byte]++;
            }

            let entropy = 0;
            const total = randomBytes.length;
            for (let count of freq) {
                if (count > 0) {
                    const p = count / total;
                    entropy -= p * Math.log2(p);
                }
            }

            return entropy;
        }

        function chiSquareTest() {
            const freq = new Array(256).fill(0);
            for (let byte of randomBytes) {
                freq[byte]++;
            }

            const expected = randomBytes.length / 256;
            let chiSquare = 0;

            for (let count of freq) {
                chiSquare += Math.pow(count - expected, 2) / expected;
            }

            return chiSquare;
        }

        function autocorrelationTest() {
            // Test autocorrelation at lag 1
            let sum = 0;
            let mean = 0;
            for (let byte of randomBytes) {
                mean += byte;
            }
            mean /= randomBytes.length;

            let variance = 0;
            for (let byte of randomBytes) {
                variance += Math.pow(byte - mean, 2);
            }
            variance /= randomBytes.length;

            for (let i = 0; i < randomBytes.length - 1; i++) {
                sum += (randomBytes[i] - mean) * (randomBytes[i + 1] - mean);
            }

            return Math.abs(sum / ((randomBytes.length - 1) * variance));
        }

        function runsTest() {
            // Count runs of bits
            let bits = '';
            for (let i = 0; i < Math.min(256, randomBytes.length); i++) {
                bits += randomBytes[i].toString(2).padStart(8, '0');
            }

            let runs = 1;
            for (let i = 1; i < bits.length; i++) {
                if (bits[i] !== bits[i - 1]) runs++;
            }

            const n = bits.length;
            const expectedRuns = (n + 1) / 2;
            const normalized = runs / expectedRuns;

            return normalized;
        }

        function updateStats(entropy, chiSquare, autocorr, runs, quality) {
            const qualityText = quality === 'good' ? 'GOOD' : quality === 'bad' ? 'POOR' : 'FAIR';
            const qualityClass = `quality-${quality}`;

            document.getElementById('statsDisplay').innerHTML = `
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-label">Entropy</div>
                        <div class="stat-value">${entropy.toFixed(3)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Chi-Square</div>
                        <div class="stat-value">${chiSquare.toFixed(1)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Autocorr</div>
                        <div class="stat-value">${autocorr.toFixed(3)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Runs</div>
                        <div class="stat-value">${runs.toFixed(3)}</div>
                    </div>
                </div>
                <div class="quality-indicator ${qualityClass}">
                    Quality: ${qualityText}
                </div>
            `;
        }

        function drawTitle() {
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Random Number Quality Analysis', width / 2 - 100, 50);

            ctx.fillStyle = '#66bb6a';
            ctx.font = '18px sans-serif';
            ctx.fillText(`Source: ${currentSource}`, width / 2 - 100, 85);
        }

        function drawByteDistribution() {
            const startX = 50;
            const startY = 130;
            const barWidth = 3;
            const maxBarHeight = 150;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Byte Distribution (0-255)', startX, startY - 20);

            // Count frequencies
            const freq = new Array(256).fill(0);
            for (let byte of randomBytes) {
                freq[byte]++;
            }

            const maxFreq = Math.max(...freq);

            // Draw bars
            for (let i = 0; i < 256; i++) {
                const x = startX + i * barWidth;
                const barHeight = (freq[i] / maxFreq) * maxBarHeight;
                const y = startY + maxBarHeight - barHeight;

                ctx.fillStyle = `hsl(${i * 1.4}, 70%, 60%)`;
                ctx.fillRect(x, y, barWidth, barHeight);
            }

            // Draw baseline
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY + maxBarHeight);
            ctx.lineTo(startX + 256 * barWidth, startY + maxBarHeight);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#b0bec5';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('0', startX, startY + maxBarHeight + 20);
            ctx.fillText('255', startX + 256 * barWidth, startY + maxBarHeight + 20);

            // Expected line
            const expected = randomBytes.length / 256;
            const expectedY = startY + maxBarHeight - (expected / maxFreq) * maxBarHeight;
            ctx.strokeStyle = '#ffa726';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(startX, expectedY);
            ctx.lineTo(startX + 256 * barWidth, expectedY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#ffa726';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Expected', startX + 260 * barWidth + 5, expectedY + 5);
        }

        function drawBitVisualization() {
            const startX = 50;
            const startY = 350;
            const bitSize = 6;
            const bitsPerRow = 128;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Bit Patterns (First 1024 bits)', startX, startY - 20);

            for (let i = 0; i < Math.min(128, randomBytes.length); i++) {
                const byte = randomBytes[i];
                for (let bit = 0; bit < 8; bit++) {
                    const bitValue = (byte >> (7 - bit)) & 1;
                    const bitIndex = i * 8 + bit;
                    const row = Math.floor(bitIndex / bitsPerRow);
                    const col = bitIndex % bitsPerRow;

                    const x = startX + col * bitSize;
                    const y = startY + row * bitSize;

                    ctx.fillStyle = bitValue === 1 ? '#66bb6a' : '#4fc3f7';
                    ctx.fillRect(x, y, bitSize - 1, bitSize - 1);
                }
            }
        }

        function drawAutocorrelation() {
            const startX = 50;
            const startY = 520;
            const plotWidth = 400;
            const plotHeight = 150;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Autocorrelation (first 100 lags)', startX, startY - 20);

            // Draw axes
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY + plotHeight / 2);
            ctx.lineTo(startX + plotWidth, startY + plotHeight / 2);
            ctx.stroke();

            // Calculate autocorrelations
            const mean = randomBytes.reduce((a, b) => a + b, 0) / randomBytes.length;
            const variance = randomBytes.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / randomBytes.length;

            const maxLag = Math.min(100, randomBytes.length - 1);

            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let lag = 0; lag <= maxLag; lag++) {
                let sum = 0;
                for (let i = 0; i < randomBytes.length - lag; i++) {
                    sum += (randomBytes[i] - mean) * (randomBytes[i + lag] - mean);
                }
                const autocorr = sum / ((randomBytes.length - lag) * variance);

                const x = startX + (lag / maxLag) * plotWidth;
                const y = startY + plotHeight / 2 - autocorr * plotHeight / 2;

                if (lag === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            ctx.stroke();

            // Draw confidence bounds
            const bound = 2 / Math.sqrt(randomBytes.length);
            ctx.strokeStyle = '#ffa726';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);

            ctx.beginPath();
            ctx.moveTo(startX, startY + plotHeight / 2 - bound * plotHeight / 2);
            ctx.lineTo(startX + plotWidth, startY + plotHeight / 2 - bound * plotHeight / 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(startX, startY + plotHeight / 2 + bound * plotHeight / 2);
            ctx.lineTo(startX + plotWidth, startY + plotHeight / 2 + bound * plotHeight / 2);
            ctx.stroke();

            ctx.setLineDash([]);
        }

        function drawEntropyMeter() {
            const centerX = width - 300;
            const centerY = 450;
            const radius = 120;

            ctx.fillStyle = '#66bb6a';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Entropy Meter', centerX, centerY - radius - 30);

            const entropy = calculateEntropy();
            const angle = (entropy / 8) * Math.PI;

            // Draw arc background
            ctx.strokeStyle = '#1e3a5f';
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 2 * Math.PI);
            ctx.stroke();

            // Draw entropy arc
            const gradient = ctx.createLinearGradient(centerX - radius, centerY, centerX + radius, centerY);
            gradient.addColorStop(0, '#f44336');
            gradient.addColorStop(0.5, '#ffa726');
            gradient.addColorStop(1, '#66bb6a');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, Math.PI + angle);
            ctx.stroke();

            // Draw needle
            const needleAngle = Math.PI + angle;
            const needleLength = radius - 10;
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + needleLength * Math.cos(needleAngle),
                centerY + needleLength * Math.sin(needleAngle)
            );
            ctx.stroke();

            // Center dot
            ctx.fillStyle = '#4fc3f7';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Labels
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '14px sans-serif';
            ctx.fillText('0', centerX - radius - 20, centerY + 5);
            ctx.fillText('8 bits', centerX + radius + 30, centerY + 5);

            // Current value
            ctx.fillStyle = '#66bb6a';
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText(entropy.toFixed(3), centerX, centerY - 20);
            ctx.font = '16px sans-serif';
            ctx.fillText('bits/byte', centerX, centerY + 10);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            if (currentSource !== 'none') {
                drawTitle();
                drawByteDistribution();
                drawBitVisualization();
                drawAutocorrelation();
                drawEntropyMeter();
            } else {
                ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 24px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click a button to generate random numbers', width / 2 - 100, height / 2);
            }

            requestAnimationFrame(draw);
        }

        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
