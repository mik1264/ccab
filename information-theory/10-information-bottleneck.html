<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Information Bottleneck - Information Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4fc3f7;
            text-decoration: none;
            font-size: 18px;
            z-index: 1000;
            padding: 10px 20px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 8px;
            border: 1px solid #4fc3f7;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(79, 195, 247, 0.2);
            transform: translateX(-5px);
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 30, 50, 0.95);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #4fc3f7;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .controls h2 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 22px;
        }

        .slider-group {
            margin-bottom: 20px;
        }

        .slider-group label {
            display: block;
            color: #66bb6a;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .slider-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            color: #81c784;
            font-size: 16px;
            font-weight: bold;
        }

        .info-box {
            background: rgba(79, 195, 247, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 3px solid #4fc3f7;
        }

        .info-box h3 {
            color: #4fc3f7;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #b0bec5;
            font-size: 13px;
            line-height: 1.6;
        }

        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(102, 187, 106, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            color: #81c784;
            font-size: 12px;
        }

        .stat {
            color: #66bb6a;
            font-weight: bold;
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Information Bottleneck</h2>

        <div class="slider-group">
            <label>Compression Rate (β): <span class="slider-value" id="betaValue">0.50</span></label>
            <input type="range" id="betaSlider" min="0" max="100" value="50">
        </div>

        <div class="slider-group">
            <label>Noise Level: <span class="slider-value" id="noiseValue">0.20</span></label>
            <input type="range" id="noiseSlider" min="0" max="50" value="20">
        </div>

        <div id="stats"></div>

        <div class="info-box">
            <h3>Information Bottleneck Method</h3>
            <p>The IB method finds compressed representation T of data X that preserves relevant information about target Y.</p>
            <div class="formula">min I(X;T) - β·I(T;Y)</div>
            <p style="margin-top: 10px;">Trade-off: Low β emphasizes compression, high β preserves more task-relevant information.</p>
        </div>

        <div class="info-box">
            <h3>Applications</h3>
            <p>• Deep learning (understanding neural networks)</p>
            <p>• Feature extraction and dimensionality reduction</p>
            <p>• Clustering and categorization</p>
            <p>• Lossy compression with relevance</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let beta = 0.5;
        let noiseLevel = 0.2;

        const betaSlider = document.getElementById('betaSlider');
        const noiseSlider = document.getElementById('noiseSlider');

        betaSlider.addEventListener('input', (e) => {
            beta = parseInt(e.target.value) / 100;
            document.getElementById('betaValue').textContent = beta.toFixed(2);
            updateStats();
        });

        noiseSlider.addEventListener('input', (e) => {
            noiseLevel = parseInt(e.target.value) / 100;
            document.getElementById('noiseValue').textContent = noiseLevel.toFixed(2);
            updateStats();
        });

        // Simplified data: 4 input clusters, 2 target classes
        const numInputs = 4;
        const numTargets = 2;
        const numCompressed = 2;

        function updateStats() {
            // Simplified information calculations
            const hX = 2; // H(X) for 4 equally likely inputs
            const hY = 1; // H(Y) for 2 equally likely targets

            // Compression reduces mutual information
            const compressionFactor = 0.3 + beta * 0.7; // 0.3 to 1.0
            const iXT = hX * (1 - compressionFactor); // I(X;T)
            const iTY = hY * compressionFactor * (1 - noiseLevel); // I(T;Y)

            const objective = iXT - beta * iTY;
            const accuracy = iTY / hY * 100;

            document.getElementById('stats').innerHTML = `
                <div class="stat">I(X;T): ${iXT.toFixed(3)} bits</div>
                <div class="stat">I(T;Y): ${iTY.toFixed(3)} bits</div>
                <div class="stat">Objective: ${objective.toFixed(3)}</div>
                <div class="stat">Task Accuracy: ${accuracy.toFixed(1)}%</div>
            `;
        }

        function drawInformationPlane() {
            const centerX = width / 2 - 150;
            const centerY = 250;
            const scale = 150;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Information Plane', centerX, 60);

            // Draw axes
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY + scale);
            ctx.lineTo(centerX + scale + 20, centerY + scale);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerX, centerY + scale + 20);
            ctx.lineTo(centerX, centerY - 20);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('I(T;Y) - Relevant Info', centerX + scale / 2, centerY + scale + 40);

            ctx.save();
            ctx.translate(centerX - 40, centerY + scale / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('I(X;T) - Compression', 0, 0);
            ctx.restore();

            // Draw information bottleneck curve
            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let t = 0; t <= 100; t++) {
                const b = t / 100;
                const compressionFactor = 0.3 + b * 0.7;
                const iXT = 2 * (1 - compressionFactor);
                const iTY = 1 * compressionFactor * (1 - noiseLevel);

                const x = centerX + iTY * scale;
                const y = centerY + scale - iXT * scale;

                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw current position
            const compressionFactor = 0.3 + beta * 0.7;
            const currentIXT = 2 * (1 - compressionFactor);
            const currentITY = 1 * compressionFactor * (1 - noiseLevel);

            const currentX = centerX + currentITY * scale;
            const currentY = centerY + scale - currentIXT * scale;

            ctx.fillStyle = '#ffa726';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#ffa726';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw optimal points
            ctx.fillStyle = '#ab47bc';
            ctx.font = '12px sans-serif';

            // Low compression (high β)
            ctx.beginPath();
            ctx.arc(centerX + 0.8 * scale, centerY + scale - 0.3 * scale, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillText('High β', centerX + 0.8 * scale + 15, centerY + scale - 0.3 * scale);

            // High compression (low β)
            ctx.beginPath();
            ctx.arc(centerX + 0.2 * scale, centerY + scale - 1.4 * scale, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillText('Low β', centerX + 0.2 * scale + 15, centerY + scale - 1.4 * scale);
        }

        function drawDataFlow() {
            const startY = 500;
            const boxWidth = 120;
            const boxHeight = 80;
            const spacing = 180;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Information Flow', 50, startY - 30);

            // Input X
            const xPos = 100;
            ctx.fillStyle = 'rgba(79, 195, 247, 0.2)';
            ctx.fillRect(xPos, startY, boxWidth, boxHeight);
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 3;
            ctx.strokeRect(xPos, startY, boxWidth, boxHeight);

            ctx.fillStyle = '#e0e0e0';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Input X', xPos + boxWidth / 2, startY + 30);
            ctx.font = '14px sans-serif';
            ctx.fillText('H(X) = 2 bits', xPos + boxWidth / 2, startY + 55);

            // Compressed T
            const tPos = xPos + spacing;
            const compressionFactor = 0.3 + beta * 0.7;
            const tHeight = boxHeight * compressionFactor;
            const tY = startY + (boxHeight - tHeight) / 2;

            ctx.fillStyle = 'rgba(102, 187, 106, 0.2)';
            ctx.fillRect(tPos, tY, boxWidth, tHeight);
            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 3;
            ctx.strokeRect(tPos, tY, boxWidth, tHeight);

            ctx.fillStyle = '#e0e0e0';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText('Compressed T', tPos + boxWidth / 2, startY + 30);
            ctx.font = '14px sans-serif';
            ctx.fillText(`${(2 * compressionFactor).toFixed(2)} bits`, tPos + boxWidth / 2, startY + 55);

            // Target Y
            const yPos = tPos + spacing;
            ctx.fillStyle = 'rgba(255, 167, 38, 0.2)';
            ctx.fillRect(yPos, startY, boxWidth, boxHeight);
            ctx.strokeStyle = '#ffa726';
            ctx.lineWidth = 3;
            ctx.strokeRect(yPos, startY, boxWidth, boxHeight);

            ctx.fillStyle = '#e0e0e0';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText('Target Y', yPos + boxWidth / 2, startY + 30);
            ctx.font = '14px sans-serif';
            ctx.fillText('H(Y) = 1 bit', yPos + boxWidth / 2, startY + 55);

            // Arrows
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);

            // X -> T
            ctx.beginPath();
            ctx.moveTo(xPos + boxWidth, startY + boxHeight / 2);
            ctx.lineTo(tPos, startY + boxHeight / 2);
            ctx.stroke();

            drawArrowhead(tPos, startY + boxHeight / 2, 0);

            ctx.fillStyle = '#4fc3f7';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Compress', xPos + boxWidth + spacing / 2, startY + boxHeight / 2 - 10);

            // T -> Y
            ctx.strokeStyle = '#66bb6a';
            ctx.beginPath();
            ctx.moveTo(tPos + boxWidth, startY + boxHeight / 2);
            ctx.lineTo(yPos, startY + boxHeight / 2);
            ctx.stroke();

            drawArrowhead(yPos, startY + boxHeight / 2, 0);

            ctx.fillStyle = '#66bb6a';
            ctx.fillText('Predict', tPos + boxWidth + spacing / 2, startY + boxHeight / 2 - 10);
        }

        function drawArrowhead(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-15, -8);
            ctx.lineTo(-15, 8);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawTradeoffCurve() {
            const startX = width - 420;
            const startY = 500;
            const plotWidth = 350;
            const plotHeight = 200;

            ctx.fillStyle = '#66bb6a';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Compression vs Accuracy', startX, startY - 20);

            // Draw axes
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX, startY + plotHeight);
            ctx.lineTo(startX + plotWidth, startY + plotHeight);
            ctx.stroke();

            // Draw trade-off curve
            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i <= 100; i++) {
                const b = i / 100;
                const compressionFactor = 0.3 + b * 0.7;
                const accuracy = compressionFactor * (1 - noiseLevel);

                const x = startX + b * plotWidth;
                const y = startY + plotHeight - accuracy * plotHeight;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw current position
            const currentX = startX + beta * plotWidth;
            const currentAccuracy = (0.3 + beta * 0.7) * (1 - noiseLevel);
            const currentY = startY + plotHeight - currentAccuracy * plotHeight;

            ctx.fillStyle = '#ffa726';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Labels
            ctx.fillStyle = '#b0bec5';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('0', startX, startY + plotHeight + 20);
            ctx.fillText('1.0', startX + plotWidth, startY + plotHeight + 20);
            ctx.fillText('β (Compression Rate)', startX + plotWidth / 2, startY + plotHeight + 40);

            ctx.save();
            ctx.translate(startX - 30, startY + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Task Accuracy', 0, 0);
            ctx.restore();
        }

        function drawClusters() {
            const startX = width - 420;
            const startY = 120;
            const radius = 80;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Data Clustering', startX, startY - 20);

            // Draw input clusters
            const clusters = [
                {x: startX + 60, y: startY + 40, color: '#4fc3f7', label: 'X1'},
                {x: startX + 140, y: startY + 40, color: '#66bb6a', label: 'X2'},
                {x: startX + 60, y: startY + 100, color: '#ffa726', label: 'X3'},
                {x: startX + 140, y: startY + 100, color: '#ab47bc', label: 'X4'}
            ];

            const compressionFactor = 0.3 + beta * 0.7;
            const mergeThreshold = 0.6;

            clusters.forEach(cluster => {
                ctx.fillStyle = cluster.color;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(cluster.x, cluster.y, 20 * (1 - compressionFactor * 0.5), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.fillStyle = '#e0e0e0';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(cluster.label, cluster.x, cluster.y + 5);
            });

            // Draw merging indicator when high compression
            if (compressionFactor < mergeThreshold) {
                ctx.strokeStyle = '#ffa726';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                // Merge clusters 1&2
                ctx.beginPath();
                ctx.moveTo(clusters[0].x, clusters[0].y);
                ctx.lineTo(clusters[1].x, clusters[1].y);
                ctx.stroke();

                // Merge clusters 3&4
                ctx.beginPath();
                ctx.moveTo(clusters[2].x, clusters[2].y);
                ctx.lineTo(clusters[3].x, clusters[3].y);
                ctx.stroke();

                ctx.setLineDash([]);
            }

            // Draw compressed representation
            ctx.fillStyle = '#66bb6a';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Clusters: ${compressionFactor < mergeThreshold ? '2' : '4'}`, startX, startY + 160);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            drawInformationPlane();
            drawDataFlow();
            drawTradeoffCurve();
            drawClusters();

            requestAnimationFrame(draw);
        }

        // Initialize
        updateStats();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
