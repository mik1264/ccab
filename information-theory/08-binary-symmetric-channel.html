<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Symmetric Channel | Information Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }
        h1 { color: #ec4899; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #ec4899; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ec4899; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #f472b6; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ec4899; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ec4899; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .formula {
            background: rgba(236, 72, 153, 0.1);
            padding: 8px; border-radius: 8px;
            font-family: monospace; margin: 10px 0;
            text-align: center; font-size: 0.85em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Information Theory</a>

    <div class="controls">
        <h1>Binary Symmetric Channel</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Noisy channel model</p>

        <div class="formula">C = 1 - H(p)</div>

        <div class="control-group">
            <label>Crossover Probability p: <span class="value" id="pValue">0.1</span></label>
            <input type="range" id="crossover" min="0" max="0.5" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Message Length: <span class="value" id="lengthValue">50</span></label>
            <input type="range" id="msgLength" min="10" max="200" step="10" value="50">
        </div>

        <button id="transmitBtn">Transmit Message</button>
        <button id="continuousBtn" style="background:#8b5cf6">Toggle Continuous</button>
        <button id="resetBtn" style="background:#444">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Channel Capacity C</span>
                <span class="stat-value" id="capacity">0 bits</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Bit Error Rate</span>
                <span class="stat-value" id="ber">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Bits Flipped</span>
                <span class="stat-value" id="flipped">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">H(p) Binary Entropy</span>
                <span class="stat-value" id="hp">0 bits</span>
            </div>
        </div>

        <div class="info">
            <strong>BSC:</strong> Each bit flips with probability p.<br>
            <strong>Capacity:</strong> Maximum reliable rate = 1-H(p).<br>
            <strong>p=0.5:</strong> Channel is useless (random output).
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let crossoverProb = 0.1;
        let msgLength = 50;
        let inputBits = [];
        let outputBits = [];
        let errorPositions = [];
        let continuous = false;
        let totalBits = 0;
        let totalErrors = 0;
        let history = [];

        function binaryEntropy(p) {
            if (p <= 0 || p >= 1) return 0;
            return -p * Math.log2(p) - (1 - p) * Math.log2(1 - p);
        }

        function generateMessage() {
            inputBits = [];
            for (let i = 0; i < msgLength; i++) {
                inputBits.push(Math.random() < 0.5 ? 0 : 1);
            }
        }

        function transmit() {
            outputBits = [];
            errorPositions = [];

            for (let i = 0; i < inputBits.length; i++) {
                if (Math.random() < crossoverProb) {
                    outputBits.push(1 - inputBits[i]);
                    errorPositions.push(i);
                } else {
                    outputBits.push(inputBits[i]);
                }
            }

            totalBits += msgLength;
            totalErrors += errorPositions.length;

            const ber = errorPositions.length / msgLength;
            history.push(ber);
            if (history.length > 100) history.shift();

            updateStats();
        }

        function updateStats() {
            const hp = binaryEntropy(crossoverProb);
            const capacity = 1 - hp;
            const ber = totalBits > 0 ? (totalErrors / totalBits) : 0;

            document.getElementById('capacity').textContent = capacity.toFixed(3) + ' bits';
            document.getElementById('ber').textContent = (ber * 100).toFixed(2) + '%';
            document.getElementById('flipped').textContent = errorPositions.length + ' / ' + msgLength;
            document.getElementById('hp').textContent = hp.toFixed(3) + ' bits';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 - 100;

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Binary Symmetric Channel (BSC)', centerX, 40);

            // Draw channel diagram
            const diagY = 80;
            const diagCenterX = centerX;

            // Input node
            ctx.beginPath();
            ctx.arc(diagCenterX - 150, diagY + 40, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('0', diagCenterX - 150, diagY + 45);

            ctx.beginPath();
            ctx.arc(diagCenterX - 150, diagY + 120, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#22c55e';
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.fillText('1', diagCenterX - 150, diagY + 125);

            // Output node
            ctx.beginPath();
            ctx.arc(diagCenterX + 150, diagY + 40, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#3b82f6';
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.fillText('0', diagCenterX + 150, diagY + 45);

            ctx.beginPath();
            ctx.arc(diagCenterX + 150, diagY + 120, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#3b82f6';
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.fillText('1', diagCenterX + 150, diagY + 125);

            // Transition arrows
            ctx.lineWidth = 2;
            // 0 -> 0 (1-p)
            ctx.strokeStyle = '#22c55e';
            ctx.beginPath();
            ctx.moveTo(diagCenterX - 120, diagY + 40);
            ctx.lineTo(diagCenterX + 120, diagY + 40);
            ctx.stroke();
            ctx.fillStyle = '#22c55e';
            ctx.font = '12px sans-serif';
            ctx.fillText(`1-p = ${(1 - crossoverProb).toFixed(2)}`, diagCenterX, diagY + 30);

            // 1 -> 1 (1-p)
            ctx.beginPath();
            ctx.moveTo(diagCenterX - 120, diagY + 120);
            ctx.lineTo(diagCenterX + 120, diagY + 120);
            ctx.stroke();
            ctx.fillText(`1-p = ${(1 - crossoverProb).toFixed(2)}`, diagCenterX, diagY + 135);

            // 0 -> 1 (p)
            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            ctx.moveTo(diagCenterX - 120, diagY + 50);
            ctx.lineTo(diagCenterX + 120, diagY + 110);
            ctx.stroke();
            ctx.fillStyle = '#ef4444';
            ctx.fillText(`p = ${crossoverProb.toFixed(2)}`, diagCenterX + 60, diagY + 70);

            // 1 -> 0 (p)
            ctx.beginPath();
            ctx.moveTo(diagCenterX - 120, diagY + 110);
            ctx.lineTo(diagCenterX + 120, diagY + 50);
            ctx.stroke();
            ctx.fillText(`p = ${crossoverProb.toFixed(2)}`, diagCenterX - 60, diagY + 100);

            // Draw bit stream
            if (inputBits.length > 0) {
                const streamY = 270;
                const bitWidth = Math.min(12, (canvas.width - 400) / msgLength);

                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Input:', 50, streamY - 10);
                ctx.fillText('Output:', 50, streamY + 50);

                const startX = 100;

                // Input bits
                for (let i = 0; i < inputBits.length; i++) {
                    const x = startX + i * bitWidth;
                    ctx.fillStyle = inputBits[i] ? '#22c55e' : '#333';
                    ctx.fillRect(x, streamY, bitWidth - 1, 20);
                }

                // Output bits with errors highlighted
                for (let i = 0; i < outputBits.length; i++) {
                    const x = startX + i * bitWidth;
                    const isError = errorPositions.includes(i);

                    if (isError) {
                        ctx.fillStyle = '#ef4444';
                    } else {
                        ctx.fillStyle = outputBits[i] ? '#3b82f6' : '#333';
                    }
                    ctx.fillRect(x, streamY + 40, bitWidth - 1, 20);

                    // Draw error indicators
                    if (isError) {
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + bitWidth / 2, streamY + 25);
                        ctx.lineTo(x + bitWidth / 2, streamY + 35);
                        ctx.stroke();
                    }
                }

                // Legend
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(50, streamY + 80, 15, 15);
                ctx.fillStyle = '#888';
                ctx.font = '12px sans-serif';
                ctx.fillText('Input 1', 70, streamY + 92);

                ctx.fillStyle = '#3b82f6';
                ctx.fillRect(150, streamY + 80, 15, 15);
                ctx.fillStyle = '#888';
                ctx.fillText('Output (correct)', 170, streamY + 92);

                ctx.fillStyle = '#ef4444';
                ctx.fillRect(300, streamY + 80, 15, 15);
                ctx.fillStyle = '#888';
                ctx.fillText('Bit error', 320, streamY + 92);
            }

            // Draw capacity curve
            const graphX = 50;
            const graphY = 420;
            const graphW = canvas.width - 400;
            const graphH = 150;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(graphX, graphY, graphW, graphH);

            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Channel Capacity vs Crossover Probability', graphX, graphY - 10);

            // Capacity curve C = 1 - H(p)
            ctx.beginPath();
            ctx.strokeStyle = '#ec4899';
            ctx.lineWidth = 2;
            for (let p = 0; p <= 0.5; p += 0.01) {
                const c = 1 - binaryEntropy(p);
                const x = graphX + (p / 0.5) * graphW;
                const y = graphY + graphH - c * graphH;
                if (p === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Current operating point
            const currX = graphX + (crossoverProb / 0.5) * graphW;
            const currC = 1 - binaryEntropy(crossoverProb);
            const currY = graphY + graphH - currC * graphH;

            ctx.beginPath();
            ctx.arc(currX, currY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#22c55e';
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`C = ${currC.toFixed(3)}`, currX, currY - 15);

            // Axes
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('0', graphX, graphY + graphH + 15);
            ctx.fillText('0.5', graphX + graphW, graphY + graphH + 15);
            ctx.fillText('p', graphX + graphW / 2, graphY + graphH + 30);

            ctx.textAlign = 'right';
            ctx.fillText('0', graphX - 5, graphY + graphH);
            ctx.fillText('1', graphX - 5, graphY + 5);

            // Draw BER history
            if (history.length > 1) {
                const histY = canvas.height - 100;

                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(graphX, histY - 60, graphW, 60);

                ctx.fillStyle = '#888';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Bit Error Rate History', graphX, histY - 70);

                ctx.beginPath();
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1;
                for (let i = 0; i < history.length; i++) {
                    const x = graphX + (i / (history.length - 1)) * graphW;
                    const y = histY - history[i] * 50;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Theoretical line at p
                ctx.strokeStyle = '#888';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(graphX, histY - crossoverProb * 50);
                ctx.lineTo(graphX + graphW, histY - crossoverProb * 50);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#888';
                ctx.textAlign = 'right';
                ctx.fillText(`p=${crossoverProb}`, graphX + graphW, histY - crossoverProb * 50 - 5);
            }

            if (continuous) {
                generateMessage();
                transmit();
            }

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('crossover').oninput = (e) => {
            crossoverProb = parseFloat(e.target.value);
            document.getElementById('pValue').textContent = crossoverProb.toFixed(2);
        };

        document.getElementById('msgLength').oninput = (e) => {
            msgLength = parseInt(e.target.value);
            document.getElementById('lengthValue').textContent = msgLength;
        };

        document.getElementById('transmitBtn').onclick = () => {
            generateMessage();
            transmit();
        };

        document.getElementById('continuousBtn').onclick = () => {
            continuous = !continuous;
            document.getElementById('continuousBtn').textContent = continuous ? 'Stop Continuous' : 'Toggle Continuous';
        };

        document.getElementById('resetBtn').onclick = () => {
            inputBits = [];
            outputBits = [];
            errorPositions = [];
            totalBits = 0;
            totalErrors = 0;
            history = [];
            continuous = false;
            document.getElementById('continuousBtn').textContent = 'Toggle Continuous';
        };

        // Initialize
        generateMessage();
        transmit();
        draw();
    </script>
</body>
</html>
