<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Source Coding | Information Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }
        h1 { color: #ec4899; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #ec4899; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ec4899; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #f472b6; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ec4899; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ec4899; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Information Theory</a>

    <div class="controls">
        <h1>Source Coding Theorem</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Lossless compression limits</p>

        <div class="control-group">
            <label>Source Type</label>
            <select id="sourceType">
                <option value="uniform">Uniform Distribution</option>
                <option value="skewed">Skewed (80/20)</option>
                <option value="binary">Binary Symmetric</option>
                <option value="english">English Text</option>
            </select>
        </div>

        <div class="control-group">
            <label>Block Length n: <span class="value" id="blockValue">10</span></label>
            <input type="range" id="blockLength" min="1" max="50" step="1" value="10">
        </div>

        <div class="control-group">
            <label>Rate R (bits/symbol): <span class="value" id="rateValue">2.0</span></label>
            <input type="range" id="rate" min="0.5" max="4" step="0.1" value="2.0">
        </div>

        <button id="simulateBtn">Simulate Encoding</button>
        <button id="resetBtn" style="background:#444">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Source Entropy H(X)</span>
                <span class="stat-value" id="entropy">0 bits</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Target Rate R</span>
                <span class="stat-value" id="targetRate">0 bits</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Error Probability</span>
                <span class="stat-value" id="errorProb">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Theoretical Limit</span>
                <span class="stat-value" id="limit">R ≥ H</span>
            </div>
        </div>

        <div class="info">
            <strong>Source Coding:</strong> Minimum rate = entropy H(X).<br>
            <strong>R < H:</strong> Errors inevitable (some sequences lost).<br>
            <strong>R ≥ H:</strong> Perfect reconstruction possible.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let sourceType = 'uniform';
        let blockLength = 10;
        let rate = 2.0;
        let simResults = [];
        let running = false;

        // Source distributions
        const sources = {
            uniform: { symbols: ['A', 'B', 'C', 'D'], probs: [0.25, 0.25, 0.25, 0.25] },
            skewed: { symbols: ['A', 'B', 'C', 'D'], probs: [0.64, 0.20, 0.10, 0.06] },
            binary: { symbols: ['0', '1'], probs: [0.5, 0.5] },
            english: { symbols: ['e', 't', 'a', 'o', 'i', 'n', 's', 'r'],
                      probs: [0.127, 0.091, 0.082, 0.075, 0.070, 0.067, 0.063, 0.060] }
        };

        function calculateEntropy(probs) {
            let H = 0;
            for (const p of probs) {
                if (p > 0) H -= p * Math.log2(p);
            }
            return H;
        }

        function sampleSource(src) {
            const r = Math.random();
            let cumulative = 0;
            for (let i = 0; i < src.symbols.length; i++) {
                cumulative += src.probs[i];
                if (r < cumulative) return src.symbols[i];
            }
            return src.symbols[src.symbols.length - 1];
        }

        function generateSequence(n) {
            const src = sources[sourceType];
            let seq = '';
            for (let i = 0; i < n; i++) {
                seq += sampleSource(src);
            }
            return seq;
        }

        function sequenceTypeProbability(seq) {
            const src = sources[sourceType];
            let logProb = 0;
            for (const char of seq) {
                const idx = src.symbols.indexOf(char);
                if (idx >= 0) {
                    logProb += Math.log2(src.probs[idx]);
                }
            }
            return logProb;
        }

        function simulate() {
            const src = sources[sourceType];
            const entropy = calculateEntropy(src.probs);
            const numCodewords = Math.pow(2, Math.floor(rate * blockLength));
            const totalSequences = Math.pow(src.symbols.length, blockLength);

            // Generate typical sequences
            const sequences = [];
            const numSamples = 100;

            for (let i = 0; i < numSamples; i++) {
                const seq = generateSequence(blockLength);
                const logProb = sequenceTypeProbability(seq);
                sequences.push({
                    seq: seq,
                    logProb: logProb,
                    isTypical: Math.abs(-logProb / blockLength - entropy) < 0.5
                });
            }

            // Count typical sequences
            const typicalCount = sequences.filter(s => s.isTypical).length;

            // Error probability: sequences that can't be encoded
            const typicalSetSize = Math.pow(2, blockLength * entropy);
            const errorProb = rate < entropy ?
                Math.min(1, 1 - numCodewords / typicalSetSize) : 0;

            simResults = sequences;

            document.getElementById('entropy').textContent = entropy.toFixed(3) + ' bits';
            document.getElementById('targetRate').textContent = rate.toFixed(2) + ' bits/sym';
            document.getElementById('errorProb').textContent = (errorProb * 100).toFixed(1) + '%';
            document.getElementById('limit').textContent = rate >= entropy ? 'R ≥ H ✓' : 'R < H ✗';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 - 100;
            const src = sources[sourceType];
            const entropy = calculateEntropy(src.probs);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Source Coding Theorem', centerX, 40);

            // Draw source distribution
            const distY = 100;
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.fillText('Source Distribution P(X)', 200, distY - 10);

            const barWidth = 50;
            const maxBarHeight = 100;
            for (let i = 0; i < src.symbols.length; i++) {
                const x = 100 + i * (barWidth + 10);
                const height = src.probs[i] * maxBarHeight;

                ctx.fillStyle = `hsl(${330 - i * 30}, 70%, 50%)`;
                ctx.fillRect(x, distY + maxBarHeight - height, barWidth, height);

                ctx.fillStyle = '#fff';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(src.symbols[i], x + barWidth / 2, distY + maxBarHeight + 20);
                ctx.fillStyle = '#888';
                ctx.font = '11px sans-serif';
                ctx.fillText(src.probs[i].toFixed(2), x + barWidth / 2, distY + maxBarHeight + 35);
            }

            // Draw rate vs entropy diagram
            const diagramX = 450;
            const diagramY = 100;
            const diagramW = 300;
            const diagramH = 150;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(diagramX, diagramY, diagramW, diagramH);

            // Entropy line
            const entropyX = diagramX + (entropy / 4) * diagramW;
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(entropyX, diagramY);
            ctx.lineTo(entropyX, diagramY + diagramH);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#22c55e';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('H(X)', entropyX, diagramY - 5);

            // Rate marker
            const rateX = diagramX + (rate / 4) * diagramW;
            ctx.fillStyle = rate >= entropy ? '#22c55e' : '#ef4444';
            ctx.beginPath();
            ctx.moveTo(rateX, diagramY + diagramH - 10);
            ctx.lineTo(rateX - 8, diagramY + diagramH + 5);
            ctx.lineTo(rateX + 8, diagramY + diagramH + 5);
            ctx.closePath();
            ctx.fill();
            ctx.fillText('R', rateX, diagramY + diagramH + 20);

            // Regions
            ctx.fillStyle = 'rgba(239, 68, 68, 0.2)';
            ctx.fillRect(diagramX, diagramY, entropyX - diagramX, diagramH);
            ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
            ctx.fillRect(entropyX, diagramY, diagramW - (entropyX - diagramX), diagramH);

            ctx.fillStyle = '#ef4444';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Impossible', (diagramX + entropyX) / 2, diagramY + diagramH / 2);
            ctx.fillStyle = '#22c55e';
            ctx.fillText('Achievable', (entropyX + diagramX + diagramW) / 2, diagramY + diagramH / 2);

            ctx.fillStyle = '#888';
            ctx.fillText('Rate (bits/symbol)', diagramX + diagramW / 2, diagramY + diagramH + 40);

            // Draw sequence space visualization
            if (simResults.length > 0) {
                const seqY = 300;
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Sequence Space (typical set highlighted):', 50, seqY);

                // Draw sequences as dots
                const gridCols = 20;
                const dotSize = 15;
                const startX = 50;

                for (let i = 0; i < Math.min(simResults.length, 100); i++) {
                    const col = i % gridCols;
                    const row = Math.floor(i / gridCols);
                    const x = startX + col * (dotSize + 5);
                    const y = seqY + 20 + row * (dotSize + 5);

                    const result = simResults[i];
                    ctx.beginPath();
                    ctx.arc(x + dotSize / 2, y + dotSize / 2, dotSize / 2, 0, Math.PI * 2);

                    if (result.isTypical) {
                        ctx.fillStyle = '#22c55e';
                    } else {
                        ctx.fillStyle = '#666';
                    }
                    ctx.fill();
                }

                // Legend
                const legendY = seqY + 150;
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(60, legendY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#888';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Typical sequence', 75, legendY + 4);

                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(200, legendY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#888';
                ctx.fillText('Atypical sequence', 215, legendY + 4);

                // Show some sequences
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText('Sample sequences:', 50, legendY + 40);

                for (let i = 0; i < Math.min(5, simResults.length); i++) {
                    const result = simResults[i];
                    ctx.fillStyle = result.isTypical ? '#22c55e' : '#666';
                    const display = result.seq.slice(0, 20) + (result.seq.length > 20 ? '...' : '');
                    ctx.fillText(`${display} (${(-result.logProb / blockLength).toFixed(2)} bits/sym)`, 50, legendY + 60 + i * 18);
                }
            }

            // Draw AEP explanation
            const aepY = canvas.height - 120;
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(50, aepY - 20, canvas.width - 400, 100);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Asymptotic Equipartition Property (AEP):', 60, aepY);

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText(`• Typical set contains ≈ 2^(nH) = 2^(${blockLength}×${entropy.toFixed(2)}) ≈ ${Math.pow(2, blockLength * entropy).toExponential(1)} sequences`, 60, aepY + 25);
            ctx.fillText(`• With rate R = ${rate.toFixed(2)}, we have 2^(nR) = ${Math.pow(2, blockLength * rate).toExponential(1)} codewords`, 60, aepY + 45);
            ctx.fillText(`• ${rate >= entropy ? 'Sufficient codewords to encode all typical sequences ✓' : 'Not enough codewords - some sequences will be lost ✗'}`, 60, aepY + 65);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('sourceType').onchange = (e) => {
            sourceType = e.target.value;
            simulate();
        };

        document.getElementById('blockLength').oninput = (e) => {
            blockLength = parseInt(e.target.value);
            document.getElementById('blockValue').textContent = blockLength;
        };

        document.getElementById('rate').oninput = (e) => {
            rate = parseFloat(e.target.value);
            document.getElementById('rateValue').textContent = rate.toFixed(1);
        };

        document.getElementById('simulateBtn').onclick = simulate;

        document.getElementById('resetBtn').onclick = () => {
            simResults = [];
        };

        // Initialize
        simulate();
        draw();
    </script>
</body>
</html>
