<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channel Capacity - Information Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4fc3f7;
            text-decoration: none;
            font-size: 18px;
            z-index: 1000;
            padding: 10px 20px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 8px;
            border: 1px solid #4fc3f7;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(79, 195, 247, 0.2);
            transform: translateX(-5px);
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 30, 50, 0.95);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #4fc3f7;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .controls h2 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 22px;
        }

        .slider-group {
            margin-bottom: 20px;
        }

        .slider-group label {
            display: block;
            color: #66bb6a;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .slider-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            color: #81c784;
            font-size: 16px;
            font-weight: bold;
        }

        .info-box {
            background: rgba(79, 195, 247, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 3px solid #4fc3f7;
        }

        .info-box h3 {
            color: #4fc3f7;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #b0bec5;
            font-size: 13px;
            line-height: 1.6;
        }

        .capacity-value {
            font-size: 24px;
            font-weight: bold;
            color: #66bb6a;
            text-align: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(102, 187, 106, 0.1);
            border-radius: 8px;
        }

        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(102, 187, 106, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            color: #81c784;
            font-size: 13px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4fc3f7;
            color: #0a0e1a;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        button:hover {
            background: #29b6f6;
            transform: scale(1.02);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Channel Capacity</h2>

        <div class="capacity-value" id="capacityValue">C = 1.000 bits/use</div>

        <div class="slider-group">
            <label>Signal-to-Noise Ratio (SNR): <span class="slider-value" id="snrValue">10.0 dB</span></label>
            <input type="range" id="snrSlider" min="-10" max="40" value="10" step="0.5">
        </div>

        <div class="slider-group">
            <label>Bandwidth: <span class="slider-value" id="bandwidthValue">1.0 MHz</span></label>
            <input type="range" id="bandwidthSlider" min="1" max="100" value="10" step="1">
        </div>

        <div class="slider-group">
            <label>Error Probability: <span class="slider-value" id="errorValue">0.100</span></label>
            <input type="range" id="errorSlider" min="0" max="50" value="10" step="1">
        </div>

        <button onclick="toggleTransmission()">Start Transmission</button>

        <div class="info-box">
            <h3>Shannon-Hartley Theorem</h3>
            <div class="formula">C = B × log₂(1 + SNR)</div>
            <p style="margin-top: 10px;">Channel capacity is the maximum rate at which information can be reliably transmitted over a noisy channel.</p>
            <p style="margin-top: 8px;">Higher SNR or bandwidth increases capacity. Errors occur when transmission rate exceeds capacity.</p>
        </div>

        <div class="info-box">
            <h3>Binary Symmetric Channel</h3>
            <div class="formula">C = 1 - H(p)</div>
            <p style="margin-top: 10px;">For a binary channel with error probability p, capacity depends on binary entropy H(p).</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let snrDB = 10;
        let bandwidth = 1; // MHz
        let errorProb = 0.1;
        let transmitting = false;
        let bits = [];
        let time = 0;

        const snrSlider = document.getElementById('snrSlider');
        const bandwidthSlider = document.getElementById('bandwidthSlider');
        const errorSlider = document.getElementById('errorSlider');

        snrSlider.addEventListener('input', (e) => {
            snrDB = parseFloat(e.target.value);
            document.getElementById('snrValue').textContent = snrDB.toFixed(1) + ' dB';
            updateCapacity();
        });

        bandwidthSlider.addEventListener('input', (e) => {
            bandwidth = parseInt(e.target.value) / 10;
            document.getElementById('bandwidthValue').textContent = bandwidth.toFixed(1) + ' MHz';
            updateCapacity();
        });

        errorSlider.addEventListener('input', (e) => {
            errorProb = parseInt(e.target.value) / 100;
            document.getElementById('errorValue').textContent = errorProb.toFixed(3);
            updateCapacity();
        });

        function updateCapacity() {
            const snrLinear = Math.pow(10, snrDB / 10);
            const capacity = bandwidth * Math.log2(1 + snrLinear);

            // Binary symmetric channel capacity
            const binaryH = errorProb > 0 && errorProb < 1 ?
                -(errorProb * Math.log2(errorProb) + (1 - errorProb) * Math.log2(1 - errorProb)) : 0;
            const bscCapacity = 1 - binaryH;

            document.getElementById('capacityValue').innerHTML =
                `C = ${capacity.toFixed(3)} Mbps<br><small>BSC: ${bscCapacity.toFixed(3)} bits/use</small>`;
        }

        function toggleTransmission() {
            transmitting = !transmitting;
            if (!transmitting) {
                bits = [];
            }
        }

        function generateBit() {
            return Math.random() < 0.5 ? 0 : 1;
        }

        function transmitThroughChannel(bit) {
            // Apply error based on error probability
            if (Math.random() < errorProb) {
                return 1 - bit; // Flip bit
            }
            return bit;
        }

        function drawChannel() {
            const centerY = height / 2;
            const leftX = 100;
            const rightX = width - 450;
            const channelWidth = rightX - leftX;

            // Draw channel box
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(leftX, centerY - 150, channelWidth, 300);
            ctx.setLineDash([]);

            // Draw title
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Noisy Channel', leftX + channelWidth / 2, centerY - 180);

            // Draw transmitter
            ctx.fillStyle = '#66bb6a';
            ctx.fillRect(leftX - 80, centerY - 40, 60, 80);
            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 2;
            ctx.strokeRect(leftX - 80, centerY - 40, 60, 80);
            ctx.fillStyle = '#0a0e1a';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('TX', leftX - 50, centerY + 5);

            // Draw receiver
            ctx.fillStyle = '#ab47bc';
            ctx.fillRect(rightX + 20, centerY - 40, 60, 80);
            ctx.strokeStyle = '#ab47bc';
            ctx.lineWidth = 2;
            ctx.strokeRect(rightX + 20, centerY - 40, 60, 80);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillText('RX', rightX + 50, centerY + 5);

            // Draw noise sources
            for (let i = 0; i < 5; i++) {
                const x = leftX + (i + 1) * channelWidth / 6;
                const y = centerY + (Math.sin(time * 0.05 + i) * 30);

                ctx.fillStyle = 'rgba(255, 167, 38, 0.3)';
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffa726';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('N', x, y + 5);
            }
        }

        function drawSignal() {
            const centerY = height / 2;
            const signalY = 120;
            const signalWidth = width - 500;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Signal Quality vs SNR', 50, signalY - 30);

            // Draw clean signal
            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < signalWidth; x++) {
                const t = x / 20;
                const y = signalY + Math.sin(t) * 30;
                if (x === 0) ctx.moveTo(50 + x, y);
                else ctx.lineTo(50 + x, y);
            }
            ctx.stroke();

            // Draw noisy signal
            const snrLinear = Math.pow(10, snrDB / 10);
            const noiseAmplitude = 30 / Math.sqrt(snrLinear + 1);

            ctx.strokeStyle = '#ffa726';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < signalWidth; x++) {
                const t = x / 20;
                const noise = (Math.random() - 0.5) * 2 * noiseAmplitude;
                const y = signalY + 80 + Math.sin(t) * 30 + noise;
                if (x === 0) ctx.moveTo(50 + x, y);
                else ctx.lineTo(50 + x, y);
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#66bb6a';
            ctx.font = '14px sans-serif';
            ctx.fillText('Clean Signal', signalWidth - 100, signalY + 10);

            ctx.fillStyle = '#ffa726';
            ctx.fillText('Noisy Signal', signalWidth - 100, signalY + 90);
        }

        function drawBitTransmission() {
            if (!transmitting) return;

            const centerY = height / 2;
            const startX = 50;
            const endX = width - 420;

            // Generate new bit periodically
            if (time % 30 === 0) {
                const sentBit = generateBit();
                const receivedBit = transmitThroughChannel(sentBit);
                bits.push({
                    sent: sentBit,
                    received: receivedBit,
                    x: startX,
                    error: sentBit !== receivedBit
                });
            }

            // Update and draw bits
            for (let i = bits.length - 1; i >= 0; i--) {
                const bit = bits[i];
                bit.x += 3;

                if (bit.x > endX) {
                    bits.splice(i, 1);
                    continue;
                }

                // Draw sent bit (before channel)
                if (bit.x < startX + 200) {
                    ctx.fillStyle = bit.sent === 1 ? '#66bb6a' : '#4fc3f7';
                    ctx.beginPath();
                    ctx.arc(bit.x, centerY - 60, 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw received bit (after channel)
                if (bit.x > endX - 200) {
                    ctx.fillStyle = bit.error ? '#f44336' : (bit.received === 1 ? '#66bb6a' : '#4fc3f7');
                    ctx.beginPath();
                    ctx.arc(bit.x, centerY + 60, 8, 0, Math.PI * 2);
                    ctx.fill();

                    if (bit.error) {
                        ctx.strokeStyle = '#f44336';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
        }

        function drawCapacityGraph() {
            const graphX = 50;
            const graphY = height - 200;
            const graphWidth = 400;
            const graphHeight = 150;

            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Capacity vs SNR', graphX, graphY - 20);

            // Draw axes
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(graphX, graphY);
            ctx.lineTo(graphX, graphY + graphHeight);
            ctx.lineTo(graphX + graphWidth, graphY + graphHeight);
            ctx.stroke();

            // Draw capacity curve
            ctx.strokeStyle = '#66bb6a';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let x = 0; x <= graphWidth; x++) {
                const snr = (x / graphWidth) * 50 - 10; // -10 to 40 dB
                const snrLinear = Math.pow(10, snr / 10);
                const capacity = bandwidth * Math.log2(1 + snrLinear);
                const normalizedCapacity = Math.min(capacity / 10, 1); // Normalize to 0-1
                const y = graphY + graphHeight - normalizedCapacity * graphHeight;

                if (x === 0) ctx.moveTo(graphX + x, y);
                else ctx.lineTo(graphX + x, y);
            }
            ctx.stroke();

            // Draw current SNR marker
            const currentX = graphX + (snrDB + 10) / 50 * graphWidth;
            const snrLinear = Math.pow(10, snrDB / 10);
            const capacity = bandwidth * Math.log2(1 + snrLinear);
            const normalizedCapacity = Math.min(capacity / 10, 1);
            const currentY = graphY + graphHeight - normalizedCapacity * graphHeight;

            ctx.fillStyle = '#ffa726';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Labels
            ctx.fillStyle = '#b0bec5';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('-10', graphX, graphY + graphHeight + 20);
            ctx.fillText('40 dB', graphX + graphWidth, graphY + graphHeight + 20);

            ctx.save();
            ctx.translate(graphX - 30, graphY + graphHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Capacity (Mbps)', 0, 0);
            ctx.restore();
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            drawSignal();
            drawChannel();
            drawBitTransmission();
            drawCapacityGraph();

            time++;
            requestAnimationFrame(draw);
        }

        // Initialize
        updateCapacity();
        draw();
    </script>
</body>
</html>
