<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Compression | Information Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 300px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }
        h1 { color: #ec4899; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="text"], textarea, select {
            width: 100%; padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px; color: white;
        }
        textarea { height: 80px; resize: vertical; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ec4899; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #f472b6; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ec4899; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ec4899; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Information Theory</a>

    <div class="controls">
        <h1>Data Compression</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Run-length & dictionary encoding</p>

        <div class="control-group">
            <label>Algorithm</label>
            <select id="algorithm">
                <option value="rle">Run-Length Encoding (RLE)</option>
                <option value="lz77">LZ77 Dictionary</option>
                <option value="bwt">Burrows-Wheeler Transform</option>
            </select>
        </div>

        <div class="control-group">
            <label>Input Data</label>
            <textarea id="inputData">AAAABBBCCDAAAABBBCCD</textarea>
        </div>

        <button id="compressBtn">Compress</button>
        <button id="exampleBtn" style="background:#444">Load Example</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Original Size</span>
                <span class="stat-value" id="origSize">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Compressed Size</span>
                <span class="stat-value" id="compSize">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Compression Ratio</span>
                <span class="stat-value" id="ratio">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Space Saved</span>
                <span class="stat-value" id="saved">0%</span>
            </div>
        </div>

        <div class="info">
            <strong>RLE:</strong> Replaces runs with count+symbol.<br>
            <strong>LZ77:</strong> References previous occurrences.<br>
            <strong>BWT:</strong> Rearranges for better RLE.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let originalData = '';
        let compressedData = '';
        let compressionSteps = [];
        let algorithm = 'rle';

        // Run-Length Encoding
        function rleEncode(str) {
            const steps = [];
            let result = '';
            let i = 0;

            while (i < str.length) {
                let count = 1;
                while (i + count < str.length && str[i + count] === str[i]) {
                    count++;
                }
                const encoded = count + str[i];
                result += encoded;
                steps.push({
                    type: 'run',
                    original: str[i].repeat(count),
                    encoded: encoded,
                    position: i
                });
                i += count;
            }

            return { result, steps };
        }

        // Simple LZ77
        function lz77Encode(str) {
            const steps = [];
            let result = '';
            let i = 0;
            const windowSize = 20;

            while (i < str.length) {
                let bestLength = 0;
                let bestOffset = 0;

                // Search in sliding window
                const searchStart = Math.max(0, i - windowSize);
                for (let j = searchStart; j < i; j++) {
                    let length = 0;
                    while (i + length < str.length && str[j + length] === str[i + length] && j + length < i) {
                        length++;
                    }
                    if (length > bestLength) {
                        bestLength = length;
                        bestOffset = i - j;
                    }
                }

                if (bestLength >= 3) {
                    const token = `(${bestOffset},${bestLength})`;
                    result += token;
                    steps.push({
                        type: 'reference',
                        original: str.slice(i, i + bestLength),
                        encoded: token,
                        position: i,
                        offset: bestOffset,
                        length: bestLength
                    });
                    i += bestLength;
                } else {
                    result += str[i];
                    steps.push({
                        type: 'literal',
                        original: str[i],
                        encoded: str[i],
                        position: i
                    });
                    i++;
                }
            }

            return { result, steps };
        }

        // Burrows-Wheeler Transform
        function bwtEncode(str) {
            const steps = [];
            const n = str.length;

            // Create all rotations
            const rotations = [];
            for (let i = 0; i < n; i++) {
                rotations.push(str.slice(i) + str.slice(0, i));
            }

            steps.push({
                type: 'rotations',
                data: rotations.slice()
            });

            // Sort rotations
            const sorted = rotations.slice().sort();

            steps.push({
                type: 'sorted',
                data: sorted.slice()
            });

            // Get last column
            let result = '';
            let originalIndex = 0;
            for (let i = 0; i < n; i++) {
                result += sorted[i][n - 1];
                if (sorted[i] === str) {
                    originalIndex = i;
                }
            }

            steps.push({
                type: 'result',
                bwt: result,
                index: originalIndex
            });

            // Now apply RLE to BWT output
            const rle = rleEncode(result);

            return {
                result: `[${originalIndex}]${rle.result}`,
                steps: steps.concat(rle.steps),
                bwtOnly: result
            };
        }

        function compress() {
            originalData = document.getElementById('inputData').value;
            if (!originalData) return;

            let result;
            switch (algorithm) {
                case 'rle':
                    result = rleEncode(originalData);
                    break;
                case 'lz77':
                    result = lz77Encode(originalData);
                    break;
                case 'bwt':
                    result = bwtEncode(originalData);
                    break;
            }

            compressedData = result.result;
            compressionSteps = result.steps;

            // Update stats
            const origSize = originalData.length;
            const compSize = compressedData.length;
            const ratio = (compSize / origSize * 100).toFixed(1);
            const saved = ((1 - compSize / origSize) * 100).toFixed(1);

            document.getElementById('origSize').textContent = origSize + ' chars';
            document.getElementById('compSize').textContent = compSize + ' chars';
            document.getElementById('ratio').textContent = ratio + '%';
            document.getElementById('saved').textContent = (saved > 0 ? saved : 0) + '%';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 - 100;

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Data Compression Visualization', centerX, 40);

            if (!originalData) {
                ctx.fillStyle = '#888';
                ctx.font = '16px sans-serif';
                ctx.fillText('Enter data and click "Compress"', centerX, canvas.height / 2);
                requestAnimationFrame(draw);
                return;
            }

            // Draw original data
            const dataY = 100;
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Original Data:', 50, dataY);

            // Draw original string with colored runs
            const charWidth = 20;
            const charHeight = 30;
            const maxChars = Math.min(originalData.length, Math.floor((canvas.width - 400) / charWidth));

            let colorIndex = 0;
            const colors = ['#ec4899', '#8b5cf6', '#06b6d4', '#22c55e', '#eab308', '#f97316'];

            for (let i = 0; i < maxChars; i++) {
                const x = 50 + i * charWidth;

                // Find which run this belongs to
                let runColor = colors[0];
                if (algorithm === 'rle' || algorithm === 'bwt') {
                    let pos = 0;
                    let cIdx = 0;
                    for (const step of compressionSteps) {
                        if (step.type === 'run') {
                            if (i >= pos && i < pos + step.original.length) {
                                runColor = colors[cIdx % colors.length];
                                break;
                            }
                            pos += step.original.length;
                            cIdx++;
                        }
                    }
                }

                ctx.fillStyle = runColor + '40';
                ctx.fillRect(x, dataY + 10, charWidth - 2, charHeight);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(originalData[i], x + charWidth / 2, dataY + 30);
            }

            if (originalData.length > maxChars) {
                ctx.fillStyle = '#888';
                ctx.fillText('...', 50 + maxChars * charWidth + 10, dataY + 30);
            }

            // Draw compression process
            const processY = 200;
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Compression Process (' + algorithm.toUpperCase() + '):', 50, processY);

            if (algorithm === 'rle') {
                // Show RLE steps
                let stepY = processY + 30;
                let stepX = 50;

                for (let i = 0; i < Math.min(compressionSteps.length, 10); i++) {
                    const step = compressionSteps[i];
                    if (step.type !== 'run') continue;

                    const color = colors[i % colors.length];

                    // Original run
                    ctx.fillStyle = color + '40';
                    ctx.fillRect(stepX, stepY, step.original.length * 15 + 10, 25);
                    ctx.strokeStyle = color;
                    ctx.strokeRect(stepX, stepY, step.original.length * 15 + 10, 25);
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(step.original, stepX + (step.original.length * 15 + 10) / 2, stepY + 17);

                    // Arrow
                    ctx.fillStyle = '#666';
                    ctx.fillText('→', stepX + step.original.length * 15 + 20, stepY + 17);

                    // Encoded
                    ctx.fillStyle = color;
                    ctx.font = 'bold 14px monospace';
                    ctx.fillText(step.encoded, stepX + step.original.length * 15 + 50, stepY + 17);

                    stepX += step.original.length * 15 + 100;
                    if (stepX > canvas.width - 500) {
                        stepX = 50;
                        stepY += 40;
                    }
                }
            } else if (algorithm === 'lz77') {
                // Show LZ77 sliding window
                let stepY = processY + 30;

                for (let i = 0; i < Math.min(compressionSteps.length, 8); i++) {
                    const step = compressionSteps[i];
                    const color = step.type === 'reference' ? '#22c55e' : '#888';

                    ctx.fillStyle = color + '40';
                    ctx.fillRect(50, stepY, 150, 25);
                    ctx.strokeStyle = color;
                    ctx.strokeRect(50, stepY, 150, 25);

                    ctx.fillStyle = '#fff';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(step.original, 55, stepY + 17);

                    ctx.fillStyle = '#666';
                    ctx.fillText('→', 210, stepY + 17);

                    ctx.fillStyle = color;
                    ctx.font = 'bold 12px monospace';
                    ctx.fillText(step.encoded, 230, stepY + 17);

                    if (step.type === 'reference') {
                        ctx.fillStyle = '#888';
                        ctx.font = '11px sans-serif';
                        ctx.fillText(`(back ${step.offset}, copy ${step.length})`, 300, stepY + 17);
                    }

                    stepY += 35;
                }
            } else if (algorithm === 'bwt') {
                // Show BWT matrix (simplified)
                const bwtSteps = compressionSteps.filter(s => s.type === 'rotations' || s.type === 'sorted' || s.type === 'result');

                if (bwtSteps.length >= 2) {
                    ctx.fillStyle = '#888';
                    ctx.font = '12px sans-serif';
                    ctx.fillText('Rotations (sorted):', 50, processY + 50);

                    const sorted = bwtSteps[1].data;
                    for (let i = 0; i < Math.min(sorted.length, 8); i++) {
                        const str = sorted[i].slice(0, 20) + (sorted[i].length > 20 ? '...' : '');
                        ctx.fillStyle = '#666';
                        ctx.font = '11px monospace';
                        ctx.fillText(str, 50, processY + 70 + i * 18);

                        // Highlight last character
                        ctx.fillStyle = '#ec4899';
                        ctx.fillText(sorted[i][sorted[i].length - 1], 50 + str.length * 7, processY + 70 + i * 18);
                    }

                    if (bwtSteps[2]) {
                        ctx.fillStyle = '#888';
                        ctx.font = '12px sans-serif';
                        ctx.fillText('BWT Output (last column):', 300, processY + 50);
                        ctx.fillStyle = '#ec4899';
                        ctx.font = '14px monospace';
                        ctx.fillText(bwtSteps[2].bwt.slice(0, 30), 300, processY + 75);
                    }
                }
            }

            // Draw compressed result
            const resultY = canvas.height - 150;
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(50, resultY - 30, canvas.width - 400, 100);

            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Compressed Output:', 60, resultY - 10);

            ctx.fillStyle = '#ec4899';
            ctx.font = '14px monospace';
            const displayCompressed = compressedData.slice(0, 80) + (compressedData.length > 80 ? '...' : '');
            ctx.fillText(displayCompressed, 60, resultY + 20);

            // Draw size comparison bar
            const barY = resultY + 50;
            const barWidth = 300;
            const origBarWidth = barWidth;
            const compBarWidth = (compressedData.length / originalData.length) * barWidth;

            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(60, barY, origBarWidth, 20);
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(60, barY + 25, compBarWidth, 20);

            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText(`Original: ${originalData.length}`, 60 + origBarWidth + 10, barY + 14);
            ctx.fillText(`Compressed: ${compressedData.length}`, 60 + barWidth + 10, barY + 39);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('algorithm').onchange = (e) => {
            algorithm = e.target.value;
        };

        document.getElementById('compressBtn').onclick = compress;

        document.getElementById('exampleBtn').onclick = () => {
            const examples = {
                'rle': 'AAAABBBCCCCCCDDDEEEEEEEFFFFFFGG',
                'lz77': 'abracadabra abracadabra',
                'bwt': 'banana'
            };
            document.getElementById('inputData').value = examples[algorithm];
            compress();
        };

        // Initialize
        draw();
    </script>
</body>
</html>
