<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>El Ni&ntilde;o Southern Oscillation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Nunito', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 1.4rem; font-weight: 600;
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center;
}
.title-overlay .subtitle {
    font-size: 0.8rem; opacity: 0.7; margin-top: 4px; font-weight: 300;
}
.organic-back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    display: flex; align-items: center; gap: 8px;
    padding: 8px 16px; border-radius: 20px;
    background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
    color: #fff; text-decoration: none; font-size: 0.9rem;
    transition: background 0.3s;
}
.organic-back-link:hover { background: rgba(255,255,255,0.2); }
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 12px; align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
    padding: 12px 24px; border-radius: 20px; color: #fff; font-size: 0.85rem;
}
.controls button {
    padding: 8px 16px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1); color: #fff; cursor: pointer;
    font-size: 0.85rem; transition: all 0.3s;
}
.controls button:hover { background: rgba(255,255,255,0.2); }
.controls button.active { background: rgba(100,180,255,0.3); border-color: rgba(100,180,255,0.6); }
.info-panel {
    position: fixed; top: 80px; right: 20px; z-index: 10;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(10px);
    padding: 12px 16px; border-radius: 12px; color: #fff; font-size: 0.75rem;
    line-height: 1.8; min-width: 160px;
}
.phase-label {
    font-size: 1.1rem; font-weight: bold; margin-bottom: 4px;
}
</style>
</head>
<body>
<a href="../index.html" class="organic-back-link">
    <span class="back-arrow">&larr;</span>
    <span class="back-text">Gallery</span>
</a>
<div class="title-overlay">
    El Ni&ntilde;o Southern Oscillation
    <div class="subtitle">Pacific Ocean cross-section &mdash; Trade winds, thermocline, and SST changes</div>
</div>
<div class="info-panel">
    <div class="phase-label" id="phaseLabel">Normal</div>
    <div>Trade Winds: <span id="windStr">Normal</span></div>
    <div>East SST: <span id="eastSST">20</span>&deg;C</div>
    <div>West SST: <span id="westSST">28</span>&deg;C</div>
    <div>Thermocline Tilt: <span id="tiltAngle">Normal</span></div>
    <div>Upwelling: <span id="upwelling">Active</span></div>
</div>
<div class="controls">
    <button id="btnNormal" class="active" onclick="setPhase('normal')">Normal</button>
    <button id="btnElNino" onclick="setPhase('elnino')">El Ni&ntilde;o</button>
    <button id="btnLaNina" onclick="setPhase('lanina')">La Ni&ntilde;a</button>
    <button id="btnCycle" onclick="toggleCycle()">Auto Cycle</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// State
let currentPhase = 'normal';
let targetPhase = 'normal';
let cycling = false;
let cycleTime = 0;

// Interpolated parameters
let tradeWindStrength = 1;   // 0=none, 1=normal, 1.5=strong
let thermoclineTilt = 0;     // -1=ElNino (flat/reversed), 0=normal, 1=LaNina (steep)
let eastSST = 20;
let westSST = 28;
let upwellingStrength = 1;

const phaseParams = {
    normal:  { winds: 1,   tilt: 0,   eastSST: 20, westSST: 28, upwelling: 1   },
    elnino:  { winds: 0.2, tilt: -0.8, eastSST: 26, westSST: 26, upwelling: 0.2 },
    lanina:  { winds: 1.5, tilt: 0.8,  eastSST: 17, westSST: 30, upwelling: 1.5 }
};

function setPhase(phase) {
    targetPhase = phase;
    currentPhase = phase;
    cycling = false;
    document.getElementById('btnCycle').classList.remove('active');
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    document.getElementById('btn' + phase.charAt(0).toUpperCase() + phase.slice(1).replace('n', 'N').replace('elnino','ElNino').replace('lanina','LaNina').replace('normal','Normal')).classList.add('active');
    // Fix button ID
    if (phase === 'normal') document.getElementById('btnNormal').classList.add('active');
    else if (phase === 'elnino') document.getElementById('btnElNino').classList.add('active');
    else if (phase === 'lanina') document.getElementById('btnLaNina').classList.add('active');
}

function toggleCycle() {
    cycling = !cycling;
    document.getElementById('btnCycle').classList.toggle('active', cycling);
    if (cycling) {
        document.querySelectorAll('.controls button:not(#btnCycle)').forEach(b => b.classList.remove('active'));
    }
}

function lerp(a, b, t) { return a + (b - a) * t; }

// Particles
const NUM_PARTICLES = 1500;
const particles = [];
const windArrows = [];

class OceanParticle {
    constructor() {
        this.reset();
    }
    reset() {
        const oceanBounds = getOceanBounds();
        this.x = oceanBounds.left + Math.random() * (oceanBounds.right - oceanBounds.left);
        this.y = oceanBounds.top + Math.random() * (oceanBounds.bottom - oceanBounds.top);
        this.vx = 0;
        this.vy = 0;
        this.size = 1 + Math.random() * 1.5;
        this.life = 0.5 + Math.random() * 0.5;
    }
    update() {
        const oceanBounds = getOceanBounds();
        const fx = (this.x - oceanBounds.left) / (oceanBounds.right - oceanBounds.left); // 0=west, 1=east
        const fy = (this.y - oceanBounds.top) / (oceanBounds.bottom - oceanBounds.top);  // 0=surface, 1=deep

        // Thermocline position
        const thermoclineDepth = getThermoclineDepth(fx);
        const isAboveThermocline = fy < thermoclineDepth;

        // Surface currents driven by trade winds
        if (fy < 0.15) {
            this.vx -= tradeWindStrength * 0.15; // Westward (trade winds push water west)
        }

        // Deep return flow
        if (fy > 0.6) {
            this.vx += tradeWindStrength * 0.05; // Eastward return
        }

        // Upwelling on east side
        if (fx > 0.8 && fy > 0.3) {
            this.vy -= upwellingStrength * 0.04;
        }

        // Downwelling on west side
        if (fx < 0.2 && fy < 0.5) {
            this.vy += tradeWindStrength * 0.02;
        }

        this.vx *= 0.97;
        this.vy *= 0.97;
        this.x += this.vx;
        this.y += this.vy;

        this.life -= 0.002;

        // Wrap/reset
        if (this.x < oceanBounds.left) this.x = oceanBounds.right;
        if (this.x > oceanBounds.right) this.x = oceanBounds.left;
        if (this.y < oceanBounds.top) this.y = oceanBounds.top + 5;
        if (this.y > oceanBounds.bottom) this.y = oceanBounds.bottom - 5;
        if (this.life <= 0) this.reset();
    }
    draw() {
        const oceanBounds = getOceanBounds();
        const fx = (this.x - oceanBounds.left) / (oceanBounds.right - oceanBounds.left);
        const fy = (this.y - oceanBounds.top) / (oceanBounds.bottom - oceanBounds.top);

        // Temperature coloring
        const surfaceTemp = lerp(westSST, eastSST, fx);
        const deepTemp = 5;
        const thermDepth = getThermoclineDepth(fx);
        let temp;
        if (fy < thermDepth) {
            temp = lerp(surfaceTemp, surfaceTemp - 5, fy / thermDepth);
        } else {
            temp = lerp(surfaceTemp - 5, deepTemp, (fy - thermDepth) / (1 - thermDepth));
        }

        const t = (temp - 5) / 25; // normalize 5-30C
        let r, g, b;
        if (t < 0.3) {
            r = 30; g = 60 + t * 300; b = 200;
        } else if (t < 0.6) {
            const tt = (t - 0.3) / 0.3;
            r = 30 + tt * 200; g = 150 + tt * 50; b = 200 - tt * 100;
        } else {
            const tt = (t - 0.6) / 0.4;
            r = 230 + tt * 25; g = 200 - tt * 130; b = 100 - tt * 80;
        }

        ctx.fillStyle = `rgba(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)},${this.life * 0.6})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new OceanParticle());
}

function getOceanBounds() {
    return {
        left: W * 0.08,
        right: W * 0.92,
        top: H * 0.35,
        bottom: H * 0.85
    };
}

function getThermoclineDepth(fx) {
    // fx: 0=west, 1=east
    // Normal: deeper in west, shallower in east
    // El Nino: flatter (deeper in east)
    // La Nina: steeper (shallower in east)
    const baseTilt = 0.15; // natural tilt
    const tilt = baseTilt + thermoclineTilt * 0.15;
    return 0.35 + fx * tilt;
}

function drawBackground() {
    // Sky
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.35);
    skyGrad.addColorStop(0, '#0a1025');
    skyGrad.addColorStop(1, '#1a2540');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H * 0.35);

    // Atmosphere label
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.font = '11px sans-serif';
    ctx.fillText('Atmosphere', W * 0.1, H * 0.1);
}

function drawOcean() {
    const bounds = getOceanBounds();

    // Ocean body
    const oceanGrad = ctx.createLinearGradient(0, bounds.top, 0, bounds.bottom);
    oceanGrad.addColorStop(0, 'rgba(15, 50, 90, 0.5)');
    oceanGrad.addColorStop(0.5, 'rgba(10, 35, 65, 0.6)');
    oceanGrad.addColorStop(1, 'rgba(5, 20, 40, 0.7)');
    ctx.fillStyle = oceanGrad;
    ctx.fillRect(bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top);

    // SST color bar at surface
    for (let x = bounds.left; x < bounds.right; x += 3) {
        const fx = (x - bounds.left) / (bounds.right - bounds.left);
        const temp = lerp(westSST, eastSST, fx);
        const t = (temp - 15) / 15;
        let r = 30 + t * 225, g = 80 + t * 120 - Math.abs(t - 0.5) * 100, b = 200 - t * 180;
        ctx.fillStyle = `rgba(${Math.floor(Math.max(0,Math.min(255,r)))},${Math.floor(Math.max(0,Math.min(255,g)))},${Math.floor(Math.max(0,Math.min(255,b)))},0.4)`;
        ctx.fillRect(x, bounds.top, 4, 15);
    }

    // Surface waves
    const time = Date.now() * 0.001;
    ctx.strokeStyle = 'rgba(100, 180, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = bounds.left; x < bounds.right; x += 3) {
        const y = bounds.top + Math.sin(x * 0.02 + time) * 2;
        if (x === Math.ceil(bounds.left)) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Thermocline line
    ctx.strokeStyle = 'rgba(255, 200, 50, 0.4)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    for (let x = bounds.left; x < bounds.right; x += 5) {
        const fx = (x - bounds.left) / (bounds.right - bounds.left);
        const depth = getThermoclineDepth(fx);
        const y = bounds.top + depth * (bounds.bottom - bounds.top);
        if (x === Math.ceil(bounds.left)) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Thermocline label
    const midFx = 0.5;
    const midDepth = getThermoclineDepth(midFx);
    const labelY = bounds.top + midDepth * (bounds.bottom - bounds.top);
    ctx.fillStyle = 'rgba(255, 200, 50, 0.4)';
    ctx.font = '11px sans-serif';
    ctx.fillText('Thermocline', bounds.left + (bounds.right - bounds.left) * 0.45, labelY - 8);

    // Region labels
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Western Pacific', bounds.left + 80, bounds.bottom + 20);
    ctx.fillText('(Indonesia/Australia)', bounds.left + 80, bounds.bottom + 35);
    ctx.fillText('Eastern Pacific', bounds.right - 80, bounds.bottom + 20);
    ctx.fillText('(South America)', bounds.right - 80, bounds.bottom + 35);
    ctx.textAlign = 'left';
}

function drawTradeWinds() {
    const bounds = getOceanBounds();
    const windY = H * 0.25;
    const time = Date.now() * 0.002;

    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Trade Winds', W * 0.5, windY - 20);
    ctx.textAlign = 'left';

    // Wind arrows
    const numArrows = 10;
    for (let i = 0; i < numArrows; i++) {
        const fx = 0.15 + (i / numArrows) * 0.7;
        const x = bounds.left + fx * (bounds.right - bounds.left);
        const y = windY + Math.sin(time + i * 0.5) * 3;
        const arrowLen = 20 * tradeWindStrength;

        if (tradeWindStrength < 0.1) continue;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(-1, 1); // Point west (left)

        ctx.strokeStyle = `rgba(150, 200, 255, ${0.15 + tradeWindStrength * 0.15})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-arrowLen / 2, 0);
        ctx.lineTo(arrowLen / 2, 0);
        ctx.stroke();

        ctx.fillStyle = `rgba(150, 200, 255, ${0.15 + tradeWindStrength * 0.15})`;
        ctx.beginPath();
        ctx.moveTo(arrowLen / 2 + 5, 0);
        ctx.lineTo(arrowLen / 2 - 3, -4);
        ctx.lineTo(arrowLen / 2 - 3, 4);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }
}

function drawUpwelling() {
    const bounds = getOceanBounds();
    if (upwellingStrength < 0.2) return;

    // Upwelling arrows on east side
    const upX = bounds.right - 60;
    ctx.strokeStyle = `rgba(100, 200, 255, ${upwellingStrength * 0.15})`;
    ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
        const x = upX + i * 15;
        const y1 = bounds.bottom - 30;
        const y2 = bounds.top + 30;
        const arrowLen = (y1 - y2) * upwellingStrength * 0.3;

        ctx.beginPath();
        ctx.moveTo(x, y1);
        ctx.lineTo(x, y1 - arrowLen);
        ctx.stroke();

        ctx.fillStyle = `rgba(100, 200, 255, ${upwellingStrength * 0.15})`;
        ctx.beginPath();
        ctx.moveTo(x, y1 - arrowLen - 5);
        ctx.lineTo(x - 4, y1 - arrowLen + 3);
        ctx.lineTo(x + 4, y1 - arrowLen + 3);
        ctx.closePath();
        ctx.fill();
    }

    ctx.fillStyle = `rgba(100, 200, 255, ${upwellingStrength * 0.12})`;
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Upwelling', upX + 10, bounds.top + 20);
    ctx.textAlign = 'left';
}

function drawConvection() {
    const bounds = getOceanBounds();

    // Atmospheric convection over warm pool
    const warmPoolX = currentPhase === 'elnino' ? W * 0.5 : bounds.left + 80;
    const convAlpha = 0.06 + (westSST - 25) * 0.01;

    if (convAlpha > 0) {
        // Rising air / clouds
        ctx.fillStyle = `rgba(180, 200, 230, ${convAlpha})`;
        for (let i = 0; i < 5; i++) {
            const time = Date.now() * 0.001;
            const x = warmPoolX + (i - 2) * 30 + Math.sin(time + i) * 10;
            const y = H * 0.08 + Math.cos(time * 0.5 + i * 0.7) * 5;
            ctx.beginPath();
            ctx.ellipse(x, y, 25, 12, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rising arrows
        ctx.strokeStyle = `rgba(255, 200, 100, ${convAlpha})`;
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(warmPoolX + i * 20, bounds.top - 5);
            ctx.lineTo(warmPoolX + i * 20, H * 0.15);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        ctx.fillStyle = `rgba(255, 200, 100, ${convAlpha + 0.05})`;
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Convection', warmPoolX, bounds.top - 10);
        ctx.textAlign = 'left';
    }
}

function drawSSTLegend() {
    const x = W * 0.08;
    const y = H * 0.92;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.roundRect(x, y, 200, 40, 8);
    ctx.fill();

    const grad = ctx.createLinearGradient(x + 10, 0, x + 180, 0);
    grad.addColorStop(0, '#1e3c8a');
    grad.addColorStop(0.3, '#2070b0');
    grad.addColorStop(0.6, '#d0a040');
    grad.addColorStop(1, '#e05020');
    ctx.fillStyle = grad;
    ctx.fillRect(x + 10, y + 8, 170, 10);

    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '9px sans-serif';
    ctx.fillText('15\u00b0C', x + 10, y + 32);
    ctx.textAlign = 'right';
    ctx.fillText('30\u00b0C', x + 180, y + 32);
    ctx.textAlign = 'center';
    ctx.fillText('Sea Surface Temperature', x + 95, y + 32);
    ctx.textAlign = 'left';
}

let time = 0;

function animate() {
    // Interpolate toward target phase
    const target = phaseParams[targetPhase];
    const speed = 0.02;
    tradeWindStrength += (target.winds - tradeWindStrength) * speed;
    thermoclineTilt += (target.tilt - thermoclineTilt) * speed;
    eastSST += (target.eastSST - eastSST) * speed;
    westSST += (target.westSST - westSST) * speed;
    upwellingStrength += (target.upwelling - upwellingStrength) * speed;

    // Auto cycle
    if (cycling) {
        cycleTime += 0.005;
        const phase = Math.sin(cycleTime);
        if (phase > 0.3) {
            targetPhase = 'lanina';
            currentPhase = 'lanina';
        } else if (phase < -0.3) {
            targetPhase = 'elnino';
            currentPhase = 'elnino';
        } else {
            targetPhase = 'normal';
            currentPhase = 'normal';
        }
    }

    ctx.fillStyle = 'rgba(10, 14, 26, 0.25)';
    ctx.fillRect(0, 0, W, H);

    drawBackground();
    drawOcean();
    drawTradeWinds();
    drawUpwelling();
    drawConvection();
    drawSSTLegend();

    for (const p of particles) {
        p.update();
        p.draw();
    }

    // Update info panel
    const phaseNames = { normal: 'Normal', elnino: 'El Ni\u00f1o', lanina: 'La Ni\u00f1a' };
    document.getElementById('phaseLabel').textContent = phaseNames[currentPhase];
    document.getElementById('phaseLabel').style.color =
        currentPhase === 'elnino' ? '#ff8040' :
        currentPhase === 'lanina' ? '#4080ff' : '#80c0ff';
    document.getElementById('windStr').textContent =
        tradeWindStrength > 1.2 ? 'Strong' : tradeWindStrength > 0.5 ? 'Normal' : 'Weak';
    document.getElementById('eastSST').textContent = eastSST.toFixed(1);
    document.getElementById('westSST').textContent = westSST.toFixed(1);
    document.getElementById('tiltAngle').textContent =
        thermoclineTilt > 0.3 ? 'Steep' : thermoclineTilt < -0.3 ? 'Flat' : 'Normal';
    document.getElementById('upwelling').textContent =
        upwellingStrength > 1 ? 'Strong' : upwellingStrength > 0.5 ? 'Active' : 'Suppressed';

    time += 0.016;
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
