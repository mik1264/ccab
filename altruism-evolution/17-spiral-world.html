<!--
# Altruism Evolution: Spiral World

## Goal
Arrange agents in a spiral pattern, creating unique spatial dynamics.
Beautiful Fibonacci/logarithmic spiral visualization.

## Approach
- Agents arranged in a logarithmic spiral from center
- Neighbors defined by spiral proximity
- Creates unique spatial topology
- Beautiful aesthetic different from grids

## Visual Appeal
- Golden ratio spiral
- Organic, natural pattern
- Different neighborhood dynamics
- Visually striking
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spiral World - Altruism Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: radial-gradient(circle at center, #1a1a2e, #000000);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            box-shadow: 0 0 60px rgba(255, 105, 180, 0.3);
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            min-width: 250px;
        }
        h2 {
            margin: 0 0 15px 0;
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: block;
            font-size: 0.85em;
            margin-bottom: 3px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value {
            color: #4ade80;
            font-family: monospace;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: none;
            border-radius: 6px;
            background: #4ade80;
            color: #000;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover {
            background: #22c55e;
        }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-family: monospace;
            font-size: 0.85em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h2>Spiral World</h2>

        <div class="control-group">
            <label>Cost: <span class="value" id="costVal">0.12</span></label>
            <input type="range" id="costSlider" min="0" max="100" value="12">
        </div>

        <div class="control-group">
            <label>Benefit: <span class="value" id="benefitVal">0.55</span></label>
            <input type="range" id="benefitSlider" min="0" max="200" value="55">
        </div>

        <button onclick="setup()">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span>Generation:</span>
                <span class="value" id="gen">0</span>
            </div>
            <div class="stat-row">
                <span style="color: #ff69b4;">● Altruists:</span>
                <span class="value" id="altCount">0</span>
            </div>
            <div class="stat-row">
                <span style="color: #00ff00;">● Selfish:</span>
                <span class="value" id="selfCount">0</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const SIZE = Math.min(window.innerWidth, window.innerHeight) - 100;
        canvas.width = SIZE;
        canvas.height = SIZE;

        const ALTRUIST = 1, SELFISH = 2;
        const POINT_COUNT = 800;
        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // Golden angle

        let points = [];
        let generation = 0;
        let params = {
            cost: 0.12,
            benefit: 0.55
        };

        document.getElementById('costSlider').oninput = (e) => {
            params.cost = e.target.value / 100;
            document.getElementById('costVal').textContent = (e.target.value / 100).toFixed(2);
        };
        document.getElementById('benefitSlider').oninput = (e) => {
            params.benefit = e.target.value / 100;
            document.getElementById('benefitVal').textContent = (e.target.value / 100).toFixed(2);
        };

        class Point {
            constructor(index) {
                this.index = index;

                // Golden spiral
                const angle = index * GOLDEN_ANGLE;
                const radius = 6 * Math.sqrt(index);

                this.x = SIZE / 2 + radius * Math.cos(angle);
                this.y = SIZE / 2 + radius * Math.sin(angle);

                this.type = Math.random() < 0.5 ? ALTRUIST : SELFISH;
                this.benefitOut = this.type === ALTRUIST ? 1 : 0;
                this.fitness = 1;
            }

            getNeighbors() {
                // Neighbors are close points in the spiral
                const neighbors = [];
                const neighborRange = 5;

                for (let i = -neighborRange; i <= neighborRange; i++) {
                    const ni = this.index + i;
                    if (ni >= 0 && ni < points.length && ni !== this.index) {
                        neighbors.push(points[ni]);
                    }
                }

                return neighbors;
            }

            draw() {
                const color = this.type === ALTRUIST ? '#ff69b4' : '#00ff00';
                const size = 4;

                ctx.fillStyle = color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function setup() {
            points = [];
            generation = 0;

            for (let i = 0; i < POINT_COUNT; i++) {
                points.push(new Point(i));
            }

            render();
            updateStats();
        }

        function update() {
            // Calculate altruism benefits
            points.forEach(point => {
                const neighbors = point.getNeighbors();
                const totalBenefit = point.benefitOut +
                    neighbors.reduce((sum, n) => sum + n.benefitOut, 0);
                point.altruismBenefit = params.benefit * totalBenefit / (neighbors.length + 1);
            });

            // Calculate fitness
            points.forEach(point => {
                if (point.type === SELFISH) {
                    point.fitness = 1 + point.altruismBenefit;
                } else {
                    point.fitness = (1 - params.cost) + point.altruismBenefit;
                }
                point.fitness = Math.min(2, point.fitness);
            });

            // Run lottery
            points.forEach(point => {
                const neighbors = point.getNeighbors();
                let altFitness = point.type === ALTRUIST ? point.fitness : 0;
                let selfFitness = point.type === SELFISH ? point.fitness : 0;

                neighbors.forEach(n => {
                    if (n.type === ALTRUIST) altFitness += n.fitness;
                    else if (n.type === SELFISH) selfFitness += n.fitness;
                });

                const total = altFitness + selfFitness;
                if (total > 0) {
                    point.newType = Math.random() < (altFitness / total) ? ALTRUIST : SELFISH;
                }
            });

            points.forEach(point => {
                point.type = point.newType;
                point.benefitOut = point.type === ALTRUIST ? 1 : 0;
            });

            generation++;
            render();
            updateStats();
        }

        function render() {
            // Radial gradient background
            const gradient = ctx.createRadialGradient(
                SIZE / 2, SIZE / 2, 0,
                SIZE / 2, SIZE / 2, SIZE / 2
            );
            gradient.addColorStop(0, '#0a0a0a');
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, SIZE, SIZE);

            // Draw spiral line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            points.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            // Draw points
            points.forEach(point => point.draw());
        }

        function updateStats() {
            const altCount = points.filter(p => p.type === ALTRUIST).length;
            const selfCount = points.filter(p => p.type === SELFISH).length;

            document.getElementById('gen').textContent = generation;
            document.getElementById('altCount').textContent = altCount;
            document.getElementById('selfCount').textContent = selfCount;
        }

        setup();
        setInterval(update, 100);
    </script>
</body>
</html>
