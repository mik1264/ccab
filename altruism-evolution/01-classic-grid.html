<!--
# Altruism Evolution: Classic Grid Simulation

## Goal
Create a faithful recreation of the NetLogo Altruism model using a classic grid-based visualization.
Show altruistic (pink) and selfish (green) agents competing for space through a genetic lottery system.

## Approach
- Use HTML5 Canvas with a 2D grid (50x50 patches)
- Implement the fitness calculation system: altruists pay cost but provide benefits
- Use von Neumann neighborhood (4 neighbors + self)
- Implement weighted lottery for next generation
- Add environmental factors: harshness and disease
- Interactive sliders for all parameters
- Real-time population tracking

## Key Mechanics
- Altruist fitness: (1 - cost) + (neighbor_altruists/5 * benefit)
- Selfish fitness: 1 + (neighbor_altruists/5 * benefit)
- Empty fitness: harshness value
- Lottery uses weighted random selection based on cumulative fitness
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Grid - Altruism Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        .subtitle {
            margin: 0 0 20px 0;
            opacity: 0.9;
            font-size: 0.9em;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: black;
        }
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            max-width: 350px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        .value-display {
            font-family: monospace;
            color: #4ade80;
            font-weight: bold;
        }
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #4ade80;
            color: #1e3c72;
        }
        .btn-primary:hover {
            background: #22c55e;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.85em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Classic Grid - Altruism Evolution</h1>
    <p class="subtitle">Evolutionary competition between altruistic and selfish agents</p>

    <div class="container">
        <canvas id="canvas"></canvas>

        <div class="controls">
            <h3>Parameters</h3>

            <div class="control-group">
                <label>Altruistic Probability: <span class="value-display" id="altProb">0.50</span></label>
                <input type="range" id="altruisticProbability" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="control-group">
                <label>Selfish Probability: <span class="value-display" id="selfProb">0.50</span></label>
                <input type="range" id="selfishProbability" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="control-group">
                <label>Cost of Altruism: <span class="value-display" id="costVal">0.10</span></label>
                <input type="range" id="costOfAltruism" min="0" max="1" step="0.01" value="0.1">
            </div>

            <div class="control-group">
                <label>Benefit from Altruism: <span class="value-display" id="benefitVal">0.50</span></label>
                <input type="range" id="benefitFromAltruism" min="0" max="2" step="0.01" value="0.5">
            </div>

            <div class="control-group">
                <label>Harshness: <span class="value-display" id="harshVal">0.00</span></label>
                <input type="range" id="harshness" min="0" max="1" step="0.01" value="0">
            </div>

            <div class="control-group">
                <label>Disease: <span class="value-display" id="diseaseVal">0.00</span></label>
                <input type="range" id="disease" min="0" max="1" step="0.01" value="0">
            </div>

            <button class="btn-primary" onclick="setup()">Reset</button>
            <button class="btn-secondary" onclick="togglePause()">Pause/Resume</button>

            <div class="stats">
                <div class="stat-row">
                    <span>Generation:</span>
                    <span class="value-display" id="generation">0</span>
                </div>
                <div class="stat-row">
                    <span>Altruists:</span>
                    <span class="value-display" id="altruistCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Selfish:</span>
                    <span class="value-display" id="selfishCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Empty:</span>
                    <span class="value-display" id="emptyCount">0</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff69b4;"></div>
                    <span>Altruist</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff00;"></div>
                    <span>Selfish</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #000000; border: 1px solid white;"></div>
                    <span>Empty</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 50;
        const CELL_SIZE = 10;
        canvas.width = GRID_SIZE * CELL_SIZE;
        canvas.height = GRID_SIZE * CELL_SIZE;

        // Patch types
        const EMPTY = 0;
        const ALTRUIST = 1;
        const SELFISH = 2;

        // Grid data
        let patches = [];
        let generation = 0;
        let paused = false;

        // Parameters
        let params = {
            altruisticProbability: 0.5,
            selfishProbability: 0.5,
            costOfAltruism: 0.1,
            benefitFromAltruism: 0.5,
            harshness: 0,
            disease: 0
        };

        // Connect sliders
        document.getElementById('altruisticProbability').oninput = (e) => {
            params.altruisticProbability = parseFloat(e.target.value);
            document.getElementById('altProb').textContent = e.target.value;
        };
        document.getElementById('selfishProbability').oninput = (e) => {
            params.selfishProbability = parseFloat(e.target.value);
            document.getElementById('selfProb').textContent = e.target.value;
        };
        document.getElementById('costOfAltruism').oninput = (e) => {
            params.costOfAltruism = parseFloat(e.target.value);
            document.getElementById('costVal').textContent = e.target.value;
        };
        document.getElementById('benefitFromAltruism').oninput = (e) => {
            params.benefitFromAltruism = parseFloat(e.target.value);
            document.getElementById('benefitVal').textContent = e.target.value;
        };
        document.getElementById('harshness').oninput = (e) => {
            params.harshness = parseFloat(e.target.value);
            document.getElementById('harshVal').textContent = e.target.value;
        };
        document.getElementById('disease').oninput = (e) => {
            params.disease = parseFloat(e.target.value);
            document.getElementById('diseaseVal').textContent = e.target.value;
        };

        // Initialize patch
        function createPatch() {
            return {
                type: EMPTY,
                benefitOut: 0,
                fitness: 0,
                altruismBenefit: 0,
                altFitness: 0,
                selfFitness: 0,
                harshFitness: 0,
                altWeight: 0,
                selfWeight: 0,
                harshWeight: 0
            };
        }

        // Initialize grid
        function setup() {
            patches = [];
            generation = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                patches[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = createPatch();
                    const rand = Math.random();

                    if (rand < params.altruisticProbability) {
                        patch.type = ALTRUIST;
                        patch.benefitOut = 1;
                    } else if (rand < params.altruisticProbability + params.selfishProbability) {
                        patch.type = SELFISH;
                        patch.benefitOut = 0;
                    } else {
                        patch.type = EMPTY;
                        patch.benefitOut = 0;
                    }

                    patches[y][x] = patch;
                }
            }

            render();
            updateStats();
        }

        // Get neighbors (von Neumann neighborhood)
        function getNeighbors(x, y) {
            const neighbors = [];
            if (x > 0) neighbors.push(patches[y][x-1]);
            if (x < GRID_SIZE-1) neighbors.push(patches[y][x+1]);
            if (y > 0) neighbors.push(patches[y-1][x]);
            if (y < GRID_SIZE-1) neighbors.push(patches[y+1][x]);
            return neighbors;
        }

        // Calculate altruism benefit for each patch
        function calculateAltruismBenefits() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const neighbors = getNeighbors(x, y);
                    const totalBenefit = patch.benefitOut + neighbors.reduce((sum, n) => sum + n.benefitOut, 0);
                    patch.altruismBenefit = params.benefitFromAltruism * totalBenefit / 5;
                }
            }
        }

        // Calculate fitness for each patch
        function calculateFitness() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];

                    if (patch.type === SELFISH) {
                        patch.fitness = 1 + patch.altruismBenefit;
                    } else if (patch.type === ALTRUIST) {
                        patch.fitness = (1 - params.costOfAltruism) + patch.altruismBenefit;
                    } else { // EMPTY
                        patch.fitness = params.harshness;
                    }
                }
            }
        }

        // Record neighbor fitness for lottery
        function recordNeighborFitness() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    patch.altFitness = patch.type === ALTRUIST ? patch.fitness : 0;
                    patch.selfFitness = patch.type === SELFISH ? patch.fitness : 0;
                    patch.harshFitness = patch.type === EMPTY ? patch.fitness : 0;

                    const neighbors = getNeighbors(x, y);
                    neighbors.forEach(n => {
                        if (n.type === ALTRUIST) patch.altFitness += n.fitness;
                        else if (n.type === SELFISH) patch.selfFitness += n.fitness;
                        else patch.harshFitness += n.fitness;
                    });
                }
            }
        }

        // Calculate lottery weights
        function calculateLotteryWeights() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const fitnessSum = patch.altFitness + patch.selfFitness + patch.harshFitness + params.disease;

                    if (fitnessSum > 0) {
                        patch.altWeight = patch.altFitness / fitnessSum;
                        patch.selfWeight = patch.selfFitness / fitnessSum;
                        patch.harshWeight = (patch.harshFitness + params.disease) / fitnessSum;
                    } else {
                        patch.altWeight = 0;
                        patch.selfWeight = 0;
                        patch.harshWeight = 0;
                    }
                }
            }
        }

        // Run lottery for next generation
        function runLottery() {
            const newPatches = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                newPatches[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const newPatch = createPatch();
                    const rand = Math.random();

                    if (rand < patch.altWeight) {
                        newPatch.type = ALTRUIST;
                        newPatch.benefitOut = 1;
                    } else if (rand < patch.altWeight + patch.selfWeight) {
                        newPatch.type = SELFISH;
                        newPatch.benefitOut = 0;
                    } else {
                        newPatch.type = EMPTY;
                        newPatch.benefitOut = 0;
                    }

                    newPatches[y][x] = newPatch;
                }
            }

            patches = newPatches;
        }

        // Update simulation
        function update() {
            if (paused) return;

            // Check if population exists
            let hasPopulation = false;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (patches[y][x].type !== EMPTY) {
                        hasPopulation = true;
                        break;
                    }
                }
                if (hasPopulation) break;
            }

            if (!hasPopulation) return;

            calculateAltruismBenefits();
            calculateFitness();
            recordNeighborFitness();
            calculateLotteryWeights();
            runLottery();

            generation++;
            render();
            updateStats();
        }

        // Render grid
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];

                    if (patch.type === ALTRUIST) {
                        ctx.fillStyle = '#ff69b4'; // Pink
                    } else if (patch.type === SELFISH) {
                        ctx.fillStyle = '#00ff00'; // Green
                    } else {
                        continue; // Keep black for empty
                    }

                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }

        // Update statistics
        function updateStats() {
            let altruistCount = 0;
            let selfishCount = 0;
            let emptyCount = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    if (patch.type === ALTRUIST) altruistCount++;
                    else if (patch.type === SELFISH) selfishCount++;
                    else emptyCount++;
                }
            }

            document.getElementById('generation').textContent = generation;
            document.getElementById('altruistCount').textContent = altruistCount;
            document.getElementById('selfishCount').textContent = selfishCount;
            document.getElementById('emptyCount').textContent = emptyCount;
        }

        // Toggle pause
        function togglePause() {
            paused = !paused;
        }

        // Animation loop
        function animate() {
            update();
            requestAnimationFrame(animate);
        }

        // Initialize
        setup();
        setInterval(update, 100); // Run at 10 fps for visibility
    </script>
</body>
</html>
