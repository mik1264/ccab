<!--
# Altruism Evolution: Hexagonal Grid

## Goal
Implement the altruism model on a hexagonal grid instead of square grid.
Hexagonal grids provide 6 neighbors instead of 4, creating different spatial dynamics.

## Approach
- Use hexagonal tessellation for more natural neighborhood
- Each hex has 6 neighbors (vs 4 in square grid)
- Adjust fitness calculations for 7-cell neighborhood (self + 6 neighbors)
- Beautiful geometric visualization with proper hex rendering
- Same evolutionary mechanics, different spatial structure

## Why Hexagons
- More symmetric neighborhood (all neighbors equidistant)
- Natural pattern found in nature (honeycomb, basalt columns)
- May affect clustering and spatial patterns differently
- Visually appealing and distinct from classic grid
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Grid - Altruism Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
        }
        .subtitle {
            margin: 0 0 20px 0;
            opacity: 0.9;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #000;
        }
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            width: 300px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.85em;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            color: #4ade80;
            font-family: monospace;
            font-weight: bold;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            background: #4ade80;
            color: #0f2027;
        }
        button:hover {
            background: #22c55e;
            transform: translateY(-2px);
        }
        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.85em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Hexagonal Grid - Altruism Evolution</h1>
    <p class="subtitle">Six-neighbor dynamics with hexagonal tessellation</p>

    <div class="container">
        <canvas id="canvas"></canvas>

        <div class="controls">
            <h3>Parameters</h3>

            <div class="control-group">
                <label>Altruistic %: <span class="value-display" id="altProb">40%</span></label>
                <input type="range" id="altProbSlider" min="0" max="100" value="40">
            </div>

            <div class="control-group">
                <label>Selfish %: <span class="value-display" id="selfProb">40%</span></label>
                <input type="range" id="selfProbSlider" min="0" max="100" value="40">
            </div>

            <div class="control-group">
                <label>Cost: <span class="value-display" id="costVal">0.10</span></label>
                <input type="range" id="costSlider" min="0" max="100" value="10">
            </div>

            <div class="control-group">
                <label>Benefit: <span class="value-display" id="benefitVal">0.50</span></label>
                <input type="range" id="benefitSlider" min="0" max="200" value="50">
            </div>

            <div class="control-group">
                <label>Harshness: <span class="value-display" id="harshVal">0.00</span></label>
                <input type="range" id="harshSlider" min="0" max="100" value="0">
            </div>

            <button onclick="setup()">Reset</button>

            <div class="stats">
                <div class="stat-row">
                    <span>Generation:</span>
                    <span class="value-display" id="generation">0</span>
                </div>
                <div class="stat-row">
                    <span style="color: #ff69b4;">⬢ Altruists:</span>
                    <span class="value-display" id="altruistCount">0</span>
                </div>
                <div class="stat-row">
                    <span style="color: #00ff00;">⬢ Selfish:</span>
                    <span class="value-display" id="selfishCount">0</span>
                </div>
                <div class="stat-row">
                    <span style="color: #666;">⬢ Empty:</span>
                    <span class="value-display" id="emptyCount">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 800;
        canvas.height = 800;

        const EMPTY = 0, ALTRUIST = 1, SELFISH = 2;
        const HEX_RADIUS = 10;
        const COLS = 45;
        const ROWS = 50;

        let hexes = [];
        let generation = 0;

        let params = {
            altProb: 0.4,
            selfProb: 0.4,
            cost: 0.1,
            benefit: 0.5,
            harshness: 0
        };

        // Slider connections
        document.getElementById('altProbSlider').oninput = (e) => {
            params.altProb = e.target.value / 100;
            document.getElementById('altProb').textContent = e.target.value + '%';
        };
        document.getElementById('selfProbSlider').oninput = (e) => {
            params.selfProb = e.target.value / 100;
            document.getElementById('selfProb').textContent = e.target.value + '%';
        };
        document.getElementById('costSlider').oninput = (e) => {
            params.cost = e.target.value / 100;
            document.getElementById('costVal').textContent = (e.target.value / 100).toFixed(2);
        };
        document.getElementById('benefitSlider').oninput = (e) => {
            params.benefit = e.target.value / 100;
            document.getElementById('benefitVal').textContent = (e.target.value / 100).toFixed(2);
        };
        document.getElementById('harshSlider').oninput = (e) => {
            params.harshness = e.target.value / 100;
            document.getElementById('harshVal').textContent = (e.target.value / 100).toFixed(2);
        };

        class Hex {
            constructor(q, r) {
                this.q = q;
                this.r = r;
                this.type = EMPTY;
                this.benefitOut = 0;
                this.fitness = 0;
                this.altruismBenefit = 0;
                this.altFitness = 0;
                this.selfFitness = 0;
                this.harshFitness = 0;
                this.altWeight = 0;
                this.selfWeight = 0;
                this.harshWeight = 0;
            }

            toPixel() {
                const hexWidth = HEX_RADIUS * Math.sqrt(3);
                const hexHeight = HEX_RADIUS * 2;
                const x = hexWidth * this.q + (this.r % 2) * (hexWidth / 2) + HEX_RADIUS;
                const y = hexHeight * 0.75 * this.r + HEX_RADIUS;
                return { x, y };
            }

            getNeighbors() {
                // Offset coordinates - even/odd row neighbors differ
                const evenRowDirs = [[+1, 0], [0, -1], [-1, -1], [-1, 0], [-1, +1], [0, +1]];
                const oddRowDirs = [[+1, 0], [+1, -1], [0, -1], [-1, 0], [0, +1], [+1, +1]];
                const directions = (this.r % 2 === 0) ? evenRowDirs : oddRowDirs;

                return directions
                    .map(([dq, dr]) => getHex(this.q + dq, this.r + dr))
                    .filter(h => h !== null);
            }
        }

        function getHex(q, r) {
            return hexes.find(h => h.q === q && h.r === r) || null;
        }

        function setup() {
            hexes = [];
            generation = 0;

            // Create rectangular hexagonal grid using offset coordinates
            for (let r = 0; r < ROWS; r++) {
                for (let q = 0; q < COLS; q++) {
                    const hex = new Hex(q, r);
                    const rand = Math.random();

                    if (rand < params.altProb) {
                        hex.type = ALTRUIST;
                        hex.benefitOut = 1;
                    } else if (rand < params.altProb + params.selfProb) {
                        hex.type = SELFISH;
                    }

                    hexes.push(hex);
                }
            }

            render();
            updateStats();
        }

        function update() {
            // Calculate altruism benefits (7-cell neighborhood)
            hexes.forEach(hex => {
                const neighbors = hex.getNeighbors();
                const totalBenefit = hex.benefitOut + neighbors.reduce((sum, n) => sum + n.benefitOut, 0);
                hex.altruismBenefit = params.benefit * totalBenefit / 7; // 6 neighbors + self
            });

            // Calculate fitness
            hexes.forEach(hex => {
                if (hex.type === SELFISH) {
                    hex.fitness = 1 + hex.altruismBenefit;
                } else if (hex.type === ALTRUIST) {
                    hex.fitness = (1 - params.cost) + hex.altruismBenefit;
                } else {
                    hex.fitness = params.harshness;
                }
            });

            // Record neighbor fitness
            hexes.forEach(hex => {
                hex.altFitness = hex.type === ALTRUIST ? hex.fitness : 0;
                hex.selfFitness = hex.type === SELFISH ? hex.fitness : 0;
                hex.harshFitness = hex.type === EMPTY ? hex.fitness : 0;

                const neighbors = hex.getNeighbors();
                neighbors.forEach(n => {
                    if (n.type === ALTRUIST) hex.altFitness += n.fitness;
                    else if (n.type === SELFISH) hex.selfFitness += n.fitness;
                    else hex.harshFitness += n.fitness;
                });
            });

            // Calculate lottery weights
            hexes.forEach(hex => {
                const fitnessSum = hex.altFitness + hex.selfFitness + hex.harshFitness;
                if (fitnessSum > 0) {
                    hex.altWeight = hex.altFitness / fitnessSum;
                    hex.selfWeight = hex.selfFitness / fitnessSum;
                    hex.harshWeight = hex.harshFitness / fitnessSum;
                }
            });

            // Run lottery
            const newTypes = hexes.map(hex => {
                const rand = Math.random();
                if (rand < hex.altWeight) return ALTRUIST;
                else if (rand < hex.altWeight + hex.selfWeight) return SELFISH;
                else return EMPTY;
            });

            hexes.forEach((hex, i) => {
                hex.type = newTypes[i];
                hex.benefitOut = (hex.type === ALTRUIST) ? 1 : 0;
            });

            generation++;
            render();
            updateStats();
        }

        function drawHexagon(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i - Math.PI / 6;
                const hx = x + radius * Math.cos(angle);
                const hy = y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.fill();

            // Outline
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            hexes.forEach(hex => {
                const { x, y } = hex.toPixel();
                let color;

                if (hex.type === ALTRUIST) {
                    color = '#ff69b4';
                } else if (hex.type === SELFISH) {
                    color = '#00ff00';
                } else {
                    color = '#111';
                }

                drawHexagon(x, y, HEX_RADIUS - 1, color);
            });
        }

        function updateStats() {
            let altruistCount = 0, selfishCount = 0, emptyCount = 0;

            hexes.forEach(hex => {
                if (hex.type === ALTRUIST) altruistCount++;
                else if (hex.type === SELFISH) selfishCount++;
                else emptyCount++;
            });

            document.getElementById('generation').textContent = generation;
            document.getElementById('altruistCount').textContent = altruistCount;
            document.getElementById('selfishCount').textContent = selfishCount;
            document.getElementById('emptyCount').textContent = emptyCount;
        }

        setup();
        setInterval(update, 100);
    </script>
</body>
</html>
