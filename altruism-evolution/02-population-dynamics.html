<!--
# Altruism Evolution: Population Dynamics Chart

## Goal
Visualize the population dynamics over time using real-time line charts.
Show how altruistic and selfish populations evolve and compete across generations.

## Approach
- Split screen: left side shows grid, right side shows population chart
- Track population counts over last 200 generations
- Use different colors for each population type
- Add percentage display
- Show dominance shifts and equilibrium points
- Update chart in real-time as simulation runs

## Insights to Reveal
- Population oscillations and stability
- Extinction events
- Impact of environmental parameters on population dynamics
- Competitive exclusion vs. coexistence
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Population Dynamics - Altruism Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
        }
        .subtitle {
            margin: 0 0 20px 0;
            opacity: 0.9;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        #gridCanvas {
            background: black;
        }
        #chartCanvas {
            background: rgba(0, 0, 0, 0.5);
        }
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            width: 300px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.85em;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            color: #4ade80;
            font-family: monospace;
            font-weight: bold;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #4ade80;
            color: #1e3c72;
        }
        .btn-primary:hover {
            background: #22c55e;
        }
        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.85em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Population Dynamics - Altruism Evolution</h1>
    <p class="subtitle">Real-time population tracking and evolutionary dynamics</p>

    <div class="container">
        <div>
            <canvas id="gridCanvas"></canvas>
            <canvas id="chartCanvas"></canvas>
        </div>

        <div class="controls">
            <h3>Parameters</h3>

            <div class="control-group">
                <label>Initial Altruists: <span class="value-display" id="altProb">50%</span></label>
                <input type="range" id="altruisticProbability" min="0" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Initial Selfish: <span class="value-display" id="selfProb">50%</span></label>
                <input type="range" id="selfishProbability" min="0" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Cost: <span class="value-display" id="costVal">0.10</span></label>
                <input type="range" id="cost" min="0" max="100" value="10">
            </div>

            <div class="control-group">
                <label>Benefit: <span class="value-display" id="benefitVal">0.50</span></label>
                <input type="range" id="benefit" min="0" max="200" value="50">
            </div>

            <div class="control-group">
                <label>Harshness: <span class="value-display" id="harshVal">0.00</span></label>
                <input type="range" id="harshness" min="0" max="100" value="0">
            </div>

            <div class="control-group">
                <label>Disease: <span class="value-display" id="diseaseVal">0.00</span></label>
                <input type="range" id="disease" min="0" max="100" value="0">
            </div>

            <button class="btn-primary" onclick="setup()">Reset</button>

            <div class="stats">
                <div class="stat-row">
                    <span>Generation:</span>
                    <span class="value-display" id="generation">0</span>
                </div>
                <div class="stat-row">
                    <span style="color: #ff69b4;">■ Altruists:</span>
                    <span class="value-display" id="altruistCount">0 (0%)</span>
                </div>
                <div class="stat-row">
                    <span style="color: #00ff00;">■ Selfish:</span>
                    <span class="value-display" id="selfishCount">0 (0%)</span>
                </div>
                <div class="stat-row">
                    <span style="color: #666;">■ Empty:</span>
                    <span class="value-display" id="emptyCount">0 (0%)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        const GRID_SIZE = 40;
        const CELL_SIZE = 10;
        gridCanvas.width = GRID_SIZE * CELL_SIZE;
        gridCanvas.height = GRID_SIZE * CELL_SIZE;
        chartCanvas.width = GRID_SIZE * CELL_SIZE;
        chartCanvas.height = 300;

        const EMPTY = 0, ALTRUIST = 1, SELFISH = 2;
        const MAX_HISTORY = 200;

        let patches = [];
        let generation = 0;
        let history = {
            altruist: [],
            selfish: [],
            empty: []
        };

        let params = {
            altruisticProbability: 0.5,
            selfishProbability: 0.5,
            costOfAltruism: 0.1,
            benefitFromAltruism: 0.5,
            harshness: 0,
            disease: 0
        };

        // Connect sliders
        document.getElementById('altruisticProbability').oninput = (e) => {
            params.altruisticProbability = e.target.value / 100;
            document.getElementById('altProb').textContent = e.target.value + '%';
        };
        document.getElementById('selfishProbability').oninput = (e) => {
            params.selfishProbability = e.target.value / 100;
            document.getElementById('selfProb').textContent = e.target.value + '%';
        };
        document.getElementById('cost').oninput = (e) => {
            params.costOfAltruism = e.target.value / 100;
            document.getElementById('costVal').textContent = (e.target.value / 100).toFixed(2);
        };
        document.getElementById('benefit').oninput = (e) => {
            params.benefitFromAltruism = e.target.value / 100;
            document.getElementById('benefitVal').textContent = (e.target.value / 100).toFixed(2);
        };
        document.getElementById('harshness').oninput = (e) => {
            params.harshness = e.target.value / 100;
            document.getElementById('harshVal').textContent = (e.target.value / 100).toFixed(2);
        };
        document.getElementById('disease').oninput = (e) => {
            params.disease = e.target.value / 100;
            document.getElementById('diseaseVal').textContent = (e.target.value / 100).toFixed(2);
        };

        function createPatch() {
            return { type: EMPTY, benefitOut: 0, fitness: 0, altruismBenefit: 0,
                    altFitness: 0, selfFitness: 0, harshFitness: 0,
                    altWeight: 0, selfWeight: 0, harshWeight: 0 };
        }

        function setup() {
            patches = [];
            generation = 0;
            history = { altruist: [], selfish: [], empty: [] };

            for (let y = 0; y < GRID_SIZE; y++) {
                patches[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = createPatch();
                    const rand = Math.random();

                    if (rand < params.altruisticProbability) {
                        patch.type = ALTRUIST;
                        patch.benefitOut = 1;
                    } else if (rand < params.altruisticProbability + params.selfishProbability) {
                        patch.type = SELFISH;
                    }

                    patches[y][x] = patch;
                }
            }

            render();
            updateStats();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            if (x > 0) neighbors.push(patches[y][x-1]);
            if (x < GRID_SIZE-1) neighbors.push(patches[y][x+1]);
            if (y > 0) neighbors.push(patches[y-1][x]);
            if (y < GRID_SIZE-1) neighbors.push(patches[y+1][x]);
            return neighbors;
        }

        function update() {
            // Calculate altruism benefits
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const neighbors = getNeighbors(x, y);
                    const totalBenefit = patch.benefitOut + neighbors.reduce((sum, n) => sum + n.benefitOut, 0);
                    patch.altruismBenefit = params.benefitFromAltruism * totalBenefit / 5;
                }
            }

            // Calculate fitness
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    if (patch.type === SELFISH) {
                        patch.fitness = 1 + patch.altruismBenefit;
                    } else if (patch.type === ALTRUIST) {
                        patch.fitness = (1 - params.costOfAltruism) + patch.altruismBenefit;
                    } else {
                        patch.fitness = params.harshness;
                    }
                }
            }

            // Record neighbor fitness
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    patch.altFitness = patch.type === ALTRUIST ? patch.fitness : 0;
                    patch.selfFitness = patch.type === SELFISH ? patch.fitness : 0;
                    patch.harshFitness = patch.type === EMPTY ? patch.fitness : 0;

                    const neighbors = getNeighbors(x, y);
                    neighbors.forEach(n => {
                        if (n.type === ALTRUIST) patch.altFitness += n.fitness;
                        else if (n.type === SELFISH) patch.selfFitness += n.fitness;
                        else patch.harshFitness += n.fitness;
                    });
                }
            }

            // Calculate lottery weights
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const fitnessSum = patch.altFitness + patch.selfFitness + patch.harshFitness + params.disease;

                    if (fitnessSum > 0) {
                        patch.altWeight = patch.altFitness / fitnessSum;
                        patch.selfWeight = patch.selfFitness / fitnessSum;
                        patch.harshWeight = (patch.harshFitness + params.disease) / fitnessSum;
                    }
                }
            }

            // Run lottery
            const newPatches = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                newPatches[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const newPatch = createPatch();
                    const rand = Math.random();

                    if (rand < patch.altWeight) {
                        newPatch.type = ALTRUIST;
                        newPatch.benefitOut = 1;
                    } else if (rand < patch.altWeight + patch.selfWeight) {
                        newPatch.type = SELFISH;
                    }

                    newPatches[y][x] = newPatch;
                }
            }

            patches = newPatches;
            generation++;
            render();
            updateStats();
        }

        function render() {
            // Render grid
            gridCtx.fillStyle = '#000';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    if (patch.type === ALTRUIST) {
                        gridCtx.fillStyle = '#ff69b4';
                    } else if (patch.type === SELFISH) {
                        gridCtx.fillStyle = '#00ff00';
                    } else {
                        continue;
                    }
                    gridCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // Render chart
            renderChart();
        }

        function renderChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;
            const padding = 40;

            chartCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            chartCtx.fillRect(0, 0, w, h);

            if (history.altruist.length < 2) return;

            const maxPop = GRID_SIZE * GRID_SIZE;
            const dataPoints = Math.min(history.altruist.length, MAX_HISTORY);
            const startIdx = Math.max(0, history.altruist.length - MAX_HISTORY);

            // Draw grid
            chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            chartCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (h - padding * 2) * i / 5;
                chartCtx.beginPath();
                chartCtx.moveTo(padding, y);
                chartCtx.lineTo(w - padding, y);
                chartCtx.stroke();

                chartCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                chartCtx.font = '10px monospace';
                chartCtx.fillText(Math.round(maxPop * (1 - i/5)), 5, y + 4);
            }

            // Draw lines
            function drawLine(data, color) {
                chartCtx.strokeStyle = color;
                chartCtx.lineWidth = 2;
                chartCtx.beginPath();

                for (let i = 0; i < dataPoints; i++) {
                    const x = padding + (w - padding * 2) * i / (dataPoints - 1);
                    const y = h - padding - (h - padding * 2) * data[startIdx + i] / maxPop;

                    if (i === 0) chartCtx.moveTo(x, y);
                    else chartCtx.lineTo(x, y);
                }

                chartCtx.stroke();
            }

            drawLine(history.altruist, '#ff69b4');
            drawLine(history.selfish, '#00ff00');
            drawLine(history.empty, '#666666');

            // Labels
            chartCtx.fillStyle = 'white';
            chartCtx.font = '12px monospace';
            chartCtx.fillText('Population Over Time', w / 2 - 80, 20);
        }

        function updateStats() {
            let altruistCount = 0;
            let selfishCount = 0;
            let emptyCount = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    if (patch.type === ALTRUIST) altruistCount++;
                    else if (patch.type === SELFISH) selfishCount++;
                    else emptyCount++;
                }
            }

            const total = GRID_SIZE * GRID_SIZE;
            history.altruist.push(altruistCount);
            history.selfish.push(selfishCount);
            history.empty.push(emptyCount);

            document.getElementById('generation').textContent = generation;
            document.getElementById('altruistCount').textContent =
                `${altruistCount} (${Math.round(100 * altruistCount / total)}%)`;
            document.getElementById('selfishCount').textContent =
                `${selfishCount} (${Math.round(100 * selfishCount / total)}%)`;
            document.getElementById('emptyCount').textContent =
                `${emptyCount} (${Math.round(100 * emptyCount / total)}%)`;
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = setup;
        window.init = setup;

        let lastUpdate = 0;
        function animateLoop(time) {
            if (time - lastUpdate > 100) { update(); lastUpdate = time; }
            requestAnimationFrame(animateLoop);
        }

        setup();
        requestAnimationFrame(animateLoop);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
