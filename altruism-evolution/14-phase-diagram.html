<!--
# Altruism Evolution: Phase Diagram

## Goal
Create a 2D phase diagram showing parameter space (cost vs benefit).
Each cell shows long-term outcome: altruist dominance, selfish dominance, or coexistence.

## Approach
- X-axis: benefit parameter (0 to 2)
- Y-axis: cost parameter (0 to 1)
- Run simulation for each parameter combination
- Color code by outcome after N generations
- Shows regions where altruism can survive

## Scientific Value
- Comprehensive parameter exploration
- Identify critical thresholds
- Show phase transitions
- Classic evolutionary biology visualization
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase Diagram - Altruism Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
        }
        .subtitle {
            margin: 0 0 20px 0;
            opacity: 0.9;
            text-align: center;
        }
        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            max-width: 700px;
            width: 100%;
            text-align: center;
        }
        button {
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            background: #4ade80;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            font-size: 1.1em;
            margin: 0 10px;
        }
        button:hover {
            background: #22c55e;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .progress {
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .axis-labels {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>Phase Diagram - Altruism Evolution</h1>
    <p class="subtitle">Parameter space exploration: Cost vs Benefit</p>

    <canvas id="canvas"></canvas>

    <div class="axis-labels">
        <div><strong>X-axis:</strong> Benefit from Altruism (0 to 2.0)</div>
        <div><strong>Y-axis:</strong> Cost of Altruism (0 to 1.0)</div>
    </div>

    <div class="controls">
        <button id="computeBtn" onclick="computePhaseDiagram()">Compute Phase Diagram</button>
        <button onclick="reset()">Reset</button>

        <div class="progress" id="progress"></div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff69b4;"></div>
                <span>Altruist Dominance</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff00;"></div>
                <span>Selfish Dominance</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffff00;"></div>
                <span>Coexistence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #666;"></div>
                <span>Extinction</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const RESOLUTION = 80;
        const CELL_SIZE = 8;
        canvas.width = RESOLUTION * CELL_SIZE;
        canvas.height = RESOLUTION * CELL_SIZE;

        const SIM_GRID_SIZE = 20;
        const SIM_GENERATIONS = 100;
        const ALTRUIST = 1, SELFISH = 2, EMPTY = 0;

        let phaseDiagram = [];
        let computing = false;

        function reset() {
            phaseDiagram = [];
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            document.getElementById('progress').textContent = '';
        }

        async function computePhaseDiagram() {
            if (computing) return;

            computing = true;
            document.getElementById('computeBtn').disabled = true;
            phaseDiagram = [];

            for (let y = 0; y < RESOLUTION; y++) {
                phaseDiagram[y] = [];

                for (let x = 0; x < RESOLUTION; x++) {
                    const benefit = (x / RESOLUTION) * 2.0;
                    const cost = 1.0 - (y / RESOLUTION);

                    const outcome = runSimulation(cost, benefit);
                    phaseDiagram[y][x] = outcome;

                    // Draw as we compute
                    let color;
                    if (outcome === 'altruist') color = '#ff69b4';
                    else if (outcome === 'selfish') color = '#00ff00';
                    else if (outcome === 'coexist') color = '#ffff00';
                    else color = '#666666';

                    ctx.fillStyle = color;
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }

                // Update progress
                const progress = Math.round(((y + 1) / RESOLUTION) * 100);
                document.getElementById('progress').textContent =
                    `Computing... ${progress}% (${y + 1}/${RESOLUTION} rows)`;

                // Yield to browser
                if (y % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            document.getElementById('progress').textContent = 'Complete!';
            document.getElementById('computeBtn').disabled = false;
            computing = false;
        }

        function runSimulation(cost, benefit) {
            // Initialize small grid
            let grid = [];
            for (let y = 0; y < SIM_GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < SIM_GRID_SIZE; x++) {
                    const rand = Math.random();
                    grid[y][x] = {
                        type: rand < 0.5 ? ALTRUIST : SELFISH,
                        benefitOut: rand < 0.5 ? 1 : 0,
                        fitness: 0
                    };
                }
            }

            // Run evolution
            for (let gen = 0; gen < SIM_GENERATIONS; gen++) {
                // Calculate altruism benefits
                for (let y = 0; y < SIM_GRID_SIZE; y++) {
                    for (let x = 0; x < SIM_GRID_SIZE; x++) {
                        const cell = grid[y][x];
                        const neighbors = getNeighbors(grid, x, y);
                        const totalBenefit = cell.benefitOut +
                            neighbors.reduce((sum, n) => sum + n.benefitOut, 0);
                        cell.altruismBenefit = benefit * totalBenefit / 5;
                    }
                }

                // Calculate fitness
                for (let y = 0; y < SIM_GRID_SIZE; y++) {
                    for (let x = 0; x < SIM_GRID_SIZE; x++) {
                        const cell = grid[y][x];
                        if (cell.type === SELFISH) {
                            cell.fitness = 1 + cell.altruismBenefit;
                        } else if (cell.type === ALTRUIST) {
                            cell.fitness = (1 - cost) + cell.altruismBenefit;
                        }
                    }
                }

                // Run lottery
                for (let y = 0; y < SIM_GRID_SIZE; y++) {
                    for (let x = 0; x < SIM_GRID_SIZE; x++) {
                        const cell = grid[y][x];
                        const neighbors = getNeighbors(grid, x, y);

                        let altFitness = cell.type === ALTRUIST ? cell.fitness : 0;
                        let selfFitness = cell.type === SELFISH ? cell.fitness : 0;

                        neighbors.forEach(n => {
                            if (n.type === ALTRUIST) altFitness += n.fitness;
                            else if (n.type === SELFISH) selfFitness += n.fitness;
                        });

                        const total = altFitness + selfFitness;
                        if (total > 0) {
                            cell.newType = Math.random() < (altFitness / total) ? ALTRUIST : SELFISH;
                        } else {
                            cell.newType = EMPTY;
                        }
                    }
                }

                for (let y = 0; y < SIM_GRID_SIZE; y++) {
                    for (let x = 0; x < SIM_GRID_SIZE; x++) {
                        grid[y][x].type = grid[y][x].newType;
                        grid[y][x].benefitOut = grid[y][x].type === ALTRUIST ? 1 : 0;
                    }
                }
            }

            // Classify outcome
            let altCount = 0, selfCount = 0;
            for (let y = 0; y < SIM_GRID_SIZE; y++) {
                for (let x = 0; x < SIM_GRID_SIZE; x++) {
                    if (grid[y][x].type === ALTRUIST) altCount++;
                    else if (grid[y][x].type === SELFISH) selfCount++;
                }
            }

            const total = altCount + selfCount;
            if (total === 0) return 'extinct';

            const altRatio = altCount / total;
            if (altRatio > 0.7) return 'altruist';
            else if (altRatio < 0.3) return 'selfish';
            else return 'coexist';
        }

        function getNeighbors(grid, x, y) {
            const neighbors = [];
            if (x > 0) neighbors.push(grid[y][x-1]);
            if (x < SIM_GRID_SIZE-1) neighbors.push(grid[y][x+1]);
            if (y > 0) neighbors.push(grid[y-1][x]);
            if (y < SIM_GRID_SIZE-1) neighbors.push(grid[y+1][x]);
            return neighbors;
        }

        // Initialize
        reset();

        // Draw axes labels
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.font = '12px monospace';

        // X-axis labels
        for (let i = 0; i <= 4; i++) {
            const x = (i / 4) * canvas.width;
            const benefit = (i / 4) * 2.0;
            ctx.fillText(benefit.toFixed(1), x - 10, canvas.height - 5);
        }

        // Y-axis labels
        for (let i = 0; i <= 4; i++) {
            const y = (i / 4) * canvas.height;
            const cost = 1.0 - (i / 4);
            ctx.fillText(cost.toFixed(1), 5, y + 10);
        }
    </script>
</body>
</html>
