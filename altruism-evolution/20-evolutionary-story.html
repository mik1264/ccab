<!--
# Altruism Evolution: Evolutionary Story Mode

## Goal
Present the altruism model as an interactive story with narration and guided scenarios.
Educational narrative experience walking through key concepts.

## Approach
- Sequential chapters/scenes
- Each scene demonstrates a key concept
- Narrative text explains what's happening
- Auto-advancing or user-paced
- Culminates in full interactive mode

## Educational Narrative
1. Introduction: Two types of agents
2. The Cost: Why altruism is expensive
3. The Benefit: How altruism helps neighbors
4. The Paradox: Selfish should win
5. The Solution: Clustering and harshness
6. Your Turn: Interactive exploration

## Value
- Accessible to beginners
- Tells the biological story
- Guided learning experience
- Memorable narrative arc
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Story - Altruism</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 900px;
            padding: 40px;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 30px;
        }
        .story-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #000;
        }
        .narrative {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        .chapter-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #4ade80;
        }
        .narrative-text {
            line-height: 1.7;
            margin-bottom: 20px;
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        button {
            padding: 12px 30px;
            margin: 0 10px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #4ade80;
            color: #000;
        }
        .btn-primary:hover {
            background: #22c55e;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .progress {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
        }
        .progress-dot.active {
            background: #4ade80;
            transform: scale(1.3);
        }
        .progress-dot.complete {
            background: rgba(74, 222, 128, 0.5);
        }
        .stats {
            font-family: monospace;
            font-size: 0.9em;
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>The Evolution of Altruism</h1>
        <p class="subtitle">An Interactive Story</p>

        <div class="progress" id="progress"></div>

        <div class="story-container">
            <canvas id="canvas"></canvas>

            <div class="narrative">
                <div class="chapter-title" id="chapterTitle">Chapter 1: Two Types</div>
                <div class="narrative-text" id="narrativeText"></div>
                <div class="stats" id="stats"></div>
            </div>
        </div>

        <div class="controls">
            <button class="btn-secondary" onclick="prevChapter()" id="prevBtn">← Previous</button>
            <button class="btn-primary" onclick="nextChapter()" id="nextBtn">Next →</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 40;
        const CELL_SIZE = 10;
        canvas.width = GRID_SIZE * CELL_SIZE;
        canvas.height = GRID_SIZE * CELL_SIZE;

        const ALTRUIST = 1, SELFISH = 2, EMPTY = 0;

        let patches = [];
        let generation = 0;
        let currentChapter = 0;

        const chapters = [
            {
                title: "Chapter 1: Two Types",
                text: "In our world, there are two types of organisms: <strong style='color: #ff69b4;'>Altruists</strong> (pink) who help their neighbors, and <strong style='color: #00ff00;'>Selfish</strong> (green) who keep everything for themselves. Let's watch them compete for space...",
                setup: () => setupMixed(),
                params: { cost: 0.1, benefit: 0.5, harshness: 0 }
            },
            {
                title: "Chapter 2: The Cost of Kindness",
                text: "Altruists pay a <strong>cost</strong> to help others. This cost makes them weaker in the evolutionary race. Watch as selfish organisms (green) begin to dominate because they don't pay this cost.",
                setup: () => setupMixed(),
                params: { cost: 0.3, benefit: 0.3, harshness: 0 }
            },
            {
                title: "Chapter 3: The Benefit",
                text: "But altruists provide <strong>benefits</strong> to their neighbors! Everyone near an altruist gets stronger. When benefits are high enough, altruists can create neighborhoods where everyone thrives.",
                setup: () => setupMixed(),
                params: { cost: 0.1, benefit: 0.8, harshness: 0 }
            },
            {
                title: "Chapter 4: The Paradox",
                text: "Here's the paradox: Even though altruists help their neighbors, <strong>selfish organisms can exploit this</strong>. They live next to altruists, get the benefits, but don't pay the cost. This is why altruism is puzzling!",
                setup: () => setupMixed(),
                params: { cost: 0.2, benefit: 0.5, harshness: 0 }
            },
            {
                title: "Chapter 5: Harsh Environments",
                text: "But there's a solution! In <strong>harsh environments</strong>, empty space resists colonization. Selfish organisms spread thinly and die out. Altruists form tight clusters that support each other and survive!",
                setup: () => setupMixed(),
                params: { cost: 0.15, benefit: 0.6, harshness: 0.4 }
            },
            {
                title: "Chapter 6: Your Turn!",
                text: "Now you understand the evolution of altruism! <strong>Altruism survives when:</strong><br>1. Benefits are high<br>2. Environments are harsh<br>3. Altruists cluster together<br><br>This is why cooperation evolved in nature!",
                setup: () => setupMixed(),
                params: { cost: 0.1, benefit: 0.6, harshness: 0.2 }
            }
        ];

        function setupMixed() {
            patches = [];
            generation = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                patches[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const rand = Math.random();
                    patches[y][x] = {
                        type: rand < 0.5 ? ALTRUIST : SELFISH,
                        benefitOut: rand < 0.5 ? 1 : 0,
                        fitness: 0
                    };
                }
            }
        }

        function loadChapter(index) {
            currentChapter = index;
            const chapter = chapters[index];

            document.getElementById('chapterTitle').textContent = chapter.title;
            document.getElementById('narrativeText').innerHTML = chapter.text;

            chapter.setup();
            updateProgress();
            updateButtons();
            render();
        }

        function updateProgress() {
            const container = document.getElementById('progress');
            container.innerHTML = '';

            chapters.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                if (i === currentChapter) dot.classList.add('active');
                else if (i < currentChapter) dot.classList.add('complete');
                container.appendChild(dot);
            });
        }

        function updateButtons() {
            document.getElementById('prevBtn').disabled = currentChapter === 0;
            document.getElementById('nextBtn').textContent =
                currentChapter === chapters.length - 1 ? 'Restart' : 'Next →';
        }

        function nextChapter() {
            if (currentChapter < chapters.length - 1) {
                loadChapter(currentChapter + 1);
            } else {
                loadChapter(0);
            }
        }

        function prevChapter() {
            if (currentChapter > 0) {
                loadChapter(currentChapter - 1);
            }
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            if (x > 0) neighbors.push(patches[y][x-1]);
            if (x < GRID_SIZE-1) neighbors.push(patches[y][x+1]);
            if (y > 0) neighbors.push(patches[y-1][x]);
            if (y < GRID_SIZE-1) neighbors.push(patches[y+1][x]);
            return neighbors;
        }

        function update() {
            const chapter = chapters[currentChapter];
            const params = chapter.params;

            // Calculate altruism benefits
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const neighbors = getNeighbors(x, y);
                    const totalBenefit = patch.benefitOut +
                        neighbors.reduce((sum, n) => sum + n.benefitOut, 0);
                    patch.altruismBenefit = params.benefit * totalBenefit / 5;
                }
            }

            // Calculate fitness
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    if (patch.type === SELFISH) {
                        patch.fitness = 1 + patch.altruismBenefit;
                    } else if (patch.type === ALTRUIST) {
                        patch.fitness = (1 - params.cost) + patch.altruismBenefit;
                    } else {
                        patch.fitness = params.harshness;
                    }
                }
            }

            // Run lottery
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];
                    const neighbors = getNeighbors(x, y);

                    let altFitness = patch.type === ALTRUIST ? patch.fitness : 0;
                    let selfFitness = patch.type === SELFISH ? patch.fitness : 0;
                    let harshFitness = patch.type === EMPTY ? patch.fitness : 0;

                    neighbors.forEach(n => {
                        if (n.type === ALTRUIST) altFitness += n.fitness;
                        else if (n.type === SELFISH) selfFitness += n.fitness;
                        else harshFitness += n.fitness;
                    });

                    const total = altFitness + selfFitness + harshFitness;
                    if (total > 0) {
                        const rand = Math.random();
                        if (rand < altFitness / total) {
                            patch.newType = ALTRUIST;
                        } else if (rand < (altFitness + selfFitness) / total) {
                            patch.newType = SELFISH;
                        } else {
                            patch.newType = EMPTY;
                        }
                    }
                }
            }

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    patches[y][x].type = patches[y][x].newType;
                    patches[y][x].benefitOut = patches[y][x].type === ALTRUIST ? 1 : 0;
                }
            }

            generation++;
            render();
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let altCount = 0, selfCount = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const patch = patches[y][x];

                    if (patch.type === ALTRUIST) {
                        ctx.fillStyle = '#ff69b4';
                        altCount++;
                    } else if (patch.type === SELFISH) {
                        ctx.fillStyle = '#00ff00';
                        selfCount++;
                    } else {
                        continue;
                    }

                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            const total = altCount + selfCount;
            const altPct = total > 0 ? Math.round((altCount / total) * 100) : 0;

            const chapter = chapters[currentChapter];
            document.getElementById('stats').innerHTML = `
                <strong>Generation:</strong> ${generation}<br>
                <strong>Altruists:</strong> ${altPct}%<br>
                <strong>Selfish:</strong> ${100 - altPct}%<br>
                <strong>Cost:</strong> ${chapter.params.cost.toFixed(2)} |
                <strong>Benefit:</strong> ${chapter.params.benefit.toFixed(2)} |
                <strong>Harshness:</strong> ${chapter.params.harshness.toFixed(2)}
            `;
        }

        // Expose for enhance.js
        window.reset = function() { loadChapter(0); };

        loadChapter(0);
        setInterval(update, 120);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
