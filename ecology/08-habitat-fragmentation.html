<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Habitat Fragmentation | Ecology</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a2e1a 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 100, 0.3);
        }
        h1 { color: #64c896; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #64c896; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c896; color: #1a2e1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88d8b0; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64c896; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c896; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 10px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 20px; height: 20px; border-radius: 3px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Ecology</a>

    <div class="controls">
        <h1>Habitat Fragmentation</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Biodiversity and connectivity</p>

        <div class="control-group">
            <label>Initial Habitat Coverage: <span class="value" id="coverageValue">70%</span></label>
            <input type="range" id="coverage" min="20" max="95" value="70">
        </div>

        <div class="control-group">
            <label>Fragment Count: <span class="value" id="fragmentsValue">5</span></label>
            <input type="range" id="fragments" min="1" max="20" value="5">
        </div>

        <div class="control-group">
            <label>Species Count: <span class="value" id="speciesValue">50</span></label>
            <input type="range" id="speciesCount" min="10" max="100" step="5" value="50">
        </div>

        <div class="control-group">
            <label>Fragmentation Type:</label>
            <select id="fragType">
                <option value="random">Random Clearing</option>
                <option value="road">Road Network</option>
                <option value="agriculture">Agricultural Grid</option>
            </select>
        </div>

        <button id="generateBtn">Generate Landscape</button>
        <button id="fragmentBtn" style="background:#ff6432">Apply Fragmentation</button>
        <button id="runBtn" style="background:#444;color:#fff">Run Simulation</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Year</span>
                <span class="stat-value" id="year">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Habitat Area</span>
                <span class="stat-value" id="habitatArea">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Patch Count</span>
                <span class="stat-value" id="patchCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Connectivity</span>
                <span class="stat-value" id="connectivity">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Living Species</span>
                <span class="stat-value" id="livingSpecies">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Extinctions</span>
                <span class="stat-value" id="extinctions" style="color:#ff6432">0</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background:#2d8a2d"></div>
                <span>Forest Habitat</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#8b7355"></div>
                <span>Cleared/Developed</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#64c896"></div>
                <span>Species (animals)</span>
            </div>
        </div>

        <div class="info">
            <strong>Click</strong> to clear habitat areas.<br>
            <strong>Fragmentation</strong> reduces connectivity and increases extinction risk due to edge effects and isolation.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initLandscape();
        }
        resize();
        window.onresize = resize;

        const FOREST = 1;
        const CLEARED = 0;

        let cellSize = 8;
        let cols, rows;
        let landscape;
        let species = [];
        let year = 0;
        let running = false;
        let extinctions = 0;

        let coverage = 0.7;
        let fragmentCount = 5;
        let speciesCount = 50;
        let fragType = 'random';

        function initLandscape() {
            cols = Math.floor((canvas.width - 350) / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            landscape = [];

            for (let y = 0; y < rows; y++) {
                landscape[y] = [];
                for (let x = 0; x < cols; x++) {
                    landscape[y][x] = FOREST;
                }
            }

            // Initial species
            initSpecies();
            year = 0;
            extinctions = 0;
            updateStats();
        }

        function initSpecies() {
            species = [];

            for (let i = 0; i < speciesCount; i++) {
                // Random starting position in forest
                let x, y;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * cols);
                    y = Math.floor(Math.random() * rows);
                    attempts++;
                } while (landscape[y][x] !== FOREST && attempts < 100);

                species.push({
                    x: x,
                    y: y,
                    alive: true,
                    minHabitat: 5 + Math.random() * 20, // Minimum habitat requirement
                    dispersal: 3 + Math.random() * 10, // Movement range
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`
                });
            }
        }

        function applyFragmentation() {
            switch (fragType) {
                case 'random':
                    applyRandomClearing();
                    break;
                case 'road':
                    applyRoadNetwork();
                    break;
                case 'agriculture':
                    applyAgricultureGrid();
                    break;
            }
            updateStats();
        }

        function applyRandomClearing() {
            const totalCells = cols * rows;
            const targetCleared = totalCells * (1 - coverage);
            const clearedPerFragment = targetCleared / fragmentCount;

            for (let f = 0; f < fragmentCount; f++) {
                // Random center for clearing
                const cx = Math.floor(Math.random() * cols);
                const cy = Math.floor(Math.random() * rows);
                const radius = Math.sqrt(clearedPerFragment / Math.PI);

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        if (dist < radius * (0.8 + Math.random() * 0.4)) {
                            landscape[y][x] = CLEARED;
                        }
                    }
                }
            }
        }

        function applyRoadNetwork() {
            // Create roads
            const roadCount = fragmentCount;
            for (let r = 0; r < roadCount; r++) {
                const horizontal = Math.random() < 0.5;
                const pos = Math.floor(Math.random() * (horizontal ? rows : cols));
                const width = 2 + Math.floor(Math.random() * 3);

                if (horizontal) {
                    for (let x = 0; x < cols; x++) {
                        for (let w = 0; w < width; w++) {
                            const y = pos + w;
                            if (y >= 0 && y < rows) {
                                landscape[y][x] = CLEARED;
                            }
                        }
                    }
                } else {
                    for (let y = 0; y < rows; y++) {
                        for (let w = 0; w < width; w++) {
                            const x = pos + w;
                            if (x >= 0 && x < cols) {
                                landscape[y][x] = CLEARED;
                            }
                        }
                    }
                }
            }

            // Additional clearing around roads
            const targetClear = (1 - coverage) * cols * rows;
            let cleared = countCleared();

            while (cleared < targetClear) {
                const x = Math.floor(Math.random() * cols);
                const y = Math.floor(Math.random() * rows);

                // Check if near road
                let nearRoad = false;
                for (let dy = -5; dy <= 5; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        const ny = y + dy;
                        const nx = x + dx;
                        if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                            if (landscape[ny][nx] === CLEARED) {
                                nearRoad = true;
                                break;
                            }
                        }
                    }
                }

                if (nearRoad && Math.random() < 0.7) {
                    landscape[y][x] = CLEARED;
                    cleared++;
                }
            }
        }

        function applyAgricultureGrid() {
            const gridSize = Math.floor(Math.max(cols, rows) / fragmentCount);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const gridX = Math.floor(x / gridSize);
                    const gridY = Math.floor(y / gridSize);

                    // Checkerboard pattern with some randomness
                    if ((gridX + gridY) % 2 === 0) {
                        if (Math.random() < 1 - coverage * 1.3) {
                            landscape[y][x] = CLEARED;
                        }
                    }
                }
            }
        }

        function countCleared() {
            let count = 0;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (landscape[y][x] === CLEARED) count++;
                }
            }
            return count;
        }

        function findPatches() {
            const visited = [];
            for (let y = 0; y < rows; y++) {
                visited[y] = new Array(cols).fill(false);
            }

            const patches = [];

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (landscape[y][x] === FOREST && !visited[y][x]) {
                        // BFS to find connected patch
                        const patch = [];
                        const queue = [[x, y]];
                        visited[y][x] = true;

                        while (queue.length > 0) {
                            const [cx, cy] = queue.shift();
                            patch.push([cx, cy]);

                            // Check 4 neighbors
                            const neighbors = [[cx-1,cy], [cx+1,cy], [cx,cy-1], [cx,cy+1]];
                            for (const [nx, ny] of neighbors) {
                                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows &&
                                    landscape[ny][nx] === FOREST && !visited[ny][nx]) {
                                    visited[ny][nx] = true;
                                    queue.push([nx, ny]);
                                }
                            }
                        }

                        patches.push(patch);
                    }
                }
            }

            return patches;
        }

        function calculateConnectivity(patches) {
            if (patches.length <= 1) return patches.length > 0 ? 1 : 0;

            // Calculate connectivity based on patch proximity
            let connected = 0;
            const threshold = 20; // Distance threshold for "connected"

            for (let i = 0; i < patches.length; i++) {
                for (let j = i + 1; j < patches.length; j++) {
                    // Find minimum distance between patches
                    let minDist = Infinity;
                    for (const [x1, y1] of patches[i]) {
                        for (const [x2, y2] of patches[j]) {
                            const dist = Math.sqrt((x1-x2)**2 + (y1-y2)**2);
                            minDist = Math.min(minDist, dist);
                        }
                        if (minDist < threshold) break;
                    }

                    if (minDist < threshold) connected++;
                }
            }

            const maxConnections = (patches.length * (patches.length - 1)) / 2;
            return maxConnections > 0 ? (connected / maxConnections).toFixed(2) : 0;
        }

        function updateSpecies() {
            const patches = findPatches();

            for (const s of species) {
                if (!s.alive) continue;

                // Check if current position is still habitat
                if (landscape[s.y][s.x] === CLEARED) {
                    // Try to find nearby habitat
                    let found = false;
                    for (let dy = -s.dispersal; dy <= s.dispersal && !found; dy++) {
                        for (let dx = -s.dispersal; dx <= s.dispersal && !found; dx++) {
                            const ny = Math.floor(s.y + dy);
                            const nx = Math.floor(s.x + dx);
                            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols &&
                                landscape[ny][nx] === FOREST) {
                                s.x = nx;
                                s.y = ny;
                                found = true;
                            }
                        }
                    }

                    if (!found) {
                        s.alive = false;
                        extinctions++;
                    }
                }

                if (s.alive) {
                    // Check patch size requirement
                    let patchSize = 0;
                    for (const patch of patches) {
                        for (const [px, py] of patch) {
                            if (Math.abs(px - s.x) < 3 && Math.abs(py - s.y) < 3) {
                                patchSize = patch.length;
                                break;
                            }
                        }
                        if (patchSize > 0) break;
                    }

                    if (patchSize < s.minHabitat) {
                        // Risk of extinction based on habitat shortage
                        if (Math.random() < 0.01 * (s.minHabitat - patchSize) / s.minHabitat) {
                            s.alive = false;
                            extinctions++;
                        }
                    }

                    // Random movement within habitat
                    if (s.alive && Math.random() < 0.3) {
                        const dx = Math.floor((Math.random() - 0.5) * 4);
                        const dy = Math.floor((Math.random() - 0.5) * 4);
                        const nx = Math.max(0, Math.min(cols - 1, s.x + dx));
                        const ny = Math.max(0, Math.min(rows - 1, s.y + dy));
                        if (landscape[ny][nx] === FOREST) {
                            s.x = nx;
                            s.y = ny;
                        }
                    }
                }
            }
        }

        function updateStats() {
            const patches = findPatches();
            const totalCells = cols * rows;
            const forestCells = totalCells - countCleared();
            const habitatPercent = ((forestCells / totalCells) * 100).toFixed(1);
            const livingCount = species.filter(s => s.alive).length;

            document.getElementById('year').textContent = year;
            document.getElementById('habitatArea').textContent = habitatPercent + '%';
            document.getElementById('patchCount').textContent = patches.length;
            document.getElementById('connectivity').textContent = calculateConnectivity(patches);
            document.getElementById('livingSpecies').textContent = livingCount;
            document.getElementById('extinctions').textContent = extinctions;
        }

        function draw() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw landscape
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (landscape[y][x] === FOREST) {
                        const shade = 0.8 + Math.random() * 0.2;
                        ctx.fillStyle = `rgb(${Math.floor(45*shade)}, ${Math.floor(138*shade)}, ${Math.floor(45*shade)})`;
                    } else {
                        ctx.fillStyle = '#8b7355';
                    }
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                }
            }

            // Draw species
            for (const s of species) {
                if (!s.alive) continue;

                ctx.beginPath();
                ctx.arc(
                    s.x * cellSize + cellSize / 2,
                    s.y * cellSize + cellSize / 2,
                    4, 0, Math.PI * 2
                );
                ctx.fillStyle = s.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Update simulation
            if (running) {
                updateSpecies();
                year++;
                if (year % 10 === 0) updateStats();
            }

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('coverage').oninput = (e) => {
            coverage = parseInt(e.target.value) / 100;
            document.getElementById('coverageValue').textContent = e.target.value + '%';
        };

        document.getElementById('fragments').oninput = (e) => {
            fragmentCount = parseInt(e.target.value);
            document.getElementById('fragmentsValue').textContent = fragmentCount;
        };

        document.getElementById('speciesCount').oninput = (e) => {
            speciesCount = parseInt(e.target.value);
            document.getElementById('speciesValue').textContent = speciesCount;
        };

        document.getElementById('fragType').onchange = (e) => {
            fragType = e.target.value;
        };

        document.getElementById('generateBtn').onclick = initLandscape;
        document.getElementById('fragmentBtn').onclick = applyFragmentation;

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Run Simulation';
        };

        canvas.onmousedown = (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const brushSize = 5;
            const cx = Math.floor(mx / cellSize);
            const cy = Math.floor(my / cellSize);

            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist <= brushSize) {
                        const nx = cx + dx;
                        const ny = cy + dy;
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            landscape[ny][nx] = CLEARED;
                        }
                    }
                }
            }
            updateStats();
        };

        canvas.onmousemove = (e) => {
            if (e.buttons === 1) {
                canvas.onmousedown(e);
            }
        };

        // Initialize
        initLandscape();
        draw();
    </script>
</body>
</html>
