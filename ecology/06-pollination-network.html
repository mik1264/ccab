<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pollination Network | Ecology</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a2e1a 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 100, 0.3);
        }
        h1 { color: #64c896; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #64c896; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c896; color: #1a2e1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88d8b0; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64c896; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c896; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 10px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Ecology</a>

    <div class="controls">
        <h1>Pollination Network</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Plant-pollinator mutualism</p>

        <div class="control-group">
            <label>Plants: <span class="value" id="plantsValue">8</span></label>
            <input type="range" id="plants" min="3" max="15" value="8">
        </div>

        <div class="control-group">
            <label>Pollinators: <span class="value" id="pollinatorsValue">10</span></label>
            <input type="range" id="pollinators" min="3" max="20" value="10">
        </div>

        <div class="control-group">
            <label>Specialization: <span class="value" id="specValue">0.3</span></label>
            <input type="range" id="specialization" min="0" max="1" step="0.1" value="0.3">
        </div>

        <div class="control-group">
            <label>Scenario:</label>
            <select id="scenario">
                <option value="normal">Normal</option>
                <option value="remove_plant">Remove Random Plant</option>
                <option value="remove_pollinator">Remove Random Pollinator</option>
                <option value="remove_specialist">Remove Specialist</option>
            </select>
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="runBtn" style="background:#444;color:#fff">Run Simulation</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Connections</span>
                <span class="stat-value" id="connections">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Network Density</span>
                <span class="stat-value" id="density">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Nestedness</span>
                <span class="stat-value" id="nestedness">0</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background:#ff88aa"></div>
                <span>Plants (flowers)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#ffd700"></div>
                <span>Pollinators (bees)</span>
            </div>
        </div>

        <div class="info">
            <strong>Mutualistic networks</strong> show nested structure - specialists interact with subsets of generalists' partners.<br>
            Click on species to highlight connections.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let nPlants = 8;
        let nPollinators = 10;
        let specialization = 0.3;

        let plants = [];
        let pollinators = [];
        let interactions = []; // [plant_idx, pollinator_idx, strength]
        let selectedSpecies = null;
        let running = false;

        // Animated pollinators
        let bees = [];

        function generateNetwork() {
            plants = [];
            pollinators = [];
            interactions = [];
            bees = [];

            const plotWidth = canvas.width - 400;

            // Create plants (bottom row)
            for (let i = 0; i < nPlants; i++) {
                plants.push({
                    x: 100 + (i + 0.5) * ((plotWidth - 100) / nPlants),
                    y: canvas.height - 150,
                    color: `hsl(${330 + Math.random() * 40}, 80%, 70%)`,
                    alive: true,
                    degree: 0
                });
            }

            // Create pollinators (top area)
            for (let i = 0; i < nPollinators; i++) {
                pollinators.push({
                    x: 100 + (i + 0.5) * ((plotWidth - 100) / nPollinators),
                    y: 150,
                    color: `hsl(${40 + Math.random() * 20}, 90%, 60%)`,
                    alive: true,
                    degree: 0
                });
            }

            // Generate interactions based on specialization
            // Lower specialization = more generalist network
            for (let p = 0; p < nPlants; p++) {
                for (let b = 0; b < nPollinators; b++) {
                    // Probability based on degree distribution (nested structure)
                    const plantRank = (p + 1) / nPlants;
                    const polRank = (b + 1) / nPollinators;

                    // Create nested structure
                    const baseProb = (1 - specialization) + specialization * plantRank * polRank;
                    const prob = baseProb * 0.4;

                    if (Math.random() < prob) {
                        const strength = 0.3 + Math.random() * 0.7;
                        interactions.push([p, b, strength]);
                        plants[p].degree++;
                        pollinators[b].degree++;
                    }
                }
            }

            // Ensure every species has at least one connection
            for (let p = 0; p < nPlants; p++) {
                if (plants[p].degree === 0) {
                    const b = Math.floor(Math.random() * nPollinators);
                    interactions.push([p, b, 0.5]);
                    plants[p].degree++;
                    pollinators[b].degree++;
                }
            }

            for (let b = 0; b < nPollinators; b++) {
                if (pollinators[b].degree === 0) {
                    const p = Math.floor(Math.random() * nPlants);
                    interactions.push([p, b, 0.5]);
                    plants[p].degree++;
                    pollinators[b].degree++;
                }
            }

            // Initialize animated bees
            for (let b = 0; b < nPollinators; b++) {
                if (pollinators[b].alive) {
                    bees.push({
                        polIdx: b,
                        x: pollinators[b].x,
                        y: pollinators[b].y,
                        targetPlant: -1,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            updateStats();
        }

        function applyScenario(scenario) {
            switch (scenario) {
                case 'remove_plant':
                    const rp = Math.floor(Math.random() * nPlants);
                    plants[rp].alive = false;
                    // Check cascade
                    checkExtinctions();
                    break;

                case 'remove_pollinator':
                    const rb = Math.floor(Math.random() * nPollinators);
                    pollinators[rb].alive = false;
                    bees = bees.filter(bee => bee.polIdx !== rb);
                    checkExtinctions();
                    break;

                case 'remove_specialist':
                    // Find and remove most specialized pollinator
                    let minDegree = Infinity;
                    let specialistIdx = -1;
                    for (let b = 0; b < nPollinators; b++) {
                        if (pollinators[b].alive && pollinators[b].degree < minDegree) {
                            minDegree = pollinators[b].degree;
                            specialistIdx = b;
                        }
                    }
                    if (specialistIdx >= 0) {
                        pollinators[specialistIdx].alive = false;
                        bees = bees.filter(bee => bee.polIdx !== specialistIdx);
                        checkExtinctions();
                    }
                    break;
            }
            updateStats();
        }

        function checkExtinctions() {
            let changed = true;
            while (changed) {
                changed = false;

                // Check plants without pollinators
                for (let p = 0; p < nPlants; p++) {
                    if (!plants[p].alive) continue;

                    let hasPartner = false;
                    for (const [pi, bi, s] of interactions) {
                        if (pi === p && pollinators[bi].alive) {
                            hasPartner = true;
                            break;
                        }
                    }

                    if (!hasPartner) {
                        plants[p].alive = false;
                        changed = true;
                    }
                }

                // Check pollinators without plants
                for (let b = 0; b < nPollinators; b++) {
                    if (!pollinators[b].alive) continue;

                    let hasPartner = false;
                    for (const [pi, bi, s] of interactions) {
                        if (bi === b && plants[pi].alive) {
                            hasPartner = true;
                            break;
                        }
                    }

                    if (!hasPartner) {
                        pollinators[b].alive = false;
                        bees = bees.filter(bee => bee.polIdx !== b);
                        changed = true;
                    }
                }
            }
        }

        function calculateNestedness() {
            // Simplified nestedness calculation
            let nestedness = 0;
            let count = 0;

            for (let i = 0; i < nPollinators; i++) {
                for (let j = i + 1; j < nPollinators; j++) {
                    const partnersI = new Set();
                    const partnersJ = new Set();

                    for (const [pi, bi, s] of interactions) {
                        if (bi === i && plants[pi].alive && pollinators[i].alive) partnersI.add(pi);
                        if (bi === j && plants[pi].alive && pollinators[j].alive) partnersJ.add(pi);
                    }

                    if (partnersI.size > 0 && partnersJ.size > 0) {
                        const smaller = partnersI.size < partnersJ.size ? partnersI : partnersJ;
                        const larger = partnersI.size < partnersJ.size ? partnersJ : partnersI;

                        let overlap = 0;
                        for (const p of smaller) {
                            if (larger.has(p)) overlap++;
                        }

                        nestedness += overlap / smaller.size;
                        count++;
                    }
                }
            }

            return count > 0 ? (nestedness / count).toFixed(2) : 0;
        }

        function updateStats() {
            let activeInteractions = 0;
            for (const [pi, bi, s] of interactions) {
                if (plants[pi].alive && pollinators[bi].alive) {
                    activeInteractions++;
                }
            }

            const alivePlants = plants.filter(p => p.alive).length;
            const alivePols = pollinators.filter(p => p.alive).length;
            const maxConnections = alivePlants * alivePols;
            const density = maxConnections > 0 ? (activeInteractions / maxConnections).toFixed(2) : 0;

            document.getElementById('connections').textContent = activeInteractions;
            document.getElementById('density').textContent = density;
            document.getElementById('nestedness').textContent = calculateNestedness();
        }

        function updateBees() {
            for (const bee of bees) {
                if (!pollinators[bee.polIdx].alive) continue;

                bee.phase += 0.02;

                if (bee.targetPlant < 0 || Math.random() < 0.01) {
                    // Choose a new target plant from interactions
                    const possibleTargets = [];
                    for (const [pi, bi, s] of interactions) {
                        if (bi === bee.polIdx && plants[pi].alive) {
                            possibleTargets.push(pi);
                        }
                    }

                    if (possibleTargets.length > 0) {
                        bee.targetPlant = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
                    }
                }

                // Move toward target
                if (bee.targetPlant >= 0) {
                    const target = plants[bee.targetPlant];
                    const dx = target.x - bee.x;
                    const dy = target.y - bee.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 20) {
                        bee.x += dx / dist * 2;
                        bee.y += dy / dist * 2;
                    } else {
                        // Reached flower, hover and then return
                        bee.x += Math.sin(bee.phase * 3) * 2;
                        bee.y += Math.cos(bee.phase * 2) * 1;

                        if (Math.random() < 0.02) {
                            bee.targetPlant = -1;
                        }
                    }
                } else {
                    // Return to pollinator home position
                    const home = pollinators[bee.polIdx];
                    const dx = home.x - bee.x;
                    const dy = home.y - bee.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 10) {
                        bee.x += dx / dist * 2;
                        bee.y += dy / dist * 2;
                    }
                }

                // Add hovering motion
                bee.x += Math.sin(bee.phase) * 0.5;
                bee.y += Math.cos(bee.phase * 1.3) * 0.3;
            }
        }

        function draw() {
            ctx.fillStyle = '#1a2e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (running) {
                updateBees();
            }

            // Draw interaction lines
            for (const [pi, bi, strength] of interactions) {
                if (!plants[pi].alive || !pollinators[bi].alive) continue;

                const isHighlighted = selectedSpecies !== null && (
                    (selectedSpecies.type === 'plant' && selectedSpecies.idx === pi) ||
                    (selectedSpecies.type === 'pollinator' && selectedSpecies.idx === bi)
                );

                ctx.beginPath();
                ctx.strokeStyle = isHighlighted ?
                    `rgba(255, 215, 0, ${0.3 + strength * 0.7})` :
                    `rgba(255, 255, 255, ${0.1 + strength * 0.2})`;
                ctx.lineWidth = isHighlighted ? 3 : 1 + strength;

                // Curved line
                const plant = plants[pi];
                const pol = pollinators[bi];
                const midX = (plant.x + pol.x) / 2;
                const midY = (plant.y + pol.y) / 2 - 50;

                ctx.moveTo(plant.x, plant.y - 20);
                ctx.quadraticCurveTo(midX, midY, pol.x, pol.y + 15);
                ctx.stroke();
            }

            // Draw plants (flowers)
            for (let i = 0; i < plants.length; i++) {
                const p = plants[i];
                if (!p.alive) {
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                    continue;
                }

                const isSelected = selectedSpecies?.type === 'plant' && selectedSpecies?.idx === i;

                // Stem
                ctx.beginPath();
                ctx.strokeStyle = '#2d8a2d';
                ctx.lineWidth = 3;
                ctx.moveTo(p.x, p.y + 20);
                ctx.lineTo(p.x, p.y + 80);
                ctx.stroke();

                // Flower petals
                const petalCount = 6;
                for (let j = 0; j < petalCount; j++) {
                    const angle = (j / petalCount) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.ellipse(
                        p.x + Math.cos(angle) * 12,
                        p.y + Math.sin(angle) * 12,
                        10, 5,
                        angle, 0, Math.PI * 2
                    );
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }

                // Center
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#ffd700';
                ctx.fill();

                if (isSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Degree label
                ctx.fillStyle = '#fff';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`P${i + 1} (${p.degree})`, p.x, p.y + 95);
            }

            // Draw pollinators (circles at top)
            for (let i = 0; i < pollinators.length; i++) {
                const pol = pollinators[i];
                if (!pol.alive) {
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(pol.x, pol.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                    continue;
                }

                const isSelected = selectedSpecies?.type === 'pollinator' && selectedSpecies?.idx === i;

                ctx.beginPath();
                ctx.arc(pol.x, pol.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = pol.color;
                ctx.fill();

                if (isSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.fillStyle = '#fff';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`B${i + 1} (${pol.degree})`, pol.x, pol.y - 25);
            }

            // Draw animated bees
            for (const bee of bees) {
                if (!pollinators[bee.polIdx].alive) continue;

                ctx.save();
                ctx.translate(bee.x, bee.y);

                // Wings
                ctx.fillStyle = 'rgba(200, 200, 255, 0.6)';
                ctx.beginPath();
                ctx.ellipse(-6, -3, 6, 3, -0.3 + Math.sin(bee.phase * 20) * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(6, -3, 6, 3, 0.3 + Math.sin(bee.phase * 20 + Math.PI) * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.fillStyle = '#ffc800';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Stripes
                ctx.fillStyle = '#000';
                ctx.fillRect(-3, -3, 2, 6);
                ctx.fillRect(2, -3, 2, 6);

                ctx.restore();
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Plant-Pollinator Mutualistic Network', 50, 50);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('plants').oninput = (e) => {
            nPlants = parseInt(e.target.value);
            document.getElementById('plantsValue').textContent = nPlants;
        };

        document.getElementById('pollinators').oninput = (e) => {
            nPollinators = parseInt(e.target.value);
            document.getElementById('pollinatorsValue').textContent = nPollinators;
        };

        document.getElementById('specialization').oninput = (e) => {
            specialization = parseFloat(e.target.value);
            document.getElementById('specValue').textContent = specialization.toFixed(1);
        };

        document.getElementById('scenario').onchange = (e) => {
            if (e.target.value !== 'normal') {
                applyScenario(e.target.value);
                e.target.value = 'normal';
            }
        };

        document.getElementById('generateBtn').onclick = generateNetwork;

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Run Simulation';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            selectedSpecies = null;

            // Check plants
            for (let i = 0; i < plants.length; i++) {
                const p = plants[i];
                if (!p.alive) continue;
                const dx = mx - p.x;
                const dy = my - p.y;
                if (dx * dx + dy * dy < 400) {
                    selectedSpecies = { type: 'plant', idx: i };
                    return;
                }
            }

            // Check pollinators
            for (let i = 0; i < pollinators.length; i++) {
                const pol = pollinators[i];
                if (!pol.alive) continue;
                const dx = mx - pol.x;
                const dy = my - pol.y;
                if (dx * dx + dy * dy < 400) {
                    selectedSpecies = { type: 'pollinator', idx: i };
                    return;
                }
            }
        };

        // Initialize
        generateNetwork();
        draw();
    </script>
</body>
</html>
