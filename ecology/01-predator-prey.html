<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predator-Prey Dynamics | Ecology</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a2e1a 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 100, 0.3);
        }
        h1 { color: #64c896; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #64c896; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c896; color: #1a2e1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88d8b0; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { font-weight: bold; }
        .prey-color { color: #64c8ff; }
        .predator-color { color: #ff6464; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c896; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Ecology</a>

    <div class="controls">
        <h1>Predator-Prey Dynamics</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Lotka-Volterra equations</p>

        <div class="control-group">
            <label>Prey Birth Rate (α): <span class="value" id="alphaValue">1.0</span></label>
            <input type="range" id="alpha" min="0.1" max="3" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Predation Rate (β): <span class="value" id="betaValue">0.1</span></label>
            <input type="range" id="beta" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Predator Death Rate (γ): <span class="value" id="gammaValue">1.5</span></label>
            <input type="range" id="gamma" min="0.1" max="3" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <label>Predator Efficiency (δ): <span class="value" id="deltaValue">0.075</span></label>
            <input type="range" id="delta" min="0.01" max="0.2" step="0.005" value="0.075">
        </div>

        <div class="control-group">
            <label>Time Speed: <span class="value" id="speedValue">1.0</span></label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1.0">
        </div>

        <button id="resetBtn">Reset Simulation</button>
        <button id="perturbBtn" style="background:#444;color:#fff">Add Perturbation</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time</span>
                <span class="stat-value" id="time">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label prey-color">Prey Population</span>
                <span class="stat-value prey-color" id="preyPop">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label predator-color">Predator Population</span>
                <span class="stat-value predator-color" id="predatorPop">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Lotka-Volterra</strong> describes oscillating predator-prey cycles.<br>
            dx/dt = αx - βxy<br>
            dy/dt = δxy - γy
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        // Lotka-Volterra parameters
        let alpha = 1.0;    // Prey birth rate
        let beta = 0.1;     // Predation rate
        let gamma = 1.5;    // Predator death rate
        let delta = 0.075;  // Predator reproduction rate
        let speed = 1.0;

        // State variables
        let x = 40;  // Prey population
        let y = 9;   // Predator population
        let time = 0;
        let history = [];
        const maxHistory = 800;

        // Animated entities for visualization
        let preyEntities = [];
        let predatorEntities = [];

        function initEntities() {
            preyEntities = [];
            predatorEntities = [];

            const preyCount = Math.min(100, Math.floor(x));
            const predCount = Math.min(50, Math.floor(y));

            for (let i = 0; i < preyCount; i++) {
                preyEntities.push({
                    x: Math.random() * (canvas.width - 400) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }

            for (let i = 0; i < predCount; i++) {
                predatorEntities.push({
                    x: Math.random() * (canvas.width - 400) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3
                });
            }
        }

        function updatePopulations(dt) {
            // Lotka-Volterra equations using RK4
            const h = dt * 0.1 * speed;

            for (let i = 0; i < 10; i++) {
                const dx1 = alpha * x - beta * x * y;
                const dy1 = delta * x * y - gamma * y;

                const x2 = x + 0.5 * h * dx1;
                const y2 = y + 0.5 * h * dy1;
                const dx2 = alpha * x2 - beta * x2 * y2;
                const dy2 = delta * x2 * y2 - gamma * y2;

                const x3 = x + 0.5 * h * dx2;
                const y3 = y + 0.5 * h * dy2;
                const dx3 = alpha * x3 - beta * x3 * y3;
                const dy3 = delta * x3 * y3 - gamma * y3;

                const x4 = x + h * dx3;
                const y4 = y + h * dy3;
                const dx4 = alpha * x4 - beta * x4 * y4;
                const dy4 = delta * x4 * y4 - gamma * y4;

                x += h * (dx1 + 2 * dx2 + 2 * dx3 + dx4) / 6;
                y += h * (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;

                x = Math.max(0.1, x);
                y = Math.max(0.1, y);
            }

            time += dt * speed;

            history.push({ t: time, x: x, y: y });
            if (history.length > maxHistory) {
                history.shift();
            }
        }

        function updateEntities() {
            // Adjust entity counts
            const targetPrey = Math.min(150, Math.floor(x * 2));
            const targetPred = Math.min(75, Math.floor(y * 3));

            while (preyEntities.length < targetPrey) {
                preyEntities.push({
                    x: Math.random() * (canvas.width - 400) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }
            while (preyEntities.length > targetPrey) {
                preyEntities.pop();
            }

            while (predatorEntities.length < targetPred) {
                predatorEntities.push({
                    x: Math.random() * (canvas.width - 400) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3
                });
            }
            while (predatorEntities.length > targetPred) {
                predatorEntities.pop();
            }

            // Move prey (avoid predators)
            for (const prey of preyEntities) {
                // Flee from nearest predator
                let fleeX = 0, fleeY = 0;
                for (const pred of predatorEntities) {
                    const dx = prey.x - pred.x;
                    const dy = prey.y - pred.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                    if (dist < 100) {
                        fleeX += dx / dist * 0.5;
                        fleeY += dy / dist * 0.5;
                    }
                }

                prey.vx += fleeX + (Math.random() - 0.5) * 0.2;
                prey.vy += fleeY + (Math.random() - 0.5) * 0.2;

                // Limit speed
                const speed = Math.sqrt(prey.vx * prey.vx + prey.vy * prey.vy);
                if (speed > 3) {
                    prey.vx *= 3 / speed;
                    prey.vy *= 3 / speed;
                }

                prey.x += prey.vx;
                prey.y += prey.vy;

                // Bounce off walls
                if (prey.x < 50 || prey.x > canvas.width - 350) prey.vx *= -1;
                if (prey.y < 50 || prey.y > canvas.height - 50) prey.vy *= -1;
                prey.x = Math.max(50, Math.min(canvas.width - 350, prey.x));
                prey.y = Math.max(50, Math.min(canvas.height - 50, prey.y));
            }

            // Move predators (chase prey)
            for (const pred of predatorEntities) {
                // Chase nearest prey
                let chaseX = 0, chaseY = 0;
                let minDist = Infinity;
                for (const prey of preyEntities) {
                    const dx = prey.x - pred.x;
                    const dy = prey.y - pred.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        chaseX = dx;
                        chaseY = dy;
                    }
                }

                if (minDist < 200 && minDist > 0) {
                    pred.vx += chaseX / minDist * 0.3;
                    pred.vy += chaseY / minDist * 0.3;
                }

                pred.vx += (Math.random() - 0.5) * 0.3;
                pred.vy += (Math.random() - 0.5) * 0.3;

                const speed = Math.sqrt(pred.vx * pred.vx + pred.vy * pred.vy);
                if (speed > 4) {
                    pred.vx *= 4 / speed;
                    pred.vy *= 4 / speed;
                }

                pred.x += pred.vx;
                pred.y += pred.vy;

                if (pred.x < 50 || pred.x > canvas.width - 350) pred.vx *= -1;
                if (pred.y < 50 || pred.y > canvas.height - 50) pred.vy *= -1;
                pred.x = Math.max(50, Math.min(canvas.width - 350, pred.x));
                pred.y = Math.max(50, Math.min(canvas.height - 50, pred.y));
            }
        }

        function updateStats() {
            document.getElementById('time').textContent = time.toFixed(1);
            document.getElementById('preyPop').textContent = x.toFixed(1);
            document.getElementById('predatorPop').textContent = y.toFixed(1);
        }

        function drawGraph() {
            const graphX = 50;
            const graphY = canvas.height - 250;
            const graphW = canvas.width - 400;
            const graphH = 200;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(graphX - 10, graphY - 30, graphW + 20, graphH + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Population Over Time', graphX, graphY - 10);

            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(graphX, graphY);
            ctx.lineTo(graphX, graphY + graphH);
            ctx.lineTo(graphX + graphW, graphY + graphH);
            ctx.stroke();

            if (history.length < 2) return;

            // Find scale
            let maxPop = 1;
            for (const h of history) {
                maxPop = Math.max(maxPop, h.x, h.y);
            }

            // Draw prey line
            ctx.beginPath();
            ctx.strokeStyle = '#64c8ff';
            ctx.lineWidth = 2;
            for (let i = 0; i < history.length; i++) {
                const px = graphX + (i / (history.length - 1)) * graphW;
                const py = graphY + graphH - (history[i].x / maxPop) * graphH;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw predator line
            ctx.beginPath();
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 2;
            for (let i = 0; i < history.length; i++) {
                const px = graphX + (i / (history.length - 1)) * graphW;
                const py = graphY + graphH - (history[i].y / maxPop) * graphH;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Legend
            ctx.fillStyle = '#64c8ff';
            ctx.fillRect(graphX + graphW - 100, graphY + 10, 15, 10);
            ctx.fillStyle = '#fff';
            ctx.fillText('Prey', graphX + graphW - 80, graphY + 18);

            ctx.fillStyle = '#ff6464';
            ctx.fillRect(graphX + graphW - 100, graphY + 25, 15, 10);
            ctx.fillStyle = '#fff';
            ctx.fillText('Predator', graphX + graphW - 80, graphY + 33);
        }

        function drawPhaseSpace() {
            const phaseX = canvas.width - 650;
            const phaseY = 100;
            const phaseSize = 200;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(phaseX - 10, phaseY - 30, phaseSize + 20, phaseSize + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Phase Space', phaseX, phaseY - 10);

            // Axes labels
            ctx.fillStyle = '#64c8ff';
            ctx.fillText('Prey →', phaseX + phaseSize - 40, phaseY + phaseSize + 20);
            ctx.save();
            ctx.translate(phaseX - 5, phaseY + phaseSize / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#ff6464';
            ctx.fillText('Predator →', -30, 0);
            ctx.restore();

            if (history.length < 2) return;

            // Find scale
            let maxX = 1, maxY = 1;
            for (const h of history) {
                maxX = Math.max(maxX, h.x);
                maxY = Math.max(maxY, h.y);
            }

            // Draw trajectory
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.6)';
            ctx.lineWidth = 1;
            for (let i = 0; i < history.length; i++) {
                const px = phaseX + (history[i].x / maxX) * phaseSize;
                const py = phaseY + phaseSize - (history[i].y / maxY) * phaseSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Current point
            const lastH = history[history.length - 1];
            const cx = phaseX + (lastH.x / maxX) * phaseSize;
            const cy = phaseY + phaseSize - (lastH.y / maxY) * phaseSize;
            ctx.beginPath();
            ctx.arc(cx, cy, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#64c896';
            ctx.fill();
        }

        function draw() {
            ctx.fillStyle = '#1a2e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grass background
            ctx.fillStyle = '#1a3a1a';
            ctx.fillRect(40, 40, canvas.width - 380, canvas.height - 300);

            // Update simulation
            updatePopulations(0.016);
            updateEntities();
            updateStats();

            // Draw entities
            for (const prey of preyEntities) {
                ctx.beginPath();
                ctx.arc(prey.x, prey.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#64c8ff';
                ctx.fill();
            }

            for (const pred of predatorEntities) {
                ctx.beginPath();
                ctx.arc(pred.x, pred.y, 7, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6464';
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(pred.x - 2, pred.y - 2, 2, 0, Math.PI * 2);
                ctx.arc(pred.x + 2, pred.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw graphs
            drawGraph();
            drawPhaseSpace();

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('alpha').oninput = (e) => {
            alpha = parseFloat(e.target.value);
            document.getElementById('alphaValue').textContent = alpha.toFixed(1);
        };

        document.getElementById('beta').oninput = (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('betaValue').textContent = beta.toFixed(2);
        };

        document.getElementById('gamma').oninput = (e) => {
            gamma = parseFloat(e.target.value);
            document.getElementById('gammaValue').textContent = gamma.toFixed(1);
        };

        document.getElementById('delta').oninput = (e) => {
            delta = parseFloat(e.target.value);
            document.getElementById('deltaValue').textContent = delta.toFixed(3);
        };

        document.getElementById('speed').oninput = (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = speed.toFixed(1);
        };

        document.getElementById('resetBtn').onclick = () => {
            x = 40;
            y = 9;
            time = 0;
            history = [];
            initEntities();
        };

        document.getElementById('perturbBtn').onclick = () => {
            x *= 0.5 + Math.random();
            y *= 0.5 + Math.random();
        };

        // Initialize
        initEntities();
        draw();
    </script>
</body>
</html>
