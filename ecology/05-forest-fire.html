<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Fire Spread | Ecology</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a2e1a 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 100, 0.3);
        }
        h1 { color: #64c896; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #64c896; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c896; color: #1a2e1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88d8b0; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { font-weight: bold; }
        .tree-color { color: #64c896; }
        .fire-color { color: #ff6432; }
        .burnt-color { color: #666; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c896; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 10px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 20px; height: 20px; border-radius: 3px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Ecology</a>

    <div class="controls">
        <h1>Forest Fire Spread</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Cellular automaton fire model</p>

        <div class="control-group">
            <label>Forest Density: <span class="value" id="densityValue">60%</span></label>
            <input type="range" id="density" min="20" max="95" value="60">
        </div>

        <div class="control-group">
            <label>Fire Spread Probability: <span class="value" id="spreadValue">80%</span></label>
            <input type="range" id="spreadProb" min="10" max="100" value="80">
        </div>

        <div class="control-group">
            <label>Wind Direction:</label>
            <select id="wind">
                <option value="none">No Wind</option>
                <option value="north">North</option>
                <option value="south">South</option>
                <option value="east">East</option>
                <option value="west">West</option>
            </select>
        </div>

        <div class="control-group">
            <label>Regrowth Rate: <span class="value" id="regrowthValue">0.5%</span></label>
            <input type="range" id="regrowth" min="0" max="5" step="0.1" value="0.5">
        </div>

        <button id="generateBtn">Generate Forest</button>
        <button id="igniteBtn" style="background:#ff6432">Ignite Fire</button>
        <button id="pauseBtn" style="background:#444;color:#fff">Pause</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Step</span>
                <span class="stat-value" id="step">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label tree-color">Trees</span>
                <span class="stat-value tree-color" id="trees">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label fire-color">Burning</span>
                <span class="stat-value fire-color" id="burning">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label burnt-color">Burnt</span>
                <span class="stat-value burnt-color" id="burnt">0</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background:#1a3a1a"></div>
                <span>Empty</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#2d8a2d"></div>
                <span>Tree</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#ff6432"></div>
                <span>Burning</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#333"></div>
                <span>Burnt</span>
            </div>
        </div>

        <div class="info">
            <strong>Click</strong> on the forest to start fires.<br>
            <strong>Percolation:</strong> Fire spreads through connected trees. Critical density ~59%.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGrid();
        }
        resize();
        window.onresize = resize;

        const EMPTY = 0;
        const TREE = 1;
        const BURNING = 2;
        const BURNT = 3;

        let cellSize = 6;
        let cols, rows;
        let grid, nextGrid;
        let density = 0.6;
        let spreadProb = 0.8;
        let regrowthRate = 0.005;
        let wind = 'none';
        let step = 0;
        let running = true;

        function initGrid() {
            cols = Math.floor((canvas.width - 320) / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            grid = [];
            nextGrid = [];

            for (let y = 0; y < rows; y++) {
                grid[y] = [];
                nextGrid[y] = [];
                for (let x = 0; x < cols; x++) {
                    grid[y][x] = Math.random() < density ? TREE : EMPTY;
                    nextGrid[y][x] = grid[y][x];
                }
            }
            step = 0;
            updateStats();
        }

        function igniteRandom() {
            // Start fire on left edge
            for (let y = 0; y < rows; y++) {
                if (grid[y][0] === TREE) {
                    grid[y][0] = BURNING;
                }
            }
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const windMods = {
                none: { north: 1, south: 1, east: 1, west: 1 },
                north: { north: 1.5, south: 0.5, east: 1, west: 1 },
                south: { north: 0.5, south: 1.5, east: 1, west: 1 },
                east: { north: 1, south: 1, east: 1.5, west: 0.5 },
                west: { north: 1, south: 1, east: 0.5, west: 1.5 }
            };
            const mods = windMods[wind];

            // 8 directions
            if (y > 0) neighbors.push({ x, y: y - 1, mod: mods.north });
            if (y < rows - 1) neighbors.push({ x, y: y + 1, mod: mods.south });
            if (x > 0) neighbors.push({ x: x - 1, y, mod: mods.west });
            if (x < cols - 1) neighbors.push({ x: x + 1, y, mod: mods.east });

            // Diagonal neighbors
            if (y > 0 && x > 0) neighbors.push({ x: x - 1, y: y - 1, mod: (mods.north + mods.west) / 2 * 0.7 });
            if (y > 0 && x < cols - 1) neighbors.push({ x: x + 1, y: y - 1, mod: (mods.north + mods.east) / 2 * 0.7 });
            if (y < rows - 1 && x > 0) neighbors.push({ x: x - 1, y: y + 1, mod: (mods.south + mods.west) / 2 * 0.7 });
            if (y < rows - 1 && x < cols - 1) neighbors.push({ x: x + 1, y: y + 1, mod: (mods.south + mods.east) / 2 * 0.7 });

            return neighbors;
        }

        function updateGrid() {
            if (!running) return;

            let hasChanges = false;

            // Copy current grid
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    nextGrid[y][x] = grid[y][x];
                }
            }

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const cell = grid[y][x];

                    if (cell === TREE) {
                        // Check if any neighbor is burning
                        const neighbors = getNeighbors(x, y);
                        for (const n of neighbors) {
                            if (grid[n.y][n.x] === BURNING) {
                                if (Math.random() < spreadProb * n.mod) {
                                    nextGrid[y][x] = BURNING;
                                    hasChanges = true;
                                    break;
                                }
                            }
                        }
                    } else if (cell === BURNING) {
                        nextGrid[y][x] = BURNT;
                        hasChanges = true;
                    } else if (cell === BURNT) {
                        // Possible regrowth
                        if (Math.random() < regrowthRate) {
                            nextGrid[y][x] = TREE;
                            hasChanges = true;
                        }
                    } else if (cell === EMPTY) {
                        // Tree growth
                        if (Math.random() < regrowthRate * 0.5) {
                            nextGrid[y][x] = TREE;
                            hasChanges = true;
                        }
                    }
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];

            step++;
            updateStats();
        }

        function updateStats() {
            let trees = 0, burning = 0, burnt = 0;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    switch (grid[y][x]) {
                        case TREE: trees++; break;
                        case BURNING: burning++; break;
                        case BURNT: burnt++; break;
                    }
                }
            }

            document.getElementById('step').textContent = step;
            document.getElementById('trees').textContent = trees;
            document.getElementById('burning').textContent = burning;
            document.getElementById('burnt').textContent = burnt;
        }

        function draw() {
            ctx.fillStyle = '#0a1a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const cell = grid[y][x];
                    let color;

                    switch (cell) {
                        case EMPTY:
                            color = '#1a2a1a';
                            break;
                        case TREE:
                            // Vary tree color slightly
                            const greenVar = 0.8 + Math.random() * 0.4;
                            color = `rgb(${Math.floor(45 * greenVar)}, ${Math.floor(138 * greenVar)}, ${Math.floor(45 * greenVar)})`;
                            break;
                        case BURNING:
                            // Animate fire
                            const fireVar = 0.7 + Math.random() * 0.3;
                            color = `rgb(255, ${Math.floor(100 * fireVar)}, ${Math.floor(50 * fireVar)})`;
                            break;
                        case BURNT:
                            color = '#222';
                            break;
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                }
            }

            // Draw wind indicator
            if (wind !== 'none') {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = '14px sans-serif';
                ctx.fillText('Wind: ' + wind.toUpperCase(), 20, canvas.height - 20);

                // Arrow
                const cx = 120, cy = canvas.height - 25;
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                let dx = 0, dy = 0;
                switch (wind) {
                    case 'north': dy = -15; break;
                    case 'south': dy = 15; break;
                    case 'east': dx = 15; break;
                    case 'west': dx = -15; break;
                }

                ctx.moveTo(cx - dx, cy - dy);
                ctx.lineTo(cx + dx, cy + dy);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(dy, dx);
                ctx.beginPath();
                ctx.moveTo(cx + dx, cy + dy);
                ctx.lineTo(cx + dx - 8 * Math.cos(angle - 0.5), cy + dy - 8 * Math.sin(angle - 0.5));
                ctx.moveTo(cx + dx, cy + dy);
                ctx.lineTo(cx + dx - 8 * Math.cos(angle + 0.5), cy + dy - 8 * Math.sin(angle + 0.5));
                ctx.stroke();
            }

            requestAnimationFrame(draw);
        }

        // Simulation loop
        setInterval(updateGrid, 50);

        // Event listeners
        document.getElementById('density').oninput = (e) => {
            density = parseInt(e.target.value) / 100;
            document.getElementById('densityValue').textContent = e.target.value + '%';
        };

        document.getElementById('spreadProb').oninput = (e) => {
            spreadProb = parseInt(e.target.value) / 100;
            document.getElementById('spreadValue').textContent = e.target.value + '%';
        };

        document.getElementById('wind').onchange = (e) => {
            wind = e.target.value;
        };

        document.getElementById('regrowth').oninput = (e) => {
            regrowthRate = parseFloat(e.target.value) / 100;
            document.getElementById('regrowthValue').textContent = e.target.value + '%';
        };

        document.getElementById('generateBtn').onclick = initGrid;
        document.getElementById('igniteBtn').onclick = igniteRandom;

        document.getElementById('pauseBtn').onclick = () => {
            running = !running;
            document.getElementById('pauseBtn').textContent = running ? 'Pause' : 'Resume';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const x = Math.floor(mx / cellSize);
            const y = Math.floor(my / cellSize);

            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                // Ignite a small area
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            if (grid[ny][nx] === TREE) {
                                grid[ny][nx] = BURNING;
                            }
                        }
                    }
                }
            }
        };

        // Initialize
        initGrid();
        draw();
    </script>
</body>
</html>
