<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Walking - CCAB</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container { display: flex; height: 100vh; }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 10px;
        }
        canvas { border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #74b9ff; }
        h3 { margin: 15px 0 8px 0; color: #a9d4ff; font-size: 14px; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 13px; }
        input[type="range"] { width: 100%; }
        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
        }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #74b9ff;
            color: #1a1a2e;
            font-weight: bold;
        }
        button:hover { background: #0984e3; color: white; }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600;">
        <span>‚Üê Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="networkCanvas"></canvas>
            <canvas id="histCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>üîó Link Walking</h2>
            <p style="font-size: 12px; opacity: 0.8;">Random walk on networks</p>

            <h3>Network Type</h3>
            <select id="network">
                <option value="random">Random (Erd≈ës-R√©nyi)</option>
                <option value="scale-free">Scale-Free (Barab√°si-Albert)</option>
                <option value="small-world">Small World (Watts-Strogatz)</option>
                <option value="ring">Ring Lattice</option>
            </select>

            <h3>Number of Nodes</h3>
            <div class="slider-group">
                <label>Nodes: <span id="nodesVal">30</span></label>
                <input type="range" id="nodes" min="10" max="60" step="5" value="30">
            </div>

            <h3>Edge Density</h3>
            <div class="slider-group">
                <label>Density: <span id="densityVal">0.15</span></label>
                <input type="range" id="density" min="0.05" max="0.4" step="0.05" value="0.15">
            </div>

            <h3>Number of Walkers</h3>
            <div class="slider-group">
                <label>Walkers: <span id="walkersVal">3</span></label>
                <input type="range" id="walkers" min="1" max="10" step="1" value="3">
            </div>

            <h3>Speed</h3>
            <div class="slider-group">
                <label>Delay: <span id="speedVal">200</span>ms</label>
                <input type="range" id="speed" min="50" max="1000" step="50" value="200">
            </div>

            <button onclick="reset()">Reset</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>
            <button onclick="stepOnce()">Step</button>

            <div class="stats">
                <div class="stat-row"><span>Steps:</span><span id="steps">0</span></div>
                <div class="stat-row"><span>Nodes Visited:</span><span id="visited">0</span></div>
                <div class="stat-row"><span>Coverage:</span><span id="coverage">0%</span></div>
                <div class="stat-row"><span>Most Visited:</span><span id="mostVisited">-</span></div>
                <div class="stat-row"><span>Avg Degree:</span><span id="avgDegree">0</span></div>
            </div>

            <div class="description">
                <strong>Random Walk on Graphs:</strong><br>
                Walker moves to random neighbor at each step.<br><br>
                <strong>PageRank Connection:</strong><br>
                Stationary distribution of walk ‚àù node centrality.<br><br>
                <strong>Networks:</strong><br>
                ‚Ä¢ Random: uniform edge probability<br>
                ‚Ä¢ Scale-free: preferential attachment<br>
                ‚Ä¢ Small-world: high clustering, low diameter<br>
                ‚Ä¢ Ring: regular lattice structure
            </div>
        </div>
    </div>

    <script>
        const networkCanvas = document.getElementById('networkCanvas');
        const networkCtx = networkCanvas.getContext('2d');
        const histCanvas = document.getElementById('histCanvas');
        const histCtx = histCanvas.getContext('2d');

        networkCanvas.width = 600;
        networkCanvas.height = 450;
        histCanvas.width = 600;
        histCanvas.height = 100;

        let nodes = [];
        let edges = [];
        let walkers = [];
        let visitCounts = [];

        let numNodes = 30;
        let edgeDensity = 0.15;
        let numWalkers = 3;
        let networkType = 'random';
        let speed = 200;
        let steps = 0;
        let paused = false;
        let animationId = null;

        function createNetwork() {
            nodes = [];
            edges = [];
            visitCounts = new Array(numNodes).fill(0);

            // Position nodes in a circle
            for (let i = 0; i < numNodes; i++) {
                const angle = (i / numNodes) * Math.PI * 2;
                const radius = Math.min(networkCanvas.width, networkCanvas.height) * 0.35;
                nodes.push({
                    x: networkCanvas.width / 2 + Math.cos(angle) * radius,
                    y: networkCanvas.height / 2 + Math.sin(angle) * radius,
                    neighbors: []
                });
            }

            // Create edges based on network type
            switch (networkType) {
                case 'random':
                    createRandomNetwork();
                    break;
                case 'scale-free':
                    createScaleFreeNetwork();
                    break;
                case 'small-world':
                    createSmallWorldNetwork();
                    break;
                case 'ring':
                    createRingNetwork();
                    break;
            }
        }

        function addEdge(i, j) {
            if (i === j) return;
            if (!nodes[i].neighbors.includes(j)) {
                nodes[i].neighbors.push(j);
                nodes[j].neighbors.push(i);
                edges.push([i, j]);
            }
        }

        function createRandomNetwork() {
            for (let i = 0; i < numNodes; i++) {
                for (let j = i + 1; j < numNodes; j++) {
                    if (Math.random() < edgeDensity) {
                        addEdge(i, j);
                    }
                }
            }
            // Ensure connected
            for (let i = 1; i < numNodes; i++) {
                if (nodes[i].neighbors.length === 0) {
                    addEdge(i, Math.floor(Math.random() * i));
                }
            }
        }

        function createScaleFreeNetwork() {
            const m = Math.max(2, Math.floor(edgeDensity * 10));
            // Start with complete graph on m nodes
            for (let i = 0; i < m; i++) {
                for (let j = i + 1; j < m; j++) {
                    addEdge(i, j);
                }
            }
            // Add remaining nodes with preferential attachment
            for (let i = m; i < numNodes; i++) {
                const degrees = nodes.map(n => n.neighbors.length);
                const totalDegree = degrees.reduce((a, b) => a + b, 0);
                const targets = new Set();

                while (targets.size < m) {
                    let rand = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        rand -= degrees[j];
                        if (rand <= 0) {
                            targets.add(j);
                            break;
                        }
                    }
                }

                for (const t of targets) {
                    addEdge(i, t);
                }
            }
        }

        function createSmallWorldNetwork() {
            const k = Math.max(2, Math.floor(edgeDensity * numNodes));
            // Create ring lattice
            for (let i = 0; i < numNodes; i++) {
                for (let j = 1; j <= k / 2; j++) {
                    addEdge(i, (i + j) % numNodes);
                }
            }
            // Rewire with probability
            const rewireProb = 0.1;
            for (const [i, j] of [...edges]) {
                if (Math.random() < rewireProb) {
                    // Remove edge and add new random one
                    const newJ = Math.floor(Math.random() * numNodes);
                    if (newJ !== i && !nodes[i].neighbors.includes(newJ)) {
                        nodes[i].neighbors = nodes[i].neighbors.filter(n => n !== j);
                        nodes[j].neighbors = nodes[j].neighbors.filter(n => n !== i);
                        addEdge(i, newJ);
                    }
                }
            }
        }

        function createRingNetwork() {
            const k = Math.max(1, Math.floor(edgeDensity * numNodes / 2));
            for (let i = 0; i < numNodes; i++) {
                for (let j = 1; j <= k; j++) {
                    addEdge(i, (i + j) % numNodes);
                }
            }
        }

        function createWalkers() {
            walkers = [];
            for (let i = 0; i < numWalkers; i++) {
                const startNode = Math.floor(Math.random() * numNodes);
                walkers.push({
                    node: startNode,
                    color: `hsl(${i * 360 / numWalkers}, 70%, 60%)`,
                    trail: [startNode]
                });
                visitCounts[startNode]++;
            }
        }

        function reset() {
            if (animationId) clearTimeout(animationId);
            numNodes = parseInt(document.getElementById('nodes').value);
            edgeDensity = parseFloat(document.getElementById('density').value);
            numWalkers = parseInt(document.getElementById('walkers').value);
            networkType = document.getElementById('network').value;
            speed = parseInt(document.getElementById('speed').value);

            steps = 0;
            paused = false;
            document.getElementById('pauseBtn').textContent = 'Pause';

            createNetwork();
            createWalkers();
            updateStats();
            draw();
            animate();
        }

        function stepOnce() {
            for (const walker of walkers) {
                const neighbors = nodes[walker.node].neighbors;
                if (neighbors.length > 0) {
                    const nextNode = neighbors[Math.floor(Math.random() * neighbors.length)];
                    walker.node = nextNode;
                    walker.trail.push(nextNode);
                    if (walker.trail.length > 20) walker.trail.shift();
                    visitCounts[nextNode]++;
                }
            }
            steps++;
        }

        function updateStats() {
            const visited = visitCounts.filter(c => c > 0).length;
            const coverage = (visited / numNodes * 100).toFixed(1);
            const maxVisits = Math.max(...visitCounts);
            const mostVisited = visitCounts.indexOf(maxVisits);
            const avgDegree = (edges.length * 2 / numNodes).toFixed(1);

            document.getElementById('steps').textContent = steps;
            document.getElementById('visited').textContent = visited;
            document.getElementById('coverage').textContent = coverage + '%';
            document.getElementById('mostVisited').textContent = `Node ${mostVisited} (${maxVisits})`;
            document.getElementById('avgDegree').textContent = avgDegree;
        }

        function draw() {
            // Network
            networkCtx.fillStyle = '#1a1a2e';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);

            // Draw edges
            networkCtx.strokeStyle = 'rgba(116, 185, 255, 0.3)';
            networkCtx.lineWidth = 1;
            for (const [i, j] of edges) {
                networkCtx.beginPath();
                networkCtx.moveTo(nodes[i].x, nodes[i].y);
                networkCtx.lineTo(nodes[j].x, nodes[j].y);
                networkCtx.stroke();
            }

            // Draw walker trails
            for (const walker of walkers) {
                if (walker.trail.length > 1) {
                    networkCtx.strokeStyle = walker.color;
                    networkCtx.lineWidth = 3;
                    networkCtx.globalAlpha = 0.5;
                    networkCtx.beginPath();
                    networkCtx.moveTo(nodes[walker.trail[0]].x, nodes[walker.trail[0]].y);
                    for (let i = 1; i < walker.trail.length; i++) {
                        networkCtx.lineTo(nodes[walker.trail[i]].x, nodes[walker.trail[i]].y);
                    }
                    networkCtx.stroke();
                    networkCtx.globalAlpha = 1;
                }
            }

            // Draw nodes
            const maxCount = Math.max(1, ...visitCounts);
            for (let i = 0; i < nodes.length; i++) {
                const n = nodes[i];
                const intensity = visitCounts[i] / maxCount;

                // Size based on degree
                const size = 5 + nodes[i].neighbors.length * 0.8;

                // Color based on visit count
                networkCtx.fillStyle = visitCounts[i] > 0
                    ? `rgba(116, 185, 255, ${0.3 + intensity * 0.7})`
                    : '#636e72';

                networkCtx.beginPath();
                networkCtx.arc(n.x, n.y, size, 0, Math.PI * 2);
                networkCtx.fill();

                // Node label
                if (numNodes <= 30) {
                    networkCtx.fillStyle = 'white';
                    networkCtx.font = '9px Arial';
                    networkCtx.textAlign = 'center';
                    networkCtx.fillText(i, n.x, n.y + 3);
                }
            }

            // Draw walkers
            for (const walker of walkers) {
                const n = nodes[walker.node];
                networkCtx.fillStyle = walker.color;
                networkCtx.beginPath();
                networkCtx.arc(n.x, n.y, 8, 0, Math.PI * 2);
                networkCtx.fill();
                networkCtx.strokeStyle = 'white';
                networkCtx.lineWidth = 2;
                networkCtx.stroke();
            }

            // Visit histogram
            histCtx.fillStyle = '#1a1a2e';
            histCtx.fillRect(0, 0, histCanvas.width, histCanvas.height);

            const barWidth = histCanvas.width / numNodes;
            for (let i = 0; i < numNodes; i++) {
                const height = (visitCounts[i] / maxCount) * (histCanvas.height - 20);
                histCtx.fillStyle = '#74b9ff';
                histCtx.fillRect(i * barWidth, histCanvas.height - height - 10, barWidth - 1, height);
            }

            histCtx.fillStyle = 'white';
            histCtx.font = '10px Arial';
            histCtx.fillText('Visit distribution by node', 5, 12);
        }

        function animate() {
            if (!paused) {
                stepOnce();
                updateStats();
            }
            draw();
            animationId = setTimeout(animate, speed);
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        }

        // Event listeners
        document.getElementById('nodes').oninput = function() {
            document.getElementById('nodesVal').textContent = this.value;
        };
        document.getElementById('density').oninput = function() {
            document.getElementById('densityVal').textContent = this.value;
        };
        document.getElementById('walkers').oninput = function() {
            document.getElementById('walkersVal').textContent = this.value;
        };
        document.getElementById('speed').oninput = function() {
            speed = parseInt(this.value);
            document.getElementById('speedVal').textContent = speed;
        };

        reset();
    </script>
</body>
</html>
