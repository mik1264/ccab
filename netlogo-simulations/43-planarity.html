<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planarity Game - NetLogo Simulations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description {
            text-align: center;
            max-width: 700px;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.5;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }
        .controls {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 220px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.85rem;
            color: #888;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .value {
            font-size: 0.8rem;
            color: #4ecdc4;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .primary { background: #4ecdc4; color: #1a1a2e; }
        .primary:hover { background: #44a08d; }
        .secondary { background: rgba(255,255,255,0.1); color: #e0e0e0; }
        .secondary:hover { background: rgba(255,255,255,0.2); }
        .success { background: #2ecc71; color: white; }
        .stats {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            font-size: 0.85rem;
        }
        .stats div { margin: 3px 0; }
        .stat-value { color: #4ecdc4; }
        .solved {
            color: #2ecc71;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .hint {
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
        }
        a.back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4ecdc4;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        a.back-link:hover { opacity: 1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>Planarity Puzzle</h1>
    <p class="description">
        Untangle the graph by dragging nodes so no edges cross. A planar graph can always be
        drawn without crossings - can you find the crossing-free embedding?
    </p>

    <div class="container">
        <canvas id="canvas" width="600" height="600"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Difficulty (Nodes): <span id="nodesVal" class="value">8</span></label>
                <input type="range" id="nodeCount" min="5" max="20" value="8">
            </div>

            <div class="control-group">
                <label>Edge Density: <span id="densityVal" class="value">Medium</span></label>
                <input type="range" id="edgeDensity" min="1" max="3" value="2">
            </div>

            <button class="primary" id="newGameBtn">New Graph</button>
            <button class="secondary" id="shuffleBtn">Shuffle Nodes</button>
            <button class="secondary" id="hintBtn">Show Hint</button>

            <div class="stats">
                <div>Crossings: <span id="crossings" class="stat-value">0</span></div>
                <div>Moves: <span id="moves" class="stat-value">0</span></div>
                <div>Time: <span id="time" class="stat-value">0:00</span></div>
                <div id="status"></div>
            </div>

            <p class="hint">Tip: Try to identify which edges are crossing and move the endpoints to uncross them.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        let nodes = [];
        let edges = [];
        let dragging = null;
        let dragOffset = { x: 0, y: 0 };
        let moves = 0;
        let startTime = null;
        let solved = false;

        const nodeCountSlider = document.getElementById('nodeCount');
        const edgeDensitySlider = document.getElementById('edgeDensity');
        const newGameBtn = document.getElementById('newGameBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const hintBtn = document.getElementById('hintBtn');

        const NODE_RADIUS = 15;

        function generatePlanarGraph(n, density) {
            nodes = [];
            edges = [];

            // Generate nodes in a planar arrangement first (circle)
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                const r = Math.min(W, H) * 0.35;
                nodes.push({
                    id: i,
                    x: W / 2 + Math.cos(angle) * r,
                    y: H / 2 + Math.sin(angle) * r,
                    originalX: W / 2 + Math.cos(angle) * r,
                    originalY: H / 2 + Math.sin(angle) * r
                });
            }

            // Generate edges (ensure planarity by connecting neighbors)
            // Connect in a cycle first
            for (let i = 0; i < n; i++) {
                edges.push([i, (i + 1) % n]);
            }

            // Add chords carefully based on density
            const maxChords = Math.floor(n * density * 0.5);
            let attempts = 0;
            let chords = 0;

            while (chords < maxChords && attempts < n * n) {
                const a = Math.floor(Math.random() * n);
                let b = Math.floor(Math.random() * n);

                // Ensure b is not adjacent to a
                if (Math.abs(a - b) <= 1 || Math.abs(a - b) >= n - 1) {
                    attempts++;
                    continue;
                }

                // Check if edge already exists
                const exists = edges.some(e =>
                    (e[0] === a && e[1] === b) || (e[0] === b && e[1] === a)
                );

                if (!exists) {
                    edges.push([a, b]);
                    chords++;
                }
                attempts++;
            }
        }

        function shuffleNodes() {
            // Randomize node positions
            nodes.forEach(node => {
                node.x = Math.random() * (W - 100) + 50;
                node.y = Math.random() * (H - 100) + 50;
            });
            moves = 0;
            startTime = Date.now();
            solved = false;
            updateStats();
        }

        function lineIntersects(x1, y1, x2, y2, x3, y3, x4, y4) {
            // Check if line segment (x1,y1)-(x2,y2) intersects (x3,y3)-(x4,y4)
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 0.0001) return false;

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

            // Must be strictly inside segments (not at endpoints)
            return ua > 0.01 && ua < 0.99 && ub > 0.01 && ub < 0.99;
        }

        function countCrossings() {
            let count = 0;
            for (let i = 0; i < edges.length; i++) {
                for (let j = i + 1; j < edges.length; j++) {
                    const e1 = edges[i];
                    const e2 = edges[j];

                    // Skip if edges share a vertex
                    if (e1[0] === e2[0] || e1[0] === e2[1] ||
                        e1[1] === e2[0] || e1[1] === e2[1]) continue;

                    const n1a = nodes[e1[0]];
                    const n1b = nodes[e1[1]];
                    const n2a = nodes[e2[0]];
                    const n2b = nodes[e2[1]];

                    if (lineIntersects(n1a.x, n1a.y, n1b.x, n1b.y,
                                       n2a.x, n2a.y, n2b.x, n2b.y)) {
                        count++;
                    }
                }
            }
            return count;
        }

        function findCrossingEdges() {
            const crossingEdges = new Set();
            for (let i = 0; i < edges.length; i++) {
                for (let j = i + 1; j < edges.length; j++) {
                    const e1 = edges[i];
                    const e2 = edges[j];

                    if (e1[0] === e2[0] || e1[0] === e2[1] ||
                        e1[1] === e2[0] || e1[1] === e2[1]) continue;

                    const n1a = nodes[e1[0]];
                    const n1b = nodes[e1[1]];
                    const n2a = nodes[e2[0]];
                    const n2b = nodes[e2[1]];

                    if (lineIntersects(n1a.x, n1a.y, n1b.x, n1b.y,
                                       n2a.x, n2a.y, n2b.x, n2b.y)) {
                        crossingEdges.add(i);
                        crossingEdges.add(j);
                    }
                }
            }
            return crossingEdges;
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            for (let i = 0; i < W; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, H);
                ctx.stroke();
            }
            for (let i = 0; i < H; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(W, i);
                ctx.stroke();
            }

            const crossingEdges = findCrossingEdges();

            // Draw edges
            edges.forEach((edge, idx) => {
                const n1 = nodes[edge[0]];
                const n2 = nodes[edge[1]];

                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.lineTo(n2.x, n2.y);

                if (crossingEdges.has(idx)) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = solved ? '#2ecc71' : '#4ecdc4';
                    ctx.lineWidth = 2;
                }
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach((node, idx) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);

                if (dragging === idx) {
                    ctx.fillStyle = '#f39c12';
                } else if (solved) {
                    ctx.fillStyle = '#2ecc71';
                } else {
                    ctx.fillStyle = '#4ecdc4';
                }
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw node number
                ctx.fillStyle = '#1a1a2e';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(idx + 1, node.x, node.y);
            });
        }

        function updateStats() {
            const crossings = countCrossings();
            document.getElementById('crossings').textContent = crossings;
            document.getElementById('moves').textContent = moves;

            if (startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                document.getElementById('time').textContent =
                    `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            const statusEl = document.getElementById('status');
            if (crossings === 0) {
                if (!solved) {
                    solved = true;
                    statusEl.innerHTML = '<span class="solved">SOLVED!</span>';
                }
            } else {
                solved = false;
                statusEl.textContent = '';
            }

            document.getElementById('nodesVal').textContent = nodeCountSlider.value;
            const densities = ['Sparse', 'Medium', 'Dense'];
            document.getElementById('densityVal').textContent =
                densities[edgeDensitySlider.value - 1];
        }

        function getNodeAt(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const dx = x - node.x;
                const dy = y - node.y;
                if (dx * dx + dy * dy <= NODE_RADIUS * NODE_RADIUS) {
                    return i;
                }
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const nodeIdx = getNodeAt(x, y);
            if (nodeIdx !== null) {
                dragging = nodeIdx;
                dragOffset.x = nodes[nodeIdx].x - x;
                dragOffset.y = nodes[nodeIdx].y - y;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (dragging !== null) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                nodes[dragging].x = Math.max(NODE_RADIUS,
                    Math.min(W - NODE_RADIUS, x + dragOffset.x));
                nodes[dragging].y = Math.max(NODE_RADIUS,
                    Math.min(H - NODE_RADIUS, y + dragOffset.y));

                draw();
                updateStats();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (dragging !== null) {
                moves++;
                dragging = null;
                updateStats();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (dragging !== null) {
                moves++;
                dragging = null;
                updateStats();
            }
        });

        newGameBtn.addEventListener('click', () => {
            generatePlanarGraph(
                parseInt(nodeCountSlider.value),
                parseInt(edgeDensitySlider.value)
            );
            shuffleNodes();
            draw();
        });

        shuffleBtn.addEventListener('click', () => {
            shuffleNodes();
            draw();
        });

        hintBtn.addEventListener('click', () => {
            // Highlight the solution briefly by showing original positions
            const originalPositions = nodes.map(n => ({ x: n.x, y: n.y }));

            // Move to planar positions
            nodes.forEach(node => {
                node.x = node.originalX;
                node.y = node.originalY;
            });
            draw();

            // Restore after 2 seconds
            setTimeout(() => {
                nodes.forEach((node, i) => {
                    node.x = originalPositions[i].x;
                    node.y = originalPositions[i].y;
                });
                draw();
            }, 2000);
        });

        // Timer update
        setInterval(() => {
            if (startTime && !solved) {
                updateStats();
            }
        }, 1000);

        // Initialize
        generatePlanarGraph(8, 2);
        shuffleNodes();
        draw();
    </script>
</body>
</html>
