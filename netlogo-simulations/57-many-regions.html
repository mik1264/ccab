<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Many Regions - Comparative Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
            display: flex;
        }
        .sidebar {
            width: 300px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main { flex: 1; display: flex; flex-direction: column; overflow-y: auto; }
        h1 { font-size: 1.4em; margin-bottom: 5px; color: #fab1a0; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 20px; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { font-size: 0.8em; color: #fab1a0; }
        .buttons { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px; }
        button { padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9em; }
        .btn-primary { background: #fab1a0; color: #000; }
        .btn-secondary { background: #444; color: #fff; }
        .btn-danger { background: #e74c3c; color: #fff; }
        .stats { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .stats h3 { font-size: 0.9em; color: #fab1a0; margin-bottom: 10px; }
        .stat-row { display: flex; justify-content: space-between; font-size: 0.85em; margin-bottom: 5px; }
        .stat-value { color: #fab1a0; }
        .canvas-container { flex: 1; display: flex; flex-wrap: wrap; justify-content: center; align-content: flex-start; gap: 15px; padding: 20px; }
        .region-container { display: flex; flex-direction: column; align-items: center; }
        .region-label { font-size: 0.8em; color: #888; margin-bottom: 5px; }
        canvas { background: #0a0a1a; border-radius: 8px; }
        .back-link { display: inline-block; color: #fab1a0; text-decoration: none; margin-bottom: 20px; font-size: 0.9em; }
        .info { font-size: 0.75em; color: #666; line-height: 1.5; margin-top: 10px; }
        .model-select { width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #444; background: #2a2a3e; color: #fff; margin-bottom: 10px; }
        .param-variation { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; margin-top: 10px; }
        .param-variation h4 { font-size: 0.8em; color: #aaa; margin-bottom: 8px; }
        .param-row { display: flex; justify-content: space-between; font-size: 0.75em; margin: 3px 0; }
    </style>
</head>
<body>
    <div class="sidebar">
        <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
        <h1>Many Regions</h1>
        <p class="subtitle">Comparative Dynamics</p>

        <div class="buttons">
            <button class="btn-primary" id="startBtn">Start</button>
            <button class="btn-secondary" id="stepBtn">Step</button>
            <button class="btn-danger" id="resetBtn">Reset</button>
        </div>

        <div class="control-group">
            <label>Model Type</label>
            <select class="model-select" id="modelType">
                <option value="sir">SIR Epidemic</option>
                <option value="predprey">Predator-Prey</option>
                <option value="diffusion">Diffusion</option>
                <option value="segregation">Segregation</option>
            </select>
        </div>

        <div class="control-group">
            <label>Number of Regions: <span class="value" id="regionsVal">4</span></label>
            <input type="range" id="numRegions" min="2" max="9" value="4">
        </div>

        <div class="control-group">
            <label>Parameter to Vary</label>
            <select class="model-select" id="varyParam">
                <option value="rate">Rate/Speed</option>
                <option value="density">Density</option>
                <option value="threshold">Threshold</option>
            </select>
        </div>

        <div class="control-group">
            <label>Variation Range: <span class="value" id="rangeVal">0.1 - 0.9</span></label>
            <input type="range" id="varRange" min="20" max="80" value="50">
        </div>

        <div class="stats">
            <h3>Global Statistics</h3>
            <div class="stat-row"><span>Time:</span><span class="stat-value" id="time">0</span></div>
            <div class="stat-row"><span>Total Population:</span><span class="stat-value" id="totalPop">0</span></div>
            <div class="stat-row"><span>Max Difference:</span><span class="stat-value" id="maxDiff">0</span></div>
        </div>

        <div class="param-variation">
            <h4>Parameter Values by Region</h4>
            <div id="paramList"></div>
        </div>

        <p class="info">
            Compare identical simulations with varying parameters across regions.
            Observe how small parameter changes lead to different emergent behaviors.
        </p>
    </div>

    <div class="main">
        <div class="canvas-container" id="container"></div>
    </div>

    <script>
        const container = document.getElementById('container');
        let regions = [], running = false, time = 0;
        let numRegions = 4, modelType = 'sir', varyParam = 'rate';
        const COLORS = ['#fab1a0', '#74b9ff', '#55efc4', '#ffeaa7', '#a29bfe', '#fd79a8', '#00cec9', '#e17055', '#6c5ce7'];

        class Region {
            constructor(index, param, canvasSize) {
                this.index = index;
                this.param = param;
                this.size = canvasSize;
                this.grid = [];
                this.gridSize = 40;
                this.cellSize = canvasSize / this.gridSize;
                this.createCanvas();
                this.init();
            }

            createCanvas() {
                const div = document.createElement('div');
                div.className = 'region-container';
                const label = document.createElement('div');
                label.className = 'region-label';
                label.textContent = `Region ${this.index + 1} (${this.param.toFixed(2)})`;
                this.labelEl = label;
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.size;
                this.canvas.height = this.size;
                this.ctx = this.canvas.getContext('2d');
                div.appendChild(label);
                div.appendChild(this.canvas);
                container.appendChild(div);
                this.containerEl = div;
            }

            init() {
                this.grid = [];
                for (let i = 0; i < this.gridSize; i++) {
                    this.grid[i] = [];
                    for (let j = 0; j < this.gridSize; j++) {
                        this.grid[i][j] = this.initCell(i, j);
                    }
                }
            }

            initCell(i, j) {
                switch (modelType) {
                    case 'sir':
                        if (i === Math.floor(this.gridSize / 2) && j === Math.floor(this.gridSize / 2)) return 1; // Infected
                        return 0; // Susceptible
                    case 'predprey':
                        const r = Math.random();
                        if (r < 0.3) return 1; // Prey
                        if (r < 0.35) return 2; // Predator
                        return 0; // Empty
                    case 'diffusion':
                        return i < this.gridSize / 4 ? 1 : 0;
                    case 'segregation':
                        const rr = Math.random();
                        if (rr < 0.4) return 1;
                        if (rr < 0.8) return 2;
                        return 0;
                }
                return 0;
            }

            update() {
                const newGrid = this.grid.map(row => [...row]);

                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        newGrid[i][j] = this.updateCell(i, j);
                    }
                }

                this.grid = newGrid;
            }

            getNeighbors(x, y) {
                const neighbors = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + this.gridSize) % this.gridSize;
                        const ny = (y + dy + this.gridSize) % this.gridSize;
                        neighbors.push(this.grid[nx][ny]);
                    }
                }
                return neighbors;
            }

            updateCell(i, j) {
                const current = this.grid[i][j];
                const neighbors = this.getNeighbors(i, j);

                switch (modelType) {
                    case 'sir': // SIR model
                        if (current === 0) { // Susceptible
                            const infected = neighbors.filter(n => n === 1).length;
                            return infected > 0 && Math.random() < this.param * 0.3 ? 1 : 0;
                        } else if (current === 1) { // Infected
                            return Math.random() < 0.1 ? 2 : 1; // Recover
                        }
                        return current; // Recovered stays recovered

                    case 'predprey':
                        if (current === 0) { // Empty
                            const prey = neighbors.filter(n => n === 1).length;
                            return prey >= 2 && Math.random() < this.param * 0.2 ? 1 : 0;
                        } else if (current === 1) { // Prey
                            const predators = neighbors.filter(n => n === 2).length;
                            return predators > 0 && Math.random() < 0.3 ? 0 : 1;
                        } else { // Predator
                            const prey = neighbors.filter(n => n === 1).length;
                            if (prey === 0) return Math.random() < 0.1 ? 0 : 2; // Starve
                            return Math.random() < this.param * 0.15 ? 2 : 2;
                        }

                    case 'diffusion':
                        if (current === 0) {
                            const filled = neighbors.filter(n => n === 1).length;
                            return Math.random() < filled * this.param * 0.1 ? 1 : 0;
                        }
                        return Math.random() < 0.01 ? 0 : 1;

                    case 'segregation':
                        if (current === 0) return 0;
                        const sameType = neighbors.filter(n => n === current).length;
                        const others = neighbors.filter(n => n !== 0 && n !== current).length;
                        if (sameType + others === 0) return current;
                        const ratio = sameType / (sameType + others);
                        if (ratio < this.param) {
                            // Move to empty neighbor
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const nx = (i + dx + this.gridSize) % this.gridSize;
                                    const ny = (j + dy + this.gridSize) % this.gridSize;
                                    if (this.grid[nx][ny] === 0) {
                                        return 0;
                                    }
                                }
                            }
                        }
                        return current;
                }
                return current;
            }

            draw() {
                this.ctx.fillStyle = '#0a0a1a';
                this.ctx.fillRect(0, 0, this.size, this.size);

                const colors = {
                    sir: ['#2d3436', '#e74c3c', '#55efc4'],
                    predprey: ['#2d3436', '#55efc4', '#e74c3c'],
                    diffusion: ['#2d3436', '#74b9ff'],
                    segregation: ['#2d3436', '#fab1a0', '#a29bfe']
                };

                const palette = colors[modelType];

                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const state = this.grid[i][j];
                        if (state > 0) {
                            this.ctx.fillStyle = palette[state] || '#fff';
                            this.ctx.fillRect(i * this.cellSize, j * this.cellSize, this.cellSize, this.cellSize);
                        }
                    }
                }
            }

            getPopulation() {
                let count = 0;
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.grid[i][j] > 0) count++;
                    }
                }
                return count;
            }

            destroy() {
                this.containerEl.remove();
            }
        }

        function createRegions() {
            regions.forEach(r => r.destroy());
            regions = [];
            container.innerHTML = '';

            const rangeVal = parseInt(document.getElementById('varRange').value) / 100;
            const minParam = 0.5 - rangeVal;
            const maxParam = 0.5 + rangeVal;

            const cols = Math.ceil(Math.sqrt(numRegions));
            const containerWidth = container.clientWidth;
            const canvasSize = Math.floor((containerWidth - (cols + 1) * 15) / cols);

            const paramList = document.getElementById('paramList');
            paramList.innerHTML = '';

            for (let i = 0; i < numRegions; i++) {
                const param = minParam + (maxParam - minParam) * (i / (numRegions - 1 || 1));
                regions.push(new Region(i, param, Math.min(canvasSize, 200)));

                const row = document.createElement('div');
                row.className = 'param-row';
                row.innerHTML = `<span>Region ${i + 1}:</span><span style="color:${COLORS[i]}">${param.toFixed(3)}</span>`;
                paramList.appendChild(row);
            }

            document.getElementById('rangeVal').textContent = `${minParam.toFixed(2)} - ${maxParam.toFixed(2)}`;
        }

        function update() {
            time++;
            regions.forEach(r => r.update());
        }

        function draw() {
            regions.forEach(r => r.draw());
        }

        function updateStats() {
            const pops = regions.map(r => r.getPopulation());
            document.getElementById('time').textContent = time;
            document.getElementById('totalPop').textContent = pops.reduce((a, b) => a + b, 0);
            document.getElementById('maxDiff').textContent = Math.max(...pops) - Math.min(...pops);
        }

        function animate() {
            if (running) update();
            draw();
            updateStats();
            requestAnimationFrame(animate);
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            time = 0;
            numRegions = parseInt(document.getElementById('numRegions').value);
            modelType = document.getElementById('modelType').value;
            varyParam = document.getElementById('varyParam').value;
            createRegions();
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });
        document.getElementById('stepBtn').addEventListener('click', () => { if (!running) update(); });
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('numRegions').addEventListener('input', (e) => {
            document.getElementById('regionsVal').textContent = e.target.value;
        });
        document.getElementById('modelType').addEventListener('change', reset);
        document.getElementById('varyParam').addEventListener('change', reset);
        document.getElementById('varRange').addEventListener('input', reset);

        window.addEventListener('resize', () => { if (!running) createRegions(); });
        reset();
        animate();
    </script>
</body>
</html>
