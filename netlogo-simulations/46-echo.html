<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo - Complex Adaptive System - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #simCanvas { flex: 2; }
        #graphCanvas { flex: 1; border-top: 1px solid #333; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #a855f7; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #9333ea; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #7e22ce; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #a855f7; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Echo Model</h1>
            <p class="description">John Holland's complex adaptive system. Agents gather resources, trade, combat, and evolve. Watch species emerge and adapt.</p>
            
            <div class="control-group">
                <label>Initial Agents: <span id="agentsVal">50</span></label>
                <input type="range" id="agents" min="20" max="100" value="50">
            </div>
            <div class="control-group">
                <label>Resource Density: <span id="resourceVal">0.3</span></label>
                <input type="range" id="resource" min="0.1" max="0.6" step="0.05" value="0.3">
            </div>
            <div class="control-group">
                <label>Combat Rate: <span id="combatVal">0.2</span></label>
                <input type="range" id="combat" min="0" max="0.5" step="0.05" value="0.2">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationVal">0.05</span></label>
                <input type="range" id="mutation" min="0" max="0.2" step="0.01" value="0.05">
            </div>
            <div class="control-group">
                <label>Trade Probability: <span id="tradeVal">0.3</span></label>
                <input type="range" id="trade" min="0" max="0.6" step="0.05" value="0.3">
            </div>
            
            <button id="reset">Reset</button>
            <button id="pause">Pause</button>
            
            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Population: <span id="population">0</span></div>
                <div>Species: <span id="species">0</span></div>
                <div>Avg Fitness: <span id="fitness">0</span></div>
                <div>Total Resources: <span id="resources">0</span></div>
            </div>
            
            <p class="description"><strong>Genome:</strong> Each agent has genes for offense, defense, resource preference, and metabolism. Children inherit with mutation.</p>
            
            <p class="description"><strong>Fitness:</strong> Agents with more resources reproduce. Those with low resources die.</p>
        </div>
    </div>
    <script>
        const simCanvas = document.getElementById('simCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const sctx = simCanvas.getContext('2d');
        const gctx = graphCanvas.getContext('2d');
        
        let W, H, GW, GH;
        let agents = [], resources = [], paused = false;
        let generation = 0;
        let history = [];
        
        const RESOURCE_TYPES = ['red', 'green', 'blue'];
        const typeColors = { red: '#ef4444', green: '#22c55e', blue: '#3b82f6' };
        
        let params = {
            agentCount: 50,
            resourceDensity: 0.3,
            combatRate: 0.2,
            mutationRate: 0.05,
            tradeProbability: 0.3
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            simCanvas.width = c.clientWidth;
            simCanvas.height = c.clientHeight * 0.65;
            graphCanvas.width = c.clientWidth;
            graphCanvas.height = c.clientHeight * 0.35;
            W = simCanvas.width;
            H = simCanvas.height;
            GW = graphCanvas.width;
            GH = graphCanvas.height;
        }
        
        function randomGenome() {
            return {
                offense: Math.random(),
                defense: Math.random(),
                preference: RESOURCE_TYPES[Math.floor(Math.random() * 3)],
                metabolism: 0.3 + Math.random() * 0.4,
                tradeWillingness: Math.random(),
                color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`
            };
        }
        
        function mutateGenome(genome) {
            const g = { ...genome };
            
            if (Math.random() < params.mutationRate) {
                g.offense = Math.max(0, Math.min(1, g.offense + (Math.random() - 0.5) * 0.2));
            }
            if (Math.random() < params.mutationRate) {
                g.defense = Math.max(0, Math.min(1, g.defense + (Math.random() - 0.5) * 0.2));
            }
            if (Math.random() < params.mutationRate) {
                g.preference = RESOURCE_TYPES[Math.floor(Math.random() * 3)];
            }
            if (Math.random() < params.mutationRate) {
                g.metabolism = Math.max(0.1, Math.min(0.9, g.metabolism + (Math.random() - 0.5) * 0.1));
            }
            if (Math.random() < params.mutationRate) {
                g.tradeWillingness = Math.max(0, Math.min(1, g.tradeWillingness + (Math.random() - 0.5) * 0.2));
            }
            if (Math.random() < params.mutationRate * 0.5) {
                const h = parseInt(g.color.match(/\d+/)[0]);
                g.color = `hsl(${(h + Math.floor((Math.random() - 0.5) * 30) + 360) % 360}, 70%, 50%)`;
            }
            
            return g;
        }
        
        function init() {
            resize();
            agents = [];
            resources = [];
            generation = 0;
            history = [];
            
            // Create agents
            for (let i = 0; i < params.agentCount; i++) {
                agents.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: 0,
                    vy: 0,
                    genome: randomGenome(),
                    inventory: { red: 1, green: 1, blue: 1 },
                    energy: 50,
                    age: 0
                });
            }
            
            // Spawn resources
            spawnResources();
            
            updateStats();
        }
        
        function spawnResources() {
            const count = Math.floor(W * H * params.resourceDensity / 1000);
            for (let i = resources.length; i < count; i++) {
                resources.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    type: RESOURCE_TYPES[Math.floor(Math.random() * 3)],
                    amount: 2 + Math.floor(Math.random() * 5)
                });
            }
        }
        
        function distance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function step() {
            generation++;
            
            // Spawn new resources
            if (Math.random() < 0.2) {
                spawnResources();
            }
            
            // Update each agent
            for (let i = agents.length - 1; i >= 0; i--) {
                const agent = agents[i];
                agent.age++;
                
                // Metabolic cost
                agent.energy -= agent.genome.metabolism * 0.5;
                
                // Movement toward preferred resource
                let targetX = agent.x, targetY = agent.y;
                let nearestDist = Infinity;
                
                for (const res of resources) {
                    if (res.type === agent.genome.preference) {
                        const d = distance(agent, res);
                        if (d < nearestDist) {
                            nearestDist = d;
                            targetX = res.x;
                            targetY = res.y;
                        }
                    }
                }
                
                // Move toward target
                if (nearestDist < Infinity) {
                    const dx = targetX - agent.x;
                    const dy = targetY - agent.y;
                    const d = Math.sqrt(dx * dx + dy * dy);
                    if (d > 1) {
                        agent.vx += (dx / d) * 0.5;
                        agent.vy += (dy / d) * 0.5;
                    }
                }
                
                // Random movement
                agent.vx += (Math.random() - 0.5) * 0.3;
                agent.vy += (Math.random() - 0.5) * 0.3;
                
                // Damping
                agent.vx *= 0.9;
                agent.vy *= 0.9;
                
                // Apply velocity
                agent.x += agent.vx;
                agent.y += agent.vy;
                
                // Boundaries
                agent.x = Math.max(10, Math.min(W - 10, agent.x));
                agent.y = Math.max(10, Math.min(H - 10, agent.y));
                
                // Gather resources
                for (let j = resources.length - 1; j >= 0; j--) {
                    const res = resources[j];
                    if (distance(agent, res) < 20) {
                        const gather = Math.min(res.amount, 2);
                        agent.inventory[res.type] += gather;
                        agent.energy += gather * 5;
                        res.amount -= gather;
                        if (res.amount <= 0) {
                            resources.splice(j, 1);
                        }
                    }
                }
                
                // Trade with nearby agents
                for (const other of agents) {
                    if (other === agent) continue;
                    if (distance(agent, other) < 30) {
                        if (Math.random() < params.tradeProbability * agent.genome.tradeWillingness * other.genome.tradeWillingness) {
                            // Find trade that benefits both
                            const myExcess = Object.entries(agent.inventory).find(([t, a]) => a > 3 && t !== agent.genome.preference);
                            const theirExcess = Object.entries(other.inventory).find(([t, a]) => a > 3 && t !== other.genome.preference);
                            
                            if (myExcess && theirExcess && myExcess[0] !== theirExcess[0]) {
                                agent.inventory[myExcess[0]]--;
                                agent.inventory[theirExcess[0]]++;
                                other.inventory[theirExcess[0]]--;
                                other.inventory[myExcess[0]]++;
                            }
                        }
                    }
                }
                
                // Combat
                for (let j = agents.length - 1; j >= 0; j--) {
                    if (i === j) continue;
                    const other = agents[j];
                    if (distance(agent, other) < 25 && Math.random() < params.combatRate) {
                        const myPower = agent.genome.offense * agent.energy * 0.1;
                        const theirPower = other.genome.defense * other.energy * 0.1;
                        
                        if (myPower > theirPower) {
                            // Win: steal resources
                            for (const type of RESOURCE_TYPES) {
                                const steal = Math.floor(other.inventory[type] / 2);
                                agent.inventory[type] += steal;
                                other.inventory[type] -= steal;
                            }
                            agent.energy += 10;
                            other.energy -= 20;
                        }
                    }
                }
                
                // Death
                if (agent.energy <= 0 || (agent.age > 500 && Math.random() < 0.01)) {
                    agents.splice(i, 1);
                    continue;
                }
                
                // Reproduction
                const totalRes = agent.inventory.red + agent.inventory.green + agent.inventory.blue;
                if (agent.energy > 80 && totalRes > 10 && Math.random() < 0.02) {
                    const childGenome = mutateGenome(agent.genome);
                    agents.push({
                        x: agent.x + (Math.random() - 0.5) * 40,
                        y: agent.y + (Math.random() - 0.5) * 40,
                        vx: 0,
                        vy: 0,
                        genome: childGenome,
                        inventory: { red: 1, green: 1, blue: 1 },
                        energy: 30,
                        age: 0
                    });
                    agent.energy -= 25;
                    for (const type of RESOURCE_TYPES) {
                        agent.inventory[type] = Math.floor(agent.inventory[type] / 2);
                    }
                }
            }
            
            // Track history
            if (generation % 10 === 0) {
                history.push({
                    generation: generation,
                    population: agents.length,
                    avgFitness: agents.reduce((s, a) => s + a.energy, 0) / Math.max(1, agents.length)
                });
                if (history.length > 100) history.shift();
            }
            
            updateStats();
        }
        
        function countSpecies() {
            // Group by color similarity
            const buckets = {};
            for (const agent of agents) {
                const hue = parseInt(agent.genome.color.match(/\d+/)[0]);
                const bucket = Math.floor(hue / 30);
                buckets[bucket] = (buckets[bucket] || 0) + 1;
            }
            return Object.keys(buckets).length;
        }
        
        function updateStats() {
            const totalResources = resources.reduce((s, r) => s + r.amount, 0);
            const avgFitness = agents.reduce((s, a) => s + a.energy, 0) / Math.max(1, agents.length);
            
            document.getElementById('generation').textContent = generation;
            document.getElementById('population').textContent = agents.length;
            document.getElementById('species').textContent = countSpecies();
            document.getElementById('fitness').textContent = avgFitness.toFixed(1);
            document.getElementById('resources').textContent = totalResources;
        }
        
        function drawSim() {
            // Background
            sctx.fillStyle = '#0f1729';
            sctx.fillRect(0, 0, W, H);
            
            // Resources
            for (const res of resources) {
                sctx.fillStyle = typeColors[res.type];
                const size = 3 + res.amount;
                sctx.beginPath();
                sctx.arc(res.x, res.y, size, 0, Math.PI * 2);
                sctx.fill();
            }
            
            // Agents
            for (const agent of agents) {
                const size = 6 + Math.min(8, agent.energy / 20);
                
                // Body
                sctx.fillStyle = agent.genome.color;
                sctx.beginPath();
                sctx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
                sctx.fill();
                
                // Offense/defense indicator
                sctx.strokeStyle = agent.genome.offense > agent.genome.defense ? '#ff6b6b' : '#4ecdc4';
                sctx.lineWidth = 2;
                sctx.stroke();
                
                // Preferred resource dot
                sctx.fillStyle = typeColors[agent.genome.preference];
                sctx.beginPath();
                sctx.arc(agent.x, agent.y, 3, 0, Math.PI * 2);
                sctx.fill();
            }
            
            // Info
            sctx.fillStyle = '#a855f7';
            sctx.font = 'bold 14px sans-serif';
            sctx.fillText(`Echo Model - Generation ${generation}`, 20, 25);
            sctx.font = '11px sans-serif';
            sctx.fillStyle = '#888';
            sctx.fillText(`Population: ${agents.length} | Species: ${countSpecies()}`, 20, 42);
        }
        
        function drawGraph() {
            gctx.fillStyle = '#0a0f1a';
            gctx.fillRect(0, 0, GW, GH);
            
            if (history.length < 2) return;
            
            const margin = { left: 50, right: 20, top: 30, bottom: 30 };
            const graphW = GW - margin.left - margin.right;
            const graphH = GH - margin.top - margin.bottom;
            
            // Axes
            gctx.strokeStyle = '#333';
            gctx.beginPath();
            gctx.moveTo(margin.left, margin.top);
            gctx.lineTo(margin.left, GH - margin.bottom);
            gctx.lineTo(GW - margin.right, GH - margin.bottom);
            gctx.stroke();
            
            gctx.fillStyle = '#666';
            gctx.font = '11px sans-serif';
            gctx.fillText('Population & Fitness Over Time', margin.left, margin.top - 10);
            
            const minGen = history[0].generation;
            const maxGen = history[history.length - 1].generation;
            const maxPop = Math.max(...history.map(h => h.population), 10);
            const maxFit = Math.max(...history.map(h => h.avgFitness), 10);
            
            // Population line
            gctx.strokeStyle = '#a855f7';
            gctx.lineWidth = 2;
            gctx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const x = margin.left + ((history[i].generation - minGen) / (maxGen - minGen)) * graphW;
                const y = GH - margin.bottom - (history[i].population / maxPop) * graphH;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            }
            gctx.stroke();
            
            // Fitness line
            gctx.strokeStyle = '#22c55e';
            gctx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const x = margin.left + ((history[i].generation - minGen) / (maxGen - minGen)) * graphW;
                const y = GH - margin.bottom - (history[i].avgFitness / maxFit) * graphH;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            }
            gctx.stroke();
            
            // Legend
            gctx.fillStyle = '#a855f7';
            gctx.fillRect(GW - 100, margin.top, 12, 12);
            gctx.fillStyle = '#888';
            gctx.fillText('Population', GW - 85, margin.top + 10);
            
            gctx.fillStyle = '#22c55e';
            gctx.fillRect(GW - 100, margin.top + 18, 12, 12);
            gctx.fillStyle = '#888';
            gctx.fillText('Fitness', GW - 85, margin.top + 28);
        }
        
        function draw() {
            drawSim();
            drawGraph();
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    step();
                }
            }, 50);
        }
        
        // Event listeners
        document.getElementById('agents').addEventListener('input', e => {
            params.agentCount = +e.target.value;
            document.getElementById('agentsVal').textContent = params.agentCount;
        });
        document.getElementById('resource').addEventListener('input', e => {
            params.resourceDensity = +e.target.value;
            document.getElementById('resourceVal').textContent = params.resourceDensity.toFixed(2);
        });
        document.getElementById('combat').addEventListener('input', e => {
            params.combatRate = +e.target.value;
            document.getElementById('combatVal').textContent = params.combatRate.toFixed(2);
        });
        document.getElementById('mutation').addEventListener('input', e => {
            params.mutationRate = +e.target.value;
            document.getElementById('mutationVal').textContent = params.mutationRate.toFixed(2);
        });
        document.getElementById('trade').addEventListener('input', e => {
            params.tradeProbability = +e.target.value;
            document.getElementById('tradeVal').textContent = params.tradeProbability.toFixed(2);
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
