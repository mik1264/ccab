<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Change - Linguistic Evolution - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #simCanvas { flex: 2; }
        #graphCanvas { flex: 1; border-top: 1px solid #333; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #8b5cf6; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #7c3aed; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #6d28d9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #8b5cf6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .word-display { font-family: monospace; font-size: 0.8rem; background: rgba(139, 92, 246, 0.2); padding: 8px; border-radius: 5px; margin-bottom: 10px; max-height: 100px; overflow-y: auto; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Language Change</h1>
            <p class="description">Words evolve through copying errors and social transmission. Watch language families diverge as groups become isolated.</p>
            
            <div class="control-group">
                <label>Population: <span id="popVal">50</span></label>
                <input type="range" id="pop" min="20" max="100" value="50">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationVal">0.05</span></label>
                <input type="range" id="mutation" min="0" max="0.2" step="0.01" value="0.05">
            </div>
            <div class="control-group">
                <label>Interaction Range: <span id="rangeVal">60</span></label>
                <input type="range" id="range" min="30" max="150" value="60">
            </div>
            <div class="control-group">
                <label>Regions: <span id="regionsVal">3</span></label>
                <input type="range" id="regions" min="1" max="6" value="3">
            </div>
            <div class="control-group">
                <label>Barrier Strength: <span id="barrierVal">0.5</span></label>
                <input type="range" id="barrier" min="0" max="1" step="0.1" value="0.5">
            </div>
            
            <button id="reset">Reset</button>
            <button id="pause">Pause</button>
            <button id="addBarrier">Add Geographic Barrier</button>
            
            <div class="stats">
                <div>Generations: <span id="generations">0</span></div>
                <div>Language Families: <span id="families">0</span></div>
                <div>Avg. Divergence: <span id="divergence">0</span>%</div>
                <div>Most Common Word: <span id="common">-</span></div>
            </div>
            
            <div class="word-display" id="wordSamples">
                Sample words will appear here...
            </div>
            
            <p class="description"><strong>Drift:</strong> Random mutations accumulate. <strong>Barriers:</strong> Reduce contact between regions, accelerating divergence.</p>
        </div>
    </div>
    <script>
        const simCanvas = document.getElementById('simCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const sctx = simCanvas.getContext('2d');
        const gctx = graphCanvas.getContext('2d');
        
        let W, H, GW, GH;
        let agents = [], barriers = [], paused = false;
        let generation = 0;
        let divergenceHistory = [];
        
        const VOWELS = 'aeiou';
        const CONSONANTS = 'bcdfghjklmnprstvwxyz';
        const originalWord = 'kala'; // Proto-word meaning "fish"
        
        const regionColors = ['#ef4444', '#22c55e', '#3b82f6', '#f59e0b', '#ec4899', '#06b6d4'];
        
        let params = {
            population: 50,
            mutationRate: 0.05,
            interactionRange: 60,
            regions: 3,
            barrierStrength: 0.5
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            simCanvas.width = c.clientWidth;
            simCanvas.height = c.clientHeight * 0.65;
            graphCanvas.width = c.clientWidth;
            graphCanvas.height = c.clientHeight * 0.35;
            W = simCanvas.width;
            H = simCanvas.height;
            GW = graphCanvas.width;
            GH = graphCanvas.height;
        }
        
        function mutateWord(word) {
            if (Math.random() > params.mutationRate) return word;
            
            const chars = word.split('');
            const idx = Math.floor(Math.random() * chars.length);
            const mutations = ['substitute', 'insert', 'delete', 'swap'];
            const mutation = mutations[Math.floor(Math.random() * mutations.length)];
            
            const isVowel = VOWELS.includes(chars[idx]);
            const charSet = isVowel ? VOWELS : CONSONANTS;
            
            switch (mutation) {
                case 'substitute':
                    chars[idx] = charSet[Math.floor(Math.random() * charSet.length)];
                    break;
                case 'insert':
                    if (chars.length < 8) {
                        const newChar = Math.random() < 0.4 ? 
                            VOWELS[Math.floor(Math.random() * VOWELS.length)] :
                            CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];
                        chars.splice(idx, 0, newChar);
                    }
                    break;
                case 'delete':
                    if (chars.length > 2) {
                        chars.splice(idx, 1);
                    }
                    break;
                case 'swap':
                    if (idx < chars.length - 1) {
                        [chars[idx], chars[idx + 1]] = [chars[idx + 1], chars[idx]];
                    }
                    break;
            }
            
            return chars.join('');
        }
        
        function wordDistance(w1, w2) {
            // Levenshtein distance
            const m = w1.length, n = w2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;
            
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (w1[i-1] === w2[j-1]) {
                        dp[i][j] = dp[i-1][j-1];
                    } else {
                        dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
                    }
                }
            }
            
            return dp[m][n];
        }
        
        function getRegion(x) {
            return Math.floor(x / (W / params.regions));
        }
        
        function init() {
            resize();
            agents = [];
            barriers = [];
            generation = 0;
            divergenceHistory = [];
            
            // Create agents spread across regions
            for (let i = 0; i < params.population; i++) {
                const region = i % params.regions;
                const regionWidth = W / params.regions;
                const x = region * regionWidth + 30 + Math.random() * (regionWidth - 60);
                
                agents.push({
                    x: x,
                    y: 50 + Math.random() * (H - 100),
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    word: originalWord,
                    region: region
                });
            }
            
            // Create initial barriers between regions
            for (let i = 1; i < params.regions; i++) {
                const x = (W / params.regions) * i;
                barriers.push({ x: x, width: 10 });
            }
            
            updateStats();
        }
        
        function canInteract(a1, a2) {
            // Check if barrier blocks interaction
            const minX = Math.min(a1.x, a2.x);
            const maxX = Math.max(a1.x, a2.x);
            
            for (const barrier of barriers) {
                if (barrier.x > minX && barrier.x < maxX) {
                    if (Math.random() < params.barrierStrength) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        function step() {
            generation++;
            
            // Move agents
            for (const agent of agents) {
                agent.x += agent.vx;
                agent.y += agent.vy;
                
                // Bounce off walls
                if (agent.x < 20 || agent.x > W - 20) agent.vx *= -1;
                if (agent.y < 20 || agent.y > H - 20) agent.vy *= -1;
                
                agent.x = Math.max(20, Math.min(W - 20, agent.x));
                agent.y = Math.max(20, Math.min(H - 20, agent.y));
                
                // Slight random perturbation
                agent.vx += (Math.random() - 0.5) * 0.2;
                agent.vy += (Math.random() - 0.5) * 0.2;
                
                // Speed limit
                const speed = Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy);
                if (speed > 2) {
                    agent.vx = (agent.vx / speed) * 2;
                    agent.vy = (agent.vy / speed) * 2;
                }
                
                // Update region
                agent.region = getRegion(agent.x);
            }
            
            // Language transmission
            for (const agent of agents) {
                // Find nearby speakers
                const nearby = [];
                for (const other of agents) {
                    if (other === agent) continue;
                    const dx = other.x - agent.x;
                    const dy = other.y - agent.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < params.interactionRange && canInteract(agent, other)) {
                        nearby.push(other);
                    }
                }
                
                // Learn from a random neighbor (with potential mutation)
                if (nearby.length > 0 && Math.random() < 0.1) {
                    const teacher = nearby[Math.floor(Math.random() * nearby.length)];
                    agent.word = mutateWord(teacher.word);
                }
            }
            
            // Track divergence
            if (generation % 50 === 0) {
                const avgDiv = calculateDivergence();
                divergenceHistory.push(avgDiv);
                if (divergenceHistory.length > 100) divergenceHistory.shift();
            }
            
            updateStats();
        }
        
        function calculateDivergence() {
            let totalDist = 0;
            let count = 0;
            
            for (let i = 0; i < agents.length; i++) {
                totalDist += wordDistance(agents[i].word, originalWord);
                count++;
            }
            
            return count > 0 ? totalDist / count : 0;
        }
        
        function findLanguageFamilies() {
            // Cluster words by similarity
            const threshold = 2; // Max edit distance to be same family
            const families = [];
            const assigned = new Set();
            
            for (let i = 0; i < agents.length; i++) {
                if (assigned.has(i)) continue;
                
                const family = [i];
                assigned.add(i);
                
                for (let j = i + 1; j < agents.length; j++) {
                    if (assigned.has(j)) continue;
                    if (wordDistance(agents[i].word, agents[j].word) <= threshold) {
                        family.push(j);
                        assigned.add(j);
                    }
                }
                
                families.push(family);
            }
            
            return families;
        }
        
        function updateStats() {
            const families = findLanguageFamilies();
            const divergence = calculateDivergence();
            
            // Find most common word
            const wordCounts = {};
            for (const agent of agents) {
                wordCounts[agent.word] = (wordCounts[agent.word] || 0) + 1;
            }
            const common = Object.entries(wordCounts).sort((a, b) => b[1] - a[1])[0];
            
            document.getElementById('generations').textContent = generation;
            document.getElementById('families').textContent = families.length;
            document.getElementById('divergence').textContent = (divergence / originalWord.length * 100).toFixed(1);
            document.getElementById('common').textContent = common ? `"${common[0]}" (${common[1]})` : '-';
            
            // Update word samples
            const samples = [];
            for (let r = 0; r < params.regions; r++) {
                const regionAgents = agents.filter(a => a.region === r);
                if (regionAgents.length > 0) {
                    const words = [...new Set(regionAgents.map(a => a.word))].slice(0, 3);
                    samples.push(`R${r + 1}: ${words.join(', ')}`);
                }
            }
            document.getElementById('wordSamples').textContent = samples.join('\n');
        }
        
        function drawSim() {
            // Background
            sctx.fillStyle = '#0f1729';
            sctx.fillRect(0, 0, W, H);
            
            // Region backgrounds
            for (let r = 0; r < params.regions; r++) {
                const regionWidth = W / params.regions;
                sctx.fillStyle = `${regionColors[r]}10`;
                sctx.fillRect(r * regionWidth, 0, regionWidth, H);
            }
            
            // Barriers
            for (const barrier of barriers) {
                const gradient = sctx.createLinearGradient(barrier.x - 20, 0, barrier.x + 20, 0);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(0.3, `rgba(100, 100, 100, ${params.barrierStrength * 0.8})`);
                gradient.addColorStop(0.5, `rgba(80, 80, 80, ${params.barrierStrength})`);
                gradient.addColorStop(0.7, `rgba(100, 100, 100, ${params.barrierStrength * 0.8})`);
                gradient.addColorStop(1, 'transparent');
                sctx.fillStyle = gradient;
                sctx.fillRect(barrier.x - 20, 0, 40, H);
                
                // Mountain icons
                sctx.fillStyle = `rgba(60, 60, 60, ${params.barrierStrength})`;
                for (let y = 30; y < H - 30; y += 80) {
                    sctx.beginPath();
                    sctx.moveTo(barrier.x - 15, y + 30);
                    sctx.lineTo(barrier.x, y);
                    sctx.lineTo(barrier.x + 15, y + 30);
                    sctx.fill();
                }
            }
            
            // Draw agents
            for (const agent of agents) {
                const color = regionColors[agent.region];
                
                // Speech bubble
                sctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                sctx.beginPath();
                sctx.roundRect(agent.x - 20, agent.y - 30, 40, 18, 4);
                sctx.fill();
                
                // Word text
                sctx.fillStyle = '#333';
                sctx.font = '10px monospace';
                sctx.textAlign = 'center';
                sctx.fillText(agent.word.substring(0, 6), agent.x, agent.y - 17);
                
                // Agent body
                sctx.fillStyle = color;
                sctx.beginPath();
                sctx.arc(agent.x, agent.y, 6, 0, Math.PI * 2);
                sctx.fill();
            }
            
            // Labels
            sctx.fillStyle = '#666';
            sctx.font = '12px sans-serif';
            sctx.textAlign = 'left';
            sctx.fillText(`Original: "${originalWord}"`, 20, 20);
            sctx.fillText(`Generation: ${generation}`, W - 120, 20);
        }
        
        function drawGraph() {
            gctx.fillStyle = '#0a0f1a';
            gctx.fillRect(0, 0, GW, GH);
            
            const margin = 50;
            const graphW = GW - 2 * margin;
            const graphH = GH - 2 * margin;
            
            // Axes
            gctx.strokeStyle = '#333';
            gctx.lineWidth = 1;
            gctx.beginPath();
            gctx.moveTo(margin, margin);
            gctx.lineTo(margin, GH - margin);
            gctx.lineTo(GW - margin, GH - margin);
            gctx.stroke();
            
            gctx.fillStyle = '#666';
            gctx.font = '11px sans-serif';
            gctx.fillText('Divergence', margin - 10, margin - 5);
            gctx.fillText('Time', GW - margin, GH - margin + 15);
            gctx.fillText('Language Divergence Over Time', margin, margin - 20);
            
            if (divergenceHistory.length < 2) return;
            
            const maxDiv = Math.max(...divergenceHistory, 3);
            
            // Draw divergence line
            gctx.strokeStyle = '#8b5cf6';
            gctx.lineWidth = 2;
            gctx.beginPath();
            for (let i = 0; i < divergenceHistory.length; i++) {
                const x = margin + (i / (divergenceHistory.length - 1)) * graphW;
                const y = GH - margin - (divergenceHistory[i] / maxDiv) * graphH;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            }
            gctx.stroke();
            
            // Current point
            if (divergenceHistory.length > 0) {
                const lastY = GH - margin - (divergenceHistory[divergenceHistory.length - 1] / maxDiv) * graphH;
                gctx.fillStyle = '#a78bfa';
                gctx.beginPath();
                gctx.arc(GW - margin, lastY, 4, 0, Math.PI * 2);
                gctx.fill();
            }
        }
        
        function draw() {
            drawSim();
            drawGraph();
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    step();
                }
            }, 100);
        }
        
        // Event listeners
        document.getElementById('pop').addEventListener('input', e => {
            params.population = +e.target.value;
            document.getElementById('popVal').textContent = params.population;
        });
        document.getElementById('mutation').addEventListener('input', e => {
            params.mutationRate = +e.target.value;
            document.getElementById('mutationVal').textContent = params.mutationRate.toFixed(2);
        });
        document.getElementById('range').addEventListener('input', e => {
            params.interactionRange = +e.target.value;
            document.getElementById('rangeVal').textContent = params.interactionRange;
        });
        document.getElementById('regions').addEventListener('input', e => {
            params.regions = +e.target.value;
            document.getElementById('regionsVal').textContent = params.regions;
        });
        document.getElementById('barrier').addEventListener('input', e => {
            params.barrierStrength = +e.target.value;
            document.getElementById('barrierVal').textContent = params.barrierStrength.toFixed(1);
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('addBarrier').addEventListener('click', () => {
            // Add a barrier at random position
            const x = 100 + Math.random() * (W - 200);
            barriers.push({ x: x, width: 10 });
        });
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
