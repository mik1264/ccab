<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Turtle-Based - Agent Cells - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0f0f0f; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #22c55e; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #16a34a; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #15803d; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #22c55e; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .pattern-btn { width: 48%; display: inline-block; margin-right: 2%; margin-bottom: 5px; font-size: 0.75rem; padding: 6px; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Life: Turtle-Based</h1>
            <p class="description">Conway's Game of Life with each cell as an independent agent (turtle). Cells track their own state and neighbor count.</p>
            
            <div class="control-group">
                <label>Grid Size: <span id="sizeVal">80</span></label>
                <input type="range" id="size" min="40" max="150" value="80">
            </div>
            <div class="control-group">
                <label>Initial Density: <span id="densityVal">25</span>%</label>
                <input type="range" id="density" min="5" max="50" value="25">
            </div>
            <div class="control-group">
                <label>Speed: <span id="speedVal">10</span> gen/s</label>
                <input type="range" id="speed" min="1" max="30" value="10">
            </div>
            
            <button id="reset">Random Reset</button>
            <button id="pause">Pause</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="step">Single Step</button>
            <button id="clear">Clear</button>
            
            <p class="description" style="margin-top:10px;"><strong>Patterns:</strong></p>
            <button class="pattern-btn" id="glider">Glider</button>
            <button class="pattern-btn" id="blinker">Blinker</button>
            <button class="pattern-btn" id="pulsar">Pulsar</button>
            <button class="pattern-btn" id="glidergun">Gosper Gun</button>
            
            <div class="stats">
                <div>Generation: <span id="gen">0</span></div>
                <div>Living Cells: <span id="alive">0</span></div>
                <div>Births: <span id="births">0</span></div>
                <div>Deaths: <span id="deaths">0</span></div>
                <div>Active Turtles: <span id="turtles">0</span></div>
            </div>
            
            <p class="description"><strong>Agent Model:</strong> Each cell is a "turtle" with state. Turtles query neighbors and apply rules independently.</p>
            
            <p class="description"><strong>Click</strong> to toggle cells on/off.</p>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Life Turtle-Based - Agent Cells</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, COLS, ROWS, CELL;
        let cells = [], paused = false, generation = 0;
        let births = 0, deaths = 0;
        
        let params = {
            gridSize: 80,
            density: 25,
            speed: 10
        };
        
        // Each cell is a turtle with its own state
        class CellTurtle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.alive = false;
                this.nextState = false;
                this.age = 0;
            }
            
            countNeighbors() {
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (this.x + dx + COLS) % COLS;
                        const ny = (this.y + dy + ROWS) % ROWS;
                        if (cells[ny][nx].alive) count++;
                    }
                }
                return count;
            }
            
            decide() {
                const neighbors = this.countNeighbors();
                
                if (this.alive) {
                    // Survival: 2 or 3 neighbors
                    this.nextState = (neighbors === 2 || neighbors === 3);
                } else {
                    // Birth: exactly 3 neighbors
                    this.nextState = (neighbors === 3);
                }
            }
            
            update() {
                const wasAlive = this.alive;
                this.alive = this.nextState;
                
                if (this.alive && !wasAlive) {
                    births++;
                    this.age = 0;
                } else if (!this.alive && wasAlive) {
                    deaths++;
                    this.age = 0;
                } else if (this.alive) {
                    this.age++;
                }
            }
        }
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
            CELL = Math.floor(Math.min(W, H) / params.gridSize);
            COLS = Math.floor(W / CELL);
            ROWS = Math.floor(H / CELL);
        }
        
        function init() {
            resize();
            generation = 0;
            births = 0;
            deaths = 0;
            
            cells = [];
            for (let y = 0; y < ROWS; y++) {
                cells[y] = [];
                for (let x = 0; x < COLS; x++) {
                    const cell = new CellTurtle(x, y);
                    cell.alive = Math.random() * 100 < params.density;
                    cells[y][x] = cell;
                }
            }
            
            updateStats();
        }
        
        function step() {
            generation++;
            
            // All turtles decide next state
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    cells[y][x].decide();
                }
            }
            
            // All turtles update
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    cells[y][x].update();
                }
            }
            
            updateStats();
        }
        
        function updateStats() {
            let alive = 0;
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (cells[y][x].alive) alive++;
                }
            }
            
            document.getElementById('gen').textContent = generation;
            document.getElementById('alive').textContent = alive;
            document.getElementById('births').textContent = births;
            document.getElementById('deaths').textContent = deaths;
            document.getElementById('turtles').textContent = COLS * ROWS;
        }
        
        function draw() {
            ctx.fillStyle = '#0f0f0f';
            ctx.fillRect(0, 0, W, H);
            
            // Draw grid lines (subtle)
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL, 0);
                ctx.lineTo(x * CELL, ROWS * CELL);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL);
                ctx.lineTo(COLS * CELL, y * CELL);
                ctx.stroke();
            }
            
            // Draw cells
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = cells[y][x];
                    if (cell.alive) {
                        // Color based on age
                        const age = Math.min(cell.age, 50);
                        const hue = 120 + age * 2; // Green to yellow
                        const brightness = 50 + (50 - age);
                        ctx.fillStyle = `hsl(${hue}, 70%, ${brightness}%)`;
                        ctx.fillRect(x * CELL + 1, y * CELL + 1, CELL - 2, CELL - 2);
                    }
                }
            }
            
            requestAnimationFrame(draw);
        }
        
        function placePattern(pattern, offsetX = 0, offsetY = 0) {
            const cx = Math.floor(COLS / 2) + offsetX;
            const cy = Math.floor(ROWS / 2) + offsetY;
            
            for (const [dx, dy] of pattern) {
                const x = (cx + dx + COLS) % COLS;
                const y = (cy + dy + ROWS) % ROWS;
                cells[y][x].alive = true;
            }
        }
        
        const PATTERNS = {
            glider: [[0,0], [1,0], [2,0], [2,-1], [1,-2]],
            blinker: [[0,0], [1,0], [2,0]],
            pulsar: (() => {
                const p = [];
                const coords = [2,3,4,8,9,10];
                for (const x of coords) {
                    p.push([x-6, -1], [x-6, -6]);
                    p.push([x-6, 1], [x-6, 6]);
                }
                for (const y of coords) {
                    p.push([-1, y-6], [-6, y-6]);
                    p.push([1, y-6], [6, y-6]);
                }
                return p;
            })(),
            glidergun: [
                [0,4],[0,5],[1,4],[1,5], // Left block
                [10,4],[10,5],[10,6],[11,3],[11,7],[12,2],[12,8],[13,2],[13,8],
                [14,5],[15,3],[15,7],[16,4],[16,5],[16,6],[17,5],
                [20,2],[20,3],[20,4],[21,2],[21,3],[21,4],[22,1],[22,5],
                [24,0],[24,1],[24,5],[24,6],
                [34,2],[34,3],[35,2],[35,3] // Right block
            ]
        };
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) step();
            }, 1000 / params.speed);
        }
        
        // Event listeners
        document.getElementById('size').addEventListener('input', e => {
            params.gridSize = +e.target.value;
            document.getElementById('sizeVal').textContent = params.gridSize;
        });
        document.getElementById('density').addEventListener('input', e => {
            params.density = +e.target.value;
            document.getElementById('densityVal').textContent = params.density;
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
            startSim();
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('step').addEventListener('click', step);
        document.getElementById('clear').addEventListener('click', () => {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    cells[y][x].alive = false;
                }
            }
            generation = 0;
            births = 0;
            deaths = 0;
            updateStats();
        });
        
        document.getElementById('glider').addEventListener('click', () => placePattern(PATTERNS.glider));
        document.getElementById('blinker').addEventListener('click', () => placePattern(PATTERNS.blinker));
        document.getElementById('pulsar').addEventListener('click', () => placePattern(PATTERNS.pulsar));
        document.getElementById('glidergun').addEventListener('click', () => {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    cells[y][x].alive = false;
                }
            }
            placePattern(PATTERNS.glidergun, -15, 0);
        });
        
        // Click to toggle cells
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL);
            const y = Math.floor((e.clientY - rect.top) / CELL);
            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                cells[y][x].alive = !cells[y][x].alive;
            }
        });
        
        window.addEventListener('resize', () => { resize(); init(); });

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
        draw();
        startSim();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
