<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heatbugs - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #canvas-container {
            flex: 1;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #controls {
            width: 280px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
        }
        h1 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #f97316;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            font-size: 0.8rem;
            margin-bottom: 5px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #f97316;
            color: #1a1a2e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #ea580c;
        }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
        }
        .stats div {
            margin-bottom: 5px;
        }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            color: #f97316;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover {
            background: rgba(249,115,22,0.2);
        }
        .description {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        .legend {
            margin-top: 15px;
            font-size: 0.75rem;
        }
        .gradient-bar {
            height: 20px;
            background: linear-gradient(to right, #1e3a5f, #3b82f6, #22c55e, #fbbf24, #f97316, #dc2626);
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #888;
        }
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #f97316;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #f97316;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Heatbugs Thermoregulation</h1>
            <p class="description">
                Bugs seek their ideal temperature. Each bug generates heat and moves
                to find comfortable zones. Watch temperature gradients emerge as
                bugs cluster and create hot spots.
            </p>

            <div class="control-group">
                <label>Number of Bugs: <span id="bugCountValue">80</span></label>
                <input type="range" id="bugCount" min="10" max="200" value="80">
            </div>

            <div class="control-group">
                <label>Heat Output: <span id="heatOutputValue">10</span></label>
                <input type="range" id="heatOutput" min="1" max="30" value="10">
            </div>

            <div class="control-group">
                <label>Heat Diffusion: <span id="diffusionValue">0.5</span></label>
                <input type="range" id="diffusion" min="0.1" max="0.9" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Heat Evaporation: <span id="evaporationValue">0.02</span></label>
                <input type="range" id="evaporation" min="0.01" max="0.1" step="0.01" value="0.02">
            </div>

            <div class="control-group">
                <label>Ideal Temperature Min: <span id="idealMinValue">30</span></label>
                <input type="range" id="idealMin" min="10" max="50" value="30">
            </div>

            <div class="control-group">
                <label>Ideal Temperature Max: <span id="idealMaxValue">50</span></label>
                <input type="range" id="idealMax" min="30" max="80" value="50">
            </div>

            <button id="reset">Reset Simulation</button>
            <button id="pause">Pause</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>

            <div class="stats">
                <div>Average Temperature: <span id="avgTemp">0</span></div>
                <div>Max Temperature: <span id="maxTemp">0</span></div>
                <div>Happy Bugs: <span id="happyBugs">0</span></div>
                <div>Unhappy (Too Hot): <span id="tooHot">0</span></div>
                <div>Unhappy (Too Cold): <span id="tooCold">0</span></div>
            </div>

            <div class="legend">
                <p style="margin-bottom: 5px;">Temperature Scale:</p>
                <div class="gradient-bar"></div>
                <div class="gradient-labels">
                    <span>Cold</span>
                    <span>Warm</span>
                    <span>Hot</span>
                </div>
            </div>
        </div>
    </div>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üî• Heatbugs: Thermoregulation</h2>
            <div class="modal-body">
                <p>Heatbugs is a classic artificial life simulation demonstrating <strong>adaptive behavior</strong> and <strong>emergent thermal patterns</strong>. Each bug seeks its ideal temperature while generating heat as a byproduct of existing.</p>

                <h3>How It Works</h3>
                <ul>
                    <li><strong>Heat generation:</strong> Every bug continuously outputs heat at its current location</li>
                    <li><strong>Heat diffusion:</strong> Warmth spreads to neighboring cells over time</li>
                    <li><strong>Evaporation:</strong> Heat gradually dissipates from the environment</li>
                    <li><strong>Movement:</strong> Bugs move toward temperatures closer to their ideal</li>
                </ul>

                <h3>Emergent Phenomena</h3>
                <p>Watch for these fascinating patterns:</p>
                <ul>
                    <li><strong>Hot spots:</strong> Clusters form where bugs congregate, raising local temperature</li>
                    <li><strong>Dynamic equilibrium:</strong> Bugs constantly adjust, never fully satisfied</li>
                    <li><strong>Feedback loops:</strong> Clustering creates heat ‚Üí attracts more bugs ‚Üí more heat</li>
                    <li><strong>Temperature gradients:</strong> Complex patterns emerge from simple rules</li>
                </ul>

                <h3>Real-World Parallels</h3>
                <p>This model illustrates principles seen in:</p>
                <ul>
                    <li><strong>Bee hivemation:</strong> Bees cluster to maintain hive temperature</li>
                    <li><strong>Urban heat islands:</strong> Cities become warmer than surroundings</li>
                    <li><strong>Thermoregulation:</strong> How organisms maintain body temperature</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Increase heat output to see stronger clustering</li>
                    <li>Adjust evaporation to change how quickly patterns form</li>
                    <li>Watch the "happy bugs" count as the system stabilizes</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const cellSize = 5;
        let gridWidth, gridHeight;
        let temperature = [];
        let tempBuffer = [];
        let bugs = [];
        let paused = false;

        let params = {
            bugCount: 80,
            heatOutput: 10,
            diffusion: 0.5,
            evaporation: 0.02,
            idealMin: 30,
            idealMax: 50
        };

        function resize() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            gridWidth = Math.floor(canvas.width / cellSize);
            gridHeight = Math.floor(canvas.height / cellSize);
        }

        function init() {
            resize();

            // Initialize temperature grid
            temperature = new Float32Array(gridWidth * gridHeight);
            tempBuffer = new Float32Array(gridWidth * gridHeight);

            // Initialize bugs with random ideal temperatures
            bugs = [];
            for (let i = 0; i < params.bugCount; i++) {
                bugs.push({
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight),
                    idealTemp: params.idealMin + Math.random() * (params.idealMax - params.idealMin),
                    heatOutput: params.heatOutput * (0.5 + Math.random())
                });
            }
        }

        function getTemp(x, y) {
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return 0;
            return temperature[y * gridWidth + x];
        }

        function setTemp(x, y, value) {
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;
            temperature[y * gridWidth + x] = Math.max(0, Math.min(100, value));
        }

        function diffuseHeat() {
            // Diffuse and evaporate heat
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    let sum = temperature[idx] * (1 - params.diffusion);

                    // Average of neighbors
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                                sum += temperature[ny * gridWidth + nx] * params.diffusion / 8;
                                neighbors++;
                            }
                        }
                    }

                    // Apply evaporation
                    tempBuffer[idx] = sum * (1 - params.evaporation);
                }
            }

            // Swap buffers
            [temperature, tempBuffer] = [tempBuffer, temperature];
        }

        function updateBug(bug) {
            // Generate heat at current position
            const idx = bug.y * gridWidth + bug.x;
            temperature[idx] += bug.heatOutput;

            const currentTemp = getTemp(bug.x, bug.y);
            const diff = currentTemp - bug.idealTemp;

            // If temperature is comfortable, random walk
            // If too hot, move toward cooler areas
            // If too cold, move toward warmer areas

            let bestX = bug.x;
            let bestY = bug.y;
            let bestScore = Math.abs(diff);

            // Check all neighbors
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = bug.x + dx;
                    const ny = bug.y + dy;

                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        const neighborTemp = getTemp(nx, ny);
                        const neighborDiff = Math.abs(neighborTemp - bug.idealTemp);

                        // Add some randomness to avoid getting stuck
                        const score = neighborDiff - Math.random() * 5;

                        if (score < bestScore) {
                            bestScore = score;
                            bestX = nx;
                            bestY = ny;
                        }
                    }
                }
            }

            // Move to best position
            bug.x = bestX;
            bug.y = bestY;
        }

        function tempToColor(temp) {
            // Map temperature to color
            const t = Math.max(0, Math.min(1, temp / 100));

            let r, g, b;
            if (t < 0.2) {
                // Cold: dark blue to blue
                r = 30;
                g = 58 + t * 5 * 100;
                b = 95 + t * 5 * 100;
            } else if (t < 0.4) {
                // Blue to green
                const s = (t - 0.2) / 0.2;
                r = 59 - 25 * s;
                g = 130 + 67 * s;
                b = 246 - 159 * s;
            } else if (t < 0.6) {
                // Green to yellow
                const s = (t - 0.4) / 0.2;
                r = 34 + 217 * s;
                g = 197 - 6 * s;
                b = 87 - 51 * s;
            } else if (t < 0.8) {
                // Yellow to orange
                const s = (t - 0.6) / 0.2;
                r = 251 - 2 * s;
                g = 191 - 76 * s;
                b = 36 - 14 * s;
            } else {
                // Orange to red
                const s = (t - 0.8) / 0.2;
                r = 249 - 29 * s;
                g = 115 - 77 * s;
                b = 22 + 16 * s;
            }

            return `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
        }

        function draw() {
            // Draw temperature field
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            let avgTemp = 0;
            let maxTemp = 0;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const temp = temperature[y * gridWidth + x];
                    avgTemp += temp;
                    maxTemp = Math.max(maxTemp, temp);

                    const t = Math.max(0, Math.min(1, temp / 100));

                    // Color mapping
                    let r, g, b;
                    if (t < 0.25) {
                        r = 30; g = 58 + t * 4 * 100; b = 95 + t * 4 * 100;
                    } else if (t < 0.5) {
                        const s = (t - 0.25) / 0.25;
                        r = 34 + 200 * s; g = 158 + 39 * s; b = 195 - 159 * s;
                    } else if (t < 0.75) {
                        const s = (t - 0.5) / 0.25;
                        r = 234 + 15 * s; g = 197 - 82 * s; b = 36 - 14 * s;
                    } else {
                        const s = (t - 0.75) / 0.25;
                        r = 249 - 29 * s; g = 115 - 77 * s; b = 22 + 16 * s;
                    }

                    // Fill cell
                    for (let cy = 0; cy < cellSize; cy++) {
                        for (let cx = 0; cx < cellSize; cx++) {
                            const px = x * cellSize + cx;
                            const py = y * cellSize + cy;
                            if (px < canvas.width && py < canvas.height) {
                                const idx = (py * canvas.width + px) * 4;
                                imageData.data[idx] = r;
                                imageData.data[idx + 1] = g;
                                imageData.data[idx + 2] = b;
                                imageData.data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw bugs
            let happyCount = 0;
            let tooHotCount = 0;
            let tooColdCount = 0;

            for (const bug of bugs) {
                const px = bug.x * cellSize + cellSize / 2;
                const py = bug.y * cellSize + cellSize / 2;

                const currentTemp = getTemp(bug.x, bug.y);
                const diff = currentTemp - bug.idealTemp;

                let color;
                if (Math.abs(diff) < 10) {
                    color = '#22c55e'; // Happy (green)
                    happyCount++;
                } else if (diff > 0) {
                    color = '#ef4444'; // Too hot (red)
                    tooHotCount++;
                } else {
                    color = '#3b82f6'; // Too cold (blue)
                    tooColdCount++;
                }

                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Update stats
            avgTemp /= (gridWidth * gridHeight);
            document.getElementById('avgTemp').textContent = avgTemp.toFixed(1);
            document.getElementById('maxTemp').textContent = maxTemp.toFixed(1);
            document.getElementById('happyBugs').textContent = happyCount;
            document.getElementById('tooHot').textContent = tooHotCount;
            document.getElementById('tooCold').textContent = tooColdCount;
        }

        function update() {
            if (paused) return;

            for (const bug of bugs) {
                updateBug(bug);
            }
            diffuseHeat();
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('bugCount').addEventListener('input', (e) => {
            params.bugCount = parseInt(e.target.value);
            document.getElementById('bugCountValue').textContent = params.bugCount;
        });

        document.getElementById('heatOutput').addEventListener('input', (e) => {
            params.heatOutput = parseInt(e.target.value);
            document.getElementById('heatOutputValue').textContent = params.heatOutput;
        });

        document.getElementById('diffusion').addEventListener('input', (e) => {
            params.diffusion = parseFloat(e.target.value);
            document.getElementById('diffusionValue').textContent = params.diffusion.toFixed(1);
        });

        document.getElementById('evaporation').addEventListener('input', (e) => {
            params.evaporation = parseFloat(e.target.value);
            document.getElementById('evaporationValue').textContent = params.evaporation.toFixed(2);
        });

        document.getElementById('idealMin').addEventListener('input', (e) => {
            params.idealMin = parseInt(e.target.value);
            document.getElementById('idealMinValue').textContent = params.idealMin;
        });

        document.getElementById('idealMax').addEventListener('input', (e) => {
            params.idealMax = parseInt(e.target.value);
            document.getElementById('idealMaxValue').textContent = params.idealMax;
        });

        document.getElementById('reset').addEventListener('click', init);

        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });

        window.addEventListener('resize', resize);

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });

        // Expose for enhance.js
        window.reset = init;

        // Start
        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
