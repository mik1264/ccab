<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chemical Equilibrium - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1e1b4b; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #sim-canvas { flex: 1; }
        #graph-canvas { height: 150px; border-top: 1px solid #333; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #c4b5fd; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #8b5cf6; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #7c3aed; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #8b5cf6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .equation { background: rgba(139,92,246,0.2); padding: 8px; border-radius: 5px; text-align: center; margin-bottom: 12px; font-family: monospace; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="sim-canvas"></canvas>
            <canvas id="graph-canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Chemical Equilibrium</h1>
            <p class="description">Reversible reaction A + B ⇌ C. Watch as forward and reverse reactions reach dynamic equilibrium where concentrations stabilize.</p>
            
            <div class="equation">A + B ⇌ C</div>
            
            <div class="control-group">
                <label>Initial A molecules: <span id="initAVal">100</span></label>
                <input type="range" id="initA" min="20" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Initial B molecules: <span id="initBVal">100</span></label>
                <input type="range" id="initB" min="20" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Forward rate (k₁): <span id="k1Val">0.02</span></label>
                <input type="range" id="k1" min="0.005" max="0.1" step="0.005" value="0.02">
            </div>
            <div class="control-group">
                <label>Reverse rate (k₂): <span id="k2Val">0.01</span></label>
                <input type="range" id="k2" min="0.005" max="0.1" step="0.005" value="0.01">
            </div>
            
            <button id="reset">Reset</button>
            <button id="pause">Pause</button>
            <button id="addA">Add 20 A molecules</button>
            <button id="addC">Add 20 C molecules</button>
            
            <div class="stats">
                <div style="color:#ef4444">A: <span id="countA">0</span></div>
                <div style="color:#3b82f6">B: <span id="countB">0</span></div>
                <div style="color:#22c55e">C: <span id="countC">0</span></div>
                <div>K = [C]/([A][B]) = <span id="Keq">0</span></div>
                <div>Expected K = k₁/k₂ = <span id="expectedK">2</span></div>
            </div>
            
            <p class="description"><strong>Le Chatelier:</strong> Adding reactants shifts equilibrium toward products. Adding products shifts toward reactants.</p>
        </div>
    </div>
    <script>
        const simCanvas = document.getElementById('sim-canvas');
        const simCtx = simCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');
        
        let W, H, molecules = [], paused = false, tick = 0;
        let history = { A: [], B: [], C: [] };
        
        let params = {
            initA: 100,
            initB: 100,
            k1: 0.02,  // Forward rate
            k2: 0.01   // Reverse rate
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            simCanvas.width = c.clientWidth;
            simCanvas.height = c.clientHeight - 150;
            graphCanvas.width = c.clientWidth;
            graphCanvas.height = 150;
            W = simCanvas.width;
            H = simCanvas.height;
        }
        
        function init() {
            resize();
            tick = 0;
            history = { A: [], B: [], C: [] };
            molecules = [];
            
            // Create A molecules
            for (let i = 0; i < params.initA; i++) {
                molecules.push(createMolecule('A'));
            }
            // Create B molecules
            for (let i = 0; i < params.initB; i++) {
                molecules.push(createMolecule('B'));
            }
            
            updateStats();
        }
        
        function createMolecule(type) {
            return {
                type: type,
                x: Math.random() * (W - 40) + 20,
                y: Math.random() * (H - 40) + 20,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3
            };
        }
        
        function step() {
            tick++;
            
            // Move molecules
            for (const m of molecules) {
                m.x += m.vx;
                m.y += m.vy;
                
                // Bounce off walls
                if (m.x < 10 || m.x > W - 10) m.vx *= -1;
                if (m.y < 10 || m.y > H - 10) m.vy *= -1;
                m.x = Math.max(10, Math.min(W - 10, m.x));
                m.y = Math.max(10, Math.min(H - 10, m.y));
            }
            
            // Forward reaction: A + B -> C
            const As = molecules.filter(m => m.type === 'A');
            const Bs = molecules.filter(m => m.type === 'B');
            
            for (const a of As) {
                for (const b of Bs) {
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 15 && Math.random() < params.k1) {
                        // React! Remove A and B, create C
                        const idx_a = molecules.indexOf(a);
                        const idx_b = molecules.indexOf(b);
                        if (idx_a > -1) molecules.splice(idx_a, 1);
                        const new_idx_b = molecules.indexOf(b);
                        if (new_idx_b > -1) molecules.splice(new_idx_b, 1);
                        
                        molecules.push({
                            type: 'C',
                            x: (a.x + b.x) / 2,
                            y: (a.y + b.y) / 2,
                            vx: (a.vx + b.vx) / 2,
                            vy: (a.vy + b.vy) / 2
                        });
                        break;
                    }
                }
            }
            
            // Reverse reaction: C -> A + B
            const Cs = molecules.filter(m => m.type === 'C');
            for (const c of Cs) {
                if (Math.random() < params.k2) {
                    // Decompose C into A and B
                    const idx = molecules.indexOf(c);
                    if (idx > -1) molecules.splice(idx, 1);
                    
                    molecules.push({
                        type: 'A',
                        x: c.x + (Math.random() - 0.5) * 10,
                        y: c.y + (Math.random() - 0.5) * 10,
                        vx: c.vx + (Math.random() - 0.5) * 2,
                        vy: c.vy + (Math.random() - 0.5) * 2
                    });
                    molecules.push({
                        type: 'B',
                        x: c.x + (Math.random() - 0.5) * 10,
                        y: c.y + (Math.random() - 0.5) * 10,
                        vx: c.vx + (Math.random() - 0.5) * 2,
                        vy: c.vy + (Math.random() - 0.5) * 2
                    });
                }
            }
            
            updateStats();
        }
        
        function updateStats() {
            const countA = molecules.filter(m => m.type === 'A').length;
            const countB = molecules.filter(m => m.type === 'B').length;
            const countC = molecules.filter(m => m.type === 'C').length;
            
            document.getElementById('countA').textContent = countA;
            document.getElementById('countB').textContent = countB;
            document.getElementById('countC').textContent = countC;
            
            // Calculate equilibrium constant K = [C]/([A][B])
            const K = (countA > 0 && countB > 0) ? countC / (countA * countB / 1000) : 0;
            document.getElementById('Keq').textContent = K.toFixed(3);
            document.getElementById('expectedK').textContent = (params.k1 / params.k2).toFixed(2);
            
            // Record history
            history.A.push(countA);
            history.B.push(countB);
            history.C.push(countC);
            if (history.A.length > 200) {
                history.A.shift();
                history.B.shift();
                history.C.shift();
            }
        }
        
        function draw() {
            // Main canvas
            simCtx.fillStyle = '#1e1b4b';
            simCtx.fillRect(0, 0, W, H);
            
            // Container
            simCtx.strokeStyle = '#4c1d95';
            simCtx.lineWidth = 3;
            simCtx.strokeRect(5, 5, W - 10, H - 10);
            
            // Draw molecules
            for (const m of molecules) {
                if (m.type === 'A') {
                    simCtx.fillStyle = '#ef4444';
                } else if (m.type === 'B') {
                    simCtx.fillStyle = '#3b82f6';
                } else {
                    simCtx.fillStyle = '#22c55e';
                }
                
                simCtx.beginPath();
                simCtx.arc(m.x, m.y, m.type === 'C' ? 8 : 6, 0, Math.PI * 2);
                simCtx.fill();
                
                simCtx.fillStyle = '#fff';
                simCtx.font = '10px sans-serif';
                simCtx.fillText(m.type, m.x - 3, m.y + 3);
            }
            
            // Graph canvas
            graphCtx.fillStyle = '#0a0a0f';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);
            
            const drawLine = (data, color) => {
                if (data.length < 2) return;
                const max = Math.max(...history.A, ...history.B, ...history.C, 50);
                graphCtx.strokeStyle = color;
                graphCtx.lineWidth = 1.5;
                graphCtx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = (i / 200) * graphCanvas.width;
                    const y = graphCanvas.height - 10 - (data[i] / max) * (graphCanvas.height - 20);
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            };
            
            drawLine(history.A, '#ef4444');
            drawLine(history.B, '#3b82f6');
            drawLine(history.C, '#22c55e');
            
            graphCtx.fillStyle = '#666';
            graphCtx.font = '10px sans-serif';
            graphCtx.fillText('Concentration vs Time (Red=A, Blue=B, Green=C)', 5, 12);
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => { if (!paused) step(); }, 50);
        }
        
        // Event listeners
        document.getElementById('initA').addEventListener('input', e => {
            params.initA = +e.target.value;
            document.getElementById('initAVal').textContent = params.initA;
        });
        document.getElementById('initB').addEventListener('input', e => {
            params.initB = +e.target.value;
            document.getElementById('initBVal').textContent = params.initB;
        });
        document.getElementById('k1').addEventListener('input', e => {
            params.k1 = +e.target.value;
            document.getElementById('k1Val').textContent = params.k1.toFixed(3);
        });
        document.getElementById('k2').addEventListener('input', e => {
            params.k2 = +e.target.value;
            document.getElementById('k2Val').textContent = params.k2.toFixed(3);
        });
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('addA').addEventListener('click', () => {
            for (let i = 0; i < 20; i++) molecules.push(createMolecule('A'));
        });
        document.getElementById('addC').addEventListener('click', () => {
            for (let i = 0; i < 20; i++) molecules.push(createMolecule('C'));
        });
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
