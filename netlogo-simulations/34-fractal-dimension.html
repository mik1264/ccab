<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Dimension - Box Counting</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 320px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #9d4edd 0%, #c77dff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #888;
            font-size: 0.95em;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            background: #000;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #bbb;
        }
        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #e0e0e0;
        }
        .control-group .value {
            text-align: right;
            font-size: 0.9em;
            color: #9d4edd;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #9d4edd 0%, #7b2cbf 100%);
            color: white;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(157,78,221,0.3);
        }
        .stats {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .stats h3 {
            margin-bottom: 12px;
            color: #9d4edd;
            font-size: 1em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #c77dff;
            font-weight: 600;
        }
        .dimension-display {
            font-size: 2em;
            text-align: center;
            padding: 20px;
            background: rgba(157,78,221,0.2);
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .dimension-display .label {
            font-size: 0.4em;
            color: #888;
            display: block;
            margin-bottom: 5px;
        }
        .info-box {
            background: rgba(157,78,221,0.1);
            border-left: 3px solid #9d4edd;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85em;
            border-radius: 0 8px 8px 0;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: color 0.3s;
        }
        .back-link:hover {
            color: #9d4edd;
        }
        .chart-container {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
        }
        .chart-container h4 {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
        }
        .formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            text-align: center;
            margin: 10px 0;
            color: #c77dff;
        }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <a href="index.html" class="back-link">‚Üê Back to Simulations</a>

            <div class="info-box">
                <strong>Box-Counting Dimension</strong><br>
                Measures the fractal dimension of shapes by counting how many boxes of decreasing size are needed to cover them.
            </div>

            <div class="dimension-display">
                <span class="label">Fractal Dimension D</span>
                <span id="dimension">--</span>
            </div>

            <div class="control-group">
                <label>Fractal Type:</label>
                <select id="fractalType">
                    <option value="sierpinski">Sierpinski Triangle</option>
                    <option value="koch">Koch Curve</option>
                    <option value="cantor">Cantor Set</option>
                    <option value="tree">Fractal Tree</option>
                    <option value="dragon">Dragon Curve</option>
                    <option value="custom">Draw Custom</option>
                </select>
            </div>

            <div class="control-group">
                <label>Iterations: <span class="value" id="iterVal">5</span></label>
                <input type="range" id="iterations" min="1" max="8" value="5">
            </div>

            <div class="control-group">
                <label>Min Box Size: <span class="value" id="minBoxVal">4</span></label>
                <input type="range" id="minBox" min="2" max="16" value="4">
            </div>

            <button class="btn-primary" id="analyzeBtn">Analyze Dimension</button>
            <button class="btn-secondary" id="clearBtn">Clear Custom</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>

            <div class="stats">
                <h3>Box Counting Results</h3>
                <div id="boxResults"></div>
            </div>

            <div class="formula">
                D = lim<sub>Œµ‚Üí0</sub> log(N) / log(1/Œµ)
            </div>

            <div class="chart-container">
                <h4>Log-Log Plot (slope = D)</h4>
                <canvas id="chartCanvas" width="280" height="150"></canvas>
            </div>

            <div class="info-box" style="margin-top: 15px;">
                <strong>Reference Dimensions:</strong><br>
                ‚Ä¢ Line: D = 1.0<br>
                ‚Ä¢ Sierpinski: D ‚âà 1.585<br>
                ‚Ä¢ Koch Curve: D ‚âà 1.262<br>
                ‚Ä¢ Cantor Set: D ‚âà 0.631<br>
                ‚Ä¢ Filled Square: D = 2.0
            </div>
        </aside>

        <main class="main">
            <header>
                <h1>Fractal Dimension Calculator</h1>
                <p class="subtitle">Box-counting method for measuring fractal complexity</p>
            </header>
            <div class="canvas-container">
                <canvas id="fractalCanvas" width="500" height="500"></canvas>
                <canvas id="boxCanvas" width="500" height="500"></canvas>
            </div>
        </main>
    </div>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Fractal Dimension - Box Counting</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const fractalCanvas = document.getElementById('fractalCanvas');
        const fractalCtx = fractalCanvas.getContext('2d');
        const boxCanvas = document.getElementById('boxCanvas');
        const boxCtx = boxCanvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        let customPoints = [];
        let isDrawing = false;

        // Controls
        const fractalType = document.getElementById('fractalType');
        const iterations = document.getElementById('iterations');
        const minBox = document.getElementById('minBox');

        iterations.addEventListener('input', () => {
            document.getElementById('iterVal').textContent = iterations.value;
            drawFractal();
        });

        minBox.addEventListener('input', () => {
            document.getElementById('minBoxVal').textContent = minBox.value;
        });

        fractalType.addEventListener('change', () => {
            if (fractalType.value !== 'custom') {
                customPoints = [];
            }
            drawFractal();
        });

        // Draw fractals
        function drawFractal() {
            fractalCtx.fillStyle = '#000';
            fractalCtx.fillRect(0, 0, fractalCanvas.width, fractalCanvas.height);
            fractalCtx.strokeStyle = '#9d4edd';
            fractalCtx.fillStyle = '#9d4edd';
            fractalCtx.lineWidth = 1;

            const iter = parseInt(iterations.value);
            const type = fractalType.value;

            switch(type) {
                case 'sierpinski':
                    drawSierpinski(iter);
                    break;
                case 'koch':
                    drawKoch(iter);
                    break;
                case 'cantor':
                    drawCantor(iter);
                    break;
                case 'tree':
                    drawTree(iter);
                    break;
                case 'dragon':
                    drawDragon(iter);
                    break;
                case 'custom':
                    drawCustom();
                    break;
            }

            // Clear box canvas
            boxCtx.clearRect(0, 0, boxCanvas.width, boxCanvas.height);
        }

        // Sierpinski Triangle
        function drawSierpinski(depth) {
            const size = 400;
            const startX = 50;
            const startY = 450;

            function triangle(x, y, size, d) {
                if (d === 0) {
                    fractalCtx.beginPath();
                    fractalCtx.moveTo(x, y);
                    fractalCtx.lineTo(x + size, y);
                    fractalCtx.lineTo(x + size/2, y - size * Math.sqrt(3)/2);
                    fractalCtx.closePath();
                    fractalCtx.fill();
                } else {
                    const half = size / 2;
                    triangle(x, y, half, d - 1);
                    triangle(x + half, y, half, d - 1);
                    triangle(x + half/2, y - half * Math.sqrt(3)/2, half, d - 1);
                }
            }

            triangle(startX, startY, size, depth);
        }

        // Koch Curve
        function drawKoch(depth) {
            function koch(x1, y1, x2, y2, d) {
                if (d === 0) {
                    fractalCtx.beginPath();
                    fractalCtx.moveTo(x1, y1);
                    fractalCtx.lineTo(x2, y2);
                    fractalCtx.stroke();
                } else {
                    const dx = (x2 - x1) / 3;
                    const dy = (y2 - y1) / 3;
                    const px = (x1 + x2) / 2 + dy * Math.sqrt(3) / 2;
                    const py = (y1 + y2) / 2 - dx * Math.sqrt(3) / 2;

                    koch(x1, y1, x1 + dx, y1 + dy, d - 1);
                    koch(x1 + dx, y1 + dy, px, py, d - 1);
                    koch(px, py, x1 + 2*dx, y1 + 2*dy, d - 1);
                    koch(x1 + 2*dx, y1 + 2*dy, x2, y2, d - 1);
                }
            }

            // Draw Koch snowflake
            const cx = 250, cy = 280;
            const r = 180;
            const pts = [];
            for (let i = 0; i < 3; i++) {
                pts.push({
                    x: cx + r * Math.cos(i * 2 * Math.PI / 3 - Math.PI/2),
                    y: cy + r * Math.sin(i * 2 * Math.PI / 3 - Math.PI/2)
                });
            }

            for (let i = 0; i < 3; i++) {
                koch(pts[i].x, pts[i].y, pts[(i+1)%3].x, pts[(i+1)%3].y, depth);
            }
        }

        // Cantor Set
        function drawCantor(depth) {
            function cantor(x, y, length, d) {
                const height = 20;
                fractalCtx.fillRect(x, y, length, height);

                if (d > 0) {
                    const newLen = length / 3;
                    cantor(x, y + 35, newLen, d - 1);
                    cantor(x + 2 * newLen, y + 35, newLen, d - 1);
                }
            }

            cantor(25, 50, 450, depth);
        }

        // Fractal Tree
        function drawTree(depth) {
            function branch(x, y, length, angle, d) {
                const x2 = x + length * Math.cos(angle);
                const y2 = y + length * Math.sin(angle);

                fractalCtx.beginPath();
                fractalCtx.moveTo(x, y);
                fractalCtx.lineTo(x2, y2);
                fractalCtx.stroke();

                if (d > 0) {
                    const newLen = length * 0.7;
                    branch(x2, y2, newLen, angle - 0.5, d - 1);
                    branch(x2, y2, newLen, angle + 0.5, d - 1);
                }
            }

            branch(250, 480, 100, -Math.PI/2, depth);
        }

        // Dragon Curve
        function drawDragon(depth) {
            function dragonPoints(depth) {
                let points = [{x: 150, y: 250}, {x: 350, y: 250}];

                for (let i = 0; i < depth; i++) {
                    const newPoints = [points[0]];
                    for (let j = 0; j < points.length - 1; j++) {
                        const p1 = points[j];
                        const p2 = points[j + 1];
                        const mx = (p1.x + p2.x) / 2;
                        const my = (p1.y + p2.y) / 2;
                        const dx = (p2.x - p1.x) / 2;
                        const dy = (p2.y - p1.y) / 2;

                        let newPoint;
                        if (j % 2 === 0) {
                            newPoint = {x: mx - dy, y: my + dx};
                        } else {
                            newPoint = {x: mx + dy, y: my - dx};
                        }

                        newPoints.push(newPoint);
                        newPoints.push(p2);
                    }
                    points = newPoints;
                }

                return points;
            }

            const points = dragonPoints(depth);
            fractalCtx.beginPath();
            fractalCtx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                fractalCtx.lineTo(points[i].x, points[i].y);
            }
            fractalCtx.stroke();
        }

        // Draw custom
        function drawCustom() {
            if (customPoints.length < 2) return;

            fractalCtx.beginPath();
            fractalCtx.moveTo(customPoints[0].x, customPoints[0].y);
            for (let i = 1; i < customPoints.length; i++) {
                fractalCtx.lineTo(customPoints[i].x, customPoints[i].y);
            }
            fractalCtx.stroke();
        }

        // Custom drawing
        fractalCanvas.addEventListener('mousedown', (e) => {
            if (fractalType.value !== 'custom') return;
            isDrawing = true;
            const rect = fractalCanvas.getBoundingClientRect();
            customPoints.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
        });

        fractalCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || fractalType.value !== 'custom') return;
            const rect = fractalCanvas.getBoundingClientRect();
            customPoints.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
            drawFractal();
        });

        fractalCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            customPoints = [];
            drawFractal();
        });

        // Box counting analysis
        function analyzeBoxCounting() {
            // Get fractal image data
            const imageData = fractalCtx.getImageData(0, 0, fractalCanvas.width, fractalCanvas.height);
            const data = imageData.data;

            // Create binary grid
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            const grid = [];

            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    // Check if pixel is part of fractal (non-black)
                    const isSet = data[idx] > 50 || data[idx + 1] > 50 || data[idx + 2] > 50;
                    row.push(isSet);
                }
                grid.push(row);
            }

            // Box counting at different scales
            const minBoxSize = parseInt(minBox.value);
            const results = [];
            const boxSizes = [];

            for (let size = 256; size >= minBoxSize; size = Math.floor(size / 2)) {
                boxSizes.push(size);
            }

            let currentBoxSize = boxSizes[0];
            let boxesShown = false;

            for (const size of boxSizes) {
                const count = countBoxes(grid, size, width, height);
                results.push({ size, count });
            }

            // Calculate dimension using linear regression on log-log data
            const logData = results.filter(r => r.count > 0).map(r => ({
                logEpsilon: Math.log(1 / r.size),
                logN: Math.log(r.count)
            }));

            if (logData.length >= 2) {
                const dimension = linearRegression(logData);
                document.getElementById('dimension').textContent = dimension.toFixed(3);
            }

            // Display results
            displayResults(results);
            drawLogLogPlot(results);
            showBoxesVisualization(grid, results[Math.min(2, results.length - 1)].size, width, height);
        }

        function countBoxes(grid, boxSize, width, height) {
            let count = 0;

            for (let y = 0; y < height; y += boxSize) {
                for (let x = 0; x < width; x += boxSize) {
                    // Check if any pixel in this box is set
                    let hasPixel = false;
                    for (let dy = 0; dy < boxSize && y + dy < height && !hasPixel; dy++) {
                        for (let dx = 0; dx < boxSize && x + dx < width && !hasPixel; dx++) {
                            if (grid[y + dy][x + dx]) {
                                hasPixel = true;
                            }
                        }
                    }
                    if (hasPixel) count++;
                }
            }

            return count;
        }

        function linearRegression(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            for (const point of data) {
                sumX += point.logEpsilon;
                sumY += point.logN;
                sumXY += point.logEpsilon * point.logN;
                sumX2 += point.logEpsilon * point.logEpsilon;
            }

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            return slope;
        }

        function displayResults(results) {
            const container = document.getElementById('boxResults');
            container.innerHTML = results.map(r => `
                <div class="stat-row">
                    <span class="stat-label">Box ${r.size}√ó${r.size}:</span>
                    <span class="stat-value">${r.count} boxes</span>
                </div>
            `).join('');
        }

        function drawLogLogPlot(results) {
            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            const filteredResults = results.filter(r => r.count > 0);
            if (filteredResults.length < 2) return;

            const logData = filteredResults.map(r => ({
                x: Math.log(1 / r.size),
                y: Math.log(r.count)
            }));

            // Find bounds
            const minX = Math.min(...logData.map(d => d.x));
            const maxX = Math.max(...logData.map(d => d.x));
            const minY = Math.min(...logData.map(d => d.y));
            const maxY = Math.max(...logData.map(d => d.y));

            const padding = 30;
            const plotWidth = chartCanvas.width - 2 * padding;
            const plotHeight = chartCanvas.height - 2 * padding;

            // Draw axes
            chartCtx.strokeStyle = '#666';
            chartCtx.lineWidth = 1;
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding);
            chartCtx.lineTo(padding, chartCanvas.height - padding);
            chartCtx.lineTo(chartCanvas.width - padding, chartCanvas.height - padding);
            chartCtx.stroke();

            // Plot points
            chartCtx.fillStyle = '#9d4edd';
            for (const point of logData) {
                const x = padding + ((point.x - minX) / (maxX - minX)) * plotWidth;
                const y = chartCanvas.height - padding - ((point.y - minY) / (maxY - minY)) * plotHeight;
                chartCtx.beginPath();
                chartCtx.arc(x, y, 4, 0, Math.PI * 2);
                chartCtx.fill();
            }

            // Draw regression line
            const dimension = linearRegression(logData.map(d => ({ logEpsilon: d.x, logN: d.y })));
            const avgX = logData.reduce((s, d) => s + d.x, 0) / logData.length;
            const avgY = logData.reduce((s, d) => s + d.y, 0) / logData.length;
            const intercept = avgY - dimension * avgX;

            const lineY1 = dimension * minX + intercept;
            const lineY2 = dimension * maxX + intercept;

            chartCtx.strokeStyle = '#c77dff';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(
                padding,
                chartCanvas.height - padding - ((lineY1 - minY) / (maxY - minY)) * plotHeight
            );
            chartCtx.lineTo(
                chartCanvas.width - padding,
                chartCanvas.height - padding - ((lineY2 - minY) / (maxY - minY)) * plotHeight
            );
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#888';
            chartCtx.font = '10px sans-serif';
            chartCtx.fillText('log(1/Œµ)', chartCanvas.width - 50, chartCanvas.height - 10);
            chartCtx.save();
            chartCtx.translate(10, 80);
            chartCtx.rotate(-Math.PI/2);
            chartCtx.fillText('log(N)', 0, 0);
            chartCtx.restore();
        }

        function showBoxesVisualization(grid, boxSize, width, height) {
            boxCtx.clearRect(0, 0, boxCanvas.width, boxCanvas.height);
            boxCtx.strokeStyle = 'rgba(157, 78, 221, 0.5)';
            boxCtx.fillStyle = 'rgba(157, 78, 221, 0.2)';
            boxCtx.lineWidth = 0.5;

            for (let y = 0; y < height; y += boxSize) {
                for (let x = 0; x < width; x += boxSize) {
                    // Check if any pixel in this box is set
                    let hasPixel = false;
                    for (let dy = 0; dy < boxSize && y + dy < height && !hasPixel; dy++) {
                        for (let dx = 0; dx < boxSize && x + dx < width && !hasPixel; dx++) {
                            if (grid[y + dy][x + dx]) {
                                hasPixel = true;
                            }
                        }
                    }

                    if (hasPixel) {
                        boxCtx.fillRect(x, y, boxSize, boxSize);
                        boxCtx.strokeRect(x, y, boxSize, boxSize);
                    }
                }
            }
        }

        // Event listeners
        document.getElementById('analyzeBtn').addEventListener('click', analyzeBoxCounting);

        // Initialize
        drawFractal();
    

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });</script>
</body>
</html>
