<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Cone - Agent Perception - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0e1a; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #60a5fa; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; background: #1a1f2e; color: #e8e6e1; border: 1px solid #333; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #60a5fa; color: #0a0e1a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #3b82f6; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 4px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #60a5fa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .behavior-desc { background: rgba(255,255,255,0.05); padding: 8px; border-radius: 5px; margin-bottom: 15px; font-size: 0.75rem; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Vision Cone: Agent Perception</h1>
            <p class="description">Agents perceive the world through vision cones. Their behavior depends on what they can see - demonstrating how limited perception affects collective behavior.</p>

            <div class="control-group">
                <label>Agents: <span id="agentsVal">30</span></label>
                <input type="range" id="agents" min="5" max="60" value="30">
            </div>
            <div class="control-group">
                <label>Vision Angle: <span id="angleVal">90</span>°</label>
                <input type="range" id="angle" min="10" max="360" value="90">
            </div>
            <div class="control-group">
                <label>Vision Range: <span id="rangeVal">100</span></label>
                <input type="range" id="range" min="30" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Speed: <span id="speedVal">2</span></label>
                <input type="range" id="speed" min="0.5" max="5" step="0.5" value="2">
            </div>
            <div class="control-group">
                <label>Turn Rate: <span id="turnVal">0.1</span></label>
                <input type="range" id="turn" min="0.02" max="0.3" step="0.02" value="0.1">
            </div>
            <div class="control-group">
                <label>Behavior</label>
                <select id="behavior">
                    <option value="follow">Follow (chase visible agents)</option>
                    <option value="avoid">Avoid (flee from visible agents)</option>
                    <option value="flock">Flock (align with visible agents)</option>
                    <option value="hunt">Hunt (predator-prey)</option>
                </select>
            </div>

            <div class="behavior-desc" id="behaviorDesc">
                Agents turn toward and follow any agent they see in their vision cone.
            </div>

            <button id="reset">Reset Simulation</button>
            <button id="pause">Pause</button>
            <button id="showCones">Toggle Vision Cones</button>

            <div class="stats">
                <div>Avg Visible Agents: <span id="avgVisible">0</span></div>
                <div>Isolated Agents: <span id="isolated">0</span></div>
                <div>Avg Heading Alignment: <span id="alignment">0</span>°</div>
                <div>Cluster Count: <span id="clusters">0</span></div>
            </div>

            <p class="description">Narrow vision angles create more complex dynamics. Wide angles (360°) give agents omniscient vision. Try different combinations to see emergent behaviors!</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        let agents = [];
        let paused = false;
        let showVisionCones = true;

        const behaviorDescriptions = {
            follow: 'Agents turn toward and follow any agent they see in their vision cone.',
            avoid: 'Agents flee from any agent they see, leading to dispersion.',
            flock: 'Agents align their heading with visible neighbors (Reynolds flocking).',
            hunt: 'Red predators chase blue prey. Prey flee from visible predators.'
        };

        let params = {
            agents: 30,
            angle: 90,
            range: 100,
            speed: 2,
            turn: 0.1,
            behavior: 'follow'
        };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }

        function init() {
            resize();
            agents = [];

            for (let i = 0; i < params.agents; i++) {
                agents.push({
                    id: i,
                    x: 50 + Math.random() * (W - 100),
                    y: 50 + Math.random() * (H - 100),
                    heading: Math.random() * Math.PI * 2,
                    type: params.behavior === 'hunt' ? (i < params.agents / 5 ? 'predator' : 'prey') : 'normal'
                });
            }

            document.getElementById('behaviorDesc').textContent = behaviorDescriptions[params.behavior];
        }

        function normalizeAngle(a) {
            while (a < 0) a += Math.PI * 2;
            while (a >= Math.PI * 2) a -= Math.PI * 2;
            return a;
        }

        function angleDiff(a, b) {
            let diff = normalizeAngle(a) - normalizeAngle(b);
            if (diff > Math.PI) diff -= Math.PI * 2;
            if (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }

        function canSee(agent, target) {
            const dx = target.x - agent.x;
            const dy = target.y - agent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > params.range || dist < 1) return false;

            const angleToTarget = Math.atan2(dy, dx);
            const halfCone = (params.angle * Math.PI / 180) / 2;

            const diff = Math.abs(angleDiff(angleToTarget, agent.heading));
            return diff <= halfCone;
        }

        function getVisibleAgents(agent) {
            return agents.filter(other => other.id !== agent.id && canSee(agent, other));
        }

        function step() {
            if (paused) return;

            for (const agent of agents) {
                const visible = getVisibleAgents(agent);
                agent.visibleCount = visible.length;

                let desiredHeading = agent.heading;

                switch (params.behavior) {
                    case 'follow':
                        if (visible.length > 0) {
                            // Average position of visible agents
                            let avgX = 0, avgY = 0;
                            for (const v of visible) {
                                avgX += v.x;
                                avgY += v.y;
                            }
                            avgX /= visible.length;
                            avgY /= visible.length;
                            desiredHeading = Math.atan2(avgY - agent.y, avgX - agent.x);
                        } else {
                            // Random walk
                            desiredHeading += (Math.random() - 0.5) * 0.3;
                        }
                        break;

                    case 'avoid':
                        if (visible.length > 0) {
                            let avgX = 0, avgY = 0;
                            for (const v of visible) {
                                avgX += v.x;
                                avgY += v.y;
                            }
                            avgX /= visible.length;
                            avgY /= visible.length;
                            // Move away from average
                            desiredHeading = Math.atan2(agent.y - avgY, agent.x - avgX);
                        } else {
                            desiredHeading += (Math.random() - 0.5) * 0.2;
                        }
                        break;

                    case 'flock':
                        if (visible.length > 0) {
                            // Alignment: average heading
                            let avgHeading = 0;
                            for (const v of visible) {
                                avgHeading += v.heading;
                            }
                            avgHeading /= visible.length;

                            // Cohesion: move toward center
                            let avgX = 0, avgY = 0;
                            for (const v of visible) {
                                avgX += v.x;
                                avgY += v.y;
                            }
                            avgX /= visible.length;
                            avgY /= visible.length;
                            const cohesionHeading = Math.atan2(avgY - agent.y, avgX - agent.x);

                            // Separation: avoid too close
                            let sepX = 0, sepY = 0;
                            for (const v of visible) {
                                const dx = agent.x - v.x;
                                const dy = agent.y - v.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 30) {
                                    sepX += dx / dist;
                                    sepY += dy / dist;
                                }
                            }
                            const separationHeading = Math.atan2(sepY, sepX);

                            // Combine behaviors
                            desiredHeading = avgHeading * 0.4 + cohesionHeading * 0.3 + separationHeading * 0.3;
                        } else {
                            desiredHeading += (Math.random() - 0.5) * 0.2;
                        }
                        break;

                    case 'hunt':
                        if (agent.type === 'predator') {
                            const prey = visible.filter(v => v.type === 'prey');
                            if (prey.length > 0) {
                                // Chase nearest prey
                                let nearest = prey[0];
                                let minDist = Infinity;
                                for (const p of prey) {
                                    const dist = Math.hypot(p.x - agent.x, p.y - agent.y);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        nearest = p;
                                    }
                                }
                                desiredHeading = Math.atan2(nearest.y - agent.y, nearest.x - agent.x);
                            } else {
                                desiredHeading += (Math.random() - 0.5) * 0.3;
                            }
                        } else { // prey
                            const predators = visible.filter(v => v.type === 'predator');
                            if (predators.length > 0) {
                                // Flee from predators
                                let avgX = 0, avgY = 0;
                                for (const p of predators) {
                                    avgX += p.x;
                                    avgY += p.y;
                                }
                                avgX /= predators.length;
                                avgY /= predators.length;
                                desiredHeading = Math.atan2(agent.y - avgY, agent.x - avgX);
                            } else {
                                desiredHeading += (Math.random() - 0.5) * 0.1;
                            }
                        }
                        break;
                }

                // Gradually turn toward desired heading
                const diff = angleDiff(desiredHeading, agent.heading);
                if (Math.abs(diff) > params.turn) {
                    agent.heading += Math.sign(diff) * params.turn;
                } else {
                    agent.heading = desiredHeading;
                }

                agent.heading = normalizeAngle(agent.heading);

                // Move forward
                const speed = params.behavior === 'hunt' && agent.type === 'predator' ?
                    params.speed * 1.2 : params.speed;
                agent.x += Math.cos(agent.heading) * speed;
                agent.y += Math.sin(agent.heading) * speed;

                // Wrap around
                if (agent.x < 0) agent.x = W;
                if (agent.x > W) agent.x = 0;
                if (agent.y < 0) agent.y = H;
                if (agent.y > H) agent.y = 0;
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Draw vision cones
            if (showVisionCones) {
                for (const agent of agents) {
                    const halfAngle = (params.angle * Math.PI / 180) / 2;

                    ctx.fillStyle = agent.type === 'predator' ? 'rgba(239, 68, 68, 0.1)' :
                                    agent.type === 'prey' ? 'rgba(59, 130, 246, 0.1)' :
                                    'rgba(96, 165, 250, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(agent.x, agent.y);
                    ctx.arc(agent.x, agent.y, params.range,
                            agent.heading - halfAngle,
                            agent.heading + halfAngle);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw agents
            for (const agent of agents) {
                const color = agent.type === 'predator' ? '#ef4444' :
                              agent.type === 'prey' ? '#3b82f6' : '#22c55e';

                // Body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Direction indicator
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(agent.x, agent.y);
                ctx.lineTo(
                    agent.x + Math.cos(agent.heading) * 15,
                    agent.y + Math.sin(agent.heading) * 15
                );
                ctx.stroke();
            }

            // Calculate stats
            const avgVisible = agents.reduce((sum, a) => sum + (a.visibleCount || 0), 0) / agents.length;
            const isolated = agents.filter(a => (a.visibleCount || 0) === 0).length;

            // Alignment: average angular deviation from mean heading
            let sumSin = 0, sumCos = 0;
            for (const agent of agents) {
                sumSin += Math.sin(agent.heading);
                sumCos += Math.cos(agent.heading);
            }
            const avgHeading = Math.atan2(sumSin, sumCos);
            let totalDeviation = 0;
            for (const agent of agents) {
                totalDeviation += Math.abs(angleDiff(agent.heading, avgHeading));
            }
            const alignment = (totalDeviation / agents.length) * 180 / Math.PI;

            // Simple cluster count
            const visited = new Set();
            let clusters = 0;
            for (const agent of agents) {
                if (visited.has(agent.id)) continue;
                clusters++;
                const queue = [agent];
                while (queue.length > 0) {
                    const current = queue.shift();
                    if (visited.has(current.id)) continue;
                    visited.add(current.id);
                    for (const other of agents) {
                        if (visited.has(other.id)) continue;
                        const dist = Math.hypot(other.x - current.x, other.y - current.y);
                        if (dist < 40) {
                            queue.push(other);
                        }
                    }
                }
            }

            document.getElementById('avgVisible').textContent = avgVisible.toFixed(1);
            document.getElementById('isolated').textContent = isolated;
            document.getElementById('alignment').textContent = alignment.toFixed(1);
            document.getElementById('clusters').textContent = clusters;
        }

        function animate() {
            step();
            draw();
            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('agents').addEventListener('input', e => {
            params.agents = +e.target.value;
            document.getElementById('agentsVal').textContent = params.agents;
        });
        document.getElementById('angle').addEventListener('input', e => {
            params.angle = +e.target.value;
            document.getElementById('angleVal').textContent = params.angle;
        });
        document.getElementById('range').addEventListener('input', e => {
            params.range = +e.target.value;
            document.getElementById('rangeVal').textContent = params.range;
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
        });
        document.getElementById('turn').addEventListener('input', e => {
            params.turn = +e.target.value;
            document.getElementById('turnVal').textContent = params.turn.toFixed(2);
        });
        document.getElementById('behavior').addEventListener('change', e => {
            params.behavior = e.target.value;
            document.getElementById('behaviorDesc').textContent = behaviorDescriptions[params.behavior];
            init();
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('showCones').addEventListener('click', () => {
            showVisionCones = !showVisionCones;
            document.getElementById('showCones').textContent = showVisionCones ? 'Hide Vision Cones' : 'Show Vision Cones';
        });

        window.addEventListener('resize', resize);
        init();
        animate();
    </script>
</body>
</html>
