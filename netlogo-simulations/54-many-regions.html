<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Many Regions - Comparative Dynamics - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0a0f; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 1fr); gap: 2px; padding: 2px; background: #222; }
        .region { position: relative; background: #111; }
        .region canvas { width: 100%; height: 100%; }
        .region-label { position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 4px; font-size: 11px; color: #fff; }
        .region-stats { position: absolute; bottom: 5px; left: 5px; background: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 4px; font-size: 10px; color: #aaa; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #f59e0b; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #d97706; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #b45309; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f59e0b; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .region-config { background: rgba(255,255,255,0.05); padding: 8px; border-radius: 5px; margin-bottom: 8px; }
        .region-config h3 { font-size: 0.8rem; color: #f59e0b; margin-bottom: 5px; }
        .mini-slider { display: flex; align-items: center; gap: 5px; margin-bottom: 4px; }
        .mini-slider label { font-size: 0.65rem; width: 60px; margin: 0; }
        .mini-slider input { flex: 1; }
        .mini-slider span { font-size: 0.65rem; width: 30px; text-align: right; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <!-- Regions will be created dynamically -->
        </div>
        <div id="controls">
            <h1>Many Regions</h1>
            <p class="description">Compare population dynamics across 6 regions with different parameters. Watch how variations in birth rate, death rate, and carrying capacity affect outcomes.</p>

            <div class="control-group">
                <label>Simulation Type:</label>
                <select id="simType">
                    <option value="population">Population Growth</option>
                    <option value="predator-prey">Predator-Prey</option>
                    <option value="epidemic">Epidemic Spread</option>
                    <option value="resources">Resource Competition</option>
                </select>
            </div>

            <div class="control-group">
                <label>Global Speed: <span id="speedVal">1</span>x</label>
                <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1">
            </div>

            <button id="reset">Reset All Regions</button>
            <button id="randomize">Randomize Parameters</button>
            <button id="sync">Sync to Region 1</button>

            <div class="stats">
                <div>Time: <span id="time">0</span></div>
                <div>Best Region: <span id="bestRegion">-</span></div>
                <div>Total Population: <span id="totalPop">0</span></div>
            </div>

            <p class="description"><strong>Region Parameters:</strong></p>
            <div id="regionConfigs"></div>

            <p class="description" style="margin-top:10px;"><strong>Key Insight:</strong> Small parameter differences lead to vastly different outcomes over time - a demonstration of sensitive dependence.</p>
        </div>
    </div>
    <script>
        const container = document.getElementById('canvas-container');
        const configContainer = document.getElementById('regionConfigs');

        const regionColors = ['#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#a855f7', '#ec4899'];
        const regionNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta'];

        let regions = [];
        let simulationTime = 0;
        let globalSpeed = 1;

        const simConfigs = {
            population: {
                params: ['birthRate', 'deathRate', 'capacity'],
                labels: ['Birth', 'Death', 'K'],
                defaults: [0.1, 0.05, 500],
                ranges: [[0.01, 0.3], [0.01, 0.2], [100, 1000]]
            },
            'predator-prey': {
                params: ['preyBirth', 'predation', 'predDeath'],
                labels: ['Prey B', 'Hunt', 'Pred D'],
                defaults: [0.1, 0.01, 0.05],
                ranges: [[0.05, 0.2], [0.005, 0.03], [0.02, 0.1]]
            },
            epidemic: {
                params: ['beta', 'gamma', 'vaccination'],
                labels: ['β', 'γ', 'Vax%'],
                defaults: [0.3, 0.1, 0],
                ranges: [[0.1, 0.5], [0.05, 0.2], [0, 0.5]]
            },
            resources: {
                params: ['growth', 'consumption', 'regen'],
                labels: ['Grow', 'Eat', 'Regen'],
                defaults: [0.05, 0.02, 0.01],
                ranges: [[0.02, 0.1], [0.01, 0.05], [0.005, 0.03]]
            }
        };

        let currentSimType = 'population';

        function createRegions() {
            container.innerHTML = '';
            configContainer.innerHTML = '';
            regions = [];

            for (let i = 0; i < 6; i++) {
                // Create region element
                const div = document.createElement('div');
                div.className = 'region';
                div.innerHTML = `
                    <canvas id="region${i}"></canvas>
                    <div class="region-label" style="border-left: 3px solid ${regionColors[i]}">Region ${regionNames[i]}</div>
                    <div class="region-stats" id="stats${i}">Pop: 0</div>
                `;
                container.appendChild(div);

                const canvas = document.getElementById(`region${i}`);
                const rect = div.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                // Create region config UI
                const config = simConfigs[currentSimType];
                const configDiv = document.createElement('div');
                configDiv.className = 'region-config';
                configDiv.innerHTML = `<h3 style="color: ${regionColors[i]}">${regionNames[i]}</h3>`;

                const params = {};
                config.params.forEach((param, j) => {
                    const range = config.ranges[j];
                    const defaultVal = config.defaults[j] * (0.8 + Math.random() * 0.4);
                    params[param] = defaultVal;

                    const slider = document.createElement('div');
                    slider.className = 'mini-slider';
                    slider.innerHTML = `
                        <label>${config.labels[j]}</label>
                        <input type="range" id="r${i}_${param}" min="${range[0]}" max="${range[1]}" step="${(range[1]-range[0])/100}" value="${defaultVal}">
                        <span id="v${i}_${param}">${defaultVal.toFixed(2)}</span>
                    `;
                    configDiv.appendChild(slider);
                });
                configContainer.appendChild(configDiv);

                // Initialize region data
                regions.push({
                    canvas,
                    ctx: canvas.getContext('2d'),
                    params,
                    history: [],
                    state: initState(currentSimType)
                });
            }

            // Add slider listeners
            document.querySelectorAll('.mini-slider input').forEach(input => {
                input.addEventListener('input', e => {
                    const [_, regionIdx, param] = e.target.id.split('_');
                    const idx = parseInt(regionIdx.replace('r', ''));
                    regions[idx].params[param] = parseFloat(e.target.value);
                    document.getElementById(`v${idx}_${param}`).textContent = parseFloat(e.target.value).toFixed(2);
                });
            });
        }

        function initState(simType) {
            switch (simType) {
                case 'population':
                    return { population: 50 + Math.random() * 50 };
                case 'predator-prey':
                    return { prey: 100, predators: 20 };
                case 'epidemic':
                    return { S: 990, I: 10, R: 0 };
                case 'resources':
                    return { population: 50, resources: 500 };
                default:
                    return {};
            }
        }

        function stepRegion(region, dt) {
            const p = region.params;
            const s = region.state;

            switch (currentSimType) {
                case 'population':
                    // Logistic growth
                    const r = p.birthRate - p.deathRate;
                    const dN = r * s.population * (1 - s.population / p.capacity);
                    s.population = Math.max(0, s.population + dN * dt);
                    break;

                case 'predator-prey':
                    // Lotka-Volterra
                    const dPrey = (p.preyBirth * s.prey - p.predation * s.prey * s.predators) * dt;
                    const dPred = (p.predation * s.prey * s.predators * 0.1 - p.predDeath * s.predators) * dt;
                    s.prey = Math.max(0, s.prey + dPrey);
                    s.predators = Math.max(0, s.predators + dPred);
                    break;

                case 'epidemic':
                    // SIR model
                    const N = s.S + s.I + s.R;
                    const effectiveBeta = p.beta * (1 - p.vaccination);
                    const newInfected = effectiveBeta * s.S * s.I / N * dt;
                    const newRecovered = p.gamma * s.I * dt;
                    s.S = Math.max(0, s.S - newInfected);
                    s.I = Math.max(0, s.I + newInfected - newRecovered);
                    s.R = s.R + newRecovered;
                    break;

                case 'resources':
                    // Resource-population dynamics
                    const popGrowth = p.growth * s.population * (s.resources / 500) * dt;
                    const consumption = p.consumption * s.population * dt;
                    const regen = p.regen * (500 - s.resources) * dt;
                    s.population = Math.max(0, s.population + popGrowth - p.consumption * s.population * 0.5 * dt);
                    s.resources = Math.max(0, Math.min(500, s.resources - consumption + regen));
                    break;
            }

            // Record history
            region.history.push(getMainValue(region));
            if (region.history.length > 200) region.history.shift();
        }

        function getMainValue(region) {
            switch (currentSimType) {
                case 'population': return region.state.population;
                case 'predator-prey': return region.state.prey + region.state.predators;
                case 'epidemic': return region.state.I;
                case 'resources': return region.state.population;
            }
            return 0;
        }

        function getStatsText(region) {
            const s = region.state;
            switch (currentSimType) {
                case 'population':
                    return `Pop: ${Math.round(s.population)}`;
                case 'predator-prey':
                    return `Prey: ${Math.round(s.prey)} | Pred: ${Math.round(s.predators)}`;
                case 'epidemic':
                    return `S: ${Math.round(s.S)} I: ${Math.round(s.I)} R: ${Math.round(s.R)}`;
                case 'resources':
                    return `Pop: ${Math.round(s.population)} | Res: ${Math.round(s.resources)}`;
            }
            return '';
        }

        function drawRegion(region, idx) {
            const ctx = region.ctx;
            const canvas = region.canvas;
            const W = canvas.width;
            const H = canvas.height;

            // Background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, W, H);

            if (region.history.length < 2) return;

            // Find max for scaling
            const maxVal = Math.max(...region.history, 100);

            // Draw history graph
            ctx.strokeStyle = regionColors[idx];
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < region.history.length; i++) {
                const x = (i / 200) * W;
                const y = H - (region.history[i] / maxVal) * H * 0.8 - 10;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fill under curve
            ctx.lineTo((region.history.length - 1) / 200 * W, H);
            ctx.lineTo(0, H);
            ctx.closePath();
            ctx.fillStyle = regionColors[idx] + '20';
            ctx.fill();

            // Draw secondary line for predator-prey
            if (currentSimType === 'predator-prey') {
                const predHistory = [];
                // We need to track predator history separately - simplified here
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const predVal = region.state.predators;
                const y = H - (predVal / maxVal) * H * 0.8 - 10;
                ctx.moveTo(W - 5, y);
                ctx.lineTo(W, y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Update stats display
            document.getElementById(`stats${idx}`).textContent = getStatsText(region);
        }

        function updateGlobalStats() {
            let totalPop = 0;
            let bestIdx = 0;
            let bestVal = 0;

            regions.forEach((region, idx) => {
                const val = getMainValue(region);
                totalPop += val;
                if (val > bestVal) {
                    bestVal = val;
                    bestIdx = idx;
                }
            });

            document.getElementById('time').textContent = simulationTime.toFixed(1);
            document.getElementById('bestRegion').textContent = regionNames[bestIdx];
            document.getElementById('totalPop').textContent = Math.round(totalPop);
        }

        function animate() {
            const dt = 0.1 * globalSpeed;
            simulationTime += dt;

            regions.forEach((region, idx) => {
                stepRegion(region, dt);
                drawRegion(region, idx);
            });

            updateGlobalStats();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('simType').addEventListener('change', e => {
            currentSimType = e.target.value;
            simulationTime = 0;
            createRegions();
        });

        document.getElementById('speed').addEventListener('input', e => {
            globalSpeed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = globalSpeed.toFixed(1);
        });

        document.getElementById('reset').addEventListener('click', () => {
            simulationTime = 0;
            regions.forEach(region => {
                region.state = initState(currentSimType);
                region.history = [];
            });
        });

        document.getElementById('randomize').addEventListener('click', () => {
            const config = simConfigs[currentSimType];
            regions.forEach((region, i) => {
                config.params.forEach((param, j) => {
                    const range = config.ranges[j];
                    const val = range[0] + Math.random() * (range[1] - range[0]);
                    region.params[param] = val;
                    document.getElementById(`r${i}_${param}`).value = val;
                    document.getElementById(`v${i}_${param}`).textContent = val.toFixed(2);
                });
            });
        });

        document.getElementById('sync').addEventListener('click', () => {
            const config = simConfigs[currentSimType];
            const sourceParams = regions[0].params;
            regions.forEach((region, i) => {
                if (i === 0) return;
                config.params.forEach(param => {
                    region.params[param] = sourceParams[param];
                    document.getElementById(`r${i}_${param}`).value = sourceParams[param];
                    document.getElementById(`v${i}_${param}`).textContent = sourceParams[param].toFixed(2);
                });
            });
        });

        window.addEventListener('resize', () => {
            regions.forEach((region, i) => {
                const div = region.canvas.parentElement;
                const rect = div.getBoundingClientRect();
                region.canvas.width = rect.width;
                region.canvas.height = rect.height;
            });
        });

        createRegions();
        animate();
    </script>
</body>
</html>
