<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painted Desert Challenge - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0e1a; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #60a5fa; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; background: #1a1f2e; color: #e8e6e1; border: 1px solid #333; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #60a5fa; color: #0a0e1a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #3b82f6; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 5px; display: flex; justify-content: space-between; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #60a5fa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .team-colors { display: flex; gap: 10px; margin-bottom: 15px; }
        .team-color { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #444; }
        .score { font-size: 1.5rem; font-weight: bold; }
        .winner { color: #22c55e; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Painted Desert Challenge</h1>
            <p class="description">Competing agents claim territory by painting cells. Each team uses different strategies to maximize their coverage. Watch emergent patterns form as they compete for space!</p>

            <div class="team-colors">
                <div class="team-color" style="background: #ef4444;"></div>
                <div class="team-color" style="background: #3b82f6;"></div>
                <div class="team-color" style="background: #22c55e;"></div>
                <div class="team-color" style="background: #eab308;"></div>
            </div>

            <div class="control-group">
                <label>Teams: <span id="teamsVal">4</span></label>
                <input type="range" id="teams" min="2" max="4" value="4">
            </div>
            <div class="control-group">
                <label>Agents per Team: <span id="agentsVal">5</span></label>
                <input type="range" id="agents" min="1" max="10" value="5">
            </div>
            <div class="control-group">
                <label>Grid Size: <span id="gridVal">50</span></label>
                <input type="range" id="grid" min="30" max="100" value="50">
            </div>
            <div class="control-group">
                <label>Agent Speed: <span id="speedVal">2</span></label>
                <input type="range" id="speed" min="1" max="5" value="2">
            </div>
            <div class="control-group">
                <label>Strategy</label>
                <select id="strategy">
                    <option value="random">Random Walk</option>
                    <option value="spiral">Spiral Pattern</option>
                    <option value="expand">Expand Outward</option>
                    <option value="greedy">Greedy (Seek Unpainted)</option>
                </select>
            </div>

            <button id="reset">New Game</button>
            <button id="pause">Pause</button>

            <div class="stats">
                <div><span style="color:#ef4444">Red Team:</span> <span id="score0" class="score">0%</span></div>
                <div><span style="color:#3b82f6">Blue Team:</span> <span id="score1" class="score">0%</span></div>
                <div><span style="color:#22c55e">Green Team:</span> <span id="score2" class="score">0%</span></div>
                <div><span style="color:#eab308">Yellow Team:</span> <span id="score3" class="score">0%</span></div>
                <div>Unclaimed: <span id="unclaimed">100%</span></div>
                <div>Time: <span id="time">0</span>s</div>
            </div>

            <div id="winnerDisplay"></div>

            <p class="description">The game ends when all territory is claimed or no new territory has been claimed for 5 seconds. Try different strategies to see which wins!</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H, cellSize, gridW, gridH;
        let grid = [];
        let agents = [];
        let paused = false;
        let startTime = 0;
        let lastChangeTime = 0;
        let gameOver = false;

        const teamColors = ['#ef4444', '#3b82f6', '#22c55e', '#eab308'];
        const teamBgColors = ['rgba(239, 68, 68, 0.7)', 'rgba(59, 130, 246, 0.7)', 'rgba(34, 197, 94, 0.7)', 'rgba(234, 179, 8, 0.7)'];

        let params = { teams: 4, agents: 5, grid: 50, speed: 2, strategy: 'random' };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            W = canvas.width;
            H = canvas.height;
            cellSize = Math.min(W / params.grid, H / params.grid);
            gridW = Math.floor(W / cellSize);
            gridH = Math.floor(H / cellSize);
        }

        function init() {
            resize();
            grid = [];
            agents = [];
            gameOver = false;
            startTime = performance.now();
            lastChangeTime = startTime;
            document.getElementById('winnerDisplay').innerHTML = '';

            // Initialize grid
            for (let y = 0; y < gridH; y++) {
                grid[y] = [];
                for (let x = 0; x < gridW; x++) {
                    grid[y][x] = -1; // Unclaimed
                }
            }

            // Create agents for each team
            const startPositions = [
                { x: 0, y: 0 },
                { x: gridW - 1, y: gridH - 1 },
                { x: gridW - 1, y: 0 },
                { x: 0, y: gridH - 1 }
            ];

            for (let t = 0; t < params.teams; t++) {
                const start = startPositions[t];
                for (let a = 0; a < params.agents; a++) {
                    agents.push({
                        x: start.x + (Math.random() - 0.5) * 5,
                        y: start.y + (Math.random() - 0.5) * 5,
                        team: t,
                        angle: Math.random() * Math.PI * 2,
                        spiralRadius: 1,
                        spiralAngle: Math.random() * Math.PI * 2
                    });
                }
            }
        }

        function moveAgent(agent) {
            const speed = params.speed;
            let dx = 0, dy = 0;

            switch (params.strategy) {
                case 'random':
                    agent.angle += (Math.random() - 0.5) * 0.5;
                    dx = Math.cos(agent.angle) * speed;
                    dy = Math.sin(agent.angle) * speed;
                    break;

                case 'spiral':
                    agent.spiralAngle += 0.1;
                    agent.spiralRadius += 0.02;
                    const cx = agent.team === 0 || agent.team === 3 ? 0 : gridW;
                    const cy = agent.team === 0 || agent.team === 2 ? 0 : gridH;
                    const targetX = cx + Math.cos(agent.spiralAngle) * agent.spiralRadius;
                    const targetY = cy + Math.sin(agent.spiralAngle) * agent.spiralRadius;
                    const dxT = targetX - agent.x;
                    const dyT = targetY - agent.y;
                    const dist = Math.sqrt(dxT * dxT + dyT * dyT);
                    if (dist > 0) {
                        dx = (dxT / dist) * speed;
                        dy = (dyT / dist) * speed;
                    }
                    break;

                case 'expand':
                    const centerX = gridW / 2;
                    const centerY = gridH / 2;
                    const toCenter = Math.atan2(centerY - agent.y, centerX - agent.x);
                    agent.angle = toCenter + (Math.random() - 0.5) * 1.0;
                    dx = Math.cos(agent.angle) * speed;
                    dy = Math.sin(agent.angle) * speed;
                    break;

                case 'greedy':
                    // Look for nearby unclaimed cells
                    let bestX = agent.x, bestY = agent.y;
                    let minDist = Infinity;
                    const searchRadius = 10;
                    for (let sy = -searchRadius; sy <= searchRadius; sy++) {
                        for (let sx = -searchRadius; sx <= searchRadius; sx++) {
                            const gx = Math.floor(agent.x) + sx;
                            const gy = Math.floor(agent.y) + sy;
                            if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
                                if (grid[gy][gx] === -1) {
                                    const d = sx * sx + sy * sy;
                                    if (d < minDist) {
                                        minDist = d;
                                        bestX = gx;
                                        bestY = gy;
                                    }
                                }
                            }
                        }
                    }
                    if (minDist < Infinity) {
                        const dxT = bestX - agent.x;
                        const dyT = bestY - agent.y;
                        const dist = Math.sqrt(dxT * dxT + dyT * dyT);
                        if (dist > 0) {
                            dx = (dxT / dist) * speed;
                            dy = (dyT / dist) * speed;
                        }
                    } else {
                        // Random if no unclaimed nearby
                        agent.angle += (Math.random() - 0.5) * 0.5;
                        dx = Math.cos(agent.angle) * speed;
                        dy = Math.sin(agent.angle) * speed;
                    }
                    break;
            }

            agent.x += dx;
            agent.y += dy;

            // Bounce off walls
            if (agent.x < 0) { agent.x = 0; agent.angle = Math.PI - agent.angle; }
            if (agent.x >= gridW) { agent.x = gridW - 0.1; agent.angle = Math.PI - agent.angle; }
            if (agent.y < 0) { agent.y = 0; agent.angle = -agent.angle; }
            if (agent.y >= gridH) { agent.y = gridH - 0.1; agent.angle = -agent.angle; }

            // Paint cell
            const gx = Math.floor(agent.x);
            const gy = Math.floor(agent.y);
            if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
                if (grid[gy][gx] !== agent.team) {
                    grid[gy][gx] = agent.team;
                    lastChangeTime = performance.now();
                }
            }
        }

        function update() {
            if (paused || gameOver) return;

            for (const agent of agents) {
                moveAgent(agent);
            }

            // Check for game over
            const now = performance.now();
            const scores = calculateScores();
            if (scores.unclaimed === 0 || (now - lastChangeTime > 5000)) {
                gameOver = true;
                showWinner(scores);
            }
        }

        function calculateScores() {
            const counts = new Array(params.teams).fill(0);
            let total = 0;

            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    total++;
                    if (grid[y][x] >= 0 && grid[y][x] < params.teams) {
                        counts[grid[y][x]]++;
                    }
                }
            }

            const unclaimed = total - counts.reduce((a, b) => a + b, 0);
            return {
                counts,
                total,
                unclaimed,
                percentages: counts.map(c => (c / total * 100).toFixed(1))
            };
        }

        function showWinner(scores) {
            const maxScore = Math.max(...scores.counts);
            const winners = scores.counts.map((c, i) => c === maxScore ? i : -1).filter(i => i >= 0);
            const teamNames = ['Red', 'Blue', 'Green', 'Yellow'];

            let text = '';
            if (winners.length === 1) {
                text = `<span style="color:${teamColors[winners[0]]}">${teamNames[winners[0]]} Team Wins!</span>`;
            } else {
                text = 'Tie: ' + winners.map(w => `<span style="color:${teamColors[w]}">${teamNames[w]}</span>`).join(' & ');
            }
            document.getElementById('winnerDisplay').innerHTML = `<div class="winner">${text}</div>`;
        }

        function draw() {
            ctx.fillStyle = '#1a1f2e';
            ctx.fillRect(0, 0, W, H);

            // Draw grid
            const offsetX = (W - gridW * cellSize) / 2;
            const offsetY = (H - gridH * cellSize) / 2;

            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const team = grid[y][x];
                    if (team >= 0) {
                        ctx.fillStyle = teamBgColors[team];
                        ctx.fillRect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw grid lines (subtle)
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= gridW; x++) {
                ctx.beginPath();
                ctx.moveTo(offsetX + x * cellSize, offsetY);
                ctx.lineTo(offsetX + x * cellSize, offsetY + gridH * cellSize);
                ctx.stroke();
            }
            for (let y = 0; y <= gridH; y++) {
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY + y * cellSize);
                ctx.lineTo(offsetX + gridW * cellSize, offsetY + y * cellSize);
                ctx.stroke();
            }

            // Draw agents
            for (const agent of agents) {
                ctx.fillStyle = teamColors[agent.team];
                ctx.beginPath();
                ctx.arc(
                    offsetX + agent.x * cellSize,
                    offsetY + agent.y * cellSize,
                    cellSize * 0.8,
                    0, Math.PI * 2
                );
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Update stats
            const scores = calculateScores();
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);

            for (let i = 0; i < 4; i++) {
                const el = document.getElementById(`score${i}`);
                if (i < params.teams) {
                    el.textContent = scores.percentages[i] + '%';
                    el.parentElement.style.display = 'flex';
                } else {
                    el.parentElement.style.display = 'none';
                }
            }
            document.getElementById('unclaimed').textContent = ((scores.unclaimed / scores.total) * 100).toFixed(1) + '%';
            document.getElementById('time').textContent = elapsed;
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('teams').addEventListener('input', e => {
            params.teams = +e.target.value;
            document.getElementById('teamsVal').textContent = params.teams;
        });
        document.getElementById('agents').addEventListener('input', e => {
            params.agents = +e.target.value;
            document.getElementById('agentsVal').textContent = params.agents;
        });
        document.getElementById('grid').addEventListener('input', e => {
            params.grid = +e.target.value;
            document.getElementById('gridVal').textContent = params.grid;
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
        });
        document.getElementById('strategy').addEventListener('change', e => {
            params.strategy = e.target.value;
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });

        window.addEventListener('resize', () => { resize(); });
        init();
        animate();
    </script>
</body>
</html>
