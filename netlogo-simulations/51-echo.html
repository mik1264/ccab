<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo - Complex Adaptive Systems - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #main-canvas { flex: 1; }
        #graph-canvas { height: 100px; border-top: 1px solid #333; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #22d3ee; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #22d3ee; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #06b6d4; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #22d3ee; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <canvas id="graph-canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Echo: Complex Adaptive Systems</h1>
            <p class="description">John Holland's Echo model. Agents gather resources, interact, reproduce, and evolve. Watch ecosystems emerge from simple rules of combat, trade, and heredity.</p>
            <div class="control-group">
                <label>Initial Agents: <span id="agentValue">50</span></label>
                <input type="range" id="agents" min="20" max="150" value="50">
            </div>
            <div class="control-group">
                <label>Resource Density: <span id="resourceValue">100</span></label>
                <input type="range" id="resource" min="50" max="300" value="100">
            </div>
            <div class="control-group">
                <label>Combat Threshold: <span id="combatValue">0.3</span></label>
                <input type="range" id="combat" min="0" max="1" step="0.1" value="0.3">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationValue">0.05</span></label>
                <input type="range" id="mutation" min="0.01" max="0.2" step="0.01" value="0.05">
            </div>
            <button id="reset">Reset Ecosystem</button>
            <button id="drought">Resource Drought</button>
            <button id="boom">Resource Boom</button>
            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Population: <span id="population">0</span></div>
                <div>Resources: <span id="resources">0</span></div>
                <div>Avg Fitness: <span id="fitness">0</span></div>
                <div>Species: <span id="species">0</span></div>
                <div>Trades: <span id="trades">0</span></div>
                <div>Combats: <span id="combats">0</span></div>
            </div>
        </div>
    </div>
    <script>
        const mainCanvas = document.getElementById('main-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');

        let width, height;
        let agents = [], resources = [];
        let generation = 0, trades = 0, combats = 0;
        let populationHistory = [];
        const maxHistory = 200;

        // Resource types
        const RESOURCE_TYPES = ['A', 'B', 'C', 'D'];
        const RESOURCE_COLORS = { A: '#ef4444', B: '#22c55e', C: '#3b82f6', D: '#f59e0b' };

        let params = { agents: 50, resource: 100, combat: 0.3, mutation: 0.05 };

        function resize() {
            mainCanvas.width = mainCanvas.clientWidth;
            mainCanvas.height = mainCanvas.clientHeight;
            graphCanvas.width = graphCanvas.clientWidth;
            graphCanvas.height = graphCanvas.clientHeight;
            width = mainCanvas.width;
            height = mainCanvas.height;
        }

        // Create agent with genome
        function createAgent(x, y, parent = null) {
            const genome = parent ? mutateGenome(parent.genome) : randomGenome();
            return {
                x: x !== undefined ? x : Math.random() * width,
                y: y !== undefined ? y : Math.random() * height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                genome: genome,
                reservoir: { A: 5, B: 5, C: 5, D: 5 },
                energy: 50,
                age: 0,
                generation: parent ? parent.generation + 1 : 0
            };
        }

        function randomGenome() {
            return {
                offense: Math.random(),        // Combat offense
                defense: Math.random(),        // Combat defense
                cooperation: Math.random(),    // Trade willingness
                gather: RESOURCE_TYPES[Math.floor(Math.random() * 4)], // Preferred resource
                speed: 0.5 + Math.random(),    // Movement speed
                size: 0.7 + Math.random() * 0.6 // Body size
            };
        }

        function mutateGenome(g) {
            const m = params.mutation;
            return {
                offense: Math.max(0, Math.min(1, g.offense + (Math.random() - 0.5) * m * 2)),
                defense: Math.max(0, Math.min(1, g.defense + (Math.random() - 0.5) * m * 2)),
                cooperation: Math.max(0, Math.min(1, g.cooperation + (Math.random() - 0.5) * m * 2)),
                gather: Math.random() < m ? RESOURCE_TYPES[Math.floor(Math.random() * 4)] : g.gather,
                speed: Math.max(0.3, Math.min(2, g.speed + (Math.random() - 0.5) * m)),
                size: Math.max(0.5, Math.min(1.5, g.size + (Math.random() - 0.5) * m))
            };
        }

        function getAgentColor(agent) {
            const r = Math.floor(agent.genome.offense * 200 + 55);
            const g = Math.floor(agent.genome.cooperation * 200 + 55);
            const b = Math.floor(agent.genome.defense * 200 + 55);
            return `rgb(${r},${g},${b})`;
        }

        function createResource() {
            return {
                x: Math.random() * width,
                y: Math.random() * height,
                type: RESOURCE_TYPES[Math.floor(Math.random() * 4)],
                amount: 3 + Math.floor(Math.random() * 5)
            };
        }

        function init() {
            resize();
            agents = [];
            resources = [];
            generation = 0;
            trades = 0;
            combats = 0;
            populationHistory = [];

            for (let i = 0; i < params.agents; i++) {
                agents.push(createAgent());
            }

            for (let i = 0; i < params.resource; i++) {
                resources.push(createResource());
            }
        }

        function update() {
            generation++;

            // Spawn new resources
            if (resources.length < params.resource && Math.random() < 0.1) {
                resources.push(createResource());
            }

            // Update agents
            for (let i = agents.length - 1; i >= 0; i--) {
                const agent = agents[i];

                // Movement toward preferred resource
                let targetX = agent.x, targetY = agent.y;
                let minDist = Infinity;
                for (let r of resources) {
                    if (r.type === agent.genome.gather) {
                        const dx = r.x - agent.x, dy = r.y - agent.y;
                        const dist = dx * dx + dy * dy;
                        if (dist < minDist) {
                            minDist = dist;
                            targetX = r.x;
                            targetY = r.y;
                        }
                    }
                }

                // Move toward target
                const dx = targetX - agent.x, dy = targetY - agent.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    agent.vx += (dx / dist) * 0.1 * agent.genome.speed;
                    agent.vy += (dy / dist) * 0.1 * agent.genome.speed;
                }

                // Random movement
                agent.vx += (Math.random() - 0.5) * 0.2;
                agent.vy += (Math.random() - 0.5) * 0.2;

                // Damping
                agent.vx *= 0.95;
                agent.vy *= 0.95;

                agent.x += agent.vx;
                agent.y += agent.vy;

                // Boundaries
                if (agent.x < 0 || agent.x > width) agent.vx *= -1;
                if (agent.y < 0 || agent.y > height) agent.vy *= -1;
                agent.x = Math.max(0, Math.min(width, agent.x));
                agent.y = Math.max(0, Math.min(height, agent.y));

                // Gather resources
                for (let j = resources.length - 1; j >= 0; j--) {
                    const r = resources[j];
                    const rdx = r.x - agent.x, rdy = r.y - agent.y;
                    if (rdx * rdx + rdy * rdy < 400) {
                        agent.reservoir[r.type]++;
                        agent.energy += 2;
                        r.amount--;
                        if (r.amount <= 0) {
                            resources.splice(j, 1);
                        }
                    }
                }

                // Energy cost
                agent.energy -= 0.1 * agent.genome.size * agent.genome.speed;
                agent.age++;

                // Death
                if (agent.energy <= 0 || agent.age > 2000) {
                    agents.splice(i, 1);
                    continue;
                }

                // Interactions with other agents
                for (let other of agents) {
                    if (other === agent) continue;
                    const odx = other.x - agent.x, ody = other.y - agent.y;
                    const odist = odx * odx + ody * ody;
                    if (odist > 900) continue;

                    // Decide: trade or combat?
                    const tradeWill = (agent.genome.cooperation + other.genome.cooperation) / 2;

                    if (Math.random() < tradeWill) {
                        // Trade - exchange resources
                        for (let type of RESOURCE_TYPES) {
                            if (agent.reservoir[type] > 3 && other.reservoir[type] < 3) {
                                agent.reservoir[type]--;
                                other.reservoir[type]++;
                                trades++;
                            }
                        }
                    } else if (Math.random() < params.combat) {
                        // Combat
                        const attackPower = agent.genome.offense * agent.genome.size * agent.energy / 50;
                        const defensePower = other.genome.defense * other.genome.size * other.energy / 50;

                        if (attackPower > defensePower) {
                            // Agent wins
                            const loot = Math.min(10, other.energy * 0.3);
                            agent.energy += loot;
                            other.energy -= loot * 1.5;
                        } else {
                            // Other wins
                            const loot = Math.min(10, agent.energy * 0.3);
                            other.energy += loot;
                            agent.energy -= loot * 1.5;
                        }
                        combats++;
                    }
                }

                // Reproduction
                const totalRes = Object.values(agent.reservoir).reduce((a, b) => a + b, 0);
                if (agent.energy > 80 && totalRes > 20 && agents.length < params.agents * 2) {
                    const child = createAgent(
                        agent.x + (Math.random() - 0.5) * 30,
                        agent.y + (Math.random() - 0.5) * 30,
                        agent
                    );
                    agent.energy -= 30;
                    for (let type of RESOURCE_TYPES) {
                        const give = Math.floor(agent.reservoir[type] / 2);
                        agent.reservoir[type] -= give;
                        child.reservoir[type] = give;
                    }
                    agents.push(child);
                }
            }

            // Record history
            populationHistory.push(agents.length);
            if (populationHistory.length > maxHistory) populationHistory.shift();
        }

        function draw() {
            // Clear
            mainCtx.fillStyle = '#0f0f1a';
            mainCtx.fillRect(0, 0, width, height);

            // Draw resources
            for (let r of resources) {
                mainCtx.fillStyle = RESOURCE_COLORS[r.type];
                mainCtx.beginPath();
                mainCtx.arc(r.x, r.y, 4 + r.amount, 0, Math.PI * 2);
                mainCtx.fill();
            }

            // Draw agents
            for (let agent of agents) {
                const size = 8 * agent.genome.size;
                const color = getAgentColor(agent);

                // Body
                mainCtx.fillStyle = color;
                mainCtx.beginPath();
                mainCtx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
                mainCtx.fill();

                // Energy bar
                const barWidth = size * 2;
                const energyPct = Math.min(1, agent.energy / 100);
                mainCtx.fillStyle = '#333';
                mainCtx.fillRect(agent.x - barWidth / 2, agent.y - size - 6, barWidth, 3);
                mainCtx.fillStyle = energyPct > 0.3 ? '#22c55e' : '#ef4444';
                mainCtx.fillRect(agent.x - barWidth / 2, agent.y - size - 6, barWidth * energyPct, 3);
            }

            // Draw graph
            graphCtx.fillStyle = '#0f0f1a';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (populationHistory.length > 1) {
                const maxPop = Math.max(...populationHistory, 10);

                graphCtx.strokeStyle = '#22d3ee';
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();
                for (let i = 0; i < populationHistory.length; i++) {
                    const x = (i / maxHistory) * graphCanvas.width;
                    const y = graphCanvas.height - (populationHistory[i] / maxPop) * graphCanvas.height * 0.9;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            }

            graphCtx.fillStyle = '#aaa';
            graphCtx.font = '10px sans-serif';
            graphCtx.fillText('Population over time', 10, 15);

            // Update stats
            document.getElementById('generation').textContent = generation;
            document.getElementById('population').textContent = agents.length;
            document.getElementById('resources').textContent = resources.length;

            const avgFitness = agents.length > 0 ?
                agents.reduce((sum, a) => sum + a.energy, 0) / agents.length : 0;
            document.getElementById('fitness').textContent = avgFitness.toFixed(1);

            // Count species (cluster by genome similarity)
            const speciesSet = new Set();
            for (let a of agents) {
                const key = `${Math.round(a.genome.offense * 5)}-${Math.round(a.genome.cooperation * 5)}-${a.genome.gather}`;
                speciesSet.add(key);
            }
            document.getElementById('species').textContent = speciesSet.size;
            document.getElementById('trades').textContent = trades;
            document.getElementById('combats').textContent = combats;
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('agents').addEventListener('input', e => {
            params.agents = parseInt(e.target.value);
            document.getElementById('agentValue').textContent = params.agents;
        });
        document.getElementById('resource').addEventListener('input', e => {
            params.resource = parseInt(e.target.value);
            document.getElementById('resourceValue').textContent = params.resource;
        });
        document.getElementById('combat').addEventListener('input', e => {
            params.combat = parseFloat(e.target.value);
            document.getElementById('combatValue').textContent = params.combat.toFixed(1);
        });
        document.getElementById('mutation').addEventListener('input', e => {
            params.mutation = parseFloat(e.target.value);
            document.getElementById('mutationValue').textContent = params.mutation.toFixed(2);
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('drought').addEventListener('click', () => {
            resources = resources.slice(0, Math.floor(resources.length / 3));
        });
        document.getElementById('boom').addEventListener('click', () => {
            for (let i = 0; i < 50; i++) {
                resources.push(createResource());
            }
        });

        window.addEventListener('resize', resize);
        init();
        animate();
    </script>
</body>
</html>
