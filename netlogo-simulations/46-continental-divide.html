<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Continental Divide - Watershed Analysis - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #06b6d4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #06b6d4; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #0891b2; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #06b6d4; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .legend { margin-top: 10px; font-size: 0.7rem; }
        .legend-item { display: flex; align-items: center; margin: 3px 0; }
        .legend-color { width: 20px; height: 10px; margin-right: 8px; border-radius: 2px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Continental Divide</h1>
            <p class="description">Watershed analysis simulation. Click to drop rain and watch water flow to different drainage basins. The continental divide separates waters flowing to different oceans.</p>
            <div class="control-group">
                <label>Terrain Roughness: <span id="roughnessValue">0.5</span></label>
                <input type="range" id="roughness" min="0.1" max="1.0" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>Mountain Height: <span id="heightValue">0.7</span></label>
                <input type="range" id="height" min="0.3" max="1.0" step="0.1" value="0.7">
            </div>
            <div class="control-group">
                <label>Rain Intensity: <span id="rainValue">20</span></label>
                <input type="range" id="rain" min="5" max="50" value="20">
            </div>
            <button id="reset">Generate New Terrain</button>
            <button id="showDivide">Highlight Divide</button>
            <button id="rainStorm">Rain Storm</button>
            <button id="clearWater">Clear Water</button>
            <div class="stats">
                <div>West Basin Area: <span id="westArea">0</span>%</div>
                <div>East Basin Area: <span id="eastArea">0</span>%</div>
                <div>Water Particles: <span id="particles">0</span></div>
                <div>Divide Length: <span id="divideLen">0</span> km</div>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#1e3a8a"></div>Pacific Drainage (West)</div>
                <div class="legend-item"><div class="legend-color" style="background:#dc2626"></div>Atlantic Drainage (East)</div>
                <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Continental Divide</div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height, terrain = [], waterDrops = [], basins = [];
        let gridSize = 4, cols, rows;
        let showDivide = false;
        let params = { roughness: 0.5, height: 0.7, rain: 20 };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            width = canvas.width;
            height = canvas.height;
            cols = Math.floor(width / gridSize);
            rows = Math.floor(height / gridSize);
        }

        function noise(x, y, scale) {
            return (Math.sin(x * scale) * Math.cos(y * scale) +
                    Math.sin(x * scale * 2.3) * Math.cos(y * scale * 1.7) * 0.5 +
                    Math.sin(x * scale * 4.1) * Math.cos(y * scale * 3.9) * 0.25) / 1.75;
        }

        function init() {
            resize();
            terrain = [];
            basins = [];
            waterDrops = [];

            // Generate terrain with central mountain range (continental divide)
            for (let y = 0; y < rows; y++) {
                terrain[y] = [];
                basins[y] = [];
                for (let x = 0; x < cols; x++) {
                    // Create mountain range down the middle
                    const centerDist = Math.abs(x - cols / 2) / (cols / 2);
                    const mountainHeight = Math.exp(-centerDist * centerDist * 3) * params.height;

                    // Add noise
                    const noiseVal = noise(x, y, 0.05 * params.roughness) * 0.3;
                    const smallNoise = noise(x, y, 0.2) * 0.1 * params.roughness;

                    terrain[y][x] = Math.max(0, mountainHeight + noiseVal + smallNoise);
                    basins[y][x] = 0; // 0 = unassigned, 1 = west, 2 = east
                }
            }

            // Calculate drainage basins using flow direction
            calculateBasins();
        }

        function calculateBasins() {
            // Simple flow direction - water flows to lowest neighbor
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let flowX = x, flowY = y;
                    let visited = new Set();

                    // Follow flow until reaching edge
                    while (flowX > 0 && flowX < cols - 1 && flowY > 0 && flowY < rows - 1) {
                        const key = `${flowX},${flowY}`;
                        if (visited.has(key)) break;
                        visited.add(key);

                        let minH = terrain[flowY][flowX];
                        let nextX = flowX, nextY = flowY;

                        // Check neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = flowX + dx, ny = flowY + dy;
                                if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                                    if (terrain[ny][nx] < minH) {
                                        minH = terrain[ny][nx];
                                        nextX = nx;
                                        nextY = ny;
                                    }
                                }
                            }
                        }

                        if (nextX === flowX && nextY === flowY) break;
                        flowX = nextX;
                        flowY = nextY;
                    }

                    // Assign basin based on where water ends up
                    basins[y][x] = flowX < cols / 2 ? 1 : 2;
                }
            }
        }

        function addWaterDrop(x, y) {
            const gx = Math.floor(x / gridSize);
            const gy = Math.floor(y / gridSize);
            if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                waterDrops.push({
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    basin: basins[gy][gx],
                    life: 500
                });
            }
        }

        function update() {
            // Update water drops
            for (let i = waterDrops.length - 1; i >= 0; i--) {
                const drop = waterDrops[i];
                const gx = Math.floor(drop.x / gridSize);
                const gy = Math.floor(drop.y / gridSize);

                if (gx < 1 || gx >= cols - 1 || gy < 1 || gy >= rows - 1) {
                    waterDrops.splice(i, 1);
                    continue;
                }

                // Calculate gradient
                const h = terrain[gy][gx];
                const hL = terrain[gy][gx - 1];
                const hR = terrain[gy][gx + 1];
                const hU = terrain[gy - 1][gx];
                const hD = terrain[gy + 1][gx];

                const gradX = (hL - hR) * 50;
                const gradY = (hU - hD) * 50;

                drop.vx += gradX * 0.1;
                drop.vy += gradY * 0.1;
                drop.vx *= 0.95;
                drop.vy *= 0.95;

                drop.x += drop.vx;
                drop.y += drop.vy;
                drop.life--;

                if (drop.life <= 0) {
                    waterDrops.splice(i, 1);
                }
            }
        }

        function draw() {
            // Draw terrain with basin colors
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const h = terrain[y][x];
                    const basin = basins[y][x];

                    let r, g, b;

                    if (showDivide) {
                        // Check if on divide (adjacent to both basins)
                        let hasWest = false, hasEast = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const ny = y + dy, nx = x + dx;
                                if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                                    if (basins[ny][nx] === 1) hasWest = true;
                                    if (basins[ny][nx] === 2) hasEast = true;
                                }
                            }
                        }

                        if (hasWest && hasEast) {
                            r = 251; g = 191; b = 36; // Yellow divide
                        } else if (basin === 1) {
                            r = 30 + h * 100; g = 58 + h * 80; b = 138 + h * 50;
                        } else {
                            r = 180 + h * 60; g = 38 + h * 80; b = 38 + h * 60;
                        }
                    } else {
                        // Elevation coloring
                        if (h > 0.6) {
                            r = 255; g = 255; b = 255; // Snow
                        } else if (h > 0.4) {
                            r = 139; g = 119; b = 101; // Rock
                        } else if (h > 0.2) {
                            r = 34 + h * 100; g = 139; b = 34;
                        } else {
                            r = 34; g = 100 + h * 200; b = 34;
                        }
                    }

                    // Fill grid cell
                    for (let py = 0; py < gridSize; py++) {
                        for (let px = 0; px < gridSize; px++) {
                            const idx = ((y * gridSize + py) * width + (x * gridSize + px)) * 4;
                            if (idx >= 0 && idx < data.length - 3) {
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw water drops
            ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
            for (const drop of waterDrops) {
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update stats
            let westCount = 0, eastCount = 0, divideCount = 0;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (basins[y][x] === 1) westCount++;
                    else eastCount++;
                }
            }
            const total = westCount + eastCount;

            document.getElementById('westArea').textContent = ((westCount / total) * 100).toFixed(1);
            document.getElementById('eastArea').textContent = ((eastCount / total) * 100).toFixed(1);
            document.getElementById('particles').textContent = waterDrops.length;
            document.getElementById('divideLen').textContent = Math.floor(rows * gridSize * 0.8 / 100);
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            for (let i = 0; i < params.rain; i++) {
                addWaterDrop(
                    e.clientX - rect.left + (Math.random() - 0.5) * 50,
                    e.clientY - rect.top + (Math.random() - 0.5) * 50
                );
            }
        });

        document.getElementById('roughness').addEventListener('input', e => {
            params.roughness = parseFloat(e.target.value);
            document.getElementById('roughnessValue').textContent = params.roughness.toFixed(1);
        });
        document.getElementById('height').addEventListener('input', e => {
            params.height = parseFloat(e.target.value);
            document.getElementById('heightValue').textContent = params.height.toFixed(1);
        });
        document.getElementById('rain').addEventListener('input', e => {
            params.rain = parseInt(e.target.value);
            document.getElementById('rainValue').textContent = params.rain;
        });
        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('showDivide').addEventListener('click', () => {
            showDivide = !showDivide;
            document.getElementById('showDivide').textContent = showDivide ? 'Show Terrain' : 'Highlight Divide';
        });
        document.getElementById('rainStorm').addEventListener('click', () => {
            for (let i = 0; i < 200; i++) {
                addWaterDrop(Math.random() * width, Math.random() * height * 0.3);
            }
        });
        document.getElementById('clearWater').addEventListener('click', () => {
            waterDrops = [];
        });

        window.addEventListener('resize', () => { resize(); init(); });
        init();
        animate();
    </script>
</body>
</html>
