<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axelrod Tournament - NetLogo Simulations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description {
            text-align: center;
            max-width: 700px;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.5;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .main-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        canvas {
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        .controls {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 280px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.85rem;
            color: #888;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .value {
            font-size: 0.8rem;
            color: #2ecc71;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .primary { background: #27ae60; color: white; }
        .primary:hover { background: #219a52; }
        .secondary { background: rgba(255,255,255,0.1); color: #e0e0e0; }
        .secondary:hover { background: rgba(255,255,255,0.2); }
        .rankings {
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.85rem;
        }
        .ranking-item:last-child { border-bottom: none; }
        .strategy-name { color: #e0e0e0; }
        .strategy-score { color: #2ecc71; font-weight: 600; }
        .payoff-matrix {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 5px;
            font-size: 0.75rem;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 5px;
        }
        .payoff-cell {
            text-align: center;
            padding: 5px;
        }
        .payoff-header { font-weight: bold; color: #888; }
        .payoff-value { color: #f39c12; }
        .match-display {
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            font-size: 0.9rem;
        }
        a.back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #2ecc71;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        a.back-link:hover { opacity: 1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>Axelrod's IPD Tournament</h1>
    <p class="description">
        Robert Axelrod's famous Prisoner's Dilemma tournaments showed that "Tit for Tat" - a simple
        cooperative strategy - outperforms complex selfish strategies through reciprocity.
    </p>

    <div class="container">
        <div class="main-panel">
            <canvas id="canvas" width="600" height="400"></canvas>
            <div class="match-display">
                <span id="matchInfo">Ready to start tournament</span>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Rounds per Match: <span id="roundsVal" class="value">200</span></label>
                <input type="range" id="roundCount" min="50" max="500" step="50" value="200">
            </div>

            <div class="control-group">
                <label>Tournament Speed: <span id="speedVal" class="value">5</span></label>
                <input type="range" id="speed" min="1" max="10" value="5">
            </div>

            <div class="control-group">
                <label>Noise (Error Rate): <span id="noiseVal" class="value">0</span>%</label>
                <input type="range" id="noise" min="0" max="20" value="0">
            </div>

            <button class="primary" id="startBtn">Run Tournament</button>
            <button class="secondary" id="resetBtn">Reset Scores</button>

            <div class="payoff-matrix">
                <div class="payoff-cell"></div>
                <div class="payoff-cell payoff-header">Cooperate</div>
                <div class="payoff-cell payoff-header">Defect</div>
                <div class="payoff-cell payoff-header">Cooperate</div>
                <div class="payoff-cell payoff-value">3, 3</div>
                <div class="payoff-cell payoff-value">0, 5</div>
                <div class="payoff-cell payoff-header">Defect</div>
                <div class="payoff-cell payoff-value">5, 0</div>
                <div class="payoff-cell payoff-value">1, 1</div>
            </div>

            <h3 style="font-size: 0.9rem; color: #888;">Tournament Rankings</h3>
            <div class="rankings" id="rankings"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Payoff matrix
        const REWARD = 3;      // Both cooperate
        const TEMPTATION = 5;  // Defect while other cooperates
        const SUCKER = 0;      // Cooperate while other defects
        const PUNISHMENT = 1;  // Both defect

        // Strategies
        const strategies = {
            'Tit for Tat': {
                description: 'Cooperate first, then copy opponent\'s last move',
                color: '#2ecc71',
                play: (myHistory, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    return oppHistory[oppHistory.length - 1];
                }
            },
            'Always Cooperate': {
                description: 'Always cooperate',
                color: '#3498db',
                play: () => 'C'
            },
            'Always Defect': {
                description: 'Always defect',
                color: '#e74c3c',
                play: () => 'D'
            },
            'Random': {
                description: '50% cooperate, 50% defect',
                color: '#9b59b6',
                play: () => Math.random() < 0.5 ? 'C' : 'D'
            },
            'Grudger': {
                description: 'Cooperate until opponent defects, then always defect',
                color: '#e67e22',
                play: (myHistory, oppHistory) => {
                    if (oppHistory.includes('D')) return 'D';
                    return 'C';
                }
            },
            'Tit for Two Tats': {
                description: 'Defect only if opponent defected twice in a row',
                color: '#1abc9c',
                play: (myHistory, oppHistory) => {
                    if (oppHistory.length < 2) return 'C';
                    if (oppHistory.slice(-2).every(m => m === 'D')) return 'D';
                    return 'C';
                }
            },
            'Suspicious TFT': {
                description: 'Like TFT but defects first',
                color: '#f39c12',
                play: (myHistory, oppHistory) => {
                    if (oppHistory.length === 0) return 'D';
                    return oppHistory[oppHistory.length - 1];
                }
            },
            'Pavlov': {
                description: 'Cooperate if last round had same moves',
                color: '#34495e',
                play: (myHistory, oppHistory) => {
                    if (myHistory.length === 0) return 'C';
                    const lastMine = myHistory[myHistory.length - 1];
                    const lastOpp = oppHistory[oppHistory.length - 1];
                    return lastMine === lastOpp ? 'C' : 'D';
                }
            },
            'Prober': {
                description: 'D-C-C then TFT, or exploit if opponent cooperates',
                color: '#7f8c8d',
                play: (myHistory, oppHistory) => {
                    if (myHistory.length === 0) return 'D';
                    if (myHistory.length === 1) return 'C';
                    if (myHistory.length === 2) return 'C';
                    // If opponent cooperated to our defection, exploit
                    if (oppHistory[0] === 'C' && oppHistory[1] === 'C' && oppHistory[2] === 'C') {
                        return 'D';
                    }
                    return oppHistory[oppHistory.length - 1];
                }
            },
            'Soft Majority': {
                description: 'Cooperate if opponent cooperated >= 50%',
                color: '#16a085',
                play: (myHistory, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    const coops = oppHistory.filter(m => m === 'C').length;
                    return coops >= oppHistory.length / 2 ? 'C' : 'D';
                }
            }
        };

        let scores = {};
        let matchHistory = [];
        let currentMatch = null;
        let tournamentRunning = false;
        let matchQueue = [];
        let currentRound = 0;

        function initScores() {
            scores = {};
            Object.keys(strategies).forEach(name => {
                scores[name] = 0;
            });
            matchHistory = [];
            currentMatch = null;
            matchQueue = [];
            currentRound = 0;
            updateRankings();
        }

        function playRound(strategy1, strategy2, history1, history2, noise) {
            let move1 = strategies[strategy1].play([...history1], [...history2]);
            let move2 = strategies[strategy2].play([...history2], [...history1]);

            // Apply noise
            if (noise > 0) {
                if (Math.random() < noise) move1 = move1 === 'C' ? 'D' : 'C';
                if (Math.random() < noise) move2 = move2 === 'C' ? 'D' : 'C';
            }

            return [move1, move2];
        }

        function getPayoff(move1, move2) {
            if (move1 === 'C' && move2 === 'C') return [REWARD, REWARD];
            if (move1 === 'C' && move2 === 'D') return [SUCKER, TEMPTATION];
            if (move1 === 'D' && move2 === 'C') return [TEMPTATION, SUCKER];
            return [PUNISHMENT, PUNISHMENT];
        }

        function setupTournament() {
            initScores();
            matchQueue = [];

            const names = Object.keys(strategies);
            for (let i = 0; i < names.length; i++) {
                for (let j = i; j < names.length; j++) {
                    matchQueue.push([names[i], names[j]]);
                }
            }

            // Shuffle for variety
            for (let i = matchQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [matchQueue[i], matchQueue[j]] = [matchQueue[j], matchQueue[i]];
            }
        }

        function runMatch(strategy1, strategy2, rounds, noise) {
            const history1 = [];
            const history2 = [];
            let score1 = 0;
            let score2 = 0;

            for (let r = 0; r < rounds; r++) {
                const [move1, move2] = playRound(strategy1, strategy2, history1, history2, noise);
                const [payoff1, payoff2] = getPayoff(move1, move2);

                history1.push(move1);
                history2.push(move2);
                score1 += payoff1;
                score2 += payoff2;
            }

            return {
                strategy1, strategy2,
                score1, score2,
                history1, history2
            };
        }

        function updateRankings() {
            const rankingsDiv = document.getElementById('rankings');
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);

            rankingsDiv.innerHTML = sorted.map(([name, score], i) => `
                <div class="ranking-item">
                    <span class="strategy-name" style="color: ${strategies[name].color}">
                        ${i + 1}. ${name}
                    </span>
                    <span class="strategy-score">${score}</span>
                </div>
            `).join('');
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            if (matchHistory.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Run tournament to see results', W / 2, H / 2);
                return;
            }

            // Draw bar chart of scores
            const names = Object.keys(strategies);
            const maxScore = Math.max(...Object.values(scores), 1);
            const barWidth = (W - 60) / names.length - 10;
            const chartHeight = H - 80;

            names.forEach((name, i) => {
                const x = 40 + i * (barWidth + 10);
                const barHeight = (scores[name] / maxScore) * chartHeight;
                const y = H - 40 - barHeight;

                // Draw bar
                ctx.fillStyle = strategies[name].color;
                ctx.fillRect(x, y, barWidth, barHeight);

                // Draw label
                ctx.save();
                ctx.translate(x + barWidth / 2, H - 5);
                ctx.rotate(-Math.PI / 4);
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(name, 0, 0);
                ctx.restore();

                // Draw score
                ctx.fillStyle = '#fff';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(scores[name], x + barWidth / 2, y - 5);
            });

            // Title
            ctx.fillStyle = '#e0e0e0';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Tournament Scores', W / 2, 25);
        }

        async function runTournament() {
            const rounds = parseInt(document.getElementById('roundCount').value);
            const speed = parseInt(document.getElementById('speed').value);
            const noise = parseInt(document.getElementById('noise').value) / 100;

            setupTournament();
            tournamentRunning = true;
            document.getElementById('startBtn').textContent = 'Running...';
            document.getElementById('startBtn').disabled = true;

            for (let i = 0; i < matchQueue.length && tournamentRunning; i++) {
                const [s1, s2] = matchQueue[i];
                document.getElementById('matchInfo').textContent =
                    `Match ${i + 1}/${matchQueue.length}: ${s1} vs ${s2}`;

                const result = runMatch(s1, s2, rounds, noise);

                // Self-play counts once, otherwise add to both
                if (s1 === s2) {
                    scores[s1] += result.score1;
                } else {
                    scores[s1] += result.score1;
                    scores[s2] += result.score2;
                }

                matchHistory.push(result);
                updateRankings();
                draw();

                // Delay based on speed
                await new Promise(r => setTimeout(r, 500 / speed));
            }

            tournamentRunning = false;
            document.getElementById('startBtn').textContent = 'Run Tournament';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('matchInfo').textContent =
                `Tournament complete! ${matchHistory.length} matches played.`;
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            if (!tournamentRunning) {
                runTournament();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            tournamentRunning = false;
            initScores();
            draw();
            document.getElementById('matchInfo').textContent = 'Ready to start tournament';
        });

        // Update value displays
        document.getElementById('roundCount').addEventListener('input', function() {
            document.getElementById('roundsVal').textContent = this.value;
        });
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedVal').textContent = this.value;
        });
        document.getElementById('noise').addEventListener('input', function() {
            document.getElementById('noiseVal').textContent = this.value;
        });

        initScores();
        draw();
    </script>
</body>
</html>
