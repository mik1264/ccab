<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Many Regions - NetLogo Simulations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description { text-align: center; max-width: 700px; margin-bottom: 20px; color: #aaa; line-height: 1.5; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .canvases { display: flex; flex-direction: column; gap: 10px; }
        canvas { border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
        .controls {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 220px;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 0.85rem; color: #888; }
        input[type="range"] { width: 100%; cursor: pointer; }
        .value { font-size: 0.8rem; color: #2ecc71; }
        button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; }
        .primary { background: #2ecc71; color: #1a1a2e; }
        .secondary { background: rgba(255,255,255,0.1); color: #e0e0e0; }
        .stats { margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.85rem; }
        .stats div { margin: 3px 0; }
        .stat-value { color: #2ecc71; }
        a.back-link { position: fixed; top: 20px; left: 20px; color: #2ecc71; text-decoration: none; font-size: 0.9rem; opacity: 0.8; }
        .region-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; font-size: 0.75rem; }
        .region-stat { display: flex; justify-content: space-between; padding: 3px 5px; background: rgba(0,0,0,0.2); border-radius: 3px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>Many Regions</h1>
    <p class="description">Multi-region population dynamics with migration between adjacent regions. Watch populations balance through diffusion-like migration flows.</p>
    <div class="container">
        <div class="canvases">
            <canvas id="mapCanvas" width="500" height="300"></canvas>
            <canvas id="graphCanvas" width="500" height="200"></canvas>
        </div>
        <div class="controls">
            <div class="control-group">
                <label>Regions: <span id="regionsVal" class="value">6</span></label>
                <input type="range" id="regionCount" min="3" max="12" value="6">
            </div>
            <div class="control-group">
                <label>Growth Rate: <span id="growthVal" class="value">0.05</span></label>
                <input type="range" id="growthRate" min="1" max="20" value="5">
            </div>
            <div class="control-group">
                <label>Migration Rate: <span id="migrationVal" class="value">0.02</span></label>
                <input type="range" id="migrationRate" min="0" max="20" value="2">
            </div>
            <div class="control-group">
                <label>Capacity Variance: <span id="varianceVal" class="value">50</span>%</label>
                <input type="range" id="variance" min="0" max="100" value="50">
            </div>
            <button class="primary" id="startBtn">Start</button>
            <button class="secondary" id="resetBtn">Reset</button>
            <div class="stats">
                <div>Time: <span id="time" class="stat-value">0</span></div>
                <div>Total Pop: <span id="totalPop" class="stat-value">0</span></div>
                <div>Migrations: <span id="migrations" class="stat-value">0</span></div>
            </div>
            <div class="region-stats" id="regionStats"></div>
        </div>
    </div>
    <script>
        const mapCanvas = document.getElementById('mapCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        const graphCtx = graphCanvas.getContext('2d');
        const MW = mapCanvas.width, MH = mapCanvas.height;
        const GW = graphCanvas.width, GH = graphCanvas.height;

        let regions = [];
        let history = [];
        let running = false;
        let time = 0;
        let totalMigrations = 0;

        const COLORS = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12',
            '#9b59b6', '#1abc9c', '#e67e22', '#34495e',
            '#16a085', '#c0392b', '#2980b9', '#27ae60'
        ];

        class Region {
            constructor(id, x, y, capacity) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.capacity = capacity;
                this.population = Math.random() * capacity * 0.5;
                this.neighbors = [];
                this.color = COLORS[id % COLORS.length];
            }
        }

        function init() {
            const count = parseInt(document.getElementById('regionCount').value);
            const variance = parseInt(document.getElementById('variance').value) / 100;

            regions = [];
            history = [];
            time = 0;
            totalMigrations = 0;

            // Create regions in a grid layout
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);
            const cellW = (MW - 40) / cols;
            const cellH = (MH - 40) / rows;

            for (let i = 0; i < count; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = 30 + col * cellW + cellW / 2;
                const y = 30 + row * cellH + cellH / 2;
                const baseCapacity = 100;
                const capacity = baseCapacity * (1 + (Math.random() - 0.5) * variance * 2);
                regions.push(new Region(i, x, y, capacity));
            }

            // Set up neighbors (adjacent in grid)
            for (let i = 0; i < count; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);

                // Right neighbor
                if (col < cols - 1 && i + 1 < count) {
                    regions[i].neighbors.push(i + 1);
                    regions[i + 1].neighbors.push(i);
                }
                // Bottom neighbor
                if (i + cols < count) {
                    regions[i].neighbors.push(i + cols);
                    regions[i + cols].neighbors.push(i);
                }
            }

            updateStats();
        }

        function update() {
            const growthRate = parseInt(document.getElementById('growthRate').value) / 100;
            const migrationRate = parseInt(document.getElementById('migrationRate').value) / 100;

            // Logistic growth for each region
            regions.forEach(r => {
                const growth = growthRate * r.population * (1 - r.population / r.capacity);
                r.population = Math.max(0, r.population + growth);
            });

            // Migration between neighbors
            const migrations = [];
            regions.forEach(r => {
                r.neighbors.forEach(nid => {
                    const neighbor = regions[nid];
                    // Migrate towards regions with lower density
                    const myDensity = r.population / r.capacity;
                    const theirDensity = neighbor.population / neighbor.capacity;

                    if (myDensity > theirDensity) {
                        const flow = migrationRate * r.population * (myDensity - theirDensity);
                        migrations.push({ from: r.id, to: nid, amount: flow });
                    }
                });
            });

            migrations.forEach(m => {
                regions[m.from].population -= m.amount;
                regions[m.to].population += m.amount;
                totalMigrations += m.amount;
            });

            // Record history
            history.push(regions.map(r => r.population));
            if (history.length > GW) history.shift();

            time++;
        }

        function drawMap() {
            mapCtx.fillStyle = '#1a1a2e';
            mapCtx.fillRect(0, 0, MW, MH);

            // Draw connections
            mapCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            mapCtx.lineWidth = 2;
            regions.forEach(r => {
                r.neighbors.forEach(nid => {
                    if (nid > r.id) {
                        const neighbor = regions[nid];
                        mapCtx.beginPath();
                        mapCtx.moveTo(r.x, r.y);
                        mapCtx.lineTo(neighbor.x, neighbor.y);
                        mapCtx.stroke();
                    }
                });
            });

            // Draw regions
            regions.forEach(r => {
                const density = r.population / r.capacity;
                const radius = 15 + density * 25;

                // Glow
                const gradient = mapCtx.createRadialGradient(r.x, r.y, 0, r.x, r.y, radius * 1.5);
                gradient.addColorStop(0, r.color);
                gradient.addColorStop(1, 'transparent');
                mapCtx.fillStyle = gradient;
                mapCtx.beginPath();
                mapCtx.arc(r.x, r.y, radius * 1.5, 0, Math.PI * 2);
                mapCtx.fill();

                // Core
                mapCtx.fillStyle = r.color;
                mapCtx.beginPath();
                mapCtx.arc(r.x, r.y, radius, 0, Math.PI * 2);
                mapCtx.fill();

                // Label
                mapCtx.fillStyle = '#fff';
                mapCtx.font = 'bold 10px sans-serif';
                mapCtx.textAlign = 'center';
                mapCtx.fillText(`R${r.id + 1}`, r.x, r.y - radius - 5);
                mapCtx.font = '9px sans-serif';
                mapCtx.fillText(Math.round(r.population), r.x, r.y + 3);
            });
        }

        function drawGraph() {
            graphCtx.fillStyle = '#1a1a2e';
            graphCtx.fillRect(0, 0, GW, GH);

            if (history.length < 2) return;

            const maxPop = Math.max(...regions.map(r => r.capacity)) * 1.2;

            // Draw lines for each region
            regions.forEach((r, ri) => {
                graphCtx.strokeStyle = r.color;
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();

                for (let i = 0; i < history.length; i++) {
                    const x = (i / (GW - 1)) * GW;
                    const y = GH - (history[i][ri] / maxPop) * (GH - 20) - 10;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            });

            // Axis labels
            graphCtx.fillStyle = '#666';
            graphCtx.font = '10px sans-serif';
            graphCtx.fillText('Population over time', 10, 15);
        }

        function updateStats() {
            const totalPop = regions.reduce((sum, r) => sum + r.population, 0);
            document.getElementById('time').textContent = time;
            document.getElementById('totalPop').textContent = Math.round(totalPop);
            document.getElementById('migrations').textContent = Math.round(totalMigrations);

            document.getElementById('regionsVal').textContent = document.getElementById('regionCount').value;
            document.getElementById('growthVal').textContent = (parseInt(document.getElementById('growthRate').value) / 100).toFixed(2);
            document.getElementById('migrationVal').textContent = (parseInt(document.getElementById('migrationRate').value) / 100).toFixed(2);
            document.getElementById('varianceVal').textContent = document.getElementById('variance').value;

            // Region stats
            const statsDiv = document.getElementById('regionStats');
            statsDiv.innerHTML = regions.map(r =>
                `<div class="region-stat"><span style="color:${r.color}">R${r.id + 1}</span><span>${Math.round(r.population)}/${Math.round(r.capacity)}</span></div>`
            ).join('');
        }

        function animate() {
            if (running) update();
            drawMap();
            drawGraph();
            updateStats();
            requestAnimationFrame(animate);
        }

        document.getElementById('startBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            init();
        });

        document.getElementById('regionCount').addEventListener('input', init);

        init();
        animate();
    </script>
</body>
</html>
