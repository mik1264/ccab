<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Cone - Agent Field of View - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        canvas { display: block; flex: 1; cursor: crosshair; }
        #controls { width: 280px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #facc15; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #facc15; color: #0f172a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #eab308; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #facc15; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .instruction { font-size: 0.8rem; color: #facc15; margin-bottom: 15px; padding: 10px; background: rgba(250, 204, 21, 0.1); border-radius: 5px; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .checkbox-group input { width: auto; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Vision Cone</h1>
            <p class="description">Demonstrates agent field-of-view mechanics. The primary agent has a vision cone that detects objects. Useful for understanding perception in agent-based models, games, and robotics.</p>
            <div class="instruction">Move mouse to control agent direction. Click to add obstacles.</div>

            <div class="control-group">
                <label>Vision Angle: <span id="angleValue">90</span>°</label>
                <input type="range" id="visionAngle" min="30" max="180" value="90">
            </div>
            <div class="control-group">
                <label>Vision Range: <span id="rangeValue">200</span></label>
                <input type="range" id="visionRange" min="50" max="400" value="200">
            </div>
            <div class="control-group">
                <label>Target Count: <span id="targetValue">10</span></label>
                <input type="range" id="targets" min="3" max="30" value="10">
            </div>
            <div class="control-group">
                <label>Target Speed: <span id="speedValue">1.0</span></label>
                <input type="range" id="speed" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showRays" checked>
                <label for="showRays">Show Detection Rays</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showObstacles" checked>
                <label for="showObstacles">Ray Occlusion</label>
            </div>
            <button id="reset">Reset</button>
            <button id="addObstacle">Add Random Obstacle</button>
            <button id="clearObstacles">Clear Obstacles</button>

            <div class="stats">
                <div>Agent Heading: <span id="heading">0</span>°</div>
                <div>Visible Targets: <span id="visible">0</span></div>
                <div>Occluded: <span id="occluded">0</span></div>
                <div>Out of Range: <span id="outOfRange">0</span></div>
                <div>Obstacles: <span id="obstacleCount">0</span></div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        let agent = { x: 0, y: 0, angle: 0 };
        let targets = [];
        let obstacles = [];
        let mouseX = 0, mouseY = 0;

        let params = {
            visionAngle: 90,
            visionRange: 200,
            targetCount: 10,
            speed: 1,
            showRays: true,
            showObstacles: true
        };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            width = canvas.width;
            height = canvas.height;
            agent.x = width / 2;
            agent.y = height / 2;
        }

        function createTarget() {
            return {
                x: 100 + Math.random() * (width - 200),
                y: 100 + Math.random() * (height - 200),
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                radius: 10 + Math.random() * 10
            };
        }

        function createObstacle(x, y) {
            return {
                x: x || 100 + Math.random() * (width - 200),
                y: y || 100 + Math.random() * (height - 200),
                width: 30 + Math.random() * 60,
                height: 30 + Math.random() * 60
            };
        }

        function init() {
            targets = [];
            obstacles = [];

            for (let i = 0; i < params.targetCount; i++) {
                targets.push(createTarget());
            }
        }

        function isInVisionCone(target) {
            const dx = target.x - agent.x;
            const dy = target.y - agent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Out of range
            if (dist > params.visionRange) return { visible: false, reason: 'range' };

            // Check angle
            const angleToTarget = Math.atan2(dy, dx);
            let angleDiff = angleToTarget - agent.angle;

            // Normalize to -PI to PI
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            const halfVision = (params.visionAngle / 2) * (Math.PI / 180);
            if (Math.abs(angleDiff) > halfVision) return { visible: false, reason: 'angle' };

            // Check occlusion by obstacles
            if (params.showObstacles) {
                for (let obs of obstacles) {
                    if (lineIntersectsRect(agent.x, agent.y, target.x, target.y, obs)) {
                        return { visible: false, reason: 'occluded' };
                    }
                }
            }

            return { visible: true, distance: dist };
        }

        function lineIntersectsRect(x1, y1, x2, y2, rect) {
            // Check if line segment intersects rectangle
            const left = rect.x;
            const right = rect.x + rect.width;
            const top = rect.y;
            const bottom = rect.y + rect.height;

            // Line segment parametric form
            const dx = x2 - x1;
            const dy = y2 - y1;

            let t0 = 0;
            let t1 = 1;

            // Check against each edge
            const p = [-dx, dx, -dy, dy];
            const q = [x1 - left, right - x1, y1 - top, bottom - y1];

            for (let i = 0; i < 4; i++) {
                if (p[i] === 0) {
                    if (q[i] < 0) return false;
                } else {
                    const t = q[i] / p[i];
                    if (p[i] < 0) {
                        if (t > t1) return false;
                        if (t > t0) t0 = t;
                    } else {
                        if (t < t0) return false;
                        if (t < t1) t1 = t;
                    }
                }
            }

            return t0 < t1;
        }

        function update() {
            // Update agent angle based on mouse position
            agent.angle = Math.atan2(mouseY - agent.y, mouseX - agent.x);

            // Move targets
            for (let t of targets) {
                t.x += t.vx * params.speed;
                t.y += t.vy * params.speed;

                // Bounce off walls
                if (t.x - t.radius < 0 || t.x + t.radius > width) t.vx *= -1;
                if (t.y - t.radius < 0 || t.y + t.radius > height) t.vy *= -1;

                t.x = Math.max(t.radius, Math.min(width - t.radius, t.x));
                t.y = Math.max(t.radius, Math.min(height - t.radius, t.y));
            }
        }

        function draw() {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            // Draw obstacles
            for (let obs of obstacles) {
                ctx.fillStyle = '#475569';
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
            }

            // Draw vision cone
            const halfAngle = (params.visionAngle / 2) * (Math.PI / 180);
            const startAngle = agent.angle - halfAngle;
            const endAngle = agent.angle + halfAngle;

            // Cone gradient
            const gradient = ctx.createRadialGradient(
                agent.x, agent.y, 0,
                agent.x, agent.y, params.visionRange
            );
            gradient.addColorStop(0, 'rgba(250, 204, 21, 0.3)');
            gradient.addColorStop(0.7, 'rgba(250, 204, 21, 0.1)');
            gradient.addColorStop(1, 'rgba(250, 204, 21, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(agent.x, agent.y);
            ctx.arc(agent.x, agent.y, params.visionRange, startAngle, endAngle);
            ctx.closePath();
            ctx.fill();

            // Cone border
            ctx.strokeStyle = 'rgba(250, 204, 21, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(agent.x, agent.y);
            ctx.lineTo(
                agent.x + Math.cos(startAngle) * params.visionRange,
                agent.y + Math.sin(startAngle) * params.visionRange
            );
            ctx.moveTo(agent.x, agent.y);
            ctx.lineTo(
                agent.x + Math.cos(endAngle) * params.visionRange,
                agent.y + Math.sin(endAngle) * params.visionRange
            );
            ctx.stroke();

            // Arc at range limit
            ctx.beginPath();
            ctx.arc(agent.x, agent.y, params.visionRange, startAngle, endAngle);
            ctx.stroke();

            // Count visibility status
            let visibleCount = 0;
            let occludedCount = 0;
            let outOfRangeCount = 0;

            // Draw targets
            for (let t of targets) {
                const status = isInVisionCone(t);

                if (status.visible) {
                    visibleCount++;

                    // Visible target
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Detection ray
                    if (params.showRays) {
                        ctx.strokeStyle = 'rgba(34, 197, 94, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(agent.x, agent.y);
                        ctx.lineTo(t.x, t.y);
                        ctx.stroke();
                    }

                    // Distance indicator
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.floor(status.distance), t.x, t.y + t.radius + 15);

                } else if (status.reason === 'occluded') {
                    occludedCount++;

                    // Occluded target
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Blocked ray
                    if (params.showRays) {
                        ctx.strokeStyle = 'rgba(245, 158, 11, 0.3)';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(agent.x, agent.y);
                        ctx.lineTo(t.x, t.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                } else {
                    if (status.reason === 'range') outOfRangeCount++;

                    // Not visible
                    ctx.fillStyle = '#ef4444';
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Target highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(t.x - t.radius * 0.3, t.y - t.radius * 0.3, t.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw agent
            ctx.fillStyle = '#facc15';
            ctx.beginPath();
            ctx.arc(agent.x, agent.y, 15, 0, Math.PI * 2);
            ctx.fill();

            // Agent direction indicator
            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.moveTo(
                agent.x + Math.cos(agent.angle) * 20,
                agent.y + Math.sin(agent.angle) * 20
            );
            ctx.lineTo(
                agent.x + Math.cos(agent.angle + 2.5) * 10,
                agent.y + Math.sin(agent.angle + 2.5) * 10
            );
            ctx.lineTo(
                agent.x + Math.cos(agent.angle - 2.5) * 10,
                agent.y + Math.sin(agent.angle - 2.5) * 10
            );
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.arc(
                agent.x + Math.cos(agent.angle) * 5,
                agent.y + Math.sin(agent.angle) * 5,
                4, 0, Math.PI * 2
            );
            ctx.fill();

            // Legend
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#22c55e';
            ctx.fillText('● Visible', 20, height - 60);
            ctx.fillStyle = '#f59e0b';
            ctx.fillText('● Occluded', 20, height - 40);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('● Not in cone/range', 20, height - 20);

            // Update stats
            document.getElementById('heading').textContent =
                ((agent.angle * 180 / Math.PI + 360) % 360).toFixed(0);
            document.getElementById('visible').textContent = visibleCount;
            document.getElementById('occluded').textContent = occludedCount;
            document.getElementById('outOfRange').textContent = outOfRangeCount;
            document.getElementById('obstacleCount').textContent = obstacles.length;
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Don't place obstacle on agent
            const dx = x - agent.x;
            const dy = y - agent.y;
            if (Math.sqrt(dx * dx + dy * dy) > 50) {
                obstacles.push(createObstacle(x - 25, y - 25));
            }
        });

        document.getElementById('visionAngle').addEventListener('input', e => {
            params.visionAngle = parseInt(e.target.value);
            document.getElementById('angleValue').textContent = params.visionAngle;
        });
        document.getElementById('visionRange').addEventListener('input', e => {
            params.visionRange = parseInt(e.target.value);
            document.getElementById('rangeValue').textContent = params.visionRange;
        });
        document.getElementById('targets').addEventListener('input', e => {
            params.targetCount = parseInt(e.target.value);
            document.getElementById('targetValue').textContent = params.targetCount;
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = params.speed.toFixed(1);
        });
        document.getElementById('showRays').addEventListener('change', e => {
            params.showRays = e.target.checked;
        });
        document.getElementById('showObstacles').addEventListener('change', e => {
            params.showObstacles = e.target.checked;
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('addObstacle').addEventListener('click', () => {
            obstacles.push(createObstacle());
        });
        document.getElementById('clearObstacles').addEventListener('click', () => {
            obstacles = [];
        });

        window.addEventListener('resize', resize);
        resize();
        init();
        animate();
    </script>
</body>
</html>
