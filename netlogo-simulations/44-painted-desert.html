<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painted Desert Challenge - Territory Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
            display: flex;
        }
        .sidebar {
            width: 300px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            overflow-y: auto;
        }
        .main-content { flex: 1; display: flex; flex-direction: column; padding: 20px; }
        h1 { font-size: 1.4rem; margin-bottom: 10px; color: #f59e0b; }
        .description { font-size: 0.85rem; color: #aaa; margin-bottom: 20px; line-height: 1.5; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { font-size: 0.75rem; color: #f59e0b; }
        .buttons { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; font-size: 0.85rem; }
        .btn-primary { background: #f59e0b; color: #1a1a2e; }
        .btn-secondary { background: #374151; color: #e8e8e8; }
        button:hover { opacity: 0.8; }
        .stats { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; }
        .stat-label { color: #888; }
        .stat-value { font-weight: bold; font-family: monospace; }
        .canvas-container { flex: 1; display: flex; gap: 20px; min-height: 0; }
        canvas { border-radius: 8px; background: #0a0a0a; }
        #simCanvas { flex: 2; }
        .charts { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .chart-container { flex: 1; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; }
        .chart-title { font-size: 0.75rem; color: #888; margin-bottom: 5px; }
        .back-link { display: inline-block; color: #f59e0b; text-decoration: none; margin-bottom: 15px; font-size: 0.85rem; }
        .back-link:hover { text-decoration: underline; }
        .scoreboard { display: flex; gap: 10px; margin-bottom: 15px; }
        .score-item { flex: 1; text-align: center; padding: 10px; border-radius: 8px; }
        .score-value { font-size: 1.5rem; font-weight: bold; }
        .score-label { font-size: 0.7rem; opacity: 0.8; }
        .strategy-select { width: 100%; padding: 8px; border-radius: 5px; background: #374151; color: #e8e8e8; border: none; margin-bottom: 10px; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
        <h1>Painted Desert Challenge</h1>
        <p class="description">
            Territory-painting game where competing agents claim regions.
            Each team tries to paint more of the desert their color.
            Different strategies compete: random walk, greedy expansion, border patrol.
        </p>

        <div class="scoreboard">
            <div class="score-item" style="background: rgba(239, 68, 68, 0.3);">
                <div class="score-value" id="redScore">0%</div>
                <div class="score-label">Red Team</div>
            </div>
            <div class="score-item" style="background: rgba(59, 130, 246, 0.3);">
                <div class="score-value" id="blueScore">0%</div>
                <div class="score-label">Blue Team</div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" id="startBtn">Start</button>
            <button class="btn-secondary" id="resetBtn">Reset</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button class="btn-secondary" id="stepBtn">Step</button>
        </div>

        <div class="control-group">
            <label>Red Team Strategy:</label>
            <select class="strategy-select" id="redStrategy">
                <option value="random">Random Walk</option>
                <option value="greedy">Greedy Expansion</option>
                <option value="border">Border Patrol</option>
                <option value="spiral">Spiral</option>
            </select>
        </div>

        <div class="control-group">
            <label>Blue Team Strategy:</label>
            <select class="strategy-select" id="blueStrategy">
                <option value="greedy">Greedy Expansion</option>
                <option value="random">Random Walk</option>
                <option value="border">Border Patrol</option>
                <option value="spiral">Spiral</option>
            </select>
        </div>

        <div class="control-group">
            <label>Agents per Team: <span class="value" id="agentsValue">5</span></label>
            <input type="range" id="agents" min="1" max="10" value="5">
        </div>

        <div class="control-group">
            <label>Agent Speed: <span class="value" id="speedValue">2</span></label>
            <input type="range" id="speed" min="1" max="5" value="2">
        </div>

        <div class="control-group">
            <label>Paint Radius: <span class="value" id="radiusValue">3</span></label>
            <input type="range" id="radius" min="1" max="8" value="3">
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time:</span>
                <span class="stat-value" id="timeStep">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Unpainted:</span>
                <span class="stat-value" id="unpainted">100%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Red Territory:</span>
                <span class="stat-value" style="color: #ef4444;" id="redTerritory">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Blue Territory:</span>
                <span class="stat-value" style="color: #3b82f6;" id="blueTerritory">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Leader:</span>
                <span class="stat-value" id="leader">Tie</span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
            <div class="charts">
                <div class="chart-container">
                    <div class="chart-title">Territory Over Time</div>
                    <canvas id="territoryChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Agent Positions</div>
                    <canvas id="positionChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Painted Desert Challenge - Territory Game</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const simCanvas = document.getElementById('simCanvas');
        const simCtx = simCanvas.getContext('2d');
        const territoryCanvas = document.getElementById('territoryChart');
        const territoryCtx = territoryCanvas.getContext('2d');
        const positionCanvas = document.getElementById('positionChart');
        const positionCtx = positionCanvas.getContext('2d');

        const GRID_SIZE = 100;
        let grid = [];
        let agents = [];
        let running = false;
        let timeStep = 0;

        let params = {
            agents: 5,
            speed: 2,
            radius: 3,
            redStrategy: 'random',
            blueStrategy: 'greedy'
        };

        const EMPTY = 0, RED = 1, BLUE = 2;
        let history = { red: [], blue: [] };
        const MAX_HISTORY = 200;

        function init() {
            resizeCanvases();
            setupControls();
            reset();
            animate();
        }

        function resizeCanvases() {
            const container = simCanvas.parentElement;
            const size = Math.min(container.clientWidth * 0.6, container.clientHeight - 40);
            simCanvas.width = size;
            simCanvas.height = size;

            document.querySelectorAll('.chart-container').forEach((c, i) => {
                const canvas = i === 0 ? territoryCanvas : positionCanvas;
                canvas.width = c.clientWidth - 20;
                canvas.height = c.clientHeight - 40;
            });
        }

        function setupControls() {
            document.getElementById('startBtn').onclick = () => {
                running = !running;
                document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            };
            document.getElementById('resetBtn').onclick = reset;
            document.getElementById('stepBtn').onclick = step;

            document.getElementById('redStrategy').onchange = (e) => params.redStrategy = e.target.value;
            document.getElementById('blueStrategy').onchange = (e) => params.blueStrategy = e.target.value;

            ['agents', 'speed', 'radius'].forEach(id => {
                document.getElementById(id).oninput = (e) => {
                    params[id] = parseInt(e.target.value);
                    document.getElementById(id + 'Value').textContent = params[id];
                };
            });

            window.addEventListener('resize', resizeCanvases);
        }

        function reset() {
            running = false;
            timeStep = 0;
            document.getElementById('startBtn').textContent = 'Start';
            history = { red: [], blue: [] };

            // Initialize grid
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = new Array(GRID_SIZE).fill(EMPTY);
            }

            // Create agents
            agents = [];
            for (let i = 0; i < params.agents; i++) {
                // Red team starts on left
                agents.push({
                    x: 10 + Math.random() * 20,
                    y: GRID_SIZE / 2 + (Math.random() - 0.5) * 40,
                    team: RED,
                    angle: Math.random() * Math.PI * 2,
                    spiralAngle: 0
                });
                // Blue team starts on right
                agents.push({
                    x: GRID_SIZE - 30 + Math.random() * 20,
                    y: GRID_SIZE / 2 + (Math.random() - 0.5) * 40,
                    team: BLUE,
                    angle: Math.random() * Math.PI * 2,
                    spiralAngle: 0
                });
            }

            updateStats();
            draw();
        }

        function step() {
            timeStep++;

            agents.forEach(agent => {
                const strategy = agent.team === RED ? params.redStrategy : params.blueStrategy;
                moveAgent(agent, strategy);
                paintArea(agent);
            });

            // Record history
            const counts = countTerritories();
            const total = GRID_SIZE * GRID_SIZE;
            history.red.push(counts.red / total * 100);
            history.blue.push(counts.blue / total * 100);
            if (history.red.length > MAX_HISTORY) {
                history.red.shift();
                history.blue.shift();
            }

            updateStats();
            draw();
        }

        function moveAgent(agent, strategy) {
            let dx = 0, dy = 0;

            switch (strategy) {
                case 'random':
                    agent.angle += (Math.random() - 0.5) * 0.5;
                    dx = Math.cos(agent.angle) * params.speed;
                    dy = Math.sin(agent.angle) * params.speed;
                    break;

                case 'greedy':
                    // Move towards nearest unpainted or enemy area
                    let bestDist = Infinity;
                    let bestX = agent.x, bestY = agent.y;
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 5 + Math.random() * 15;
                        const tx = agent.x + Math.cos(angle) * dist;
                        const ty = agent.y + Math.sin(angle) * dist;
                        const gx = Math.floor(tx), gy = Math.floor(ty);
                        if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                            if (grid[gy][gx] !== agent.team) {
                                const d = Math.sqrt((tx - agent.x) ** 2 + (ty - agent.y) ** 2);
                                if (d < bestDist) {
                                    bestDist = d;
                                    bestX = tx;
                                    bestY = ty;
                                }
                            }
                        }
                    }
                    const gdx = bestX - agent.x;
                    const gdy = bestY - agent.y;
                    const gd = Math.sqrt(gdx * gdx + gdy * gdy);
                    if (gd > 0) {
                        dx = gdx / gd * params.speed;
                        dy = gdy / gd * params.speed;
                    }
                    break;

                case 'border':
                    // Patrol the border of own territory
                    let borderX = agent.x, borderY = agent.y;
                    for (let i = 0; i < 10; i++) {
                        const angle = agent.angle + (Math.random() - 0.5) * Math.PI;
                        const dist = 5;
                        const tx = agent.x + Math.cos(angle) * dist;
                        const ty = agent.y + Math.sin(angle) * dist;
                        const gx = Math.floor(tx), gy = Math.floor(ty);
                        if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                            // Look for border cells (own territory next to empty/enemy)
                            let isBorder = false;
                            for (let dy2 = -1; dy2 <= 1; dy2++) {
                                for (let dx2 = -1; dx2 <= 1; dx2++) {
                                    const nx = gx + dx2, ny = gy + dy2;
                                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                                        if (grid[ny][nx] !== agent.team) isBorder = true;
                                    }
                                }
                            }
                            if (isBorder) {
                                borderX = tx;
                                borderY = ty;
                                break;
                            }
                        }
                    }
                    const bdx = borderX - agent.x;
                    const bdy = borderY - agent.y;
                    const bd = Math.sqrt(bdx * bdx + bdy * bdy);
                    if (bd > 0.1) {
                        dx = bdx / bd * params.speed;
                        dy = bdy / bd * params.speed;
                    } else {
                        agent.angle += 0.2;
                        dx = Math.cos(agent.angle) * params.speed;
                        dy = Math.sin(agent.angle) * params.speed;
                    }
                    break;

                case 'spiral':
                    agent.spiralAngle += 0.1;
                    const spiralRadius = 5 + agent.spiralAngle * 0.5;
                    const centerX = agent.team === RED ? GRID_SIZE * 0.3 : GRID_SIZE * 0.7;
                    const centerY = GRID_SIZE / 2;
                    const targetX = centerX + Math.cos(agent.spiralAngle) * spiralRadius;
                    const targetY = centerY + Math.sin(agent.spiralAngle) * spiralRadius;
                    const sdx = targetX - agent.x;
                    const sdy = targetY - agent.y;
                    const sd = Math.sqrt(sdx * sdx + sdy * sdy);
                    if (sd > 0) {
                        dx = sdx / sd * params.speed;
                        dy = sdy / sd * params.speed;
                    }
                    break;
            }

            agent.x += dx;
            agent.y += dy;

            // Boundaries
            agent.x = Math.max(1, Math.min(GRID_SIZE - 2, agent.x));
            agent.y = Math.max(1, Math.min(GRID_SIZE - 2, agent.y));
        }

        function paintArea(agent) {
            const gx = Math.floor(agent.x);
            const gy = Math.floor(agent.y);
            const r = params.radius;

            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx * dx + dy * dy <= r * r) {
                        const nx = gx + dx;
                        const ny = gy + dy;
                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                            grid[ny][nx] = agent.team;
                        }
                    }
                }
            }
        }

        function countTerritories() {
            let red = 0, blue = 0, empty = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === RED) red++;
                    else if (grid[y][x] === BLUE) blue++;
                    else empty++;
                }
            }
            return { red, blue, empty };
        }

        function updateStats() {
            const counts = countTerritories();
            const total = GRID_SIZE * GRID_SIZE;

            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('unpainted').textContent = (counts.empty / total * 100).toFixed(1) + '%';
            document.getElementById('redTerritory').textContent = counts.red;
            document.getElementById('blueTerritory').textContent = counts.blue;
            document.getElementById('redScore').textContent = (counts.red / total * 100).toFixed(1) + '%';
            document.getElementById('blueScore').textContent = (counts.blue / total * 100).toFixed(1) + '%';

            let leader = 'Tie';
            if (counts.red > counts.blue) leader = 'Red';
            else if (counts.blue > counts.red) leader = 'Blue';
            document.getElementById('leader').textContent = leader;
            document.getElementById('leader').style.color =
                leader === 'Red' ? '#ef4444' : leader === 'Blue' ? '#3b82f6' : '#888';
        }

        function draw() {
            drawSimulation();
            drawTerritoryChart();
            drawPositionChart();
        }

        function drawSimulation() {
            const cellSize = simCanvas.width / GRID_SIZE;

            // Draw grid
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === RED) {
                        simCtx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                    } else if (grid[y][x] === BLUE) {
                        simCtx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    } else {
                        simCtx.fillStyle = '#d4a574'; // Desert sand
                    }
                    simCtx.fillRect(x * cellSize, y * cellSize, cellSize + 0.5, cellSize + 0.5);
                }
            }

            // Draw agents
            agents.forEach(agent => {
                const px = agent.x * cellSize;
                const py = agent.y * cellSize;

                simCtx.fillStyle = agent.team === RED ? '#dc2626' : '#2563eb';
                simCtx.beginPath();
                simCtx.arc(px, py, cellSize * 2, 0, Math.PI * 2);
                simCtx.fill();

                simCtx.strokeStyle = '#fff';
                simCtx.lineWidth = 2;
                simCtx.stroke();
            });
        }

        function drawTerritoryChart() {
            const w = territoryCanvas.width, h = territoryCanvas.height;
            territoryCtx.fillStyle = 'rgba(0,0,0,0.3)';
            territoryCtx.fillRect(0, 0, w, h);

            if (history.red.length < 2) return;

            // Red territory
            territoryCtx.strokeStyle = '#ef4444';
            territoryCtx.lineWidth = 2;
            territoryCtx.beginPath();
            history.red.forEach((v, i) => {
                const x = (i / MAX_HISTORY) * w;
                const y = h - (v / 100) * h;
                if (i === 0) territoryCtx.moveTo(x, y);
                else territoryCtx.lineTo(x, y);
            });
            territoryCtx.stroke();

            // Blue territory
            territoryCtx.strokeStyle = '#3b82f6';
            territoryCtx.beginPath();
            history.blue.forEach((v, i) => {
                const x = (i / MAX_HISTORY) * w;
                const y = h - (v / 100) * h;
                if (i === 0) territoryCtx.moveTo(x, y);
                else territoryCtx.lineTo(x, y);
            });
            territoryCtx.stroke();

            // 50% line
            territoryCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            territoryCtx.setLineDash([5, 5]);
            territoryCtx.beginPath();
            territoryCtx.moveTo(0, h / 2);
            territoryCtx.lineTo(w, h / 2);
            territoryCtx.stroke();
            territoryCtx.setLineDash([]);
        }

        function drawPositionChart() {
            const w = positionCanvas.width, h = positionCanvas.height;
            positionCtx.fillStyle = 'rgba(0,0,0,0.3)';
            positionCtx.fillRect(0, 0, w, h);

            // Mini map
            const scale = Math.min(w, h) / GRID_SIZE * 0.9;
            const offsetX = (w - GRID_SIZE * scale) / 2;
            const offsetY = (h - GRID_SIZE * scale) / 2;

            // Territory colors (simplified)
            for (let y = 0; y < GRID_SIZE; y += 4) {
                for (let x = 0; x < GRID_SIZE; x += 4) {
                    let redCount = 0, blueCount = 0;
                    for (let dy = 0; dy < 4; dy++) {
                        for (let dx = 0; dx < 4; dx++) {
                            if (y + dy < GRID_SIZE && x + dx < GRID_SIZE) {
                                if (grid[y + dy][x + dx] === RED) redCount++;
                                else if (grid[y + dy][x + dx] === BLUE) blueCount++;
                            }
                        }
                    }
                    if (redCount > blueCount) {
                        positionCtx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                    } else if (blueCount > redCount) {
                        positionCtx.fillStyle = 'rgba(59, 130, 246, 0.5)';
                    } else {
                        positionCtx.fillStyle = 'rgba(212, 165, 116, 0.3)';
                    }
                    positionCtx.fillRect(
                        offsetX + x * scale,
                        offsetY + y * scale,
                        4 * scale,
                        4 * scale
                    );
                }
            }

            // Agents
            agents.forEach(agent => {
                positionCtx.fillStyle = agent.team === RED ? '#ef4444' : '#3b82f6';
                positionCtx.beginPath();
                positionCtx.arc(
                    offsetX + agent.x * scale,
                    offsetY + agent.y * scale,
                    4, 0, Math.PI * 2
                );
                positionCtx.fill();
            });
        }

        function animate() {
            if (running) step();
            requestAnimationFrame(animate);
        }


        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
    </script>
</body>
</html>
