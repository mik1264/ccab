<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Table - Collision Resolution Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #3498db;
            text-decoration: none;
            z-index: 100;
        }
        header { text-align: center; padding: 15px; }
        h1 { color: #3498db; font-size: 1.6rem; }
        .container {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 15px;
            padding: 0 15px 15px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .main-area { display: flex; flex-direction: column; gap: 15px; }
        .canvas-wrapper {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
        }
        .canvas-wrapper h3 {
            color: #3498db;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        #hashCanvas {
            width: 100%;
            height: 400px;
            background: #0a0a15;
            border-radius: 8px;
        }
        .sidebar {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
        }
        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: block;
            color: #3498db;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 5px;
            background: #333;
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="text"] {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #3498db;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #888;
            margin-top: 4px;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #3498db;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: #3498db;
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { background: #2980b9; }
        button.secondary { background: #333; }
        .stats {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 0.8rem;
        }
        .stat-label { color: #888; }
        .stat-value { color: #3498db; font-family: monospace; }
        .load-bar {
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        .load-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #f39c12, #e74c3c);
            transition: width 0.3s;
        }
        .history {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 10px;
            font-size: 0.75rem;
            font-family: monospace;
        }
        .history-item {
            padding: 4px 8px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 4px;
            margin-bottom: 2px;
        }
        .history-item.collision { background: rgba(231, 76, 60, 0.2); }
        .info {
            margin-top: 12px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 6px;
            font-size: 0.75rem;
            line-height: 1.4;
        }
        .info h4 { color: #3498db; margin-bottom: 6px; }
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back</a>

    <header>
        <h1>Hash Table</h1>
        <p style="color: #888; font-size: 0.9rem;">Collision Resolution Visualization</p>
    </header>

    <div class="container">
        <div class="main-area">
            <div class="canvas-wrapper">
                <h3>Hash Table Buckets</h3>
                <canvas id="hashCanvas"></canvas>
            </div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <label>Table Size</label>
                <input type="range" id="tableSize" min="7" max="31" value="13">
                <div class="value-display"><span id="tableSizeVal">13</span> buckets</div>
            </div>

            <div class="control-group">
                <label>Collision Resolution</label>
                <select id="resolution">
                    <option value="chaining">Chaining (Linked Lists)</option>
                    <option value="linear">Linear Probing</option>
                    <option value="quadratic">Quadratic Probing</option>
                    <option value="double">Double Hashing</option>
                </select>
            </div>

            <div class="control-group">
                <label>Insert Key</label>
                <input type="text" id="keyInput" placeholder="Enter a string or number">
            </div>

            <button id="insertBtn">Insert Key</button>
            <button id="randomBtn" class="secondary">Insert Random</button>
            <button id="fillBtn" class="secondary">Fill to 70%</button>
            <button id="resetBtn" class="secondary">Clear Table</button>

            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Items:</span>
                    <span class="stat-value" id="itemsStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Load Factor:</span>
                    <span class="stat-value" id="loadStat">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Collisions:</span>
                    <span class="stat-value" id="collisionsStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Probes:</span>
                    <span class="stat-value" id="probesStat">0</span>
                </div>
                <div class="load-bar">
                    <div class="load-fill" id="loadFill" style="width: 0%"></div>
                </div>
            </div>

            <div class="history" id="history"></div>

            <div class="info">
                <h4>Hash Function</h4>
                <p>h(key) = (sum of char codes) mod table_size</p>
                <p style="margin-top:6px"><strong>Chaining:</strong> Store collisions in linked lists.</p>
                <p><strong>Linear:</strong> Probe next slot (h+1, h+2, ...)</p>
                <p><strong>Quadratic:</strong> Probe h+1², h+2², ...</p>
                <p><strong>Double:</strong> Use second hash for step size.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('hashCanvas');
        const ctx = canvas.getContext('2d');

        let tableSize = 13;
        let resolution = 'chaining';
        let table = [];
        let totalCollisions = 0;
        let totalProbes = 0;
        let insertCount = 0;
        let lastInsert = null;

        function resize() {
            canvas.width = canvas.parentElement.clientWidth - 30;
            canvas.height = 400;
            render();
        }

        function initTable() {
            if (resolution === 'chaining') {
                table = new Array(tableSize).fill(null).map(() => []);
            } else {
                table = new Array(tableSize).fill(null);
            }
            totalCollisions = 0;
            totalProbes = 0;
            insertCount = 0;
            lastInsert = null;
            document.getElementById('history').innerHTML = '';
            updateStats();
            render();
        }

        function hash(key) {
            let sum = 0;
            const str = String(key);
            for (let i = 0; i < str.length; i++) {
                sum += str.charCodeAt(i);
            }
            return sum % tableSize;
        }

        function hash2(key) {
            // Second hash for double hashing
            let sum = 0;
            const str = String(key);
            for (let i = 0; i < str.length; i++) {
                sum += str.charCodeAt(i) * (i + 1);
            }
            return 1 + (sum % (tableSize - 1));
        }

        function insert(key) {
            const h = hash(key);
            let probes = 1;
            let collision = false;
            let finalIndex = h;

            if (resolution === 'chaining') {
                if (table[h].length > 0) {
                    collision = true;
                    totalCollisions++;
                }
                table[h].push(key);
            } else {
                // Open addressing
                if (table[h] !== null) {
                    collision = true;
                    let i = 1;
                    let found = false;

                    while (!found && probes < tableSize) {
                        let newIndex;
                        if (resolution === 'linear') {
                            newIndex = (h + i) % tableSize;
                        } else if (resolution === 'quadratic') {
                            newIndex = (h + i * i) % tableSize;
                        } else if (resolution === 'double') {
                            const step = hash2(key);
                            newIndex = (h + i * step) % tableSize;
                        }

                        probes++;
                        if (table[newIndex] === null) {
                            table[newIndex] = key;
                            finalIndex = newIndex;
                            found = true;
                        }
                        i++;
                    }

                    if (!found) {
                        addHistory(`Failed to insert "${key}" - table full`, true);
                        return;
                    }
                    totalCollisions++;
                } else {
                    table[h] = key;
                }
            }

            totalProbes += probes;
            insertCount++;
            lastInsert = { key, index: finalIndex, hash: h, probes, collision };

            const msg = collision
                ? `"${key}" → h=${h}, ${probes} probes → slot ${finalIndex}`
                : `"${key}" → h=${h} (direct)`;
            addHistory(msg, collision);

            updateStats();
            render();
        }

        function addHistory(msg, isCollision) {
            const history = document.getElementById('history');
            const item = document.createElement('div');
            item.className = 'history-item' + (isCollision ? ' collision' : '');
            item.textContent = msg;
            history.insertBefore(item, history.firstChild);

            // Keep history bounded
            while (history.children.length > 20) {
                history.removeChild(history.lastChild);
            }
        }

        function getItemCount() {
            if (resolution === 'chaining') {
                return table.reduce((sum, bucket) => sum + bucket.length, 0);
            } else {
                return table.filter(slot => slot !== null).length;
            }
        }

        function updateStats() {
            const items = getItemCount();
            const loadFactor = (items / tableSize * 100).toFixed(1);
            const avgProbes = insertCount > 0 ? (totalProbes / insertCount).toFixed(2) : '0';

            document.getElementById('itemsStat').textContent = items;
            document.getElementById('loadStat').textContent = loadFactor + '%';
            document.getElementById('collisionsStat').textContent = totalCollisions;
            document.getElementById('probesStat').textContent = avgProbes;
            document.getElementById('loadFill').style.width = loadFactor + '%';
        }

        function render() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const bucketWidth = (canvas.width - 80) / tableSize;
            const startX = 40;
            const startY = 50;

            // Draw bucket indices
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';

            for (let i = 0; i < tableSize; i++) {
                const x = startX + i * bucketWidth + bucketWidth / 2;
                ctx.fillText(i, x, 30);
            }

            if (resolution === 'chaining') {
                // Draw chaining visualization
                const maxChainLength = Math.max(...table.map(b => b.length), 1);
                const cellHeight = Math.min(30, (canvas.height - 100) / maxChainLength);

                for (let i = 0; i < tableSize; i++) {
                    const x = startX + i * bucketWidth;
                    const bucket = table[i];

                    // Draw bucket outline
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 2, startY, bucketWidth - 4, canvas.height - 80);

                    // Draw items in bucket
                    for (let j = 0; j < bucket.length; j++) {
                        const y = startY + 5 + j * cellHeight;
                        const isLast = lastInsert && lastInsert.index === i && j === bucket.length - 1;

                        ctx.fillStyle = isLast ? '#e74c3c' : '#3498db';
                        ctx.fillRect(x + 4, y, bucketWidth - 8, cellHeight - 2);

                        ctx.fillStyle = '#fff';
                        ctx.font = '10px sans-serif';
                        const text = String(bucket[j]).substring(0, 4);
                        ctx.fillText(text, x + bucketWidth / 2, y + cellHeight / 2 + 3);
                    }
                }
            } else {
                // Draw open addressing visualization
                const cellHeight = 40;

                for (let i = 0; i < tableSize; i++) {
                    const x = startX + i * bucketWidth;
                    const isHighlight = lastInsert && lastInsert.index === i;
                    const isProbed = lastInsert && lastInsert.collision && i >= lastInsert.hash && i <= lastInsert.index;

                    // Draw slot
                    if (table[i] !== null) {
                        ctx.fillStyle = isHighlight ? '#e74c3c' : '#3498db';
                    } else {
                        ctx.fillStyle = isProbed ? 'rgba(231, 76, 60, 0.3)' : '#1a1a2e';
                    }
                    ctx.fillRect(x + 2, startY, bucketWidth - 4, cellHeight);

                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 2, startY, bucketWidth - 4, cellHeight);

                    // Draw content
                    if (table[i] !== null) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px sans-serif';
                        const text = String(table[i]).substring(0, 4);
                        ctx.fillText(text, x + bucketWidth / 2, startY + cellHeight / 2 + 3);
                    }
                }

                // Draw probe path if there was a collision
                if (lastInsert && lastInsert.collision) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();

                    const startBucketX = startX + lastInsert.hash * bucketWidth + bucketWidth / 2;
                    const endBucketX = startX + lastInsert.index * bucketWidth + bucketWidth / 2;

                    ctx.moveTo(startBucketX, startY + cellHeight + 10);
                    ctx.lineTo(endBucketX, startY + cellHeight + 10);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Arrow
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.moveTo(endBucketX, startY + cellHeight + 10);
                    ctx.lineTo(endBucketX - 5, startY + cellHeight + 5);
                    ctx.lineTo(endBucketX - 5, startY + cellHeight + 15);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw load factor visualization
            const barY = canvas.height - 30;
            ctx.fillStyle = '#333';
            ctx.fillRect(40, barY, canvas.width - 80, 15);

            const loadFactor = getItemCount() / tableSize;
            const loadColor = loadFactor < 0.5 ? '#2ecc71' : loadFactor < 0.75 ? '#f39c12' : '#e74c3c';
            ctx.fillStyle = loadColor;
            ctx.fillRect(40, barY, (canvas.width - 80) * loadFactor, 15);

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Load Factor', 40, barY - 5);
        }

        function generateRandomKey() {
            const chars = 'abcdefghijklmnopqrstuvwxyz';
            let key = '';
            const len = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < len; i++) {
                key += chars[Math.floor(Math.random() * chars.length)];
            }
            return key;
        }

        // Event listeners
        document.getElementById('tableSize').addEventListener('input', (e) => {
            tableSize = parseInt(e.target.value);
            document.getElementById('tableSizeVal').textContent = tableSize;
        });

        document.getElementById('resolution').addEventListener('change', (e) => {
            resolution = e.target.value;
            initTable();
        });

        document.getElementById('insertBtn').addEventListener('click', () => {
            const key = document.getElementById('keyInput').value.trim();
            if (key) {
                insert(key);
                document.getElementById('keyInput').value = '';
            }
        });

        document.getElementById('keyInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('insertBtn').click();
            }
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            insert(generateRandomKey());
        });

        document.getElementById('fillBtn').addEventListener('click', () => {
            const targetCount = Math.floor(tableSize * 0.7);
            const currentCount = getItemCount();
            for (let i = currentCount; i < targetCount; i++) {
                insert(generateRandomKey());
            }
        });

        document.getElementById('resetBtn').addEventListener('click', initTable);

        window.addEventListener('resize', resize);
        resize();
        initTable();
    </script>
</body>
</html>
