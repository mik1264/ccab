<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo - Complex Adaptive Systems</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
        }
        .container {
            display: flex;
            width: 100%;
        }
        .controls {
            width: 300px;
            padding: 20px;
            background: #12172b;
            overflow-y: auto;
            max-height: 100vh;
        }
        .controls h1 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: #ce93d8;
        }
        .controls p {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ba68c8;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #ce93d8;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        button.primary {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
            color: white;
        }
        button.secondary {
            background: #2d3a4f;
            color: #ba68c8;
        }
        button:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
        }
        .stats h3 {
            font-size: 0.9rem;
            color: #ce93d8;
            margin-bottom: 10px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #2a3050;
            font-size: 0.85rem;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #e1bee7;
            font-weight: 500;
        }
        .legend {
            margin-top: 15px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
        }
        .legend h3 {
            font-size: 0.9rem;
            color: #ce93d8;
            margin-bottom: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
            font-size: 0.8rem;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #ce93d8;
            text-decoration: none;
            font-size: 0.85rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .back-link:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <a href="index.html" class="back-link">← Back to Gallery</a>
            <h1>Echo Model</h1>
            <p>John Holland's Echo model of complex adaptive systems. Agents gather resources, engage in combat, trade, and reproduce with hereditary transmission of tags.</p>

            <div class="control-group">
                <label>Initial Agents: <span class="value-display" id="agentVal">50</span></label>
                <input type="range" id="agents" min="20" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Resource Sites: <span class="value-display" id="resourceVal">30</span></label>
                <input type="range" id="resources" min="10" max="50" value="30">
            </div>

            <div class="control-group">
                <label>Combat Rate: <span class="value-display" id="combatVal">20%</span></label>
                <input type="range" id="combat" min="0" max="50" value="20">
            </div>

            <div class="control-group">
                <label>Trade Rate: <span class="value-display" id="tradeVal">30%</span></label>
                <input type="range" id="trade" min="0" max="50" value="30">
            </div>

            <div class="control-group">
                <label>Mutation Rate: <span class="value-display" id="mutationVal">5%</span></label>
                <input type="range" id="mutation" min="0" max="20" value="5">
            </div>

            <div class="control-group">
                <label>Simulation Speed: <span class="value-display" id="speedVal">1x</span></label>
                <input type="range" id="speed" min="1" max="10" value="1">
            </div>

            <button class="primary" onclick="toggleSimulation()">Start</button>
            <button class="secondary" onclick="resetSimulation()">Reset</button>

            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Tick</span>
                    <span class="stat-value" id="tick">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Population</span>
                    <span class="stat-value" id="population">50</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Combats</span>
                    <span class="stat-value" id="combats">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Trades</span>
                    <span class="stat-value" id="trades">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Births</span>
                    <span class="stat-value" id="births">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Deaths</span>
                    <span class="stat-value" id="deaths">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Dominant Tag</span>
                    <span class="stat-value" id="dominantTag">-</span>
                </div>
            </div>

            <div class="legend">
                <h3>Agent Tags (Resources)</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef5350;"></div>
                    <span>Red (A resource)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #66bb6a;"></div>
                    <span>Green (B resource)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #42a5f5;"></div>
                    <span>Blue (C resource)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffca28;"></div>
                    <span>Yellow (D resource)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255,255,255,0.5);"></div>
                    <span>○ Resource Sites</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let running = false;
        let tick = 0;
        let agents = [];
        let resourceSites = [];
        let combatCount = 0;
        let tradeCount = 0;
        let birthCount = 0;
        let deathCount = 0;

        // Resource types
        const RESOURCE_TYPES = ['A', 'B', 'C', 'D'];
        const RESOURCE_COLORS = {
            'A': '#ef5350',
            'B': '#66bb6a',
            'C': '#42a5f5',
            'D': '#ffca28'
        };

        // Simulation parameters
        let params = {
            agents: 50,
            resources: 30,
            combatRate: 0.2,
            tradeRate: 0.3,
            mutationRate: 0.05,
            speed: 1
        };

        function initCanvas() {
            const wrapper = document.querySelector('.canvas-wrapper');
            const size = Math.min(wrapper.clientWidth - 40, wrapper.clientHeight - 40, 600);
            canvas.width = size;
            canvas.height = size;
        }

        function createAgent(x = null, y = null, parentTag = null) {
            const agent = {
                x: x || Math.random() * canvas.width,
                y: y || Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                tag: parentTag ? mutateTag(parentTag) : generateRandomTag(),
                reservoir: {},
                energy: 50 + Math.random() * 50,
                age: 0
            };

            // Initialize reservoir
            RESOURCE_TYPES.forEach(r => agent.reservoir[r] = 0);

            return agent;
        }

        function generateRandomTag() {
            // Tag is a sequence of resource types (like DNA)
            const length = 3 + Math.floor(Math.random() * 3);
            let tag = '';
            for (let i = 0; i < length; i++) {
                tag += RESOURCE_TYPES[Math.floor(Math.random() * RESOURCE_TYPES.length)];
            }
            return tag;
        }

        function mutateTag(tag) {
            if (Math.random() > params.mutationRate) return tag;

            let newTag = tag.split('');
            const mutation = Math.random();

            if (mutation < 0.4 && newTag.length > 1) {
                // Delete a character
                const idx = Math.floor(Math.random() * newTag.length);
                newTag.splice(idx, 1);
            } else if (mutation < 0.7) {
                // Change a character
                const idx = Math.floor(Math.random() * newTag.length);
                newTag[idx] = RESOURCE_TYPES[Math.floor(Math.random() * RESOURCE_TYPES.length)];
            } else if (newTag.length < 6) {
                // Add a character
                const idx = Math.floor(Math.random() * (newTag.length + 1));
                newTag.splice(idx, 0, RESOURCE_TYPES[Math.floor(Math.random() * RESOURCE_TYPES.length)]);
            }

            return newTag.join('');
        }

        function createResourceSite() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                type: RESOURCE_TYPES[Math.floor(Math.random() * RESOURCE_TYPES.length)],
                amount: 50 + Math.random() * 100,
                maxAmount: 150,
                regeneration: 0.5 + Math.random() * 1.5
            };
        }

        function init() {
            agents = [];
            resourceSites = [];

            for (let i = 0; i < params.agents; i++) {
                agents.push(createAgent());
            }

            for (let i = 0; i < params.resources; i++) {
                resourceSites.push(createResourceSite());
            }

            tick = 0;
            combatCount = 0;
            tradeCount = 0;
            birthCount = 0;
            deathCount = 0;

            updateStats();
            render();
        }

        function getTagColor(tag) {
            // Mix colors based on tag composition
            const counts = {};
            RESOURCE_TYPES.forEach(r => counts[r] = 0);
            for (const c of tag) {
                counts[c]++;
            }

            let r = 0, g = 0, b = 0;
            const total = tag.length;

            // Red contribution (A)
            r += counts['A'] / total * 239;
            g += counts['A'] / total * 83;
            b += counts['A'] / total * 80;

            // Green contribution (B)
            r += counts['B'] / total * 102;
            g += counts['B'] / total * 187;
            b += counts['B'] / total * 106;

            // Blue contribution (C)
            r += counts['C'] / total * 66;
            g += counts['C'] / total * 165;
            b += counts['C'] / total * 245;

            // Yellow contribution (D)
            r += counts['D'] / total * 255;
            g += counts['D'] / total * 202;
            b += counts['D'] / total * 40;

            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        function getTagSimilarity(tag1, tag2) {
            // Compute similarity based on shared prefixes
            const minLen = Math.min(tag1.length, tag2.length);
            let matches = 0;
            for (let i = 0; i < minLen; i++) {
                if (tag1[i] === tag2[i]) matches++;
            }
            return matches / Math.max(tag1.length, tag2.length);
        }

        function step() {
            // Regenerate resources
            for (const site of resourceSites) {
                site.amount = Math.min(site.maxAmount, site.amount + site.regeneration);
            }

            // Update agents
            for (const agent of agents) {
                // Movement
                agent.x += agent.vx;
                agent.y += agent.vy;

                // Bounce off walls
                if (agent.x < 0 || agent.x > canvas.width) agent.vx *= -1;
                if (agent.y < 0 || agent.y > canvas.height) agent.vy *= -1;

                agent.x = Math.max(0, Math.min(canvas.width, agent.x));
                agent.y = Math.max(0, Math.min(canvas.height, agent.y));

                // Random direction change
                if (Math.random() < 0.1) {
                    agent.vx += (Math.random() - 0.5) * 0.5;
                    agent.vy += (Math.random() - 0.5) * 0.5;
                    const speed = Math.sqrt(agent.vx ** 2 + agent.vy ** 2);
                    if (speed > 3) {
                        agent.vx = (agent.vx / speed) * 3;
                        agent.vy = (agent.vy / speed) * 3;
                    }
                }

                // Energy cost
                agent.energy -= 0.1;
                agent.age++;

                // Gather resources
                for (const site of resourceSites) {
                    const dist = Math.hypot(agent.x - site.x, agent.y - site.y);
                    if (dist < 20 && site.amount > 0) {
                        const gather = Math.min(2, site.amount);
                        site.amount -= gather;
                        agent.reservoir[site.type] += gather;
                        agent.energy += gather * 2;
                    }
                }
            }

            // Agent interactions
            for (let i = 0; i < agents.length; i++) {
                for (let j = i + 1; j < agents.length; j++) {
                    const a1 = agents[i];
                    const a2 = agents[j];
                    const dist = Math.hypot(a1.x - a2.x, a1.y - a2.y);

                    if (dist < 15) {
                        const similarity = getTagSimilarity(a1.tag, a2.tag);

                        if (similarity < 0.3 && Math.random() < params.combatRate) {
                            // Combat between dissimilar agents
                            combat(a1, a2);
                        } else if (similarity > 0.5 && Math.random() < params.tradeRate) {
                            // Trade between similar agents
                            trade(a1, a2);
                        }
                    }
                }
            }

            // Reproduction
            const newAgents = [];
            for (const agent of agents) {
                if (agent.energy > 100 && canReproduce(agent)) {
                    const offspring = reproduce(agent);
                    if (offspring) {
                        newAgents.push(offspring);
                        birthCount++;
                    }
                }
            }
            agents.push(...newAgents);

            // Death
            const survivingAgents = agents.filter(a => {
                if (a.energy <= 0) {
                    deathCount++;
                    return false;
                }
                return true;
            });
            agents = survivingAgents;

            // Population control
            while (agents.length > 200) {
                // Remove oldest/weakest
                agents.sort((a, b) => a.energy - b.energy);
                agents.shift();
                deathCount++;
            }

            tick++;
            updateStats();
        }

        function combat(a1, a2) {
            combatCount++;

            // Combat based on offense/defense tags
            const a1Strength = a1.tag.length + a1.energy / 50;
            const a2Strength = a2.tag.length + a2.energy / 50;

            if (a1Strength > a2Strength) {
                // A1 wins, takes resources
                for (const r of RESOURCE_TYPES) {
                    const stolen = Math.min(a2.reservoir[r], 10);
                    a1.reservoir[r] += stolen;
                    a2.reservoir[r] -= stolen;
                }
                a2.energy -= 20;
                a1.energy += 10;
            } else {
                // A2 wins
                for (const r of RESOURCE_TYPES) {
                    const stolen = Math.min(a1.reservoir[r], 10);
                    a2.reservoir[r] += stolen;
                    a1.reservoir[r] -= stolen;
                }
                a1.energy -= 20;
                a2.energy += 10;
            }
        }

        function trade(a1, a2) {
            tradeCount++;

            // Exchange resources based on needs
            for (const r of RESOURCE_TYPES) {
                const diff = a1.reservoir[r] - a2.reservoir[r];
                if (Math.abs(diff) > 5) {
                    const transfer = Math.sign(diff) * 2;
                    a1.reservoir[r] -= transfer;
                    a2.reservoir[r] += transfer;
                    a1.energy += 1;
                    a2.energy += 1;
                }
            }
        }

        function canReproduce(agent) {
            // Need resources matching tag pattern
            for (const r of agent.tag) {
                if (agent.reservoir[r] < 3) return false;
            }
            return true;
        }

        function reproduce(agent) {
            // Consume resources
            for (const r of agent.tag) {
                agent.reservoir[r] -= 3;
            }
            agent.energy -= 30;

            // Create offspring near parent
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 10;
            return createAgent(
                agent.x + Math.cos(angle) * dist,
                agent.y + Math.sin(angle) * dist,
                agent.tag
            );
        }

        function updateStats() {
            document.getElementById('tick').textContent = tick;
            document.getElementById('population').textContent = agents.length;
            document.getElementById('combats').textContent = combatCount;
            document.getElementById('trades').textContent = tradeCount;
            document.getElementById('births').textContent = birthCount;
            document.getElementById('deaths').textContent = deathCount;

            // Find dominant tag
            const tagCounts = {};
            for (const agent of agents) {
                tagCounts[agent.tag] = (tagCounts[agent.tag] || 0) + 1;
            }

            let maxCount = 0;
            let dominantTag = '-';
            for (const tag in tagCounts) {
                if (tagCounts[tag] > maxCount) {
                    maxCount = tagCounts[tag];
                    dominantTag = tag;
                }
            }
            document.getElementById('dominantTag').textContent = dominantTag + ` (${maxCount})`;
        }

        function render() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw resource sites
            for (const site of resourceSites) {
                const alpha = Math.min(1, site.amount / site.maxAmount);
                ctx.fillStyle = RESOURCE_COLORS[site.type];
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(site.x, site.y, 15 + site.amount / 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(site.x, site.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.strokeStyle = RESOURCE_COLORS[site.type];
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(site.x, site.y, 15, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw agents
            for (const agent of agents) {
                const color = getTagColor(agent.tag);
                const size = 4 + Math.min(6, agent.energy / 30);

                // Glow for high-energy agents
                if (agent.energy > 80) {
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.2;
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Body
                ctx.globalAlpha = 1;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Direction indicator
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(agent.x, agent.y);
                ctx.lineTo(agent.x + agent.vx * 3, agent.y + agent.vy * 3);
                ctx.stroke();
            }

            // Draw interaction lines briefly
            ctx.globalAlpha = 1;
        }

        function animate() {
            if (!running) return;

            for (let i = 0; i < params.speed; i++) {
                step();
            }
            render();
            requestAnimationFrame(animate);
        }

        function toggleSimulation() {
            running = !running;
            document.querySelector('.primary').textContent = running ? 'Pause' : 'Start';
            if (running) animate();
        }

        function resetSimulation() {
            running = false;
            document.querySelector('.primary').textContent = 'Start';

            params.agents = parseInt(document.getElementById('agents').value);
            params.resources = parseInt(document.getElementById('resources').value);
            params.combatRate = parseInt(document.getElementById('combat').value) / 100;
            params.tradeRate = parseInt(document.getElementById('trade').value) / 100;
            params.mutationRate = parseInt(document.getElementById('mutation').value) / 100;

            init();
        }

        // Event listeners
        document.getElementById('agents').addEventListener('input', function() {
            document.getElementById('agentVal').textContent = this.value;
        });
        document.getElementById('resources').addEventListener('input', function() {
            document.getElementById('resourceVal').textContent = this.value;
        });
        document.getElementById('combat').addEventListener('input', function() {
            document.getElementById('combatVal').textContent = this.value + '%';
        });
        document.getElementById('trade').addEventListener('input', function() {
            document.getElementById('tradeVal').textContent = this.value + '%';
        });
        document.getElementById('mutation').addEventListener('input', function() {
            document.getElementById('mutationVal').textContent = this.value + '%';
        });
        document.getElementById('speed').addEventListener('input', function() {
            params.speed = parseInt(this.value);
            document.getElementById('speedVal').textContent = this.value + 'x';
        });

        window.addEventListener('resize', () => {
            initCanvas();
            render();
        });

        // Initialize
        initCanvas();
        init();
    </script>
</body>
</html>
