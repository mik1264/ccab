<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Living Decisions - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls {
            width: 300px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            overflow-y: auto;
        }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #60a5fa; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #60a5fa;
            color: #1a1a2e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background: #3b82f6; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-bottom: 15px;
        }
        .stats div { margin-bottom: 5px; }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            color: #60a5fa;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover { background: rgba(96,165,250,0.2); }
        .legend { margin-top: 15px; font-size: 0.75rem; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .legend-color { width: 15px; height: 15px; margin-right: 8px; border-radius: 3px; }
        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
        }
        .modal-close:hover { color: #fff; }
        .modal h2 { color: #60a5fa; margin-bottom: 20px; font-size: 1.5rem; }
        .modal-body { color: #ccc; line-height: 1.8; font-size: 0.95rem; }
        .modal-body h3 { color: #a5b4fc; margin: 20px 0 10px 0; font-size: 1.1rem; }
        .modal-body p { margin-bottom: 15px; }
        .modal-body ul { margin: 10px 0 15px 20px; }
        .modal-body li { margin-bottom: 8px; }
        .modal-body strong { color: #60a5fa; }
        .modal-body em { color: #a5b4fc; font-style: normal; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Group Living Decisions</h1>

            <div class="control-group">
                <label>Number of Individuals: <span id="popCountValue">100</span></label>
                <input type="range" id="popCount" min="20" max="200" value="100">
            </div>

            <div class="control-group">
                <label>Predation Pressure: <span id="predationValue">0.5</span></label>
                <input type="range" id="predation" min="0" max="1.0" step="0.05" value="0.5">
            </div>

            <div class="control-group">
                <label>Resource Competition: <span id="competitionValue">0.3</span></label>
                <input type="range" id="competition" min="0" max="1.0" step="0.05" value="0.3">
            </div>

            <div class="control-group">
                <label>Information Benefit: <span id="infoValue">0.5</span></label>
                <input type="range" id="info" min="0" max="1.0" step="0.05" value="0.5">
            </div>

            <div class="control-group">
                <label>Disease Risk: <span id="diseaseValue">0.1</span></label>
                <input type="range" id="disease" min="0" max="0.5" step="0.02" value="0.1">
            </div>

            <button id="reset">Reset Simulation</button>
            <button id="addPredator">Add Predator</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>

            <div class="stats">
                <div>Avg Group Size: <span id="avgGroupSize">0</span></div>
                <div>Number of Groups: <span id="numGroups">0</span></div>
                <div>Solitary: <span id="solitary">0</span></div>
                <div>Survival Rate: <span id="survivalRate">0%</span></div>
                <div>Avg Fitness: <span id="avgFitness">0</span></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #60a5fa;"></div>
                    <span>Group Members</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Predators</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>Food Resources</span>
                </div>
            </div>
        </div>
    </div>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>ü¶ì Group Living Decisions</h2>
            <div class="modal-body">
                <p>This simulation explores the <strong>evolution of sociality</strong> ‚Äî why do some animals live in groups while others are solitary? The answer lies in a cost-benefit analysis.</p>

                <h3>Benefits of Group Living</h3>
                <ul>
                    <li><strong>Predator Dilution:</strong> In a group of 10, each individual has only 1/10 chance of being the victim</li>
                    <li><strong>Vigilance Sharing:</strong> More eyes = earlier predator detection</li>
                    <li><strong>Information Transfer:</strong> Learn food locations from others</li>
                    <li><strong>Cooperative Defense:</strong> Mobbing predators together</li>
                </ul>

                <h3>Costs of Group Living</h3>
                <ul>
                    <li><strong>Competition:</strong> Must share food with group members</li>
                    <li><strong>Conspicuousness:</strong> Large groups attract predators</li>
                    <li><strong>Disease Risk:</strong> Pathogens spread faster in dense groups</li>
                    <li><strong>Aggression:</strong> Conflict over resources and mates</li>
                </ul>

                <h3>Optimal Group Size</h3>
                <p>Theory predicts an <strong>optimal group size</strong> where benefits exceed costs maximally. Groups smaller or larger than optimal have lower fitness:</p>
                <ul>
                    <li>Too small: Predation risk remains high</li>
                    <li>Too large: Competition eliminates predation benefits</li>
                </ul>

                <h3>Real Examples</h3>
                <ul>
                    <li><strong>Redshanks:</strong> Optimal flock size ~30-70 birds for sparrowhawk defense</li>
                    <li><strong>Lions:</strong> Prides of 4-6 females optimal for territory defense</li>
                    <li><strong>Fish Schools:</strong> Size varies with predator presence</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Increase <em>Predation Pressure</em> to favor larger groups</li>
                    <li>Increase <em>Competition</em> to favor smaller groups</li>
                    <li>Add predators and watch groups form/disperse</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let params = {
            popCount: 100,
            predation: 0.5,
            competition: 0.3,
            infoBenefit: 0.5,
            disease: 0.1
        };

        let individuals = [];
        let predators = [];
        let resources = [];
        let deaths = 0;
        let totalBorn = 0;

        function resize() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function createIndividual(x, y) {
            return {
                x: x || Math.random() * canvas.width,
                y: y || Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                groupPreference: Math.random(), // 0 = solitary, 1 = social
                energy: 0.5 + Math.random() * 0.5,
                fitness: 0,
                alive: true
            };
        }

        function createPredator() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                energy: 1,
                target: null
            };
        }

        function createResource() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                value: 0.3 + Math.random() * 0.7
            };
        }

        function init() {
            resize();
            individuals = [];
            predators = [];
            resources = [];
            deaths = 0;
            totalBorn = params.popCount;

            for (let i = 0; i < params.popCount; i++) {
                individuals.push(createIndividual());
            }

            // Add some predators based on predation pressure
            const numPredators = Math.floor(params.predation * 5);
            for (let i = 0; i < numPredators; i++) {
                predators.push(createPredator());
            }

            // Add resources
            for (let i = 0; i < 50; i++) {
                resources.push(createResource());
            }
        }

        function getGroupSize(individual) {
            let count = 0;
            const groupRadius = 50;
            for (let other of individuals) {
                if (other.alive && other !== individual) {
                    const dx = other.x - individual.x;
                    const dy = other.y - individual.y;
                    if (dx * dx + dy * dy < groupRadius * groupRadius) {
                        count++;
                    }
                }
            }
            return count;
        }

        function calculateFitness(individual) {
            const groupSize = getGroupSize(individual);
            
            // Dilution effect (predation risk decreases with group size)
            const dilutionBenefit = params.predation * (1 - 1 / (groupSize + 1));
            
            // Information benefit
            const infoBenefit = params.infoBenefit * Math.log(groupSize + 1) * 0.2;
            
            // Competition cost
            const competitionCost = params.competition * groupSize * 0.1;
            
            // Disease cost
            const diseaseCost = params.disease * groupSize * 0.05;
            
            return individual.energy + dilutionBenefit + infoBenefit - competitionCost - diseaseCost;
        }

        function updateIndividual(individual) {
            if (!individual.alive) return;

            const groupSize = getGroupSize(individual);
            individual.fitness = calculateFitness(individual);

            // Movement based on group preference
            let targetX = individual.x;
            let targetY = individual.y;

            if (individual.groupPreference > 0.5) {
                // Social: move toward others
                let nearbyCount = 0;
                let avgX = 0, avgY = 0;
                for (let other of individuals) {
                    if (other !== individual && other.alive) {
                        const dx = other.x - individual.x;
                        const dy = other.y - individual.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            avgX += other.x;
                            avgY += other.y;
                            nearbyCount++;
                        }
                    }
                }
                if (nearbyCount > 0) {
                    targetX = avgX / nearbyCount;
                    targetY = avgY / nearbyCount;
                }
            } else {
                // Solitary: avoid others
                for (let other of individuals) {
                    if (other !== individual && other.alive) {
                        const dx = other.x - individual.x;
                        const dy = other.y - individual.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 50 && dist > 0) {
                            targetX -= dx / dist * 10;
                            targetY -= dy / dist * 10;
                        }
                    }
                }
            }

            // Flee from predators
            for (let pred of predators) {
                const dx = pred.x - individual.x;
                const dy = pred.y - individual.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150) {
                    targetX -= dx / dist * 50;
                    targetY -= dy / dist * 50;
                }
            }

            // Move toward resources if hungry
            if (individual.energy < 0.5) {
                let nearestFood = null;
                let nearestDist = Infinity;
                for (let res of resources) {
                    const dx = res.x - individual.x;
                    const dy = res.y - individual.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestFood = res;
                    }
                }
                if (nearestFood && nearestDist < 200) {
                    targetX = nearestFood.x;
                    targetY = nearestFood.y;
                }
            }

            // Apply movement
            const dx = targetX - individual.x;
            const dy = targetY - individual.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 1) {
                individual.vx += dx / dist * 0.2;
                individual.vy += dy / dist * 0.2;
            }

            individual.vx *= 0.95;
            individual.vy *= 0.95;
            individual.x += individual.vx;
            individual.y += individual.vy;

            // Bounce off walls
            if (individual.x < 0 || individual.x > canvas.width) individual.vx *= -1;
            if (individual.y < 0 || individual.y > canvas.height) individual.vy *= -1;
            individual.x = Math.max(0, Math.min(canvas.width, individual.x));
            individual.y = Math.max(0, Math.min(canvas.height, individual.y));

            // Eat resources
            for (let i = resources.length - 1; i >= 0; i--) {
                const res = resources[i];
                const dx = res.x - individual.x;
                const dy = res.y - individual.y;
                if (dx * dx + dy * dy < 100) {
                    // Share with group members (competition)
                    const share = res.value / (groupSize + 1);
                    individual.energy = Math.min(1.5, individual.energy + share);
                    resources.splice(i, 1);
                    resources.push(createResource());
                }
            }

            // Energy decay
            individual.energy -= 0.001;
            if (individual.energy <= 0) {
                individual.alive = false;
                deaths++;
            }
        }

        function updatePredator(predator) {
            // Find target
            if (!predator.target || !predator.target.alive) {
                // Target individuals in smaller groups (easier prey)
                let bestTarget = null;
                let bestScore = -Infinity;
                
                for (let ind of individuals) {
                    if (!ind.alive) continue;
                    const dx = ind.x - predator.x;
                    const dy = ind.y - predator.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const groupSize = getGroupSize(ind);
                    
                    // Prefer closer, more isolated prey
                    const score = 1000 / (dist + 1) - groupSize * params.predation * 10;
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = ind;
                    }
                }
                predator.target = bestTarget;
            }

            // Chase target
            if (predator.target && predator.target.alive) {
                const dx = predator.target.x - predator.x;
                const dy = predator.target.y - predator.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    predator.vx += dx / dist * 0.3;
                    predator.vy += dy / dist * 0.3;
                }

                // Catch prey
                if (dist < 15) {
                    const groupSize = getGroupSize(predator.target);
                    // Dilution effect
                    const catchProb = 1 / (groupSize + 1);
                    if (Math.random() < catchProb) {
                        predator.target.alive = false;
                        deaths++;
                        predator.energy = 1;
                    }
                    predator.target = null;
                }
            }

            predator.vx *= 0.95;
            predator.vy *= 0.95;
            predator.x += predator.vx;
            predator.y += predator.vy;

            // Bounce off walls
            if (predator.x < 0 || predator.x > canvas.width) predator.vx *= -1;
            if (predator.y < 0 || predator.y > canvas.height) predator.vy *= -1;
            predator.x = Math.max(0, Math.min(canvas.width, predator.x));
            predator.y = Math.max(0, Math.min(canvas.height, predator.y));

            // Energy decay
            predator.energy -= 0.002;
            if (predator.energy <= 0) {
                const idx = predators.indexOf(predator);
                if (idx >= 0) predators.splice(idx, 1);
            }
        }

        function reproduce() {
            const aliveInds = individuals.filter(i => i.alive);
            if (aliveInds.length < params.popCount * 0.5) {
                // Reproduce based on fitness
                const fitInds = [...aliveInds].sort((a, b) => b.fitness - a.fitness);
                const numOffspring = Math.min(5, params.popCount - aliveInds.length);
                
                for (let i = 0; i < numOffspring && i < fitInds.length; i++) {
                    const parent = fitInds[i];
                    const offspring = createIndividual(
                        parent.x + (Math.random() - 0.5) * 20,
                        parent.y + (Math.random() - 0.5) * 20
                    );
                    // Inherit group preference with mutation
                    offspring.groupPreference = parent.groupPreference + (Math.random() - 0.5) * 0.2;
                    offspring.groupPreference = Math.max(0, Math.min(1, offspring.groupPreference));
                    individuals.push(offspring);
                    totalBorn++;
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw resources
            for (let res of resources) {
                ctx.beginPath();
                ctx.arc(res.x, res.y, 4 + res.value * 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(34, 197, 94, ${0.3 + res.value * 0.5})`;
                ctx.fill();
            }

            // Find groups and draw connections
            const aliveInds = individuals.filter(i => i.alive);
            for (let ind of aliveInds) {
                for (let other of aliveInds) {
                    if (other !== ind) {
                        const dx = other.x - ind.x;
                        const dy = other.y - ind.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 50) {
                            ctx.beginPath();
                            ctx.moveTo(ind.x, ind.y);
                            ctx.lineTo(other.x, other.y);
                            ctx.strokeStyle = `rgba(96, 165, 250, ${0.1 * (1 - dist/50)})`;
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw individuals
            let totalGroupSize = 0;
            let numInGroups = 0;
            let solitary = 0;

            for (let ind of aliveInds) {
                updateIndividual(ind);
                
                const groupSize = getGroupSize(ind);
                if (groupSize > 0) {
                    numInGroups++;
                    totalGroupSize += groupSize + 1;
                } else {
                    solitary++;
                }

                const size = 4 + ind.energy * 4;
                ctx.beginPath();
                ctx.arc(ind.x, ind.y, size, 0, Math.PI * 2);
                
                // Color based on group preference
                const hue = 200 + ind.groupPreference * 60;
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.fill();
            }

            // Draw predators
            for (let pred of predators) {
                updatePredator(pred);
                
                ctx.beginPath();
                ctx.arc(pred.x, pred.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();

                // Eyes
                const angle = Math.atan2(pred.vy, pred.vx);
                ctx.beginPath();
                ctx.arc(pred.x + Math.cos(angle) * 5, pred.y + Math.sin(angle) * 5, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fill();
            }

            // Periodically reproduce
            if (Math.random() < 0.02) reproduce();

            // Update stats
            const aliveCount = individuals.filter(i => i.alive).length;
            const avgFitness = aliveCount > 0 ? 
                aliveInds.reduce((s, i) => s + i.fitness, 0) / aliveCount : 0;

            // Count distinct groups
            const checked = new Set();
            let numGroups = 0;
            for (let ind of aliveInds) {
                if (!checked.has(ind)) {
                    const groupSize = getGroupSize(ind);
                    if (groupSize > 0) {
                        numGroups++;
                        for (let other of aliveInds) {
                            const dx = other.x - ind.x;
                            const dy = other.y - ind.y;
                            if (dx * dx + dy * dy < 50 * 50) checked.add(other);
                        }
                    }
                    checked.add(ind);
                }
            }

            const avgGroupSize = numInGroups > 0 ? (totalGroupSize / numInGroups).toFixed(1) : 0;

            document.getElementById('avgGroupSize').textContent = avgGroupSize;
            document.getElementById('numGroups').textContent = numGroups;
            document.getElementById('solitary').textContent = solitary;
            document.getElementById('survivalRate').textContent = 
                totalBorn > 0 ? ((aliveCount / totalBorn) * 100).toFixed(1) + '%' : '100%';
            document.getElementById('avgFitness').textContent = avgFitness.toFixed(2);
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('popCount').addEventListener('input', (e) => {
            params.popCount = parseInt(e.target.value);
            document.getElementById('popCountValue').textContent = params.popCount;
        });

        document.getElementById('predation').addEventListener('input', (e) => {
            params.predation = parseFloat(e.target.value);
            document.getElementById('predationValue').textContent = params.predation.toFixed(2);
        });

        document.getElementById('competition').addEventListener('input', (e) => {
            params.competition = parseFloat(e.target.value);
            document.getElementById('competitionValue').textContent = params.competition.toFixed(2);
        });

        document.getElementById('info').addEventListener('input', (e) => {
            params.infoBenefit = parseFloat(e.target.value);
            document.getElementById('infoValue').textContent = params.infoBenefit.toFixed(2);
        });

        document.getElementById('disease').addEventListener('input', (e) => {
            params.disease = parseFloat(e.target.value);
            document.getElementById('diseaseValue').textContent = params.disease.toFixed(2);
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('addPredator').addEventListener('click', () => {
            predators.push(createPredator());
        });

        window.addEventListener('resize', () => { resize(); init(); });

        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => modal.classList.add('active'));
        modal.querySelector('.modal-close').addEventListener('click', () => modal.classList.remove('active'));
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('active'); });

        init();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
