<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Population Two Region - NetLogo Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            min-height: 100vh;
            display: flex;
            color: #e0e0e0;
        }
        .sidebar {
            width: 340px;
            background: rgba(20, 20, 35, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }
        h1 {
            font-size: 1.4rem;
            margin-bottom: 8px;
            color: #66bb6a;
        }
        .subtitle {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 3px;
        }
        .buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            color: #fff;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid #444;
        }
        button:hover { transform: translateY(-2px); }
        .region-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .region-panel h3 {
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        .region-panel.a h3 { color: #64b5f6; }
        .region-panel.b h3 { color: #ffb74d; }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.8rem;
        }
        .stat-label { color: #888; }
        .stat-value {
            color: #66bb6a;
            font-weight: bold;
        }
        canvas {
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #66bb6a;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .back-link:hover { opacity: 1; }
        .explanation {
            background: rgba(102, 187, 106, 0.1);
            border: 1px solid rgba(102, 187, 106, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.8rem;
            line-height: 1.5;
        }
        .graph-container {
            margin-top: 15px;
            width: 100%;
        }
        .graph-title {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h1>Population Two Region</h1>
        <p class="subtitle">Two regions with different carrying capacities and birth/death rates. Migration flows based on relative prosperity.</p>

        <div class="explanation">
            <strong>Migration Dynamics:</strong> People migrate from less prosperous regions to more prosperous ones. Prosperity is determined by population density relative to carrying capacity.
        </div>

        <div class="buttons">
            <button class="btn-primary" id="startBtn">Start</button>
            <button class="btn-secondary" id="resetBtn">Reset</button>
            <button class="btn-secondary" id="shockBtn">Economic Shock</button>
        </div>

        <div class="region-panel a">
            <h3>Region A (Blue)</h3>
            <div class="control-group">
                <label>Birth Rate: <span id="birthAVal">0.03</span></label>
                <input type="range" id="birthRateA" min="0" max="0.1" step="0.005" value="0.03">
            </div>
            <div class="control-group">
                <label>Death Rate: <span id="deathAVal">0.01</span></label>
                <input type="range" id="deathRateA" min="0" max="0.1" step="0.005" value="0.01">
            </div>
            <div class="control-group">
                <label>Carrying Capacity: <span id="carryAVal">500</span></label>
                <input type="range" id="carryingCapA" min="100" max="1000" step="50" value="500">
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="popAStat">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Density</span>
                <span class="stat-value" id="densityAStat">-</span>
            </div>
        </div>

        <div class="region-panel b">
            <h3>Region B (Orange)</h3>
            <div class="control-group">
                <label>Birth Rate: <span id="birthBVal">0.02</span></label>
                <input type="range" id="birthRateB" min="0" max="0.1" step="0.005" value="0.02">
            </div>
            <div class="control-group">
                <label>Death Rate: <span id="deathBVal">0.015</span></label>
                <input type="range" id="deathRateB" min="0" max="0.1" step="0.005" value="0.015">
            </div>
            <div class="control-group">
                <label>Carrying Capacity: <span id="carryBVal">400</span></label>
                <input type="range" id="carryingCapB" min="100" max="1000" step="50" value="400">
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="popBStat">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Density</span>
                <span class="stat-value" id="densityBStat">-</span>
            </div>
        </div>

        <div class="control-group">
            <label>Migration Rate: <span id="migrationVal">0.05</span></label>
            <input type="range" id="migrationRate" min="0" max="0.2" step="0.01" value="0.05">
        </div>

        <div class="stat-row">
            <span class="stat-label">Net Migration A→B</span>
            <span class="stat-value" id="netMigrationStat">-</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Population</span>
            <span class="stat-value" id="totalPopStat">-</span>
        </div>

        <div class="graph-container">
            <div class="graph-title">Population Over Time</div>
            <canvas id="graphCanvas" width="300" height="180"></canvas>
        </div>
    </div>

    <div class="main">
        <a href="index.html" class="back-link">← Back to Gallery</a>
        <canvas id="simCanvas" width="800" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        let running = false;
        let tick = 0;

        // Region state
        let regionA = { population: 200, people: [] };
        let regionB = { population: 150, people: [] };

        // History for graphs
        let historyA = [];
        let historyB = [];
        let migrationHistory = [];
        let lastMigration = 0;

        const regionABounds = { x: 50, y: 80, width: 340, height: 440 };
        const regionBBounds = { x: 410, y: 80, width: 340, height: 440 };

        class Person {
            constructor(x, y, region) {
                this.x = x;
                this.y = y;
                this.region = region;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.age = Math.random() * 50 + 10;
                this.migrating = false;
                this.targetX = x;
                this.targetY = y;
            }

            update() {
                const bounds = this.region === 'A' ? regionABounds : regionBBounds;

                if (this.migrating) {
                    // Move toward target
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 5) {
                        this.migrating = false;
                        this.region = this.region === 'A' ? 'B' : 'A';
                    } else {
                        this.x += dx * 0.05;
                        this.y += dy * 0.05;
                    }
                } else {
                    // Random walk within region
                    this.vx += (Math.random() - 0.5) * 0.5;
                    this.vy += (Math.random() - 0.5) * 0.5;

                    this.vx *= 0.95;
                    this.vy *= 0.95;

                    this.x += this.vx;
                    this.y += this.vy;

                    // Keep in bounds
                    if (this.x < bounds.x + 10) { this.x = bounds.x + 10; this.vx = Math.abs(this.vx); }
                    if (this.x > bounds.x + bounds.width - 10) { this.x = bounds.x + bounds.width - 10; this.vx = -Math.abs(this.vx); }
                    if (this.y < bounds.y + 10) { this.y = bounds.y + 10; this.vy = Math.abs(this.vy); }
                    if (this.y > bounds.y + bounds.height - 10) { this.y = bounds.y + bounds.height - 10; this.vy = -Math.abs(this.vy); }
                }

                this.age += 0.02;
            }

            draw() {
                const color = this.region === 'A' ? '#64b5f6' : '#ffb74d';
                const alpha = this.migrating ? 0.5 : 1;

                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function initSimulation() {
            regionA.people = [];
            regionB.people = [];

            const initPopA = 200;
            const initPopB = 150;

            for (let i = 0; i < initPopA; i++) {
                const x = regionABounds.x + 20 + Math.random() * (regionABounds.width - 40);
                const y = regionABounds.y + 20 + Math.random() * (regionABounds.height - 40);
                regionA.people.push(new Person(x, y, 'A'));
            }

            for (let i = 0; i < initPopB; i++) {
                const x = regionBBounds.x + 20 + Math.random() * (regionBBounds.width - 40);
                const y = regionBBounds.y + 20 + Math.random() * (regionBBounds.height - 40);
                regionB.people.push(new Person(x, y, 'B'));
            }

            tick = 0;
            historyA = [];
            historyB = [];
            migrationHistory = [];
        }

        function getProsperity(population, carryingCapacity) {
            // Higher when population is below carrying capacity
            return Math.max(0, 1 - population / carryingCapacity);
        }

        function simulateStep() {
            const birthRateA = parseFloat(document.getElementById('birthRateA').value);
            const deathRateA = parseFloat(document.getElementById('deathRateA').value);
            const carryA = parseFloat(document.getElementById('carryingCapA').value);

            const birthRateB = parseFloat(document.getElementById('birthRateB').value);
            const deathRateB = parseFloat(document.getElementById('deathRateB').value);
            const carryB = parseFloat(document.getElementById('carryingCapB').value);

            const migrationRate = parseFloat(document.getElementById('migrationRate').value);

            const popA = regionA.people.filter(p => p.region === 'A').length;
            const popB = regionB.people.filter(p => p.region === 'B').length;

            // Births (logistic growth)
            const effectiveBirthA = birthRateA * (1 - popA / carryA);
            const effectiveBirthB = birthRateB * (1 - popB / carryB);

            const birthsA = Math.floor(popA * Math.max(0, effectiveBirthA));
            const birthsB = Math.floor(popB * Math.max(0, effectiveBirthB));

            for (let i = 0; i < birthsA; i++) {
                const parent = regionA.people.find(p => p.region === 'A');
                if (parent) {
                    const x = parent.x + (Math.random() - 0.5) * 20;
                    const y = parent.y + (Math.random() - 0.5) * 20;
                    const p = new Person(x, y, 'A');
                    p.age = 0;
                    regionA.people.push(p);
                }
            }

            for (let i = 0; i < birthsB; i++) {
                const parent = regionB.people.find(p => p.region === 'B');
                if (parent) {
                    const x = parent.x + (Math.random() - 0.5) * 20;
                    const y = parent.y + (Math.random() - 0.5) * 20;
                    const p = new Person(x, y, 'B');
                    p.age = 0;
                    regionB.people.push(p);
                }
            }

            // Deaths
            const deathsA = Math.floor(popA * deathRateA);
            const deathsB = Math.floor(popB * deathRateB);

            // Remove oldest/random
            for (let i = 0; i < deathsA; i++) {
                const candidates = regionA.people.filter(p => p.region === 'A' && !p.migrating);
                if (candidates.length > 0) {
                    // Prefer older
                    candidates.sort((a, b) => b.age - a.age);
                    const toRemove = candidates[0];
                    regionA.people = regionA.people.filter(p => p !== toRemove);
                }
            }

            for (let i = 0; i < deathsB; i++) {
                const candidates = regionB.people.filter(p => p.region === 'B' && !p.migrating);
                if (candidates.length > 0) {
                    candidates.sort((a, b) => b.age - a.age);
                    const toRemove = candidates[0];
                    regionB.people = regionB.people.filter(p => p !== toRemove);
                }
            }

            // Migration based on prosperity difference
            const prosperityA = getProsperity(popA, carryA);
            const prosperityB = getProsperity(popB, carryB);

            let netMigration = 0;

            // A to B migration
            if (prosperityB > prosperityA) {
                const migrationProbA = migrationRate * (prosperityB - prosperityA);
                const candidatesA = regionA.people.filter(p => p.region === 'A' && !p.migrating);
                candidatesA.forEach(p => {
                    if (Math.random() < migrationProbA) {
                        p.migrating = true;
                        p.targetX = regionBBounds.x + 20 + Math.random() * (regionBBounds.width - 40);
                        p.targetY = regionBBounds.y + 20 + Math.random() * (regionBBounds.height - 40);
                        netMigration++;
                        // Move to B's array
                        regionA.people = regionA.people.filter(pp => pp !== p);
                        regionB.people.push(p);
                    }
                });
            }

            // B to A migration
            if (prosperityA > prosperityB) {
                const migrationProbB = migrationRate * (prosperityA - prosperityB);
                const candidatesB = regionB.people.filter(p => p.region === 'B' && !p.migrating);
                candidatesB.forEach(p => {
                    if (Math.random() < migrationProbB) {
                        p.migrating = true;
                        p.targetX = regionABounds.x + 20 + Math.random() * (regionABounds.width - 40);
                        p.targetY = regionABounds.y + 20 + Math.random() * (regionABounds.height - 40);
                        netMigration--;
                        // Move to A's array
                        regionB.people = regionB.people.filter(pp => pp !== p);
                        regionA.people.push(p);
                    }
                });
            }

            lastMigration = netMigration;

            // Update all people
            regionA.people.forEach(p => p.update());
            regionB.people.forEach(p => p.update());

            tick++;

            // Record history
            if (tick % 5 === 0) {
                const finalPopA = regionA.people.filter(p => p.region === 'A').length;
                const finalPopB = regionB.people.filter(p => p.region === 'B').length;
                historyA.push(finalPopA);
                historyB.push(finalPopB);
                migrationHistory.push(netMigration);
                if (historyA.length > 100) {
                    historyA.shift();
                    historyB.shift();
                    migrationHistory.shift();
                }
            }
        }

        function updateStats() {
            const popA = regionA.people.filter(p => p.region === 'A').length;
            const popB = regionB.people.filter(p => p.region === 'B').length;
            const carryA = parseFloat(document.getElementById('carryingCapA').value);
            const carryB = parseFloat(document.getElementById('carryingCapB').value);

            document.getElementById('popAStat').textContent = popA;
            document.getElementById('popBStat').textContent = popB;
            document.getElementById('densityAStat').textContent = (popA / carryA * 100).toFixed(0) + '%';
            document.getElementById('densityBStat').textContent = (popB / carryB * 100).toFixed(0) + '%';
            document.getElementById('netMigrationStat').textContent = lastMigration > 0 ? `+${lastMigration}` : lastMigration;
            document.getElementById('totalPopStat').textContent = popA + popB;
        }

        function drawRegions() {
            const carryA = parseFloat(document.getElementById('carryingCapA').value);
            const carryB = parseFloat(document.getElementById('carryingCapB').value);
            const popA = regionA.people.filter(p => p.region === 'A').length;
            const popB = regionB.people.filter(p => p.region === 'B').length;

            // Region A
            const prosperityA = getProsperity(popA, carryA);
            ctx.fillStyle = `rgba(100, 181, 246, ${0.1 + prosperityA * 0.2})`;
            ctx.fillRect(regionABounds.x, regionABounds.y, regionABounds.width, regionABounds.height);
            ctx.strokeStyle = '#64b5f6';
            ctx.lineWidth = 2;
            ctx.strokeRect(regionABounds.x, regionABounds.y, regionABounds.width, regionABounds.height);

            // Region B
            const prosperityB = getProsperity(popB, carryB);
            ctx.fillStyle = `rgba(255, 183, 77, ${0.1 + prosperityB * 0.2})`;
            ctx.fillRect(regionBBounds.x, regionBBounds.y, regionBBounds.width, regionBBounds.height);
            ctx.strokeStyle = '#ffb74d';
            ctx.lineWidth = 2;
            ctx.strokeRect(regionBBounds.x, regionBBounds.y, regionBBounds.width, regionBBounds.height);

            // Labels
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';

            ctx.fillStyle = '#64b5f6';
            ctx.fillText('Region A', regionABounds.x + regionABounds.width / 2, regionABounds.y - 10);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#888';
            ctx.fillText(`Pop: ${popA} / ${carryA}`, regionABounds.x + regionABounds.width / 2, regionABounds.y + regionABounds.height + 20);
            ctx.fillText(`Prosperity: ${(prosperityA * 100).toFixed(0)}%`, regionABounds.x + regionABounds.width / 2, regionABounds.y + regionABounds.height + 40);

            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ffb74d';
            ctx.fillText('Region B', regionBBounds.x + regionBBounds.width / 2, regionBBounds.y - 10);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#888';
            ctx.fillText(`Pop: ${popB} / ${carryB}`, regionBBounds.x + regionBBounds.width / 2, regionBBounds.y + regionBBounds.height + 20);
            ctx.fillText(`Prosperity: ${(prosperityB * 100).toFixed(0)}%`, regionBBounds.x + regionBBounds.width / 2, regionBBounds.y + regionBBounds.height + 40);

            // Migration arrow
            const arrowY = regionABounds.y + regionABounds.height / 2;
            const arrowStartX = regionABounds.x + regionABounds.width + 5;
            const arrowEndX = regionBBounds.x - 5;
            const arrowMidX = (arrowStartX + arrowEndX) / 2;

            if (prosperityB > prosperityA) {
                // Arrow A -> B
                ctx.strokeStyle = 'rgba(102, 187, 106, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(arrowStartX, arrowY);
                ctx.lineTo(arrowEndX, arrowY);
                ctx.lineTo(arrowEndX - 10, arrowY - 8);
                ctx.moveTo(arrowEndX, arrowY);
                ctx.lineTo(arrowEndX - 10, arrowY + 8);
                ctx.stroke();
            } else if (prosperityA > prosperityB) {
                // Arrow B -> A
                ctx.strokeStyle = 'rgba(102, 187, 106, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(arrowEndX, arrowY);
                ctx.lineTo(arrowStartX, arrowY);
                ctx.lineTo(arrowStartX + 10, arrowY - 8);
                ctx.moveTo(arrowStartX, arrowY);
                ctx.lineTo(arrowStartX + 10, arrowY + 8);
                ctx.stroke();
            }
        }

        function drawGraph() {
            graphCtx.fillStyle = 'rgba(0,0,0,0.3)';
            graphCtx.fillRect(0, 0, 300, 180);

            const margin = 30;
            const width = 300 - margin * 2;
            const height = 180 - margin * 2;

            // Axes
            graphCtx.strokeStyle = '#666';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(margin, margin);
            graphCtx.lineTo(margin, margin + height);
            graphCtx.lineTo(margin + width, margin + height);
            graphCtx.stroke();

            if (historyA.length < 2) return;

            const maxPop = Math.max(...historyA, ...historyB, 100);

            // Draw Region A
            graphCtx.strokeStyle = '#64b5f6';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            for (let i = 0; i < historyA.length; i++) {
                const x = margin + (i / historyA.length) * width;
                const y = margin + height - (historyA[i] / maxPop) * height;
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Draw Region B
            graphCtx.strokeStyle = '#ffb74d';
            graphCtx.beginPath();
            for (let i = 0; i < historyB.length; i++) {
                const x = margin + (i / historyB.length) * width;
                const y = margin + height - (historyB[i] / maxPop) * height;
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Legend
            graphCtx.fillStyle = '#64b5f6';
            graphCtx.fillRect(margin, 5, 15, 10);
            graphCtx.fillStyle = '#888';
            graphCtx.font = '10px Arial';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('A', margin + 20, 14);

            graphCtx.fillStyle = '#ffb74d';
            graphCtx.fillRect(margin + 40, 5, 15, 10);
            graphCtx.fillStyle = '#888';
            graphCtx.fillText('B', margin + 60, 14);
        }

        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawRegions();

            // Draw people
            regionA.people.forEach(p => p.draw());
            regionB.people.forEach(p => p.draw());

            // Title
            ctx.fillStyle = '#66bb6a';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Two-Region Population Dynamics with Migration', canvas.width / 2, 40);

            ctx.fillStyle = '#888';
            ctx.font = '14px Arial';
            ctx.fillText('People migrate toward more prosperous regions', canvas.width / 2, 60);
        }

        function update() {
            if (running) {
                simulateStep();
            }

            updateStats();
            draw();
            drawGraph();
            requestAnimationFrame(update);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        document.getElementById('shockBtn').addEventListener('click', () => {
            // Economic shock - halve carrying capacity of region B temporarily
            const carryB = document.getElementById('carryingCapB');
            const originalValue = parseInt(carryB.value);
            carryB.value = Math.floor(originalValue / 2);
            document.getElementById('carryBVal').textContent = carryB.value;

            // Restore after 5 seconds
            setTimeout(() => {
                carryB.value = originalValue;
                document.getElementById('carryBVal').textContent = originalValue;
            }, 5000);
        });

        // Input event listeners
        ['birthRateA', 'deathRateA', 'carryingCapA', 'birthRateB', 'deathRateB', 'carryingCapB', 'migrationRate'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                const valId = id.replace('Rate', '').replace('carrying', 'carry').replace('Cap', '') + 'Val';
                document.getElementById(valId).textContent = e.target.value;
            });
        });

        // Initialize
        initSimulation();
        update();
    </script>
</body>
</html>
