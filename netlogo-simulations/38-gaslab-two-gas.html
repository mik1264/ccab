<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GasLab Two Gas - Mixture Diffusion</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
            display: flex;
        }
        .sidebar {
            width: 300px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            overflow-y: auto;
        }
        .main-content { flex: 1; display: flex; flex-direction: column; padding: 20px; }
        h1 { font-size: 1.4rem; margin-bottom: 10px; color: #a78bfa; }
        .description { font-size: 0.85rem; color: #aaa; margin-bottom: 20px; line-height: 1.5; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { font-size: 0.75rem; color: #a78bfa; }
        .buttons { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; font-size: 0.85rem; }
        .btn-primary { background: #a78bfa; color: #1a1a2e; }
        .btn-secondary { background: #374151; color: #e8e8e8; }
        button:hover { opacity: 0.8; }
        .stats { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; }
        .stat-label { color: #888; }
        .stat-value { font-weight: bold; font-family: monospace; }
        .gas-legend { display: flex; gap: 20px; margin-bottom: 15px; }
        .gas-item { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; }
        .gas-dot { width: 12px; height: 12px; border-radius: 50%; }
        .canvas-container { flex: 1; display: flex; gap: 20px; min-height: 0; }
        canvas { border-radius: 8px; background: #0a0a0a; }
        #simCanvas { flex: 2; }
        .charts { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .chart-container { flex: 1; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; }
        .chart-title { font-size: 0.75rem; color: #888; margin-bottom: 5px; }
        .back-link { display: inline-block; color: #a78bfa; text-decoration: none; margin-bottom: 15px; font-size: 0.85rem; }
        .back-link:hover { text-decoration: underline; }
        .divider-indicator { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; text-align: center; font-size: 0.8rem; margin-bottom: 15px; }
    </style>
</head>
<body>
    <div class="sidebar">
        <a href="index.html" class="back-link">← Back to Gallery</a>
        <h1>GasLab Two Gas</h1>
        <p class="description">
            Two gas species with different molecular masses diffuse and mix.
            Heavy molecules (blue) move slower; light molecules (red) move faster.
            Demonstrates Graham's Law: rate ∝ 1/√(mass).
        </p>

        <div class="gas-legend">
            <div class="gas-item">
                <div class="gas-dot" style="background: #3b82f6;"></div>
                <span>Heavy (N₂-like)</span>
            </div>
            <div class="gas-item">
                <div class="gas-dot" style="background: #ef4444;"></div>
                <span>Light (He-like)</span>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" id="startBtn">Start</button>
            <button class="btn-secondary" id="resetBtn">Reset</button>
            <button class="btn-secondary" id="removeDividerBtn">Remove Divider</button>
        </div>

        <div class="divider-indicator" id="dividerStatus">
            Divider: <strong>Present</strong>
        </div>

        <div class="control-group">
            <label>Heavy Gas Count: <span class="value" id="heavyCountValue">50</span></label>
            <input type="range" id="heavyCount" min="10" max="100" value="50">
        </div>

        <div class="control-group">
            <label>Light Gas Count: <span class="value" id="lightCountValue">50</span></label>
            <input type="range" id="lightCount" min="10" max="100" value="50">
        </div>

        <div class="control-group">
            <label>Heavy Mass (amu): <span class="value" id="heavyMassValue">28</span></label>
            <input type="range" id="heavyMass" min="20" max="100" value="28">
        </div>

        <div class="control-group">
            <label>Light Mass (amu): <span class="value" id="lightMassValue">4</span></label>
            <input type="range" id="lightMass" min="1" max="20" value="4">
        </div>

        <div class="control-group">
            <label>Temperature: <span class="value" id="tempValue">300 K</span></label>
            <input type="range" id="temp" min="100" max="600" value="300">
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Heavy in Left:</span>
                <span class="stat-value" style="color: #3b82f6;" id="heavyLeft">50</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Heavy in Right:</span>
                <span class="stat-value" style="color: #3b82f6;" id="heavyRight">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Light in Left:</span>
                <span class="stat-value" style="color: #ef4444;" id="lightLeft">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Light in Right:</span>
                <span class="stat-value" style="color: #ef4444;" id="lightRight">50</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Mixing Index:</span>
                <span class="stat-value" id="mixingIndex">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Effusion Ratio:</span>
                <span class="stat-value" id="effusionRatio">--</span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
            <div class="charts">
                <div class="chart-container">
                    <div class="chart-title">Distribution Over Time</div>
                    <canvas id="distChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Velocity Distribution</div>
                    <canvas id="velChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const simCanvas = document.getElementById('simCanvas');
        const simCtx = simCanvas.getContext('2d');
        const distCanvas = document.getElementById('distChart');
        const distCtx = distCanvas.getContext('2d');
        const velCanvas = document.getElementById('velChart');
        const velCtx = velCanvas.getContext('2d');

        let particles = [];
        let running = false;
        let hasDivider = true;

        let params = {
            heavyCount: 50,
            lightCount: 50,
            heavyMass: 28,
            lightMass: 4,
            temp: 300
        };

        let history = { heavyLeft: [], heavyRight: [], lightLeft: [], lightRight: [] };
        const MAX_HISTORY = 200;
        let effusionCounts = { heavy: 0, light: 0 };

        function init() {
            resizeCanvases();
            setupControls();
            reset();
            animate();
        }

        function resizeCanvases() {
            const container = simCanvas.parentElement;
            const size = Math.min(container.clientWidth * 0.6, container.clientHeight - 40);
            simCanvas.width = size;
            simCanvas.height = size * 0.7;

            document.querySelectorAll('.chart-container').forEach((c, i) => {
                const canvas = i === 0 ? distCanvas : velCanvas;
                canvas.width = c.clientWidth - 20;
                canvas.height = c.clientHeight - 40;
            });
        }

        function setupControls() {
            document.getElementById('startBtn').onclick = () => {
                running = !running;
                document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            };
            document.getElementById('resetBtn').onclick = reset;
            document.getElementById('removeDividerBtn').onclick = () => {
                hasDivider = false;
                document.getElementById('dividerStatus').innerHTML = 'Divider: <strong style="color:#22c55e">Removed</strong>';
                effusionCounts = { heavy: 0, light: 0 };
            };

            ['heavyCount', 'lightCount', 'heavyMass', 'lightMass', 'temp'].forEach(id => {
                document.getElementById(id).oninput = (e) => {
                    params[id] = parseFloat(e.target.value);
                    const suffix = id === 'temp' ? ' K' : (id.includes('Mass') ? '' : '');
                    document.getElementById(id + 'Value').textContent = params[id] + suffix;
                };
            });

            window.addEventListener('resize', resizeCanvases);
        }

        function reset() {
            running = false;
            hasDivider = true;
            document.getElementById('startBtn').textContent = 'Start';
            document.getElementById('dividerStatus').innerHTML = 'Divider: <strong>Present</strong>';
            history = { heavyLeft: [], heavyRight: [], lightLeft: [], lightRight: [] };
            effusionCounts = { heavy: 0, light: 0 };
            createParticles();
            draw();
        }

        function createParticles() {
            particles = [];
            const w = simCanvas.width, h = simCanvas.height;
            const midX = w / 2;

            // Heavy gas on left side
            for (let i = 0; i < params.heavyCount; i++) {
                const speed = getSpeed(params.heavyMass, params.temp);
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: 20 + Math.random() * (midX - 40),
                    y: 20 + Math.random() * (h - 40),
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    mass: params.heavyMass,
                    type: 'heavy',
                    radius: 5
                });
            }

            // Light gas on right side
            for (let i = 0; i < params.lightCount; i++) {
                const speed = getSpeed(params.lightMass, params.temp);
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: midX + 20 + Math.random() * (midX - 40),
                    y: 20 + Math.random() * (h - 40),
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    mass: params.lightMass,
                    type: 'light',
                    radius: 4
                });
            }
        }

        function getSpeed(mass, temp) {
            // Maxwell-Boltzmann: v_rms ∝ sqrt(T/m)
            return Math.sqrt(temp / mass) * 0.5;
        }

        function update() {
            const w = simCanvas.width, h = simCanvas.height;
            const midX = w / 2;
            const gapY = h / 2;
            const gapSize = 30;

            particles.forEach(p => {
                const prevX = p.x;
                p.x += p.vx;
                p.y += p.vy;

                // Wall collisions
                if (p.x - p.radius < 10) { p.x = 10 + p.radius; p.vx *= -1; }
                if (p.x + p.radius > w - 10) { p.x = w - 10 - p.radius; p.vx *= -1; }
                if (p.y - p.radius < 10) { p.y = 10 + p.radius; p.vy *= -1; }
                if (p.y + p.radius > h - 10) { p.y = h - 10 - p.radius; p.vy *= -1; }

                // Divider collision (with gap)
                if (hasDivider) {
                    const inGap = p.y > gapY - gapSize/2 && p.y < gapY + gapSize/2;
                    if (!inGap) {
                        if (prevX < midX && p.x >= midX - p.radius) {
                            p.x = midX - p.radius;
                            p.vx *= -1;
                        } else if (prevX > midX && p.x <= midX + p.radius) {
                            p.x = midX + p.radius;
                            p.vx *= -1;
                        }
                    } else {
                        // Track effusion through gap
                        if (prevX < midX && p.x >= midX) {
                            effusionCounts[p.type]++;
                        }
                    }
                }
            });

            // Particle-particle collisions
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    collide(particles[i], particles[j]);
                }
            }

            // Record history
            const counts = countParticles();
            history.heavyLeft.push(counts.heavyLeft);
            history.heavyRight.push(counts.heavyRight);
            history.lightLeft.push(counts.lightLeft);
            history.lightRight.push(counts.lightRight);

            if (history.heavyLeft.length > MAX_HISTORY) {
                Object.keys(history).forEach(k => history[k].shift());
            }

            updateStats(counts);
        }

        function collide(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = p1.radius + p2.radius;

            if (dist < minDist && dist > 0) {
                // Elastic collision
                const nx = dx / dist;
                const ny = dy / dist;
                const dvx = p1.vx - p2.vx;
                const dvy = p1.vy - p2.vy;
                const dvn = dvx * nx + dvy * ny;

                if (dvn > 0) {
                    const m1 = p1.mass, m2 = p2.mass;
                    const factor = 2 * dvn / (m1 + m2);

                    p1.vx -= factor * m2 * nx;
                    p1.vy -= factor * m2 * ny;
                    p2.vx += factor * m1 * nx;
                    p2.vy += factor * m1 * ny;

                    // Separate particles
                    const overlap = minDist - dist;
                    p1.x -= overlap * 0.5 * nx;
                    p1.y -= overlap * 0.5 * ny;
                    p2.x += overlap * 0.5 * nx;
                    p2.y += overlap * 0.5 * ny;
                }
            }
        }

        function countParticles() {
            const midX = simCanvas.width / 2;
            let heavyLeft = 0, heavyRight = 0, lightLeft = 0, lightRight = 0;

            particles.forEach(p => {
                if (p.type === 'heavy') {
                    if (p.x < midX) heavyLeft++; else heavyRight++;
                } else {
                    if (p.x < midX) lightLeft++; else lightRight++;
                }
            });

            return { heavyLeft, heavyRight, lightLeft, lightRight };
        }

        function updateStats(counts) {
            document.getElementById('heavyLeft').textContent = counts.heavyLeft;
            document.getElementById('heavyRight').textContent = counts.heavyRight;
            document.getElementById('lightLeft').textContent = counts.lightLeft;
            document.getElementById('lightRight').textContent = counts.lightRight;

            // Mixing index (0 = separated, 100 = fully mixed)
            const totalHeavy = counts.heavyLeft + counts.heavyRight;
            const totalLight = counts.lightLeft + counts.lightRight;
            const idealHeavyEach = totalHeavy / 2;
            const idealLightEach = totalLight / 2;

            const heavyDeviation = Math.abs(counts.heavyLeft - idealHeavyEach) / totalHeavy;
            const lightDeviation = Math.abs(counts.lightLeft - idealLightEach) / totalLight;
            const mixingIndex = Math.round((1 - (heavyDeviation + lightDeviation) / 2) * 100);

            document.getElementById('mixingIndex').textContent = mixingIndex + '%';

            // Effusion ratio (Graham's Law prediction: sqrt(m2/m1))
            if (effusionCounts.heavy > 0 && effusionCounts.light > 0) {
                const actualRatio = effusionCounts.light / effusionCounts.heavy;
                const theoreticalRatio = Math.sqrt(params.heavyMass / params.lightMass);
                document.getElementById('effusionRatio').textContent =
                    `${actualRatio.toFixed(2)} (theory: ${theoreticalRatio.toFixed(2)})`;
            }
        }

        function draw() {
            drawSimulation();
            drawDistChart();
            drawVelChart();
        }

        function drawSimulation() {
            const w = simCanvas.width, h = simCanvas.height;
            simCtx.fillStyle = '#0a0a0a';
            simCtx.fillRect(0, 0, w, h);

            // Chamber
            simCtx.strokeStyle = '#4b5563';
            simCtx.lineWidth = 3;
            simCtx.strokeRect(10, 10, w - 20, h - 20);

            // Divider with gap
            if (hasDivider) {
                const midX = w / 2;
                const gapY = h / 2;
                const gapSize = 30;

                simCtx.strokeStyle = '#6b7280';
                simCtx.lineWidth = 4;
                simCtx.beginPath();
                simCtx.moveTo(midX, 10);
                simCtx.lineTo(midX, gapY - gapSize/2);
                simCtx.moveTo(midX, gapY + gapSize/2);
                simCtx.lineTo(midX, h - 10);
                simCtx.stroke();

                // Gap indicator
                simCtx.fillStyle = 'rgba(167, 139, 250, 0.3)';
                simCtx.fillRect(midX - 5, gapY - gapSize/2, 10, gapSize);
            }

            // Particles
            particles.forEach(p => {
                simCtx.fillStyle = p.type === 'heavy' ? '#3b82f6' : '#ef4444';
                simCtx.beginPath();
                simCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                simCtx.fill();
            });

            // Labels
            simCtx.fillStyle = '#666';
            simCtx.font = '11px sans-serif';
            simCtx.fillText('Heavy (N₂)', 15, 25);
            simCtx.fillText('Light (He)', w - 70, 25);
        }

        function drawDistChart() {
            const w = distCanvas.width, h = distCanvas.height;
            distCtx.fillStyle = 'rgba(0,0,0,0.3)';
            distCtx.fillRect(0, 0, w, h);

            if (history.heavyLeft.length < 2) return;

            const maxCount = Math.max(params.heavyCount, params.lightCount);

            // Heavy left (solid blue)
            distCtx.strokeStyle = '#3b82f6';
            distCtx.lineWidth = 2;
            distCtx.beginPath();
            history.heavyLeft.forEach((v, i) => {
                const x = (i / MAX_HISTORY) * w;
                const y = h - (v / maxCount) * h;
                if (i === 0) distCtx.moveTo(x, y); else distCtx.lineTo(x, y);
            });
            distCtx.stroke();

            // Heavy right (dashed blue)
            distCtx.setLineDash([5, 5]);
            distCtx.beginPath();
            history.heavyRight.forEach((v, i) => {
                const x = (i / MAX_HISTORY) * w;
                const y = h - (v / maxCount) * h;
                if (i === 0) distCtx.moveTo(x, y); else distCtx.lineTo(x, y);
            });
            distCtx.stroke();
            distCtx.setLineDash([]);

            // Light left (solid red)
            distCtx.strokeStyle = '#ef4444';
            distCtx.beginPath();
            history.lightLeft.forEach((v, i) => {
                const x = (i / MAX_HISTORY) * w;
                const y = h - (v / maxCount) * h;
                if (i === 0) distCtx.moveTo(x, y); else distCtx.lineTo(x, y);
            });
            distCtx.stroke();

            // Light right (dashed red)
            distCtx.setLineDash([5, 5]);
            distCtx.beginPath();
            history.lightRight.forEach((v, i) => {
                const x = (i / MAX_HISTORY) * w;
                const y = h - (v / maxCount) * h;
                if (i === 0) distCtx.moveTo(x, y); else distCtx.lineTo(x, y);
            });
            distCtx.stroke();
            distCtx.setLineDash([]);

            // 50% line
            distCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            distCtx.beginPath();
            distCtx.moveTo(0, h/2);
            distCtx.lineTo(w, h/2);
            distCtx.stroke();
        }

        function drawVelChart() {
            const w = velCanvas.width, h = velCanvas.height;
            velCtx.fillStyle = 'rgba(0,0,0,0.3)';
            velCtx.fillRect(0, 0, w, h);

            // Build velocity histograms
            const bins = 20;
            const maxSpeed = 15;
            const heavyHist = new Array(bins).fill(0);
            const lightHist = new Array(bins).fill(0);

            particles.forEach(p => {
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                const bin = Math.min(bins - 1, Math.floor(speed / maxSpeed * bins));
                if (p.type === 'heavy') heavyHist[bin]++;
                else lightHist[bin]++;
            });

            const maxBin = Math.max(...heavyHist, ...lightHist, 1);
            const barWidth = w / bins;

            // Heavy bars
            velCtx.fillStyle = 'rgba(59, 130, 246, 0.6)';
            heavyHist.forEach((count, i) => {
                const barHeight = (count / maxBin) * (h - 20);
                velCtx.fillRect(i * barWidth + 1, h - 10 - barHeight, barWidth/2 - 1, barHeight);
            });

            // Light bars
            velCtx.fillStyle = 'rgba(239, 68, 68, 0.6)';
            lightHist.forEach((count, i) => {
                const barHeight = (count / maxBin) * (h - 20);
                velCtx.fillRect(i * barWidth + barWidth/2, h - 10 - barHeight, barWidth/2 - 1, barHeight);
            });

            // Axis
            velCtx.strokeStyle = '#4b5563';
            velCtx.beginPath();
            velCtx.moveTo(0, h - 10);
            velCtx.lineTo(w, h - 10);
            velCtx.stroke();

            velCtx.fillStyle = '#666';
            velCtx.font = '9px sans-serif';
            velCtx.fillText('Speed →', w - 45, h - 2);
        }

        function animate() {
            if (running) update();
            draw();
            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>
