<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grain Growth - MaterialSim - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #simCanvas { flex: 2; }
        #graphCanvas { flex: 1; border-top: 1px solid #333; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #94a3b8; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #64748b; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #475569; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #94a3b8; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Grain Growth</h1>
            <p class="description">Monte Carlo Potts model simulating metallurgical grain growth. Watch grains coarsen as the system minimizes boundary energy.</p>
            
            <div class="control-group">
                <label>Temperature: <span id="tempVal">0.5</span></label>
                <input type="range" id="temp" min="0.1" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>Initial Grain Count: <span id="grainsVal">200</span></label>
                <input type="range" id="grains" min="50" max="500" value="200">
            </div>
            <div class="control-group">
                <label>Boundary Energy: <span id="energyVal">1.0</span></label>
                <input type="range" id="energy" min="0.5" max="2" step="0.1" value="1">
            </div>
            
            <button id="reset">Reset / Nucleate</button>
            <button id="pause">Pause</button>
            <button id="anneal">Anneal (High T)</button>
            
            <div class="stats">
                <div>Monte Carlo Steps: <span id="steps">0</span></div>
                <div>Grain Count: <span id="grainCount">0</span></div>
                <div>Avg Grain Size: <span id="avgSize">0</span> px²</div>
                <div>Total Energy: <span id="totalEnergy">0</span></div>
            </div>
            
            <p class="description"><strong>Potts Model:</strong> Each site has a grain ID. Boundary sites have higher energy. System evolves to minimize total boundary length.</p>
            
            <p class="description"><strong>Coarsening:</strong> Larger grains grow at the expense of smaller ones. Average grain area increases linearly with time.</p>
        </div>
    </div>
    <script>
        const simCanvas = document.getElementById('simCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const sctx = simCanvas.getContext('2d');
        const gctx = graphCanvas.getContext('2d');
        
        let W, H, GW, GH;
        let grid = [], paused = false;
        let steps = 0;
        let history = [];
        
        const gridSize = 150;
        let grainColors = {};
        
        let params = {
            temperature: 0.5,
            initialGrains: 200,
            boundaryEnergy: 1.0
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            simCanvas.width = c.clientWidth;
            simCanvas.height = c.clientHeight * 0.65;
            graphCanvas.width = c.clientWidth;
            graphCanvas.height = c.clientHeight * 0.35;
            W = simCanvas.width;
            H = simCanvas.height;
            GW = graphCanvas.width;
            GH = graphCanvas.height;
        }
        
        function randomColor() {
            const h = Math.floor(Math.random() * 360);
            const s = 50 + Math.floor(Math.random() * 30);
            const l = 40 + Math.floor(Math.random() * 30);
            return `hsl(${h}, ${s}%, ${l}%)`;
        }
        
        function init() {
            resize();
            grid = [];
            grainColors = {};
            steps = 0;
            history = [];
            
            // Initialize with random grain seeds using Voronoi-like pattern
            const seeds = [];
            for (let i = 0; i < params.initialGrains; i++) {
                seeds.push({
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize),
                    id: i + 1
                });
                grainColors[i + 1] = randomColor();
            }
            
            // Assign each cell to nearest seed
            for (let y = 0; y < gridSize; y++) {
                const row = [];
                for (let x = 0; x < gridSize; x++) {
                    let minDist = Infinity;
                    let nearestId = 1;
                    
                    for (const seed of seeds) {
                        const dx = x - seed.x;
                        const dy = y - seed.y;
                        const dist = dx * dx + dy * dy;
                        if (dist < minDist) {
                            minDist = dist;
                            nearestId = seed.id;
                        }
                    }
                    
                    row.push(nearestId);
                }
                grid.push(row);
            }
            
            updateStats();
        }
        
        function getNeighbors(x, y) {
            const neighbors = [];
            const dirs = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [1,-1], [-1,1], [1,1]];
            for (const [dx, dy] of dirs) {
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                neighbors.push(grid[ny][nx]);
            }
            return neighbors;
        }
        
        function calculateEnergy(x, y, grainId) {
            const neighbors = getNeighbors(x, y);
            let energy = 0;
            for (const n of neighbors) {
                if (n !== grainId) {
                    energy += params.boundaryEnergy;
                }
            }
            return energy;
        }
        
        function step() {
            // Perform many Monte Carlo updates per step
            const updatesPerStep = gridSize * gridSize;
            
            for (let i = 0; i < updatesPerStep; i++) {
                // Pick random site
                const x = Math.floor(Math.random() * gridSize);
                const y = Math.floor(Math.random() * gridSize);
                
                const currentId = grid[y][x];
                const neighbors = getNeighbors(x, y);
                
                // Pick random neighbor's grain ID as candidate
                const candidateId = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                if (candidateId === currentId) continue;
                
                // Calculate energy change
                const currentEnergy = calculateEnergy(x, y, currentId);
                const newEnergy = calculateEnergy(x, y, candidateId);
                const deltaE = newEnergy - currentEnergy;
                
                // Metropolis criterion
                if (deltaE <= 0 || Math.random() < Math.exp(-deltaE / params.temperature)) {
                    grid[y][x] = candidateId;
                }
            }
            
            steps++;
            
            // Record history every 10 steps
            if (steps % 10 === 0) {
                const grains = countGrains();
                history.push({
                    step: steps,
                    grainCount: grains.count,
                    avgSize: grains.avgSize
                });
                if (history.length > 100) history.shift();
            }
            
            updateStats();
        }
        
        function countGrains() {
            const grainSizes = {};
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const id = grid[y][x];
                    grainSizes[id] = (grainSizes[id] || 0) + 1;
                }
            }
            
            const count = Object.keys(grainSizes).length;
            const totalCells = gridSize * gridSize;
            const avgSize = totalCells / count;
            
            return { count, avgSize, sizes: grainSizes };
        }
        
        function calculateTotalEnergy() {
            let energy = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const id = grid[y][x];
                    // Only count right and down to avoid double counting
                    const right = grid[y][(x + 1) % gridSize];
                    const down = grid[(y + 1) % gridSize][x];
                    if (id !== right) energy += params.boundaryEnergy;
                    if (id !== down) energy += params.boundaryEnergy;
                }
            }
            return energy;
        }
        
        function updateStats() {
            const grains = countGrains();
            const energy = calculateTotalEnergy();
            
            document.getElementById('steps').textContent = steps;
            document.getElementById('grainCount').textContent = grains.count;
            document.getElementById('avgSize').textContent = grains.avgSize.toFixed(1);
            document.getElementById('totalEnergy').textContent = energy;
        }
        
        function drawSim() {
            const cellW = W / gridSize;
            const cellH = H / gridSize;
            
            // Draw grains
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const id = grid[y][x];
                    sctx.fillStyle = grainColors[id] || '#666';
                    sctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
                }
            }
            
            // Draw grain boundaries
            sctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            sctx.lineWidth = 1;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const id = grid[y][x];
                    const right = grid[y][(x + 1) % gridSize];
                    const down = grid[(y + 1) % gridSize][x];
                    
                    if (id !== right) {
                        sctx.beginPath();
                        sctx.moveTo((x + 1) * cellW, y * cellH);
                        sctx.lineTo((x + 1) * cellW, (y + 1) * cellH);
                        sctx.stroke();
                    }
                    if (id !== down) {
                        sctx.beginPath();
                        sctx.moveTo(x * cellW, (y + 1) * cellH);
                        sctx.lineTo((x + 1) * cellW, (y + 1) * cellH);
                        sctx.stroke();
                    }
                }
            }
            
            // Info
            sctx.fillStyle = '#fff';
            sctx.font = 'bold 14px sans-serif';
            sctx.fillText(`Grain Growth - Step ${steps}`, 10, 20);
        }
        
        function drawGraph() {
            gctx.fillStyle = '#0a0f1a';
            gctx.fillRect(0, 0, GW, GH);
            
            if (history.length < 2) return;
            
            const margin = { left: 60, right: 20, top: 30, bottom: 30 };
            const graphW = GW - margin.left - margin.right;
            const graphH = GH - margin.top - margin.bottom;
            
            // Axes
            gctx.strokeStyle = '#333';
            gctx.beginPath();
            gctx.moveTo(margin.left, margin.top);
            gctx.lineTo(margin.left, GH - margin.bottom);
            gctx.lineTo(GW - margin.right, GH - margin.bottom);
            gctx.stroke();
            
            gctx.fillStyle = '#666';
            gctx.font = '11px sans-serif';
            gctx.fillText('Grain Count Over Time', margin.left, margin.top - 10);
            
            const minStep = history[0].step;
            const maxStep = history[history.length - 1].step;
            const maxCount = Math.max(...history.map(h => h.grainCount));
            
            // Grain count line
            gctx.strokeStyle = '#94a3b8';
            gctx.lineWidth = 2;
            gctx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const x = margin.left + ((history[i].step - minStep) / (maxStep - minStep)) * graphW;
                const y = GH - margin.bottom - (history[i].grainCount / maxCount) * graphH;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            }
            gctx.stroke();
            
            // Theory line: n(t) = n0 / (1 + kt) approximately linear decrease
            gctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
            gctx.setLineDash([5, 5]);
            gctx.beginPath();
            const n0 = history[0].grainCount;
            for (let i = 0; i < history.length; i++) {
                const t = history[i].step - minStep;
                const predicted = n0 / (1 + t * 0.01);
                const x = margin.left + ((history[i].step - minStep) / (maxStep - minStep)) * graphW;
                const y = GH - margin.bottom - (predicted / maxCount) * graphH;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            }
            gctx.stroke();
            gctx.setLineDash([]);
            
            // Legend
            gctx.fillStyle = '#94a3b8';
            gctx.fillText('Actual', GW - 80, margin.top + 10);
            gctx.fillStyle = '#3b82f6';
            gctx.fillText('Theory', GW - 80, margin.top + 25);
        }
        
        function draw() {
            drawSim();
            drawGraph();
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    step();
                }
            }, 50);
        }
        
        // Event listeners
        document.getElementById('temp').addEventListener('input', e => {
            params.temperature = +e.target.value;
            document.getElementById('tempVal').textContent = params.temperature.toFixed(1);
        });
        document.getElementById('grains').addEventListener('input', e => {
            params.initialGrains = +e.target.value;
            document.getElementById('grainsVal').textContent = params.initialGrains;
        });
        document.getElementById('energy').addEventListener('input', e => {
            params.boundaryEnergy = +e.target.value;
            document.getElementById('energyVal').textContent = params.boundaryEnergy.toFixed(1);
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('anneal').addEventListener('click', () => {
            params.temperature = 1.5;
            document.getElementById('temp').value = 1.5;
            document.getElementById('tempVal').textContent = '1.5';
        });
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
