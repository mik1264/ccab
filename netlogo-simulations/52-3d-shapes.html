<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shapes - NetLogo Simulations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #9b59b6, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description { text-align: center; max-width: 700px; margin-bottom: 20px; color: #aaa; line-height: 1.5; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        canvas { border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
        .controls {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 220px;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 0.85rem; color: #888; }
        input[type="range"] { width: 100%; cursor: pointer; }
        select { width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: #e0e0e0; border: none; }
        .value { font-size: 0.8rem; color: #9b59b6; }
        button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; }
        .primary { background: #9b59b6; color: white; }
        .secondary { background: rgba(255,255,255,0.1); color: #e0e0e0; }
        .stats { margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.85rem; }
        .stats div { margin: 3px 0; }
        .stat-value { color: #9b59b6; }
        a.back-link { position: fixed; top: 20px; left: 20px; color: #9b59b6; text-decoration: none; font-size: 0.9rem; opacity: 0.8; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>3D Shapes</h1>
    <p class="description">3D wireframe rendering with rotation, lighting, and perspective projection. Drag to rotate shapes.</p>
    <div class="container">
        <canvas id="canvas" width="500" height="500"></canvas>
        <div class="controls">
            <div class="control-group">
                <label>Shape:</label>
                <select id="shape">
                    <option value="cube">Cube</option>
                    <option value="tetrahedron">Tetrahedron</option>
                    <option value="octahedron">Octahedron</option>
                    <option value="icosahedron">Icosahedron</option>
                    <option value="dodecahedron">Dodecahedron</option>
                    <option value="sphere">Sphere</option>
                    <option value="torus">Torus</option>
                </select>
            </div>
            <div class="control-group">
                <label>Rotation Speed: <span id="speedVal" class="value">1</span></label>
                <input type="range" id="speed" min="0" max="5" step="0.5" value="1">
            </div>
            <div class="control-group">
                <label>Scale: <span id="scaleVal" class="value">100</span></label>
                <input type="range" id="scale" min="50" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Perspective: <span id="perspVal" class="value">500</span></label>
                <input type="range" id="perspective" min="200" max="1000" value="500">
            </div>
            <button class="primary" id="resetBtn">Reset Rotation</button>
            <button class="secondary" id="wireframeBtn">Toggle Fill</button>
            <div class="stats">
                <div>Vertices: <span id="vertices" class="stat-value">0</span></div>
                <div>Edges: <span id="edges" class="stat-value">0</span></div>
                <div>Faces: <span id="faces" class="stat-value">0</span></div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        let rotX = 0.3, rotY = 0.5, rotZ = 0;
        let autoRotate = true;
        let wireframe = true;
        let dragging = false, lastX, lastY;

        const shapes = {
            cube: {
                vertices: [[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]],
                faces: [[0,1,2,3],[4,5,6,7],[0,1,5,4],[2,3,7,6],[0,3,7,4],[1,2,6,5]]
            },
            tetrahedron: {
                vertices: [[1,1,1],[1,-1,-1],[-1,1,-1],[-1,-1,1]],
                faces: [[0,1,2],[0,1,3],[0,2,3],[1,2,3]]
            },
            octahedron: {
                vertices: [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],
                faces: [[0,2,4],[0,2,5],[0,3,4],[0,3,5],[1,2,4],[1,2,5],[1,3,4],[1,3,5]]
            },
            icosahedron: (() => {
                const phi = (1 + Math.sqrt(5)) / 2;
                return {
                    vertices: [[0,1,phi],[0,-1,phi],[0,1,-phi],[0,-1,-phi],[1,phi,0],[-1,phi,0],[1,-phi,0],[-1,-phi,0],[phi,0,1],[-phi,0,1],[phi,0,-1],[-phi,0,-1]],
                    faces: [[0,1,8],[0,1,9],[2,3,10],[2,3,11],[4,5,0],[4,5,2],[6,7,1],[6,7,3],[8,10,4],[8,10,6],[9,11,5],[9,11,7],[0,4,8],[0,5,9],[1,6,8],[1,7,9],[2,4,10],[2,5,11],[3,6,10],[3,7,11]]
                };
            })(),
            dodecahedron: (() => {
                const phi = (1 + Math.sqrt(5)) / 2;
                const a = 1/phi, b = phi;
                return {
                    vertices: [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1],[0,a,b],[0,-a,b],[0,a,-b],[0,-a,-b],[a,b,0],[-a,b,0],[a,-b,0],[-a,-b,0],[b,0,a],[b,0,-a],[-b,0,a],[-b,0,-1]],
                    faces: [[0,8,9,2,16],[0,12,4,8],[0,16,17,1,12],[1,10,5,13,12],[1,17,3,11,10],[2,9,6,15,14],[2,14,3,17,16],[3,14,15,7,11],[4,13,5,19,18],[4,18,6,9,8],[5,10,11,7,19],[6,18,19,7,15]]
                };
            })(),
            sphere: (() => {
                const vertices = [];
                const faces = [];
                const segments = 12;
                for (let i = 0; i <= segments; i++) {
                    const lat = Math.PI * i / segments - Math.PI / 2;
                    for (let j = 0; j < segments; j++) {
                        const lon = 2 * Math.PI * j / segments;
                        vertices.push([Math.cos(lat) * Math.cos(lon), Math.sin(lat), Math.cos(lat) * Math.sin(lon)]);
                    }
                }
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < segments; j++) {
                        const a = i * segments + j;
                        const b = i * segments + (j + 1) % segments;
                        const c = (i + 1) * segments + (j + 1) % segments;
                        const d = (i + 1) * segments + j;
                        faces.push([a, b, c, d]);
                    }
                }
                return { vertices, faces };
            })(),
            torus: (() => {
                const vertices = [];
                const faces = [];
                const R = 1, r = 0.4;
                const segments = 16, rings = 12;
                for (let i = 0; i < rings; i++) {
                    const u = 2 * Math.PI * i / rings;
                    for (let j = 0; j < segments; j++) {
                        const v = 2 * Math.PI * j / segments;
                        vertices.push([(R + r * Math.cos(v)) * Math.cos(u), r * Math.sin(v), (R + r * Math.cos(v)) * Math.sin(u)]);
                    }
                }
                for (let i = 0; i < rings; i++) {
                    for (let j = 0; j < segments; j++) {
                        const a = i * segments + j;
                        const b = i * segments + (j + 1) % segments;
                        const c = ((i + 1) % rings) * segments + (j + 1) % segments;
                        const d = ((i + 1) % rings) * segments + j;
                        faces.push([a, b, c, d]);
                    }
                }
                return { vertices, faces };
            })()
        };

        function rotatePoint(p, rx, ry, rz) {
            let [x, y, z] = p;
            // Rotate X
            let y1 = y * Math.cos(rx) - z * Math.sin(rx);
            let z1 = y * Math.sin(rx) + z * Math.cos(rx);
            // Rotate Y
            let x2 = x * Math.cos(ry) + z1 * Math.sin(ry);
            let z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);
            // Rotate Z
            let x3 = x2 * Math.cos(rz) - y1 * Math.sin(rz);
            let y3 = x2 * Math.sin(rz) + y1 * Math.cos(rz);
            return [x3, y3, z2];
        }

        function project(p, scale, persp) {
            const [x, y, z] = p;
            const factor = persp / (persp + z * scale);
            return [W/2 + x * scale * factor, H/2 - y * scale * factor, z];
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            const shapeName = document.getElementById('shape').value;
            const shape = shapes[shapeName];
            const scale = parseInt(document.getElementById('scale').value);
            const persp = parseInt(document.getElementById('perspective').value);
            const speed = parseFloat(document.getElementById('speed').value);

            if (autoRotate) {
                rotY += 0.01 * speed;
                rotX += 0.005 * speed;
            }

            // Transform vertices
            const transformed = shape.vertices.map(v => rotatePoint(v, rotX, rotY, rotZ));
            const projected = transformed.map(v => project(v, scale, persp));

            // Sort faces by average z for painter's algorithm
            const faceData = shape.faces.map((face, i) => {
                const avgZ = face.reduce((sum, vi) => sum + transformed[vi][2], 0) / face.length;
                return { face, avgZ, index: i };
            }).sort((a, b) => a.avgZ - b.avgZ);

            // Draw faces
            faceData.forEach(({ face, avgZ }) => {
                ctx.beginPath();
                face.forEach((vi, i) => {
                    const [x, y] = projected[vi];
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();

                if (!wireframe) {
                    const brightness = Math.floor(40 + (avgZ + 2) * 30);
                    const hue = (rotY * 30 + avgZ * 20) % 360;
                    ctx.fillStyle = `hsl(${hue}, 60%, ${brightness}%)`;
                    ctx.fill();
                }

                ctx.strokeStyle = wireframe ? `hsl(${(270 + avgZ * 30) % 360}, 70%, 60%)` : 'rgba(0,0,0,0.3)';
                ctx.lineWidth = wireframe ? 2 : 1;
                ctx.stroke();
            });

            // Update stats
            document.getElementById('vertices').textContent = shape.vertices.length;
            document.getElementById('edges').textContent = shape.faces.reduce((sum, f) => sum + f.length, 0);
            document.getElementById('faces').textContent = shape.faces.length;
            document.getElementById('speedVal').textContent = speed;
            document.getElementById('scaleVal').textContent = scale;
            document.getElementById('perspVal').textContent = persp;

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('mousedown', (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; autoRotate = false; });
        canvas.addEventListener('mouseup', () => dragging = false);
        canvas.addEventListener('mouseleave', () => dragging = false);
        canvas.addEventListener('mousemove', (e) => {
            if (dragging) {
                rotY += (e.clientX - lastX) * 0.01;
                rotX += (e.clientY - lastY) * 0.01;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => { rotX = 0.3; rotY = 0.5; rotZ = 0; autoRotate = true; });
        document.getElementById('wireframeBtn').addEventListener('click', () => { wireframe = !wireframe; });

        draw();
    </script>
</body>
</html>
