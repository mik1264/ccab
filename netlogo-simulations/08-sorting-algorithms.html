<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #a29bfe; }
        h3 { margin: 15px 0 8px 0; color: #74b9ff; font-size: 14px; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 13px; }
        input[type="range"] { width: 100%; }
        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            margin: 5px 0;
        }
        select option { background: #1a1a2e; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #a29bfe;
            color: #1a1a2e;
            font-weight: bold;
        }
        button:hover { background: #8b85e0; }
        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            font-size: 11px;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 15px; height: 15px; border-radius: 2px; }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.1); transition: all 0.3s ease;">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="canvas"></canvas>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #74b9ff;"></div> Unsorted</div>
                <div class="legend-item"><div class="legend-color" style="background: #ff7675;"></div> Comparing</div>
                <div class="legend-item"><div class="legend-color" style="background: #fdcb6e;"></div> Swapping</div>
                <div class="legend-item"><div class="legend-color" style="background: #55efc4;"></div> Sorted</div>
            </div>
        </div>
        <div class="controls">
            <h2>üìä Sorting Algorithms</h2>
            <p style="font-size: 12px; opacity: 0.8;">Visualize classic sorting algorithms</p>

            <h3>Algorithm</h3>
            <select id="algorithm">
                <option value="bubble">Bubble Sort - O(n¬≤)</option>
                <option value="selection">Selection Sort - O(n¬≤)</option>
                <option value="insertion">Insertion Sort - O(n¬≤)</option>
                <option value="quick">Quick Sort - O(n log n)</option>
                <option value="merge">Merge Sort - O(n log n)</option>
                <option value="heap">Heap Sort - O(n log n)</option>
            </select>

            <h3>Parameters</h3>
            <div class="slider-group">
                <label>Array Size: <span id="arraySizeVal">50</span></label>
                <input type="range" id="arraySize" min="10" max="200" step="10" value="50">
            </div>
            <div class="slider-group">
                <label>Speed (ms/step): <span id="speedVal">50</span></label>
                <input type="range" id="speed" min="1" max="200" step="5" value="50">
            </div>

            <button onclick="startSort()">Start Sort</button>
            <button onclick="resetArray()">New Array</button>
            <button onclick="togglePause()">Pause/Play</button>

            <div class="stats">
                <div class="stat-row"><span>Comparisons:</span><span id="comparisons">0</span></div>
                <div class="stat-row"><span>Swaps:</span><span id="swaps">0</span></div>
                <div class="stat-row"><span>Array Accesses:</span><span id="accesses">0</span></div>
                <div class="stat-row"><span>Status:</span><span id="status">Ready</span></div>
            </div>

            <div class="description" id="algoDesc">
                <strong>Bubble Sort:</strong><br>
                Repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order. The pass through the list is repeated until sorted.<br><br>
                <strong>Time:</strong> O(n¬≤) average and worst case<br>
                <strong>Space:</strong> O(1)
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 800;
        canvas.height = 400;

        let arraySize = 50;
        let speed = 50;
        let arr = [];
        let sortedIndices = new Set();
        let comparing = [];
        let swapping = [];
        let paused = false;
        let sorting = false;

        let comparisons = 0;
        let swaps = 0;
        let accesses = 0;

        const descriptions = {
            bubble: `<strong>Bubble Sort:</strong><br>
                Repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order. Simple but inefficient.<br><br>
                <strong>Time:</strong> O(n¬≤) average and worst<br>
                <strong>Space:</strong> O(1)`,
            selection: `<strong>Selection Sort:</strong><br>
                Finds the minimum element and moves it to the sorted portion. Repeats for the remaining unsorted portion.<br><br>
                <strong>Time:</strong> O(n¬≤) always<br>
                <strong>Space:</strong> O(1)`,
            insertion: `<strong>Insertion Sort:</strong><br>
                Builds the sorted array one item at a time by inserting each element into its correct position. Efficient for small or nearly sorted arrays.<br><br>
                <strong>Time:</strong> O(n¬≤) average, O(n) best<br>
                <strong>Space:</strong> O(1)`,
            quick: `<strong>Quick Sort:</strong><br>
                Divides array using a pivot element, then recursively sorts the partitions. Very efficient in practice.<br><br>
                <strong>Time:</strong> O(n log n) average, O(n¬≤) worst<br>
                <strong>Space:</strong> O(log n)`,
            merge: `<strong>Merge Sort:</strong><br>
                Divides array in half, recursively sorts each half, then merges them. Guaranteed O(n log n) but requires extra space.<br><br>
                <strong>Time:</strong> O(n log n) always<br>
                <strong>Space:</strong> O(n)`,
            heap: `<strong>Heap Sort:</strong><br>
                Builds a max heap, then repeatedly extracts the maximum to build the sorted array. In-place with guaranteed O(n log n).<br><br>
                <strong>Time:</strong> O(n log n) always<br>
                <strong>Space:</strong> O(1)`
        };

        function initArray() {
            arr = [];
            for (let i = 0; i < arraySize; i++) {
                arr.push(Math.random() * canvas.height * 0.9 + canvas.height * 0.05);
            }
            sortedIndices.clear();
            comparing = [];
            swapping = [];
            comparisons = 0;
            swaps = 0;
            accesses = 0;
            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / arr.length;

            for (let i = 0; i < arr.length; i++) {
                let color = '#74b9ff'; // Default unsorted

                if (sortedIndices.has(i)) {
                    color = '#55efc4'; // Sorted
                }
                if (comparing.includes(i)) {
                    color = '#ff7675'; // Comparing
                }
                if (swapping.includes(i)) {
                    color = '#fdcb6e'; // Swapping
                }

                ctx.fillStyle = color;
                ctx.fillRect(
                    i * barWidth + 1,
                    canvas.height - arr[i],
                    barWidth - 2,
                    arr[i]
                );
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitIfPaused() {
            while (paused) {
                await sleep(100);
            }
        }

        function updateStats() {
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('swaps').textContent = swaps;
            document.getElementById('accesses').textContent = accesses;
        }

        async function bubbleSort() {
            for (let i = 0; i < arr.length; i++) {
                for (let j = 0; j < arr.length - i - 1; j++) {
                    await waitIfPaused();
                    if (!sorting) return;

                    comparing = [j, j + 1];
                    comparisons++;
                    accesses += 2;
                    draw();
                    await sleep(speed);

                    if (arr[j] > arr[j + 1]) {
                        swapping = [j, j + 1];
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        swaps++;
                        accesses += 2;
                        draw();
                        await sleep(speed);
                        swapping = [];
                    }
                    comparing = [];
                }
                sortedIndices.add(arr.length - i - 1);
                updateStats();
            }
        }

        async function selectionSort() {
            for (let i = 0; i < arr.length; i++) {
                let minIdx = i;

                for (let j = i + 1; j < arr.length; j++) {
                    await waitIfPaused();
                    if (!sorting) return;

                    comparing = [minIdx, j];
                    comparisons++;
                    accesses += 2;
                    draw();
                    await sleep(speed);

                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }

                if (minIdx !== i) {
                    swapping = [i, minIdx];
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    swaps++;
                    accesses += 2;
                    draw();
                    await sleep(speed);
                    swapping = [];
                }

                comparing = [];
                sortedIndices.add(i);
                updateStats();
            }
        }

        async function insertionSort() {
            sortedIndices.add(0);

            for (let i = 1; i < arr.length; i++) {
                let key = arr[i];
                let j = i - 1;
                accesses++;

                while (j >= 0) {
                    await waitIfPaused();
                    if (!sorting) return;

                    comparing = [j, j + 1];
                    comparisons++;
                    accesses++;
                    draw();
                    await sleep(speed);

                    if (arr[j] > key) {
                        swapping = [j, j + 1];
                        arr[j + 1] = arr[j];
                        swaps++;
                        accesses += 2;
                        draw();
                        await sleep(speed);
                        swapping = [];
                        j--;
                    } else {
                        break;
                    }
                }

                arr[j + 1] = key;
                accesses++;
                comparing = [];
                sortedIndices.add(i);
                updateStats();
            }
        }

        async function quickSort(low = 0, high = arr.length - 1) {
            if (low < high) {
                const pi = await partition(low, high);
                if (!sorting) return;
                await quickSort(low, pi - 1);
                if (!sorting) return;
                await quickSort(pi + 1, high);
            } else if (low >= 0 && low < arr.length) {
                sortedIndices.add(low);
            }
        }

        async function partition(low, high) {
            const pivot = arr[high];
            accesses++;
            let i = low - 1;

            for (let j = low; j < high; j++) {
                await waitIfPaused();
                if (!sorting) return -1;

                comparing = [j, high];
                comparisons++;
                accesses++;
                draw();
                await sleep(speed);

                if (arr[j] < pivot) {
                    i++;
                    swapping = [i, j];
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    swaps++;
                    accesses += 2;
                    draw();
                    await sleep(speed);
                    swapping = [];
                }
                comparing = [];
            }

            swapping = [i + 1, high];
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            swaps++;
            accesses += 2;
            draw();
            await sleep(speed);
            swapping = [];

            sortedIndices.add(i + 1);
            updateStats();
            return i + 1;
        }

        async function mergeSort(start = 0, end = arr.length - 1) {
            if (start < end) {
                const mid = Math.floor((start + end) / 2);
                await mergeSort(start, mid);
                if (!sorting) return;
                await mergeSort(mid + 1, end);
                if (!sorting) return;
                await merge(start, mid, end);
            } else if (start >= 0 && start < arr.length) {
                sortedIndices.add(start);
            }
        }

        async function merge(start, mid, end) {
            const left = arr.slice(start, mid + 1);
            const right = arr.slice(mid + 1, end + 1);
            accesses += end - start + 1;

            let i = 0, j = 0, k = start;

            while (i < left.length && j < right.length) {
                await waitIfPaused();
                if (!sorting) return;

                comparing = [start + i, mid + 1 + j];
                comparisons++;
                draw();
                await sleep(speed);

                if (left[i] <= right[j]) {
                    arr[k] = left[i];
                    i++;
                } else {
                    arr[k] = right[j];
                    j++;
                }
                swaps++;
                accesses++;
                k++;
                comparing = [];
            }

            while (i < left.length) {
                arr[k] = left[i];
                accesses++;
                i++;
                k++;
            }

            while (j < right.length) {
                arr[k] = right[j];
                accesses++;
                j++;
                k++;
            }

            for (let idx = start; idx <= end; idx++) {
                sortedIndices.add(idx);
            }
            updateStats();
        }

        async function heapSort() {
            // Build max heap
            for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
                await heapify(arr.length, i);
                if (!sorting) return;
            }

            // Extract elements from heap
            for (let i = arr.length - 1; i > 0; i--) {
                await waitIfPaused();
                if (!sorting) return;

                swapping = [0, i];
                [arr[0], arr[i]] = [arr[i], arr[0]];
                swaps++;
                accesses += 2;
                draw();
                await sleep(speed);
                swapping = [];

                sortedIndices.add(i);
                await heapify(i, 0);
            }
            sortedIndices.add(0);
            updateStats();
        }

        async function heapify(n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            if (left < n) {
                comparing = [largest, left];
                comparisons++;
                accesses += 2;
                draw();
                await sleep(speed / 2);
                if (arr[left] > arr[largest]) {
                    largest = left;
                }
            }

            if (right < n) {
                comparing = [largest, right];
                comparisons++;
                accesses += 2;
                draw();
                await sleep(speed / 2);
                if (arr[right] > arr[largest]) {
                    largest = right;
                }
            }

            comparing = [];

            if (largest !== i) {
                swapping = [i, largest];
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                swaps++;
                accesses += 2;
                draw();
                await sleep(speed);
                swapping = [];

                await heapify(n, largest);
            }
            updateStats();
        }

        async function startSort() {
            if (sorting) return;

            sorting = true;
            document.getElementById('status').textContent = 'Sorting...';

            const algo = document.getElementById('algorithm').value;

            switch (algo) {
                case 'bubble': await bubbleSort(); break;
                case 'selection': await selectionSort(); break;
                case 'insertion': await insertionSort(); break;
                case 'quick': await quickSort(); break;
                case 'merge': await mergeSort(); break;
                case 'heap': await heapSort(); break;
            }

            if (sorting) {
                // Mark all as sorted
                for (let i = 0; i < arr.length; i++) {
                    sortedIndices.add(i);
                }
                draw();
                document.getElementById('status').textContent = 'Complete!';
            }
            sorting = false;
        }

        function resetArray() {
            sorting = false;
            paused = false;
            arraySize = parseInt(document.getElementById('arraySize').value);
            initArray();
            draw();
            document.getElementById('status').textContent = 'Ready';
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('status').textContent = paused ? 'Paused' : 'Sorting...';
        }

        // Event listeners
        document.getElementById('arraySize').oninput = function() {
            document.getElementById('arraySizeVal').textContent = this.value;
        };
        document.getElementById('speed').oninput = function() {
            document.getElementById('speedVal').textContent = this.value;
            speed = parseInt(this.value);
        };
        document.getElementById('algorithm').onchange = function() {
            document.getElementById('algoDesc').innerHTML = descriptions[this.value];
        };

        initArray();
        draw();
    </script>
</body>
</html>
