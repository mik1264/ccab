<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Dimension - Box Counting - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #18181b; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; }
        canvas { display: block; }
        #fractalCanvas { flex: 2; }
        #graphCanvas { flex: 1; border-left: 1px solid #333; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #c084fc; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 6px; background: #333; color: #fff; border: none; border-radius: 4px; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #9333ea; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #7e22ce; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #c084fc; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .dimension { font-size: 1.5rem; font-weight: bold; color: #c084fc; }
        .theoretical { color: #22c55e; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="fractalCanvas"></canvas>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Fractal Dimension</h1>
            <p class="description">Measure fractal dimension using the box-counting method. The slope of log(N) vs log(1/ε) gives the dimension D.</p>
            
            <div class="control-group">
                <label>Fractal Type:</label>
                <select id="fractalType">
                    <option value="sierpinski">Sierpinski Triangle (D≈1.585)</option>
                    <option value="koch">Koch Curve (D≈1.262)</option>
                    <option value="cantor">Cantor Set (D≈0.631)</option>
                    <option value="tree">Fractal Tree (D≈1.4-1.8)</option>
                    <option value="fern">Barnsley Fern (D≈1.8)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Iterations: <span id="iterVal">5</span></label>
                <input type="range" id="iterations" min="2" max="8" value="5">
            </div>
            <div class="control-group">
                <label>Min Box Size: <span id="minBoxVal">4</span>px</label>
                <input type="range" id="minBox" min="2" max="16" value="4">
            </div>
            
            <button id="generate">Generate Fractal</button>
            <button id="measure">Measure Dimension</button>
            <button id="showBoxes">Show/Hide Boxes</button>
            
            <div class="stats">
                <div>Measured Dimension:</div>
                <div class="dimension" id="measuredD">—</div>
                <div style="margin-top: 8px;">Theoretical: <span class="theoretical" id="theoreticalD">1.585</span></div>
                <div>R² correlation: <span id="r2">—</span></div>
                <div style="margin-top: 8px;">Box sizes tested: <span id="boxSizes">—</span></div>
            </div>
            
            <p class="description"><strong>Box Counting:</strong> Cover the fractal with boxes of size ε and count N(ε). The dimension D = lim(log N / log(1/ε)) as ε→0.</p>
            
            <p class="description"><strong>Examples:</strong> A line has D=1, a filled square has D=2. Fractals have non-integer dimensions!</p>
        </div>
    </div>
    <script>
        const fractalCanvas = document.getElementById('fractalCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const fctx = fractalCanvas.getContext('2d');
        const gctx = graphCanvas.getContext('2d');
        
        let W, H, GW, GH;
        let showBoxes = false;
        let boxData = [];
        
        const FRACTALS = {
            sierpinski: { theoretical: Math.log(3) / Math.log(2) }, // ≈1.585
            koch: { theoretical: Math.log(4) / Math.log(3) },       // ≈1.262
            cantor: { theoretical: Math.log(2) / Math.log(3) },     // ≈0.631
            tree: { theoretical: 1.6 },
            fern: { theoretical: 1.8 }
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            const totalW = c.clientWidth;
            fractalCanvas.width = totalW * 0.65;
            fractalCanvas.height = c.clientHeight;
            graphCanvas.width = totalW * 0.35;
            graphCanvas.height = c.clientHeight;
            W = fractalCanvas.width;
            H = fractalCanvas.height;
            GW = graphCanvas.width;
            GH = graphCanvas.height;
        }
        
        function drawSierpinski(x, y, size, depth) {
            if (depth === 0) {
                fctx.beginPath();
                fctx.moveTo(x, y);
                fctx.lineTo(x + size, y);
                fctx.lineTo(x + size/2, y - size * Math.sqrt(3)/2);
                fctx.closePath();
                fctx.fill();
                return;
            }
            
            const half = size / 2;
            const h = half * Math.sqrt(3) / 2;
            drawSierpinski(x, y, half, depth - 1);
            drawSierpinski(x + half, y, half, depth - 1);
            drawSierpinski(x + half/2, y - h, half, depth - 1);
        }
        
        function drawKoch(x1, y1, x2, y2, depth) {
            if (depth === 0) {
                fctx.beginPath();
                fctx.moveTo(x1, y1);
                fctx.lineTo(x2, y2);
                fctx.stroke();
                return;
            }
            
            const dx = x2 - x1, dy = y2 - y1;
            const x3 = x1 + dx / 3, y3 = y1 + dy / 3;
            const x5 = x1 + 2 * dx / 3, y5 = y1 + 2 * dy / 3;
            const x4 = (x1 + x2) / 2 - dy * Math.sqrt(3) / 6;
            const y4 = (y1 + y2) / 2 + dx * Math.sqrt(3) / 6;
            
            drawKoch(x1, y1, x3, y3, depth - 1);
            drawKoch(x3, y3, x4, y4, depth - 1);
            drawKoch(x4, y4, x5, y5, depth - 1);
            drawKoch(x5, y5, x2, y2, depth - 1);
        }
        
        function drawCantor(x, y, length, depth) {
            const height = 10;
            if (depth === 0) {
                fctx.fillRect(x, y, length, height);
                return;
            }
            
            fctx.fillRect(x, y, length, height);
            const third = length / 3;
            drawCantor(x, y + 25, third, depth - 1);
            drawCantor(x + 2 * third, y + 25, third, depth - 1);
        }
        
        function drawTree(x, y, length, angle, depth) {
            if (depth === 0 || length < 2) return;
            
            const x2 = x + Math.cos(angle) * length;
            const y2 = y + Math.sin(angle) * length;
            
            fctx.beginPath();
            fctx.moveTo(x, y);
            fctx.lineTo(x2, y2);
            fctx.stroke();
            
            const branchRatio = 0.7;
            const spreadAngle = 0.4;
            drawTree(x2, y2, length * branchRatio, angle - spreadAngle, depth - 1);
            drawTree(x2, y2, length * branchRatio, angle + spreadAngle, depth - 1);
        }
        
        function drawFern(iterations) {
            let x = 0, y = 0;
            fctx.fillStyle = '#22c55e';
            
            for (let i = 0; i < iterations * 10000; i++) {
                const r = Math.random();
                let xn, yn;
                
                if (r < 0.01) {
                    xn = 0;
                    yn = 0.16 * y;
                } else if (r < 0.86) {
                    xn = 0.85 * x + 0.04 * y;
                    yn = -0.04 * x + 0.85 * y + 1.6;
                } else if (r < 0.93) {
                    xn = 0.2 * x - 0.26 * y;
                    yn = 0.23 * x + 0.22 * y + 1.6;
                } else {
                    xn = -0.15 * x + 0.28 * y;
                    yn = 0.26 * x + 0.24 * y + 0.44;
                }
                
                x = xn;
                y = yn;
                
                const px = W/2 + x * 40;
                const py = H - 20 - y * 35;
                fctx.fillRect(px, py, 1, 1);
            }
        }
        
        function generateFractal() {
            resize();
            fctx.fillStyle = '#18181b';
            fctx.fillRect(0, 0, W, H);
            
            const type = document.getElementById('fractalType').value;
            const iterations = +document.getElementById('iterations').value;
            
            fctx.fillStyle = '#c084fc';
            fctx.strokeStyle = '#c084fc';
            fctx.lineWidth = 2;
            
            switch(type) {
                case 'sierpinski':
                    const size = Math.min(W - 100, H - 100);
                    drawSierpinski(W/2 - size/2, H - 50, size, iterations);
                    break;
                case 'koch':
                    const margin = 50;
                    drawKoch(margin, H/2, W - margin, H/2, iterations);
                    break;
                case 'cantor':
                    drawCantor(50, 50, W - 100, iterations);
                    break;
                case 'tree':
                    fctx.lineWidth = Math.max(1, 4 - iterations * 0.3);
                    drawTree(W/2, H - 30, H/4, -Math.PI/2, iterations + 3);
                    break;
                case 'fern':
                    drawFern(iterations);
                    break;
            }
            
            document.getElementById('theoreticalD').textContent = 
                FRACTALS[type].theoretical.toFixed(3);
            
            boxData = [];
            showBoxes = false;
            drawGraph();
        }
        
        function countBoxes(boxSize) {
            const imageData = fctx.getImageData(0, 0, W, H);
            const data = imageData.data;
            
            const cols = Math.ceil(W / boxSize);
            const rows = Math.ceil(H / boxSize);
            let count = 0;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    let hasPixel = false;
                    
                    outerLoop:
                    for (let y = row * boxSize; y < Math.min((row + 1) * boxSize, H); y++) {
                        for (let x = col * boxSize; x < Math.min((col + 1) * boxSize, W); x++) {
                            const idx = (y * W + x) * 4;
                            // Check if pixel is not background
                            if (data[idx] > 30 || data[idx + 1] > 30 || data[idx + 2] > 30) {
                                hasPixel = true;
                                break outerLoop;
                            }
                        }
                    }
                    
                    if (hasPixel) count++;
                }
            }
            
            return count;
        }
        
        function measureDimension() {
            const minBox = +document.getElementById('minBox').value;
            boxData = [];
            
            // Measure at different box sizes
            for (let size = Math.max(minBox, 4); size <= 128; size *= 2) {
                const count = countBoxes(size);
                if (count > 0) {
                    boxData.push({
                        size: size,
                        count: count,
                        logEps: Math.log(1 / size),
                        logN: Math.log(count)
                    });
                }
            }
            
            if (boxData.length < 2) {
                document.getElementById('measuredD').textContent = 'Need more data';
                return;
            }
            
            // Linear regression on log-log plot
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            const n = boxData.length;
            
            for (const d of boxData) {
                sumX += d.logEps;
                sumY += d.logN;
                sumXY += d.logEps * d.logN;
                sumX2 += d.logEps * d.logEps;
                sumY2 += d.logN * d.logN;
            }
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            
            // R² correlation
            const r2 = Math.pow((n * sumXY - sumX * sumY) / 
                Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY)), 2);
            
            document.getElementById('measuredD').textContent = slope.toFixed(3);
            document.getElementById('r2').textContent = r2.toFixed(4);
            document.getElementById('boxSizes').textContent = boxData.map(d => d.size + 'px').join(', ');
            
            drawGraph();
        }
        
        function drawGraph() {
            gctx.fillStyle = '#1f1f23';
            gctx.fillRect(0, 0, GW, GH);
            
            if (boxData.length === 0) {
                gctx.fillStyle = '#666';
                gctx.font = '14px sans-serif';
                gctx.fillText('Click "Measure Dimension"', 20, GH/2);
                gctx.fillText('to see log-log plot', 20, GH/2 + 20);
                return;
            }
            
            // Find data bounds
            const minX = Math.min(...boxData.map(d => d.logEps));
            const maxX = Math.max(...boxData.map(d => d.logEps));
            const minY = Math.min(...boxData.map(d => d.logN));
            const maxY = Math.max(...boxData.map(d => d.logN));
            
            const margin = 50;
            const graphW = GW - 2 * margin;
            const graphH = GH - 2 * margin;
            
            const scaleX = graphW / (maxX - minX + 0.5);
            const scaleY = graphH / (maxY - minY + 0.5);
            
            const toScreenX = x => margin + (x - minX) * scaleX;
            const toScreenY = y => GH - margin - (y - minY) * scaleY;
            
            // Axes
            gctx.strokeStyle = '#666';
            gctx.lineWidth = 1;
            gctx.beginPath();
            gctx.moveTo(margin, margin);
            gctx.lineTo(margin, GH - margin);
            gctx.lineTo(GW - margin, GH - margin);
            gctx.stroke();
            
            // Axis labels
            gctx.fillStyle = '#aaa';
            gctx.font = '12px sans-serif';
            gctx.fillText('log(1/ε)', GW/2, GH - 10);
            gctx.save();
            gctx.translate(15, GH/2);
            gctx.rotate(-Math.PI/2);
            gctx.fillText('log(N)', 0, 0);
            gctx.restore();
            
            // Plot line of best fit
            if (boxData.length >= 2) {
                gctx.strokeStyle = '#22c55e';
                gctx.lineWidth = 2;
                gctx.beginPath();
                gctx.moveTo(toScreenX(boxData[0].logEps), toScreenY(boxData[0].logN));
                for (const d of boxData) {
                    gctx.lineTo(toScreenX(d.logEps), toScreenY(d.logN));
                }
                gctx.stroke();
            }
            
            // Plot data points
            gctx.fillStyle = '#c084fc';
            for (const d of boxData) {
                gctx.beginPath();
                gctx.arc(toScreenX(d.logEps), toScreenY(d.logN), 6, 0, Math.PI * 2);
                gctx.fill();
            }
            
            // Title
            gctx.fillStyle = '#fff';
            gctx.font = 'bold 14px sans-serif';
            gctx.fillText('Log-Log Plot', margin, 30);
        }
        
        function toggleBoxes() {
            showBoxes = !showBoxes;
            generateFractal();
            
            if (showBoxes && boxData.length > 0) {
                const size = boxData[Math.floor(boxData.length / 2)].size;
                
                fctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                fctx.lineWidth = 1;
                
                const cols = Math.ceil(W / size);
                const rows = Math.ceil(H / size);
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        fctx.strokeRect(col * size, row * size, size, size);
                    }
                }
            }
        }
        
        // Event listeners
        document.getElementById('fractalType').addEventListener('change', generateFractal);
        document.getElementById('iterations').addEventListener('input', e => {
            document.getElementById('iterVal').textContent = e.target.value;
        });
        document.getElementById('minBox').addEventListener('input', e => {
            document.getElementById('minBoxVal').textContent = e.target.value;
        });
        document.getElementById('generate').addEventListener('click', generateFractal);
        document.getElementById('measure').addEventListener('click', measureDimension);
        document.getElementById('showBoxes').addEventListener('click', toggleBoxes);
        
        window.addEventListener('resize', generateFractal);
        generateFractal();
    </script>
</body>
</html>
