<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voting Model - Opinion Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #9b59b6;
            text-decoration: none;
            z-index: 100;
        }
        header { text-align: center; padding: 15px; }
        h1 { color: #9b59b6; font-size: 1.6rem; }
        .container {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 15px;
            padding: 0 15px 15px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .main-area { display: flex; flex-direction: column; gap: 15px; }
        .canvas-wrapper {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
        }
        .canvas-wrapper h3 {
            color: #9b59b6;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        #gridCanvas {
            width: 100%;
            height: 400px;
            background: #0a0a15;
            border-radius: 8px;
        }
        #histCanvas {
            width: 100%;
            height: 120px;
            background: #0a0a15;
            border-radius: 8px;
            margin-top: 15px;
        }
        .sidebar {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
        }
        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: block;
            color: #9b59b6;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 5px;
            background: #333;
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #9b59b6;
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #888;
            margin-top: 4px;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #9b59b6;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: #9b59b6;
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { background: #8e44ad; }
        button.secondary { background: #333; }
        button.running { background: #27ae60; }
        .stats {
            background: rgba(155, 89, 182, 0.1);
            border: 1px solid rgba(155, 89, 182, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 0.8rem;
        }
        .stat-label { color: #888; }
        .stat-value { color: #9b59b6; font-family: monospace; }
        .party-bar {
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
            display: flex;
        }
        .party-segment {
            height: 100%;
            transition: width 0.3s;
        }
        .info {
            margin-top: 12px;
            padding: 10px;
            background: rgba(155, 89, 182, 0.1);
            border-radius: 6px;
            font-size: 0.75rem;
            line-height: 1.4;
        }
        .info h4 { color: #9b59b6; margin-bottom: 6px; }
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back</a>

    <header>
        <h1>Voting Model</h1>
        <p style="color: #888; font-size: 0.9rem;">Opinion Dynamics & Political Polarization</p>
    </header>

    <div class="container">
        <div class="main-area">
            <div class="canvas-wrapper">
                <h3>Voter Grid</h3>
                <canvas id="gridCanvas"></canvas>
                <h3 style="margin-top: 15px;">Opinion Distribution</h3>
                <canvas id="histCanvas"></canvas>
            </div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <label>Grid Size</label>
                <input type="range" id="gridSize" min="20" max="80" value="50">
                <div class="value-display"><span id="gridSizeVal">50</span> Ã— 50</div>
            </div>

            <div class="control-group">
                <label>Number of Parties</label>
                <input type="range" id="parties" min="2" max="6" value="3">
                <div class="value-display"><span id="partiesVal">3</span> parties</div>
            </div>

            <div class="control-group">
                <label>Social Influence</label>
                <input type="range" id="influence" min="0" max="100" value="30">
                <div class="value-display"><span id="influenceVal">30</span>%</div>
            </div>

            <div class="control-group">
                <label>Stubbornness</label>
                <input type="range" id="stubbornness" min="0" max="50" value="10">
                <div class="value-display"><span id="stubbornnessVal">10</span>%</div>
            </div>

            <div class="control-group">
                <label>Update Rule</label>
                <select id="rule">
                    <option value="majority">Majority Rule</option>
                    <option value="random">Random Neighbor</option>
                    <option value="threshold">Threshold Model</option>
                    <option value="voter">Classic Voter Model</option>
                </select>
            </div>

            <button id="startBtn">Start Simulation</button>
            <button id="stepBtn" class="secondary">Single Step</button>
            <button id="resetBtn" class="secondary">Reset</button>

            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Iteration:</span>
                    <span class="stat-value" id="iterationStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Consensus:</span>
                    <span class="stat-value" id="consensusStat">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Changes/Step:</span>
                    <span class="stat-value" id="changesStat">0</span>
                </div>
                <div class="party-bar" id="partyBar"></div>
            </div>

            <div class="info">
                <h4>Voting Models</h4>
                <p><strong>Majority:</strong> Adopt the most common neighbor opinion.</p>
                <p><strong>Random:</strong> Copy a random neighbor's opinion.</p>
                <p><strong>Threshold:</strong> Switch only if majority exceeds threshold.</p>
                <p><strong>Voter:</strong> Classic probabilistic voter model.</p>
            </div>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const histCanvas = document.getElementById('histCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const histCtx = histCanvas.getContext('2d');

        let gridSize = 50;
        let numParties = 3;
        let influence = 0.3;
        let stubbornness = 0.1;
        let updateRule = 'majority';
        let grid = [];
        let stubborn = []; // Stubborn voters who never change
        let running = false;
        let iteration = 0;
        let animFrame;

        const partyColors = [
            '#e74c3c', // Red
            '#3498db', // Blue
            '#2ecc71', // Green
            '#f39c12', // Orange
            '#9b59b6', // Purple
            '#1abc9c'  // Teal
        ];

        function resize() {
            gridCanvas.width = gridCanvas.parentElement.clientWidth - 30;
            gridCanvas.height = 400;
            histCanvas.width = histCanvas.parentElement.clientWidth - 30;
            histCanvas.height = 120;
            render();
        }

        function initGrid() {
            grid = [];
            stubborn = [];
            for (let y = 0; y < gridSize; y++) {
                const row = [];
                const stubRow = [];
                for (let x = 0; x < gridSize; x++) {
                    row.push(Math.floor(Math.random() * numParties));
                    stubRow.push(Math.random() < stubbornness);
                }
                grid.push(row);
                stubborn.push(stubRow);
            }
            iteration = 0;
            updateStats();
            render();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            for (const [dy, dx] of offsets) {
                const ny = (y + dy + gridSize) % gridSize;
                const nx = (x + dx + gridSize) % gridSize;
                neighbors.push(grid[ny][nx]);
            }
            return neighbors;
        }

        function majorityOpinion(neighbors) {
            const counts = new Array(numParties).fill(0);
            for (const n of neighbors) {
                counts[n]++;
            }
            let maxCount = 0;
            let maxParties = [];
            for (let i = 0; i < numParties; i++) {
                if (counts[i] > maxCount) {
                    maxCount = counts[i];
                    maxParties = [i];
                } else if (counts[i] === maxCount) {
                    maxParties.push(i);
                }
            }
            return maxParties[Math.floor(Math.random() * maxParties.length)];
        }

        function step() {
            let changes = 0;
            const newGrid = grid.map(row => [...row]);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    // Skip stubborn voters
                    if (stubborn[y][x]) continue;

                    // Check if influenced this step
                    if (Math.random() > influence) continue;

                    const neighbors = getNeighbors(x, y);
                    const current = grid[y][x];
                    let newOpinion = current;

                    switch (updateRule) {
                        case 'majority':
                            newOpinion = majorityOpinion(neighbors);
                            break;

                        case 'random':
                            newOpinion = neighbors[Math.floor(Math.random() * neighbors.length)];
                            break;

                        case 'threshold':
                            const counts = new Array(numParties).fill(0);
                            for (const n of neighbors) counts[n]++;
                            for (let i = 0; i < numParties; i++) {
                                if (i !== current && counts[i] >= 5) { // 5/8 = 62.5% threshold
                                    newOpinion = i;
                                    break;
                                }
                            }
                            break;

                        case 'voter':
                            // Classic voter: copy random neighbor with probability
                            const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                            if (randomNeighbor !== current) {
                                newOpinion = randomNeighbor;
                            }
                            break;
                    }

                    if (newOpinion !== current) {
                        newGrid[y][x] = newOpinion;
                        changes++;
                    }
                }
            }

            grid = newGrid;
            iteration++;
            document.getElementById('changesStat').textContent = changes.toLocaleString();
            updateStats();
            render();

            return changes;
        }

        function updateStats() {
            const counts = new Array(numParties).fill(0);
            const total = gridSize * gridSize;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    counts[grid[y][x]]++;
                }
            }

            const maxCount = Math.max(...counts);
            const consensus = (maxCount / total * 100).toFixed(1);

            document.getElementById('iterationStat').textContent = iteration.toLocaleString();
            document.getElementById('consensusStat').textContent = consensus + '%';

            // Update party bar
            const partyBar = document.getElementById('partyBar');
            partyBar.innerHTML = '';
            for (let i = 0; i < numParties; i++) {
                const segment = document.createElement('div');
                segment.className = 'party-segment';
                segment.style.width = (counts[i] / total * 100) + '%';
                segment.style.background = partyColors[i];
                partyBar.appendChild(segment);
            }
        }

        function render() {
            // Draw grid
            const cellW = gridCanvas.width / gridSize;
            const cellH = gridCanvas.height / gridSize;

            gridCtx.fillStyle = '#0a0a15';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const party = grid[y][x];
                    gridCtx.fillStyle = partyColors[party];

                    // Stubborn voters have darker color
                    if (stubborn[y][x]) {
                        gridCtx.globalAlpha = 0.6;
                    }

                    gridCtx.fillRect(x * cellW, y * cellH, cellW - 0.5, cellH - 0.5);
                    gridCtx.globalAlpha = 1;
                }
            }

            // Draw histogram
            const counts = new Array(numParties).fill(0);
            const total = gridSize * gridSize;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    counts[grid[y][x]]++;
                }
            }

            histCtx.fillStyle = '#0a0a15';
            histCtx.fillRect(0, 0, histCanvas.width, histCanvas.height);

            const barWidth = (histCanvas.width - 40) / numParties;
            const maxHeight = histCanvas.height - 30;

            for (let i = 0; i < numParties; i++) {
                const height = (counts[i] / total) * maxHeight;
                const x = 20 + i * barWidth;
                const y = histCanvas.height - 20 - height;

                histCtx.fillStyle = partyColors[i];
                histCtx.fillRect(x + 5, y, barWidth - 10, height);

                // Label
                histCtx.fillStyle = '#888';
                histCtx.font = '11px sans-serif';
                histCtx.textAlign = 'center';
                histCtx.fillText((counts[i] / total * 100).toFixed(0) + '%', x + barWidth / 2, y - 5);
                histCtx.fillText('Party ' + (i + 1), x + barWidth / 2, histCanvas.height - 5);
            }
        }

        function animate() {
            if (!running) return;
            const changes = step();

            // Stop if consensus reached or no changes
            if (changes === 0) {
                running = false;
                document.getElementById('startBtn').textContent = 'Start Simulation';
                document.getElementById('startBtn').classList.remove('running');
                return;
            }

            animFrame = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('gridSize').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('gridSizeVal').textContent = gridSize;
        });

        document.getElementById('parties').addEventListener('input', (e) => {
            numParties = parseInt(e.target.value);
            document.getElementById('partiesVal').textContent = numParties;
        });

        document.getElementById('influence').addEventListener('input', (e) => {
            influence = parseInt(e.target.value) / 100;
            document.getElementById('influenceVal').textContent = e.target.value;
        });

        document.getElementById('stubbornness').addEventListener('input', (e) => {
            stubbornness = parseInt(e.target.value) / 100;
            document.getElementById('stubbornnessVal').textContent = e.target.value;
        });

        document.getElementById('rule').addEventListener('change', (e) => {
            updateRule = e.target.value;
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            if (running) {
                document.getElementById('startBtn').textContent = 'Pause';
                document.getElementById('startBtn').classList.add('running');
                animate();
            } else {
                document.getElementById('startBtn').textContent = 'Resume';
                document.getElementById('startBtn').classList.remove('running');
                cancelAnimationFrame(animFrame);
            }
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (!running) step();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Simulation';
            document.getElementById('startBtn').classList.remove('running');
            cancelAnimationFrame(animFrame);
            initGrid();
        });

        window.addEventListener('resize', resize);
        resize();
        initGrid();
    </script>
</body>
</html>
