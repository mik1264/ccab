<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planarity Puzzle - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0e1a; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas.dragging { cursor: grabbing; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #60a5fa; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; background: #1a1f2e; color: #e8e6e1; border: 1px solid #333; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #60a5fa; color: #0a0e1a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #3b82f6; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #60a5fa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .success { color: #22c55e; font-weight: bold; text-align: center; padding: 10px; background: rgba(34, 197, 94, 0.2); border-radius: 5px; margin-bottom: 15px; }
        .crossings { font-size: 2rem; text-align: center; margin-bottom: 15px; }
        .crossings span { font-weight: bold; color: #ef4444; }
        .crossings.solved span { color: #22c55e; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Planarity Puzzle</h1>
            <p class="description">Untangle the graph! Drag nodes to eliminate all edge crossings. A planar graph can always be drawn without crossings.</p>

            <div class="crossings" id="crossingsDisplay">
                Crossings: <span id="crossingCount">0</span>
            </div>

            <div id="successMsg" class="success" style="display: none;">
                Solved! No crossings!
            </div>

            <div class="control-group">
                <label>Difficulty</label>
                <select id="difficulty">
                    <option value="easy">Easy (6 nodes)</option>
                    <option value="medium" selected>Medium (10 nodes)</option>
                    <option value="hard">Hard (15 nodes)</option>
                    <option value="expert">Expert (20 nodes)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Graph Type</label>
                <select id="graphType">
                    <option value="planar">Planar (solvable)</option>
                    <option value="random">Random</option>
                    <option value="complete">Complete (may not be planar)</option>
                </select>
            </div>

            <button id="newGame">New Puzzle</button>
            <button id="shuffle">Shuffle Nodes</button>
            <button id="hint">Show Hint</button>

            <div class="stats">
                <div>Nodes: <span id="nodeCount">0</span></div>
                <div>Edges: <span id="edgeCount">0</span></div>
                <div>Moves: <span id="moves">0</span></div>
                <div>Best for this size: <span id="bestScore">-</span></div>
            </div>

            <p class="description">Tips: Start by identifying nodes with many connections (hubs) and place them centrally. Work from the outside in.</p>

            <p class="description">Kuratowski's theorem: A graph is planar if and only if it doesn't contain K₅ or K₃,₃ as a subgraph.</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        let nodes = [];
        let edges = [];
        let dragging = null;
        let moves = 0;
        let bestScores = {};

        const difficulties = {
            easy: 6,
            medium: 10,
            hard: 15,
            expert: 20
        };

        let params = {
            difficulty: 'medium',
            graphType: 'planar'
        };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }

        function generatePlanarGraph(n) {
            // Generate a planar graph using triangulation
            nodes = [];
            edges = [];

            // Place nodes in a circle initially
            const cx = W / 2, cy = H / 2;
            const r = Math.min(W, H) * 0.35;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push({
                    id: i,
                    x: cx + Math.cos(angle) * r,
                    y: cy + Math.sin(angle) * r,
                    originalX: cx + Math.cos(angle) * r * 0.5,
                    originalY: cy + Math.sin(angle) * r * 0.5
                });
            }

            // Create a planar graph (outer cycle + some inner edges)
            // Outer cycle
            for (let i = 0; i < n; i++) {
                edges.push({ from: i, to: (i + 1) % n });
            }

            // Add some diagonal edges (triangulation)
            if (n >= 4) {
                for (let i = 0; i < n - 2; i += 2) {
                    edges.push({ from: i, to: i + 2 });
                }
            }

            // Add a few more edges while keeping planarity
            const maxExtraEdges = Math.floor(n / 2);
            for (let i = 0; i < maxExtraEdges; i++) {
                const from = Math.floor(Math.random() * n);
                const to = (from + 2 + Math.floor(Math.random() * (n - 3))) % n;
                if (!hasEdge(from, to) && from !== to) {
                    edges.push({ from, to });
                }
            }
        }

        function generateRandomGraph(n) {
            nodes = [];
            edges = [];

            const cx = W / 2, cy = H / 2;
            const r = Math.min(W, H) * 0.35;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push({
                    id: i,
                    x: cx + Math.cos(angle) * r,
                    y: cy + Math.sin(angle) * r
                });
            }

            // Random edges
            const numEdges = Math.floor(n * 1.5);
            for (let i = 0; i < numEdges; i++) {
                const from = Math.floor(Math.random() * n);
                const to = Math.floor(Math.random() * n);
                if (from !== to && !hasEdge(from, to)) {
                    edges.push({ from, to });
                }
            }
        }

        function generateCompleteGraph(n) {
            nodes = [];
            edges = [];

            const cx = W / 2, cy = H / 2;
            const r = Math.min(W, H) * 0.35;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push({
                    id: i,
                    x: cx + Math.cos(angle) * r,
                    y: cy + Math.sin(angle) * r
                });
            }

            // All edges (complete graph)
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    edges.push({ from: i, to: j });
                }
            }
        }

        function hasEdge(a, b) {
            return edges.some(e =>
                (e.from === a && e.to === b) ||
                (e.from === b && e.to === a)
            );
        }

        function shuffleNodes() {
            const cx = W / 2, cy = H / 2;
            const r = Math.min(W, H) * 0.35;

            for (const node of nodes) {
                node.x = cx + (Math.random() - 0.5) * r * 2;
                node.y = cy + (Math.random() - 0.5) * r * 2;
            }
        }

        function init() {
            resize();
            moves = 0;

            const n = difficulties[params.difficulty];

            switch (params.graphType) {
                case 'planar':
                    generatePlanarGraph(n);
                    break;
                case 'random':
                    generateRandomGraph(n);
                    break;
                case 'complete':
                    generateCompleteGraph(Math.min(n, 8)); // Limit complete graphs
                    break;
            }

            shuffleNodes();
            document.getElementById('successMsg').style.display = 'none';
        }

        function lineIntersects(x1, y1, x2, y2, x3, y3, x4, y4) {
            // Check if line segment (x1,y1)-(x2,y2) intersects (x3,y3)-(x4,y4)
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 0.0001) return false;

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

            // Exclude endpoints (they share nodes)
            return ua > 0.01 && ua < 0.99 && ub > 0.01 && ub < 0.99;
        }

        function countCrossings() {
            let crossings = 0;

            for (let i = 0; i < edges.length; i++) {
                for (let j = i + 1; j < edges.length; j++) {
                    const e1 = edges[i];
                    const e2 = edges[j];

                    // Skip if edges share a node
                    if (e1.from === e2.from || e1.from === e2.to ||
                        e1.to === e2.from || e1.to === e2.to) continue;

                    const n1 = nodes[e1.from];
                    const n2 = nodes[e1.to];
                    const n3 = nodes[e2.from];
                    const n4 = nodes[e2.to];

                    if (lineIntersects(n1.x, n1.y, n2.x, n2.y, n3.x, n3.y, n4.x, n4.y)) {
                        crossings++;
                    }
                }
            }

            return crossings;
        }

        function showHint() {
            // Move a random node slightly toward a better position
            const currentCrossings = countCrossings();

            for (const node of nodes) {
                const oldX = node.x, oldY = node.y;

                // Try a few random positions
                for (let attempt = 0; attempt < 10; attempt++) {
                    node.x = oldX + (Math.random() - 0.5) * 50;
                    node.y = oldY + (Math.random() - 0.5) * 50;

                    // Keep in bounds
                    node.x = Math.max(50, Math.min(W - 50, node.x));
                    node.y = Math.max(50, Math.min(H - 50, node.y));

                    if (countCrossings() < currentCrossings) {
                        // Found improvement, highlight this node
                        node.highlighted = true;
                        setTimeout(() => { node.highlighted = false; }, 1000);
                        return;
                    }
                }

                // Restore
                node.x = oldX;
                node.y = oldY;
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            const crossings = countCrossings();

            // Draw edges
            for (const edge of edges) {
                const n1 = nodes[edge.from];
                const n2 = nodes[edge.to];

                // Check if this edge crosses any other
                let crosses = false;
                for (const other of edges) {
                    if (edge === other) continue;
                    if (edge.from === other.from || edge.from === other.to ||
                        edge.to === other.from || edge.to === other.to) continue;

                    const o1 = nodes[other.from];
                    const o2 = nodes[other.to];
                    if (lineIntersects(n1.x, n1.y, n2.x, n2.y, o1.x, o1.y, o2.x, o2.y)) {
                        crosses = true;
                        break;
                    }
                }

                ctx.strokeStyle = crosses ? '#ef4444' : '#22c55e';
                ctx.lineWidth = crosses ? 2 : 1.5;
                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.lineTo(n2.x, n2.y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                const r = dragging === node ? 14 : 10;

                // Glow for highlighted nodes (hint)
                if (node.highlighted) {
                    const gradient = ctx.createRadialGradient(node.x, node.y, r, node.x, node.y, r + 20);
                    gradient.addColorStop(0, 'rgba(96, 165, 250, 0.5)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r + 20, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = dragging === node ? '#60a5fa' : '#fff';
                ctx.beginPath();
                ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Node number
                ctx.fillStyle = '#0a0e1a';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id.toString(), node.x, node.y);
            }

            // Update stats
            document.getElementById('crossingCount').textContent = crossings;
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;
            document.getElementById('moves').textContent = moves;

            const crossingsDiv = document.getElementById('crossingsDisplay');
            crossingsDiv.className = crossings === 0 ? 'crossings solved' : 'crossings';

            if (crossings === 0 && nodes.length > 0) {
                document.getElementById('successMsg').style.display = 'block';
                const key = `${params.difficulty}-${params.graphType}`;
                if (!bestScores[key] || moves < bestScores[key]) {
                    bestScores[key] = moves;
                    document.getElementById('bestScore').textContent = moves;
                }
            }

            requestAnimationFrame(draw);
        }

        // Mouse handling
        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const node of nodes) {
                const dx = x - node.x;
                const dy = y - node.y;
                if (dx * dx + dy * dy < 400) {
                    dragging = node;
                    canvas.classList.add('dragging');
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (!dragging) return;

            const rect = canvas.getBoundingClientRect();
            dragging.x = e.clientX - rect.left;
            dragging.y = e.clientY - rect.top;

            // Keep in bounds
            dragging.x = Math.max(20, Math.min(W - 20, dragging.x));
            dragging.y = Math.max(20, Math.min(H - 20, dragging.y));
        });

        canvas.addEventListener('mouseup', () => {
            if (dragging) {
                moves++;
            }
            dragging = null;
            canvas.classList.remove('dragging');
        });

        canvas.addEventListener('mouseleave', () => {
            if (dragging) moves++;
            dragging = null;
            canvas.classList.remove('dragging');
        });

        // Touch support
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            for (const node of nodes) {
                const dx = x - node.x;
                const dy = y - node.y;
                if (dx * dx + dy * dy < 600) {
                    dragging = node;
                    break;
                }
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!dragging) return;

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            dragging.x = touch.clientX - rect.left;
            dragging.y = touch.clientY - rect.top;

            dragging.x = Math.max(20, Math.min(W - 20, dragging.x));
            dragging.y = Math.max(20, Math.min(H - 20, dragging.y));
        });

        canvas.addEventListener('touchend', () => {
            if (dragging) moves++;
            dragging = null;
        });

        // Controls
        document.getElementById('difficulty').addEventListener('change', e => {
            params.difficulty = e.target.value;
        });
        document.getElementById('graphType').addEventListener('change', e => {
            params.graphType = e.target.value;
        });

        document.getElementById('newGame').addEventListener('click', init);
        document.getElementById('shuffle').addEventListener('click', shuffleNodes);
        document.getElementById('hint').addEventListener('click', showHint);

        window.addEventListener('resize', resize);
        init();
        draw();
    </script>
</body>
</html>
