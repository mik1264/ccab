<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axelrod Tournament - Prisoner's Dilemma Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
        }
        .container {
            display: flex;
            width: 100%;
        }
        .controls {
            width: 320px;
            padding: 20px;
            background: #12172b;
            overflow-y: auto;
            max-height: 100vh;
        }
        .controls h1 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: #ff7043;
        }
        .controls p {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ffab91;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #ff7043;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        button.primary {
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: white;
        }
        button.secondary {
            background: #2d3a4f;
            color: #ffab91;
        }
        button:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
        }
        .results h3 {
            font-size: 0.9rem;
            color: #ff7043;
            margin-bottom: 10px;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: #232850;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        .strategy-name {
            flex: 1;
            font-weight: 500;
        }
        .strategy-score {
            color: #ff7043;
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }
        .strategy-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 4px;
        }
        .strategy-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s;
        }
        .payoff-matrix {
            margin-top: 15px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
        }
        .payoff-matrix h3 {
            font-size: 0.9rem;
            color: #ff7043;
            margin-bottom: 10px;
        }
        .matrix-table {
            width: 100%;
            font-size: 0.8rem;
        }
        .matrix-table td, .matrix-table th {
            padding: 8px;
            text-align: center;
            border: 1px solid #333;
        }
        .matrix-table th {
            background: #232850;
            color: #ffab91;
        }
        .matrix-table td {
            background: #1a2040;
        }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #ff7043;
            text-decoration: none;
            font-size: 0.85rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .back-link:hover {
            opacity: 1;
        }
        .strategy-desc {
            font-size: 0.75rem;
            color: #666;
            margin-top: 15px;
            padding: 10px;
            background: #1a2040;
            border-radius: 4px;
        }
        .strategy-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 0.85rem;
        }
        .strategy-toggle input {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <a href="index.html" class="back-link">← Back to Gallery</a>
            <h1>Axelrod Tournament</h1>
            <p>Robert Axelrod's famous tournament for evolving Prisoner's Dilemma strategies. Strategies compete in round-robin matches across generations.</p>

            <div class="control-group">
                <label>Rounds per Match: <span class="value-display" id="roundsVal">200</span></label>
                <input type="range" id="rounds" min="50" max="500" value="200" step="50">
            </div>

            <div class="control-group">
                <label>Noise (Mistakes): <span class="value-display" id="noiseVal">0%</span></label>
                <input type="range" id="noise" min="0" max="20" value="0">
            </div>

            <div class="control-group">
                <label>Generations: <span class="value-display" id="genVal">20</span></label>
                <input type="range" id="generations" min="5" max="50" value="20">
            </div>

            <div class="control-group">
                <label>Active Strategies:</label>
                <div id="strategyToggles"></div>
            </div>

            <button class="primary" onclick="runTournament()">Run Tournament</button>
            <button class="secondary" onclick="runEvolution()">Run Evolution</button>
            <button class="secondary" onclick="resetResults()">Reset</button>

            <div class="results" id="results">
                <h3>Tournament Results</h3>
                <div id="rankings"></div>
            </div>

            <div class="payoff-matrix">
                <h3>Payoff Matrix</h3>
                <table class="matrix-table">
                    <tr>
                        <th></th>
                        <th>Cooperate</th>
                        <th>Defect</th>
                    </tr>
                    <tr>
                        <th>Cooperate</th>
                        <td>R=3, R=3</td>
                        <td>S=0, T=5</td>
                    </tr>
                    <tr>
                        <th>Defect</th>
                        <td>T=5, S=0</td>
                        <td>P=1, P=1</td>
                    </tr>
                </table>
            </div>

            <div class="strategy-desc">
                <strong>Classic Strategies:</strong><br>
                • TFT: Cooperate first, then copy opponent<br>
                • GTFT: Generous TFT (forgive sometimes)<br>
                • STFT: Suspicious TFT (defect first)<br>
                • Pavlov: Win-stay, Lose-switch<br>
                • AllC/AllD: Always cooperate/defect<br>
                • Random: 50/50 random choice<br>
                • Grudger: Cooperate until betrayed<br>
                • Detective: Probe then TFT or AllD
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Payoffs
        const T = 5; // Temptation (defect vs cooperate)
        const R = 3; // Reward (both cooperate)
        const P = 1; // Punishment (both defect)
        const S = 0; // Sucker (cooperate vs defect)

        // Strategy definitions
        const strategies = {
            'Tit-for-Tat': {
                color: '#4caf50',
                init: () => ({ lastMove: null }),
                play: (state, history, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    return oppHistory[oppHistory.length - 1];
                }
            },
            'Generous TFT': {
                color: '#8bc34a',
                init: () => ({}),
                play: (state, history, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    if (oppHistory[oppHistory.length - 1] === 'D') {
                        return Math.random() < 0.1 ? 'C' : 'D';
                    }
                    return 'C';
                }
            },
            'Suspicious TFT': {
                color: '#cddc39',
                init: () => ({}),
                play: (state, history, oppHistory) => {
                    if (oppHistory.length === 0) return 'D';
                    return oppHistory[oppHistory.length - 1];
                }
            },
            'Pavlov': {
                color: '#2196f3',
                init: () => ({ last: 'C' }),
                play: (state, history, oppHistory) => {
                    if (history.length === 0) return 'C';
                    const lastOwn = history[history.length - 1];
                    const lastOpp = oppHistory[oppHistory.length - 1];
                    // Win-stay, lose-switch
                    if ((lastOwn === 'C' && lastOpp === 'C') || (lastOwn === 'D' && lastOpp === 'D')) {
                        return lastOwn;
                    }
                    return lastOwn === 'C' ? 'D' : 'C';
                }
            },
            'Always Cooperate': {
                color: '#00bcd4',
                init: () => ({}),
                play: () => 'C'
            },
            'Always Defect': {
                color: '#f44336',
                init: () => ({}),
                play: () => 'D'
            },
            'Random': {
                color: '#9e9e9e',
                init: () => ({}),
                play: () => Math.random() < 0.5 ? 'C' : 'D'
            },
            'Grudger': {
                color: '#ff9800',
                init: () => ({ grudge: false }),
                play: (state, history, oppHistory) => {
                    if (oppHistory.includes('D')) state.grudge = true;
                    return state.grudge ? 'D' : 'C';
                }
            },
            'Detective': {
                color: '#9c27b0',
                init: () => ({ phase: 0, useTFT: false }),
                play: (state, history, oppHistory) => {
                    // First 4 moves: C, D, C, C
                    const probe = ['C', 'D', 'C', 'C'];
                    if (history.length < 4) return probe[history.length];

                    if (history.length === 4) {
                        // Check if opponent defected in first 4 rounds
                        state.useTFT = oppHistory.slice(0, 4).includes('D');
                    }

                    if (state.useTFT) {
                        return oppHistory[oppHistory.length - 1];
                    }
                    return 'D'; // Exploit if opponent never defected
                }
            },
            'Tit-for-Two-Tats': {
                color: '#03a9f4',
                init: () => ({}),
                play: (state, history, oppHistory) => {
                    if (oppHistory.length < 2) return 'C';
                    if (oppHistory[oppHistory.length - 1] === 'D' &&
                        oppHistory[oppHistory.length - 2] === 'D') {
                        return 'D';
                    }
                    return 'C';
                }
            },
            'Hard TFT': {
                color: '#ffc107',
                init: () => ({}),
                play: (state, history, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    // Defect if opponent defected in last 3 rounds
                    const recent = oppHistory.slice(-3);
                    return recent.includes('D') ? 'D' : 'C';
                }
            }
        };

        let activeStrategies = Object.keys(strategies);
        let results = {};
        let evolutionHistory = [];

        function initCanvas() {
            const wrapper = document.querySelector('.canvas-wrapper');
            const width = wrapper.clientWidth - 40;
            const height = wrapper.clientHeight - 40;
            canvas.width = Math.min(width, 700);
            canvas.height = Math.min(height, 500);
        }

        function initToggles() {
            const container = document.getElementById('strategyToggles');
            container.innerHTML = '';

            for (const name of Object.keys(strategies)) {
                const div = document.createElement('div');
                div.className = 'strategy-toggle';
                div.innerHTML = `
                    <input type="checkbox" id="strat_${name}" checked>
                    <label for="strat_${name}" style="color: ${strategies[name].color}">${name}</label>
                `;
                container.appendChild(div);
            }
        }

        function getActiveStrategies() {
            activeStrategies = [];
            for (const name of Object.keys(strategies)) {
                const cb = document.getElementById(`strat_${name}`);
                if (cb && cb.checked) {
                    activeStrategies.push(name);
                }
            }
            return activeStrategies;
        }

        function applyNoise(move, noise) {
            if (Math.random() < noise) {
                return move === 'C' ? 'D' : 'C';
            }
            return move;
        }

        function playMatch(strat1, strat2, rounds, noise) {
            const s1 = strategies[strat1];
            const s2 = strategies[strat2];

            const state1 = s1.init();
            const state2 = s2.init();
            const history1 = [];
            const history2 = [];
            let score1 = 0, score2 = 0;

            for (let r = 0; r < rounds; r++) {
                let move1 = s1.play(state1, history1, history2);
                let move2 = s2.play(state2, history2, history1);

                move1 = applyNoise(move1, noise);
                move2 = applyNoise(move2, noise);

                history1.push(move1);
                history2.push(move2);

                // Calculate payoffs
                if (move1 === 'C' && move2 === 'C') {
                    score1 += R;
                    score2 += R;
                } else if (move1 === 'C' && move2 === 'D') {
                    score1 += S;
                    score2 += T;
                } else if (move1 === 'D' && move2 === 'C') {
                    score1 += T;
                    score2 += S;
                } else {
                    score1 += P;
                    score2 += P;
                }
            }

            return { score1, score2, history1, history2 };
        }

        function runTournament() {
            getActiveStrategies();
            const rounds = parseInt(document.getElementById('rounds').value);
            const noise = parseInt(document.getElementById('noise').value) / 100;

            results = {};
            for (const name of activeStrategies) {
                results[name] = { total: 0, matches: 0 };
            }

            // Round-robin tournament
            for (let i = 0; i < activeStrategies.length; i++) {
                for (let j = i; j < activeStrategies.length; j++) {
                    const s1 = activeStrategies[i];
                    const s2 = activeStrategies[j];

                    const match = playMatch(s1, s2, rounds, noise);

                    results[s1].total += match.score1;
                    results[s1].matches++;

                    if (i !== j) {
                        results[s2].total += match.score2;
                        results[s2].matches++;
                    }
                }
            }

            // Calculate averages
            for (const name of activeStrategies) {
                results[name].avg = results[name].total / results[name].matches;
            }

            displayResults();
            renderChart();
        }

        function runEvolution() {
            getActiveStrategies();
            const rounds = parseInt(document.getElementById('rounds').value);
            const noise = parseInt(document.getElementById('noise').value) / 100;
            const generations = parseInt(document.getElementById('generations').value);

            // Initial population
            let population = {};
            for (const name of activeStrategies) {
                population[name] = 100 / activeStrategies.length;
            }

            evolutionHistory = [{ ...population }];

            for (let gen = 0; gen < generations; gen++) {
                // Run tournament with current population
                const scores = {};
                for (const name of activeStrategies) {
                    scores[name] = 0;
                }

                for (let i = 0; i < activeStrategies.length; i++) {
                    for (let j = 0; j < activeStrategies.length; j++) {
                        const s1 = activeStrategies[i];
                        const s2 = activeStrategies[j];
                        const weight = (population[s1] * population[s2]) / 10000;

                        if (weight > 0.001) {
                            const match = playMatch(s1, s2, rounds, noise);
                            scores[s1] += match.score1 * weight;
                            scores[s2] += match.score2 * weight;
                        }
                    }
                }

                // Update population based on scores
                let totalScore = 0;
                for (const name of activeStrategies) {
                    totalScore += Math.max(0, scores[name]);
                }

                if (totalScore > 0) {
                    for (const name of activeStrategies) {
                        population[name] = Math.max(0.1, (scores[name] / totalScore) * 100);
                    }
                }

                evolutionHistory.push({ ...population });
            }

            // Set final results
            results = {};
            for (const name of activeStrategies) {
                results[name] = { avg: population[name] };
            }

            displayResults();
            renderEvolutionChart();
        }

        function displayResults() {
            const rankings = document.getElementById('rankings');
            const sorted = activeStrategies
                .filter(name => results[name])
                .sort((a, b) => results[b].avg - results[a].avg);

            const maxScore = sorted.length > 0 ? results[sorted[0]].avg : 1;

            rankings.innerHTML = sorted.map((name, i) => {
                const score = results[name].avg;
                const width = (score / maxScore) * 100;
                return `
                    <div class="result-row">
                        <span style="color: ${strategies[name].color}; margin-right: 8px;">${i + 1}.</span>
                        <span class="strategy-name">${name}</span>
                        <span class="strategy-score">${score.toFixed(1)}</span>
                    </div>
                    <div class="strategy-bar">
                        <div class="strategy-bar-fill" style="width: ${width}%; background: ${strategies[name].color};"></div>
                    </div>
                `;
            }).join('');
        }

        function renderChart() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const sorted = activeStrategies
                .filter(name => results[name])
                .sort((a, b) => results[b].avg - results[a].avg);

            if (sorted.length === 0) return;

            const maxScore = results[sorted[0]].avg;
            const barWidth = (canvas.width - 100) / sorted.length - 10;
            const chartHeight = canvas.height - 80;

            // Title
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Tournament Results - Average Score per Match', canvas.width / 2, 30);

            // Draw bars
            sorted.forEach((name, i) => {
                const score = results[name].avg;
                const height = (score / maxScore) * chartHeight * 0.8;
                const x = 60 + i * (barWidth + 10);
                const y = canvas.height - 50 - height;

                // Bar
                ctx.fillStyle = strategies[name].color;
                ctx.fillRect(x, y, barWidth, height);

                // Score label
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(score.toFixed(0), x + barWidth / 2, y - 5);

                // Strategy name
                ctx.save();
                ctx.translate(x + barWidth / 2, canvas.height - 35);
                ctx.rotate(-Math.PI / 4);
                ctx.textAlign = 'right';
                ctx.fillStyle = strategies[name].color;
                ctx.fillText(name.substring(0, 12), 0, 0);
                ctx.restore();
            });
        }

        function renderEvolutionChart() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (evolutionHistory.length === 0) return;

            const chartWidth = canvas.width - 100;
            const chartHeight = canvas.height - 80;
            const generations = evolutionHistory.length;

            // Title
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Evolution of Strategy Populations', canvas.width / 2, 30);

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = 50 + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(60, y);
                ctx.lineTo(canvas.width - 40, y);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText((100 - i * 20) + '%', 55, y + 4);
            }

            // Draw lines for each strategy
            for (const name of activeStrategies) {
                ctx.strokeStyle = strategies[name].color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let g = 0; g < generations; g++) {
                    const x = 60 + (g / (generations - 1)) * chartWidth;
                    const pop = evolutionHistory[g][name] || 0;
                    const y = 50 + (1 - pop / 100) * chartHeight;

                    if (g === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            // X-axis label
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Generation', canvas.width / 2, canvas.height - 10);

            // Legend
            let legendY = 50;
            for (const name of activeStrategies) {
                const finalPop = evolutionHistory[generations - 1][name] || 0;
                if (finalPop > 1) {
                    ctx.fillStyle = strategies[name].color;
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${name}: ${finalPop.toFixed(1)}%`, canvas.width - 150, legendY);
                    legendY += 15;
                }
            }
        }

        function resetResults() {
            results = {};
            evolutionHistory = [];
            document.getElementById('rankings').innerHTML = '';
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#666';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Click "Run Tournament" or "Run Evolution" to see results', canvas.width / 2, canvas.height / 2);
        }

        // Event listeners
        document.getElementById('rounds').addEventListener('input', function() {
            document.getElementById('roundsVal').textContent = this.value;
        });
        document.getElementById('noise').addEventListener('input', function() {
            document.getElementById('noiseVal').textContent = this.value + '%';
        });
        document.getElementById('generations').addEventListener('input', function() {
            document.getElementById('genVal').textContent = this.value;
        });

        window.addEventListener('resize', () => {
            initCanvas();
            if (evolutionHistory.length > 0) {
                renderEvolutionChart();
            } else if (Object.keys(results).length > 0) {
                renderChart();
            } else {
                resetResults();
            }
        });

        // Initialize
        initCanvas();
        initToggles();
        resetResults();
    </script>
</body>
</html>
