<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Party - Social Clustering - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        #simCanvas { width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #ec4899; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #be185d; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #9d174d; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #ec4899; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .legend { font-size: 0.65rem; color: #666; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Party Simulation</h1>
            <p class="description">Agents mingle at a party, gravitating toward others with similar attributes. Watch clusters form based on homophily (preference for similar others).</p>
            
            <div class="control-group">
                <label>Guests: <span id="guestsVal">100</span></label>
                <input type="range" id="guests" min="30" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Attributes (types): <span id="attrsVal">4</span></label>
                <input type="range" id="attrs" min="2" max="8" value="4">
            </div>
            <div class="control-group">
                <label>Homophily Strength: <span id="homophilyVal">0.7</span></label>
                <input type="range" id="homophily" min="0" max="1" step="0.05" value="0.7">
            </div>
            <div class="control-group">
                <label>Move Speed: <span id="speedVal">2</span></label>
                <input type="range" id="speed" min="0.5" max="5" step="0.5" value="2">
            </div>
            <div class="control-group">
                <label>Personal Space: <span id="spaceVal">30</span></label>
                <input type="range" id="space" min="15" max="60" value="30">
            </div>
            
            <button id="reset">New Party</button>
            <button id="pause">Pause</button>
            <button id="shuffle">Shuffle Positions</button>
            
            <div class="stats">
                <div>Clusters: <span id="clusters">0</span></div>
                <div>Avg Cluster Size: <span id="avgSize">0</span></div>
                <div>Segregation Index: <span id="segregation">0</span></div>
                <div>Time: <span id="time">0</span>s</div>
            </div>
            
            <p class="description"><strong>Homophily:</strong> The tendency for people to seek out similar others. Higher values = stronger clustering by type.</p>
            
            <div class="legend" id="legend"></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, agents = [], paused = false, startTime = 0;
        
        const typeColors = [
            '#ef4444', '#f97316', '#eab308', '#22c55e', 
            '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'
        ];
        
        let params = {
            guestCount: 100,
            attrCount: 4,
            homophily: 0.7,
            speed: 2,
            personalSpace: 30
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }
        
        function init() {
            resize();
            agents = [];
            startTime = Date.now();
            
            // Create agents with random types
            for (let i = 0; i < params.guestCount; i++) {
                agents.push({
                    x: 50 + Math.random() * (W - 100),
                    y: 50 + Math.random() * (H - 100),
                    vx: 0,
                    vy: 0,
                    type: Math.floor(Math.random() * params.attrCount),
                    radius: 8,
                    targetX: null,
                    targetY: null
                });
            }
            
            updateLegend();
            updateStats();
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '<strong>Guest Types:</strong><br>';
            for (let i = 0; i < params.attrCount; i++) {
                legend.innerHTML += `<div class="legend-item"><div class="legend-color" style="background:${typeColors[i]}"></div>Type ${i + 1}</div>`;
            }
        }
        
        function findNearby(agent, radius) {
            const nearby = [];
            for (const other of agents) {
                if (other === agent) continue;
                const dx = other.x - agent.x;
                const dy = other.y - agent.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    nearby.push({ agent: other, dist, dx, dy });
                }
            }
            return nearby;
        }
        
        function step() {
            const socialRadius = 100;
            
            for (const agent of agents) {
                let fx = 0, fy = 0;
                
                const nearby = findNearby(agent, socialRadius);
                
                for (const { agent: other, dist, dx, dy } of nearby) {
                    const same = other.type === agent.type;
                    
                    // Attraction to similar, slight repulsion from different
                    if (same) {
                        // Attract toward similar types (homophily)
                        const attract = params.homophily * 0.1;
                        fx += (dx / dist) * attract;
                        fy += (dy / dist) * attract;
                    } else {
                        // Slight avoidance of different types
                        const avoid = params.homophily * 0.03;
                        fx -= (dx / dist) * avoid;
                        fy -= (dy / dist) * avoid;
                    }
                    
                    // Personal space - repel if too close
                    if (dist < params.personalSpace) {
                        const repel = (params.personalSpace - dist) / params.personalSpace * 0.5;
                        fx -= (dx / dist) * repel;
                        fy -= (dy / dist) * repel;
                    }
                }
                
                // Random wandering
                fx += (Math.random() - 0.5) * 0.1;
                fy += (Math.random() - 0.5) * 0.1;
                
                // Apply forces
                agent.vx += fx;
                agent.vy += fy;
                
                // Damping
                agent.vx *= 0.9;
                agent.vy *= 0.9;
                
                // Speed limit
                const speed = Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy);
                if (speed > params.speed) {
                    agent.vx = (agent.vx / speed) * params.speed;
                    agent.vy = (agent.vy / speed) * params.speed;
                }
                
                // Move
                agent.x += agent.vx;
                agent.y += agent.vy;
                
                // Boundaries
                const margin = 40;
                if (agent.x < margin) { agent.x = margin; agent.vx *= -0.5; }
                if (agent.x > W - margin) { agent.x = W - margin; agent.vx *= -0.5; }
                if (agent.y < margin) { agent.y = margin; agent.vy *= -0.5; }
                if (agent.y > H - margin) { agent.y = H - margin; agent.vy *= -0.5; }
            }
            
            updateStats();
        }
        
        function findClusters() {
            const clusterDist = params.personalSpace * 2;
            const visited = new Set();
            const clusters = [];
            
            for (let i = 0; i < agents.length; i++) {
                if (visited.has(i)) continue;
                
                const cluster = [];
                const stack = [i];
                
                while (stack.length > 0) {
                    const idx = stack.pop();
                    if (visited.has(idx)) continue;
                    visited.add(idx);
                    cluster.push(agents[idx]);
                    
                    // Find neighbors
                    for (let j = 0; j < agents.length; j++) {
                        if (visited.has(j)) continue;
                        const dx = agents[j].x - agents[idx].x;
                        const dy = agents[j].y - agents[idx].y;
                        if (Math.sqrt(dx * dx + dy * dy) < clusterDist) {
                            stack.push(j);
                        }
                    }
                }
                
                clusters.push(cluster);
            }
            
            return clusters;
        }
        
        function calculateSegregation() {
            // Segregation: how much do same types cluster together vs random?
            let sameTypeNeighbors = 0;
            let totalNeighbors = 0;
            const neighborDist = params.personalSpace * 2;
            
            for (const agent of agents) {
                const nearby = findNearby(agent, neighborDist);
                for (const { agent: other } of nearby) {
                    totalNeighbors++;
                    if (other.type === agent.type) {
                        sameTypeNeighbors++;
                    }
                }
            }
            
            if (totalNeighbors === 0) return 0;
            
            const observed = sameTypeNeighbors / totalNeighbors;
            const expected = 1 / params.attrCount;
            
            // Normalize: 0 = random mixing, 1 = complete segregation
            return Math.max(0, (observed - expected) / (1 - expected));
        }
        
        function updateStats() {
            const clusters = findClusters();
            const avgSize = agents.length / clusters.length;
            const segregation = calculateSegregation();
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            
            document.getElementById('clusters').textContent = clusters.length;
            document.getElementById('avgSize').textContent = avgSize.toFixed(1);
            document.getElementById('segregation').textContent = (segregation * 100).toFixed(1) + '%';
            document.getElementById('time').textContent = elapsed;
        }
        
        function draw() {
            // Party room background
            ctx.fillStyle = '#1a1625';
            ctx.fillRect(0, 0, W, H);
            
            // Dance floor pattern
            const tileSize = 60;
            for (let x = 0; x < W; x += tileSize) {
                for (let y = 0; y < H; y += tileSize) {
                    const dark = ((x / tileSize) + (y / tileSize)) % 2 === 0;
                    ctx.fillStyle = dark ? '#1e1930' : '#241f3a';
                    ctx.fillRect(x, y, tileSize, tileSize);
                }
            }
            
            // Room boundary
            ctx.strokeStyle = '#4a4060';
            ctx.lineWidth = 3;
            ctx.strokeRect(30, 30, W - 60, H - 60);
            
            // Disco lights effect
            const time = Date.now() / 1000;
            for (let i = 0; i < 3; i++) {
                const angle = time * 0.5 + i * Math.PI * 2 / 3;
                const cx = W / 2 + Math.cos(angle) * 150;
                const cy = H / 2 + Math.sin(angle) * 100;
                const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 200);
                gradient.addColorStop(0, `hsla(${(i * 120 + time * 30) % 360}, 70%, 50%, 0.1)`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, W, H);
            }
            
            // Draw social connections
            ctx.lineWidth = 0.5;
            for (const agent of agents) {
                const nearby = findNearby(agent, params.personalSpace * 2);
                for (const { agent: other, dist } of nearby) {
                    if (other.type === agent.type) {
                        const alpha = Math.max(0, 1 - dist / (params.personalSpace * 2)) * 0.3;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(agent.x, agent.y);
                        ctx.lineTo(other.x, other.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw agents
            for (const agent of agents) {
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(agent.x + 2, agent.y + 4, agent.radius, agent.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.fillStyle = typeColors[agent.type];
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, agent.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(agent.x - 2, agent.y - 2, agent.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Title
            ctx.fillStyle = '#ec4899';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Party - Homophily Clustering', 40, 55);
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    for (let i = 0; i < 2; i++) step();
                }
            }, 16);
        }
        
        // Event listeners
        document.getElementById('guests').addEventListener('input', e => {
            params.guestCount = +e.target.value;
            document.getElementById('guestsVal').textContent = params.guestCount;
        });
        document.getElementById('attrs').addEventListener('input', e => {
            params.attrCount = +e.target.value;
            document.getElementById('attrsVal').textContent = params.attrCount;
        });
        document.getElementById('homophily').addEventListener('input', e => {
            params.homophily = +e.target.value;
            document.getElementById('homophilyVal').textContent = params.homophily.toFixed(2);
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
        });
        document.getElementById('space').addEventListener('input', e => {
            params.personalSpace = +e.target.value;
            document.getElementById('spaceVal').textContent = params.personalSpace;
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('shuffle').addEventListener('click', () => {
            for (const agent of agents) {
                agent.x = 50 + Math.random() * (W - 100);
                agent.y = 50 + Math.random() * (H - 100);
                agent.vx = 0;
                agent.vy = 0;
            }
        });
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
