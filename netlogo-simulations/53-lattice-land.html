<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lattice Land - Pattern Generator - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0a0f; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        #simCanvas { width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #a78bfa; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #7c3aed; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #6d28d9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #a78bfa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .preset-btn { width: 48%; display: inline-block; padding: 6px; margin-bottom: 6px; font-size: 0.75rem; }
        .preset-btn:nth-child(odd) { margin-right: 4%; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Lattice Land</h1>
            <p class="description">Explore emergent patterns from simple lattice rules. Different neighborhood structures create unique world dynamics.</p>

            <div class="control-group">
                <label>Rule Set:</label>
                <select id="ruleset">
                    <option value="life">Game of Life</option>
                    <option value="seeds">Seeds</option>
                    <option value="daynight">Day & Night</option>
                    <option value="highlife">HighLife</option>
                    <option value="maze">Maze</option>
                    <option value="anneal">Anneal</option>
                    <option value="custom">Custom Rule</option>
                </select>
            </div>
            <div class="control-group">
                <label>Neighborhood:</label>
                <select id="neighborhood">
                    <option value="moore">Moore (8 neighbors)</option>
                    <option value="vonneumann">Von Neumann (4 neighbors)</option>
                    <option value="hex">Hexagonal (6 neighbors)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Grid Size: <span id="sizeVal">100</span></label>
                <input type="range" id="size" min="50" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Speed: <span id="speedVal">10</span> gen/s</label>
                <input type="range" id="speed" min="1" max="30" value="10">
            </div>
            <div class="control-group">
                <label>Initial Density: <span id="densityVal">30</span>%</label>
                <input type="range" id="density" min="5" max="70" value="30">
            </div>

            <div class="control-group" id="customRules" style="display:none;">
                <label>Birth Rule (neighbors to be born):</label>
                <input type="text" id="birthRule" value="3" style="width:100%; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:4px;">
                <label style="margin-top:8px;">Survive Rule (neighbors to survive):</label>
                <input type="text" id="surviveRule" value="2,3" style="width:100%; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:4px;">
            </div>

            <button id="reset">Random Seed</button>
            <button id="clear">Clear Grid</button>
            <button id="toggle">Pause</button>

            <p class="description" style="margin-top:10px;"><strong>Presets:</strong></p>
            <button class="preset-btn" data-pattern="glider">Glider</button>
            <button class="preset-btn" data-pattern="blinker">Blinker</button>
            <button class="preset-btn" data-pattern="pulsar">Pulsar</button>
            <button class="preset-btn" data-pattern="gosper">Gosper Gun</button>
            <button class="preset-btn" data-pattern="rpentomino">R-Pentomino</button>
            <button class="preset-btn" data-pattern="acorn">Acorn</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Population: <span id="population">0</span></div>
                <div>Density: <span id="currentDensity">0</span>%</div>
                <div>Rule: <span id="ruleDisplay">B3/S23</span></div>
            </div>

            <p class="description"><strong>Click</strong> to draw/erase cells<br><strong>Drag</strong> to paint patterns</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        let W, H, cellSize, cols, rows;
        let grid, nextGrid;
        let generation = 0;
        let running = true;
        let lastUpdate = 0;
        let isDrawing = false;
        let drawValue = 1;

        const rules = {
            life: { birth: [3], survive: [2, 3] },
            seeds: { birth: [2], survive: [] },
            daynight: { birth: [3, 6, 7, 8], survive: [3, 4, 6, 7, 8] },
            highlife: { birth: [3, 6], survive: [2, 3] },
            maze: { birth: [3], survive: [1, 2, 3, 4, 5] },
            anneal: { birth: [4, 6, 7, 8], survive: [3, 5, 6, 7, 8] },
            custom: { birth: [3], survive: [2, 3] }
        };

        let params = {
            ruleset: 'life',
            neighborhood: 'moore',
            size: 100,
            speed: 10,
            density: 30
        };

        const patterns = {
            glider: [[0,1,0],[0,0,1],[1,1,1]],
            blinker: [[1,1,1]],
            pulsar: [
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0]
            ],
            gosper: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            rpentomino: [[0,1,1],[1,1,0],[0,1,0]],
            acorn: [[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[1,1,0,0,1,1,1]]
        };

        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;

            cellSize = Math.floor(Math.min(W, H) / params.size);
            cols = Math.floor(W / cellSize);
            rows = Math.floor(H / cellSize);
        }

        function createGrid() {
            grid = [];
            nextGrid = [];
            for (let y = 0; y < rows; y++) {
                grid[y] = [];
                nextGrid[y] = [];
                for (let x = 0; x < cols; x++) {
                    grid[y][x] = 0;
                    nextGrid[y][x] = 0;
                }
            }
        }

        function randomize() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid[y][x] = Math.random() < params.density / 100 ? 1 : 0;
                }
            }
            generation = 0;
        }

        function getNeighbors(x, y) {
            let count = 0;

            if (params.neighborhood === 'moore') {
                // 8 neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + cols) % cols;
                        const ny = (y + dy + rows) % rows;
                        count += grid[ny][nx];
                    }
                }
            } else if (params.neighborhood === 'vonneumann') {
                // 4 neighbors (orthogonal only)
                const offsets = [[0,-1], [1,0], [0,1], [-1,0]];
                for (const [dx, dy] of offsets) {
                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    count += grid[ny][nx];
                }
            } else if (params.neighborhood === 'hex') {
                // 6 neighbors (hexagonal)
                const even = y % 2 === 0;
                const offsets = even ?
                    [[-1,-1], [0,-1], [-1,0], [1,0], [-1,1], [0,1]] :
                    [[0,-1], [1,-1], [-1,0], [1,0], [0,1], [1,1]];
                for (const [dx, dy] of offsets) {
                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    count += grid[ny][nx];
                }
            }

            return count;
        }

        function step() {
            const rule = rules[params.ruleset];

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const neighbors = getNeighbors(x, y);
                    const alive = grid[y][x];

                    if (alive) {
                        nextGrid[y][x] = rule.survive.includes(neighbors) ? 1 : 0;
                    } else {
                        nextGrid[y][x] = rule.birth.includes(neighbors) ? 1 : 0;
                    }
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];
            generation++;
        }

        function placePattern(pattern, centerX, centerY) {
            const h = pattern.length;
            const w = pattern[0].length;
            const startX = Math.floor(centerX - w / 2);
            const startY = Math.floor(centerY - h / 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const gx = (startX + x + cols) % cols;
                    const gy = (startY + y + rows) % rows;
                    grid[gy][gx] = pattern[y][x];
                }
            }
        }

        function updateStats() {
            let pop = 0;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    pop += grid[y][x];
                }
            }

            const rule = rules[params.ruleset];
            const ruleStr = `B${rule.birth.join('')}/S${rule.survive.join('')}`;

            document.getElementById('generation').textContent = generation;
            document.getElementById('population').textContent = pop;
            document.getElementById('currentDensity').textContent = (pop / (rows * cols) * 100).toFixed(1);
            document.getElementById('ruleDisplay').textContent = ruleStr;
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, W, H);

            // Draw cells
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x]) {
                        // Color based on neighborhood count
                        const neighbors = getNeighbors(x, y);
                        const hue = 260 + neighbors * 10;
                        ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                    }
                }
            }

            // Draw grid lines if cells are large enough
            if (cellSize > 4) {
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= cols; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, rows * cellSize);
                    ctx.stroke();
                }
                for (let y = 0; y <= rows; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(cols * cellSize, y * cellSize);
                    ctx.stroke();
                }
            }
        }

        function animate(timestamp) {
            if (running && timestamp - lastUpdate > 1000 / params.speed) {
                step();
                lastUpdate = timestamp;
            }

            updateStats();
            draw();
            requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', e => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                drawValue = grid[y][x] ? 0 : 1;
                grid[y][x] = drawValue;
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                grid[y][x] = drawValue;
            }
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // Controls
        document.getElementById('ruleset').addEventListener('change', e => {
            params.ruleset = e.target.value;
            document.getElementById('customRules').style.display =
                e.target.value === 'custom' ? 'block' : 'none';
        });

        document.getElementById('neighborhood').addEventListener('change', e => {
            params.neighborhood = e.target.value;
        });

        document.getElementById('size').addEventListener('input', e => {
            params.size = +e.target.value;
            document.getElementById('sizeVal').textContent = params.size;
        });

        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
        });

        document.getElementById('density').addEventListener('input', e => {
            params.density = +e.target.value;
            document.getElementById('densityVal').textContent = params.density;
        });

        document.getElementById('birthRule').addEventListener('change', e => {
            rules.custom.birth = e.target.value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
        });

        document.getElementById('surviveRule').addEventListener('change', e => {
            rules.custom.survive = e.target.value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
        });

        document.getElementById('reset').addEventListener('click', () => {
            resize();
            createGrid();
            randomize();
        });

        document.getElementById('clear').addEventListener('click', () => {
            createGrid();
            generation = 0;
        });

        document.getElementById('toggle').addEventListener('click', e => {
            running = !running;
            e.target.textContent = running ? 'Pause' : 'Play';
        });

        // Pattern buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const patternName = btn.dataset.pattern;
                if (patterns[patternName]) {
                    createGrid();
                    generation = 0;
                    placePattern(patterns[patternName], Math.floor(cols / 2), Math.floor(rows / 2));
                }
            });
        });

        window.addEventListener('resize', () => {
            resize();
            createGrid();
            randomize();
        });

        resize();
        createGrid();
        randomize();
        animate(0);
    </script>
</body>
</html>
