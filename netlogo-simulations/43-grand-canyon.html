<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Canyon Formation - Erosion Simulation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        #simCanvas { width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #f97316; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #ea580c; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #c2410c; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f97316; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .layer-legend { font-size: 0.65rem; margin-top: 10px; }
        .layer-item { display: flex; align-items: center; margin: 3px 0; }
        .layer-color { width: 20px; height: 12px; margin-right: 8px; border-radius: 2px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Grand Canyon Formation</h1>
            <p class="description">Watch millions of years of erosion carve a canyon through layered rock. River power and rock hardness shape the morphology.</p>
            
            <div class="control-group">
                <label>Erosion Rate: <span id="erosionVal">1.0</span></label>
                <input type="range" id="erosion" min="0.2" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Water Volume: <span id="waterVal">1.0</span></label>
                <input type="range" id="water" min="0.5" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Weathering Rate: <span id="weatherVal">0.3</span></label>
                <input type="range" id="weather" min="0" max="1" step="0.05" value="0.3">
            </div>
            <div class="control-group">
                <label>Simulation Speed: <span id="speedVal">10</span> kya/step</label>
                <input type="range" id="speed" min="1" max="50" value="10">
            </div>
            
            <button id="reset">Reset Terrain</button>
            <button id="pause">Pause</button>
            <button id="flood">Major Flood Event</button>
            
            <div class="stats">
                <div>Time: <span id="time">0</span> million years</div>
                <div>Canyon Depth: <span id="depth">0</span> m</div>
                <div>Canyon Width: <span id="width">0</span> m</div>
                <div>Material Removed: <span id="removed">0</span> km³</div>
            </div>
            
            <p class="description"><strong>Geology:</strong> Harder layers (limestone, sandstone) resist erosion, forming cliffs. Softer shale erodes faster, creating slopes.</p>
            
            <div class="layer-legend">
                <strong>Rock Layers:</strong>
                <div class="layer-item"><div class="layer-color" style="background:#d4a574"></div>Kaibab Limestone</div>
                <div class="layer-item"><div class="layer-color" style="background:#c9956c"></div>Toroweap Formation</div>
                <div class="layer-item"><div class="layer-color" style="background:#e8d4b8"></div>Coconino Sandstone</div>
                <div class="layer-item"><div class="layer-color" style="background:#8b7355"></div>Hermit Shale</div>
                <div class="layer-item"><div class="layer-color" style="background:#cd853f"></div>Supai Group</div>
                <div class="layer-item"><div class="layer-color" style="background:#a0522d"></div>Redwall Limestone</div>
                <div class="layer-item"><div class="layer-color" style="background:#696969"></div>Muav Limestone</div>
                <div class="layer-item"><div class="layer-color" style="background:#4a4a4a"></div>Vishnu Schist (basement)</div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, terrain = [], paused = false;
        let time = 0;
        let totalRemoved = 0;
        
        const layers = [
            { name: 'Kaibab', color: '#d4a574', hardness: 0.8, thickness: 100 },
            { name: 'Toroweap', color: '#c9956c', hardness: 0.6, thickness: 80 },
            { name: 'Coconino', color: '#e8d4b8', hardness: 0.7, thickness: 100 },
            { name: 'Hermit', color: '#8b7355', hardness: 0.3, thickness: 80 },
            { name: 'Supai', color: '#cd853f', hardness: 0.5, thickness: 150 },
            { name: 'Redwall', color: '#a0522d', hardness: 0.9, thickness: 150 },
            { name: 'Muav', color: '#696969', hardness: 0.7, thickness: 100 },
            { name: 'Vishnu', color: '#4a4a4a', hardness: 1.0, thickness: 200 }
        ];
        
        let params = {
            erosionRate: 1.0,
            waterVolume: 1.0,
            weathering: 0.3,
            speed: 10 // thousand years per step
        };
        
        const gridWidth = 200;
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }
        
        function init() {
            resize();
            terrain = [];
            time = 0;
            totalRemoved = 0;
            
            // Build initial terrain with horizontal layers and slight random variation
            const totalHeight = layers.reduce((sum, l) => sum + l.thickness, 0);
            
            for (let x = 0; x < gridWidth; x++) {
                const column = [];
                let currentY = 0;
                
                for (const layer of layers) {
                    const layerVariation = (Math.sin(x * 0.1) * 10 + Math.random() * 5);
                    const adjustedThickness = layer.thickness + layerVariation;
                    
                    for (let y = 0; y < adjustedThickness; y++) {
                        column.push({
                            layer: layer,
                            eroded: false,
                            weathered: 0
                        });
                    }
                }
                
                terrain.push(column);
            }
            
            updateStats();
        }
        
        function getTerrainHeight(x) {
            if (x < 0 || x >= terrain.length) return 0;
            let height = 0;
            for (let y = 0; y < terrain[x].length; y++) {
                if (!terrain[x][y].eroded) height++;
            }
            return height;
        }
        
        function erodePoint(x, power) {
            if (x < 0 || x >= terrain.length) return 0;
            
            let eroded = 0;
            for (let y = terrain[x].length - 1; y >= 0; y--) {
                if (!terrain[x][y].eroded) {
                    const cell = terrain[x][y];
                    const resistance = cell.layer.hardness * (1 - cell.weathered * 0.5);
                    
                    if (power > resistance * 0.5) {
                        cell.eroded = true;
                        eroded++;
                        power *= 0.8; // Power diminishes with depth
                        
                        if (eroded > power * 2) break;
                    } else {
                        break;
                    }
                }
            }
            
            return eroded;
        }
        
        function step() {
            time += params.speed;
            
            // River erosion - strongest in center
            const centerX = Math.floor(gridWidth / 2);
            const riverWidth = Math.floor(10 + params.waterVolume * 15);
            
            for (let dx = -riverWidth; dx <= riverWidth; dx++) {
                const x = centerX + dx;
                if (x < 0 || x >= terrain.length) continue;
                
                // Power decreases toward edges
                const distFromCenter = Math.abs(dx);
                const power = params.erosionRate * params.waterVolume * 
                    (1 - (distFromCenter / riverWidth) * 0.7);
                
                // Add some randomness
                if (Math.random() < 0.7) {
                    const removed = erodePoint(x, power);
                    totalRemoved += removed;
                }
            }
            
            // Weathering of exposed surfaces
            for (let x = 0; x < terrain.length; x++) {
                for (let y = terrain[x].length - 1; y >= 0; y--) {
                    if (!terrain[x][y].eroded) {
                        // Check if exposed (adjacent to eroded cell)
                        let exposed = y === terrain[x].length - 1;
                        if (!exposed && x > 0) {
                            const adjY = y;
                            if (adjY < terrain[x-1].length && terrain[x-1][adjY].eroded) exposed = true;
                        }
                        if (!exposed && x < terrain.length - 1) {
                            const adjY = y;
                            if (adjY < terrain[x+1].length && terrain[x+1][adjY].eroded) exposed = true;
                        }
                        
                        if (exposed) {
                            terrain[x][y].weathered += params.weathering * 0.01;
                            terrain[x][y].weathered = Math.min(1, terrain[x][y].weathered);
                            
                            // Soft layers collapse when weathered
                            if (terrain[x][y].weathered > 0.5 && 
                                terrain[x][y].layer.hardness < 0.5 &&
                                Math.random() < 0.1) {
                                terrain[x][y].eroded = true;
                                totalRemoved++;
                            }
                        }
                        break;
                    }
                }
            }
            
            // Lateral erosion (undercutting)
            for (let x = 1; x < terrain.length - 1; x++) {
                const leftH = getTerrainHeight(x - 1);
                const rightH = getTerrainHeight(x + 1);
                const myH = getTerrainHeight(x);
                
                // If neighbors are lower, tendency to collapse
                if (myH > leftH + 20 || myH > rightH + 20) {
                    if (Math.random() < 0.05 * params.weathering) {
                        erodePoint(x, 0.5);
                    }
                }
            }
            
            updateStats();
        }
        
        function majorFlood() {
            const centerX = Math.floor(gridWidth / 2);
            const floodWidth = 30;
            
            for (let dx = -floodWidth; dx <= floodWidth; dx++) {
                const x = centerX + dx;
                if (x < 0 || x >= terrain.length) continue;
                
                const power = 3 * (1 - Math.abs(dx) / floodWidth);
                const removed = erodePoint(x, power);
                totalRemoved += removed;
            }
        }
        
        function updateStats() {
            const centerX = Math.floor(gridWidth / 2);
            const originalHeight = layers.reduce((sum, l) => sum + l.thickness, 0);
            const currentHeight = getTerrainHeight(centerX);
            const depth = originalHeight - currentHeight;
            
            // Calculate width at half depth
            let width = 0;
            const halfDepthHeight = originalHeight - depth / 2;
            for (let x = 0; x < terrain.length; x++) {
                if (getTerrainHeight(x) < halfDepthHeight) width++;
            }
            
            document.getElementById('time').textContent = (time / 1000).toFixed(1);
            document.getElementById('depth').textContent = Math.round(depth * 5); // Scale to meters
            document.getElementById('width').textContent = Math.round(width * 80); // Scale to meters
            document.getElementById('removed').textContent = (totalRemoved * 0.0001).toFixed(2);
        }
        
        function draw() {
            // Sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, H * 0.3);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(1, '#e0f0ff');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, W, H * 0.3);
            
            // Draw terrain
            const scaleX = W / gridWidth;
            const maxHeight = layers.reduce((sum, l) => sum + l.thickness, 0);
            const scaleY = (H * 0.8) / maxHeight;
            const baseY = H * 0.9;
            
            for (let x = 0; x < terrain.length; x++) {
                for (let y = 0; y < terrain[x].length; y++) {
                    const cell = terrain[x][y];
                    if (cell.eroded) continue;
                    
                    const px = x * scaleX;
                    const py = baseY - y * scaleY;
                    
                    // Darken weathered areas
                    let color = cell.layer.color;
                    if (cell.weathered > 0) {
                        const darken = Math.floor(cell.weathered * 40);
                        const r = parseInt(color.slice(1, 3), 16) - darken;
                        const g = parseInt(color.slice(3, 5), 16) - darken;
                        const b = parseInt(color.slice(5, 7), 16) - darken;
                        color = `rgb(${Math.max(0, r)}, ${Math.max(0, g)}, ${Math.max(0, b)})`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(px, py - scaleY, scaleX + 1, scaleY + 1);
                }
            }
            
            // Draw river
            const riverCenterX = W / 2;
            ctx.fillStyle = 'rgba(64, 164, 223, 0.8)';
            const riverY = baseY - getTerrainHeight(Math.floor(gridWidth / 2)) * scaleY;
            ctx.fillRect(riverCenterX - 10 * params.waterVolume, riverY, 20 * params.waterVolume, H - riverY);
            
            // River bed rocks
            ctx.fillStyle = '#444';
            for (let i = 0; i < 10; i++) {
                const rx = riverCenterX - 8 + Math.random() * 16;
                const ry = riverY + 5 + Math.random() * (H - riverY - 10);
                ctx.beginPath();
                ctx.ellipse(rx, ry, 2 + Math.random() * 4, 1 + Math.random() * 2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Grand Canyon Formation - ${(time / 1000).toFixed(1)} Million Years`, 20, 30);
            
            // Scale bar
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            const barLength = 100;
            const barY = H - 20;
            ctx.fillRect(20, barY - 2, barLength, 4);
            ctx.fillText(`${Math.round(barLength / scaleX * 80)} m`, 20, barY + 15);
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    step();
                }
            }, 50);
        }
        
        // Event listeners
        document.getElementById('erosion').addEventListener('input', e => {
            params.erosionRate = +e.target.value;
            document.getElementById('erosionVal').textContent = params.erosionRate.toFixed(1);
        });
        document.getElementById('water').addEventListener('input', e => {
            params.waterVolume = +e.target.value;
            document.getElementById('waterVal').textContent = params.waterVolume.toFixed(1);
        });
        document.getElementById('weather').addEventListener('input', e => {
            params.weathering = +e.target.value;
            document.getElementById('weatherVal').textContent = params.weathering.toFixed(2);
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('flood').addEventListener('click', majorFlood);
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
