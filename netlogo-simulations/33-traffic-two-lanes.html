<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Two Lanes - NetLogo Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 320px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ff6b35 0%, #f7c59f 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #888;
            font-size: 0.95em;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #bbb;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .control-group .value {
            text-align: right;
            font-size: 0.9em;
            color: #ff6b35;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255,107,53,0.3);
        }
        .stats {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .stats h3 {
            margin-bottom: 12px;
            color: #ff6b35;
            font-size: 1em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #f7c59f;
            font-weight: 600;
        }
        .info-box {
            background: rgba(255,107,53,0.1);
            border-left: 3px solid #ff6b35;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85em;
            border-radius: 0 8px 8px 0;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8em;
        }
        .legend-color {
            width: 16px;
            height: 12px;
            border-radius: 3px;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: color 0.3s;
        }
        .back-link:hover {
            color: #ff6b35;
        }
        .chart-container {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
        }
        .chart-container h4 {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
        }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <a href="index.html" class="back-link">‚Üê Back to Simulations</a>

            <div class="info-box">
                <strong>Traffic Two Lanes</strong><br>
                Models two-lane highway traffic with lane-changing behavior. Observe how lane changes affect throughput and how phantom jams emerge.
            </div>

            <div class="control-group">
                <label>Number of Cars: <span class="value" id="numCarsVal">50</span></label>
                <input type="range" id="numCars" min="10" max="150" value="50">
            </div>

            <div class="control-group">
                <label>Max Speed: <span class="value" id="maxSpeedVal">5</span></label>
                <input type="range" id="maxSpeed" min="1" max="10" value="5">
            </div>

            <div class="control-group">
                <label>Acceleration: <span class="value" id="accelVal">0.3</span></label>
                <input type="range" id="accel" min="0.1" max="1" step="0.1" value="0.3">
            </div>

            <div class="control-group">
                <label>Deceleration: <span class="value" id="decelVal">0.5</span></label>
                <input type="range" id="decel" min="0.1" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>Lane Change Threshold: <span class="value" id="laneThreshVal">2.0</span></label>
                <input type="range" id="laneThresh" min="0.5" max="5" step="0.5" value="2.0">
            </div>

            <div class="control-group">
                <label>Safe Gap: <span class="value" id="safeGapVal">3</span></label>
                <input type="range" id="safeGap" min="1" max="8" value="3">
            </div>

            <button class="btn-primary" id="startBtn">Start</button>
            <button class="btn-secondary" id="resetBtn">Reset</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>

            <div class="stats">
                <h3>Traffic Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Average Speed (Lane 1):</span>
                    <span class="stat-value" id="avgSpeed1">0.0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Average Speed (Lane 2):</span>
                    <span class="stat-value" id="avgSpeed2">0.0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Throughput/min:</span>
                    <span class="stat-value" id="throughput">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Lane Changes:</span>
                    <span class="stat-value" id="laneChanges">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Traffic Jams:</span>
                    <span class="stat-value" id="jams">0</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff00;"></div>
                    Fast
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffff00;"></div>
                    Medium
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6600;"></div>
                    Slow
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0000;"></div>
                    Stopped
                </div>
            </div>

            <div class="chart-container">
                <h4>Speed Distribution</h4>
                <canvas id="chartCanvas" width="280" height="100"></canvas>
            </div>
        </aside>

        <main class="main">
            <header>
                <h1>Traffic Two Lanes</h1>
                <p class="subtitle">Two-lane highway with lane-changing dynamics and throughput analysis</p>
            </header>
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
        </main>
    </div>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Traffic Two Lanes - NetLogo Simulation</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        // Canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = Math.min(container.clientWidth - 40, 1000);
            canvas.height = 300;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let cars = [];
        let running = false;
        let animationId = null;
        let throughputCount = 0;
        let laneChangeCount = 0;
        let jamCount = 0;
        let lastThroughputTime = Date.now();
        let speedHistory = [];

        // Road parameters
        const roadLength = 200;
        const laneWidth = 60;
        const carLength = 4;

        // Controls
        const controls = {
            numCars: document.getElementById('numCars'),
            maxSpeed: document.getElementById('maxSpeed'),
            accel: document.getElementById('accel'),
            decel: document.getElementById('decel'),
            laneThresh: document.getElementById('laneThresh'),
            safeGap: document.getElementById('safeGap')
        };

        // Update value displays
        Object.keys(controls).forEach(key => {
            const input = controls[key];
            const valueSpan = document.getElementById(key + 'Val');
            input.addEventListener('input', () => {
                valueSpan.textContent = input.value;
            });
        });

        // Car class
        class Car {
            constructor(lane, position) {
                this.lane = lane; // 0 or 1
                this.position = position;
                this.speed = Math.random() * 2 + 1;
                this.targetLane = lane;
                this.laneChangeProgress = 0;
                this.patience = Math.random() * 0.5 + 0.5; // Patience factor for lane changes
            }

            getColor() {
                const maxSpeed = parseFloat(controls.maxSpeed.value);
                const ratio = this.speed / maxSpeed;
                if (ratio > 0.7) return '#00ff00';
                if (ratio > 0.4) return '#ffff00';
                if (ratio > 0.1) return '#ff6600';
                return '#ff0000';
            }
        }

        // Initialize cars
        function initCars() {
            cars = [];
            const numCars = parseInt(controls.numCars.value);
            const positions = [];

            for (let i = 0; i < numCars; i++) {
                const lane = Math.random() < 0.5 ? 0 : 1;
                let position;
                let attempts = 0;

                // Find non-overlapping position
                do {
                    position = Math.random() * roadLength;
                    attempts++;
                } while (attempts < 100 && positions.some(p =>
                    p.lane === lane && Math.abs(p.pos - position) < carLength * 2
                ));

                positions.push({ lane, pos: position });
                cars.push(new Car(lane, position));
            }

            throughputCount = 0;
            laneChangeCount = 0;
            jamCount = 0;
            lastThroughputTime = Date.now();
            speedHistory = [];
        }

        // Get car ahead in same lane
        function getCarAhead(car, laneCars) {
            let minDist = Infinity;
            let carAhead = null;

            for (const other of laneCars) {
                if (other === car) continue;
                let dist = (other.position - car.position + roadLength) % roadLength;
                if (dist > 0 && dist < minDist) {
                    minDist = dist;
                    carAhead = other;
                }
            }
            return { car: carAhead, distance: minDist };
        }

        // Check if lane change is safe
        function canChangeLane(car, targetLane) {
            const safeGap = parseFloat(controls.safeGap.value);
            const targetLaneCars = cars.filter(c => c.lane === targetLane);

            for (const other of targetLaneCars) {
                const dist = Math.abs((other.position - car.position + roadLength / 2) % roadLength - roadLength / 2);
                if (dist < safeGap * 2) {
                    return false;
                }
            }
            return true;
        }

        // Evaluate lane benefit
        function evaluateLaneBenefit(car) {
            const currentLaneCars = cars.filter(c => c.lane === car.lane);
            const otherLane = 1 - car.lane;
            const otherLaneCars = cars.filter(c => c.lane === otherLane);

            const { distance: currentDist } = getCarAhead(car, currentLaneCars);

            // Calculate potential gap in other lane
            const tempCar = { ...car, lane: otherLane, position: car.position };
            const { distance: otherDist } = getCarAhead(tempCar, otherLaneCars);

            return otherDist - currentDist;
        }

        // Update simulation
        function update() {
            const maxSpeed = parseFloat(controls.maxSpeed.value);
            const accel = parseFloat(controls.accel.value);
            const decel = parseFloat(controls.decel.value);
            const laneThreshold = parseFloat(controls.laneThresh.value);
            const safeGap = parseFloat(controls.safeGap.value);

            // Update each car
            for (const car of cars) {
                const laneCars = cars.filter(c => c.lane === car.lane);
                const { car: carAhead, distance: distAhead } = getCarAhead(car, laneCars);

                // Lane change logic
                if (car.laneChangeProgress === 0) {
                    const benefit = evaluateLaneBenefit(car);
                    const otherLane = 1 - car.lane;

                    // Consider lane change if benefit is above threshold and it's safe
                    if (benefit > laneThreshold * car.patience && canChangeLane(car, otherLane)) {
                        // Also check if we're being slowed down
                        if (distAhead < safeGap * 3 && car.speed < maxSpeed * 0.8) {
                            car.targetLane = otherLane;
                            car.laneChangeProgress = 0.01;
                            laneChangeCount++;
                        }
                    }
                }

                // Execute lane change
                if (car.laneChangeProgress > 0 && car.laneChangeProgress < 1) {
                    car.laneChangeProgress += 0.1;
                    if (car.laneChangeProgress >= 1) {
                        car.lane = car.targetLane;
                        car.laneChangeProgress = 0;
                    }
                }

                // Speed adjustment based on car ahead
                const actualLaneCars = cars.filter(c => c.lane === car.lane);
                const { distance: actualDist } = getCarAhead(car, actualLaneCars);

                if (actualDist < safeGap) {
                    // Emergency brake
                    car.speed = Math.max(0, car.speed - decel * 2);
                } else if (actualDist < safeGap * 2) {
                    // Slow down
                    car.speed = Math.max(0, car.speed - decel);
                } else if (actualDist < safeGap * 4) {
                    // Match speed ahead or slow
                    if (carAhead && car.speed > carAhead.speed) {
                        car.speed = Math.max(carAhead.speed, car.speed - decel * 0.5);
                    }
                } else {
                    // Accelerate
                    car.speed = Math.min(maxSpeed, car.speed + accel);
                }

                // Random slowdown (simulation of driver behavior)
                if (Math.random() < 0.01) {
                    car.speed = Math.max(0, car.speed - 0.5);
                }

                // Move car
                const oldPosition = car.position;
                car.position = (car.position + car.speed) % roadLength;

                // Count throughput (cars crossing the finish line)
                if (car.position < oldPosition) {
                    throughputCount++;
                }
            }

            // Count jams (groups of slow cars)
            let currentJams = 0;
            for (let lane = 0; lane < 2; lane++) {
                const laneCars = cars.filter(c => c.lane === lane).sort((a, b) => a.position - b.position);
                let jamLength = 0;
                for (const car of laneCars) {
                    if (car.speed < 1) {
                        jamLength++;
                    } else {
                        if (jamLength >= 3) currentJams++;
                        jamLength = 0;
                    }
                }
                if (jamLength >= 3) currentJams++;
            }
            jamCount = currentJams;

            updateStats();
        }

        // Update statistics display
        function updateStats() {
            // Calculate average speeds per lane
            const lane1Cars = cars.filter(c => c.lane === 0);
            const lane2Cars = cars.filter(c => c.lane === 1);

            const avgSpeed1 = lane1Cars.length > 0
                ? lane1Cars.reduce((sum, c) => sum + c.speed, 0) / lane1Cars.length
                : 0;
            const avgSpeed2 = lane2Cars.length > 0
                ? lane2Cars.reduce((sum, c) => sum + c.speed, 0) / lane2Cars.length
                : 0;

            document.getElementById('avgSpeed1').textContent = avgSpeed1.toFixed(2);
            document.getElementById('avgSpeed2').textContent = avgSpeed2.toFixed(2);

            // Throughput per minute
            const elapsed = (Date.now() - lastThroughputTime) / 1000;
            const throughputPerMin = elapsed > 0 ? Math.round(throughputCount / elapsed * 60) : 0;
            document.getElementById('throughput').textContent = throughputPerMin;

            document.getElementById('laneChanges').textContent = laneChangeCount;
            document.getElementById('jams').textContent = jamCount;

            // Update speed history for chart
            const avgSpeed = cars.reduce((sum, c) => sum + c.speed, 0) / cars.length;
            speedHistory.push(avgSpeed);
            if (speedHistory.length > 100) speedHistory.shift();
        }

        // Draw simulation
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const scale = canvas.width / roadLength;
            const laneY1 = canvas.height / 2 - laneWidth / 2;
            const laneY2 = canvas.height / 2 + laneWidth / 2;

            // Draw road
            ctx.fillStyle = '#333';
            ctx.fillRect(0, laneY1 - 30, canvas.width, 60);
            ctx.fillRect(0, laneY2 - 30, canvas.width, 60);

            // Lane markings
            ctx.strokeStyle = '#666';
            ctx.setLineDash([20, 20]);
            ctx.lineWidth = 2;

            // Outer edges
            ctx.strokeStyle = '#fff';
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(0, laneY1 - 30);
            ctx.lineTo(canvas.width, laneY1 - 30);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, laneY2 + 30);
            ctx.lineTo(canvas.width, laneY2 + 30);
            ctx.stroke();

            // Center divider
            ctx.strokeStyle = '#ffcc00';
            ctx.setLineDash([30, 15]);
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw cars
            for (const car of cars) {
                const x = car.position * scale;
                let y;

                if (car.laneChangeProgress > 0) {
                    // Interpolate between lanes during lane change
                    const startY = car.lane === car.targetLane ?
                        (car.targetLane === 0 ? laneY1 : laneY2) :
                        (car.lane === 0 ? laneY1 : laneY2);
                    const endY = car.targetLane === 0 ? laneY1 : laneY2;
                    y = startY + (endY - startY) * car.laneChangeProgress;
                } else {
                    y = car.lane === 0 ? laneY1 : laneY2;
                }

                // Car body
                ctx.fillStyle = car.getColor();
                const carWidth = carLength * scale;
                ctx.fillRect(x - carWidth / 2, y - 8, carWidth, 16);

                // Car windshield
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(x + carWidth / 4, y - 6, carWidth / 4, 12);

                // Direction indicator during lane change
                if (car.laneChangeProgress > 0) {
                    ctx.fillStyle = '#ffcc00';
                    const indicatorY = car.targetLane < car.lane ? y - 10 : y + 10;
                    ctx.beginPath();
                    ctx.arc(x, indicatorY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw speed chart
            drawChart();
        }

        // Draw speed history chart
        function drawChart() {
            chartCtx.fillStyle = 'rgba(0,0,0,0.3)';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (speedHistory.length < 2) return;

            const maxSpeed = parseFloat(controls.maxSpeed.value);

            chartCtx.strokeStyle = '#ff6b35';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();

            for (let i = 0; i < speedHistory.length; i++) {
                const x = (i / 99) * chartCanvas.width;
                const y = chartCanvas.height - (speedHistory[i] / maxSpeed) * chartCanvas.height;
                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            }
            chartCtx.stroke();

            // Grid lines
            chartCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            chartCtx.lineWidth = 1;
            for (let i = 0.25; i < 1; i += 0.25) {
                const y = chartCanvas.height * (1 - i);
                chartCtx.beginPath();
                chartCtx.moveTo(0, y);
                chartCtx.lineTo(chartCanvas.width, y);
                chartCtx.stroke();
            }
        }

        // Animation loop
        function animate() {
            if (!running) return;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) animate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);
            initCars();
            draw();
        });

        // Initialize
        initCars();
        draw();
    

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });</script>
</body>
</html>
