<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Change - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0e1a; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #60a5fa; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #60a5fa; color: #0a0e1a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #3b82f6; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 4px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #60a5fa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .word-display { font-family: monospace; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 0.8rem; max-height: 150px; overflow-y: auto; }
        .word-item { display: inline-block; padding: 2px 6px; margin: 2px; border-radius: 3px; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Language Change</h1>
            <p class="description">Agents speak and modify words over time. Watch as languages drift apart through random mutations, borrowing, and geographic isolation - simulating how language families diverge.</p>

            <div class="control-group">
                <label>Agents: <span id="agentsVal">100</span></label>
                <input type="range" id="agents" min="30" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Regions: <span id="regionsVal">4</span></label>
                <input type="range" id="regions" min="2" max="6" value="4">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationVal">0.01</span></label>
                <input type="range" id="mutation" min="0" max="0.1" step="0.005" value="0.01">
            </div>
            <div class="control-group">
                <label>Migration Rate: <span id="migrationVal">0.02</span></label>
                <input type="range" id="migration" min="0" max="0.1" step="0.01" value="0.02">
            </div>
            <div class="control-group">
                <label>Conformity: <span id="conformityVal">0.8</span></label>
                <input type="range" id="conformity" min="0" max="1" step="0.05" value="0.8">
            </div>

            <button id="reset">Reset Languages</button>
            <button id="pause">Pause</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="isolate">Isolate Regions</button>

            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Distinct Words: <span id="wordCount">0</span></div>
                <div>Language Families: <span id="families">0</span></div>
                <div>Mutual Intelligibility: <span id="intelligibility">100</span>%</div>
            </div>

            <p class="description">Regional Vocabularies:</p>
            <div class="word-display" id="wordDisplay"></div>

            <p class="description">Words mutate when spoken (sound changes), and agents adopt words from neighbors (conformity). Isolated regions diverge into separate language families.</p>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Language Change</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        let agents = [];
        let paused = false;
        let generation = 0;
        let isolated = false;

        const regionColors = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#8b5cf6', '#ec4899'];

        // Phoneme inventory for word generation
        const consonants = 'bdfghjklmnprstvwz';
        const vowels = 'aeiou';

        let params = {
            agents: 100,
            regions: 4,
            mutation: 0.01,
            migration: 0.02,
            conformity: 0.8
        };

        // Original words that all languages start with
        const ORIGINAL_WORDS = ['kato', 'mina', 'beru', 'dosa', 'feli'];

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }

        function generateWord() {
            const len = 2 + Math.floor(Math.random() * 3);
            let word = '';
            for (let i = 0; i < len; i++) {
                word += consonants[Math.floor(Math.random() * consonants.length)];
                word += vowels[Math.floor(Math.random() * vowels.length)];
            }
            return word;
        }

        function mutateWord(word) {
            if (word.length < 2) return word;

            const mutationType = Math.floor(Math.random() * 5);
            const pos = Math.floor(Math.random() * word.length);
            const chars = word.split('');

            switch (mutationType) {
                case 0: // Vowel shift
                    if (vowels.includes(chars[pos])) {
                        const newVowel = vowels[(vowels.indexOf(chars[pos]) + 1) % vowels.length];
                        chars[pos] = newVowel;
                    }
                    break;
                case 1: // Consonant shift
                    if (consonants.includes(chars[pos])) {
                        const newCons = consonants[(consonants.indexOf(chars[pos]) + 1) % consonants.length];
                        chars[pos] = newCons;
                    }
                    break;
                case 2: // Deletion (if long enough)
                    if (word.length > 3) {
                        chars.splice(pos, 1);
                    }
                    break;
                case 3: // Reduplication (add syllable)
                    if (word.length < 8) {
                        chars.push(consonants[Math.floor(Math.random() * consonants.length)]);
                        chars.push(vowels[Math.floor(Math.random() * vowels.length)]);
                    }
                    break;
                case 4: // Assimilation (copy from neighbor)
                    if (pos > 0 && consonants.includes(chars[pos]) && consonants.includes(chars[pos-1])) {
                        chars[pos] = chars[pos-1];
                    }
                    break;
            }

            return chars.join('');
        }

        function wordSimilarity(w1, w2) {
            // Simple Levenshtein-like similarity
            const len = Math.max(w1.length, w2.length);
            let matches = 0;
            for (let i = 0; i < Math.min(w1.length, w2.length); i++) {
                if (w1[i] === w2[i]) matches++;
            }
            return matches / len;
        }

        function init() {
            resize();
            agents = [];
            generation = 0;
            isolated = false;

            // Create agents in regions
            const agentsPerRegion = Math.floor(params.agents / params.regions);

            for (let r = 0; r < params.regions; r++) {
                const regionX = (r % 2) * (W / 2) + W / 4;
                const regionY = Math.floor(r / 2) * (H / 2) + H / 4;

                for (let i = 0; i < agentsPerRegion; i++) {
                    agents.push({
                        id: agents.length,
                        x: regionX + (Math.random() - 0.5) * (W / 3),
                        y: regionY + (Math.random() - 0.5) * (H / 3),
                        vx: 0,
                        vy: 0,
                        region: r,
                        vocabulary: [...ORIGINAL_WORDS] // Start with same words
                    });
                }
            }
        }

        function getRegion(x, y) {
            const col = x < W / 2 ? 0 : 1;
            const row = y < H / 2 ? 0 : 1;
            return row * 2 + col;
        }

        function step() {
            if (paused) return;
            generation++;

            for (const agent of agents) {
                // Random movement within region
                agent.vx += (Math.random() - 0.5) * 0.5;
                agent.vy += (Math.random() - 0.5) * 0.5;
                agent.vx *= 0.9;
                agent.vy *= 0.9;

                agent.x += agent.vx;
                agent.y += agent.vy;

                // Regional boundaries
                const margin = 20;
                const regionW = W / 2;
                const regionH = H / 2;
                const regionX = (agent.region % 2) * regionW;
                const regionY = Math.floor(agent.region / 2) * regionH;

                if (!isolated) {
                    // Migration to other regions
                    if (Math.random() < params.migration) {
                        agent.region = Math.floor(Math.random() * params.regions);
                    }
                }

                // Stay in bounds
                agent.x = Math.max(margin, Math.min(W - margin, agent.x));
                agent.y = Math.max(margin, Math.min(H - margin, agent.y));

                // Word mutation
                for (let i = 0; i < agent.vocabulary.length; i++) {
                    if (Math.random() < params.mutation) {
                        agent.vocabulary[i] = mutateWord(agent.vocabulary[i]);
                    }
                }

                // Conformity - adopt words from neighbors
                const neighbors = agents.filter(other =>
                    other.id !== agent.id &&
                    Math.abs(other.x - agent.x) < 50 &&
                    Math.abs(other.y - agent.y) < 50
                );

                if (neighbors.length > 0 && Math.random() < params.conformity) {
                    const neighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const wordIdx = Math.floor(Math.random() * agent.vocabulary.length);
                    // Adopt neighbor's word for this concept
                    agent.vocabulary[wordIdx] = neighbor.vocabulary[wordIdx];
                }
            }
        }

        function calculateFamilies() {
            // Cluster languages by vocabulary similarity
            const regionWords = [];
            for (let r = 0; r < params.regions; r++) {
                const regionAgents = agents.filter(a => a.region === r);
                if (regionAgents.length === 0) continue;

                // Get most common word for each concept in this region
                const commonWords = [];
                for (let w = 0; w < ORIGINAL_WORDS.length; w++) {
                    const wordCounts = {};
                    for (const agent of regionAgents) {
                        const word = agent.vocabulary[w];
                        wordCounts[word] = (wordCounts[word] || 0) + 1;
                    }
                    const sorted = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);
                    commonWords.push(sorted[0] ? sorted[0][0] : '');
                }
                regionWords.push(commonWords);
            }

            // Count distinct language families (based on similarity threshold)
            const threshold = 0.5;
            const families = [];

            for (let i = 0; i < regionWords.length; i++) {
                let foundFamily = false;
                for (const family of families) {
                    let avgSim = 0;
                    for (let w = 0; w < ORIGINAL_WORDS.length; w++) {
                        avgSim += wordSimilarity(regionWords[i][w], regionWords[family[0]][w]);
                    }
                    avgSim /= ORIGINAL_WORDS.length;
                    if (avgSim > threshold) {
                        family.push(i);
                        foundFamily = true;
                        break;
                    }
                }
                if (!foundFamily) {
                    families.push([i]);
                }
            }

            return { families: families.length, regionWords };
        }

        function calculateIntelligibility() {
            // How similar are vocabularies across all agents?
            if (agents.length < 2) return 100;

            let totalSim = 0;
            let comparisons = 0;

            for (let i = 0; i < Math.min(50, agents.length); i++) {
                for (let j = i + 1; j < Math.min(50, agents.length); j++) {
                    for (let w = 0; w < ORIGINAL_WORDS.length; w++) {
                        totalSim += wordSimilarity(agents[i].vocabulary[w], agents[j].vocabulary[w]);
                        comparisons++;
                    }
                }
            }

            return comparisons > 0 ? (totalSim / comparisons) * 100 : 100;
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Draw region boundaries
            ctx.strokeStyle = isolated ? '#ef4444' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = isolated ? 3 : 1;
            ctx.beginPath();
            ctx.moveTo(W / 2, 0);
            ctx.lineTo(W / 2, H);
            ctx.moveTo(0, H / 2);
            ctx.lineTo(W, H / 2);
            ctx.stroke();

            // Draw agents
            for (const agent of agents) {
                const color = regionColors[agent.region % regionColors.length];
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw region labels
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            for (let r = 0; r < params.regions && r < 4; r++) {
                const x = (r % 2) * (W / 2) + W / 4;
                const y = Math.floor(r / 2) * (H / 2) + 30;
                ctx.fillText(`Region ${r + 1}`, x - 30, y);
            }

            // Update stats
            const { families, regionWords } = calculateFamilies();
            const intelligibility = calculateIntelligibility();

            // Count distinct words
            const allWords = new Set();
            for (const agent of agents) {
                for (const word of agent.vocabulary) {
                    allWords.add(word);
                }
            }

            document.getElementById('generation').textContent = generation;
            document.getElementById('wordCount').textContent = allWords.size;
            document.getElementById('families').textContent = families;
            document.getElementById('intelligibility').textContent = intelligibility.toFixed(1);

            // Update word display
            const wordDisplay = document.getElementById('wordDisplay');
            let html = '';
            for (let r = 0; r < regionWords.length; r++) {
                html += `<div style="color:${regionColors[r]}">R${r + 1}: `;
                html += regionWords[r].map(w => `<span class="word-item" style="background:${regionColors[r]}20">${w}</span>`).join(' ');
                html += '</div>';
            }
            wordDisplay.innerHTML = html;
        }

        function animate() {
            step();
            draw();
            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('agents').addEventListener('input', e => {
            params.agents = +e.target.value;
            document.getElementById('agentsVal').textContent = params.agents;
        });
        document.getElementById('regions').addEventListener('input', e => {
            params.regions = +e.target.value;
            document.getElementById('regionsVal').textContent = params.regions;
        });
        document.getElementById('mutation').addEventListener('input', e => {
            params.mutation = +e.target.value;
            document.getElementById('mutationVal').textContent = params.mutation.toFixed(3);
        });
        document.getElementById('migration').addEventListener('input', e => {
            params.migration = +e.target.value;
            document.getElementById('migrationVal').textContent = params.migration.toFixed(2);
        });
        document.getElementById('conformity').addEventListener('input', e => {
            params.conformity = +e.target.value;
            document.getElementById('conformityVal').textContent = params.conformity.toFixed(2);
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('isolate').addEventListener('click', () => {
            isolated = !isolated;
            document.getElementById('isolate').textContent = isolated ? 'Open Borders' : 'Isolate Regions';
        });

        window.addEventListener('resize', resize);

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
