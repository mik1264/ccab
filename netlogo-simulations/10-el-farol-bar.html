<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Farol Bar Problem - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #main-canvas { flex: 1; }
        #history-canvas { height: 150px; border-top: 1px solid #333; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #f59e0b; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #f59e0b; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #d97706; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f59e0b; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .strategy-list { font-size: 0.7rem; color: #666; margin-top: 10px; line-height: 1.4; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <canvas id="history-canvas"></canvas>
        </div>
        <div id="controls">
            <h1>El Farol Bar Problem</h1>
            <p class="description">The El Farol bar problem models bounded rationality. Each week, 100 agents decide whether to go to the bar. If >60 attend, it's too crowded and everyone regrets going. Agents use different prediction strategies based on past attendance.</p>
            
            <div class="control-group">
                <label>Agents: <span id="agentCountVal">100</span></label>
                <input type="range" id="agentCount" min="50" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Crowding Threshold: <span id="thresholdVal">60</span>%</label>
                <input type="range" id="threshold" min="30" max="80" value="60">
            </div>
            <div class="control-group">
                <label>Memory Length: <span id="memoryVal">5</span> weeks</label>
                <input type="range" id="memory" min="2" max="20" value="5">
            </div>
            <div class="control-group">
                <label>Speed: <span id="speedVal">500</span>ms</label>
                <input type="range" id="speed" min="100" max="2000" value="500">
            </div>
            
            <button id="reset">Reset Simulation</button>
            <button id="pause">Pause</button>
            <button id="step">Step Once</button>
            
            <div class="stats">
                <div>Week: <span id="week">0</span></div>
                <div>Attendance: <span id="attendance">0</span></div>
                <div>Crowded: <span id="crowded">No</span></div>
                <div>Avg Attendance: <span id="avgAttendance">0</span></div>
                <div>Times Crowded: <span id="timesCrowded">0</span></div>
            </div>
            
            <p class="description"><strong>Strategies:</strong> Each agent has a set of predictive strategies (e.g., "same as last week", "opposite of average", "random"). They use whichever strategy has worked best recently.</p>
            
            <div class="strategy-list">
                <strong>Active strategies:</strong><br>
                • Last week's value<br>
                • Mirror of last week<br>
                • Average of last N weeks<br>
                • Trend following<br>
                • Random guess<br>
                • Contrarian (opposite of trend)
            </div>
        </div>
    </div>
    <script>
        const mainCanvas = document.getElementById('main-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const histCanvas = document.getElementById('history-canvas');
        const histCtx = histCanvas.getContext('2d');
        
        let W, H, agents = [], history = [], paused = false, week = 0, timesCrowded = 0;
        let intervalId = null;
        
        let params = {
            agentCount: 100,
            threshold: 60,
            memory: 5,
            speed: 500
        };
        
        // Strategy types
        const STRATEGIES = [
            'lastWeek',      // Use last week's attendance
            'mirror',        // 100 - last week
            'average',       // Average of memory
            'trend',         // Follow the trend
            'random',        // Random guess
            'contrarian'     // Opposite of trend
        ];
        
        function resize() {
            const c = document.getElementById('canvas-container');
            mainCanvas.width = c.clientWidth;
            mainCanvas.height = c.clientHeight - 150;
            histCanvas.width = c.clientWidth;
            histCanvas.height = 150;
            W = mainCanvas.width;
            H = mainCanvas.height;
        }
        
        function predictWithStrategy(strategy, history, memory) {
            if (history.length === 0) return 50;
            
            const recent = history.slice(-memory);
            const last = history[history.length - 1];
            
            switch (strategy) {
                case 'lastWeek':
                    return last;
                case 'mirror':
                    return 100 - last;
                case 'average':
                    return recent.reduce((a, b) => a + b, 0) / recent.length;
                case 'trend':
                    if (recent.length < 2) return last;
                    const diff = last - recent[0];
                    return Math.max(0, Math.min(100, last + diff / recent.length));
                case 'random':
                    return Math.random() * 100;
                case 'contrarian':
                    if (recent.length < 2) return 50;
                    const trend = last - recent[0];
                    return Math.max(0, Math.min(100, last - trend));
                default:
                    return 50;
            }
        }
        
        function init() {
            resize();
            agents = [];
            history = [];
            week = 0;
            timesCrowded = 0;
            
            // Create agents with random strategy portfolios
            for (let i = 0; i < params.agentCount; i++) {
                const numStrategies = 3 + Math.floor(Math.random() * 4); // 3-6 strategies
                const strategies = [];
                const shuffled = [...STRATEGIES].sort(() => Math.random() - 0.5);
                for (let s = 0; s < numStrategies; s++) {
                    strategies.push({
                        type: shuffled[s % STRATEGIES.length],
                        score: 0
                    });
                }
                
                agents.push({
                    x: Math.random() * W * 0.7 + W * 0.05,
                    y: Math.random() * H * 0.8 + H * 0.05,
                    strategies: strategies,
                    currentStrategy: 0,
                    attending: false,
                    targetX: 0,
                    targetY: 0
                });
            }
            
            updateStats(0, false);
            draw();
        }
        
        function step() {
            week++;
            const threshold = params.threshold;
            
            // Each agent decides whether to attend
            let attendance = 0;
            
            for (const agent of agents) {
                // Find best performing strategy
                let bestScore = -Infinity;
                let bestIdx = 0;
                for (let i = 0; i < agent.strategies.length; i++) {
                    if (agent.strategies[i].score > bestScore) {
                        bestScore = agent.strategies[i].score;
                        bestIdx = i;
                    }
                }
                agent.currentStrategy = bestIdx;
                
                // Use best strategy to predict
                const prediction = predictWithStrategy(
                    agent.strategies[bestIdx].type,
                    history,
                    params.memory
                );
                
                // Decide to attend if prediction < threshold (won't be crowded)
                agent.attending = prediction < threshold;
                if (agent.attending) attendance++;
            }
            
            // Calculate attendance percentage
            const attendancePercent = (attendance / params.agentCount) * 100;
            const crowded = attendancePercent > threshold;
            if (crowded) timesCrowded++;
            
            // Update strategy scores
            for (const agent of agents) {
                for (const strategy of agent.strategies) {
                    const prediction = predictWithStrategy(strategy.type, history, params.memory);
                    const wouldAttend = prediction < threshold;
                    
                    // Good outcome: attended and not crowded, or didn't attend and was crowded
                    const success = (wouldAttend && !crowded) || (!wouldAttend && crowded);
                    strategy.score = strategy.score * 0.9 + (success ? 1 : 0);
                }
            }
            
            history.push(attendancePercent);
            if (history.length > 100) history.shift();
            
            // Update agent positions (animate to bar or home)
            const barX = W * 0.85;
            const barY = H * 0.5;
            for (const agent of agents) {
                if (agent.attending) {
                    agent.targetX = barX + (Math.random() - 0.5) * 100;
                    agent.targetY = barY + (Math.random() - 0.5) * 150;
                } else {
                    agent.targetX = agent.x + (Math.random() - 0.5) * 20;
                    agent.targetY = agent.y + (Math.random() - 0.5) * 20;
                    agent.targetX = Math.max(20, Math.min(W * 0.6, agent.targetX));
                    agent.targetY = Math.max(20, Math.min(H - 20, agent.targetY));
                }
            }
            
            updateStats(attendancePercent, crowded);
        }
        
        function updateStats(attendance, crowded) {
            document.getElementById('week').textContent = week;
            document.getElementById('attendance').textContent = attendance.toFixed(1) + '%';
            document.getElementById('crowded').textContent = crowded ? 'Yes (too crowded!)' : 'No (comfortable)';
            document.getElementById('crowded').style.color = crowded ? '#ef4444' : '#22c55e';
            
            const avg = history.length > 0 ? history.reduce((a, b) => a + b, 0) / history.length : 0;
            document.getElementById('avgAttendance').textContent = avg.toFixed(1) + '%';
            document.getElementById('timesCrowded').textContent = timesCrowded + ' / ' + week;
        }
        
        function draw() {
            // Main visualization
            mainCtx.fillStyle = '#1a1a2e';
            mainCtx.fillRect(0, 0, W, H);
            
            // Draw "home" area
            mainCtx.fillStyle = 'rgba(100, 100, 100, 0.2)';
            mainCtx.fillRect(10, 10, W * 0.6, H - 20);
            mainCtx.strokeStyle = '#444';
            mainCtx.strokeRect(10, 10, W * 0.6, H - 20);
            mainCtx.fillStyle = '#666';
            mainCtx.font = '14px sans-serif';
            mainCtx.fillText('Home (Staying In)', 20, 30);
            
            // Draw bar area
            const barX = W * 0.65;
            mainCtx.fillStyle = 'rgba(245, 158, 11, 0.2)';
            mainCtx.fillRect(barX, 10, W - barX - 10, H - 20);
            mainCtx.strokeStyle = '#f59e0b';
            mainCtx.lineWidth = 2;
            mainCtx.strokeRect(barX, 10, W - barX - 10, H - 20);
            mainCtx.fillStyle = '#f59e0b';
            mainCtx.fillText('El Farol Bar', barX + 10, 30);
            
            // Draw threshold line
            const thresholdY = 50;
            mainCtx.fillStyle = '#888';
            mainCtx.fillText(`Threshold: ${params.threshold}% (${Math.floor(params.agentCount * params.threshold / 100)} people)`, barX + 10, thresholdY);
            
            // Count attendees for live count
            const attendees = agents.filter(a => a.attending).length;
            const stayingHome = agents.length - attendees;
            
            mainCtx.fillStyle = '#aaa';
            mainCtx.fillText(`At bar: ${attendees}`, barX + 10, 70);
            mainCtx.fillText(`At home: ${stayingHome}`, 20, 50);
            
            // Animate agents
            for (const agent of agents) {
                agent.x += (agent.targetX - agent.x) * 0.1;
                agent.y += (agent.targetY - agent.y) * 0.1;
                
                // Color based on whether attending and if outcome was good
                let color;
                if (agent.attending) {
                    const crowded = (attendees / params.agentCount * 100) > params.threshold;
                    color = crowded ? '#ef4444' : '#22c55e'; // Red if crowded, green if good
                } else {
                    color = '#64748b'; // Gray for staying home
                }
                
                mainCtx.fillStyle = color;
                mainCtx.beginPath();
                mainCtx.arc(agent.x, agent.y, 5, 0, Math.PI * 2);
                mainCtx.fill();
            }
            
            // Draw history graph
            histCtx.fillStyle = '#0a0a15';
            histCtx.fillRect(0, 0, histCanvas.width, histCanvas.height);
            
            // Threshold line
            const thresholdLineY = histCanvas.height - (params.threshold / 100) * (histCanvas.height - 30) - 15;
            histCtx.strokeStyle = '#f59e0b';
            histCtx.setLineDash([5, 5]);
            histCtx.beginPath();
            histCtx.moveTo(0, thresholdLineY);
            histCtx.lineTo(histCanvas.width, thresholdLineY);
            histCtx.stroke();
            histCtx.setLineDash([]);
            
            // Attendance line
            if (history.length > 1) {
                histCtx.strokeStyle = '#60a5fa';
                histCtx.lineWidth = 2;
                histCtx.beginPath();
                for (let i = 0; i < history.length; i++) {
                    const x = (i / 100) * histCanvas.width;
                    const y = histCanvas.height - (history[i] / 100) * (histCanvas.height - 30) - 15;
                    if (i === 0) histCtx.moveTo(x, y);
                    else histCtx.lineTo(x, y);
                }
                histCtx.stroke();
            }
            
            histCtx.fillStyle = '#888';
            histCtx.font = '10px sans-serif';
            histCtx.fillText('Attendance History (threshold = orange line)', 10, 12);
            histCtx.fillText('0%', 5, histCanvas.height - 5);
            histCtx.fillText('100%', 5, 25);
            
            requestAnimationFrame(draw);
        }
        
        function startSimulation() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) step();
            }, params.speed);
        }
        
        // Event listeners
        document.getElementById('agentCount').addEventListener('input', e => {
            params.agentCount = +e.target.value;
            document.getElementById('agentCountVal').textContent = params.agentCount;
        });
        
        document.getElementById('threshold').addEventListener('input', e => {
            params.threshold = +e.target.value;
            document.getElementById('thresholdVal').textContent = params.threshold;
        });
        
        document.getElementById('memory').addEventListener('input', e => {
            params.memory = +e.target.value;
            document.getElementById('memoryVal').textContent = params.memory;
        });
        
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = +e.target.value;
            document.getElementById('speedVal').textContent = params.speed;
            startSimulation();
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            init();
            startSimulation();
        });
        
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('step').addEventListener('click', () => {
            step();
        });
        
        window.addEventListener('resize', resize);
        
        init();
        draw();
        startSimulation();
    </script>
</body>
</html>
