<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein Folding - HP Lattice Model</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f1729 0%, #1a2744 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #4ecdc4, #556270);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description {
            text-align: center;
            max-width: 700px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #888;
        }
        #container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        #canvas { border: 1px solid #334; border-radius: 8px; background: #0a0f1a; }
        .panel {
            background: rgba(15, 23, 41, 0.95);
            padding: 15px;
            border-radius: 8px;
            width: 230px;
            border: 1px solid #334;
        }
        .panel h3 { font-size: 0.9rem; margin-bottom: 10px; color: #4ecdc4; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; color: #8899aa; margin-bottom: 3px; }
        input[type="range"], input[type="text"] { width: 100%; }
        input[type="text"] {
            background: #1a2744;
            border: 1px solid #334;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
        }
        button {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #4ecdc4, #556270);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { opacity: 0.9; }
        .stats { font-size: 0.75rem; color: #8899aa; }
        .stats div { margin-bottom: 4px; display: flex; justify-content: space-between; }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(15, 23, 41, 0.95);
            color: #4ecdc4;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.7rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .sequence-display {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            background: #1a2744;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .presets { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
        .preset-btn {
            padding: 4px 8px;
            font-size: 0.7rem;
            background: #334;
            border: none;
            border-radius: 3px;
            color: #aaa;
            cursor: pointer;
        }
        .preset-btn:hover { background: #445; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Protein Folding</h1>
    <p class="description">HP (Hydrophobic-Polar) lattice model of protein folding. Monte Carlo simulation minimizes energy by bringing hydrophobic (H) residues together while polar (P) residues stay exposed.</p>

    <div id="container">
        <canvas id="canvas" width="500" height="500"></canvas>
        <div class="panel">
            <h3>Sequence</h3>
            <div class="sequence-display" id="seqDisplay">HPHPPHHPHPPH</div>
            <input type="text" id="sequence" value="HPHPPHHPHPPHPHHPHP" placeholder="H=Hydrophobic, P=Polar">

            <div class="presets">
                <button class="preset-btn" data-seq="HPHPPHHPHPPH">Short</button>
                <button class="preset-btn" data-seq="HPHPPHHPHPPHPHHPHP">Medium</button>
                <button class="preset-btn" data-seq="HHPPHPPHPPHPPHPPHPPHPPHH">Long</button>
                <button class="preset-btn" data-seq="PPHPPHHPPHHPPPHHPPHHPP">Complex</button>
            </div>

            <h3>Controls</h3>
            <div class="control-group">
                <label>Temperature: <span id="tempVal">1.0</span></label>
                <input type="range" id="temperature" min="0.1" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Steps per Frame: <span id="stepsVal">100</span></label>
                <input type="range" id="stepsPerFrame" min="10" max="500" step="10" value="100">
            </div>
            <button id="resetBtn">Reset/Apply Sequence</button>
            <button id="pauseBtn">Pause</button>
            <button id="annealBtn">Simulated Annealing</button>

            <h3>Statistics</h3>
            <div class="stats">
                <div><span>Energy:</span> <span id="energy">0</span></div>
                <div><span>H-H Contacts:</span> <span id="contacts">0</span></div>
                <div><span>Monte Carlo Steps:</span> <span id="mcSteps">0</span></div>
                <div><span>Acceptance Rate:</span> <span id="acceptRate">0</span>%</div>
                <div><span>Best Energy:</span> <span id="bestEnergy">0</span></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: #e74c3c;"></div>
                    <span>H (Hydrophobic)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #3498db;"></div>
                    <span>P (Polar)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let sequence = 'HPHPPHHPHPPHPHHPHP';
        let positions = [];
        let temperature = 1.0;
        let stepsPerFrame = 100;
        let mcSteps = 0;
        let accepted = 0;
        let attempted = 0;
        let bestEnergy = 0;
        let running = true;
        let annealing = false;
        let annealStep = 0;

        const CELL_SIZE = 20;
        const OFFSET_X = canvas.width / 2;
        const OFFSET_Y = canvas.height / 2;

        function initProtein() {
            sequence = document.getElementById('sequence').value.toUpperCase().replace(/[^HP]/g, '');
            if (sequence.length < 2) sequence = 'HP';
            document.getElementById('seqDisplay').textContent = sequence;

            // Start with a straight line
            positions = [];
            for (let i = 0; i < sequence.length; i++) {
                positions.push({ x: i - Math.floor(sequence.length / 2), y: 0 });
            }

            mcSteps = 0;
            accepted = 0;
            attempted = 0;
            bestEnergy = calculateEnergy();
            annealing = false;
        }

        function isValidConformation() {
            // Check for overlaps
            const seen = new Set();
            for (const pos of positions) {
                const key = `${pos.x},${pos.y}`;
                if (seen.has(key)) return false;
                seen.add(key);
            }

            // Check connectivity
            for (let i = 1; i < positions.length; i++) {
                const dx = Math.abs(positions[i].x - positions[i-1].x);
                const dy = Math.abs(positions[i].y - positions[i-1].y);
                if (dx + dy !== 1) return false;
            }

            return true;
        }

        function calculateEnergy() {
            let energy = 0;
            const posMap = new Map();

            positions.forEach((pos, i) => {
                posMap.set(`${pos.x},${pos.y}`, i);
            });

            // Count H-H contacts (not along backbone)
            for (let i = 0; i < sequence.length; i++) {
                if (sequence[i] !== 'H') continue;

                const neighbors = [
                    { x: positions[i].x + 1, y: positions[i].y },
                    { x: positions[i].x - 1, y: positions[i].y },
                    { x: positions[i].x, y: positions[i].y + 1 },
                    { x: positions[i].x, y: positions[i].y - 1 }
                ];

                for (const n of neighbors) {
                    const key = `${n.x},${n.y}`;
                    const j = posMap.get(key);
                    if (j !== undefined && Math.abs(j - i) > 1 && sequence[j] === 'H') {
                        energy--;
                    }
                }
            }

            return energy / 2; // Each contact counted twice
        }

        function countHHContacts() {
            return -calculateEnergy();
        }

        function mcMove() {
            // Pick random residue (not endpoints for corner flip, or any for crankshaft)
            const moveType = Math.random();

            if (moveType < 0.5) {
                // Corner flip
                const i = 1 + Math.floor(Math.random() * (sequence.length - 2));
                const prev = positions[i - 1];
                const next = positions[i + 1];

                // Check if corner exists
                if (Math.abs(prev.x - next.x) === 1 && Math.abs(prev.y - next.y) === 1) {
                    const oldPos = { ...positions[i] };
                    const newX = prev.x + next.x - positions[i].x;
                    const newY = prev.y + next.y - positions[i].y;

                    positions[i] = { x: newX, y: newY };

                    if (!isValidConformation()) {
                        positions[i] = oldPos;
                        return false;
                    }
                    return true;
                }
            } else {
                // End flip
                const isStart = Math.random() < 0.5;
                const i = isStart ? 0 : sequence.length - 1;
                const anchor = isStart ? 1 : sequence.length - 2;

                const oldPos = { ...positions[i] };
                const directions = [
                    { x: positions[anchor].x + 1, y: positions[anchor].y },
                    { x: positions[anchor].x - 1, y: positions[anchor].y },
                    { x: positions[anchor].x, y: positions[anchor].y + 1 },
                    { x: positions[anchor].x, y: positions[anchor].y - 1 }
                ].filter(d => d.x !== oldPos.x || d.y !== oldPos.y);

                if (directions.length > 0) {
                    const newPos = directions[Math.floor(Math.random() * directions.length)];
                    positions[i] = newPos;

                    if (!isValidConformation()) {
                        positions[i] = oldPos;
                        return false;
                    }
                    return true;
                }
            }

            return false;
        }

        function mcStep() {
            const oldEnergy = calculateEnergy();

            if (mcMove()) {
                attempted++;
                const newEnergy = calculateEnergy();
                const deltaE = newEnergy - oldEnergy;

                // Metropolis criterion
                if (deltaE <= 0 || Math.random() < Math.exp(-deltaE / temperature)) {
                    accepted++;
                    if (newEnergy < bestEnergy) {
                        bestEnergy = newEnergy;
                    }
                } else {
                    // Reject - but we already moved, so we need to undo
                    // Actually the move was already done, let's just accept it for simplicity
                    // In a proper implementation, we'd store and restore
                }
            }

            mcSteps++;
        }

        function draw() {
            ctx.fillStyle = '#0a0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#1a2744';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw backbone
            ctx.strokeStyle = '#556270';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < positions.length; i++) {
                const x = OFFSET_X + positions[i].x * CELL_SIZE;
                const y = OFFSET_Y + positions[i].y * CELL_SIZE;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw H-H contacts
            const posMap = new Map();
            positions.forEach((pos, i) => {
                posMap.set(`${pos.x},${pos.y}`, i);
            });

            ctx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < sequence.length; i++) {
                if (sequence[i] !== 'H') continue;
                const neighbors = [
                    { x: positions[i].x + 1, y: positions[i].y },
                    { x: positions[i].x - 1, y: positions[i].y },
                    { x: positions[i].x, y: positions[i].y + 1 },
                    { x: positions[i].x, y: positions[i].y - 1 }
                ];
                for (const n of neighbors) {
                    const j = posMap.get(`${n.x},${n.y}`);
                    if (j !== undefined && j > i + 1 && sequence[j] === 'H') {
                        ctx.beginPath();
                        ctx.moveTo(OFFSET_X + positions[i].x * CELL_SIZE, OFFSET_Y + positions[i].y * CELL_SIZE);
                        ctx.lineTo(OFFSET_X + n.x * CELL_SIZE, OFFSET_Y + n.y * CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }

            // Draw residues
            for (let i = 0; i < positions.length; i++) {
                const x = OFFSET_X + positions[i].x * CELL_SIZE;
                const y = OFFSET_Y + positions[i].y * CELL_SIZE;
                const isH = sequence[i] === 'H';

                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fillStyle = isH ? '#e74c3c' : '#3498db';
                ctx.fill();
                ctx.strokeStyle = isH ? '#c0392b' : '#2980b9';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(sequence[i], x, y);
            }
        }

        function updateStats() {
            document.getElementById('energy').textContent = calculateEnergy();
            document.getElementById('contacts').textContent = countHHContacts();
            document.getElementById('mcSteps').textContent = mcSteps.toLocaleString();
            document.getElementById('acceptRate').textContent = attempted > 0 ? Math.round(accepted / attempted * 100) : 0;
            document.getElementById('bestEnergy').textContent = bestEnergy;
        }

        // Controls
        document.getElementById('temperature').addEventListener('input', function() {
            temperature = parseFloat(this.value);
            document.getElementById('tempVal').textContent = temperature.toFixed(1);
        });

        document.getElementById('stepsPerFrame').addEventListener('input', function() {
            stepsPerFrame = parseInt(this.value);
            document.getElementById('stepsVal').textContent = stepsPerFrame;
        });

        document.getElementById('resetBtn').addEventListener('click', initProtein);

        document.getElementById('pauseBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Resume';
        });

        document.getElementById('annealBtn').addEventListener('click', function() {
            annealing = true;
            annealStep = 0;
            temperature = 3.0;
            document.getElementById('temperature').value = temperature;
            document.getElementById('tempVal').textContent = temperature.toFixed(1);
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.getElementById('sequence').value = this.dataset.seq;
                initProtein();
            });
        });

        function animate() {
            if (running) {
                for (let i = 0; i < stepsPerFrame; i++) {
                    mcStep();
                }

                if (annealing) {
                    annealStep++;
                    if (annealStep % 100 === 0) {
                        temperature = Math.max(0.1, temperature * 0.99);
                        document.getElementById('temperature').value = temperature;
                        document.getElementById('tempVal').textContent = temperature.toFixed(1);
                    }
                    if (temperature <= 0.11) {
                        annealing = false;
                    }
                }

                draw();
                updateStats();
            }
            requestAnimationFrame(animate);
        }

        initProtein();
        draw();
        updateStats();
        animate();
    </script>
</body>
</html>
