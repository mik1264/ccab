<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Canyon Formation - NetLogo Simulations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c17f59, #a8634a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description {
            text-align: center;
            max-width: 700px;
            margin-bottom: 20px;
            color: #aaa;
            line-height: 1.5;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        .controls {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 220px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.85rem;
            color: #888;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .value {
            font-size: 0.8rem;
            color: #c17f59;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .primary { background: #c17f59; color: white; }
        .primary:hover { background: #a8634a; }
        .secondary { background: rgba(255,255,255,0.1); color: #e0e0e0; }
        .secondary:hover { background: rgba(255,255,255,0.2); }
        .stats {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            font-size: 0.85rem;
        }
        .stats div { margin: 3px 0; }
        .stat-value { color: #c17f59; }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.75rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        a.back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c17f59;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        a.back-link:hover { opacity: 1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>Grand Canyon Formation</h1>
    <p class="description">
        Simulate canyon formation over geological time through water erosion, sediment transport,
        and layer exposure. Watch how a river carves through stratified rock layers.
    </p>

    <div class="container">
        <canvas id="canvas" width="700" height="500"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Water Flow Rate: <span id="flowVal" class="value">50</span></label>
                <input type="range" id="flowRate" min="10" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Erosion Power: <span id="erosionVal" class="value">5</span></label>
                <input type="range" id="erosionPower" min="1" max="10" value="5">
            </div>

            <div class="control-group">
                <label>Simulation Speed: <span id="speedVal" class="value">5</span></label>
                <input type="range" id="simSpeed" min="1" max="10" value="5">
            </div>

            <div class="control-group">
                <label>Rainfall: <span id="rainVal" class="value">30</span>%</label>
                <input type="range" id="rainfall" min="0" max="100" value="30">
            </div>

            <button class="primary" id="startBtn">Start Erosion</button>
            <button class="secondary" id="resetBtn">Reset Terrain</button>

            <div class="stats">
                <div>Years: <span id="years" class="stat-value">0</span> million</div>
                <div>Canyon Depth: <span id="depth" class="stat-value">0</span> m</div>
                <div>Sediment Moved: <span id="sediment" class="stat-value">0</span> tons</div>
                <div>Exposed Layers: <span id="layers" class="stat-value">0</span></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background:#8B4513"></div>
                    <span>Kaibab (Limestone)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#C19A6B"></div>
                    <span>Coconino (Sandstone)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#A0522D"></div>
                    <span>Hermit (Shale)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#CD853F"></div>
                    <span>Supai (Red Sandstone)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#8B0000"></div>
                    <span>Redwall (Limestone)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#556B2F"></div>
                    <span>Muav (Dolomite)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#2F4F4F"></div>
                    <span>Vishnu (Schist)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Rock layers with hardness and colors (inspired by real Grand Canyon geology)
        const rockLayers = [
            { name: 'Kaibab Limestone', color: '#8B4513', hardness: 0.7 },
            { name: 'Coconino Sandstone', color: '#C19A6B', hardness: 0.4 },
            { name: 'Hermit Shale', color: '#A0522D', hardness: 0.3 },
            { name: 'Supai Formation', color: '#CD853F', hardness: 0.5 },
            { name: 'Redwall Limestone', color: '#8B0000', hardness: 0.8 },
            { name: 'Muav Limestone', color: '#556B2F', hardness: 0.6 },
            { name: 'Vishnu Schist', color: '#2F4F4F', hardness: 0.95 }
        ];

        // Terrain heightmap
        let terrain = [];
        let waterLevel = [];
        let sedimentCarried = [];

        const COLS = 140;
        const ROWS = 100;
        const cellW = W / COLS;
        const cellH = H / ROWS;

        let running = false;
        let years = 0;
        let totalSediment = 0;
        let maxDepth = 0;
        let exposedLayers = new Set();

        // Controls
        const flowRateSlider = document.getElementById('flowRate');
        const erosionPowerSlider = document.getElementById('erosionPower');
        const simSpeedSlider = document.getElementById('simSpeed');
        const rainfallSlider = document.getElementById('rainfall');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');

        function initTerrain() {
            terrain = [];
            waterLevel = [];
            sedimentCarried = [];

            for (let y = 0; y < ROWS; y++) {
                terrain[y] = [];
                waterLevel[y] = [];
                sedimentCarried[y] = [];
                for (let x = 0; x < COLS; x++) {
                    // Initial flat plateau with slight variations
                    let baseHeight = ROWS * 0.85;
                    // Add some natural variation
                    baseHeight += Math.sin(x * 0.1) * 2 + Math.cos(y * 0.05) * 1;
                    terrain[y][x] = baseHeight;
                    waterLevel[y][x] = 0;
                    sedimentCarried[y][x] = 0;
                }
            }

            // Initial river channel in the middle
            const riverX = Math.floor(COLS / 2);
            for (let y = 0; y < ROWS; y++) {
                for (let dx = -3; dx <= 3; dx++) {
                    const x = riverX + dx;
                    if (x >= 0 && x < COLS) {
                        terrain[y][x] -= 2 - Math.abs(dx) * 0.5;
                    }
                }
            }

            years = 0;
            totalSediment = 0;
            maxDepth = 0;
            exposedLayers.clear();
            updateStats();
        }

        function getLayerAt(depth) {
            // depth is from surface (0 = top, higher = deeper)
            const layerHeight = (ROWS * 0.85) / rockLayers.length;
            const layerIndex = Math.min(Math.floor(depth / layerHeight), rockLayers.length - 1);
            return layerIndex;
        }

        function erode() {
            const flowRate = parseInt(flowRateSlider.value) / 100;
            const erosionPower = parseInt(erosionPowerSlider.value) / 10;
            const rainfall = parseInt(rainfallSlider.value) / 100;

            // Add water at top (river source) and random rainfall
            const riverX = Math.floor(COLS / 2);
            for (let dx = -5; dx <= 5; dx++) {
                const x = riverX + dx;
                if (x >= 0 && x < COLS) {
                    waterLevel[0][x] += flowRate * (1 - Math.abs(dx) / 5);
                }
            }

            // Random rainfall
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (Math.random() < rainfall * 0.01) {
                        waterLevel[y][x] += 0.1;
                    }
                }
            }

            // Flow water and erode
            for (let y = 0; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    if (waterLevel[y][x] > 0.01) {
                        const currentHeight = terrain[y][x] + waterLevel[y][x];

                        // Find lowest neighbor
                        let neighbors = [
                            { dx: 0, dy: 1, h: terrain[y + 1][x] },
                            { dx: -1, dy: 1, h: terrain[y + 1][x - 1] },
                            { dx: 1, dy: 1, h: terrain[y + 1][x + 1] },
                            { dx: -1, dy: 0, h: terrain[y][x - 1] },
                            { dx: 1, dy: 0, h: terrain[y][x + 1] }
                        ];

                        neighbors.sort((a, b) => a.h - b.h);
                        const lowest = neighbors[0];

                        if (lowest.h < currentHeight) {
                            const nx = x + lowest.dx;
                            const ny = y + lowest.dy;

                            if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                                // Calculate erosion based on water volume and slope
                                const slope = currentHeight - lowest.h;
                                const depth = ROWS * 0.85 - terrain[y][x];
                                const layerIndex = getLayerAt(Math.max(0, depth));
                                const hardness = rockLayers[layerIndex].hardness;

                                const erosionAmount = waterLevel[y][x] * slope * erosionPower * 0.01 * (1 - hardness * 0.8);

                                if (erosionAmount > 0) {
                                    terrain[y][x] -= erosionAmount;
                                    sedimentCarried[y][x] += erosionAmount;
                                    totalSediment += erosionAmount * 1000; // Convert to "tons"

                                    // Track exposed layers
                                    exposedLayers.add(layerIndex);
                                }

                                // Move water and sediment
                                const waterTransfer = waterLevel[y][x] * 0.5;
                                waterLevel[ny][nx] += waterTransfer;
                                waterLevel[y][x] -= waterTransfer;

                                // Deposit sediment on flatter areas
                                if (slope < 0.5 && sedimentCarried[y][x] > 0) {
                                    const deposit = sedimentCarried[y][x] * 0.2;
                                    terrain[ny][nx] += deposit * 0.3;
                                    sedimentCarried[ny][nx] += sedimentCarried[y][x] - deposit;
                                    sedimentCarried[y][x] = 0;
                                }
                            }
                        }
                    }

                    // Evaporation
                    waterLevel[y][x] *= 0.98;
                }
            }

            // Update max depth
            const centerX = Math.floor(COLS / 2);
            const surfaceHeight = ROWS * 0.85;
            for (let y = Math.floor(ROWS / 2); y < ROWS; y++) {
                const depth = surfaceHeight - terrain[y][centerX];
                if (depth > maxDepth) maxDepth = depth;
            }

            years += 0.01;
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Draw sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.3);
            skyGrad.addColorStop(0, '#87CEEB');
            skyGrad.addColorStop(1, '#E0F7FF');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, W, H * 0.15);

            // Draw terrain with layers
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const height = terrain[y][x];
                    const surfaceHeight = ROWS * 0.85;
                    const depth = Math.max(0, surfaceHeight - height);
                    const layerIndex = getLayerAt(depth);

                    // Only draw if this cell is part of the terrain
                    const screenY = H - (height / ROWS) * H;

                    if (screenY < H && screenY > 0) {
                        // Draw from screen bottom up to terrain surface
                        const terrainTop = screenY;

                        // Color based on layer at this depth
                        let color = rockLayers[layerIndex].color;

                        // Add some noise for realism
                        const noise = (Math.sin(x * 0.5 + y * 0.3) * 0.1);

                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellW, terrainTop, cellW + 0.5, H - terrainTop);

                        // Draw water
                        if (waterLevel[y][x] > 0.1) {
                            const waterHeight = Math.min(waterLevel[y][x] * 5, 20);
                            ctx.fillStyle = `rgba(64, 164, 223, ${Math.min(0.8, waterLevel[y][x] * 0.3)})`;
                            ctx.fillRect(x * cellW, terrainTop - waterHeight, cellW + 0.5, waterHeight);
                        }
                    }
                }
            }

            // Draw layer boundaries on canyon walls
            const centerX = Math.floor(COLS / 2);
            let lastLayer = -1;
            for (let y = 0; y < ROWS; y++) {
                const height = terrain[y][centerX];
                const surfaceHeight = ROWS * 0.85;
                const depth = Math.max(0, surfaceHeight - height);
                const layerIndex = getLayerAt(depth);

                if (layerIndex !== lastLayer && depth > 5) {
                    const screenY = H - (height / ROWS) * H;
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(W, screenY);
                    ctx.stroke();
                    lastLayer = layerIndex;
                }
            }
        }

        function updateStats() {
            document.getElementById('years').textContent = years.toFixed(2);
            document.getElementById('depth').textContent = Math.round(maxDepth * 18); // Scale to meters
            document.getElementById('sediment').textContent = Math.round(totalSediment).toLocaleString();
            document.getElementById('layers').textContent = exposedLayers.size;

            document.getElementById('flowVal').textContent = flowRateSlider.value;
            document.getElementById('erosionVal').textContent = erosionPowerSlider.value;
            document.getElementById('speedVal').textContent = simSpeedSlider.value;
            document.getElementById('rainVal').textContent = rainfallSlider.value;
        }

        function animate() {
            if (running) {
                const speed = parseInt(simSpeedSlider.value);
                for (let i = 0; i < speed; i++) {
                    erode();
                }
            }
            draw();
            updateStats();
            requestAnimationFrame(animate);
        }

        startBtn.addEventListener('click', () => {
            running = !running;
            startBtn.textContent = running ? 'Pause' : 'Start Erosion';
        });

        resetBtn.addEventListener('click', () => {
            running = false;
            startBtn.textContent = 'Start Erosion';
            initTerrain();
        });

        // Update value displays
        [flowRateSlider, erosionPowerSlider, simSpeedSlider, rainfallSlider].forEach(slider => {
            slider.addEventListener('input', updateStats);
        });

        initTerrain();
        animate();
    </script>
</body>
</html>
