<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Hunt Camouflage - Natural Selection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
        }
        .container {
            display: flex;
            width: 100%;
        }
        .controls {
            width: 300px;
            padding: 20px;
            background: #12172b;
            overflow-y: auto;
            max-height: 100vh;
        }
        .controls h1 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: #4caf50;
        }
        .controls p {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #81c784;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .control-group select {
            width: 100%;
            padding: 8px;
            background: #1a2040;
            border: 1px solid #333;
            color: #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #4caf50;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        button.primary {
            background: linear-gradient(135deg, #43a047, #2e7d32);
            color: white;
        }
        button.secondary {
            background: #2d3a4f;
            color: #81c784;
        }
        button:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
        }
        .stats h3 {
            font-size: 0.9rem;
            color: #4caf50;
            margin-bottom: 10px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #2a3050;
            font-size: 0.85rem;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #66bb6a;
            font-weight: 500;
        }
        .instructions {
            margin-top: 15px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #888;
        }
        .instructions h3 {
            color: #4caf50;
            margin-bottom: 10px;
        }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            cursor: crosshair;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #4caf50;
            text-decoration: none;
            font-size: 0.85rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .back-link:hover {
            opacity: 1;
        }
        .score-display {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.2rem;
            color: #4caf50;
        }
        .histogram {
            margin-top: 15px;
            padding: 15px;
            background: #1a2040;
            border-radius: 8px;
        }
        .histogram h3 {
            font-size: 0.9rem;
            color: #4caf50;
            margin-bottom: 10px;
        }
        .histogram-bars {
            display: flex;
            gap: 2px;
            height: 60px;
            align-items: flex-end;
        }
        .histogram-bar {
            flex: 1;
            min-width: 10px;
            transition: height 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <a href="index.html" class="back-link">← Back to Gallery</a>
            <h1>Bug Hunt Camouflage</h1>
            <p>Click to catch bugs! Colors that blend with the background survive longer and reproduce more. Watch cryptic coloration evolve through natural selection.</p>

            <div class="control-group">
                <label>Environment</label>
                <select id="environment">
                    <option value="forest">Forest (Green)</option>
                    <option value="desert">Desert (Brown)</option>
                    <option value="snow">Snow (White)</option>
                    <option value="rocks">Rocky (Gray)</option>
                    <option value="mixed">Mixed Terrain</option>
                </select>
            </div>

            <div class="control-group">
                <label>Bug Population: <span class="value-display" id="populationVal">30</span></label>
                <input type="range" id="population" min="10" max="50" value="30">
            </div>

            <div class="control-group">
                <label>Mutation Rate: <span class="value-display" id="mutationVal">10%</span></label>
                <input type="range" id="mutation" min="1" max="30" value="10">
            </div>

            <div class="control-group">
                <label>Bug Size: <span class="value-display" id="sizeVal">12</span></label>
                <input type="range" id="bugSize" min="5" max="25" value="12">
            </div>

            <button class="primary" onclick="resetSimulation()">Reset Simulation</button>
            <button class="secondary" onclick="changeEnvironment()">Random Environment</button>
            <button class="secondary" onclick="toggleAutoPlay()">Auto Hunt: OFF</button>

            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Generation</span>
                    <span class="stat-value" id="generation">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Bugs Caught</span>
                    <span class="stat-value" id="caught">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Bugs Alive</span>
                    <span class="stat-value" id="alive">30</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg. Camouflage</span>
                    <span class="stat-value" id="avgCamo">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Best Camouflage</span>
                    <span class="stat-value" id="bestCamo">0%</span>
                </div>
            </div>

            <div class="histogram">
                <h3>Color Distribution</h3>
                <div class="histogram-bars" id="histogram"></div>
            </div>

            <div class="instructions">
                <h3>How It Works</h3>
                <p>1. Click on bugs to "eat" them (predation)</p>
                <p>2. Well-camouflaged bugs are harder to see</p>
                <p>3. Survivors reproduce with slight mutations</p>
                <p>4. Over generations, bug colors adapt to background</p>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let bugs = [];
        let population = 30;
        let mutationRate = 0.1;
        let bugSize = 12;
        let generation = 0;
        let caught = 0;
        let autoPlay = false;
        let autoPlayTimer = null;

        // Environment colors
        const environments = {
            forest: {
                primary: [34, 139, 34],
                secondary: [50, 100, 50],
                pattern: 'leaves'
            },
            desert: {
                primary: [210, 180, 140],
                secondary: [194, 156, 115],
                pattern: 'sand'
            },
            snow: {
                primary: [250, 250, 255],
                secondary: [220, 230, 240],
                pattern: 'snow'
            },
            rocks: {
                primary: [128, 128, 128],
                secondary: [100, 100, 100],
                pattern: 'rocks'
            },
            mixed: {
                primary: [100, 120, 80],
                secondary: [140, 110, 90],
                pattern: 'mixed'
            }
        };

        let currentEnv = 'forest';
        let backgroundData = null;

        function initCanvas() {
            const wrapper = document.querySelector('.canvas-wrapper');
            const size = Math.min(wrapper.clientWidth - 40, wrapper.clientHeight - 40, 600);
            canvas.width = size;
            canvas.height = size;
            generateBackground();
        }

        function generateBackground() {
            const env = environments[currentEnv];
            ctx.fillStyle = `rgb(${env.primary.join(',')})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add texture based on pattern
            const pattern = env.pattern;

            if (pattern === 'leaves') {
                // Forest pattern with leaf-like shapes
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const shade = Math.random() * 40 - 20;
                    ctx.fillStyle = `rgb(${34 + shade}, ${139 + shade}, ${34 + shade})`;
                    ctx.beginPath();
                    ctx.ellipse(x, y, Math.random() * 15 + 5, Math.random() * 8 + 3,
                               Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (pattern === 'sand') {
                // Desert pattern with sand grains
                for (let i = 0; i < 500; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const shade = Math.random() * 30 - 15;
                    ctx.fillStyle = `rgb(${210 + shade}, ${180 + shade}, ${140 + shade})`;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (pattern === 'snow') {
                // Snow pattern with sparkle
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const shade = Math.random() * 20 - 10;
                    ctx.fillStyle = `rgb(${240 + shade}, ${240 + shade}, ${250 + shade})`;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random() * 10 + 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (pattern === 'rocks') {
                // Rocky pattern with stones
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const shade = Math.random() * 60 - 30;
                    ctx.fillStyle = `rgb(${128 + shade}, ${128 + shade}, ${128 + shade})`;
                    ctx.beginPath();
                    const size = Math.random() * 20 + 10;
                    ctx.ellipse(x, y, size, size * 0.7, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (pattern === 'mixed') {
                // Mixed terrain with patches
                for (let i = 0; i < 150; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const type = Math.random();
                    let color;
                    if (type < 0.33) {
                        color = [50 + Math.random() * 40, 100 + Math.random() * 40, 50 + Math.random() * 30];
                    } else if (type < 0.66) {
                        color = [180 + Math.random() * 40, 150 + Math.random() * 40, 100 + Math.random() * 40];
                    } else {
                        color = [100 + Math.random() * 40, 100 + Math.random() * 40, 80 + Math.random() * 40];
                    }
                    ctx.fillStyle = `rgb(${Math.floor(color[0])}, ${Math.floor(color[1])}, ${Math.floor(color[2])})`;
                    ctx.beginPath();
                    ctx.ellipse(x, y, Math.random() * 20 + 10, Math.random() * 15 + 5,
                               Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Store background for camouflage calculation
            backgroundData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        function createBug(parentColor = null) {
            const x = Math.random() * (canvas.width - bugSize * 4) + bugSize * 2;
            const y = Math.random() * (canvas.height - bugSize * 4) + bugSize * 2;

            let color;
            if (parentColor) {
                // Mutate from parent color
                color = parentColor.map(c => {
                    const mutation = (Math.random() - 0.5) * 2 * mutationRate * 255;
                    return Math.max(0, Math.min(255, Math.floor(c + mutation)));
                });
            } else {
                // Random color
                color = [
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256)
                ];
            }

            return { x, y, color, alive: true, age: 0 };
        }

        function initBugs() {
            bugs = [];
            for (let i = 0; i < population; i++) {
                bugs.push(createBug());
            }
        }

        function getBackgroundColorAt(x, y) {
            if (!backgroundData) return [128, 128, 128];

            const px = Math.floor(x);
            const py = Math.floor(y);
            const idx = (py * canvas.width + px) * 4;

            return [
                backgroundData.data[idx],
                backgroundData.data[idx + 1],
                backgroundData.data[idx + 2]
            ];
        }

        function calculateCamouflage(bug) {
            const bgColor = getBackgroundColorAt(bug.x, bug.y);
            const diff = Math.sqrt(
                Math.pow(bug.color[0] - bgColor[0], 2) +
                Math.pow(bug.color[1] - bgColor[1], 2) +
                Math.pow(bug.color[2] - bgColor[2], 2)
            );
            // Max diff is sqrt(255^2 * 3) ≈ 441
            return Math.max(0, 100 - (diff / 441) * 100);
        }

        function drawBug(bug) {
            ctx.save();
            ctx.translate(bug.x, bug.y);

            // Body
            ctx.fillStyle = `rgb(${bug.color.join(',')})`;
            ctx.beginPath();
            ctx.ellipse(0, 0, bugSize, bugSize * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(bugSize * 0.8, 0, bugSize * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Spots (darker version of color)
            ctx.fillStyle = `rgb(${bug.color.map(c => Math.floor(c * 0.7)).join(',')})`;
            ctx.beginPath();
            ctx.arc(-bugSize * 0.3, -bugSize * 0.2, bugSize * 0.15, 0, Math.PI * 2);
            ctx.arc(bugSize * 0.2, bugSize * 0.2, bugSize * 0.12, 0, Math.PI * 2);
            ctx.arc(-bugSize * 0.2, bugSize * 0.15, bugSize * 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Antennae
            ctx.strokeStyle = `rgb(${bug.color.map(c => Math.floor(c * 0.5)).join(',')})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bugSize * 0.8, -bugSize * 0.2);
            ctx.lineTo(bugSize * 1.3, -bugSize * 0.5);
            ctx.moveTo(bugSize * 0.8, bugSize * 0.2);
            ctx.lineTo(bugSize * 1.3, bugSize * 0.5);
            ctx.stroke();

            ctx.restore();
        }

        function render() {
            // Restore background
            if (backgroundData) {
                ctx.putImageData(backgroundData, 0, 0);
            }

            // Draw all alive bugs
            for (const bug of bugs) {
                if (bug.alive) {
                    drawBug(bug);
                }
            }
        }

        function handleClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if any bug was clicked
            for (const bug of bugs) {
                if (!bug.alive) continue;

                const dx = x - bug.x;
                const dy = y - bug.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < bugSize * 1.2) {
                    // Bug caught!
                    bug.alive = false;
                    caught++;
                    document.getElementById('caught').textContent = caught;

                    // Check if generation is complete
                    const alive = bugs.filter(b => b.alive).length;
                    document.getElementById('alive').textContent = alive;

                    if (alive <= population * 0.3) {
                        nextGeneration();
                    } else {
                        render();
                    }
                    return;
                }
            }
        }

        function nextGeneration() {
            generation++;
            document.getElementById('generation').textContent = generation;

            // Get survivors
            const survivors = bugs.filter(b => b.alive);

            if (survivors.length === 0) {
                // All died, start fresh
                initBugs();
            } else {
                // Reproduce from survivors
                const newBugs = [];
                while (newBugs.length < population) {
                    // Select parent based on fitness (camouflage)
                    const parent = survivors[Math.floor(Math.random() * survivors.length)];
                    newBugs.push(createBug(parent.color));
                }
                bugs = newBugs;
            }

            updateStats();
            render();
        }

        function updateStats() {
            const alive = bugs.filter(b => b.alive);
            document.getElementById('alive').textContent = alive.length;

            if (alive.length > 0) {
                const camoScores = alive.map(b => calculateCamouflage(b));
                const avgCamo = camoScores.reduce((a, b) => a + b, 0) / camoScores.length;
                const bestCamo = Math.max(...camoScores);

                document.getElementById('avgCamo').textContent = avgCamo.toFixed(1) + '%';
                document.getElementById('bestCamo').textContent = bestCamo.toFixed(1) + '%';
            }

            updateHistogram();
        }

        function updateHistogram() {
            const histogramEl = document.getElementById('histogram');
            histogramEl.innerHTML = '';

            // Create color histogram (by hue)
            const hueBins = new Array(12).fill(0);
            const alive = bugs.filter(b => b.alive);

            for (const bug of alive) {
                const [r, g, b] = bug.color;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h = 0;

                if (max !== min) {
                    const d = max - min;
                    if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
                    else if (max === g) h = (b - r) / d + 2;
                    else h = (r - g) / d + 4;
                    h /= 6;
                }

                const bin = Math.floor(h * 12) % 12;
                hueBins[bin]++;
            }

            const maxCount = Math.max(...hueBins, 1);

            for (let i = 0; i < 12; i++) {
                const bar = document.createElement('div');
                bar.className = 'histogram-bar';
                const height = (hueBins[i] / maxCount) * 100;
                bar.style.height = `${Math.max(2, height)}%`;
                const hue = i * 30;
                bar.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
                histogramEl.appendChild(bar);
            }
        }

        function resetSimulation() {
            generation = 0;
            caught = 0;
            document.getElementById('generation').textContent = 0;
            document.getElementById('caught').textContent = 0;

            population = parseInt(document.getElementById('population').value);
            mutationRate = parseInt(document.getElementById('mutation').value) / 100;
            bugSize = parseInt(document.getElementById('bugSize').value);

            generateBackground();
            initBugs();
            updateStats();
            render();
        }

        function changeEnvironment() {
            const envs = Object.keys(environments);
            currentEnv = envs[Math.floor(Math.random() * envs.length)];
            document.getElementById('environment').value = currentEnv;
            generateBackground();
            render();
            updateStats();
        }

        function toggleAutoPlay() {
            autoPlay = !autoPlay;
            const btn = event.target;

            if (autoPlay) {
                btn.textContent = 'Auto Hunt: ON';
                btn.style.background = 'linear-gradient(135deg, #f44336, #c62828)';
                runAutoPlay();
            } else {
                btn.textContent = 'Auto Hunt: OFF';
                btn.style.background = '#2d3a4f';
                if (autoPlayTimer) {
                    clearTimeout(autoPlayTimer);
                }
            }
        }

        function runAutoPlay() {
            if (!autoPlay) return;

            // Find the least camouflaged bug (easiest to see)
            const alive = bugs.filter(b => b.alive);
            if (alive.length === 0) {
                nextGeneration();
                autoPlayTimer = setTimeout(runAutoPlay, 500);
                return;
            }

            // Sort by camouflage (lowest first = most visible)
            const sorted = alive.map(b => ({ bug: b, camo: calculateCamouflage(b) }))
                               .sort((a, b) => a.camo - b.camo);

            // Probability of catching based on visibility
            // Less camouflaged bugs more likely to be caught
            const target = sorted[0];
            const catchProb = (100 - target.camo) / 100;

            if (Math.random() < catchProb) {
                target.bug.alive = false;
                caught++;
                document.getElementById('caught').textContent = caught;

                const aliveCount = bugs.filter(b => b.alive).length;
                document.getElementById('alive').textContent = aliveCount;

                if (aliveCount <= population * 0.3) {
                    nextGeneration();
                } else {
                    render();
                }
            }

            autoPlayTimer = setTimeout(runAutoPlay, 300);
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);

        document.getElementById('environment').addEventListener('change', function() {
            currentEnv = this.value;
            generateBackground();
            render();
            updateStats();
        });

        document.getElementById('population').addEventListener('input', function() {
            document.getElementById('populationVal').textContent = this.value;
        });

        document.getElementById('mutation').addEventListener('input', function() {
            document.getElementById('mutationVal').textContent = this.value + '%';
        });

        document.getElementById('bugSize').addEventListener('input', function() {
            document.getElementById('sizeVal').textContent = this.value;
        });

        window.addEventListener('resize', () => {
            initCanvas();
            initBugs();
            render();
        });

        // Initialize
        initCanvas();
        initBugs();
        updateStats();
        render();
    </script>
</body>
</html>
