<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Change - Linguistic Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 320px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #06d6a0 0%, #1b9aaa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #888;
            font-size: 0.95em;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 20px;
        }
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #bbb;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .control-group .value {
            text-align: right;
            font-size: 0.9em;
            color: #06d6a0;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #06d6a0 0%, #118ab2 100%);
            color: white;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(6,214,160,0.3);
        }
        .stats {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .stats h3 {
            margin-bottom: 12px;
            color: #06d6a0;
            font-size: 1em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #73d2de;
            font-weight: 600;
        }
        .info-box {
            background: rgba(6,214,160,0.1);
            border-left: 3px solid #06d6a0;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85em;
            border-radius: 0 8px 8px 0;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: color 0.3s;
        }
        .back-link:hover {
            color: #06d6a0;
        }
        .word-display {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .word-display h4 {
            color: #06d6a0;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        .word-variants {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .variant {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-family: monospace;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75em;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <a href="index.html" class="back-link">← Back to Simulations</a>

            <div class="info-box">
                <strong>Language Change</strong><br>
                Models how words evolve through generations. Speakers interact and their language variants drift over time, leading to dialect formation and language divergence.
            </div>

            <div class="control-group">
                <label>Population: <span class="value" id="popVal">100</span></label>
                <input type="range" id="pop" min="20" max="200" value="100">
            </div>

            <div class="control-group">
                <label>Mutation Rate: <span class="value" id="mutationVal">0.01</span></label>
                <input type="range" id="mutation" min="0" max="0.1" step="0.005" value="0.01">
            </div>

            <div class="control-group">
                <label>Conformity: <span class="value" id="conformityVal">0.7</span></label>
                <input type="range" id="conformity" min="0" max="1" step="0.05" value="0.7">
            </div>

            <div class="control-group">
                <label>Mobility: <span class="value" id="mobilityVal">0.1</span></label>
                <input type="range" id="mobility" min="0" max="1" step="0.05" value="0.1">
            </div>

            <div class="control-group">
                <label>Number of Regions: <span class="value" id="regionsVal">4</span></label>
                <input type="range" id="regions" min="1" max="9" value="4">
            </div>

            <button class="btn-primary" id="startBtn">Start Evolution</button>
            <button class="btn-secondary" id="resetBtn">Reset</button>

            <div class="stats">
                <h3>Language Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Generation:</span>
                    <span class="stat-value" id="generation">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Unique Variants:</span>
                    <span class="stat-value" id="variants">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Dominant Variant:</span>
                    <span class="stat-value" id="dominant">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Language Entropy:</span>
                    <span class="stat-value" id="entropy">0.00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Regional Diversity:</span>
                    <span class="stat-value" id="diversity">0%</span>
                </div>
            </div>

            <div class="word-display">
                <h4>Current Variants (Word: "water")</h4>
                <div class="word-variants" id="wordVariants">
                    <!-- Filled dynamically -->
                </div>
            </div>

            <div class="legend" id="regionLegend">
                <!-- Filled dynamically -->
            </div>
        </aside>

        <main class="main">
            <header>
                <h1>Language Change Simulation</h1>
                <p class="subtitle">Watch linguistic evolution through generations - dialects emerge from drift</p>
            </header>
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
                <canvas id="historyCanvas"></canvas>
            </div>
        </main>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const historyCanvas = document.getElementById('historyCanvas');
        const historyCtx = historyCanvas.getContext('2d');

        // Canvas sizing
        function resizeCanvases() {
            const container = canvas.parentElement;
            const width = Math.min(container.clientWidth - 40, 700);
            canvas.width = width;
            canvas.height = width * 0.6;
            historyCanvas.width = width;
            historyCanvas.height = 150;
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let speakers = [];
        let running = false;
        let animationId = null;
        let generation = 0;
        let variantHistory = [];
        let regionColors = [];

        // Original word
        const originalWord = "water";

        // Controls
        const controls = {
            pop: document.getElementById('pop'),
            mutation: document.getElementById('mutation'),
            conformity: document.getElementById('conformity'),
            mobility: document.getElementById('mobility'),
            regions: document.getElementById('regions')
        };

        // Update value displays
        Object.keys(controls).forEach(key => {
            const input = controls[key];
            const valueSpan = document.getElementById(key + 'Val');
            input.addEventListener('input', () => {
                valueSpan.textContent = input.value;
            });
        });

        // Speaker class
        class Speaker {
            constructor(region, word) {
                this.region = region;
                this.word = word;
                this.x = 0;
                this.y = 0;
                this.updatePosition();
            }

            updatePosition() {
                const numRegions = parseInt(controls.regions.value);
                const cols = Math.ceil(Math.sqrt(numRegions));
                const rows = Math.ceil(numRegions / cols);
                const regionWidth = canvas.width / cols;
                const regionHeight = canvas.height / rows;

                const regionCol = this.region % cols;
                const regionRow = Math.floor(this.region / cols);

                this.x = regionCol * regionWidth + Math.random() * regionWidth;
                this.y = regionRow * regionHeight + Math.random() * regionHeight;
            }
        }

        // Mutate a word
        function mutateWord(word) {
            const mutations = [
                // Vowel shifts
                { from: 'a', to: 'æ' },
                { from: 'a', to: 'o' },
                { from: 'e', to: 'i' },
                { from: 'o', to: 'u' },
                { from: 'u', to: 'ü' },
                // Consonant changes
                { from: 't', to: 'd' },
                { from: 't', to: 'th' },
                { from: 'w', to: 'v' },
                { from: 'r', to: '' },
                // Additions
                { from: '', to: 'h', position: 'start' },
                { from: 'er', to: 'a' }
            ];

            const mutation = mutations[Math.floor(Math.random() * mutations.length)];

            if (mutation.position === 'start') {
                return mutation.to + word;
            } else if (mutation.from === '') {
                const pos = Math.floor(Math.random() * word.length);
                return word.slice(0, pos) + mutation.to + word.slice(pos);
            } else {
                return word.replace(mutation.from, mutation.to);
            }
        }

        // Get word color based on its hash
        function getWordColor(word) {
            let hash = 0;
            for (let i = 0; i < word.length; i++) {
                hash = word.charCodeAt(i) + ((hash << 5) - hash);
            }
            const hue = Math.abs(hash) % 360;
            return `hsl(${hue}, 70%, 50%)`;
        }

        // Initialize simulation
        function initSimulation() {
            speakers = [];
            const numSpeakers = parseInt(controls.pop.value);
            const numRegions = parseInt(controls.regions.value);

            // Generate region colors
            regionColors = [];
            for (let i = 0; i < numRegions; i++) {
                regionColors.push(`hsl(${(i / numRegions) * 360}, 60%, 40%)`);
            }

            // Update legend
            const legend = document.getElementById('regionLegend');
            legend.innerHTML = regionColors.map((color, i) => `
                <div class="legend-item">
                    <div class="legend-color" style="background: ${color};"></div>
                    Region ${i + 1}
                </div>
            `).join('');

            // Create speakers
            for (let i = 0; i < numSpeakers; i++) {
                const region = Math.floor(Math.random() * numRegions);
                speakers.push(new Speaker(region, originalWord));
            }

            generation = 0;
            variantHistory = [];
        }

        // Run one generation
        function runGeneration() {
            const mutationRate = parseFloat(controls.mutation.value);
            const conformity = parseFloat(controls.conformity.value);
            const mobility = parseFloat(controls.mobility.value);
            const numRegions = parseInt(controls.regions.value);

            // Each speaker interacts
            for (const speaker of speakers) {
                // Maybe move to another region
                if (Math.random() < mobility) {
                    speaker.region = Math.floor(Math.random() * numRegions);
                    speaker.updatePosition();
                }

                // Find nearby speakers (same region or adjacent)
                const neighbors = speakers.filter(s => s !== speaker && s.region === speaker.region);

                if (neighbors.length > 0 && Math.random() < conformity) {
                    // Adopt most common variant in region
                    const wordCounts = {};
                    neighbors.forEach(n => {
                        wordCounts[n.word] = (wordCounts[n.word] || 0) + 1;
                    });

                    let maxCount = 0;
                    let dominantWord = speaker.word;
                    for (const [word, count] of Object.entries(wordCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            dominantWord = word;
                        }
                    }
                    speaker.word = dominantWord;
                }

                // Random mutation
                if (Math.random() < mutationRate) {
                    speaker.word = mutateWord(speaker.word);
                }
            }

            generation++;

            // Record history
            const wordCounts = {};
            speakers.forEach(s => {
                wordCounts[s.word] = (wordCounts[s.word] || 0) + 1;
            });
            variantHistory.push(wordCounts);
            if (variantHistory.length > 200) variantHistory.shift();

            updateStats();
        }

        // Update statistics
        function updateStats() {
            document.getElementById('generation').textContent = generation;

            // Count variants
            const wordCounts = {};
            speakers.forEach(s => {
                wordCounts[s.word] = (wordCounts[s.word] || 0) + 1;
            });

            const variants = Object.keys(wordCounts);
            document.getElementById('variants').textContent = variants.length;

            // Find dominant
            let maxCount = 0;
            let dominant = '-';
            for (const [word, count] of Object.entries(wordCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    dominant = word;
                }
            }
            document.getElementById('dominant').textContent = `"${dominant}" (${Math.round(maxCount / speakers.length * 100)}%)`;

            // Calculate entropy
            const total = speakers.length;
            let entropy = 0;
            for (const count of Object.values(wordCounts)) {
                const p = count / total;
                if (p > 0) entropy -= p * Math.log2(p);
            }
            document.getElementById('entropy').textContent = entropy.toFixed(2);

            // Regional diversity (how different are regions from each other)
            const numRegions = parseInt(controls.regions.value);
            const regionWords = [];
            for (let r = 0; r < numRegions; r++) {
                const regionSpeakers = speakers.filter(s => s.region === r);
                if (regionSpeakers.length > 0) {
                    const counts = {};
                    regionSpeakers.forEach(s => counts[s.word] = (counts[s.word] || 0) + 1);
                    let maxW = null, maxC = 0;
                    for (const [w, c] of Object.entries(counts)) {
                        if (c > maxC) { maxC = c; maxW = w; }
                    }
                    regionWords.push(maxW);
                }
            }
            const uniqueRegionWords = new Set(regionWords);
            const diversity = Math.round((uniqueRegionWords.size - 1) / Math.max(1, regionWords.length - 1) * 100);
            document.getElementById('diversity').textContent = diversity + '%';

            // Update word variants display
            const variantsDiv = document.getElementById('wordVariants');
            const sortedVariants = Object.entries(wordCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            variantsDiv.innerHTML = sortedVariants.map(([word, count]) => `
                <span class="variant" style="background: ${getWordColor(word)}; color: white;">
                    ${word} (${count})
                </span>
            `).join('');
        }

        // Draw simulation
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const numRegions = parseInt(controls.regions.value);
            const cols = Math.ceil(Math.sqrt(numRegions));
            const rows = Math.ceil(numRegions / cols);
            const regionWidth = canvas.width / cols;
            const regionHeight = canvas.height / rows;

            // Draw regions
            for (let r = 0; r < numRegions; r++) {
                const col = r % cols;
                const row = Math.floor(r / cols);
                ctx.fillStyle = regionColors[r] + '40';
                ctx.fillRect(col * regionWidth, row * regionHeight, regionWidth, regionHeight);

                // Region border
                ctx.strokeStyle = regionColors[r];
                ctx.lineWidth = 2;
                ctx.strokeRect(col * regionWidth, row * regionHeight, regionWidth, regionHeight);

                // Region label
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.fillText(`Region ${r + 1}`, col * regionWidth + 10, row * regionHeight + 20);
            }

            // Draw speakers
            for (const speaker of speakers) {
                ctx.fillStyle = getWordColor(speaker.word);
                ctx.beginPath();
                ctx.arc(speaker.x, speaker.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw history chart
            drawHistory();
        }

        function drawHistory() {
            historyCtx.fillStyle = '#1a1a2e';
            historyCtx.fillRect(0, 0, historyCanvas.width, historyCanvas.height);

            if (variantHistory.length < 2) return;

            // Get all words that ever appeared
            const allWords = new Set();
            variantHistory.forEach(h => Object.keys(h).forEach(w => allWords.add(w)));
            const wordList = Array.from(allWords);

            // Draw stacked area chart
            const total = speakers.length;
            const barWidth = historyCanvas.width / variantHistory.length;

            for (let t = 0; t < variantHistory.length; t++) {
                const counts = variantHistory[t];
                let y = historyCanvas.height;

                for (const word of wordList) {
                    const count = counts[word] || 0;
                    const height = (count / total) * historyCanvas.height;

                    historyCtx.fillStyle = getWordColor(word);
                    historyCtx.fillRect(t * barWidth, y - height, barWidth, height);
                    y -= height;
                }
            }

            // Label
            historyCtx.fillStyle = '#888';
            historyCtx.font = '10px sans-serif';
            historyCtx.fillText('Variant distribution over time →', 10, historyCanvas.height - 5);
        }

        // Animation loop
        let lastTime = 0;
        function animate(currentTime) {
            if (!running) return;

            if (currentTime - lastTime > 100) {
                runGeneration();
                lastTime = currentTime;
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Evolution';
            if (running) {
                lastTime = performance.now();
                animate(lastTime);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Evolution';
            if (animationId) cancelAnimationFrame(animationId);
            initSimulation();
            draw();
        });

        controls.regions.addEventListener('input', () => {
            if (!running) {
                initSimulation();
                draw();
            }
        });

        // Initialize
        initSimulation();
        draw();
    </script>
</body>
</html>
