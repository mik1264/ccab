<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallel Sorting Networks - CCAB</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container { display: flex; height: 100vh; }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 10px;
        }
        canvas { border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #a29bfe; }
        h3 { margin: 15px 0 8px 0; color: #d4a5ff; font-size: 14px; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 13px; }
        input[type="range"] { width: 100%; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #a29bfe;
            color: #1a1a2e;
            font-weight: bold;
        }
        button:hover { background: #6c5ce7; color: white; }
        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
        }
        select option { background: #1a1a2e; }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600;">
        <span>← Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="networkCanvas"></canvas>
            <canvas id="arrayCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>⚡ Parallel Sorting</h2>
            <p style="font-size: 12px; opacity: 0.8;">Sorting network visualization</p>

            <h3>Network Type</h3>
            <select id="network">
                <option value="oddeven">Odd-Even Transposition</option>
                <option value="bitonic">Bitonic Sort</option>
                <option value="batcher">Batcher Odd-Even Merge</option>
            </select>

            <h3>Array Size (2ⁿ)</h3>
            <div class="slider-group">
                <label>n = <span id="sizeVal">4</span> → <span id="arraySize">16</span> elements</label>
                <input type="range" id="size" min="2" max="5" step="1" value="4">
            </div>

            <h3>Animation Speed</h3>
            <div class="slider-group">
                <label>Delay: <span id="speedVal">300</span>ms</label>
                <input type="range" id="speed" min="50" max="1000" step="50" value="300">
            </div>

            <button onclick="randomize()">Randomize</button>
            <button onclick="startSort()">Sort</button>
            <button onclick="stepSort()">Step</button>

            <div class="stats">
                <div class="stat-row"><span>Network:</span><span id="networkName">Odd-Even</span></div>
                <div class="stat-row"><span>Array Size:</span><span id="arraySizeStat">16</span></div>
                <div class="stat-row"><span>Current Stage:</span><span id="stage">0</span></div>
                <div class="stat-row"><span>Comparisons:</span><span id="comparisons">0</span></div>
                <div class="stat-row"><span>Swaps:</span><span id="swaps">0</span></div>
                <div class="stat-row"><span>Parallel Steps:</span><span id="parallelSteps">0</span></div>
                <div class="stat-row"><span>Status:</span><span id="status">Ready</span></div>
            </div>

            <div class="description">
                <strong>Sorting Networks:</strong><br>
                Fixed comparison sequences that sort any input. All comparisons in a stage can run in parallel.<br><br>
                <strong>Odd-Even Transposition:</strong><br>
                O(n) parallel steps, compares adjacent pairs alternating odd/even positions.<br><br>
                <strong>Bitonic Sort:</strong><br>
                O(log²n) parallel steps, builds and merges bitonic sequences.<br><br>
                <strong>Batcher Merge:</strong><br>
                O(log²n) parallel steps, uses odd-even merge networks.
            </div>
        </div>
    </div>

    <script>
        const networkCanvas = document.getElementById('networkCanvas');
        const networkCtx = networkCanvas.getContext('2d');
        const arrayCanvas = document.getElementById('arrayCanvas');
        const arrayCtx = arrayCanvas.getContext('2d');

        networkCanvas.width = 700;
        networkCanvas.height = 350;
        arrayCanvas.width = 700;
        arrayCanvas.height = 150;

        let n = 4;
        let arraySize = 16;
        let array = [];
        let network = [];
        let currentStage = 0;
        let comparisons = 0;
        let swaps = 0;
        let sorting = false;
        let speed = 300;
        let networkType = 'oddeven';
        let activeComparators = [];

        function generateOddEvenNetwork(n) {
            const stages = [];
            for (let phase = 0; phase < n; phase++) {
                const stage = [];
                for (let i = phase % 2; i < n - 1; i += 2) {
                    stage.push([i, i + 1]);
                }
                if (stage.length > 0) stages.push(stage);
            }
            return stages;
        }

        function generateBitonicNetwork(n) {
            const stages = [];

            function bitonicMerge(lo, cnt, dir) {
                if (cnt > 1) {
                    const k = Math.floor(cnt / 2);
                    const stage = [];
                    for (let i = lo; i < lo + k; i++) {
                        stage.push(dir ? [i, i + k] : [i + k, i]);
                    }
                    stages.push(stage);
                    bitonicMerge(lo, k, dir);
                    bitonicMerge(lo + k, k, dir);
                }
            }

            function bitonicSort(lo, cnt, dir) {
                if (cnt > 1) {
                    const k = Math.floor(cnt / 2);
                    bitonicSort(lo, k, true);
                    bitonicSort(lo + k, k, false);
                    bitonicMerge(lo, cnt, dir);
                }
            }

            bitonicSort(0, n, true);

            // Flatten stages with same depth
            const flattened = [];
            for (const stage of stages) {
                if (flattened.length === 0 || !canMergeStages(flattened[flattened.length - 1], stage)) {
                    flattened.push([...stage]);
                } else {
                    flattened[flattened.length - 1].push(...stage);
                }
            }

            return stages;
        }

        function generateBatcherNetwork(n) {
            const stages = [];

            function oddEvenMerge(lo, hi, r) {
                const step = r * 2;
                if (step < hi - lo) {
                    oddEvenMerge(lo, hi, step);
                    oddEvenMerge(lo + r, hi, step);
                    for (let i = lo + r; i < hi - r; i += step) {
                        stages.push([[i, i + r]]);
                    }
                } else {
                    stages.push([[lo, lo + r]]);
                }
            }

            function batcherSort(lo, hi) {
                if (hi - lo >= 1) {
                    const mid = Math.floor((lo + hi) / 2);
                    batcherSort(lo, mid);
                    batcherSort(mid + 1, hi);
                    oddEvenMerge(lo, hi, 1);
                }
            }

            batcherSort(0, n - 1);
            return stages;
        }

        function canMergeStages(stage1, stage2) {
            const used = new Set();
            for (const [a, b] of stage1) {
                used.add(a);
                used.add(b);
            }
            for (const [a, b] of stage2) {
                if (used.has(a) || used.has(b)) return false;
            }
            return true;
        }

        function generateNetwork() {
            switch (networkType) {
                case 'oddeven':
                    network = generateOddEvenNetwork(arraySize);
                    break;
                case 'bitonic':
                    network = generateBitonicNetwork(arraySize);
                    break;
                case 'batcher':
                    network = generateBatcherNetwork(arraySize);
                    break;
            }
        }

        function randomize() {
            array = [];
            for (let i = 0; i < arraySize; i++) {
                array.push(Math.floor(Math.random() * 100) + 1);
            }
            currentStage = 0;
            comparisons = 0;
            swaps = 0;
            sorting = false;
            activeComparators = [];
            generateNetwork();
            updateStats();
            draw();
        }

        function startSort() {
            if (sorting) return;
            sorting = true;
            currentStage = 0;
            comparisons = 0;
            swaps = 0;
            document.getElementById('status').textContent = 'Sorting...';
            runSort();
        }

        function runSort() {
            if (currentStage >= network.length) {
                sorting = false;
                document.getElementById('status').textContent = 'Complete!';
                activeComparators = [];
                draw();
                return;
            }

            const stage = network[currentStage];
            activeComparators = [...stage];

            // Perform all comparisons in parallel
            for (const [i, j] of stage) {
                const a = Math.min(i, j);
                const b = Math.max(i, j);
                comparisons++;

                if (array[a] > array[b]) {
                    [array[a], array[b]] = [array[b], array[a]];
                    swaps++;
                }
            }

            currentStage++;
            updateStats();
            draw();

            if (sorting) {
                setTimeout(runSort, speed);
            }
        }

        function stepSort() {
            if (currentStage >= network.length) {
                document.getElementById('status').textContent = 'Complete!';
                return;
            }

            const stage = network[currentStage];
            activeComparators = [...stage];

            for (const [i, j] of stage) {
                const a = Math.min(i, j);
                const b = Math.max(i, j);
                comparisons++;

                if (array[a] > array[b]) {
                    [array[a], array[b]] = [array[b], array[a]];
                    swaps++;
                }
            }

            currentStage++;
            updateStats();
            draw();

            if (currentStage >= network.length) {
                document.getElementById('status').textContent = 'Complete!';
                activeComparators = [];
            }
        }

        function updateStats() {
            const networkNames = {
                'oddeven': 'Odd-Even Transposition',
                'bitonic': 'Bitonic Sort',
                'batcher': 'Batcher Odd-Even Merge'
            };

            document.getElementById('networkName').textContent = networkNames[networkType];
            document.getElementById('arraySizeStat').textContent = arraySize;
            document.getElementById('stage').textContent = `${currentStage}/${network.length}`;
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('swaps').textContent = swaps;
            document.getElementById('parallelSteps').textContent = network.length;
        }

        function draw() {
            // Network visualization
            networkCtx.fillStyle = '#2d2d44';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);

            const padding = 40;
            const wireSpacing = (networkCanvas.height - 2 * padding) / (arraySize - 1);
            const stageWidth = (networkCanvas.width - 2 * padding) / Math.max(network.length, 1);

            // Draw wires
            networkCtx.strokeStyle = '#636e72';
            networkCtx.lineWidth = 1;
            for (let i = 0; i < arraySize; i++) {
                const y = padding + i * wireSpacing;
                networkCtx.beginPath();
                networkCtx.moveTo(padding, y);
                networkCtx.lineTo(networkCanvas.width - padding, y);
                networkCtx.stroke();
            }

            // Draw comparators
            for (let s = 0; s < network.length; s++) {
                const stage = network[s];
                const x = padding + (s + 0.5) * stageWidth;

                for (const [i, j] of stage) {
                    const y1 = padding + i * wireSpacing;
                    const y2 = padding + j * wireSpacing;

                    const isActive = s === currentStage - 1 &&
                        activeComparators.some(([a, b]) => a === i && b === j);

                    networkCtx.strokeStyle = s < currentStage ? '#55efc4' : (isActive ? '#ffeaa7' : '#a29bfe');
                    networkCtx.lineWidth = isActive ? 3 : 2;

                    // Vertical line
                    networkCtx.beginPath();
                    networkCtx.moveTo(x, y1);
                    networkCtx.lineTo(x, y2);
                    networkCtx.stroke();

                    // Nodes
                    networkCtx.fillStyle = networkCtx.strokeStyle;
                    networkCtx.beginPath();
                    networkCtx.arc(x, y1, 4, 0, Math.PI * 2);
                    networkCtx.fill();
                    networkCtx.beginPath();
                    networkCtx.arc(x, y2, 4, 0, Math.PI * 2);
                    networkCtx.fill();
                }
            }

            // Current stage indicator
            if (currentStage > 0 && currentStage <= network.length) {
                const x = padding + (currentStage - 0.5) * stageWidth;
                networkCtx.fillStyle = 'rgba(255, 234, 167, 0.3)';
                networkCtx.fillRect(x - stageWidth/2, 0, stageWidth, networkCanvas.height);
            }

            // Array visualization
            arrayCtx.fillStyle = '#1a1a2e';
            arrayCtx.fillRect(0, 0, arrayCanvas.width, arrayCanvas.height);

            const barWidth = (arrayCanvas.width - 40) / arraySize;
            const maxVal = Math.max(...array, 100);

            for (let i = 0; i < array.length; i++) {
                const barHeight = (array[i] / maxVal) * (arrayCanvas.height - 30);
                const x = 20 + i * barWidth;
                const y = arrayCanvas.height - barHeight - 10;

                // Color based on sorted position
                const hue = (array[i] / maxVal) * 240;
                arrayCtx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                arrayCtx.fillRect(x, y, barWidth - 2, barHeight);

                // Value label for small arrays
                if (arraySize <= 16) {
                    arrayCtx.fillStyle = 'white';
                    arrayCtx.font = '10px Arial';
                    arrayCtx.textAlign = 'center';
                    arrayCtx.fillText(array[i], x + barWidth/2, y - 3);
                }
            }

            arrayCtx.fillStyle = 'white';
            arrayCtx.font = '11px Arial';
            arrayCtx.textAlign = 'left';
            arrayCtx.fillText('Current array state', 5, 12);
        }

        // Event listeners
        document.getElementById('network').onchange = function() {
            networkType = this.value;
            randomize();
        };

        document.getElementById('size').oninput = function() {
            n = parseInt(this.value);
            arraySize = Math.pow(2, n);
            document.getElementById('sizeVal').textContent = n;
            document.getElementById('arraySize').textContent = arraySize;
            randomize();
        };

        document.getElementById('speed').oninput = function() {
            speed = parseInt(this.value);
            document.getElementById('speedVal').textContent = speed;
        };

        // Initialize
        randomize();
    </script>
</body>
</html>
