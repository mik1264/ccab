<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumor Mill - Information Spread - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        #simCanvas { flex: 2; }
        #graphCanvas { flex: 1; border-top: 1px solid #333; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #a78bfa; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #7c3aed; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #6d28d9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #a78bfa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .legend { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
        .legend-item { display: flex; align-items: center; gap: 4px; font-size: 0.7rem; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Rumor Mill</h1>
            <p class="description">Watch rumors spread through a network. Each retelling may corrupt the message. Like telephone game meets epidemiology!</p>
            
            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background:#666"></div>Ignorant</div>
                <div class="legend-item"><div class="legend-dot" style="background:#a78bfa"></div>Spreader</div>
                <div class="legend-item"><div class="legend-dot" style="background:#22c55e"></div>Stifler</div>
            </div>
            
            <div class="control-group">
                <label>Population: <span id="popVal">100</span></label>
                <input type="range" id="pop" min="30" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Spread Rate: <span id="spreadVal">0.3</span></label>
                <input type="range" id="spread" min="0.1" max="0.8" step="0.05" value="0.3">
            </div>
            <div class="control-group">
                <label>Decay Rate (per telling): <span id="decayVal">0.1</span></label>
                <input type="range" id="decay" min="0" max="0.3" step="0.02" value="0.1">
            </div>
            <div class="control-group">
                <label>Stifle Rate: <span id="stifleVal">0.05</span></label>
                <input type="range" id="stifle" min="0" max="0.2" step="0.01" value="0.05">
            </div>
            
            <button id="reset">Reset</button>
            <button id="pause">Pause</button>
            <button id="newRumor">Start New Rumor</button>
            
            <div class="stats">
                <div>Time: <span id="time">0</span></div>
                <div>Ignorant: <span id="ignorant" style="color:#888">0</span></div>
                <div>Spreaders: <span id="spreaders" style="color:#a78bfa">0</span></div>
                <div>Stiflers: <span id="stiflers" style="color:#22c55e">0</span></div>
                <div>Avg Message Fidelity: <span id="fidelity">100</span>%</div>
            </div>
            
            <p class="description"><strong>Dynamics:</strong> Spreaders tell ignorants (who become spreaders). When spreaders meet stiflers or other spreaders, they become stiflers.</p>
            
            <p class="description"><strong>Decay:</strong> Each retelling corrupts the message slightly. Watch fidelity drop as rumor spreads!</p>
        </div>
    </div>
    <script>
        const simCanvas = document.getElementById('simCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const sctx = simCanvas.getContext('2d');
        const gctx = graphCanvas.getContext('2d');
        
        let W, H, GW, GH, people = [], paused = false, time = 0;
        let history = [];
        
        const STATE = { IGNORANT: 0, SPREADER: 1, STIFLER: 2 };
        const COLORS = ['#555', '#a78bfa', '#22c55e'];
        
        let params = {
            population: 100,
            spreadRate: 0.3,
            decayRate: 0.1,
            stifleRate: 0.05
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            simCanvas.width = c.clientWidth;
            simCanvas.height = c.clientHeight * 0.6;
            graphCanvas.width = c.clientWidth;
            graphCanvas.height = c.clientHeight * 0.4;
            W = simCanvas.width;
            H = simCanvas.height;
            GW = graphCanvas.width;
            GH = graphCanvas.height;
        }
        
        class Person {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.state = STATE.IGNORANT;
                this.fidelity = 0; // Message accuracy (0-1)
                this.messageVersion = 0;
            }
            
            update() {
                this.vx += (Math.random() - 0.5) * 0.2;
                this.vy += (Math.random() - 0.5) * 0.2;
                
                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (speed > 2) {
                    this.vx *= 2 / speed;
                    this.vy *= 2 / speed;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < 20) { this.x = 20; this.vx *= -1; }
                if (this.x > W - 20) { this.x = W - 20; this.vx *= -1; }
                if (this.y < 20) { this.y = 20; this.vy *= -1; }
                if (this.y > H - 20) { this.y = H - 20; this.vy *= -1; }
            }
            
            draw() {
                // Size based on fidelity for spreaders
                const size = this.state === STATE.SPREADER ? 6 + this.fidelity * 4 : 6;
                
                // Glow for spreaders
                if (this.state === STATE.SPREADER) {
                    sctx.fillStyle = `rgba(167, 139, 250, ${0.2 + this.fidelity * 0.3})`;
                    sctx.beginPath();
                    sctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
                    sctx.fill();
                }
                
                sctx.fillStyle = COLORS[this.state];
                sctx.beginPath();
                sctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                sctx.fill();
                
                // Show fidelity percentage for spreaders
                if (this.state === STATE.SPREADER && this.fidelity > 0) {
                    sctx.fillStyle = '#fff';
                    sctx.font = '8px sans-serif';
                    sctx.fillText(Math.round(this.fidelity * 100) + '%', this.x - 8, this.y - 12);
                }
            }
        }
        
        function init() {
            resize();
            time = 0;
            history = [];
            people = [];
            
            for (let i = 0; i < params.population; i++) {
                people.push(new Person(
                    50 + Math.random() * (W - 100),
                    50 + Math.random() * (H - 100)
                ));
            }
            
            // Start with one spreader
            if (people.length > 0) {
                const starter = people[Math.floor(people.length / 2)];
                starter.state = STATE.SPREADER;
                starter.fidelity = 1.0;
                starter.messageVersion = 1;
            }
            
            updateStats();
        }
        
        function step() {
            time++;
            
            // Update positions
            for (const p of people) {
                p.update();
            }
            
            // Interactions
            for (let i = 0; i < people.length; i++) {
                for (let j = i + 1; j < people.length; j++) {
                    const p1 = people[i];
                    const p2 = people[j];
                    
                    const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
                    if (dist > 30) continue;
                    
                    // Spreader meets Ignorant
                    if (p1.state === STATE.SPREADER && p2.state === STATE.IGNORANT) {
                        if (Math.random() < params.spreadRate) {
                            p2.state = STATE.SPREADER;
                            // Message decays with each telling
                            p2.fidelity = p1.fidelity * (1 - params.decayRate);
                            p2.messageVersion = p1.messageVersion + 1;
                        }
                    } else if (p2.state === STATE.SPREADER && p1.state === STATE.IGNORANT) {
                        if (Math.random() < params.spreadRate) {
                            p1.state = STATE.SPREADER;
                            p1.fidelity = p2.fidelity * (1 - params.decayRate);
                            p1.messageVersion = p2.messageVersion + 1;
                        }
                    }
                    
                    // Spreader meets Spreader or Stifler -> becomes Stifler
                    if (p1.state === STATE.SPREADER && (p2.state === STATE.SPREADER || p2.state === STATE.STIFLER)) {
                        if (Math.random() < params.stifleRate) {
                            p1.state = STATE.STIFLER;
                        }
                    }
                    if (p2.state === STATE.SPREADER && (p1.state === STATE.SPREADER || p1.state === STATE.STIFLER)) {
                        if (Math.random() < params.stifleRate) {
                            p2.state = STATE.STIFLER;
                        }
                    }
                }
            }
            
            // Record history
            const counts = getCounts();
            history.push(counts);
            if (history.length > 500) history.shift();
            
            updateStats();
        }
        
        function getCounts() {
            const counts = { ignorant: 0, spreaders: 0, stiflers: 0, fidelity: 0 };
            let spreaderCount = 0;
            
            for (const p of people) {
                if (p.state === STATE.IGNORANT) counts.ignorant++;
                else if (p.state === STATE.SPREADER) {
                    counts.spreaders++;
                    counts.fidelity += p.fidelity;
                    spreaderCount++;
                }
                else counts.stiflers++;
            }
            
            counts.fidelity = spreaderCount > 0 ? counts.fidelity / spreaderCount : 0;
            return counts;
        }
        
        function updateStats() {
            const counts = getCounts();
            
            document.getElementById('time').textContent = time;
            document.getElementById('ignorant').textContent = counts.ignorant;
            document.getElementById('spreaders').textContent = counts.spreaders;
            document.getElementById('stiflers').textContent = counts.stiflers;
            document.getElementById('fidelity').textContent = (counts.fidelity * 100).toFixed(1);
        }
        
        function drawSim() {
            sctx.fillStyle = '#1a1a2e';
            sctx.fillRect(0, 0, W, H);
            
            // Draw connections between spreaders
            sctx.strokeStyle = 'rgba(167, 139, 250, 0.1)';
            sctx.lineWidth = 1;
            const spreaders = people.filter(p => p.state === STATE.SPREADER);
            for (let i = 0; i < spreaders.length; i++) {
                for (let j = i + 1; j < spreaders.length; j++) {
                    const dist = Math.sqrt((spreaders[i].x - spreaders[j].x) ** 2 + 
                                          (spreaders[i].y - spreaders[j].y) ** 2);
                    if (dist < 100) {
                        sctx.beginPath();
                        sctx.moveTo(spreaders[i].x, spreaders[i].y);
                        sctx.lineTo(spreaders[j].x, spreaders[j].y);
                        sctx.stroke();
                    }
                }
            }
            
            for (const p of people) {
                p.draw();
            }
        }
        
        function drawGraph() {
            gctx.fillStyle = '#0f0f1a';
            gctx.fillRect(0, 0, GW, GH);
            
            if (history.length < 2) return;
            
            const margin = 40;
            const graphW = GW - 2 * margin;
            const graphH = GH - 2 * margin;
            
            gctx.strokeStyle = '#333';
            gctx.lineWidth = 1;
            gctx.beginPath();
            gctx.moveTo(margin, margin);
            gctx.lineTo(margin, GH - margin);
            gctx.lineTo(GW - margin, GH - margin);
            gctx.stroke();
            
            gctx.fillStyle = '#666';
            gctx.font = '11px sans-serif';
            gctx.fillText('Population over time', margin, margin - 10);
            
            const n = history.length;
            const maxY = params.population;
            
            // Draw stacked areas
            const states = ['ignorant', 'spreaders', 'stiflers'];
            const stateColors = ['rgba(85, 85, 85, 0.7)', 'rgba(167, 139, 250, 0.7)', 'rgba(34, 197, 94, 0.7)'];
            
            for (let s = states.length - 1; s >= 0; s--) {
                gctx.fillStyle = stateColors[s];
                gctx.beginPath();
                gctx.moveTo(margin, GH - margin);
                
                for (let i = 0; i < n; i++) {
                    let cumulative = 0;
                    for (let k = 0; k <= s; k++) {
                        cumulative += history[i][states[k]];
                    }
                    const x = margin + (i / (n - 1)) * graphW;
                    const y = GH - margin - (cumulative / maxY) * graphH;
                    gctx.lineTo(x, y);
                }
                
                gctx.lineTo(margin + graphW, GH - margin);
                gctx.closePath();
                gctx.fill();
            }
            
            // Fidelity line
            gctx.strokeStyle = '#fbbf24';
            gctx.lineWidth = 2;
            gctx.beginPath();
            for (let i = 0; i < n; i++) {
                const x = margin + (i / (n - 1)) * graphW;
                const y = GH - margin - history[i].fidelity * graphH;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            }
            gctx.stroke();
            
            gctx.fillStyle = '#fbbf24';
            gctx.fillText('Fidelity', GW - margin - 50, margin + 15);
        }
        
        function draw() {
            drawSim();
            drawGraph();
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) step();
            }, 50);
        }
        
        // Event listeners
        document.getElementById('pop').addEventListener('input', e => {
            params.population = +e.target.value;
            document.getElementById('popVal').textContent = params.population;
        });
        document.getElementById('spread').addEventListener('input', e => {
            params.spreadRate = +e.target.value;
            document.getElementById('spreadVal').textContent = params.spreadRate.toFixed(2);
        });
        document.getElementById('decay').addEventListener('input', e => {
            params.decayRate = +e.target.value;
            document.getElementById('decayVal').textContent = params.decayRate.toFixed(2);
        });
        document.getElementById('stifle').addEventListener('input', e => {
            params.stifleRate = +e.target.value;
            document.getElementById('stifleVal').textContent = params.stifleRate.toFixed(2);
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('newRumor').addEventListener('click', () => {
            const ignorants = people.filter(p => p.state === STATE.IGNORANT);
            if (ignorants.length > 0) {
                const starter = ignorants[Math.floor(Math.random() * ignorants.length)];
                starter.state = STATE.SPREADER;
                starter.fidelity = 1.0;
            }
        });
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
