<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grain Growth Simulation - MaterialSim</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description {
            text-align: center;
            max-width: 700px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #888;
        }
        #container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        #canvas { border: 1px solid #444; image-rendering: pixelated; }
        .panel {
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            width: 220px;
        }
        .panel h3 { font-size: 0.9rem; margin-bottom: 10px; color: #f39c12; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; color: #aaa; margin-bottom: 3px; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 5px; background: #222; color: #ddd; border: 1px solid #444; border-radius: 4px; }
        button {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { opacity: 0.9; }
        .stats { font-size: 0.75rem; color: #888; }
        .stats div { margin-bottom: 3px; }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.8);
            color: #f39c12;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 0.65rem;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Grain Growth Simulation</h1>
    <p class="description">Monte Carlo Potts model for metallurgical grain growth. Watch crystal grains coarsen over time through boundary migration, driven by minimization of grain boundary energy.</p>

    <div id="container">
        <canvas id="canvas" width="400" height="400"></canvas>
        <div class="panel">
            <h3>Controls</h3>
            <div class="control-group">
                <label>Temperature: <span id="tempVal">0.5</span></label>
                <input type="range" id="temperature" min="0.1" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>Initial Grains: <span id="grainVal">50</span></label>
                <input type="range" id="grainCount" min="10" max="200" step="10" value="50">
            </div>
            <div class="control-group">
                <label>Grid Size:</label>
                <select id="gridSize">
                    <option value="100">100x100</option>
                    <option value="150" selected>150x150</option>
                    <option value="200">200x200</option>
                </select>
            </div>
            <div class="control-group">
                <label>Steps per Frame: <span id="stepsVal">500</span></label>
                <input type="range" id="stepsPerFrame" min="100" max="2000" step="100" value="500">
            </div>
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>

            <h3>Statistics</h3>
            <div class="stats">
                <div>Monte Carlo Steps: <span id="mcSteps">0</span></div>
                <div>Current Grains: <span id="currentGrains">0</span></div>
                <div>Avg Grain Size: <span id="avgSize">0</span></div>
                <div>Total Energy: <span id="totalEnergy">0</span></div>
            </div>

            <h3>Grain Colors</h3>
            <div class="legend" id="legend"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let gridSize = 150;
        let grid = [];
        let grainColors = [];
        let temperature = 0.5;
        let initialGrains = 50;
        let stepsPerFrame = 500;
        let mcSteps = 0;
        let running = true;

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function generateColors(n) {
            grainColors = [];
            for (let i = 0; i < n; i++) {
                const hue = (i * 137.508) % 360 / 360;
                const [r, g, b] = hslToRgb(hue, 0.7, 0.5);
                grainColors.push({r, g, b});
            }
        }

        function init() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            initialGrains = parseInt(document.getElementById('grainCount').value);
            generateColors(initialGrains);

            grid = new Array(gridSize * gridSize).fill(0);

            // Voronoi-like initialization
            const seeds = [];
            for (let i = 0; i < initialGrains; i++) {
                seeds.push({
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize),
                    id: i
                });
            }

            // Assign each cell to nearest seed
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let minDist = Infinity;
                    let nearestId = 0;
                    for (const seed of seeds) {
                        // Toroidal distance
                        let dx = Math.abs(x - seed.x);
                        let dy = Math.abs(y - seed.y);
                        dx = Math.min(dx, gridSize - dx);
                        dy = Math.min(dy, gridSize - dy);
                        const dist = dx * dx + dy * dy;
                        if (dist < minDist) {
                            minDist = dist;
                            nearestId = seed.id;
                        }
                    }
                    grid[y * gridSize + x] = nearestId;
                }
            }

            mcSteps = 0;
            updateLegend();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dx, dy] of offsets) {
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                neighbors.push(grid[ny * gridSize + nx]);
            }
            return neighbors;
        }

        function calculateLocalEnergy(x, y) {
            const currentGrain = grid[y * gridSize + x];
            const neighbors = getNeighbors(x, y);
            let energy = 0;
            for (const n of neighbors) {
                if (n !== currentGrain) energy++;
            }
            return energy;
        }

        function mcStep() {
            const x = Math.floor(Math.random() * gridSize);
            const y = Math.floor(Math.random() * gridSize);
            const currentGrain = grid[y * gridSize + x];

            // Get a random neighbor grain
            const neighbors = getNeighbors(x, y);
            const newGrain = neighbors[Math.floor(Math.random() * neighbors.length)];

            if (newGrain === currentGrain) return;

            // Calculate energy change
            const oldEnergy = calculateLocalEnergy(x, y);
            grid[y * gridSize + x] = newGrain;
            const newEnergy = calculateLocalEnergy(x, y);
            const deltaE = newEnergy - oldEnergy;

            // Metropolis criterion
            if (deltaE > 0 && Math.random() > Math.exp(-deltaE / temperature)) {
                grid[y * gridSize + x] = currentGrain; // Reject
            }
        }

        function countGrains() {
            const grains = new Set(grid);
            return grains.size;
        }

        function calculateTotalEnergy() {
            let energy = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    energy += calculateLocalEnergy(x, y);
                }
            }
            return energy / 2; // Each boundary counted twice
        }

        function draw() {
            const cellSize = canvas.width / gridSize;
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const grainId = grid[y * gridSize + x];
                    const color = grainColors[grainId % grainColors.length];

                    // Draw cell (scaling up)
                    for (let py = 0; py < cellSize; py++) {
                        for (let px = 0; px < cellSize; px++) {
                            const screenX = Math.floor(x * cellSize + px);
                            const screenY = Math.floor(y * cellSize + py);
                            if (screenX < canvas.width && screenY < canvas.height) {
                                const idx = (screenY * canvas.width + screenX) * 4;
                                imageData.data[idx] = color.r;
                                imageData.data[idx + 1] = color.g;
                                imageData.data[idx + 2] = color.b;
                                imageData.data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            // Draw grain boundaries
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const current = grid[y * gridSize + x];
                    const right = grid[y * gridSize + ((x + 1) % gridSize)];
                    const below = grid[((y + 1) % gridSize) * gridSize + x];

                    if (current !== right || current !== below) {
                        const screenX = Math.floor((x + 1) * cellSize);
                        const screenY = Math.floor((y + 1) * cellSize);
                        for (let i = -1; i <= 0; i++) {
                            for (let j = -1; j <= 0; j++) {
                                const px = screenX + i;
                                const py = screenY + j;
                                if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                    const idx = (py * canvas.width + px) * 4;
                                    imageData.data[idx] = 0;
                                    imageData.data[idx + 1] = 0;
                                    imageData.data[idx + 2] = 0;
                                    imageData.data[idx + 3] = 255;
                                }
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateStats() {
            const currentGrains = countGrains();
            const totalEnergy = calculateTotalEnergy();
            const avgSize = (gridSize * gridSize) / currentGrains;

            document.getElementById('mcSteps').textContent = mcSteps.toLocaleString();
            document.getElementById('currentGrains').textContent = currentGrains;
            document.getElementById('avgSize').textContent = avgSize.toFixed(1);
            document.getElementById('totalEnergy').textContent = totalEnergy;
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            const uniqueGrains = [...new Set(grid)].slice(0, 10);
            for (const grainId of uniqueGrains) {
                const color = grainColors[grainId % grainColors.length];
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="legend-color" style="background: rgb(${color.r},${color.g},${color.b})"></div><span>G${grainId}</span>`;
                legend.appendChild(item);
            }
            if ([...new Set(grid)].length > 10) {
                const more = document.createElement('div');
                more.className = 'legend-item';
                more.textContent = '...more';
                legend.appendChild(more);
            }
        }

        // Controls
        document.getElementById('temperature').addEventListener('input', function() {
            temperature = parseFloat(this.value);
            document.getElementById('tempVal').textContent = temperature.toFixed(1);
        });

        document.getElementById('grainCount').addEventListener('input', function() {
            document.getElementById('grainVal').textContent = this.value;
        });

        document.getElementById('stepsPerFrame').addEventListener('input', function() {
            stepsPerFrame = parseInt(this.value);
            document.getElementById('stepsVal').textContent = stepsPerFrame;
        });

        document.getElementById('resetBtn').addEventListener('click', init);

        document.getElementById('pauseBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Resume';
        });

        function animate() {
            if (running) {
                for (let i = 0; i < stepsPerFrame; i++) {
                    mcStep();
                    mcSteps++;
                }
                draw();
                if (mcSteps % 5000 < stepsPerFrame) {
                    updateStats();
                    updateLegend();
                }
            }
            requestAnimationFrame(animate);
        }

        init();
        draw();
        updateStats();
        animate();
    </script>
</body>
</html>
