<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man - Ghost AI Behaviors - CCAB</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #000 0%, #1a1a2e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container { display: flex; height: 100vh; }
        .game-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas { border-radius: 8px; }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #ffeb3b; }
        h3 { margin: 15px 0 8px 0; color: #ffc107; font-size: 14px; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #ffeb3b;
            color: #000;
            font-weight: bold;
        }
        button:hover { background: #ffc107; }
        .ghost-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        .ghost-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        .ghost-color {
            width: 20px;
            height: 20px;
            border-radius: 50% 50% 0 0;
        }
        .controls-hint {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            margin: 10px 0;
        }
        .big-score {
            font-size: 2rem;
            text-align: center;
            color: #ffeb3b;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600;">
        <span>‚Üê Gallery</span>
    </a>
    <div class="container">
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>üëª Pac-Man</h2>
            <p style="font-size: 12px; opacity: 0.8;">Classic game with ghost AI behaviors</p>

            <div class="big-score">
                Score: <span id="score">0</span>
            </div>

            <div class="controls-hint">
                Arrow Keys or WASD to move
            </div>

            <button onclick="resetGame()">New Game</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>

            <h3>Ghost Personalities</h3>
            <div class="ghost-legend">
                <div class="ghost-item">
                    <div class="ghost-color" style="background: #ff0000;"></div>
                    <span>Blinky (Chase)</span>
                </div>
                <div class="ghost-item">
                    <div class="ghost-color" style="background: #ffb8ff;"></div>
                    <span>Pinky (Ambush)</span>
                </div>
                <div class="ghost-item">
                    <div class="ghost-color" style="background: #00ffff;"></div>
                    <span>Inky (Flank)</span>
                </div>
                <div class="ghost-item">
                    <div class="ghost-color" style="background: #ffb852;"></div>
                    <span>Clyde (Random)</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat-row"><span>Lives:</span><span id="lives">3</span></div>
                <div class="stat-row"><span>Level:</span><span id="level">1</span></div>
                <div class="stat-row"><span>Dots Left:</span><span id="dots">0</span></div>
                <div class="stat-row"><span>Power Mode:</span><span id="powerMode">No</span></div>
                <div class="stat-row"><span>High Score:</span><span id="highScore">0</span></div>
            </div>

            <div class="description">
                <strong>Ghost AI Behaviors:</strong><br><br>
                <strong style="color: #ff0000;">Blinky:</strong> Direct chase - targets Pac-Man's current position.<br><br>
                <strong style="color: #ffb8ff;">Pinky:</strong> Ambush - targets 4 tiles ahead of Pac-Man.<br><br>
                <strong style="color: #00ffff;">Inky:</strong> Flank - uses Blinky's position to calculate target.<br><br>
                <strong style="color: #ffb852;">Clyde:</strong> Random - switches between chase and scatter.<br><br>
                <strong>Power Pellets:</strong> Make ghosts vulnerable for 8 seconds!
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE = 20;
        const COLS = 28;
        const ROWS = 31;
        canvas.width = COLS * TILE;
        canvas.height = ROWS * TILE;

        // Map: 0=empty, 1=wall, 2=dot, 3=power, 4=gate
        const baseMap = [
            "1111111111111111111111111111",
            "1222222222222112222222222221",
            "1211112111112112111112111121",
            "1311112111112112111112111131",
            "1211112111112112111112111121",
            "1222222222222222222222222221",
            "1211112112111111112112111121",
            "1211112112111111112112111121",
            "1222222112222112222112222221",
            "1111112111110110111112111111",
            "0000012111110110111112100000",
            "0000012110000000001112100000",
            "0000012110111441110112100000",
            "1111112110100000010112111111",
            "0000002000100000010002000000",
            "1111112110100000010112111111",
            "0000012110111111110112100000",
            "0000012110000000001112100000",
            "0000012110111111110112100000",
            "1111112110111111110112111111",
            "1222222222222112222222222221",
            "1211112111112112111112111121",
            "1211112111112112111112111121",
            "1322112222222002222222112231",
            "1112112112111111112112112111",
            "1112112112111111112112112111",
            "1222222112222112222112222221",
            "1211111111112112111111111121",
            "1211111111112112111111111121",
            "1222222222222222222222222221",
            "1111111111111111111111111111"
        ];

        let map = [];
        let pacman = { x: 14, y: 23, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 } };
        let ghosts = [];
        let score = 0;
        let lives = 3;
        let level = 1;
        let highScore = 0;
        let paused = false;
        let gameOver = false;
        let powerMode = false;
        let powerTimer = 0;
        let animFrame = 0;

        function initMap() {
            map = baseMap.map(row => row.split('').map(Number));
        }

        function initGhosts() {
            ghosts = [
                { x: 13, y: 14, color: '#ff0000', name: 'blinky', dir: { x: 0, y: -1 }, scared: false },
                { x: 14, y: 14, color: '#ffb8ff', name: 'pinky', dir: { x: 0, y: -1 }, scared: false },
                { x: 13, y: 13, color: '#00ffff', name: 'inky', dir: { x: 1, y: 0 }, scared: false },
                { x: 14, y: 13, color: '#ffb852', name: 'clyde', dir: { x: -1, y: 0 }, scared: false }
            ];
        }

        function resetGame() {
            initMap();
            pacman = { x: 14, y: 23, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 } };
            initGhosts();
            score = 0;
            lives = 3;
            level = 1;
            powerMode = false;
            powerTimer = 0;
            gameOver = false;
            paused = false;
            document.getElementById('pauseBtn').textContent = 'Pause';
            updateStats();
        }

        function canMove(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return true; // Tunnel
            return map[y][x] !== 1;
        }

        function getTarget(ghost) {
            const px = pacman.x;
            const py = pacman.y;

            switch (ghost.name) {
                case 'blinky':
                    // Direct chase
                    return { x: px, y: py };

                case 'pinky':
                    // 4 tiles ahead
                    return {
                        x: px + pacman.dir.x * 4,
                        y: py + pacman.dir.y * 4
                    };

                case 'inky':
                    // Flank using Blinky's position
                    const blinky = ghosts[0];
                    const ahead = { x: px + pacman.dir.x * 2, y: py + pacman.dir.y * 2 };
                    return {
                        x: ahead.x + (ahead.x - blinky.x),
                        y: ahead.y + (ahead.y - blinky.y)
                    };

                case 'clyde':
                    // Random when close
                    const dist = Math.hypot(ghost.x - px, ghost.y - py);
                    if (dist < 8) {
                        return { x: 1, y: ROWS - 2 }; // Scatter corner
                    }
                    return { x: px, y: py };

                default:
                    return { x: px, y: py };
            }
        }

        function moveGhost(ghost) {
            if (powerMode && ghost.scared) {
                // Run away
                const dirs = [
                    { x: 0, y: -1 }, { x: 0, y: 1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 }
                ];

                let bestDir = ghost.dir;
                let maxDist = 0;

                for (const d of dirs) {
                    // Don't reverse
                    if (d.x === -ghost.dir.x && d.y === -ghost.dir.y) continue;

                    const nx = ghost.x + d.x;
                    const ny = ghost.y + d.y;

                    if (canMove(nx, ny) && map[ny]?.[nx] !== 4) {
                        const dist = Math.hypot(nx - pacman.x, ny - pacman.y);
                        if (dist > maxDist) {
                            maxDist = dist;
                            bestDir = d;
                        }
                    }
                }
                ghost.dir = bestDir;
            } else {
                // Chase
                const target = getTarget(ghost);
                const dirs = [
                    { x: 0, y: -1 }, { x: 0, y: 1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 }
                ];

                let bestDir = ghost.dir;
                let minDist = Infinity;

                for (const d of dirs) {
                    // Don't reverse
                    if (d.x === -ghost.dir.x && d.y === -ghost.dir.y) continue;

                    const nx = ghost.x + d.x;
                    const ny = ghost.y + d.y;

                    if (canMove(nx, ny) && map[ny]?.[nx] !== 4) {
                        const dist = Math.hypot(nx - target.x, ny - target.y);
                        if (dist < minDist) {
                            minDist = dist;
                            bestDir = d;
                        }
                    }
                }
                ghost.dir = bestDir;
            }

            ghost.x += ghost.dir.x;
            ghost.y += ghost.dir.y;

            // Tunnel wrap
            if (ghost.x < 0) ghost.x = COLS - 1;
            if (ghost.x >= COLS) ghost.x = 0;
        }

        function update() {
            if (paused || gameOver) return;

            animFrame++;

            // Try next direction first
            const nextX = pacman.x + pacman.nextDir.x;
            const nextY = pacman.y + pacman.nextDir.y;
            if (canMove(nextX, nextY)) {
                pacman.dir = { ...pacman.nextDir };
            }

            // Move Pac-Man
            const newX = pacman.x + pacman.dir.x;
            const newY = pacman.y + pacman.dir.y;
            if (canMove(newX, newY)) {
                pacman.x = newX;
                pacman.y = newY;

                // Tunnel wrap
                if (pacman.x < 0) pacman.x = COLS - 1;
                if (pacman.x >= COLS) pacman.x = 0;
            }

            // Eat dots
            if (map[pacman.y]?.[pacman.x] === 2) {
                map[pacman.y][pacman.x] = 0;
                score += 10;
            }

            // Eat power pellet
            if (map[pacman.y]?.[pacman.x] === 3) {
                map[pacman.y][pacman.x] = 0;
                score += 50;
                powerMode = true;
                powerTimer = 480; // 8 seconds at 60fps
                ghosts.forEach(g => g.scared = true);
            }

            // Power mode timer
            if (powerMode) {
                powerTimer--;
                if (powerTimer <= 0) {
                    powerMode = false;
                    ghosts.forEach(g => g.scared = false);
                }
            }

            // Move ghosts
            if (animFrame % 2 === 0) {
                ghosts.forEach(moveGhost);
            }

            // Check collision
            for (const ghost of ghosts) {
                if (Math.abs(ghost.x - pacman.x) < 1 && Math.abs(ghost.y - pacman.y) < 1) {
                    if (powerMode && ghost.scared) {
                        // Eat ghost
                        score += 200;
                        ghost.x = 13;
                        ghost.y = 14;
                        ghost.scared = false;
                    } else {
                        // Lose life
                        lives--;
                        if (lives <= 0) {
                            gameOver = true;
                            if (score > highScore) highScore = score;
                        } else {
                            pacman = { x: 14, y: 23, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 } };
                            initGhosts();
                        }
                    }
                }
            }

            // Check level complete
            const dotsLeft = map.flat().filter(c => c === 2 || c === 3).length;
            if (dotsLeft === 0) {
                level++;
                initMap();
                pacman = { x: 14, y: 23, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 } };
                initGhosts();
            }

            updateStats();
        }

        function updateStats() {
            const dotsLeft = map.flat().filter(c => c === 2 || c === 3).length;
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
            document.getElementById('dots').textContent = dotsLeft;
            document.getElementById('powerMode').textContent = powerMode ? `Yes (${Math.ceil(powerTimer/60)}s)` : 'No';
            document.getElementById('highScore').textContent = highScore;
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw map
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = map[y][x];

                    if (cell === 1) {
                        ctx.fillStyle = '#2121de';
                        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
                    } else if (cell === 2) {
                        ctx.fillStyle = '#ffb897';
                        ctx.beginPath();
                        ctx.arc(x * TILE + TILE/2, y * TILE + TILE/2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 3) {
                        ctx.fillStyle = '#ffb897';
                        ctx.beginPath();
                        ctx.arc(x * TILE + TILE/2, y * TILE + TILE/2, 7, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 4) {
                        ctx.fillStyle = '#ffb8ff';
                        ctx.fillRect(x * TILE, y * TILE + TILE/2 - 2, TILE, 4);
                    }
                }
            }

            // Draw Pac-Man
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            const mouthAngle = 0.2 + Math.abs(Math.sin(animFrame * 0.3)) * 0.3;
            let startAngle = mouthAngle;
            let endAngle = Math.PI * 2 - mouthAngle;

            // Adjust angle based on direction
            if (pacman.dir.x === 1) { startAngle += 0; endAngle += 0; }
            else if (pacman.dir.x === -1) { startAngle += Math.PI; endAngle += Math.PI; }
            else if (pacman.dir.y === -1) { startAngle -= Math.PI/2; endAngle -= Math.PI/2; }
            else if (pacman.dir.y === 1) { startAngle += Math.PI/2; endAngle += Math.PI/2; }

            ctx.arc(pacman.x * TILE + TILE/2, pacman.y * TILE + TILE/2, TILE/2 - 2, startAngle, endAngle);
            ctx.lineTo(pacman.x * TILE + TILE/2, pacman.y * TILE + TILE/2);
            ctx.fill();

            // Draw ghosts
            for (const ghost of ghosts) {
                const gx = ghost.x * TILE + TILE/2;
                const gy = ghost.y * TILE + TILE/2;

                if (ghost.scared && powerMode) {
                    ctx.fillStyle = powerTimer < 120 && animFrame % 20 < 10 ? '#fff' : '#2121de';
                } else {
                    ctx.fillStyle = ghost.color;
                }

                // Body
                ctx.beginPath();
                ctx.arc(gx, gy - 2, TILE/2 - 2, Math.PI, 0);
                ctx.lineTo(gx + TILE/2 - 2, gy + TILE/2 - 4);

                // Wavy bottom
                for (let i = 0; i < 3; i++) {
                    const wx = gx + TILE/2 - 2 - i * (TILE-4)/3;
                    ctx.lineTo(wx - (TILE-4)/6, gy + TILE/2 - 8);
                    ctx.lineTo(wx - (TILE-4)/3, gy + TILE/2 - 4);
                }
                ctx.lineTo(gx - TILE/2 + 2, gy + TILE/2 - 4);
                ctx.fill();

                // Eyes
                if (!ghost.scared || !powerMode) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(gx - 4, gy - 3, 4, 0, Math.PI * 2);
                    ctx.arc(gx + 4, gy - 3, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#00f';
                    const eyeDir = ghost.dir;
                    ctx.beginPath();
                    ctx.arc(gx - 4 + eyeDir.x * 2, gy - 3 + eyeDir.y * 2, 2, 0, Math.PI * 2);
                    ctx.arc(gx + 4 + eyeDir.x * 2, gy - 3 + eyeDir.y * 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Game over
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);

                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 40);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            if (gameOver) {
                resetGame();
            } else {
                paused = !paused;
                document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
            }
        }

        // Controls
        document.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    pacman.nextDir = { x: 0, y: -1 };
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    pacman.nextDir = { x: 0, y: 1 };
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    pacman.nextDir = { x: -1, y: 0 };
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    pacman.nextDir = { x: 1, y: 0 };
                    e.preventDefault();
                    break;
                case ' ':
                    togglePause();
                    e.preventDefault();
                    break;
            }
        });

        resetGame();
        gameLoop();
    </script>
</body>
</html>
