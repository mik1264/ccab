<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystallization - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a1628; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #a5f3fc; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #22d3ee; color: #0a1628; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #06b6d4; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #22d3ee; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Crystallization</h1>
            <p class="description">Crystal growth simulation with nucleation and lattice formation. Atoms randomly move until they find stable lattice positions near existing crystal structure.</p>
            
            <div class="control-group">
                <label>Temperature: <span id="tempVal">0.5</span></label>
                <input type="range" id="temp" min="0.1" max="1.0" step="0.05" value="0.5">
            </div>
            <div class="control-group">
                <label>Atoms in Solution: <span id="atomsVal">500</span></label>
                <input type="range" id="atoms" min="100" max="1000" value="500">
            </div>
            <div class="control-group">
                <label>Lattice Spacing: <span id="spacingVal">12</span></label>
                <input type="range" id="spacing" min="8" max="20" value="12">
            </div>
            
            <button id="reset">Reset</button>
            <button id="pause">Pause</button>
            <button id="seed">Add Seed Crystal</button>
            <button id="cool">Rapid Cooling</button>
            
            <div class="stats">
                <div>Free Atoms: <span id="freeAtoms">0</span></div>
                <div>Crystallized: <span id="crystallized">0</span></div>
                <div>Crystal Size: <span id="crystalSize">0</span>%</div>
                <div>Temperature: <span id="temperature">0.5</span></div>
            </div>
            
            <p class="description"><strong>Temperature effect:</strong> Higher temperature = more random motion, slower crystallization. Lower temperature = faster growth but more defects.</p>
            
            <p class="description"><strong>Crystal colors:</strong> White = seed crystal, cyan shades = growth layers, blue = newly crystallized</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let SIZE = 600;
        let atoms = [];
        let crystal = [];
        let latticePoints = [];
        let paused = false;
        
        let params = {
            temp: 0.5,
            atomCount: 500,
            spacing: 12
        };
        
        function resize() {
            const container = document.getElementById('canvas-container');
            SIZE = Math.min(container.clientWidth - 40, container.clientHeight - 40, 600);
            canvas.width = SIZE;
            canvas.height = SIZE;
        }
        
        function generateLatticePoints() {
            latticePoints = [];
            const spacing = params.spacing;
            const centerX = SIZE / 2;
            const centerY = SIZE / 2;
            
            // Generate hexagonal lattice points
            for (let y = spacing; y < SIZE - spacing; y += spacing * 0.866) {
                const row = Math.floor(y / (spacing * 0.866));
                const offset = (row % 2) * (spacing / 2);
                for (let x = spacing + offset; x < SIZE - spacing; x += spacing) {
                    latticePoints.push({
                        x: x,
                        y: y,
                        occupied: false
                    });
                }
            }
        }
        
        function init() {
            resize();
            generateLatticePoints();
            atoms = [];
            crystal = [];
            
            // Create free atoms
            for (let i = 0; i < params.atomCount; i++) {
                atoms.push({
                    x: Math.random() * SIZE,
                    y: Math.random() * SIZE,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    crystallized: false
                });
            }
            
            // Add seed crystal at center
            addSeedCrystal();
            
            updateStats();
        }
        
        function addSeedCrystal() {
            const centerX = SIZE / 2;
            const centerY = SIZE / 2;
            
            // Find closest lattice point to center
            let minDist = Infinity;
            let centerPoint = null;
            for (const point of latticePoints) {
                const dist = Math.sqrt(Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2));
                if (dist < minDist) {
                    minDist = dist;
                    centerPoint = point;
                }
            }
            
            if (centerPoint && !centerPoint.occupied) {
                centerPoint.occupied = true;
                crystal.push({
                    x: centerPoint.x,
                    y: centerPoint.y,
                    layer: 0,
                    seed: true
                });
            }
        }
        
        function findNearestLatticePoint(x, y) {
            let minDist = Infinity;
            let nearest = null;
            
            for (const point of latticePoints) {
                if (point.occupied) continue;
                const dist = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = point;
                }
            }
            
            return { point: nearest, dist: minDist };
        }
        
        function isNearCrystal(x, y) {
            const threshold = params.spacing * 1.5;
            for (const c of crystal) {
                const dist = Math.sqrt(Math.pow(c.x - x, 2) + Math.pow(c.y - y, 2));
                if (dist < threshold) return true;
            }
            return false;
        }
        
        function step() {
            if (paused) return;
            
            const temp = params.temp;
            const crystallizeProb = (1 - temp) * 0.3;
            
            for (const atom of atoms) {
                if (atom.crystallized) continue;
                
                // Random thermal motion
                atom.vx += (Math.random() - 0.5) * temp * 2;
                atom.vy += (Math.random() - 0.5) * temp * 2;
                
                // Damping
                atom.vx *= 0.95;
                atom.vy *= 0.95;
                
                // Move
                atom.x += atom.vx;
                atom.y += atom.vy;
                
                // Bounce off walls
                if (atom.x < 5 || atom.x > SIZE - 5) atom.vx *= -1;
                if (atom.y < 5 || atom.y > SIZE - 5) atom.vy *= -1;
                atom.x = Math.max(5, Math.min(SIZE - 5, atom.x));
                atom.y = Math.max(5, Math.min(SIZE - 5, atom.y));
                
                // Check if near crystal and can crystallize
                if (isNearCrystal(atom.x, atom.y)) {
                    const { point, dist } = findNearestLatticePoint(atom.x, atom.y);
                    if (point && dist < params.spacing && Math.random() < crystallizeProb) {
                        // Crystallize!
                        atom.crystallized = true;
                        point.occupied = true;
                        crystal.push({
                            x: point.x,
                            y: point.y,
                            layer: crystal.length,
                            seed: false
                        });
                    }
                }
            }
            
            updateStats();
        }
        
        function updateStats() {
            const free = atoms.filter(a => !a.crystallized).length;
            const crystallized = atoms.filter(a => a.crystallized).length;
            const pct = ((crystallized / params.atomCount) * 100).toFixed(1);
            
            document.getElementById('freeAtoms').textContent = free;
            document.getElementById('crystallized').textContent = crystallized;
            document.getElementById('crystalSize').textContent = pct;
            document.getElementById('temperature').textContent = params.temp.toFixed(2);
        }
        
        function draw() {
            ctx.fillStyle = '#0a1628';
            ctx.fillRect(0, 0, SIZE, SIZE);
            
            // Draw lattice points (subtle)
            ctx.fillStyle = 'rgba(100, 100, 100, 0.1)';
            for (const point of latticePoints) {
                if (!point.occupied) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw crystal
            for (const c of crystal) {
                if (c.seed) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 10;
                } else {
                    // Color based on layer
                    const layerRatio = c.layer / crystal.length;
                    const hue = 180 + layerRatio * 40; // Cyan to blue
                    ctx.fillStyle = `hsl(${hue}, 80%, ${50 + layerRatio * 20}%)`;
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.shadowBlur = 3;
                }
                
                ctx.beginPath();
                ctx.arc(c.x, c.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            
            // Draw free atoms
            for (const atom of atoms) {
                if (atom.crystallized) continue;
                
                ctx.fillStyle = 'rgba(168, 85, 247, 0.6)';
                ctx.beginPath();
                ctx.arc(atom.x, atom.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSimulation() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(step, 30);
        }
        
        // Event listeners
        document.getElementById('temp').addEventListener('input', e => {
            params.temp = +e.target.value;
            document.getElementById('tempVal').textContent = params.temp.toFixed(2);
        });
        
        document.getElementById('atoms').addEventListener('input', e => {
            params.atomCount = +e.target.value;
            document.getElementById('atomsVal').textContent = params.atomCount;
        });
        
        document.getElementById('spacing').addEventListener('input', e => {
            params.spacing = +e.target.value;
            document.getElementById('spacingVal').textContent = params.spacing;
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            init();
            startSimulation();
        });
        
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('seed').addEventListener('click', addSeedCrystal);
        
        document.getElementById('cool').addEventListener('click', () => {
            params.temp = 0.1;
            document.getElementById('temp').value = 0.1;
            document.getElementById('tempVal').textContent = '0.10';
        });
        
        window.addEventListener('resize', resize);
        
        init();
        draw();
        startSimulation();
    </script>
</body>
</html>
