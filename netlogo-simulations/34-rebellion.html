<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rebellion - Epstein Civil Violence Model - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1f1f1f; color: #e6e6e6; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(30,30,30,0.95); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 10px; color: #ef4444; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #dc2626; }
        .stats { background: rgba(255,255,255,0.05); padding: 12px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 4px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(30,30,30,0.9); color: #ef4444; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .legend { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
        .legend-item { display: flex; align-items: center; gap: 4px; font-size: 0.7rem; }
        .legend-dot { width: 12px; height: 12px; border-radius: 2px; }
        .graph { background: #2a2a2a; border-radius: 5px; padding: 10px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Rebellion Model</h1>
            <p class="description">Epstein's civil violence model with citizens and cops. Citizens have grievance based on hardship and regime legitimacy. When grievance exceeds threshold and risk is low, they rebel. Cops arrest active rebels.</p>

            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background:#22c55e"></div>Quiet Citizen</div>
                <div class="legend-item"><div class="legend-dot" style="background:#ef4444"></div>Active Rebel</div>
                <div class="legend-item"><div class="legend-dot" style="background:#6366f1"></div>Cop</div>
                <div class="legend-item"><div class="legend-dot" style="background:#6b7280"></div>Jailed</div>
            </div>

            <div class="stats">
                <div>Population: <span id="population">0</span></div>
                <div>Quiet Citizens: <span id="quietCount">0</span></div>
                <div>Active Rebels: <span id="activeCount">0</span></div>
                <div>Jailed: <span id="jailedCount">0</span></div>
                <div>Cops: <span id="copCount">0</span></div>
                <div>Time Step: <span id="timeStep">0</span></div>
            </div>

            <div class="graph">
                <canvas id="graphCanvas" width="260" height="120"></canvas>
            </div>

            <div class="control-group">
                <label>Cop Density: <span id="copDensityVal">0.04</span></label>
                <input type="range" id="copDensity" min="0.01" max="0.15" step="0.01" value="0.04">
            </div>

            <div class="control-group">
                <label>Legitimacy: <span id="legitimacyVal">0.8</span></label>
                <input type="range" id="legitimacy" min="0.1" max="1.0" step="0.05" value="0.8">
            </div>

            <div class="control-group">
                <label>Max Jail Term: <span id="maxJailVal">30</span></label>
                <input type="range" id="maxJail" min="5" max="100" step="5" value="30">
            </div>

            <div class="control-group">
                <label>Vision Range: <span id="visionVal">7</span></label>
                <input type="range" id="vision" min="1" max="15" step="1" value="7">
            </div>

            <div class="control-group">
                <label>Threshold: <span id="thresholdVal">0.1</span></label>
                <input type="range" id="threshold" min="0.0" max="0.5" step="0.05" value="0.1">
            </div>

            <button onclick="reset()">Reset Simulation</button>
            <button onclick="togglePause()">Pause / Resume</button>
            <button onclick="crackdown()">Crackdown (Add Cops)</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Grid
        const CELL_SIZE = 12;
        let gridWidth, gridHeight;
        let grid;

        // Agent types
        const EMPTY = 0, CITIZEN = 1, COP = 2;
        const QUIET = 0, ACTIVE = 1, JAILED = 2;

        // Parameters
        let copDensity = 0.04;
        let legitimacy = 0.8;
        let maxJail = 30;
        let vision = 7;
        let threshold = 0.1;

        let agents = [];
        let timeStep = 0;
        let paused = false;
        let history = { quiet: [], active: [], jailed: [] };

        class Agent {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // CITIZEN or COP

                if (type === CITIZEN) {
                    this.hardship = Math.random(); // perceived hardship
                    this.riskAversion = Math.random(); // risk tolerance
                    this.state = QUIET;
                    this.jailTerm = 0;
                    this.grievance = this.hardship * (1 - legitimacy);
                }
            }

            update() {
                if (this.type === CITIZEN) {
                    if (this.state === JAILED) {
                        this.jailTerm--;
                        if (this.jailTerm <= 0) {
                            this.state = QUIET;
                        }
                        return;
                    }

                    // Calculate grievance
                    this.grievance = this.hardship * (1 - legitimacy);

                    // Calculate arrest probability
                    const { cops, actives } = this.countNearby();
                    const arrestProb = 1 - Math.exp(-2.3 * Math.floor(cops / (actives + 1)));
                    const netRisk = arrestProb * this.riskAversion;

                    // Decide to rebel or stay quiet
                    if (this.grievance - netRisk > threshold) {
                        this.state = ACTIVE;
                    } else {
                        this.state = QUIET;
                    }
                } else if (this.type === COP) {
                    // Arrest nearby active citizens
                    this.arrest();
                }

                // Move
                this.move();
            }

            countNearby() {
                let cops = 0, actives = 0;

                for (let dy = -vision; dy <= vision; dy++) {
                    for (let dx = -vision; dx <= vision; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        if (Math.abs(dx) + Math.abs(dy) > vision) continue;

                        const nx = (this.x + dx + gridWidth) % gridWidth;
                        const ny = (this.y + dy + gridHeight) % gridHeight;
                        const cell = grid[ny][nx];

                        if (cell && cell.type === COP) cops++;
                        if (cell && cell.type === CITIZEN && cell.state === ACTIVE) actives++;
                    }
                }

                return { cops, actives };
            }

            arrest() {
                // Find active citizens nearby
                const targets = [];

                for (let dy = -vision; dy <= vision; dy++) {
                    for (let dx = -vision; dx <= vision; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        if (Math.abs(dx) + Math.abs(dy) > vision) continue;

                        const nx = (this.x + dx + gridWidth) % gridWidth;
                        const ny = (this.y + dy + gridHeight) % gridHeight;
                        const cell = grid[ny][nx];

                        if (cell && cell.type === CITIZEN && cell.state === ACTIVE) {
                            targets.push(cell);
                        }
                    }
                }

                if (targets.length > 0) {
                    // Arrest random active citizen
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    target.state = JAILED;
                    target.jailTerm = Math.floor(Math.random() * maxJail) + 1;
                }
            }

            move() {
                // Find empty neighboring cell
                const neighbors = [];

                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;

                        const nx = (this.x + dx + gridWidth) % gridWidth;
                        const ny = (this.y + dy + gridHeight) % gridHeight;

                        if (!grid[ny][nx]) {
                            neighbors.push({ x: nx, y: ny });
                        }
                    }
                }

                if (neighbors.length > 0 && Math.random() < 0.3) {
                    const newPos = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[this.y][this.x] = null;
                    this.x = newPos.x;
                    this.y = newPos.y;
                    grid[this.y][this.x] = this;
                }
            }

            draw() {
                const x = this.x * CELL_SIZE + CELL_SIZE / 2;
                const y = this.y * CELL_SIZE + CELL_SIZE / 2;

                if (this.type === CITIZEN) {
                    if (this.state === JAILED) {
                        ctx.fillStyle = '#6b7280';
                    } else if (this.state === ACTIVE) {
                        ctx.fillStyle = '#ef4444';
                    } else {
                        // Color by grievance level
                        const g = Math.floor(this.grievance * 255);
                        ctx.fillStyle = `rgb(${g}, ${200 - g}, 100)`;
                    }
                    ctx.beginPath();
                    ctx.arc(x, y, CELL_SIZE / 2 - 1, 0, Math.PI * 2);
                    ctx.fill();

                    // Active indicator
                    if (this.state === ACTIVE) {
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, CELL_SIZE / 2 + 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (this.type === COP) {
                    ctx.fillStyle = '#6366f1';
                    ctx.fillRect(x - CELL_SIZE / 2 + 1, y - CELL_SIZE / 2 + 1, CELL_SIZE - 2, CELL_SIZE - 2);

                    // Badge
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function init() {
            gridWidth = Math.floor(canvas.width / CELL_SIZE);
            gridHeight = Math.floor(canvas.height / CELL_SIZE);
            grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(null));
            agents = [];
            timeStep = 0;
            history = { quiet: [], active: [], jailed: [] };

            const totalCells = gridWidth * gridHeight;
            const citizenDensity = 0.7;
            const numCitizens = Math.floor(totalCells * citizenDensity);
            const numCops = Math.floor(totalCells * copDensity);

            // Place citizens
            let placed = 0;
            while (placed < numCitizens) {
                const x = Math.floor(Math.random() * gridWidth);
                const y = Math.floor(Math.random() * gridHeight);
                if (!grid[y][x]) {
                    const agent = new Agent(x, y, CITIZEN);
                    grid[y][x] = agent;
                    agents.push(agent);
                    placed++;
                }
            }

            // Place cops
            placed = 0;
            while (placed < numCops) {
                const x = Math.floor(Math.random() * gridWidth);
                const y = Math.floor(Math.random() * gridHeight);
                if (!grid[y][x]) {
                    const agent = new Agent(x, y, COP);
                    grid[y][x] = agent;
                    agents.push(agent);
                    placed++;
                }
            }
        }

        function update() {
            if (paused) return;

            timeStep++;

            // Shuffle agents for random update order
            const shuffled = [...agents].sort(() => Math.random() - 0.5);
            shuffled.forEach(agent => agent.update());

            // Record history
            const citizens = agents.filter(a => a.type === CITIZEN);
            const quiet = citizens.filter(c => c.state === QUIET).length;
            const active = citizens.filter(c => c.state === ACTIVE).length;
            const jailed = citizens.filter(c => c.state === JAILED).length;

            history.quiet.push(quiet);
            history.active.push(active);
            history.jailed.push(jailed);

            if (history.quiet.length > 200) {
                history.quiet.shift();
                history.active.shift();
                history.jailed.shift();
            }

            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#1f1f1f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines (subtle)
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= gridWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, gridHeight * CELL_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y <= gridHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(gridWidth * CELL_SIZE, y * CELL_SIZE);
                ctx.stroke();
            }

            // Draw agents
            agents.forEach(agent => agent.draw());

            // Draw graph
            drawGraph();
        }

        function drawGraph() {
            graphCtx.fillStyle = '#2a2a2a';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (history.quiet.length < 2) return;

            const total = agents.filter(a => a.type === CITIZEN).length;
            const maxY = total;

            const drawLine = (data, color) => {
                graphCtx.strokeStyle = color;
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();

                data.forEach((val, i) => {
                    const x = (i / 200) * graphCanvas.width;
                    const y = graphCanvas.height - (val / maxY) * graphCanvas.height;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                });
                graphCtx.stroke();
            };

            drawLine(history.quiet, '#22c55e');
            drawLine(history.active, '#ef4444');
            drawLine(history.jailed, '#6b7280');
        }

        function updateStats() {
            const citizens = agents.filter(a => a.type === CITIZEN);
            const cops = agents.filter(a => a.type === COP);

            document.getElementById('population').textContent = citizens.length;
            document.getElementById('quietCount').textContent = citizens.filter(c => c.state === QUIET).length;
            document.getElementById('activeCount').textContent = citizens.filter(c => c.state === ACTIVE).length;
            document.getElementById('jailedCount').textContent = citizens.filter(c => c.state === JAILED).length;
            document.getElementById('copCount').textContent = cops.length;
            document.getElementById('timeStep').textContent = timeStep;
        }

        function reset() { init(); }
        function togglePause() { paused = !paused; }

        function crackdown() {
            // Add more cops
            const numNew = 10;
            let added = 0;
            while (added < numNew) {
                const x = Math.floor(Math.random() * gridWidth);
                const y = Math.floor(Math.random() * gridHeight);
                if (!grid[y][x]) {
                    const agent = new Agent(x, y, COP);
                    grid[y][x] = agent;
                    agents.push(agent);
                    added++;
                }
            }
        }

        // Event listeners
        document.getElementById('copDensity').addEventListener('input', function() {
            copDensity = parseFloat(this.value);
            document.getElementById('copDensityVal').textContent = this.value;
        });

        document.getElementById('legitimacy').addEventListener('input', function() {
            legitimacy = parseFloat(this.value);
            document.getElementById('legitimacyVal').textContent = this.value;
            // Update grievances
            agents.filter(a => a.type === CITIZEN).forEach(c => {
                c.grievance = c.hardship * (1 - legitimacy);
            });
        });

        document.getElementById('maxJail').addEventListener('input', function() {
            maxJail = parseInt(this.value);
            document.getElementById('maxJailVal').textContent = this.value;
        });

        document.getElementById('vision').addEventListener('input', function() {
            vision = parseInt(this.value);
            document.getElementById('visionVal').textContent = this.value;
        });

        document.getElementById('threshold').addEventListener('input', function() {
            threshold = parseFloat(this.value);
            document.getElementById('thresholdVal').textContent = this.value;
        });

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        init();
        animate();
    </script>
</body>
</html>
