<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Sprawl - City Growth Simulation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        #simCanvas { width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #64748b; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #475569; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #334155; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #64748b; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .legend { font-size: 0.65rem; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; margin: 3px 0; }
        .legend-color { width: 15px; height: 15px; margin-right: 8px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Urban Sprawl</h1>
            <p class="description">Watch a city grow outward from a central core. Development spreads along transportation networks and responds to zoning.</p>
            
            <div class="control-group">
                <label>Growth Rate: <span id="growthVal">0.3</span></label>
                <input type="range" id="growth" min="0.1" max="0.8" step="0.05" value="0.3">
            </div>
            <div class="control-group">
                <label>Road Priority: <span id="roadVal">0.7</span></label>
                <input type="range" id="road" min="0" max="1" step="0.1" value="0.7">
            </div>
            <div class="control-group">
                <label>Commercial Ratio: <span id="commVal">0.2</span></label>
                <input type="range" id="comm" min="0.1" max="0.5" step="0.05" value="0.2">
            </div>
            <div class="control-group">
                <label>Industrial Ratio: <span id="indVal">0.1</span></label>
                <input type="range" id="ind" min="0" max="0.3" step="0.05" value="0.1">
            </div>
            <div class="control-group">
                <label>Green Space Target: <span id="greenVal">0.15</span></label>
                <input type="range" id="green" min="0" max="0.3" step="0.05" value="0.15">
            </div>
            
            <button id="reset">Reset City</button>
            <button id="pause">Pause</button>
            <button id="highway">Build Highway</button>
            <button id="park">Add Park</button>
            
            <div class="stats">
                <div>Year: <span id="year">2000</span></div>
                <div>Population: <span id="population">0</span></div>
                <div>Developed Area: <span id="developed">0</span>%</div>
                <div>Road Network: <span id="roads">0</span> km</div>
                <div>Density: <span id="density">0</span>/km²</div>
            </div>
            
            <div class="legend">
                <strong>Zone Types:</strong>
                <div class="legend-item"><div class="legend-color" style="background:#fef3c7"></div>Residential - Low</div>
                <div class="legend-item"><div class="legend-color" style="background:#fcd34d"></div>Residential - High</div>
                <div class="legend-item"><div class="legend-color" style="background:#60a5fa"></div>Commercial</div>
                <div class="legend-item"><div class="legend-color" style="background:#a855f7"></div>Industrial</div>
                <div class="legend-item"><div class="legend-color" style="background:#4ade80"></div>Parks/Green</div>
                <div class="legend-item"><div class="legend-color" style="background:#555"></div>Roads</div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, grid = [], paused = false;
        let year = 2000;
        
        const gridSize = 80;
        const TYPES = {
            EMPTY: 0,
            RES_LOW: 1,
            RES_HIGH: 2,
            COMMERCIAL: 3,
            INDUSTRIAL: 4,
            PARK: 5,
            ROAD: 6,
            HIGHWAY: 7,
            DOWNTOWN: 8
        };
        
        const colors = {
            [TYPES.EMPTY]: '#1e293b',
            [TYPES.RES_LOW]: '#fef3c7',
            [TYPES.RES_HIGH]: '#fcd34d',
            [TYPES.COMMERCIAL]: '#60a5fa',
            [TYPES.INDUSTRIAL]: '#a855f7',
            [TYPES.PARK]: '#4ade80',
            [TYPES.ROAD]: '#555',
            [TYPES.HIGHWAY]: '#777',
            [TYPES.DOWNTOWN]: '#ef4444'
        };
        
        let params = {
            growthRate: 0.3,
            roadPriority: 0.7,
            commercialRatio: 0.2,
            industrialRatio: 0.1,
            greenTarget: 0.15
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }
        
        function init() {
            resize();
            grid = [];
            year = 2000;
            
            for (let y = 0; y < gridSize; y++) {
                const row = [];
                for (let x = 0; x < gridSize; x++) {
                    row.push(TYPES.EMPTY);
                }
                grid.push(row);
            }
            
            // Downtown core
            const cx = Math.floor(gridSize / 2);
            const cy = Math.floor(gridSize / 2);
            
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) <= 3) {
                        grid[cy + dy][cx + dx] = TYPES.DOWNTOWN;
                    }
                }
            }
            
            // Initial roads from downtown
            for (let i = cx - 10; i <= cx + 10; i++) {
                if (i >= 0 && i < gridSize) grid[cy][i] = TYPES.ROAD;
            }
            for (let i = cy - 10; i <= cy + 10; i++) {
                if (i >= 0 && i < gridSize) grid[i][cx] = TYPES.ROAD;
            }
            
            // Initial development around downtown
            for (let r = 3; r <= 5; r++) {
                for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                    const x = Math.floor(cx + Math.cos(angle) * r);
                    const y = Math.floor(cy + Math.sin(angle) * r);
                    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize && grid[y][x] === TYPES.EMPTY) {
                        grid[y][x] = Math.random() < 0.3 ? TYPES.COMMERCIAL : TYPES.RES_LOW;
                    }
                }
            }
            
            updateStats();
        }
        
        function getNeighbors(x, y) {
            const neighbors = [];
            const dirs = [[-1,0], [1,0], [0,-1], [0,1]];
            for (const [dx, dy] of dirs) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                    neighbors.push({ x: nx, y: ny, type: grid[ny][nx] });
                }
            }
            return neighbors;
        }
        
        function countNearby(x, y, types, radius = 3) {
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        if (types.includes(grid[ny][nx])) count++;
                    }
                }
            }
            return count;
        }
        
        function nearRoad(x, y, radius = 2) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        if (grid[ny][nx] === TYPES.ROAD || grid[ny][nx] === TYPES.HIGHWAY) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function step() {
            year++;
            
            const cx = Math.floor(gridSize / 2);
            const cy = Math.floor(gridSize / 2);
            
            // Find development candidates
            const candidates = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] !== TYPES.EMPTY) continue;
                    
                    const neighbors = getNeighbors(x, y);
                    const developedNeighbors = neighbors.filter(n => 
                        n.type !== TYPES.EMPTY && n.type !== TYPES.ROAD && n.type !== TYPES.HIGHWAY
                    );
                    
                    if (developedNeighbors.length > 0 || nearRoad(x, y, 1)) {
                        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        const roadBonus = nearRoad(x, y) ? params.roadPriority * 2 : 0;
                        const score = 1 / (dist + 1) + roadBonus + developedNeighbors.length * 0.2;
                        candidates.push({ x, y, score });
                    }
                }
            }
            
            // Sort by score and develop some
            candidates.sort((a, b) => b.score - a.score);
            const toDevelop = Math.floor(candidates.length * params.growthRate * 0.1);
            
            for (let i = 0; i < Math.min(toDevelop, candidates.length); i++) {
                const { x, y } = candidates[i];
                
                // Decide zone type
                const nearDowntown = countNearby(x, y, [TYPES.DOWNTOWN], 8) > 0;
                const nearIndustrial = countNearby(x, y, [TYPES.INDUSTRIAL], 4) > 0;
                const nearPark = countNearby(x, y, [TYPES.PARK], 3) > 0;
                
                let type;
                const rand = Math.random();
                
                // Check green space needs
                const greenCount = countNearby(x, y, [TYPES.PARK], 10);
                const totalCount = Math.pow(21, 2);
                
                if (greenCount / totalCount < params.greenTarget && rand < 0.05) {
                    type = TYPES.PARK;
                } else if (nearDowntown && rand < params.commercialRatio * 2) {
                    type = TYPES.COMMERCIAL;
                } else if (!nearDowntown && rand < params.industrialRatio && !nearPark) {
                    type = TYPES.INDUSTRIAL;
                } else if (nearDowntown || nearRoad(x, y, 1)) {
                    type = TYPES.RES_HIGH;
                } else {
                    type = TYPES.RES_LOW;
                }
                
                grid[y][x] = type;
                
                // Sometimes extend road network
                if (Math.random() < 0.1 && !nearRoad(x, y, 1)) {
                    // Build road toward downtown
                    const dx = Math.sign(cx - x);
                    const dy = Math.sign(cy - y);
                    if (Math.random() < 0.5 && x + dx >= 0 && x + dx < gridSize) {
                        grid[y][x + dx] = TYPES.ROAD;
                    } else if (y + dy >= 0 && y + dy < gridSize) {
                        grid[y + dy][x] = TYPES.ROAD;
                    }
                }
            }
            
            updateStats();
        }
        
        function buildHighway() {
            // Build highway from edge through downtown
            const cx = Math.floor(gridSize / 2);
            const cy = Math.floor(gridSize / 2);
            
            if (Math.random() < 0.5) {
                // Horizontal highway
                for (let x = 0; x < gridSize; x++) {
                    const offset = Math.floor(Math.sin(x * 0.1) * 3);
                    const y = cy + offset;
                    if (y >= 0 && y < gridSize) {
                        grid[y][x] = TYPES.HIGHWAY;
                    }
                }
            } else {
                // Vertical highway
                for (let y = 0; y < gridSize; y++) {
                    const offset = Math.floor(Math.sin(y * 0.1) * 3);
                    const x = cx + offset;
                    if (x >= 0 && x < gridSize) {
                        grid[y][x] = TYPES.HIGHWAY;
                    }
                }
            }
        }
        
        function addPark() {
            // Find good spot for park (not downtown, not industrial)
            const candidates = [];
            for (let y = 5; y < gridSize - 5; y++) {
                for (let x = 5; x < gridSize - 5; x++) {
                    if (grid[y][x] === TYPES.EMPTY || grid[y][x] === TYPES.RES_LOW) {
                        const nearInd = countNearby(x, y, [TYPES.INDUSTRIAL], 5);
                        const nearRes = countNearby(x, y, [TYPES.RES_LOW, TYPES.RES_HIGH], 5);
                        if (nearInd === 0 && nearRes > 3) {
                            candidates.push({ x, y, score: nearRes });
                        }
                    }
                }
            }
            
            if (candidates.length > 0) {
                candidates.sort((a, b) => b.score - a.score);
                const { x, y } = candidates[0];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (x + dx >= 0 && x + dx < gridSize && y + dy >= 0 && y + dy < gridSize) {
                            grid[y + dy][x + dx] = TYPES.PARK;
                        }
                    }
                }
            }
        }
        
        function updateStats() {
            let developed = 0, residential = 0, roads = 0;
            const total = gridSize * gridSize;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const t = grid[y][x];
                    if (t !== TYPES.EMPTY) developed++;
                    if (t === TYPES.RES_LOW || t === TYPES.RES_HIGH) residential++;
                    if (t === TYPES.ROAD || t === TYPES.HIGHWAY) roads++;
                }
            }
            
            const population = residential * 150 + developed * 10;
            const area = developed * 0.01; // km²
            const density = area > 0 ? population / area : 0;
            
            document.getElementById('year').textContent = year;
            document.getElementById('population').textContent = population.toLocaleString();
            document.getElementById('developed').textContent = (developed / total * 100).toFixed(1);
            document.getElementById('roads').textContent = (roads * 0.1).toFixed(1);
            document.getElementById('density').textContent = Math.round(density);
        }
        
        function draw() {
            ctx.fillStyle = '#0f1729';
            ctx.fillRect(0, 0, W, H);
            
            const cellW = W / gridSize;
            const cellH = H / gridSize;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const type = grid[y][x];
                    if (type !== TYPES.EMPTY) {
                        ctx.fillStyle = colors[type];
                        ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
                    }
                }
            }
            
            // Grid lines (subtle)
            ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i * cellW, 0);
                ctx.lineTo(i * cellW, H);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellH);
                ctx.lineTo(W, i * cellH);
                ctx.stroke();
            }
            
            // Info
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Urban Sprawl - Year ${year}`, 20, 30);
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    step();
                }
            }, 100);
        }
        
        // Event listeners
        document.getElementById('growth').addEventListener('input', e => {
            params.growthRate = +e.target.value;
            document.getElementById('growthVal').textContent = params.growthRate.toFixed(2);
        });
        document.getElementById('road').addEventListener('input', e => {
            params.roadPriority = +e.target.value;
            document.getElementById('roadVal').textContent = params.roadPriority.toFixed(1);
        });
        document.getElementById('comm').addEventListener('input', e => {
            params.commercialRatio = +e.target.value;
            document.getElementById('commVal').textContent = params.commercialRatio.toFixed(2);
        });
        document.getElementById('ind').addEventListener('input', e => {
            params.industrialRatio = +e.target.value;
            document.getElementById('indVal').textContent = params.industrialRatio.toFixed(2);
        });
        document.getElementById('green').addEventListener('input', e => {
            params.greenTarget = +e.target.value;
            document.getElementById('greenVal').textContent = params.greenTarget.toFixed(2);
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('highway').addEventListener('click', buildHighway);
        document.getElementById('park').addEventListener('click', addPark);
        
        window.addEventListener('resize', resize);
        init();
        draw();
        startSim();
    </script>
</body>
</html>
