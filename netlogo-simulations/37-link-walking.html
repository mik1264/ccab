<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Walking - Network Random Walks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 320px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #7209b7 0%, #a855f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #888;
            font-size: 0.95em;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #bbb;
        }
        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #e0e0e0;
        }
        .control-group .value {
            text-align: right;
            font-size: 0.9em;
            color: #a855f7;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #7209b7 0%, #560bad 100%);
            color: white;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(114,9,183,0.3);
        }
        .stats {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .stats h3 {
            margin-bottom: 12px;
            color: #a855f7;
            font-size: 1em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #c4b5fd;
            font-weight: 600;
        }
        .info-box {
            background: rgba(114,9,183,0.1);
            border-left: 3px solid #7209b7;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85em;
            border-radius: 0 8px 8px 0;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: color 0.3s;
        }
        .back-link:hover {
            color: #a855f7;
        }
        .centrality-display {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        .node-box {
            text-align: center;
            padding: 5px;
            border-radius: 5px;
            font-size: 0.7em;
            background: rgba(114,9,183,0.2);
        }
        .node-box .rank {
            font-size: 1.2em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <a href="index.html" class="back-link">← Back to Simulations</a>

            <div class="info-box">
                <strong>Link Walking</strong><br>
                Random walkers traverse network edges. Visit frequency reveals node centrality - similar to PageRank. Higher centrality = more important node.
            </div>

            <div class="control-group">
                <label>Network Type:</label>
                <select id="networkType">
                    <option value="random">Random (Erdős-Rényi)</option>
                    <option value="scale-free">Scale-Free (Barabási-Albert)</option>
                    <option value="small-world">Small World (Watts-Strogatz)</option>
                    <option value="star">Star Network</option>
                    <option value="ring">Ring Network</option>
                </select>
            </div>

            <div class="control-group">
                <label>Number of Nodes: <span class="value" id="nodesVal">30</span></label>
                <input type="range" id="nodes" min="10" max="60" value="30">
            </div>

            <div class="control-group">
                <label>Number of Walkers: <span class="value" id="walkersVal">5</span></label>
                <input type="range" id="walkers" min="1" max="20" value="5">
            </div>

            <div class="control-group">
                <label>Walk Speed: <span class="value" id="speedVal">3</span></label>
                <input type="range" id="speed" min="1" max="10" value="3">
            </div>

            <div class="control-group">
                <label>Connection Probability: <span class="value" id="probVal">0.15</span></label>
                <input type="range" id="prob" min="0.05" max="0.5" step="0.05" value="0.15">
            </div>

            <button class="btn-primary" id="startBtn">Start Walking</button>
            <button class="btn-secondary" id="resetBtn">New Network</button>

            <div class="stats">
                <h3>Walk Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Total Steps:</span>
                    <span class="stat-value" id="steps">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Nodes Visited:</span>
                    <span class="stat-value" id="visited">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Coverage:</span>
                    <span class="stat-value" id="coverage">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Most Visited:</span>
                    <span class="stat-value" id="mostVisited">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg. Visits:</span>
                    <span class="stat-value" id="avgVisits">0</span>
                </div>
            </div>

            <div class="stats">
                <h3>Top 10 Central Nodes</h3>
                <div class="centrality-display" id="topNodes">
                    <!-- Filled dynamically -->
                </div>
            </div>
        </aside>

        <main class="main">
            <header>
                <h1>Link Walking on Networks</h1>
                <p class="subtitle">Random walks reveal network centrality through visit frequency</p>
            </header>
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
        </main>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = Math.min(container.clientWidth - 40, 700);
            canvas.height = canvas.width;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Network state
        let nodes = [];
        let edges = [];
        let walkers = [];
        let running = false;
        let animationId = null;
        let totalSteps = 0;

        // Controls
        const controls = {
            networkType: document.getElementById('networkType'),
            nodes: document.getElementById('nodes'),
            walkers: document.getElementById('walkers'),
            speed: document.getElementById('speed'),
            prob: document.getElementById('prob')
        };

        // Update value displays
        ['nodes', 'walkers', 'speed', 'prob'].forEach(key => {
            const input = controls[key];
            const valueSpan = document.getElementById(key + 'Val');
            input.addEventListener('input', () => {
                valueSpan.textContent = input.value;
            });
        });

        // Node class
        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.neighbors = [];
                this.visitCount = 0;
            }
        }

        // Walker class
        class Walker {
            constructor(startNode) {
                this.currentNode = startNode;
                this.x = startNode.x;
                this.y = startNode.y;
                this.targetNode = null;
                this.progress = 1;
                this.color = `hsl(${Math.random() * 60 + 260}, 80%, 60%)`;
                this.trail = [];
            }

            step() {
                if (this.progress >= 1 && this.currentNode.neighbors.length > 0) {
                    // Choose random neighbor
                    const randomIndex = Math.floor(Math.random() * this.currentNode.neighbors.length);
                    this.targetNode = this.currentNode.neighbors[randomIndex];
                    this.progress = 0;
                    return true;
                }
                return false;
            }

            update(speed) {
                if (this.targetNode && this.progress < 1) {
                    this.progress += speed * 0.02;
                    if (this.progress >= 1) {
                        this.progress = 1;
                        this.currentNode = this.targetNode;
                        this.currentNode.visitCount++;
                        this.targetNode = null;

                        // Add to trail
                        this.trail.push({ x: this.x, y: this.y });
                        if (this.trail.length > 50) this.trail.shift();
                    }
                    // Interpolate position
                    this.x = this.currentNode.x + (this.targetNode ? (this.targetNode.x - this.currentNode.x) * this.progress : 0);
                    this.y = this.currentNode.y + (this.targetNode ? (this.targetNode.y - this.currentNode.y) * this.progress : 0);
                }
            }
        }

        // Generate network
        function generateNetwork() {
            nodes = [];
            edges = [];
            const numNodes = parseInt(controls.nodes.value);
            const type = controls.networkType.value;

            // Create nodes with force-directed layout
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.min(cx, cy) * 0.8;

            for (let i = 0; i < numNodes; i++) {
                const angle = (i / numNodes) * Math.PI * 2;
                const r = radius * (0.5 + Math.random() * 0.5);
                nodes.push(new Node(
                    i,
                    cx + Math.cos(angle) * r,
                    cy + Math.sin(angle) * r
                ));
            }

            // Create edges based on network type
            switch (type) {
                case 'random':
                    generateRandomNetwork();
                    break;
                case 'scale-free':
                    generateScaleFreeNetwork();
                    break;
                case 'small-world':
                    generateSmallWorldNetwork();
                    break;
                case 'star':
                    generateStarNetwork();
                    break;
                case 'ring':
                    generateRingNetwork();
                    break;
            }

            // Apply force-directed layout
            for (let iter = 0; iter < 100; iter++) {
                forceDirectedStep();
            }

            // Initialize walkers
            initWalkers();
            totalSteps = 0;
        }

        function addEdge(i, j) {
            if (i !== j && !nodes[i].neighbors.includes(nodes[j])) {
                nodes[i].neighbors.push(nodes[j]);
                nodes[j].neighbors.push(nodes[i]);
                edges.push([i, j]);
            }
        }

        function generateRandomNetwork() {
            const prob = parseFloat(controls.prob.value);
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (Math.random() < prob) {
                        addEdge(i, j);
                    }
                }
            }
            // Ensure connected
            ensureConnected();
        }

        function generateScaleFreeNetwork() {
            // Start with small complete graph
            for (let i = 0; i < 3; i++) {
                for (let j = i + 1; j < 3; j++) {
                    addEdge(i, j);
                }
            }

            // Add nodes with preferential attachment
            for (let i = 3; i < nodes.length; i++) {
                const m = 2; // edges per new node
                const targets = new Set();
                const totalDegree = nodes.slice(0, i).reduce((sum, n) => sum + n.neighbors.length, 0);

                while (targets.size < m && targets.size < i) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        r -= nodes[j].neighbors.length || 1;
                        if (r <= 0) {
                            targets.add(j);
                            break;
                        }
                    }
                }

                targets.forEach(j => addEdge(i, j));
            }
        }

        function generateSmallWorldNetwork() {
            const k = 4; // neighbors per side
            // Create ring lattice
            for (let i = 0; i < nodes.length; i++) {
                for (let j = 1; j <= k; j++) {
                    addEdge(i, (i + j) % nodes.length);
                }
            }

            // Rewire with probability
            const prob = 0.1;
            for (const edge of [...edges]) {
                if (Math.random() < prob) {
                    const [i, j] = edge;
                    // Remove edge
                    nodes[i].neighbors = nodes[i].neighbors.filter(n => n !== nodes[j]);
                    nodes[j].neighbors = nodes[j].neighbors.filter(n => n !== nodes[i]);

                    // Add new random edge
                    let newTarget;
                    do {
                        newTarget = Math.floor(Math.random() * nodes.length);
                    } while (newTarget === i || nodes[i].neighbors.includes(nodes[newTarget]));
                    addEdge(i, newTarget);
                }
            }
        }

        function generateStarNetwork() {
            // Central node connects to all others
            for (let i = 1; i < nodes.length; i++) {
                addEdge(0, i);
            }
            // Position central node at center
            nodes[0].x = canvas.width / 2;
            nodes[0].y = canvas.height / 2;
        }

        function generateRingNetwork() {
            for (let i = 0; i < nodes.length; i++) {
                addEdge(i, (i + 1) % nodes.length);
            }
        }

        function ensureConnected() {
            // Find disconnected components and connect them
            const visited = new Set();
            const components = [];

            for (let i = 0; i < nodes.length; i++) {
                if (visited.has(i)) continue;
                const component = [];
                const queue = [i];
                visited.add(i);

                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    for (const neighbor of nodes[current].neighbors) {
                        if (!visited.has(neighbor.id)) {
                            visited.add(neighbor.id);
                            queue.push(neighbor.id);
                        }
                    }
                }
                components.push(component);
            }

            // Connect components
            for (let i = 1; i < components.length; i++) {
                const a = components[i - 1][Math.floor(Math.random() * components[i - 1].length)];
                const b = components[i][Math.floor(Math.random() * components[i].length)];
                addEdge(a, b);
            }
        }

        function forceDirectedStep() {
            const k = 50; // Optimal distance
            const forces = nodes.map(() => ({ fx: 0, fy: 0 }));

            // Repulsion between all pairs
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = (k * k) / dist;
                    forces[i].fx -= (dx / dist) * force * 0.1;
                    forces[i].fy -= (dy / dist) * force * 0.1;
                    forces[j].fx += (dx / dist) * force * 0.1;
                    forces[j].fy += (dy / dist) * force * 0.1;
                }
            }

            // Attraction along edges
            for (const [i, j] of edges) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = (dist - k) / k;
                forces[i].fx += (dx / dist) * force;
                forces[i].fy += (dy / dist) * force;
                forces[j].fx -= (dx / dist) * force;
                forces[j].fy -= (dy / dist) * force;
            }

            // Apply forces
            const margin = 50;
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].x += forces[i].fx;
                nodes[i].y += forces[i].fy;
                nodes[i].x = Math.max(margin, Math.min(canvas.width - margin, nodes[i].x));
                nodes[i].y = Math.max(margin, Math.min(canvas.height - margin, nodes[i].y));
            }
        }

        function initWalkers() {
            walkers = [];
            const numWalkers = parseInt(controls.walkers.value);
            for (let i = 0; i < numWalkers; i++) {
                const startNode = nodes[Math.floor(Math.random() * nodes.length)];
                startNode.visitCount++;
                walkers.push(new Walker(startNode));
            }
        }

        // Update simulation
        function update() {
            const speed = parseInt(controls.speed.value);

            for (const walker of walkers) {
                if (walker.step()) {
                    totalSteps++;
                }
                walker.update(speed);
            }

            updateStats();
        }

        // Update statistics
        function updateStats() {
            document.getElementById('steps').textContent = totalSteps;

            const visitedNodes = nodes.filter(n => n.visitCount > 0).length;
            document.getElementById('visited').textContent = visitedNodes;
            document.getElementById('coverage').textContent =
                Math.round(visitedNodes / nodes.length * 100) + '%';

            const maxVisits = Math.max(...nodes.map(n => n.visitCount));
            const mostVisitedNode = nodes.find(n => n.visitCount === maxVisits);
            document.getElementById('mostVisited').textContent =
                mostVisitedNode ? `Node ${mostVisitedNode.id} (${maxVisits})` : '-';

            const avgVisits = nodes.reduce((sum, n) => sum + n.visitCount, 0) / nodes.length;
            document.getElementById('avgVisits').textContent = avgVisits.toFixed(1);

            // Update top nodes display
            const sortedNodes = [...nodes].sort((a, b) => b.visitCount - a.visitCount);
            const topNodesDiv = document.getElementById('topNodes');
            topNodesDiv.innerHTML = sortedNodes.slice(0, 10).map((n, i) => `
                <div class="node-box" style="opacity: ${0.5 + 0.5 * (10 - i) / 10}">
                    <div class="rank">${n.id}</div>
                    <div>${n.visitCount}</div>
                </div>
            `).join('');
        }

        // Draw simulation
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Find max visits for scaling
            const maxVisits = Math.max(1, ...nodes.map(n => n.visitCount));

            // Draw edges
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.3)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw walker trails
            for (const walker of walkers) {
                if (walker.trail.length > 1) {
                    ctx.strokeStyle = walker.color.replace('60%', '40%');
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(walker.trail[0].x, walker.trail[0].y);
                    for (let i = 1; i < walker.trail.length; i++) {
                        ctx.lineTo(walker.trail[i].x, walker.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }

            // Draw nodes
            for (const node of nodes) {
                const intensity = node.visitCount / maxVisits;
                const radius = 8 + intensity * 12;

                // Glow for high-visit nodes
                if (intensity > 0.3) {
                    const gradient = ctx.createRadialGradient(
                        node.x, node.y, radius,
                        node.x, node.y, radius * 2
                    );
                    gradient.addColorStop(0, `rgba(168, 85, 247, ${intensity * 0.5})`);
                    gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Node circle
                const hue = 260 + intensity * 40;
                ctx.fillStyle = `hsl(${hue}, 70%, ${40 + intensity * 30}%)`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Node border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Node label
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id.toString(), node.x, node.y);
            }

            // Draw walkers
            for (const walker of walkers) {
                ctx.fillStyle = walker.color;
                ctx.beginPath();
                ctx.arc(walker.x, walker.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Animation loop
        function animate() {
            if (!running) return;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Walking';
            if (running) animate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Walking';
            if (animationId) cancelAnimationFrame(animationId);
            generateNetwork();
            draw();
        });

        controls.networkType.addEventListener('change', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Walking';
            if (animationId) cancelAnimationFrame(animationId);
            generateNetwork();
            draw();
        });

        // Initialize
        generateNetwork();
        draw();
    </script>
</body>
</html>
