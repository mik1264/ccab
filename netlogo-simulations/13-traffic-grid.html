<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Grid Simulation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #3b82f6; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #3b82f6; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #2563eb; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #3b82f6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; font-size: 0.7rem; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Traffic Grid</h1>
            <p class="description">City traffic simulation with intersections and traffic lights. Cars follow simple rules: stop at red lights, slow when approaching other cars, and turn randomly at intersections.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>Green Light</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Red Light</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #facc15;"></div>
                    <span>Yellow Light</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Grid Size: <span id="gridSizeVal">4</span>×<span id="gridSizeVal2">4</span></label>
                <input type="range" id="gridSize" min="2" max="6" value="4">
            </div>
            <div class="control-group">
                <label>Number of Cars: <span id="carCountVal">50</span></label>
                <input type="range" id="carCount" min="10" max="150" value="50">
            </div>
            <div class="control-group">
                <label>Light Cycle (steps): <span id="lightCycleVal">60</span></label>
                <input type="range" id="lightCycle" min="20" max="120" value="60">
            </div>
            <div class="control-group">
                <label>Car Speed: <span id="carSpeedVal">2</span></label>
                <input type="range" id="carSpeed" min="1" max="5" value="2">
            </div>
            
            <button id="reset">Reset Simulation</button>
            <button id="pause">Pause</button>
            <button id="sync">Sync All Lights</button>
            <button id="wave">Green Wave Mode</button>
            
            <div class="stats">
                <div>Time Step: <span id="timeStep">0</span></div>
                <div>Cars Moving: <span id="moving">0</span></div>
                <div>Cars Stopped: <span id="stopped">0</span></div>
                <div>Avg Speed: <span id="avgSpeed">0</span></div>
                <div>Throughput: <span id="throughput">0</span>/min</div>
            </div>
            
            <p class="description"><strong>Tip:</strong> Try "Green Wave Mode" to see how synchronized signals can improve traffic flow on main arteries.</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, roads = [], intersections = [], cars = [], paused = false, timeStep = 0;
        let completedTrips = 0, lastThroughputTime = 0;
        
        let params = {
            gridSize: 4,
            carCount: 50,
            lightCycle: 60,
            carSpeed: 2
        };
        
        const ROAD_WIDTH = 30;
        const CAR_LENGTH = 15;
        const CAR_WIDTH = 8;
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }
        
        function init() {
            resize();
            timeStep = 0;
            completedTrips = 0;
            lastThroughputTime = 0;
            
            // Create grid of intersections
            intersections = [];
            const spacingX = (W - 100) / (params.gridSize + 1);
            const spacingY = (H - 100) / (params.gridSize + 1);
            
            for (let row = 0; row < params.gridSize; row++) {
                for (let col = 0; col < params.gridSize; col++) {
                    intersections.push({
                        x: 50 + (col + 1) * spacingX,
                        y: 50 + (row + 1) * spacingY,
                        row: row,
                        col: col,
                        // Phase: true = horizontal green, false = vertical green
                        phase: Math.random() < 0.5,
                        timer: Math.floor(Math.random() * params.lightCycle),
                        yellowTimer: 0  // For yellow light transition
                    });
                }
            }
            
            // Create roads connecting intersections
            roads = [];
            for (const inter of intersections) {
                // Horizontal road to the right
                const rightInter = intersections.find(i => i.row === inter.row && i.col === inter.col + 1);
                if (rightInter) {
                    roads.push({
                        x1: inter.x, y1: inter.y,
                        x2: rightInter.x, y2: rightInter.y,
                        horizontal: true
                    });
                }
                // Vertical road downward
                const downInter = intersections.find(i => i.row === inter.row + 1 && i.col === inter.col);
                if (downInter) {
                    roads.push({
                        x1: inter.x, y1: inter.y,
                        x2: downInter.x, y2: downInter.y,
                        horizontal: false
                    });
                }
            }
            
            // Create cars
            cars = [];
            for (let i = 0; i < params.carCount; i++) {
                spawnCar();
            }
            
            updateStats();
        }
        
        function spawnCar() {
            // Spawn on a random road
            if (roads.length === 0) return;
            
            const road = roads[Math.floor(Math.random() * roads.length)];
            const t = 0.2 + Math.random() * 0.6; // Position along road
            
            // Direction: along the road
            let dx, dy;
            if (road.horizontal) {
                dx = Math.random() < 0.5 ? 1 : -1;
                dy = 0;
            } else {
                dx = 0;
                dy = Math.random() < 0.5 ? 1 : -1;
            }
            
            cars.push({
                x: road.x1 + (road.x2 - road.x1) * t,
                y: road.y1 + (road.y2 - road.y1) * t + (road.horizontal ? (dy === 0 ? (dx > 0 ? -5 : 5) : 0) : 0),
                dx: dx,
                dy: dy,
                speed: 0,
                maxSpeed: params.carSpeed,
                stopped: false
            });
        }
        
        function getIntersectionAt(x, y, radius = 30) {
            return intersections.find(i => 
                Math.abs(i.x - x) < radius && Math.abs(i.y - y) < radius
            );
        }
        
        function canPass(car) {
            // Check if car can pass through nearby intersection
            const inter = getIntersectionAt(car.x + car.dx * 20, car.y + car.dy * 20);
            if (!inter) return true;
            
            // Check if light is green for this direction
            const horizontal = car.dx !== 0;
            if (inter.yellowTimer > 0) return false; // Yellow = stop
            return horizontal === inter.phase;
        }
        
        function getCarAhead(car) {
            // Find the nearest car ahead
            let minDist = Infinity;
            let carAhead = null;
            
            for (const other of cars) {
                if (other === car) continue;
                
                // Check if other is ahead
                const dx = other.x - car.x;
                const dy = other.y - car.y;
                
                // Same direction check
                const sameDir = (car.dx !== 0 && other.dx !== 0 && Math.abs(dy) < ROAD_WIDTH) ||
                               (car.dy !== 0 && other.dy !== 0 && Math.abs(dx) < ROAD_WIDTH);
                
                if (!sameDir) continue;
                
                // Ahead check
                const dist = car.dx !== 0 ? dx * car.dx : dy * car.dy;
                
                if (dist > 0 && dist < minDist && dist < 50) {
                    minDist = dist;
                    carAhead = other;
                }
            }
            
            return { car: carAhead, dist: minDist };
        }
        
        function updateCar(car) {
            // Check traffic light
            const canPassLight = canPass(car);
            
            // Check car ahead
            const ahead = getCarAhead(car);
            const safeDistance = CAR_LENGTH * 2;
            
            // Determine target speed
            let targetSpeed = car.maxSpeed;
            
            if (!canPassLight) {
                // Approaching red light
                const inter = getIntersectionAt(car.x + car.dx * 30, car.y + car.dy * 30);
                if (inter) {
                    const distToInter = Math.sqrt(
                        Math.pow(inter.x - car.x, 2) + 
                        Math.pow(inter.y - car.y, 2)
                    );
                    if (distToInter < 40) {
                        targetSpeed = 0;
                    }
                }
            }
            
            if (ahead.car && ahead.dist < safeDistance) {
                targetSpeed = Math.min(targetSpeed, ahead.car.speed * 0.8);
            }
            
            // Accelerate/decelerate
            if (car.speed < targetSpeed) {
                car.speed = Math.min(car.speed + 0.2, targetSpeed);
            } else {
                car.speed = Math.max(car.speed - 0.5, targetSpeed);
            }
            
            car.stopped = car.speed < 0.1;
            
            // Move
            car.x += car.dx * car.speed;
            car.y += car.dy * car.speed;
            
            // Check if at intersection - maybe turn
            const atInter = getIntersectionAt(car.x, car.y, 15);
            if (atInter && Math.random() < 0.1) {
                // Random turn
                if (car.dx !== 0) {
                    // Was horizontal, turn vertical
                    car.dy = Math.random() < 0.5 ? 1 : -1;
                    car.dx = 0;
                } else {
                    // Was vertical, turn horizontal
                    car.dx = Math.random() < 0.5 ? 1 : -1;
                    car.dy = 0;
                }
            }
            
            // Wrap around or respawn if out of bounds
            if (car.x < 10 || car.x > W - 10 || car.y < 10 || car.y > H - 10) {
                completedTrips++;
                // Respawn
                const road = roads[Math.floor(Math.random() * roads.length)];
                const t = 0.2 + Math.random() * 0.6;
                car.x = road.x1 + (road.x2 - road.x1) * t;
                car.y = road.y1 + (road.y2 - road.y1) * t;
                if (road.horizontal) {
                    car.dx = Math.random() < 0.5 ? 1 : -1;
                    car.dy = 0;
                } else {
                    car.dx = 0;
                    car.dy = Math.random() < 0.5 ? 1 : -1;
                }
                car.speed = 0;
            }
        }
        
        function updateLights() {
            for (const inter of intersections) {
                inter.timer++;
                
                if (inter.yellowTimer > 0) {
                    inter.yellowTimer--;
                    if (inter.yellowTimer === 0) {
                        inter.phase = !inter.phase;
                    }
                } else if (inter.timer >= params.lightCycle) {
                    inter.timer = 0;
                    inter.yellowTimer = 5; // Yellow for 5 steps
                }
            }
        }
        
        function step() {
            timeStep++;
            updateLights();
            for (const car of cars) {
                updateCar(car);
            }
            updateStats();
        }
        
        function updateStats() {
            const moving = cars.filter(c => !c.stopped).length;
            const stopped = cars.length - moving;
            const avgSpeed = cars.reduce((sum, c) => sum + c.speed, 0) / cars.length;
            
            // Calculate throughput (trips per minute)
            const elapsed = timeStep - lastThroughputTime;
            let throughput = 0;
            if (elapsed > 0) {
                throughput = (completedTrips / elapsed) * 600; // 600 steps ≈ 1 minute
            }
            
            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('moving').textContent = moving;
            document.getElementById('stopped').textContent = stopped;
            document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(2);
            document.getElementById('throughput').textContent = throughput.toFixed(1);
        }
        
        function syncLights() {
            // Sync all lights to same phase
            for (const inter of intersections) {
                inter.phase = true;
                inter.timer = 0;
                inter.yellowTimer = 0;
            }
        }
        
        function greenWave() {
            // Create a "green wave" - offset lights to favor horizontal traffic
            for (const inter of intersections) {
                inter.phase = true;
                inter.timer = (inter.col * 15) % params.lightCycle;
                inter.yellowTimer = 0;
            }
        }
        
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            
            // Draw roads
            ctx.strokeStyle = '#333';
            ctx.lineWidth = ROAD_WIDTH;
            for (const road of roads) {
                ctx.beginPath();
                ctx.moveTo(road.x1, road.y1);
                ctx.lineTo(road.x2, road.y2);
                ctx.stroke();
            }
            
            // Road center lines
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.setLineDash([10, 10]);
            for (const road of roads) {
                ctx.beginPath();
                ctx.moveTo(road.x1, road.y1);
                ctx.lineTo(road.x2, road.y2);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw intersections
            for (const inter of intersections) {
                // Intersection box
                ctx.fillStyle = '#2a2a4e';
                ctx.fillRect(inter.x - ROAD_WIDTH/2, inter.y - ROAD_WIDTH/2, ROAD_WIDTH, ROAD_WIDTH);
                
                // Traffic lights
                const lightSize = 6;
                const offset = ROAD_WIDTH/2 + 5;
                
                // Horizontal lights
                const hColor = inter.yellowTimer > 0 ? '#facc15' : (inter.phase ? '#22c55e' : '#ef4444');
                ctx.fillStyle = hColor;
                ctx.beginPath();
                ctx.arc(inter.x - offset, inter.y, lightSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(inter.x + offset, inter.y, lightSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Vertical lights
                const vColor = inter.yellowTimer > 0 ? '#facc15' : (!inter.phase ? '#22c55e' : '#ef4444');
                ctx.fillStyle = vColor;
                ctx.beginPath();
                ctx.arc(inter.x, inter.y - offset, lightSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(inter.x, inter.y + offset, lightSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw cars
            for (const car of cars) {
                ctx.save();
                ctx.translate(car.x, car.y);
                
                // Rotate based on direction
                const angle = Math.atan2(car.dy, car.dx);
                ctx.rotate(angle);
                
                // Color based on speed
                const speedRatio = car.speed / car.maxSpeed;
                const hue = speedRatio * 120; // 0=red, 120=green
                ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                
                ctx.fillRect(-CAR_LENGTH/2, -CAR_WIDTH/2, CAR_LENGTH, CAR_WIDTH);
                
                // Headlights
                ctx.fillStyle = '#fff';
                ctx.fillRect(CAR_LENGTH/2 - 2, -CAR_WIDTH/2, 2, 2);
                ctx.fillRect(CAR_LENGTH/2 - 2, CAR_WIDTH/2 - 2, 2, 2);
                
                ctx.restore();
            }
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSimulation() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) step();
            }, 50);
        }
        
        // Event listeners
        document.getElementById('gridSize').addEventListener('input', e => {
            params.gridSize = +e.target.value;
            document.getElementById('gridSizeVal').textContent = params.gridSize;
            document.getElementById('gridSizeVal2').textContent = params.gridSize;
        });
        
        document.getElementById('carCount').addEventListener('input', e => {
            params.carCount = +e.target.value;
            document.getElementById('carCountVal').textContent = params.carCount;
        });
        
        document.getElementById('lightCycle').addEventListener('input', e => {
            params.lightCycle = +e.target.value;
            document.getElementById('lightCycleVal').textContent = params.lightCycle;
        });
        
        document.getElementById('carSpeed').addEventListener('input', e => {
            params.carSpeed = +e.target.value;
            document.getElementById('carSpeedVal').textContent = params.carSpeed;
            for (const car of cars) {
                car.maxSpeed = params.carSpeed;
            }
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            init();
            startSimulation();
        });
        
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('sync').addEventListener('click', syncLights);
        document.getElementById('wave').addEventListener('click', greenWave);
        
        window.addEventListener('resize', resize);
        
        init();
        draw();
        startSimulation();
    </script>
</body>
</html>
