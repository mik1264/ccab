<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voting Simulation - Social Influence - CCAB</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container { display: flex; height: 100vh; }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 10px;
        }
        canvas { border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #74b9ff; }
        h3 { margin: 15px 0 8px 0; color: #a3d8f4; font-size: 14px; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 13px; }
        input[type="range"] { width: 100%; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #74b9ff;
            color: #1a1a2e;
            font-weight: bold;
        }
        button:hover { background: #0984e3; }
        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
        }
        select option { background: #1a1a2e; }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 11px;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        .vote-bar {
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            display: flex;
            margin: 15px 0;
        }
        .vote-blue { background: #74b9ff; height: 100%; transition: width 0.3s; }
        .vote-red { background: #ff7675; height: 100%; transition: width 0.3s; }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600;">
        <span>‚Üê Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="worldCanvas"></canvas>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #74b9ff;"></div> Party A</div>
                <div class="legend-item"><div class="legend-color" style="background: #ff7675;"></div> Party B</div>
                <div class="legend-item"><div class="legend-color" style="background: #b2bec3;"></div> Undecided</div>
            </div>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>üó≥Ô∏è Voting Simulation</h2>
            <p style="font-size: 12px; opacity: 0.8;">Spatial voting and social influence</p>

            <h3>Influence Model</h3>
            <select id="model">
                <option value="majority">Majority Rule</option>
                <option value="weighted">Distance Weighted</option>
                <option value="threshold">Threshold Model</option>
                <option value="contrarian">Contrarian Minority</option>
            </select>

            <div class="vote-bar">
                <div class="vote-blue" id="blueBar" style="width: 50%;"></div>
                <div class="vote-red" id="redBar" style="width: 50%;"></div>
            </div>

            <h3>Grid Size</h3>
            <div class="slider-group">
                <label>Size: <span id="gridSizeVal">50</span></label>
                <input type="range" id="gridSize" min="20" max="80" step="10" value="50">
            </div>

            <h3>Influence Radius</h3>
            <div class="slider-group">
                <label>Radius: <span id="radiusVal">2</span></label>
                <input type="range" id="radius" min="1" max="5" step="1" value="2">
            </div>

            <h3>Stubbornness</h3>
            <div class="slider-group">
                <label>Probability: <span id="stubbornnessVal">0.10</span></label>
                <input type="range" id="stubbornness" min="0" max="0.5" step="0.05" value="0.10">
            </div>

            <h3>Speed</h3>
            <div class="slider-group">
                <label>Delay: <span id="speedVal">50</span>ms</label>
                <input type="range" id="speed" min="10" max="200" step="10" value="50">
            </div>

            <button onclick="reset()">Reset</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>

            <div class="stats">
                <div class="stat-row"><span>Time:</span><span id="time">0</span></div>
                <div class="stat-row"><span>Party A:</span><span id="partyA">0</span> (<span id="pctA">50</span>%)</div>
                <div class="stat-row"><span>Party B:</span><span id="partyB">0</span> (<span id="pctB">50</span>%)</div>
                <div class="stat-row"><span>Undecided:</span><span id="undecided">0</span></div>
                <div class="stat-row"><span>Changes this step:</span><span id="changes">0</span></div>
            </div>

            <div class="description">
                <strong>Voting Models:</strong><br><br>
                <strong>Majority Rule:</strong> Adopt the most common opinion among neighbors.<br><br>
                <strong>Distance Weighted:</strong> Closer neighbors have more influence.<br><br>
                <strong>Threshold:</strong> Change only if >60% of neighbors agree.<br><br>
                <strong>Contrarian:</strong> 10% of voters oppose the local majority.
            </div>
        </div>
    </div>

    <script>
        const worldCanvas = document.getElementById('worldCanvas');
        const worldCtx = worldCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        let gridSize = 50;
        let cellSize = 10;
        let grid = [];
        let radius = 2;
        let stubbornness = 0.1;
        let speed = 50;
        let model = 'majority';
        let time = 0;
        let paused = false;
        let animationId = null;
        let history = { a: [], b: [], u: [] };

        function initGrid() {
            worldCanvas.width = gridSize * cellSize;
            worldCanvas.height = gridSize * cellSize;
            graphCanvas.width = worldCanvas.width;
            graphCanvas.height = 120;

            grid = [];
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    const r = Math.random();
                    if (r < 0.4) grid[y][x] = 1;      // Party A (blue)
                    else if (r < 0.8) grid[y][x] = -1; // Party B (red)
                    else grid[y][x] = 0;              // Undecided
                }
            }
        }

        function reset() {
            if (animationId) clearTimeout(animationId);
            gridSize = parseInt(document.getElementById('gridSize').value);
            cellSize = Math.floor(500 / gridSize);
            radius = parseInt(document.getElementById('radius').value);
            stubbornness = parseFloat(document.getElementById('stubbornness').value);
            speed = parseInt(document.getElementById('speed').value);
            model = document.getElementById('model').value;

            time = 0;
            history = { a: [], b: [], u: [] };
            paused = false;
            document.getElementById('pauseBtn').textContent = 'Pause';

            initGrid();
            updateStats();
            draw();
            animate();
        }

        function getNeighborInfluence(x, y) {
            let sumA = 0, sumB = 0, total = 0;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = (x + dx + gridSize) % gridSize;
                    const ny = (y + dy + gridSize) % gridSize;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= radius) {
                        let weight = 1;
                        if (model === 'weighted') {
                            weight = 1 / distance;
                        }

                        if (grid[ny][nx] === 1) sumA += weight;
                        else if (grid[ny][nx] === -1) sumB += weight;
                        total += weight;
                    }
                }
            }

            return { sumA, sumB, total };
        }

        function step() {
            const newGrid = grid.map(row => [...row]);
            let changes = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    // Stubborn voters don't change
                    if (Math.random() < stubbornness) continue;

                    const { sumA, sumB, total } = getNeighborInfluence(x, y);
                    let newVote = grid[y][x];

                    switch (model) {
                        case 'majority':
                            if (sumA > sumB) newVote = 1;
                            else if (sumB > sumA) newVote = -1;
                            break;

                        case 'weighted':
                            if (sumA > sumB * 1.1) newVote = 1;
                            else if (sumB > sumA * 1.1) newVote = -1;
                            break;

                        case 'threshold':
                            const threshold = 0.6;
                            if (sumA / total > threshold) newVote = 1;
                            else if (sumB / total > threshold) newVote = -1;
                            break;

                        case 'contrarian':
                            if (Math.random() < 0.1) {
                                // Contrarian: oppose majority
                                if (sumA > sumB) newVote = -1;
                                else if (sumB > sumA) newVote = 1;
                            } else {
                                // Normal: follow majority
                                if (sumA > sumB) newVote = 1;
                                else if (sumB > sumA) newVote = -1;
                            }
                            break;
                    }

                    if (newVote !== grid[y][x]) {
                        changes++;
                    }
                    newGrid[y][x] = newVote;
                }
            }

            grid = newGrid;
            time++;

            // Update history
            const counts = countVotes();
            history.a.push(counts.a);
            history.b.push(counts.b);
            history.u.push(counts.u);

            if (history.a.length > 200) {
                history.a.shift();
                history.b.shift();
                history.u.shift();
            }

            document.getElementById('changes').textContent = changes;
        }

        function countVotes() {
            let a = 0, b = 0, u = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 1) a++;
                    else if (grid[y][x] === -1) b++;
                    else u++;
                }
            }
            return { a, b, u };
        }

        function updateStats() {
            const { a, b, u } = countVotes();
            const total = a + b;
            const pctA = total > 0 ? ((a / total) * 100).toFixed(1) : 50;
            const pctB = total > 0 ? ((b / total) * 100).toFixed(1) : 50;

            document.getElementById('time').textContent = time;
            document.getElementById('partyA').textContent = a;
            document.getElementById('partyB').textContent = b;
            document.getElementById('undecided').textContent = u;
            document.getElementById('pctA').textContent = pctA;
            document.getElementById('pctB').textContent = pctB;

            document.getElementById('blueBar').style.width = pctA + '%';
            document.getElementById('redBar').style.width = pctB + '%';
        }

        function draw() {
            // Draw grid
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    switch (grid[y][x]) {
                        case 1: worldCtx.fillStyle = '#74b9ff'; break;  // Party A
                        case -1: worldCtx.fillStyle = '#ff7675'; break; // Party B
                        case 0: worldCtx.fillStyle = '#b2bec3'; break;  // Undecided
                    }
                    worldCtx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                }
            }

            // Draw graph
            graphCtx.fillStyle = '#1a1a2e';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (history.a.length > 1) {
                const maxVal = gridSize * gridSize;

                // Party A line
                drawLine(history.a, '#74b9ff', maxVal);

                // Party B line
                drawLine(history.b, '#ff7675', maxVal);
            }

            graphCtx.fillStyle = 'white';
            graphCtx.font = '11px Arial';
            graphCtx.fillText('Vote distribution over time', 5, 12);
        }

        function drawLine(data, color, maxVal) {
            graphCtx.strokeStyle = color;
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();

            for (let i = 0; i < data.length; i++) {
                const x = (i / (data.length - 1)) * graphCanvas.width;
                const y = graphCanvas.height - (data[i] / maxVal) * (graphCanvas.height - 20);
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();
        }

        function animate() {
            if (!paused) {
                step();
                updateStats();
            }
            draw();
            animationId = setTimeout(animate, speed);
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        }

        // Event listeners
        document.getElementById('gridSize').oninput = function() {
            document.getElementById('gridSizeVal').textContent = this.value;
        };
        document.getElementById('radius').oninput = function() {
            document.getElementById('radiusVal').textContent = this.value;
        };
        document.getElementById('stubbornness').oninput = function() {
            document.getElementById('stubbornnessVal').textContent = parseFloat(this.value).toFixed(2);
        };
        document.getElementById('speed').oninput = function() {
            speed = parseInt(this.value);
            document.getElementById('speedVal').textContent = speed;
        };
        document.getElementById('model').onchange = function() {
            model = this.value;
        };

        reset();
    </script>
</body>
</html>
