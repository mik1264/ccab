<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Assembly - Network Formation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        #simCanvas { width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #06b6d4; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #0891b2; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #0e7490; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #06b6d4; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Team Assembly</h1>
            <p class="description">Agents form collaboration networks based on skill complementarity and past success. Watch teams emerge and network structure evolve.</p>
            
            <div class="control-group">
                <label>Agents: <span id="agentsVal">40</span></label>
                <input type="range" id="agents" min="15" max="80" value="40">
            </div>
            <div class="control-group">
                <label>Skill Types: <span id="skillsVal">4</span></label>
                <input type="range" id="skills" min="2" max="6" value="4">
            </div>
            <div class="control-group">
                <label>Team Size: <span id="teamSizeVal">3</span></label>
                <input type="range" id="teamSize" min="2" max="6" value="3">
            </div>
            <div class="control-group">
                <label>Connection Decay: <span id="decayVal">0.02</span></label>
                <input type="range" id="decay" min="0" max="0.1" step="0.01" value="0.02">
            </div>
            <div class="control-group">
                <label>Success Bonus: <span id="bonusVal">0.3</span></label>
                <input type="range" id="bonus" min="0" max="1" step="0.05" value="0.3">
            </div>
            
            <button id="reset">Reset Network</button>
            <button id="pause">Pause</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="formTeam">Form New Team</button>
            
            <div class="stats">
                <div>Teams Formed: <span id="teams">0</span></div>
                <div>Total Edges: <span id="edges">0</span></div>
                <div>Avg. Degree: <span id="degree">0</span></div>
                <div>Clustering Coeff: <span id="clustering">0</span></div>
                <div>Most Connected: <span id="hub">-</span></div>
            </div>
            
            <p class="description"><strong>Skill Colors:</strong> Each agent has a primary skill (color). Teams need diverse skills to succeed.</p>
            
            <p class="description"><strong>Edge Strength:</strong> Thicker lines = stronger collaboration history. Fades over time without renewal.</p>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Team Assembly - Network Formation</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, agents = [], edges = {}, paused = false;
        let teamsFormed = 0;
        
        const skillColors = ['#ef4444', '#22c55e', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899'];
        
        let params = {
            agentCount: 40,
            skillTypes: 4,
            teamSize: 3,
            decay: 0.02,
            successBonus: 0.3
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }
        
        function init() {
            resize();
            agents = [];
            edges = {};
            teamsFormed = 0;
            
            const centerX = W / 2;
            const centerY = H / 2;
            const radius = Math.min(W, H) * 0.35;
            
            for (let i = 0; i < params.agentCount; i++) {
                const angle = (i / params.agentCount) * Math.PI * 2;
                const r = radius * (0.7 + Math.random() * 0.3);
                
                agents.push({
                    id: i,
                    x: centerX + Math.cos(angle) * r,
                    y: centerY + Math.sin(angle) * r,
                    vx: 0,
                    vy: 0,
                    skill: Math.floor(Math.random() * params.skillTypes),
                    successRate: 0.5 + Math.random() * 0.3,
                    name: `A${i + 1}`
                });
            }
            
            updateStats();
        }
        
        function getEdgeKey(i, j) {
            return i < j ? `${i}-${j}` : `${j}-${i}`;
        }
        
        function addEdge(i, j, strength) {
            const key = getEdgeKey(i, j);
            if (!edges[key]) {
                edges[key] = { i, j, strength: 0 };
            }
            edges[key].strength = Math.min(1, edges[key].strength + strength);
        }
        
        function formTeam() {
            // Select agents to form a team - prefer skill diversity
            const available = [...agents];
            const team = [];
            const usedSkills = new Set();
            
            // First pass: try to get diverse skills
            for (let t = 0; t < params.teamSize && available.length > 0; t++) {
                // Find agents with unused skills
                let candidates = available.filter(a => !usedSkills.has(a.skill));
                if (candidates.length === 0) {
                    candidates = available;
                }
                
                // Weight by success rate and existing connections
                const weights = candidates.map(a => {
                    let weight = a.successRate;
                    // Bonus for connecting to team members
                    for (const member of team) {
                        const key = getEdgeKey(a.id, member.id);
                        if (edges[key]) {
                            weight += edges[key].strength * 0.5;
                        }
                    }
                    return weight;
                });
                
                const totalWeight = weights.reduce((a, b) => a + b, 0);
                let r = Math.random() * totalWeight;
                let selected = candidates[0];
                for (let i = 0; i < candidates.length; i++) {
                    r -= weights[i];
                    if (r <= 0) {
                        selected = candidates[i];
                        break;
                    }
                }
                
                team.push(selected);
                usedSkills.add(selected.skill);
                available.splice(available.indexOf(selected), 1);
            }
            
            // Check team success - based on skill diversity
            const uniqueSkills = new Set(team.map(a => a.skill)).size;
            const diversityBonus = uniqueSkills / params.skillTypes;
            const avgSuccess = team.reduce((s, a) => s + a.successRate, 0) / team.length;
            const teamSuccess = Math.random() < (avgSuccess * 0.5 + diversityBonus * 0.5);
            
            // Create/strengthen edges between team members
            const strength = teamSuccess ? params.successBonus : params.successBonus * 0.3;
            for (let i = 0; i < team.length; i++) {
                for (let j = i + 1; j < team.length; j++) {
                    addEdge(team[i].id, team[j].id, strength);
                }
                // Update success rate
                if (teamSuccess) {
                    team[i].successRate = Math.min(0.95, team[i].successRate + 0.02);
                }
            }
            
            teamsFormed++;
            return { team, success: teamSuccess };
        }
        
        function step() {
            // Decay edges
            for (const key in edges) {
                edges[key].strength -= params.decay;
                if (edges[key].strength <= 0) {
                    delete edges[key];
                }
            }
            
            // Occasionally form teams
            if (Math.random() < 0.1) {
                formTeam();
            }
            
            // Force-directed layout
            const k = 80; // Ideal spring length
            const repulsion = 5000;
            const attraction = 0.1;
            
            // Reset forces
            for (const agent of agents) {
                agent.fx = 0;
                agent.fy = 0;
            }
            
            // Repulsion between all nodes
            for (let i = 0; i < agents.length; i++) {
                for (let j = i + 1; j < agents.length; j++) {
                    const dx = agents[j].x - agents[i].x;
                    const dy = agents[j].y - agents[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                    const force = repulsion / (dist * dist);
                    
                    agents[i].fx -= (dx / dist) * force;
                    agents[i].fy -= (dy / dist) * force;
                    agents[j].fx += (dx / dist) * force;
                    agents[j].fy += (dy / dist) * force;
                }
            }
            
            // Attraction along edges
            for (const key in edges) {
                const edge = edges[key];
                const a1 = agents[edge.i];
                const a2 = agents[edge.j];
                const dx = a2.x - a1.x;
                const dy = a2.y - a1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const force = (dist - k) * attraction * edge.strength;
                
                a1.fx += (dx / dist) * force;
                a1.fy += (dy / dist) * force;
                a2.fx -= (dx / dist) * force;
                a2.fy -= (dy / dist) * force;
            }
            
            // Center gravity
            const centerX = W / 2;
            const centerY = H / 2;
            for (const agent of agents) {
                agent.fx += (centerX - agent.x) * 0.01;
                agent.fy += (centerY - agent.y) * 0.01;
            }
            
            // Apply forces
            for (const agent of agents) {
                agent.vx = (agent.vx + agent.fx) * 0.5;
                agent.vy = (agent.vy + agent.fy) * 0.5;
                agent.x += agent.vx;
                agent.y += agent.vy;
                
                // Boundaries
                const margin = 50;
                agent.x = Math.max(margin, Math.min(W - margin, agent.x));
                agent.y = Math.max(margin, Math.min(H - margin, agent.y));
            }
            
            updateStats();
        }
        
        function calculateClustering() {
            // Local clustering coefficient
            let totalClustering = 0;
            let nodesWithNeighbors = 0;
            
            for (const agent of agents) {
                const neighbors = [];
                for (const key in edges) {
                    const edge = edges[key];
                    if (edge.i === agent.id) neighbors.push(edge.j);
                    else if (edge.j === agent.id) neighbors.push(edge.i);
                }
                
                if (neighbors.length < 2) continue;
                
                // Count edges between neighbors
                let triangles = 0;
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i + 1; j < neighbors.length; j++) {
                        const key = getEdgeKey(neighbors[i], neighbors[j]);
                        if (edges[key]) triangles++;
                    }
                }
                
                const possibleTriangles = (neighbors.length * (neighbors.length - 1)) / 2;
                totalClustering += triangles / possibleTriangles;
                nodesWithNeighbors++;
            }
            
            return nodesWithNeighbors > 0 ? totalClustering / nodesWithNeighbors : 0;
        }
        
        function updateStats() {
            const edgeCount = Object.keys(edges).length;
            
            // Calculate degrees
            const degrees = {};
            for (const agent of agents) {
                degrees[agent.id] = 0;
            }
            for (const key in edges) {
                const edge = edges[key];
                degrees[edge.i]++;
                degrees[edge.j]++;
            }
            
            const avgDegree = Object.values(degrees).reduce((a, b) => a + b, 0) / agents.length;
            const clustering = calculateClustering();
            
            // Find hub (most connected)
            let maxDegree = 0;
            let hub = null;
            for (const agent of agents) {
                if (degrees[agent.id] > maxDegree) {
                    maxDegree = degrees[agent.id];
                    hub = agent;
                }
            }
            
            document.getElementById('teams').textContent = teamsFormed;
            document.getElementById('edges').textContent = edgeCount;
            document.getElementById('degree').textContent = avgDegree.toFixed(2);
            document.getElementById('clustering').textContent = clustering.toFixed(3);
            document.getElementById('hub').textContent = hub ? `${hub.name} (${maxDegree})` : '-';
        }
        
        function draw() {
            // Background
            ctx.fillStyle = '#0f1729';
            ctx.fillRect(0, 0, W, H);
            
            // Draw edges
            for (const key in edges) {
                const edge = edges[key];
                const a1 = agents[edge.i];
                const a2 = agents[edge.j];
                
                ctx.strokeStyle = `rgba(100, 200, 255, ${edge.strength * 0.8})`;
                ctx.lineWidth = 1 + edge.strength * 4;
                ctx.beginPath();
                ctx.moveTo(a1.x, a1.y);
                ctx.lineTo(a2.x, a2.y);
                ctx.stroke();
            }
            
            // Draw agents
            for (const agent of agents) {
                // Glow based on degree
                const degree = Object.values(edges).filter(e => e.i === agent.id || e.j === agent.id).length;
                if (degree > 2) {
                    const gradient = ctx.createRadialGradient(agent.x, agent.y, 8, agent.x, agent.y, 25);
                    gradient.addColorStop(0, `${skillColors[agent.skill]}40`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Node
                const radius = 8 + degree * 1.5;
                ctx.fillStyle = skillColors[agent.skill];
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(agent.name, agent.x, agent.y + radius + 12);
            }
            
            // Title
            ctx.fillStyle = '#06b6d4';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Team Assembly Network', 20, 30);
            ctx.font = '11px sans-serif';
            ctx.fillStyle = '#888';
            ctx.fillText('Node size = connections, Edge thickness = collaboration strength', 20, 48);
            
            requestAnimationFrame(draw);
        }
        
        let intervalId = null;
        function startSim() {
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                if (!paused) {
                    step();
                }
            }, 50);
        }
        
        // Event listeners
        document.getElementById('agents').addEventListener('input', e => {
            params.agentCount = +e.target.value;
            document.getElementById('agentsVal').textContent = params.agentCount;
        });
        document.getElementById('skills').addEventListener('input', e => {
            params.skillTypes = +e.target.value;
            document.getElementById('skillsVal').textContent = params.skillTypes;
        });
        document.getElementById('teamSize').addEventListener('input', e => {
            params.teamSize = +e.target.value;
            document.getElementById('teamSizeVal').textContent = params.teamSize;
        });
        document.getElementById('decay').addEventListener('input', e => {
            params.decay = +e.target.value;
            document.getElementById('decayVal').textContent = params.decay.toFixed(2);
        });
        document.getElementById('bonus').addEventListener('input', e => {
            params.successBonus = +e.target.value;
            document.getElementById('bonusVal').textContent = params.successBonus.toFixed(2);
        });
        
        document.getElementById('reset').addEventListener('click', () => { init(); startSim(); });
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('formTeam').addEventListener('click', () => {
            const result = formTeam();
            console.log('Team formed:', result.team.map(a => a.name), 'Success:', result.success);
        });
        
        window.addEventListener('resize', resize);

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
        draw();
        startSim();
    </script>
</body>
</html>
