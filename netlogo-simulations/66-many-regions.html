<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Many Regions - Multi-Region Population Dynamics - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        canvas { display: block; flex: 1; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #fb7185; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #fb7185; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #f43f5e; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #fb7185; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .region-list { font-size: 0.75rem; max-height: 200px; overflow-y: auto; }
        .region-item { display: flex; align-items: center; margin-bottom: 5px; padding: 5px; background: rgba(255,255,255,0.05); border-radius: 3px; }
        .region-color { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Many Regions</h1>
            <p class="description">Multi-region population dynamics with migration between interconnected regions. Each region has different carrying capacity and growth rates. Watch populations equilibrate across the network.</p>

            <div class="control-group">
                <label>Number of Regions: <span id="regionValue">8</span></label>
                <input type="range" id="regions" min="3" max="15" value="8">
            </div>
            <div class="control-group">
                <label>Base Growth Rate: <span id="growthValue">0.02</span></label>
                <input type="range" id="growth" min="0.005" max="0.05" step="0.005" value="0.02">
            </div>
            <div class="control-group">
                <label>Migration Rate: <span id="migrationValue">0.05</span></label>
                <input type="range" id="migration" min="0.01" max="0.2" step="0.01" value="0.05">
            </div>
            <div class="control-group">
                <label>Network Connectivity: <span id="connectivityValue">0.4</span></label>
                <input type="range" id="connectivity" min="0.2" max="1.0" step="0.1" value="0.4">
            </div>
            <button id="reset">Reset Simulation</button>
            <button id="disaster">Random Disaster</button>
            <button id="boom">Population Boom</button>

            <div class="stats">
                <div>Total Population: <span id="totalPop">0</span></div>
                <div>Total Capacity: <span id="totalCapacity">0</span></div>
                <div>Migrations/tick: <span id="migrations">0</span></div>
                <div>Tick: <span id="tick">0</span></div>
            </div>

            <label style="font-size: 0.8rem; margin-bottom: 10px;">Region Details:</label>
            <div id="regionList" class="region-list"></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        let regions = [];
        let connections = [];
        let tick = 0;
        let migrationsThisTick = 0;

        let params = {
            regionCount: 8,
            growth: 0.02,
            migration: 0.05,
            connectivity: 0.4
        };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function createRegion(id, x, y) {
            const hue = (id * 360 / params.regionCount) % 360;
            const capacity = 50 + Math.floor(Math.random() * 150);
            const population = Math.floor(capacity * (0.1 + Math.random() * 0.4));

            return {
                id,
                x,
                y,
                radius: 30 + capacity / 5,
                population,
                capacity,
                growthRate: params.growth * (0.5 + Math.random()),
                color: `hsl(${hue}, 70%, 50%)`,
                colorLight: `hsl(${hue}, 70%, 70%)`,
                neighbors: [],
                inMigration: 0,
                outMigration: 0
            };
        }

        function init() {
            regions = [];
            connections = [];
            tick = 0;

            // Generate regions in a circular layout with some randomness
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;

            for (let i = 0; i < params.regionCount; i++) {
                const angle = (i / params.regionCount) * Math.PI * 2 - Math.PI / 2;
                const r = radius * (0.8 + Math.random() * 0.4);
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                regions.push(createRegion(i, x, y));
            }

            // Create connections based on connectivity
            for (let i = 0; i < regions.length; i++) {
                for (let j = i + 1; j < regions.length; j++) {
                    // Always connect neighbors
                    const isNeighbor = Math.abs(i - j) === 1 ||
                        (i === 0 && j === regions.length - 1);

                    if (isNeighbor || Math.random() < params.connectivity - 0.3) {
                        connections.push({ a: i, b: j });
                        regions[i].neighbors.push(j);
                        regions[j].neighbors.push(i);
                    }
                }
            }

            updateRegionList();
        }

        function update() {
            tick++;
            migrationsThisTick = 0;

            // Reset migration counters
            for (let r of regions) {
                r.inMigration = 0;
                r.outMigration = 0;
            }

            // Population growth (logistic)
            for (let r of regions) {
                const growthFactor = 1 - r.population / r.capacity;
                const growth = r.population * r.growthRate * growthFactor;
                r.population = Math.max(0, r.population + growth);
            }

            // Migration
            for (let conn of connections) {
                const a = regions[conn.a];
                const b = regions[conn.b];

                // Calculate pressure differential
                const pressureA = a.population / a.capacity;
                const pressureB = b.population / b.capacity;
                const diff = pressureA - pressureB;

                if (Math.abs(diff) > 0.05) {
                    const migrants = Math.abs(diff) * params.migration *
                        Math.min(a.population, b.population) * 0.5;

                    if (diff > 0) {
                        // A -> B
                        const actual = Math.min(migrants, a.population * 0.1);
                        a.population -= actual;
                        b.population += actual;
                        a.outMigration += actual;
                        b.inMigration += actual;
                    } else {
                        // B -> A
                        const actual = Math.min(migrants, b.population * 0.1);
                        b.population -= actual;
                        a.population += actual;
                        b.outMigration += actual;
                        a.inMigration += actual;
                    }
                    migrationsThisTick += migrants;
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw connections
            for (let conn of connections) {
                const a = regions[conn.a];
                const b = regions[conn.b];

                // Connection intensity based on flow
                const flow = Math.abs((a.population / a.capacity) - (b.population / b.capacity));
                const alpha = 0.1 + flow * 0.5;

                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1 + flow * 3;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();

                // Arrow indicator for net flow
                if (flow > 0.1) {
                    const pressureA = a.population / a.capacity;
                    const pressureB = b.population / b.capacity;
                    const midX = (a.x + b.x) / 2;
                    const midY = (a.y + b.y) / 2;

                    const fromRegion = pressureA > pressureB ? a : b;
                    const angle = Math.atan2(midY - fromRegion.y, midX - fromRegion.x);

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(midX, midY);
                    ctx.lineTo(midX - 8 * Math.cos(angle - 0.5), midY - 8 * Math.sin(angle - 0.5));
                    ctx.lineTo(midX - 8 * Math.cos(angle + 0.5), midY - 8 * Math.sin(angle + 0.5));
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw regions
            for (let r of regions) {
                const fillLevel = r.population / r.capacity;
                const displayRadius = r.radius * (0.7 + fillLevel * 0.3);

                // Outer ring (capacity)
                ctx.strokeStyle = r.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Fill level
                ctx.fillStyle = r.color;
                ctx.globalAlpha = 0.3 + fillLevel * 0.4;
                ctx.beginPath();
                ctx.arc(r.x, r.y, displayRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Population pie indicator
                ctx.fillStyle = r.colorLight;
                ctx.beginPath();
                ctx.moveTo(r.x, r.y);
                ctx.arc(r.x, r.y, r.radius * 0.6, -Math.PI / 2,
                    -Math.PI / 2 + fillLevel * Math.PI * 2);
                ctx.closePath();
                ctx.fill();

                // Center dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(r.x, r.y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Population text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.floor(r.population), r.x, r.y - r.radius - 15);

                // Capacity text
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#888';
                ctx.fillText(`/${r.capacity}`, r.x, r.y - r.radius - 3);

                // Migration indicators
                if (r.inMigration > 0.5) {
                    ctx.fillStyle = '#22c55e';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(`+${r.inMigration.toFixed(0)}`, r.x + r.radius + 10, r.y - 5);
                }
                if (r.outMigration > 0.5) {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText(`-${r.outMigration.toFixed(0)}`, r.x + r.radius + 10, r.y + 10);
                }
            }

            // Update stats
            const totalPop = regions.reduce((sum, r) => sum + r.population, 0);
            const totalCap = regions.reduce((sum, r) => sum + r.capacity, 0);

            document.getElementById('totalPop').textContent = Math.floor(totalPop);
            document.getElementById('totalCapacity').textContent = totalCap;
            document.getElementById('migrations').textContent = Math.floor(migrationsThisTick);
            document.getElementById('tick').textContent = tick;
        }

        function updateRegionList() {
            const list = document.getElementById('regionList');
            list.innerHTML = '';

            for (let r of regions) {
                const item = document.createElement('div');
                item.className = 'region-item';
                item.innerHTML = `
                    <span class="region-color" style="background: ${r.color}"></span>
                    <span>Region ${r.id + 1}: ${Math.floor(r.population)}/${r.capacity}</span>
                `;
                list.appendChild(item);
            }
        }

        function animate() {
            update();
            draw();

            if (tick % 20 === 0) updateRegionList();

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('regions').addEventListener('input', e => {
            params.regionCount = parseInt(e.target.value);
            document.getElementById('regionValue').textContent = params.regionCount;
        });
        document.getElementById('growth').addEventListener('input', e => {
            params.growth = parseFloat(e.target.value);
            document.getElementById('growthValue').textContent = params.growth.toFixed(3);
        });
        document.getElementById('migration').addEventListener('input', e => {
            params.migration = parseFloat(e.target.value);
            document.getElementById('migrationValue').textContent = params.migration.toFixed(2);
        });
        document.getElementById('connectivity').addEventListener('input', e => {
            params.connectivity = parseFloat(e.target.value);
            document.getElementById('connectivityValue').textContent = params.connectivity.toFixed(1);
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('disaster').addEventListener('click', () => {
            const victim = regions[Math.floor(Math.random() * regions.length)];
            victim.population *= 0.2;
        });
        document.getElementById('boom').addEventListener('click', () => {
            const lucky = regions[Math.floor(Math.random() * regions.length)];
            lucky.population = lucky.capacity * 1.5;
        });

        window.addEventListener('resize', () => {
            resize();
            init();
        });

        resize();
        init();
        animate();
    </script>
</body>
</html>
