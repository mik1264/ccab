<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Membrane Formation - Lipid Bilayer Self-Assembly - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a15;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        canvas { display: block; flex: 1; }
        #controls { width: 280px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #06b6d4; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #06b6d4; color: #0a0a15; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #0891b2; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #06b6d4; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Membrane Formation</h1>
            <p class="description">Lipid bilayer self-assembly simulation. Amphiphilic molecules (hydrophilic heads, hydrophobic tails) spontaneously form micelles and vesicles in water.</p>
            <div class="control-group">
                <label>Lipid Count: <span id="lipidValue">200</span></label>
                <input type="range" id="lipids" min="50" max="500" value="200">
            </div>
            <div class="control-group">
                <label>Temperature: <span id="tempValue">1.0</span></label>
                <input type="range" id="temp" min="0.3" max="2.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Hydrophobic Strength: <span id="hydroValue">1.0</span></label>
                <input type="range" id="hydro" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>
            <button id="reset">Reset</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="heat">Add Heat</button>
            <button id="addLipids">Add More Lipids</button>
            <div class="stats">
                <div>Lipids: <span id="count">0</span></div>
                <div>Micelles: <span id="micelles">0</span></div>
                <div>Vesicles: <span id="vesicles">0</span></div>
                <div>Free Lipids: <span id="free">0</span></div>
                <div>Avg Cluster Size: <span id="avgCluster">0</span></div>
            </div>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Membrane Formation - Lipid Bilayer Self-Assembly</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        let lipids = [];
        let params = { lipids: 200, temp: 1.0, hydro: 1.0 };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function createLipid(x, y) {
            return {
                x: x !== undefined ? x : Math.random() * width,
                y: y !== undefined ? y : Math.random() * height,
                angle: Math.random() * Math.PI * 2,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                va: (Math.random() - 0.5) * 0.1,
                headRadius: 5,
                tailLength: 12,
                clusterId: -1
            };
        }

        function init() {
            resize();
            lipids = [];

            for (let i = 0; i < params.lipids; i++) {
                lipids.push(createLipid());
            }
        }

        function headPos(lipid) {
            return {
                x: lipid.x + Math.cos(lipid.angle) * lipid.headRadius,
                y: lipid.y + Math.sin(lipid.angle) * lipid.headRadius
            };
        }

        function tailPos(lipid) {
            return {
                x: lipid.x - Math.cos(lipid.angle) * lipid.tailLength,
                y: lipid.y - Math.sin(lipid.angle) * lipid.tailLength
            };
        }

        function update() {
            // Apply forces between lipids
            for (let i = 0; i < lipids.length; i++) {
                const a = lipids[i];
                const aHead = headPos(a);
                const aTail = tailPos(a);

                for (let j = i + 1; j < lipids.length; j++) {
                    const b = lipids[j];
                    const bHead = headPos(b);
                    const bTail = tailPos(b);

                    // Head-head repulsion (both hydrophilic, repel slightly)
                    let dx = bHead.x - aHead.x;
                    let dy = bHead.y - aHead.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 20 && dist > 0) {
                        const force = 0.3 / dist;
                        a.vx -= (dx / dist) * force;
                        a.vy -= (dy / dist) * force;
                        b.vx += (dx / dist) * force;
                        b.vy += (dy / dist) * force;
                    }

                    // Tail-tail attraction (hydrophobic effect)
                    dx = bTail.x - aTail.x;
                    dy = bTail.y - aTail.y;
                    dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 30 && dist > 5) {
                        const force = 0.5 * params.hydro / dist;
                        a.vx += (dx / dist) * force;
                        a.vy += (dy / dist) * force;
                        b.vx -= (dx / dist) * force;
                        b.vy -= (dy / dist) * force;

                        // Align tails (tend to be parallel)
                        const angleDiff = b.angle - a.angle;
                        a.va += Math.sin(angleDiff) * 0.01;
                        b.va -= Math.sin(angleDiff) * 0.01;
                    }

                    // Head-tail repulsion (hydrophilic head avoids hydrophobic tail)
                    dx = bTail.x - aHead.x;
                    dy = bTail.y - aHead.y;
                    dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 15 && dist > 0) {
                        const force = 0.4 * params.hydro / dist;
                        a.vx -= (dx / dist) * force;
                        a.vy -= (dy / dist) * force;
                    }

                    dx = aTail.x - bHead.x;
                    dy = aTail.y - bHead.y;
                    dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 15 && dist > 0) {
                        const force = 0.4 * params.hydro / dist;
                        b.vx -= (dx / dist) * force;
                        b.vy -= (dy / dist) * force;
                    }

                    // General collision avoidance
                    dx = b.x - a.x;
                    dy = b.y - a.y;
                    dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 10 && dist > 0) {
                        const force = 1 / dist;
                        a.vx -= (dx / dist) * force;
                        a.vy -= (dy / dist) * force;
                        b.vx += (dx / dist) * force;
                        b.vy += (dy / dist) * force;
                    }
                }

                // Brownian motion
                a.vx += (Math.random() - 0.5) * params.temp;
                a.vy += (Math.random() - 0.5) * params.temp;
                a.va += (Math.random() - 0.5) * 0.05 * params.temp;
            }

            // Update positions
            for (let lipid of lipids) {
                lipid.vx *= 0.95;
                lipid.vy *= 0.95;
                lipid.va *= 0.9;

                // Speed limit
                const speed = Math.sqrt(lipid.vx * lipid.vx + lipid.vy * lipid.vy);
                if (speed > 5) {
                    lipid.vx = (lipid.vx / speed) * 5;
                    lipid.vy = (lipid.vy / speed) * 5;
                }

                lipid.x += lipid.vx;
                lipid.y += lipid.vy;
                lipid.angle += lipid.va;

                // Boundaries
                if (lipid.x < 20) { lipid.x = 20; lipid.vx *= -0.5; }
                if (lipid.x > width - 20) { lipid.x = width - 20; lipid.vx *= -0.5; }
                if (lipid.y < 20) { lipid.y = 20; lipid.vy *= -0.5; }
                if (lipid.y > height - 20) { lipid.y = height - 20; lipid.vy *= -0.5; }
            }

            // Cluster detection
            for (let lipid of lipids) lipid.clusterId = -1;
            let clusterId = 0;
            for (let i = 0; i < lipids.length; i++) {
                if (lipids[i].clusterId >= 0) continue;

                // BFS to find cluster
                const queue = [i];
                lipids[i].clusterId = clusterId;
                while (queue.length > 0) {
                    const idx = queue.shift();
                    const a = lipids[idx];
                    const aTail = tailPos(a);

                    for (let j = 0; j < lipids.length; j++) {
                        if (lipids[j].clusterId >= 0) continue;
                        const bTail = tailPos(lipids[j]);
                        const dx = bTail.x - aTail.x;
                        const dy = bTail.y - aTail.y;
                        if (dx * dx + dy * dy < 400) {
                            lipids[j].clusterId = clusterId;
                            queue.push(j);
                        }
                    }
                }
                clusterId++;
            }
        }

        function draw() {
            // Water background
            ctx.fillStyle = '#0a1525';
            ctx.fillRect(0, 0, width, height);

            // Draw water molecules (subtle)
            ctx.fillStyle = 'rgba(50, 100, 150, 0.1)';
            for (let i = 0; i < 100; i++) {
                const x = (Math.sin(Date.now() * 0.001 + i) * 0.5 + 0.5) * width;
                const y = (Math.cos(Date.now() * 0.0012 + i * 1.3) * 0.5 + 0.5) * height;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw lipids
            for (let lipid of lipids) {
                const head = headPos(lipid);
                const tail = tailPos(lipid);

                // Tail (hydrophobic) - yellow/orange
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(lipid.x, lipid.y);
                ctx.lineTo(tail.x, tail.y);
                ctx.stroke();

                // Tail end
                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(tail.x, tail.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Head (hydrophilic) - blue/cyan
                ctx.fillStyle = '#06b6d4';
                ctx.beginPath();
                ctx.arc(head.x, head.y, lipid.headRadius, 0, Math.PI * 2);
                ctx.fill();

                // Head highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(head.x - 1, head.y - 1, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Count structures
            const clusterSizes = {};
            for (let lipid of lipids) {
                clusterSizes[lipid.clusterId] = (clusterSizes[lipid.clusterId] || 0) + 1;
            }

            const sizes = Object.values(clusterSizes);
            const freeLipids = sizes.filter(s => s === 1).length;
            const micelles = sizes.filter(s => s >= 5 && s < 20).length;
            const vesicles = sizes.filter(s => s >= 20).length;
            const avgCluster = sizes.length > 0 ?
                sizes.reduce((a, b) => a + b, 0) / sizes.length : 0;

            document.getElementById('count').textContent = lipids.length;
            document.getElementById('micelles').textContent = micelles;
            document.getElementById('vesicles').textContent = vesicles;
            document.getElementById('free').textContent = freeLipids;
            document.getElementById('avgCluster').textContent = avgCluster.toFixed(1);
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('lipids').addEventListener('input', e => {
            params.lipids = parseInt(e.target.value);
            document.getElementById('lipidValue').textContent = params.lipids;
        });
        document.getElementById('temp').addEventListener('input', e => {
            params.temp = parseFloat(e.target.value);
            document.getElementById('tempValue').textContent = params.temp.toFixed(1);
        });
        document.getElementById('hydro').addEventListener('input', e => {
            params.hydro = parseFloat(e.target.value);
            document.getElementById('hydroValue').textContent = params.hydro.toFixed(1);
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('heat').addEventListener('click', () => {
            for (let lipid of lipids) {
                lipid.vx += (Math.random() - 0.5) * 10;
                lipid.vy += (Math.random() - 0.5) * 10;
            }
        });
        document.getElementById('addLipids').addEventListener('click', () => {
            for (let i = 0; i < 20; i++) {
                lipids.push(createLipid(width / 2 + (Math.random() - 0.5) * 100,
                                        height / 2 + (Math.random() - 0.5) * 100));
            }
        });

        window.addEventListener('resize', resize);

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
