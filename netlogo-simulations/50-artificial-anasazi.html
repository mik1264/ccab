<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artificial Anasazi - Long House Valley Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #2d1f0f 0%, #1a120a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: #e0d5c5;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #d4a574, #8b6914);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .description {
            text-align: center;
            max-width: 700px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #a89078;
        }
        #container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        #canvas { border: 2px solid #5d4d35; border-radius: 4px; }
        .panel {
            background: rgba(45, 31, 15, 0.9);
            padding: 15px;
            border-radius: 8px;
            width: 240px;
            border: 1px solid #5d4d35;
        }
        .panel h3 { font-size: 0.9rem; margin-bottom: 10px; color: #d4a574; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; color: #a89078; margin-bottom: 3px; }
        input[type="range"] { width: 100%; }
        button {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #d4a574, #8b6914);
            border: none;
            border-radius: 5px;
            color: #1a120a;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { opacity: 0.9; }
        .stats { font-size: 0.75rem; color: #a89078; }
        .stats div { margin-bottom: 4px; display: flex; justify-content: space-between; }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(26, 18, 10, 0.9);
            color: #d4a574;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
        }
        .year-display {
            font-size: 1.2rem;
            color: #d4a574;
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .chart { height: 80px; background: rgba(0,0,0,0.3); border-radius: 4px; margin-top: 10px; }
        #popChart { width: 100%; height: 100%; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Artificial Anasazi</h1>
    <p class="description">Long House Valley archaeological simulation. Models ancestral Puebloan settlement patterns based on climate, maize agriculture, and population dynamics from 800-1350 CE.</p>

    <div id="container">
        <canvas id="canvas" width="500" height="400"></canvas>
        <div class="panel">
            <div class="year-display">Year: <span id="yearDisplay">800</span> CE</div>

            <h3>Controls</h3>
            <div class="control-group">
                <label>Simulation Speed: <span id="speedVal">1</span>x</label>
                <input type="range" id="speed" min="1" max="10" step="1" value="1">
            </div>
            <div class="control-group">
                <label>Fertility Rate: <span id="fertilityVal">0.125</span></label>
                <input type="range" id="fertility" min="0.05" max="0.2" step="0.005" value="0.125">
            </div>
            <div class="control-group">
                <label>Death Rate: <span id="deathVal">0.1</span></label>
                <input type="range" id="death" min="0.05" max="0.2" step="0.01" value="0.1">
            </div>
            <button id="resetBtn">Reset (800 CE)</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="pauseBtn">Pause</button>

            <h3>Statistics</h3>
            <div class="stats">
                <div><span>Population:</span> <span id="population">0</span></div>
                <div><span>Households:</span> <span id="households">0</span></div>
                <div><span>Settlements:</span> <span id="settlements">0</span></div>
                <div><span>Maize Yield:</span> <span id="maizeYield">0</span></div>
                <div><span>Climate:</span> <span id="climate">Normal</span></div>
            </div>

            <h3>Population History</h3>
            <div class="chart">
                <canvas id="popChart"></canvas>
            </div>
        </div>
    </div>

    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Artificial Anasazi - Long House Valley Simulation</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const popChart = document.getElementById('popChart');
        const popCtx = popChart.getContext('2d');
        popChart.width = 210;
        popChart.height = 80;

        const GRID_SIZE = 50;
        const CELL_W = canvas.width / GRID_SIZE;
        const CELL_H = canvas.height / GRID_SIZE;

        let year = 800;
        let running = true;
        let speed = 1;
        let fertility = 0.125;
        let deathRate = 0.1;

        let terrain = [];
        let households = [];
        let populationHistory = [];

        // Historical climate data (simplified)
        const climateData = {
            800: 1.0, 850: 1.1, 900: 0.9, 950: 1.2, 1000: 1.0,
            1050: 0.8, 1100: 1.1, 1150: 1.0, 1200: 0.7, 1250: 0.6,
            1300: 0.5, 1350: 0.4
        };

        function getClimate(y) {
            const keys = Object.keys(climateData).map(Number).sort((a,b) => a-b);
            let prev = keys[0], next = keys[0];
            for (const k of keys) {
                if (k <= y) prev = k;
                if (k >= y && next === keys[0]) next = k;
            }
            if (prev === next) return climateData[prev];
            const t = (y - prev) / (next - prev);
            return climateData[prev] * (1 - t) + climateData[next] * t;
        }

        function initTerrain() {
            terrain = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    // Create varied terrain with water sources and fertile areas
                    const riverDist = Math.abs(x - GRID_SIZE/2 + Math.sin(y/5) * 5);
                    const elevation = Math.sin(x/10) * Math.cos(y/8) * 0.3 + 0.5;
                    const waterAccess = Math.max(0, 1 - riverDist / 10);
                    const fertility = (waterAccess * 0.6 + (1 - elevation) * 0.4) * (0.7 + Math.random() * 0.3);

                    terrain.push({
                        x, y,
                        elevation,
                        waterAccess,
                        baseFertility: fertility,
                        maizeYield: 0
                    });
                }
            }
        }

        function updateMaizeYields() {
            const climate = getClimate(year);
            for (const cell of terrain) {
                cell.maizeYield = cell.baseFertility * climate * (0.8 + Math.random() * 0.4);
            }
        }

        class Household {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.population = 3 + Math.floor(Math.random() * 4);
                this.corn = 100;
                this.age = 0;
            }

            getCellIndex() {
                const gx = Math.floor(this.x / CELL_W);
                const gy = Math.floor(this.y / CELL_H);
                return gy * GRID_SIZE + gx;
            }

            update() {
                this.age++;
                const cellIdx = this.getCellIndex();
                const cell = terrain[cellIdx];

                // Harvest maize
                const harvest = cell.maizeYield * 50 * this.population;
                this.corn += harvest;

                // Consumption
                const consumption = this.population * 30;
                this.corn -= consumption;

                // Population dynamics
                if (this.corn > 200 * this.population) {
                    // Surplus - chance of birth
                    if (Math.random() < fertility) {
                        this.population++;
                    }
                } else if (this.corn < 50 * this.population) {
                    // Shortage - chance of death
                    if (Math.random() < deathRate * 2) {
                        this.population--;
                    }
                }

                // Normal death
                if (Math.random() < deathRate * 0.5) {
                    this.population--;
                }

                // Move if resources are depleted
                if (this.corn < 30 * this.population) {
                    this.findBetterLocation();
                }

                this.corn = Math.max(0, this.corn);
                return this.population > 0;
            }

            findBetterLocation() {
                let bestCell = null;
                let bestYield = 0;

                for (let i = 0; i < 10; i++) {
                    const idx = Math.floor(Math.random() * terrain.length);
                    const cell = terrain[idx];
                    if (cell.maizeYield > bestYield) {
                        // Check if not too crowded
                        const nearby = households.filter(h => {
                            const dx = h.x - cell.x * CELL_W;
                            const dy = h.y - cell.y * CELL_H;
                            return Math.sqrt(dx*dx + dy*dy) < CELL_W * 3;
                        }).length;

                        if (nearby < 3) {
                            bestYield = cell.maizeYield;
                            bestCell = cell;
                        }
                    }
                }

                if (bestCell) {
                    this.x = bestCell.x * CELL_W + CELL_W/2;
                    this.y = bestCell.y * CELL_H + CELL_H/2;
                }
            }

            fission() {
                if (this.population >= 8 && this.corn > 300) {
                    const newPop = Math.floor(this.population / 2);
                    this.population -= newPop;
                    this.corn /= 2;

                    const newHH = new Household(
                        this.x + (Math.random() - 0.5) * CELL_W * 4,
                        this.y + (Math.random() - 0.5) * CELL_H * 4
                    );
                    newHH.population = newPop;
                    newHH.corn = this.corn;
                    return newHH;
                }
                return null;
            }
        }

        function init() {
            year = 800;
            households = [];
            populationHistory = [];
            initTerrain();
            updateMaizeYields();

            // Initial population
            for (let i = 0; i < 10; i++) {
                const cell = terrain[Math.floor(Math.random() * terrain.length)];
                if (cell.baseFertility > 0.5) {
                    households.push(new Household(
                        cell.x * CELL_W + CELL_W/2,
                        cell.y * CELL_H + CELL_H/2
                    ));
                }
            }
        }

        function step() {
            year++;
            updateMaizeYields();

            // Update households
            const newHouseholds = [];
            households = households.filter(h => {
                const alive = h.update();
                if (alive) {
                    const child = h.fission();
                    if (child) newHouseholds.push(child);
                }
                return alive;
            });
            households.push(...newHouseholds);

            // Record population
            const totalPop = households.reduce((sum, h) => sum + h.population, 0);
            populationHistory.push({ year, pop: totalPop });
            if (populationHistory.length > 200) populationHistory.shift();

            // End simulation at 1350
            if (year >= 1350) {
                running = false;
                document.getElementById('pauseBtn').textContent = 'Complete';
            }
        }

        function draw() {
            // Draw terrain
            for (const cell of terrain) {
                const fertility = cell.maizeYield;
                const r = Math.floor(139 + (1 - fertility) * 50);
                const g = Math.floor(90 + fertility * 80);
                const b = Math.floor(43 + (1 - fertility) * 30);

                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(cell.x * CELL_W, cell.y * CELL_H, CELL_W, CELL_H);

                // Water
                if (cell.waterAccess > 0.5) {
                    ctx.fillStyle = `rgba(65, 105, 225, ${cell.waterAccess * 0.3})`;
                    ctx.fillRect(cell.x * CELL_W, cell.y * CELL_H, CELL_W, CELL_H);
                }
            }

            // Draw households as pueblos
            for (const h of households) {
                const size = 3 + h.population / 2;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(h.x - size/2 + 2, h.y - size/2 + 2, size, size);

                // Building
                ctx.fillStyle = '#c9a66b';
                ctx.fillRect(h.x - size/2, h.y - size/2, size, size);

                // Roof detail
                ctx.fillStyle = '#8b6914';
                ctx.fillRect(h.x - size/2, h.y - size/2, size, 2);
            }

            // Draw population chart
            popCtx.fillStyle = 'rgba(0,0,0,0.5)';
            popCtx.fillRect(0, 0, popChart.width, popChart.height);

            if (populationHistory.length > 1) {
                const maxPop = Math.max(...populationHistory.map(p => p.pop), 100);
                popCtx.strokeStyle = '#d4a574';
                popCtx.lineWidth = 1.5;
                popCtx.beginPath();

                populationHistory.forEach((p, i) => {
                    const x = (i / populationHistory.length) * popChart.width;
                    const y = popChart.height - (p.pop / maxPop) * (popChart.height - 10);
                    if (i === 0) popCtx.moveTo(x, y);
                    else popCtx.lineTo(x, y);
                });
                popCtx.stroke();
            }
        }

        function updateStats() {
            const totalPop = households.reduce((sum, h) => sum + h.population, 0);
            const avgYield = terrain.reduce((sum, c) => sum + c.maizeYield, 0) / terrain.length;
            const climate = getClimate(year);

            document.getElementById('yearDisplay').textContent = year;
            document.getElementById('population').textContent = totalPop;
            document.getElementById('households').textContent = households.length;
            document.getElementById('settlements').textContent = new Set(
                households.map(h => `${Math.floor(h.x/CELL_W/5)},${Math.floor(h.y/CELL_H/5)}`)
            ).size;
            document.getElementById('maizeYield').textContent = (avgYield * 100).toFixed(0) + '%';
            document.getElementById('climate').textContent =
                climate > 1.0 ? 'Wet' : climate > 0.7 ? 'Normal' : climate > 0.5 ? 'Dry' : 'Drought';
        }

        // Controls
        document.getElementById('speed').addEventListener('input', function() {
            speed = parseInt(this.value);
            document.getElementById('speedVal').textContent = speed;
        });

        document.getElementById('fertility').addEventListener('input', function() {
            fertility = parseFloat(this.value);
            document.getElementById('fertilityVal').textContent = fertility.toFixed(3);
        });

        document.getElementById('death').addEventListener('input', function() {
            deathRate = parseFloat(this.value);
            document.getElementById('deathVal').textContent = deathRate.toFixed(2);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            init();
            running = true;
            document.getElementById('pauseBtn').textContent = 'Pause';
        });

        document.getElementById('pauseBtn').addEventListener('click', function() {
            if (year < 1350) {
                running = !running;
                this.textContent = running ? 'Pause' : 'Resume';
            }
        });

        let frameCount = 0;
        function animate() {
            if (running) {
                frameCount++;
                if (frameCount % Math.max(1, 11 - speed) === 0) {
                    step();
                    draw();
                    updateStats();
                }
            }
            requestAnimationFrame(animate);
        }


        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
        draw();
        updateStats();
        animate();
    </script>
</body>
</html>
