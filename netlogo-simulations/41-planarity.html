<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planarity - Graph Untangling Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 320px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #888;
            font-size: 0.95em;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #bbb;
        }
        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #e0e0e0;
        }
        .control-group .value {
            text-align: right;
            font-size: 0.9em;
            color: #10b981;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(16,185,129,0.3);
        }
        .stats {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .stats h3 {
            margin-bottom: 12px;
            color: #10b981;
            font-size: 1em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #6ee7b7;
            font-weight: 600;
        }
        .info-box {
            background: rgba(16,185,129,0.1);
            border-left: 3px solid #10b981;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85em;
            border-radius: 0 8px 8px 0;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: color 0.3s;
        }
        .back-link:hover {
            color: #10b981;
        }
        .victory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16,185,129,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            display: none;
        }
        .victory h2 {
            font-size: 2em;
            margin-bottom: 15px;
        }
        .victory p {
            margin-bottom: 20px;
        }
        .level-display {
            font-size: 2em;
            text-align: center;
            padding: 15px;
            background: rgba(16,185,129,0.2);
            border-radius: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <a href="index.html" class="back-link">← Back to Simulations</a>

            <div class="info-box">
                <strong>Planarity Puzzle</strong><br>
                Untangle the graph by dragging nodes! A planar graph can be drawn with no edge crossings. Your goal: eliminate all crossings.
            </div>

            <div class="level-display">
                Level <span id="level">1</span>
            </div>

            <div class="control-group">
                <label>Difficulty:</label>
                <select id="difficulty">
                    <option value="1">Easy (5 nodes)</option>
                    <option value="2" selected>Medium (8 nodes)</option>
                    <option value="3">Hard (12 nodes)</option>
                    <option value="4">Expert (16 nodes)</option>
                </select>
            </div>

            <button class="btn-primary" id="newGame">New Puzzle</button>
            <button class="btn-secondary" id="hint">Show Hint</button>
            <button class="btn-secondary" id="shuffle">Shuffle</button>

            <div class="stats">
                <h3>Puzzle Status</h3>
                <div class="stat-row">
                    <span class="stat-label">Crossings:</span>
                    <span class="stat-value" id="crossings">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Nodes:</span>
                    <span class="stat-value" id="nodeCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Edges:</span>
                    <span class="stat-value" id="edgeCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Moves:</span>
                    <span class="stat-value" id="moves">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Best Time:</span>
                    <span class="stat-value" id="bestTime">--</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Tips:</strong><br>
                • Start with high-degree nodes<br>
                • Keep edge lengths similar<br>
                • Look for symmetry<br>
                • Outer nodes often form a cycle
            </div>
        </aside>

        <main class="main">
            <header>
                <h1>Planarity Puzzle</h1>
                <p class="subtitle">Drag nodes to untangle the graph - eliminate all edge crossings</p>
            </header>
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>
        </main>
    </div>

    <div class="victory" id="victory">
        <h2>Solved!</h2>
        <p>You untangled the graph in <span id="solveTime">0</span> seconds with <span id="solveMoves">0</span> moves!</p>
        <button class="btn-primary" id="nextLevel">Next Level</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = Math.min(container.clientWidth - 40, 700);
            canvas.height = canvas.width;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let crossings = 0;
        let moves = 0;
        let level = 1;
        let startTime = 0;
        let bestTimes = {};
        let hintPositions = [];

        // Difficulty settings
        const difficulties = {
            1: { nodes: 5, edges: 7 },
            2: { nodes: 8, edges: 14 },
            3: { nodes: 12, edges: 24 },
            4: { nodes: 16, edges: 36 }
        };

        // Generate a planar graph
        function generatePlanarGraph(nodeCount, edgeCount) {
            nodes = [];
            edges = [];
            hintPositions = [];

            // Create nodes in a circle (guaranteed planar layout)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.7;

            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push({ id: i, x, y });
                hintPositions.push({ x, y });
            }

            // Create edges - planar triangulation approach
            // First, create outer cycle
            for (let i = 0; i < nodeCount; i++) {
                edges.push([i, (i + 1) % nodeCount]);
            }

            // Add internal edges (spokes and chords)
            const maxEdges = Math.min(edgeCount, nodeCount * 3 - 6); // Euler's formula limit
            let attempts = 0;

            while (edges.length < maxEdges && attempts < 1000) {
                const i = Math.floor(Math.random() * nodeCount);
                let j = Math.floor(Math.random() * nodeCount);

                // Skip if same node or already connected
                if (i === j) { attempts++; continue; }
                if (edges.some(e => (e[0] === i && e[1] === j) || (e[0] === j && e[1] === i))) {
                    attempts++;
                    continue;
                }

                // Check if adding this edge would create a crossing in the hint layout
                let wouldCross = false;
                for (const [a, b] of edges) {
                    if (a === i || a === j || b === i || b === j) continue;
                    if (edgesIntersect(
                        hintPositions[i], hintPositions[j],
                        hintPositions[a], hintPositions[b]
                    )) {
                        wouldCross = true;
                        break;
                    }
                }

                if (!wouldCross) {
                    edges.push([i, j]);
                }
                attempts++;
            }

            // Shuffle node positions
            shuffleNodes();

            moves = 0;
            startTime = Date.now();
            updateStats();
        }

        // Shuffle nodes
        function shuffleNodes() {
            const margin = 50;
            for (const node of nodes) {
                node.x = margin + Math.random() * (canvas.width - 2 * margin);
                node.y = margin + Math.random() * (canvas.height - 2 * margin);
            }
        }

        // Check if two line segments intersect
        function edgesIntersect(p1, p2, p3, p4) {
            const ccw = (A, B, C) => {
                return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
            };

            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) &&
                   ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }

        // Count crossings
        function countCrossings() {
            let count = 0;
            for (let i = 0; i < edges.length; i++) {
                for (let j = i + 1; j < edges.length; j++) {
                    const [a, b] = edges[i];
                    const [c, d] = edges[j];

                    // Skip if edges share a node
                    if (a === c || a === d || b === c || b === d) continue;

                    if (edgesIntersect(nodes[a], nodes[b], nodes[c], nodes[d])) {
                        count++;
                    }
                }
            }
            return count;
        }

        // Update statistics
        function updateStats() {
            crossings = countCrossings();
            document.getElementById('crossings').textContent = crossings;
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;
            document.getElementById('moves').textContent = moves;
            document.getElementById('level').textContent = level;

            const key = `level${level}`;
            document.getElementById('bestTime').textContent =
                bestTimes[key] ? `${bestTimes[key]}s` : '--';

            // Check for victory
            if (crossings === 0 && nodes.length > 0) {
                victory();
            }
        }

        // Victory!
        function victory() {
            const solveTime = Math.round((Date.now() - startTime) / 1000);
            document.getElementById('solveTime').textContent = solveTime;
            document.getElementById('solveMoves').textContent = moves;
            document.getElementById('victory').style.display = 'block';

            const key = `level${level}`;
            if (!bestTimes[key] || solveTime < bestTimes[key]) {
                bestTimes[key] = solveTime;
            }
        }

        // Draw game
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Find crossing edges for highlighting
            const crossingEdges = new Set();
            for (let i = 0; i < edges.length; i++) {
                for (let j = i + 1; j < edges.length; j++) {
                    const [a, b] = edges[i];
                    const [c, d] = edges[j];
                    if (a === c || a === d || b === c || b === d) continue;
                    if (edgesIntersect(nodes[a], nodes[b], nodes[c], nodes[d])) {
                        crossingEdges.add(i);
                        crossingEdges.add(j);
                    }
                }
            }

            // Draw edges
            for (let i = 0; i < edges.length; i++) {
                const [a, b] = edges[i];
                const isCrossing = crossingEdges.has(i);

                ctx.strokeStyle = isCrossing ? '#ef4444' : '#10b981';
                ctx.lineWidth = isCrossing ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(nodes[a].x, nodes[a].y);
                ctx.lineTo(nodes[b].x, nodes[b].y);
                ctx.stroke();
            }

            // Draw crossing points
            for (let i = 0; i < edges.length; i++) {
                for (let j = i + 1; j < edges.length; j++) {
                    const [a, b] = edges[i];
                    const [c, d] = edges[j];
                    if (a === c || a === d || b === c || b === d) continue;
                    if (edgesIntersect(nodes[a], nodes[b], nodes[c], nodes[d])) {
                        // Find intersection point
                        const intersect = getIntersection(nodes[a], nodes[b], nodes[c], nodes[d]);
                        if (intersect) {
                            ctx.fillStyle = '#fbbf24';
                            ctx.beginPath();
                            ctx.arc(intersect.x, intersect.y, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw nodes
            for (const node of nodes) {
                const isSelected = node === selectedNode;
                const radius = isSelected ? 18 : 14;

                // Glow
                if (isSelected) {
                    const gradient = ctx.createRadialGradient(
                        node.x, node.y, radius,
                        node.x, node.y, radius * 2
                    );
                    gradient.addColorStop(0, 'rgba(16,185,129,0.4)');
                    gradient.addColorStop(1, 'rgba(16,185,129,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Node circle
                ctx.fillStyle = isSelected ? '#34d399' : '#10b981';
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((node.id + 1).toString(), node.x, node.y);
            }

            requestAnimationFrame(draw);
        }

        // Get intersection point of two lines
        function getIntersection(p1, p2, p3, p4) {
            const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (Math.abs(denom) < 0.0001) return null;

            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
            return {
                x: p1.x + ua * (p2.x - p1.x),
                y: p1.y + ua * (p2.y - p1.y)
            };
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find clicked node
            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (dx * dx + dy * dy < 400) {
                    selectedNode = node;
                    dragOffset.x = dx;
                    dragOffset.y = dy;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!selectedNode) return;

            const rect = canvas.getBoundingClientRect();
            selectedNode.x = e.clientX - rect.left + dragOffset.x;
            selectedNode.y = e.clientY - rect.top + dragOffset.y;

            // Keep in bounds
            const margin = 20;
            selectedNode.x = Math.max(margin, Math.min(canvas.width - margin, selectedNode.x));
            selectedNode.y = Math.max(margin, Math.min(canvas.height - margin, selectedNode.y));
        });

        canvas.addEventListener('mouseup', () => {
            if (selectedNode) {
                moves++;
                updateStats();
            }
            selectedNode = null;
        });

        canvas.addEventListener('mouseleave', () => {
            if (selectedNode) {
                moves++;
                updateStats();
            }
            selectedNode = null;
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (dx * dx + dy * dy < 600) {
                    selectedNode = node;
                    dragOffset.x = dx;
                    dragOffset.y = dy;
                    break;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!selectedNode) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            selectedNode.x = touch.clientX - rect.left + dragOffset.x;
            selectedNode.y = touch.clientY - rect.top + dragOffset.y;

            const margin = 20;
            selectedNode.x = Math.max(margin, Math.min(canvas.width - margin, selectedNode.x));
            selectedNode.y = Math.max(margin, Math.min(canvas.height - margin, selectedNode.y));
        });

        canvas.addEventListener('touchend', () => {
            if (selectedNode) {
                moves++;
                updateStats();
            }
            selectedNode = null;
        });

        // Button events
        document.getElementById('newGame').addEventListener('click', () => {
            document.getElementById('victory').style.display = 'none';
            const diff = parseInt(document.getElementById('difficulty').value);
            const settings = difficulties[diff];
            generatePlanarGraph(settings.nodes, settings.edges);
        });

        document.getElementById('hint').addEventListener('click', () => {
            // Show hint positions briefly
            for (let i = 0; i < nodes.length; i++) {
                const target = hintPositions[i];
                const node = nodes[i];
                const dx = (target.x - node.x) * 0.3;
                const dy = (target.y - node.y) * 0.3;
                node.x += dx;
                node.y += dy;
            }
            moves += 5; // Penalty for hint
            updateStats();
        });

        document.getElementById('shuffle').addEventListener('click', () => {
            shuffleNodes();
            moves = 0;
            startTime = Date.now();
            updateStats();
        });

        document.getElementById('nextLevel').addEventListener('click', () => {
            document.getElementById('victory').style.display = 'none';
            level++;
            const diffSelect = document.getElementById('difficulty');
            const newDiff = Math.min(4, Math.ceil(level / 3));
            diffSelect.value = newDiff;
            const settings = difficulties[newDiff];
            generatePlanarGraph(
                settings.nodes + Math.floor(level / 4),
                settings.edges + Math.floor(level / 2)
            );
        });

        // Initialize
        const initialDiff = difficulties[2];
        generatePlanarGraph(initialDiff.nodes, initialDiff.edges);
        draw();
    </script>
</body>
</html>
