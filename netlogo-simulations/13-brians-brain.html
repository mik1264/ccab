<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brian's Brain - Three-State Cellular Automaton</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #9b59b6;
            text-decoration: none;
            z-index: 100;
        }
        header { text-align: center; padding: 15px; }
        h1 { color: #9b59b6; font-size: 1.6rem; }
        .container {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 15px;
            padding: 0 15px 15px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .main-area { display: flex; flex-direction: column; gap: 15px; }
        .canvas-wrapper {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
        }
        #canvas {
            width: 100%;
            aspect-ratio: 1;
            max-height: 550px;
            background: #0a0a15;
            border-radius: 8px;
            cursor: crosshair;
        }
        .sidebar {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
        }
        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: block;
            color: #9b59b6;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 5px;
            background: #333;
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #9b59b6;
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #888;
            margin-top: 4px;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: #9b59b6;
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { background: #8e44ad; }
        button.secondary { background: #333; }
        .stats {
            background: rgba(155, 89, 182, 0.1);
            border: 1px solid rgba(155, 89, 182, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 0.8rem;
        }
        .stat-label { color: #888; }
        .stat-value { color: #9b59b6; font-family: monospace; }
        .legend {
            margin-top: 12px;
            padding: 10px;
            background: rgba(155, 89, 182, 0.1);
            border-radius: 6px;
        }
        .legend h4 { color: #9b59b6; margin-bottom: 8px; font-size: 0.85rem; }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 0.8rem;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        .info {
            margin-top: 12px;
            padding: 10px;
            background: rgba(155, 89, 182, 0.1);
            border-radius: 6px;
            font-size: 0.75rem;
            line-height: 1.4;
        }
        .info h4 { color: #9b59b6; margin-bottom: 6px; }
        .patterns {
            margin-top: 12px;
        }
        .patterns h4 { color: #9b59b6; margin-bottom: 8px; font-size: 0.85rem; }
        .pattern-btn {
            padding: 6px 10px;
            margin: 2px;
            font-size: 0.75rem;
            background: #333;
        }
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>

    <header>
        <h1>Brian's Brain</h1>
        <p style="color: #888; font-size: 0.9rem;">Three-State Cellular Automaton</p>
    </header>

    <div class="container">
        <div class="main-area">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <label>Simulation Speed</label>
                <input type="range" id="speed" min="1" max="60" value="15">
                <div class="value-display"><span id="speedVal">15</span> fps</div>
            </div>

            <div class="control-group">
                <label>Grid Size</label>
                <input type="range" id="gridSize" min="50" max="200" value="100">
                <div class="value-display"><span id="gridVal">100</span> x <span id="gridVal2">100</span></div>
            </div>

            <button id="startBtn">Start</button>
            <button id="stepBtn" class="secondary">Step</button>
            <button id="clearBtn" class="secondary">Clear</button>
            <button id="randomBtn" class="secondary">Random Fill</button>

            <div class="patterns">
                <h4>Patterns</h4>
                <button class="pattern-btn" data-pattern="glider">Glider</button>
                <button class="pattern-btn" data-pattern="gun">Glider Gun</button>
                <button class="pattern-btn" data-pattern="oscillator">Oscillator</button>
            </div>

            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Generation:</span>
                    <span class="stat-value" id="genStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Firing (On):</span>
                    <span class="stat-value" id="onStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Dying:</span>
                    <span class="stat-value" id="dyingStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Off:</span>
                    <span class="stat-value" id="offStat">0</span>
                </div>
            </div>

            <div class="legend">
                <h4>Cell States</h4>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>Firing (On) - Active neuron</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>Dying - Refractory period</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #1a1a2e;"></div>
                    <span>Off - Ready to fire</span>
                </div>
            </div>

            <div class="info">
                <h4>Rules</h4>
                <p><strong>Off → On:</strong> Exactly 2 neighbors are On</p>
                <p><strong>On → Dying:</strong> Always</p>
                <p><strong>Dying → Off:</strong> Always</p>
                <p style="margin-top:8px">Click/drag to draw firing cells. Creates characteristic glider patterns.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // States
        const OFF = 0;
        const ON = 1;
        const DYING = 2;

        let gridSize = 100;
        let cellSize;
        let grid, nextGrid;
        let running = false;
        let generation = 0;
        let speed = 15;
        let lastTime = 0;

        function resize() {
            const size = Math.min(canvas.parentElement.clientWidth - 30, 550);
            canvas.width = size;
            canvas.height = size;
            cellSize = size / gridSize;
            render();
        }

        function initGrid() {
            grid = new Uint8Array(gridSize * gridSize);
            nextGrid = new Uint8Array(gridSize * gridSize);
            generation = 0;
        }

        function getIndex(x, y) {
            return ((y + gridSize) % gridSize) * gridSize + ((x + gridSize) % gridSize);
        }

        function countOnNeighbors(x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    if (grid[getIndex(x + dx, y + dy)] === ON) count++;
                }
            }
            return count;
        }

        function step() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = getIndex(x, y);
                    const state = grid[idx];

                    if (state === OFF) {
                        // Off cell turns on if exactly 2 neighbors are on
                        nextGrid[idx] = countOnNeighbors(x, y) === 2 ? ON : OFF;
                    } else if (state === ON) {
                        // On cell becomes dying
                        nextGrid[idx] = DYING;
                    } else {
                        // Dying cell becomes off
                        nextGrid[idx] = OFF;
                    }
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];
            generation++;
            updateStats();
        }

        function updateStats() {
            let onCount = 0, dyingCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] === ON) onCount++;
                else if (grid[i] === DYING) dyingCount++;
            }
            document.getElementById('genStat').textContent = generation;
            document.getElementById('onStat').textContent = onCount;
            document.getElementById('dyingStat').textContent = dyingCount;
            document.getElementById('offStat').textContent = gridSize * gridSize - onCount - dyingCount;
        }

        function render() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const state = grid[getIndex(x, y)];
                    if (state === ON) {
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize - 0.5, cellSize - 0.5);
                    } else if (state === DYING) {
                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize - 0.5, cellSize - 0.5);
                    }
                }
            }
        }

        function animate(time) {
            if (running && time - lastTime > 1000 / speed) {
                step();
                render();
                lastTime = time;
            }
            requestAnimationFrame(animate);
        }

        function randomFill() {
            for (let i = 0; i < grid.length; i++) {
                grid[i] = Math.random() < 0.1 ? ON : OFF;
            }
            generation = 0;
            updateStats();
            render();
        }

        // Pattern definitions
        const patterns = {
            glider: [
                [0, 1], [1, 0], [1, 1], [1, 2], [2, 1]
            ],
            gun: [
                // A simple glider-generating pattern
                [0, 0], [0, 1], [1, 0], [1, 1],
                [4, 0], [4, 1], [4, 2], [5, -1], [5, 3],
                [6, -2], [6, 4], [7, -2], [7, 4],
                [8, 1], [9, -1], [9, 3], [10, 0], [10, 1], [10, 2],
                [11, 1]
            ],
            oscillator: [
                [0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]
            ]
        };

        function placePattern(name) {
            const pattern = patterns[name];
            if (!pattern) return;

            const cx = Math.floor(gridSize / 2);
            const cy = Math.floor(gridSize / 2);

            pattern.forEach(([dx, dy]) => {
                const idx = getIndex(cx + dx, cy + dy);
                grid[idx] = ON;
            });

            render();
            updateStats();
        }

        // Mouse drawing
        let isDrawing = false;

        function getCellPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);
            return { x, y };
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const { x, y } = getCellPos(e);
            grid[getIndex(x, y)] = ON;
            render();
            updateStats();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const { x, y } = getCellPos(e);
            grid[getIndex(x, y)] = ON;
            render();
            updateStats();
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // Controls
        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedVal').textContent = speed;
        });

        document.getElementById('gridSize').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('gridVal').textContent = gridSize;
            document.getElementById('gridVal2').textContent = gridSize;
            initGrid();
            resize();
            updateStats();
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            step();
            render();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            initGrid();
            render();
            updateStats();
        });

        document.getElementById('randomBtn').addEventListener('click', randomFill);

        document.querySelectorAll('.pattern-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                placePattern(btn.dataset.pattern);
            });
        });

        // Initialize
        window.addEventListener('resize', resize);
        initGrid();
        resize();
        randomFill();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
