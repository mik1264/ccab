<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Population Two Region Model - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; display: flex; flex-direction: column; }
        #main-canvas { flex: 1; }
        #graph-canvas { height: 150px; border-top: 1px solid #333; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #f59e0b; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #f59e0b; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #d97706; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f59e0b; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .region-stats { display: flex; gap: 10px; margin-bottom: 15px; }
        .region-box { flex: 1; padding: 10px; border-radius: 8px; text-align: center; }
        .region-a { background: rgba(59, 130, 246, 0.2); border: 1px solid #3b82f6; }
        .region-b { background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; }
        .region-pop { font-size: 1.5rem; font-weight: bold; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <canvas id="graph-canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Two Region Population</h1>
            <p class="description">Two-region population model with migration flows. Analyze equilibrium conditions and migration pressure dynamics between regions with different carrying capacities.</p>
            <div class="region-stats">
                <div class="region-box region-a">
                    <div>Region A</div>
                    <div class="region-pop" id="popA">0</div>
                </div>
                <div class="region-box region-b">
                    <div>Region B</div>
                    <div class="region-pop" id="popB">0</div>
                </div>
            </div>
            <div class="control-group">
                <label>Region A Capacity: <span id="capAValue">500</span></label>
                <input type="range" id="capA" min="100" max="1000" value="500">
            </div>
            <div class="control-group">
                <label>Region B Capacity: <span id="capBValue">500</span></label>
                <input type="range" id="capB" min="100" max="1000" value="500">
            </div>
            <div class="control-group">
                <label>Birth Rate: <span id="birthValue">0.03</span></label>
                <input type="range" id="birth" min="0.01" max="0.1" step="0.01" value="0.03">
            </div>
            <div class="control-group">
                <label>Migration Rate: <span id="migrationValue">0.02</span></label>
                <input type="range" id="migration" min="0" max="0.1" step="0.005" value="0.02">
            </div>
            <div class="control-group">
                <label>Migration Sensitivity: <span id="sensitivityValue">2</span></label>
                <input type="range" id="sensitivity" min="0.5" max="5" step="0.5" value="2">
            </div>
            <button id="reset">Reset Simulation</button>
            <button id="disaster">Disaster in Region A</button>
            <button id="boom">Boom in Region B</button>
            <div class="stats">
                <div>Year: <span id="year">0</span></div>
                <div>Total Population: <span id="totalPop">0</span></div>
                <div>Migration A→B: <span id="migAB">0</span>/yr</div>
                <div>Migration B→A: <span id="migBA">0</span>/yr</div>
                <div>Net Flow: <span id="netFlow">0</span>/yr</div>
            </div>
        </div>
    </div>
    <script>
        const mainCanvas = document.getElementById('main-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');

        let width, height;
        let agents = [];
        let year = 0;
        let historyA = [], historyB = [];
        const maxHistory = 300;

        let stats = { migAB: 0, migBA: 0 };

        let params = {
            capA: 500, capB: 500,
            birth: 0.03, migration: 0.02, sensitivity: 2
        };

        function resize() {
            mainCanvas.width = mainCanvas.clientWidth;
            mainCanvas.height = mainCanvas.clientHeight;
            graphCanvas.width = graphCanvas.clientWidth;
            graphCanvas.height = graphCanvas.clientHeight;
            width = mainCanvas.width;
            height = mainCanvas.height;
        }

        function createAgent(region) {
            const halfWidth = width / 2;
            return {
                region: region,
                x: region === 'A' ?
                    50 + Math.random() * (halfWidth - 100) :
                    halfWidth + 50 + Math.random() * (halfWidth - 100),
                y: 50 + Math.random() * (height - 100),
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                age: Math.random() * 50
            };
        }

        function init() {
            resize();
            agents = [];
            year = 0;
            historyA = [];
            historyB = [];
            stats = { migAB: 0, migBA: 0 };

            // Initial populations
            for (let i = 0; i < 100; i++) {
                agents.push(createAgent('A'));
                agents.push(createAgent('B'));
            }
        }

        function countRegion(r) {
            return agents.filter(a => a.region === r).length;
        }

        function getDensity(region) {
            const pop = countRegion(region);
            const cap = region === 'A' ? params.capA : params.capB;
            return pop / cap;
        }

        function update() {
            year++;
            stats.migAB = 0;
            stats.migBA = 0;

            const halfWidth = width / 2;
            const popA = countRegion('A');
            const popB = countRegion('B');
            const densityA = popA / params.capA;
            const densityB = popB / params.capB;

            // Update each agent
            for (let i = agents.length - 1; i >= 0; i--) {
                const agent = agents[i];

                // Movement
                agent.vx += (Math.random() - 0.5) * 0.5;
                agent.vy += (Math.random() - 0.5) * 0.5;
                agent.vx *= 0.95;
                agent.vy *= 0.95;
                agent.x += agent.vx;
                agent.y += agent.vy;

                // Boundaries
                const minX = agent.region === 'A' ? 10 : halfWidth + 10;
                const maxX = agent.region === 'A' ? halfWidth - 10 : width - 10;

                if (agent.x < minX) { agent.x = minX; agent.vx *= -1; }
                if (agent.x > maxX) { agent.x = maxX; agent.vx *= -1; }
                if (agent.y < 10) { agent.y = 10; agent.vy *= -1; }
                if (agent.y > height - 10) { agent.y = height - 10; agent.vy *= -1; }

                agent.age += 0.02;

                // Death (density-dependent + age)
                const density = agent.region === 'A' ? densityA : densityB;
                const deathProb = 0.001 + density * 0.01 + (agent.age > 70 ? 0.05 : 0);
                if (Math.random() < deathProb) {
                    agents.splice(i, 1);
                    continue;
                }

                // Birth (density-dependent)
                const birthProb = params.birth * (1 - density * 0.8);
                if (birthProb > 0 && Math.random() < birthProb && agent.age > 15 && agent.age < 45) {
                    const child = createAgent(agent.region);
                    child.x = agent.x + (Math.random() - 0.5) * 20;
                    child.y = agent.y + (Math.random() - 0.5) * 20;
                    child.age = 0;
                    agents.push(child);
                }

                // Migration decision
                if (params.migration > 0 && Math.random() < params.migration) {
                    const myDensity = agent.region === 'A' ? densityA : densityB;
                    const otherDensity = agent.region === 'A' ? densityB : densityA;

                    // Migrate if other region is less crowded
                    const migrationPressure = (myDensity - otherDensity) * params.sensitivity;
                    if (migrationPressure > 0 && Math.random() < migrationPressure) {
                        if (agent.region === 'A') {
                            agent.region = 'B';
                            agent.x = halfWidth + 50 + Math.random() * (halfWidth - 100);
                            stats.migAB++;
                        } else {
                            agent.region = 'A';
                            agent.x = 50 + Math.random() * (halfWidth - 100);
                            stats.migBA++;
                        }
                    }
                }
            }

            // Record history
            historyA.push(countRegion('A'));
            historyB.push(countRegion('B'));
            if (historyA.length > maxHistory) historyA.shift();
            if (historyB.length > maxHistory) historyB.shift();
        }

        function draw() {
            const halfWidth = width / 2;

            // Region backgrounds
            mainCtx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            mainCtx.fillRect(0, 0, halfWidth, height);
            mainCtx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            mainCtx.fillRect(halfWidth, 0, halfWidth, height);

            // Divider
            mainCtx.strokeStyle = '#444';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([10, 10]);
            mainCtx.beginPath();
            mainCtx.moveTo(halfWidth, 0);
            mainCtx.lineTo(halfWidth, height);
            mainCtx.stroke();
            mainCtx.setLineDash([]);

            // Carrying capacity indicators
            const capHeightA = (params.capA / 1000) * height * 0.8;
            const capHeightB = (params.capB / 1000) * height * 0.8;

            mainCtx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            mainCtx.fillRect(20, height - capHeightA - 20, 30, capHeightA);
            mainCtx.strokeStyle = '#3b82f6';
            mainCtx.strokeRect(20, height - capHeightA - 20, 30, capHeightA);

            mainCtx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            mainCtx.fillRect(width - 50, height - capHeightB - 20, 30, capHeightB);
            mainCtx.strokeStyle = '#ef4444';
            mainCtx.strokeRect(width - 50, height - capHeightB - 20, 30, capHeightB);

            // Draw agents
            for (let agent of agents) {
                mainCtx.fillStyle = agent.region === 'A' ? '#3b82f6' : '#ef4444';
                mainCtx.beginPath();
                mainCtx.arc(agent.x, agent.y, 3, 0, Math.PI * 2);
                mainCtx.fill();
            }

            // Labels
            mainCtx.font = 'bold 24px sans-serif';
            mainCtx.fillStyle = '#3b82f6';
            mainCtx.textAlign = 'center';
            mainCtx.fillText('Region A', halfWidth / 2, 40);
            mainCtx.fillStyle = '#ef4444';
            mainCtx.fillText('Region B', halfWidth + halfWidth / 2, 40);

            // Draw graph
            graphCtx.fillStyle = '#1a1a2e';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (historyA.length > 1) {
                const maxPop = Math.max(...historyA, ...historyB, params.capA, params.capB);

                // Carrying capacity lines
                graphCtx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
                graphCtx.setLineDash([5, 5]);
                graphCtx.beginPath();
                const capYA = graphCanvas.height - (params.capA / maxPop) * graphCanvas.height * 0.9;
                graphCtx.moveTo(0, capYA);
                graphCtx.lineTo(graphCanvas.width, capYA);
                graphCtx.stroke();

                graphCtx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                graphCtx.beginPath();
                const capYB = graphCanvas.height - (params.capB / maxPop) * graphCanvas.height * 0.9;
                graphCtx.moveTo(0, capYB);
                graphCtx.lineTo(graphCanvas.width, capYB);
                graphCtx.stroke();
                graphCtx.setLineDash([]);

                // Population lines
                graphCtx.strokeStyle = '#3b82f6';
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();
                for (let i = 0; i < historyA.length; i++) {
                    const x = (i / maxHistory) * graphCanvas.width;
                    const y = graphCanvas.height - (historyA[i] / maxPop) * graphCanvas.height * 0.9;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();

                graphCtx.strokeStyle = '#ef4444';
                graphCtx.beginPath();
                for (let i = 0; i < historyB.length; i++) {
                    const x = (i / maxHistory) * graphCanvas.width;
                    const y = graphCanvas.height - (historyB[i] / maxPop) * graphCanvas.height * 0.9;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            }

            graphCtx.fillStyle = '#aaa';
            graphCtx.font = '10px sans-serif';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('Population over time (dashed = carrying capacity)', 10, 15);

            // Update stats
            const popA = countRegion('A');
            const popB = countRegion('B');
            document.getElementById('popA').textContent = popA;
            document.getElementById('popB').textContent = popB;
            document.getElementById('year').textContent = year;
            document.getElementById('totalPop').textContent = popA + popB;
            document.getElementById('migAB').textContent = stats.migAB;
            document.getElementById('migBA').textContent = stats.migBA;
            document.getElementById('netFlow').textContent = stats.migAB - stats.migBA;
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('capA').addEventListener('input', e => {
            params.capA = parseInt(e.target.value);
            document.getElementById('capAValue').textContent = params.capA;
        });
        document.getElementById('capB').addEventListener('input', e => {
            params.capB = parseInt(e.target.value);
            document.getElementById('capBValue').textContent = params.capB;
        });
        document.getElementById('birth').addEventListener('input', e => {
            params.birth = parseFloat(e.target.value);
            document.getElementById('birthValue').textContent = params.birth.toFixed(2);
        });
        document.getElementById('migration').addEventListener('input', e => {
            params.migration = parseFloat(e.target.value);
            document.getElementById('migrationValue').textContent = params.migration.toFixed(3);
        });
        document.getElementById('sensitivity').addEventListener('input', e => {
            params.sensitivity = parseFloat(e.target.value);
            document.getElementById('sensitivityValue').textContent = params.sensitivity;
        });

        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('disaster').addEventListener('click', () => {
            // Kill half of region A
            const toRemove = agents.filter(a => a.region === 'A').slice(0, Math.floor(countRegion('A') / 2));
            for (let a of toRemove) {
                const idx = agents.indexOf(a);
                if (idx > -1) agents.splice(idx, 1);
            }
        });
        document.getElementById('boom').addEventListener('click', () => {
            // Double region B capacity temporarily
            for (let i = 0; i < 50; i++) {
                agents.push(createAgent('B'));
            }
        });

        window.addEventListener('resize', resize);
        init();
        animate();
    </script>
</body>
</html>
