<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Hunt Camouflage - Evolution - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0c1222; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; cursor: crosshair; }
        #simCanvas { width: 100%; height: 100%; }
        #controls { width: 280px; background: rgba(0,0,0,0.9); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.1rem; margin-bottom: 15px; color: #84cc16; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 3px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 8px; margin-bottom: 8px; background: #65a30d; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.85rem; }
        button:hover { background: #4d7c0f; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; margin-bottom: 15px; }
        .stats div { margin-bottom: 3px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #84cc16; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.7rem; color: #888; margin-bottom: 12px; line-height: 1.4; }
        .score-display { font-size: 1.4rem; text-align: center; padding: 10px; background: rgba(132, 204, 22, 0.2); border-radius: 5px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
        <div id="controls">
            <h1>Bug Hunt Camouflage</h1>
            <p class="description">Click on bugs to "eat" them! Bugs that blend in survive longer and reproduce. Watch camouflage evolve.</p>
            
            <div class="score-display">
                Bugs Caught: <span id="caught">0</span>
            </div>
            
            <div class="control-group">
                <label>Bug Population: <span id="popVal">30</span></label>
                <input type="range" id="pop" min="10" max="60" value="30">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationVal">0.1</span></label>
                <input type="range" id="mutation" min="0" max="0.3" step="0.02" value="0.1">
            </div>
            <div class="control-group">
                <label>Background Complexity: <span id="complexVal">3</span></label>
                <input type="range" id="complex" min="1" max="6" value="3">
            </div>
            
            <button id="reset">New Environment</button>
            <button id="changeBackground">Change Background</button>
            <button id="showBugs">Flash Bugs (Cheat)</button>
            
            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Alive: <span id="alive">0</span></div>
                <div>Avg Camo Score: <span id="camoScore">0</span>%</div>
                <div>Dominant Color: <span id="dominantColor">-</span></div>
            </div>
            
            <p class="description"><strong>Selection:</strong> You are the predator! Conspicuous bugs get eaten. Well-camouflaged bugs survive to reproduce.</p>
            
            <p class="description"><strong>Evolution:</strong> Each caught bug is replaced by offspring of a survivor (with mutation).</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        let W, H, bugs = [], background = [];
        let bugsCaught = 0;
        let generation = 0;
        let showingBugs = false;
        
        let params = {
            population: 30,
            mutationRate: 0.1,
            complexity: 3
        };
        
        function resize() {
            const c = document.getElementById('canvas-container');
            canvas.width = c.clientWidth;
            canvas.height = c.clientHeight;
            W = canvas.width;
            H = canvas.height;
        }
        
        function generateBackground() {
            background = [];
            const patchSize = 50 + Math.random() * 50;
            
            // Generate base colors for patches
            const baseHue = Math.random() * 360;
            
            for (let y = 0; y < H; y += patchSize) {
                for (let x = 0; x < W; x += patchSize) {
                    const hue = (baseHue + (Math.random() - 0.5) * 60 + 360) % 360;
                    const sat = 20 + Math.random() * 40;
                    const light = 30 + Math.random() * 30;
                    
                    background.push({
                        x, y,
                        w: patchSize + Math.random() * 20,
                        h: patchSize + Math.random() * 20,
                        color: { h: hue, s: sat, l: light }
                    });
                }
            }
            
            // Add noise patterns based on complexity
            for (let i = 0; i < params.complexity * 50; i++) {
                const x = Math.random() * W;
                const y = Math.random() * H;
                const size = 10 + Math.random() * 40;
                const hue = (baseHue + (Math.random() - 0.5) * 80 + 360) % 360;
                const sat = 15 + Math.random() * 50;
                const light = 25 + Math.random() * 40;
                
                background.push({
                    x: x - size/2, y: y - size/2,
                    w: size, h: size,
                    color: { h: hue, s: sat, l: light }
                });
            }
        }
        
        function getBackgroundColorAt(x, y) {
            // Sample background color at position
            let h = 0, s = 0, l = 0, count = 0;
            
            for (const patch of background) {
                if (x >= patch.x && x < patch.x + patch.w &&
                    y >= patch.y && y < patch.y + patch.h) {
                    h += patch.color.h;
                    s += patch.color.s;
                    l += patch.color.l;
                    count++;
                }
            }
            
            if (count === 0) return { h: 120, s: 30, l: 40 };
            return { h: h/count, s: s/count, l: l/count };
        }
        
        function colorDistance(c1, c2) {
            // Simple color distance in HSL space
            const hDiff = Math.min(Math.abs(c1.h - c2.h), 360 - Math.abs(c1.h - c2.h)) / 180;
            const sDiff = Math.abs(c1.s - c2.s) / 100;
            const lDiff = Math.abs(c1.l - c2.l) / 100;
            return Math.sqrt(hDiff * hDiff + sDiff * sDiff + lDiff * lDiff);
        }
        
        function mutateColor(color) {
            if (Math.random() > params.mutationRate) return { ...color };
            
            return {
                h: (color.h + (Math.random() - 0.5) * 40 + 360) % 360,
                s: Math.max(10, Math.min(80, color.s + (Math.random() - 0.5) * 20)),
                l: Math.max(20, Math.min(70, color.l + (Math.random() - 0.5) * 20))
            };
        }
        
        function createBug(parent = null) {
            let color;
            if (parent) {
                color = mutateColor(parent.color);
            } else {
                color = {
                    h: Math.random() * 360,
                    s: 20 + Math.random() * 60,
                    l: 30 + Math.random() * 40
                };
            }
            
            return {
                x: 30 + Math.random() * (W - 60),
                y: 30 + Math.random() * (H - 60),
                color: color,
                size: 12 + Math.random() * 6
            };
        }
        
        function init() {
            resize();
            bugs = [];
            bugsCaught = 0;
            generation = 0;
            
            generateBackground();
            
            for (let i = 0; i < params.population; i++) {
                bugs.push(createBug());
            }
            
            updateStats();
        }
        
        function getCamouflageScore(bug) {
            const bgColor = getBackgroundColorAt(bug.x, bug.y);
            const distance = colorDistance(bug.color, bgColor);
            return Math.max(0, 1 - distance) * 100;
        }
        
        function updateStats() {
            let totalCamo = 0;
            const colorCounts = {};
            
            for (const bug of bugs) {
                totalCamo += getCamouflageScore(bug);
                
                const hueKey = Math.floor(bug.color.h / 30) * 30;
                colorCounts[hueKey] = (colorCounts[hueKey] || 0) + 1;
            }
            
            const avgCamo = bugs.length > 0 ? totalCamo / bugs.length : 0;
            
            // Find dominant hue
            let dominantHue = 0;
            let maxCount = 0;
            for (const [hue, count] of Object.entries(colorCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    dominantHue = +hue;
                }
            }
            
            document.getElementById('caught').textContent = bugsCaught;
            document.getElementById('generation').textContent = generation;
            document.getElementById('alive').textContent = bugs.length;
            document.getElementById('camoScore').textContent = avgCamo.toFixed(1);
            document.getElementById('dominantColor').innerHTML = 
                `<span style="color: hsl(${dominantHue}, 60%, 50%)">■</span> ${Math.round(dominantHue)}°`;
        }
        
        function catchBug(x, y) {
            // Find clicked bug
            for (let i = bugs.length - 1; i >= 0; i--) {
                const bug = bugs[i];
                const dx = x - bug.x;
                const dy = y - bug.y;
                if (dx * dx + dy * dy < bug.size * bug.size) {
                    // Bug caught!
                    bugs.splice(i, 1);
                    bugsCaught++;
                    generation++;
                    
                    // Replace with offspring of random survivor
                    if (bugs.length > 0) {
                        const parent = bugs[Math.floor(Math.random() * bugs.length)];
                        bugs.push(createBug(parent));
                    } else {
                        bugs.push(createBug());
                    }
                    
                    updateStats();
                    return true;
                }
            }
            return false;
        }
        
        function draw() {
            // Draw background
            ctx.fillStyle = '#3d5a3d';
            ctx.fillRect(0, 0, W, H);
            
            for (const patch of background) {
                ctx.fillStyle = `hsl(${patch.color.h}, ${patch.color.s}%, ${patch.color.l}%)`;
                ctx.fillRect(patch.x, patch.y, patch.w, patch.h);
            }
            
            // Draw bugs
            for (const bug of bugs) {
                const { h, s, l } = bug.color;
                
                if (showingBugs) {
                    // Highlight mode
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(bug.x, bug.y, bug.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Bug body
                ctx.fillStyle = `hsl(${h}, ${s}%, ${l}%)`;
                ctx.beginPath();
                ctx.ellipse(bug.x, bug.y, bug.size, bug.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Bug spots (pattern)
                ctx.fillStyle = `hsl(${h}, ${s}%, ${l - 10}%)`;
                const spotSize = bug.size * 0.2;
                ctx.beginPath();
                ctx.arc(bug.x - bug.size * 0.3, bug.y - bug.size * 0.2, spotSize, 0, Math.PI * 2);
                ctx.arc(bug.x + bug.size * 0.3, bug.y - bug.size * 0.2, spotSize, 0, Math.PI * 2);
                ctx.arc(bug.x, bug.y + bug.size * 0.2, spotSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Bug head
                ctx.fillStyle = `hsl(${h}, ${s}%, ${l - 15}%)`;
                ctx.beginPath();
                ctx.arc(bug.x, bug.y - bug.size * 0.6, bug.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Instructions
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(W - 200, 10, 190, 30);
            ctx.fillStyle = '#84cc16';
            ctx.font = '12px sans-serif';
            ctx.fillText('Click on bugs to catch them!', W - 190, 30);
            
            requestAnimationFrame(draw);
        }
        
        // Event listeners
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            catchBug(x, y);
        });
        
        document.getElementById('pop').addEventListener('input', e => {
            params.population = +e.target.value;
            document.getElementById('popVal').textContent = params.population;
        });
        document.getElementById('mutation').addEventListener('input', e => {
            params.mutationRate = +e.target.value;
            document.getElementById('mutationVal').textContent = params.mutationRate.toFixed(2);
        });
        document.getElementById('complex').addEventListener('input', e => {
            params.complexity = +e.target.value;
            document.getElementById('complexVal').textContent = params.complexity;
        });
        
        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('changeBackground').addEventListener('click', () => {
            generateBackground();
        });
        document.getElementById('showBugs').addEventListener('click', () => {
            showingBugs = true;
            setTimeout(() => { showingBugs = false; }, 1000);
        });
        
        window.addEventListener('resize', () => {
            resize();
            generateBackground();
        });
        
        init();
        draw();
    </script>
</body>
</html>
