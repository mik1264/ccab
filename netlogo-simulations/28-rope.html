<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rope Physics Simulation - CCAB</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container { display: flex; height: 100vh; }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas { border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #fdcb6e; }
        h3 { margin: 15px 0 8px 0; color: #ffeaa7; font-size: 14px; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 13px; }
        input[type="range"] { width: 100%; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #fdcb6e;
            color: #1a1a2e;
            font-weight: bold;
        }
        button:hover { background: #f39c12; }
        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
        }
        select option { background: #1a1a2e; }
        .hint {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600;">
        <span>‚Üê Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="ropeCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>ü™¢ Rope Physics</h2>
            <p style="font-size: 12px; opacity: 0.8;">Wave propagation & tension simulation</p>

            <div class="hint">
                Click and drag to disturb the rope
            </div>

            <h3>Preset</h3>
            <select id="preset">
                <option value="hanging">Hanging Rope</option>
                <option value="horizontal">Horizontal String</option>
                <option value="fixed">Fixed Both Ends</option>
                <option value="pendulum">Rope Pendulum</option>
            </select>

            <h3>Segments</h3>
            <div class="slider-group">
                <label>Count: <span id="segmentsVal">40</span></label>
                <input type="range" id="segments" min="10" max="80" step="5" value="40">
            </div>

            <h3>Stiffness</h3>
            <div class="slider-group">
                <label>k: <span id="stiffnessVal">500</span></label>
                <input type="range" id="stiffness" min="100" max="2000" step="100" value="500">
            </div>

            <h3>Damping</h3>
            <div class="slider-group">
                <label>Factor: <span id="dampingVal">0.98</span></label>
                <input type="range" id="damping" min="0.9" max="1.0" step="0.01" value="0.98">
            </div>

            <h3>Gravity</h3>
            <div class="slider-group">
                <label>g: <span id="gravityVal">0.5</span></label>
                <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
            </div>

            <button onclick="reset()">Reset</button>
            <button onclick="pulse()">Send Pulse</button>
            <button onclick="shake()">Shake</button>

            <div class="stats">
                <div class="stat-row"><span>Segments:</span><span id="segmentsStat">40</span></div>
                <div class="stat-row"><span>Total Energy:</span><span id="energy">0</span></div>
                <div class="stat-row"><span>Max Tension:</span><span id="tension">0</span></div>
                <div class="stat-row"><span>Wave Speed:</span><span id="waveSpeed">0</span></div>
            </div>

            <div class="description">
                <strong>Physics:</strong><br>
                Each segment is a mass connected by springs (Hooke's Law).<br><br>
                <strong>Wave Speed:</strong><br>
                v = ‚àö(T/Œº) where T is tension, Œº is linear density<br><br>
                <strong>Key Phenomena:</strong><br>
                ‚Ä¢ Standing waves with fixed ends<br>
                ‚Ä¢ Reflection at boundaries<br>
                ‚Ä¢ Energy transfer through tension<br>
                ‚Ä¢ Damping dissipates energy
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('ropeCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 700;
        canvas.height = 500;

        let segments = 40;
        let stiffness = 500;
        let damping = 0.98;
        let gravity = 0.5;
        let preset = 'hanging';

        let points = [];
        let restLength = 0;
        let dragging = false;
        let dragIndex = -1;

        class Point {
            constructor(x, y, fixed = false) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.vx = 0;
                this.vy = 0;
                this.fixed = fixed;
                this.mass = 1;
            }
        }

        function initRope() {
            points = [];
            const padding = 100;

            switch (preset) {
                case 'hanging':
                    // Fixed at top-left, hanging
                    restLength = (canvas.width - 2 * padding) / segments * 0.8;
                    for (let i = 0; i <= segments; i++) {
                        const x = padding + i * restLength * 0.5;
                        const y = 100 + i * restLength * 0.3;
                        points.push(new Point(x, y, i === 0));
                    }
                    break;

                case 'horizontal':
                    // Fixed at left, horizontal
                    restLength = (canvas.width - 2 * padding) / segments;
                    for (let i = 0; i <= segments; i++) {
                        const x = padding + i * restLength;
                        const y = canvas.height / 2;
                        points.push(new Point(x, y, i === 0));
                    }
                    break;

                case 'fixed':
                    // Fixed both ends
                    restLength = (canvas.width - 2 * padding) / segments;
                    for (let i = 0; i <= segments; i++) {
                        const x = padding + i * restLength;
                        const y = canvas.height / 2;
                        points.push(new Point(x, y, i === 0 || i === segments));
                    }
                    break;

                case 'pendulum':
                    // Fixed at top center, vertical
                    restLength = (canvas.height - 150) / segments;
                    for (let i = 0; i <= segments; i++) {
                        const x = canvas.width / 2;
                        const y = 50 + i * restLength;
                        points.push(new Point(x, y, i === 0));
                    }
                    break;
            }
        }

        function reset() {
            segments = parseInt(document.getElementById('segments').value);
            stiffness = parseInt(document.getElementById('stiffness').value);
            damping = parseFloat(document.getElementById('damping').value);
            gravity = parseFloat(document.getElementById('gravity').value);
            preset = document.getElementById('preset').value;

            initRope();
        }

        function pulse() {
            // Send a pulse from the fixed end
            const pulseIndex = points.findIndex(p => p.fixed);
            const nextIndex = pulseIndex === 0 ? 1 : points.length - 2;

            if (nextIndex >= 0 && nextIndex < points.length) {
                const perpX = 0;
                const perpY = -50;
                points[nextIndex].vy += perpY * 0.3;
                points[nextIndex].vx += perpX * 0.3;
            }
        }

        function shake() {
            for (let i = 0; i < points.length; i++) {
                if (!points[i].fixed) {
                    points[i].vx += (Math.random() - 0.5) * 20;
                    points[i].vy += (Math.random() - 0.5) * 20;
                }
            }
        }

        function update() {
            const dt = 0.016; // ~60fps
            const iterations = 5;

            for (let iter = 0; iter < iterations; iter++) {
                // Apply gravity
                for (const p of points) {
                    if (!p.fixed) {
                        p.vy += gravity;
                    }
                }

                // Constraint solving (distance constraints)
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist === 0) continue;

                    const diff = (dist - restLength) / dist;

                    // Spring force
                    const fx = dx * diff * 0.5;
                    const fy = dy * diff * 0.5;

                    if (!p1.fixed) {
                        p1.x += fx;
                        p1.y += fy;
                    }
                    if (!p2.fixed) {
                        p2.x -= fx;
                        p2.y -= fy;
                    }
                }
            }

            // Verlet integration with damping
            for (const p of points) {
                if (!p.fixed) {
                    const vx = (p.x - p.oldX) * damping;
                    const vy = (p.y - p.oldY) * damping;

                    p.oldX = p.x;
                    p.oldY = p.y;

                    p.x += vx;
                    p.y += vy;

                    p.vx = vx;
                    p.vy = vy;

                    // Boundary constraints
                    if (p.y > canvas.height - 20) {
                        p.y = canvas.height - 20;
                        p.vy *= -0.5;
                    }
                    if (p.x < 20) p.x = 20;
                    if (p.x > canvas.width - 20) p.x = canvas.width - 20;
                }
            }

            updateStats();
        }

        function updateStats() {
            // Calculate energy
            let kineticEnergy = 0;
            let potentialEnergy = 0;
            let maxTension = 0;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                kineticEnergy += 0.5 * p.mass * (p.vx * p.vx + p.vy * p.vy);
                potentialEnergy += p.mass * gravity * (canvas.height - p.y);

                // Calculate tension in each segment
                if (i < points.length - 1) {
                    const p2 = points[i + 1];
                    const dx = p2.x - p.x;
                    const dy = p2.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const tension = Math.abs(dist - restLength) * stiffness;
                    maxTension = Math.max(maxTension, tension);
                }
            }

            const totalEnergy = kineticEnergy + potentialEnergy;
            const waveSpeed = Math.sqrt(stiffness / 1);

            document.getElementById('segmentsStat').textContent = segments;
            document.getElementById('energy').textContent = totalEnergy.toFixed(1);
            document.getElementById('tension').textContent = maxTension.toFixed(1);
            document.getElementById('waveSpeed').textContent = waveSpeed.toFixed(1);
        }

        function draw() {
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw rope segments with tension coloring
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const tension = Math.abs(dist - restLength) / restLength;

                // Color based on tension (blue = relaxed, red = stretched)
                const hue = 60 - tension * 200;
                ctx.strokeStyle = `hsl(${Math.max(0, hue)}, 80%, 60%)`;
                ctx.lineWidth = 4;

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            // Draw points
            for (const p of points) {
                ctx.fillStyle = p.fixed ? '#ff7675' : '#fdcb6e';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.fixed ? 8 : 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw velocity vectors (small)
            ctx.strokeStyle = 'rgba(116, 185, 255, 0.5)';
            ctx.lineWidth = 1;
            for (const p of points) {
                if (!p.fixed && (Math.abs(p.vx) > 0.5 || Math.abs(p.vy) > 0.5)) {
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.vx * 5, p.y + p.vy * 5);
                    ctx.stroke();
                }
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const dist = Math.hypot(p.x - mx, p.y - my);
                if (dist < 20 && !p.fixed) {
                    dragging = true;
                    dragIndex = i;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (dragging && dragIndex >= 0) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                points[dragIndex].x = mx;
                points[dragIndex].y = my;
                points[dragIndex].oldX = mx;
                points[dragIndex].oldY = my;
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = false;
            dragIndex = -1;
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = false;
            dragIndex = -1;
        });

        // Event listeners
        document.getElementById('preset').onchange = function() {
            preset = this.value;
            reset();
        };

        document.getElementById('segments').oninput = function() {
            document.getElementById('segmentsVal').textContent = this.value;
        };

        document.getElementById('stiffness').oninput = function() {
            stiffness = parseInt(this.value);
            document.getElementById('stiffnessVal').textContent = this.value;
        };

        document.getElementById('damping').oninput = function() {
            damping = parseFloat(this.value);
            document.getElementById('dampingVal').textContent = parseFloat(this.value).toFixed(2);
        };

        document.getElementById('gravity').oninput = function() {
            gravity = parseFloat(this.value);
            document.getElementById('gravityVal').textContent = parseFloat(this.value).toFixed(1);
        };

        // Initialize
        reset();
        animate();
    </script>
</body>
</html>
