<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link-Walking Turtles - Network Navigation - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f1a;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        canvas { display: block; flex: 1; }
        #controls { width: 280px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #10b981; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        select { width: 100%; padding: 8px; background: #1a1a2e; color: #fff; border: 1px solid #333; border-radius: 5px; margin-bottom: 10px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #10b981; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #059669; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #10b981; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Link-Walking Turtles</h1>
            <p class="description">Agents traverse a network graph by walking along links between nodes. Demonstrates network navigation strategies and path-finding behavior.</p>
            <div class="control-group">
                <label>Network Type</label>
                <select id="networkType">
                    <option value="random">Random Network</option>
                    <option value="lattice">Lattice Grid</option>
                    <option value="smallWorld">Small World</option>
                    <option value="hub">Hub Network</option>
                </select>
            </div>
            <div class="control-group">
                <label>Nodes: <span id="nodesValue">30</span></label>
                <input type="range" id="nodes" min="10" max="60" value="30">
            </div>
            <div class="control-group">
                <label>Walkers: <span id="walkersValue">10</span></label>
                <input type="range" id="walkers" min="1" max="30" value="10">
            </div>
            <div class="control-group">
                <label>Walk Speed: <span id="speedValue">0.02</span></label>
                <input type="range" id="speed" min="0.005" max="0.1" step="0.005" value="0.02">
            </div>
            <div class="control-group">
                <label>Walking Strategy</label>
                <select id="strategy">
                    <option value="random">Random Walk</option>
                    <option value="preferNew">Prefer Unvisited</option>
                    <option value="preferDegree">Prefer High Degree</option>
                    <option value="avoid">Avoid Others</option>
                </select>
            </div>
            <button id="reset">New Network</button>
            <button id="pause">Pause</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="addWalker">Add Walker</button>
            <div class="stats">
                <div>Nodes: <span id="nodeCount">0</span></div>
                <div>Links: <span id="linkCount">0</span></div>
                <div>Active Walkers: <span id="walkerCount">0</span></div>
                <div>Nodes Visited: <span id="visitedCount">0</span></div>
                <div>Coverage: <span id="coverage">0</span>%</div>
                <div>Total Steps: <span id="steps">0</span></div>
            </div>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Link-Walking Turtles - Network Navigation</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        let nodes = [];
        let links = [];
        let walkers = [];
        let paused = false;
        let totalSteps = 0;

        let params = {
            networkType: 'random',
            nodeCount: 30,
            walkerCount: 10,
            speed: 0.02,
            strategy: 'random'
        };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function createNetwork() {
            nodes = [];
            links = [];
            walkers = [];
            totalSteps = 0;

            const padding = 80;
            const n = params.nodeCount;

            // Create nodes based on network type
            switch (params.networkType) {
                case 'lattice':
                    const cols = Math.ceil(Math.sqrt(n));
                    const rows = Math.ceil(n / cols);
                    const cellW = (width - 2 * padding) / (cols - 1 || 1);
                    const cellH = (height - 2 * padding) / (rows - 1 || 1);
                    for (let i = 0; i < n; i++) {
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        nodes.push({
                            id: i,
                            x: padding + col * cellW,
                            y: padding + row * cellH,
                            visited: false,
                            visitCount: 0,
                            neighbors: []
                        });
                    }
                    // Create lattice links
                    for (let i = 0; i < n; i++) {
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        if (col < cols - 1 && i + 1 < n) addLink(i, i + 1);
                        if (row < rows - 1 && i + cols < n) addLink(i, i + cols);
                    }
                    break;

                case 'hub':
                    // Central hub with spokes
                    nodes.push({ id: 0, x: width / 2, y: height / 2, visited: false, visitCount: 0, neighbors: [] });
                    for (let i = 1; i < n; i++) {
                        const angle = (i - 1) / (n - 1) * Math.PI * 2;
                        const r = 150 + Math.random() * 100;
                        nodes.push({
                            id: i,
                            x: width / 2 + Math.cos(angle) * r,
                            y: height / 2 + Math.sin(angle) * r,
                            visited: false,
                            visitCount: 0,
                            neighbors: []
                        });
                        addLink(0, i); // Connect to hub
                        // Some peripheral connections
                        if (Math.random() < 0.3 && i > 1) {
                            addLink(i, ((i - 2) % (n - 1)) + 1);
                        }
                    }
                    break;

                case 'smallWorld':
                    // Ring with shortcuts
                    for (let i = 0; i < n; i++) {
                        const angle = i / n * Math.PI * 2;
                        const r = Math.min(width, height) * 0.35;
                        nodes.push({
                            id: i,
                            x: width / 2 + Math.cos(angle) * r,
                            y: height / 2 + Math.sin(angle) * r,
                            visited: false,
                            visitCount: 0,
                            neighbors: []
                        });
                    }
                    // Ring connections
                    for (let i = 0; i < n; i++) {
                        addLink(i, (i + 1) % n);
                        if (n > 4) addLink(i, (i + 2) % n);
                    }
                    // Random shortcuts
                    for (let i = 0; i < n * 0.3; i++) {
                        const a = Math.floor(Math.random() * n);
                        const b = Math.floor(Math.random() * n);
                        if (a !== b) addLink(a, b);
                    }
                    break;

                default: // random
                    for (let i = 0; i < n; i++) {
                        nodes.push({
                            id: i,
                            x: padding + Math.random() * (width - 2 * padding),
                            y: padding + Math.random() * (height - 2 * padding),
                            visited: false,
                            visitCount: 0,
                            neighbors: []
                        });
                    }
                    // Create random links (ensure connectivity)
                    for (let i = 1; i < n; i++) {
                        const target = Math.floor(Math.random() * i);
                        addLink(i, target);
                    }
                    // Additional random links
                    for (let i = 0; i < n * 0.5; i++) {
                        const a = Math.floor(Math.random() * n);
                        const b = Math.floor(Math.random() * n);
                        if (a !== b) addLink(a, b);
                    }
            }

            // Create walkers
            for (let i = 0; i < params.walkerCount; i++) {
                createWalker();
            }
        }

        function addLink(a, b) {
            // Check if link already exists
            const exists = links.some(l =>
                (l.source === a && l.target === b) ||
                (l.source === b && l.target === a)
            );
            if (!exists && a !== b) {
                links.push({ source: a, target: b, traversed: 0 });
                nodes[a].neighbors.push(b);
                nodes[b].neighbors.push(a);
            }
        }

        function createWalker() {
            const startNode = Math.floor(Math.random() * nodes.length);
            const hue = Math.random() * 360;
            walkers.push({
                currentNode: startNode,
                targetNode: -1,
                progress: 1, // 1 = at node, 0-1 = traveling
                color: `hsl(${hue}, 70%, 60%)`,
                trail: [startNode],
                stepsCount: 0
            });
            nodes[startNode].visited = true;
            nodes[startNode].visitCount++;
        }

        function chooseNextNode(walker) {
            const current = nodes[walker.currentNode];
            if (current.neighbors.length === 0) return -1;

            let candidates = [...current.neighbors];

            switch (params.strategy) {
                case 'preferNew':
                    const unvisited = candidates.filter(n => !nodes[n].visited);
                    if (unvisited.length > 0) candidates = unvisited;
                    break;

                case 'preferDegree':
                    candidates.sort((a, b) => nodes[b].neighbors.length - nodes[a].neighbors.length);
                    candidates = candidates.slice(0, Math.max(1, Math.ceil(candidates.length / 3)));
                    break;

                case 'avoid':
                    // Prefer nodes without other walkers
                    const occupiedNodes = walkers
                        .filter(w => w !== walker && w.progress === 1)
                        .map(w => w.currentNode);
                    const empty = candidates.filter(n => !occupiedNodes.includes(n));
                    if (empty.length > 0) candidates = empty;
                    break;
            }

            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        function update() {
            if (paused) return;

            for (let walker of walkers) {
                if (walker.progress >= 1) {
                    // At a node, choose next destination
                    walker.targetNode = chooseNextNode(walker);
                    if (walker.targetNode >= 0) {
                        walker.progress = 0;
                    }
                } else {
                    // Traveling along link
                    walker.progress += params.speed;
                    if (walker.progress >= 1) {
                        walker.progress = 1;
                        walker.currentNode = walker.targetNode;
                        nodes[walker.currentNode].visited = true;
                        nodes[walker.currentNode].visitCount++;
                        walker.trail.push(walker.currentNode);
                        if (walker.trail.length > 50) walker.trail.shift();
                        walker.stepsCount++;
                        totalSteps++;

                        // Mark link as traversed
                        const link = links.find(l =>
                            (l.source === walker.currentNode && l.target === walker.targetNode) ||
                            (l.target === walker.currentNode && l.source === walker.targetNode)
                        );
                        if (link) link.traversed++;
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, width, height);

            // Draw links
            for (let link of links) {
                const a = nodes[link.source];
                const b = nodes[link.target];

                const intensity = Math.min(1, link.traversed / 10);
                ctx.strokeStyle = `rgba(100, 200, 150, ${0.2 + intensity * 0.5})`;
                ctx.lineWidth = 1 + intensity * 2;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            }

            // Draw nodes
            for (let node of nodes) {
                const radius = 8 + Math.min(node.visitCount, 10);
                const intensity = node.visited ? 1 : 0.3;

                // Glow effect for visited nodes
                if (node.visited) {
                    ctx.fillStyle = `rgba(16, 185, 129, ${0.2 + node.visitCount * 0.02})`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius + 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = node.visited ? '#10b981' : '#333';
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Node degree indicator
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.neighbors.length, node.x, node.y);
            }

            // Draw walker trails
            for (let walker of walkers) {
                if (walker.trail.length > 1) {
                    ctx.strokeStyle = walker.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(nodes[walker.trail[0]].x, nodes[walker.trail[0]].y);
                    for (let i = 1; i < walker.trail.length; i++) {
                        ctx.lineTo(nodes[walker.trail[i]].x, nodes[walker.trail[i]].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }

            // Draw walkers
            for (let walker of walkers) {
                let x, y;
                if (walker.progress >= 1 || walker.targetNode < 0) {
                    x = nodes[walker.currentNode].x;
                    y = nodes[walker.currentNode].y;
                } else {
                    const a = nodes[walker.currentNode];
                    const b = nodes[walker.targetNode];
                    x = a.x + (b.x - a.x) * walker.progress;
                    y = a.y + (b.y - a.y) * walker.progress;
                }

                // Walker glow
                ctx.fillStyle = walker.color;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Walker body
                ctx.fillStyle = walker.color;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x - 2, y - 2, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update stats
            const visitedNodes = nodes.filter(n => n.visited).length;
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('linkCount').textContent = links.length;
            document.getElementById('walkerCount').textContent = walkers.length;
            document.getElementById('visitedCount').textContent = visitedNodes;
            document.getElementById('coverage').textContent =
                ((visitedNodes / nodes.length) * 100).toFixed(1);
            document.getElementById('steps').textContent = totalSteps;
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('networkType').addEventListener('change', e => {
            params.networkType = e.target.value;
            createNetwork();
        });
        document.getElementById('nodes').addEventListener('input', e => {
            params.nodeCount = parseInt(e.target.value);
            document.getElementById('nodesValue').textContent = params.nodeCount;
        });
        document.getElementById('walkers').addEventListener('input', e => {
            params.walkerCount = parseInt(e.target.value);
            document.getElementById('walkersValue').textContent = params.walkerCount;
        });
        document.getElementById('speed').addEventListener('input', e => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = params.speed.toFixed(3);
        });
        document.getElementById('strategy').addEventListener('change', e => {
            params.strategy = e.target.value;
        });

        document.getElementById('reset').addEventListener('click', createNetwork);
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('addWalker').addEventListener('click', () => {
            createWalker();
        });

        window.addEventListener('resize', () => {
            resize();
            createNetwork();
        });

        resize();
        createNetwork();

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        animate();
    </script>
</body>
</html>
