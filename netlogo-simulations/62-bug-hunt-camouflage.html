<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Hunt Camouflage - Evolution of Cryptic Coloration - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        canvas { display: block; flex: 1; cursor: crosshair; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #f59e0b; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 5px; }
        select { width: 100%; padding: 8px; background: #1a1a2e; color: #fff; border: 1px solid #333; border-radius: 5px; margin-bottom: 10px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #f59e0b; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { background: #d97706; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .stats div { margin-bottom: 5px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f59e0b; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .description { font-size: 0.75rem; color: #888; margin-bottom: 15px; line-height: 1.5; }
        .color-sample { display: inline-block; width: 15px; height: 15px; border-radius: 3px; margin-right: 5px; vertical-align: middle; }
        .instruction { font-size: 0.8rem; color: #f59e0b; margin-bottom: 15px; padding: 10px; background: rgba(245, 158, 11, 0.1); border-radius: 5px; }

        .explain-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            margin-top: 10px;
        }
        .explain-btn:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        .modal {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: #fff;
            background: none;
        }
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
            font-size: 1.5rem;
            padding-right: 30px;
        }
        .modal-body {
            color: #ccc;
            line-height: 1.8;
            font-size: 0.95rem;
        }
        .modal-body h3 {
            color: #a5b4fc;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .modal-body ul {
            margin: 10px 0 15px 20px;
        }
        .modal-body li {
            margin-bottom: 8px;
        }
        .modal-body strong {
            color: #fbbf24;
        }
        .modal-body em {
            color: #a5b4fc;
            font-style: normal;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <h1>Bug Hunt Camouflage</h1>
            <p class="description">Click on bugs to "eat" them! Bugs that are harder to see (better camouflaged) survive and reproduce. Watch camouflage evolve over generations.</p>
            <div class="instruction">üéØ Click bugs to hunt them. The harder-to-see bugs survive!</div>
            <div class="control-group">
                <label>Background Environment</label>
                <select id="environment">
                    <option value="forest">Forest Floor</option>
                    <option value="sand">Sandy Beach</option>
                    <option value="grass">Grassland</option>
                    <option value="rocks">Rocky Terrain</option>
                    <option value="snow">Snow Field</option>
                </select>
            </div>
            <div class="control-group">
                <label>Bug Population: <span id="popValue">30</span></label>
                <input type="range" id="population" min="10" max="60" value="30">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationValue">0.1</span></label>
                <input type="range" id="mutation" min="0.01" max="0.3" step="0.01" value="0.1">
            </div>
            <div class="control-group">
                <label>Bug Size: <span id="sizeValue">15</span></label>
                <input type="range" id="bugSize" min="8" max="25" value="15">
            </div>
            <button id="reset">New Generation</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <button id="changeEnv">Randomize Environment</button>
            <button id="showBugs">Flash Bugs (Cheat!)</button>
            <div class="stats">
                <div>Generation: <span id="generation">1</span></div>
                <div>Bugs Alive: <span id="alive">0</span></div>
                <div>Bugs Eaten: <span id="eaten">0</span></div>
                <div>Total Hunted: <span id="totalHunted">0</span></div>
                <div>Avg Fitness: <span id="avgFitness">0</span></div>
                <div>Dominant Color: <span id="dominantColor"></span><span id="colorSample" class="color-sample"></span></div>
            </div>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>üìö Bug Hunt Camouflage - Evolution of Cryptic Coloration</h2>
            <div class="modal-body">
                <p>This simulation demonstrates key concepts in complex systems and agent-based modeling.</p>

                <h3>How It Works</h3>
                <p>Agents follow simple local rules that lead to emergent global behavior.</p>

                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Emergence:</strong> Complex patterns arise from simple rules</li>
                    <li><strong>Self-organization:</strong> Order without central control</li>
                    <li><strong>Feedback loops:</strong> Actions influence future states</li>
                </ul>

                <h3>Try This</h3>
                <ul>
                    <li>Adjust parameters to see different behaviors</li>
                    <li>Watch for patterns that emerge over time</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        let bugs = [];
        let bgColors = [];
        let bgPattern = null;
        let generation = 1;
        let totalHunted = 0;
        let eatenThisGen = 0;
        let flashMode = false;
        let flashTimer = 0;

        let params = {
            population: 30,
            mutation: 0.1,
            bugSize: 15,
            environment: 'forest'
        };

        const environments = {
            forest: {
                colors: ['#3d5a3d', '#4a6741', '#5c7a4f', '#6b8a5d', '#4f6848', '#3a4f3a'],
                noise: 0.4
            },
            sand: {
                colors: ['#d4b896', '#c9a882', '#dbc4a4', '#e8d5b5', '#c4a070', '#b89565'],
                noise: 0.2
            },
            grass: {
                colors: ['#4a7c34', '#5d8f42', '#6fa550', '#3d6928', '#7ab85e', '#4e8338'],
                noise: 0.5
            },
            rocks: {
                colors: ['#5a5a5a', '#6e6e6e', '#4a4a4a', '#787878', '#3d3d3d', '#8a8a8a'],
                noise: 0.6
            },
            snow: {
                colors: ['#e8e8e8', '#f0f0f0', '#d8d8d8', '#ffffff', '#e0e0e0', '#c8c8c8'],
                noise: 0.15
            }
        };

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            width = canvas.width;
            height = canvas.height;
            generateBackground();
        }

        function generateBackground() {
            const env = environments[params.environment];
            bgColors = [];

            // Create tiled background with patches
            const tileSize = 20;
            for (let y = 0; y < height; y += tileSize) {
                for (let x = 0; x < width; x += tileSize) {
                    const baseColor = env.colors[Math.floor(Math.random() * env.colors.length)];
                    const variation = (Math.random() - 0.5) * env.noise * 60;

                    const r = parseInt(baseColor.substr(1, 2), 16) + variation;
                    const g = parseInt(baseColor.substr(3, 2), 16) + variation;
                    const b = parseInt(baseColor.substr(5, 2), 16) + variation;

                    bgColors.push({
                        x, y,
                        r: Math.min(255, Math.max(0, r)),
                        g: Math.min(255, Math.max(0, g)),
                        b: Math.min(255, Math.max(0, b))
                    });
                }
            }
        }

        function createBug(parent = null) {
            const env = environments[params.environment];
            let r, g, b;

            if (parent) {
                // Inherit with mutation
                const mutation = params.mutation * 60;
                r = parent.r + (Math.random() - 0.5) * mutation * 2;
                g = parent.g + (Math.random() - 0.5) * mutation * 2;
                b = parent.b + (Math.random() - 0.5) * mutation * 2;
            } else {
                // Random color (some matching environment, some not)
                if (Math.random() < 0.5) {
                    const baseColor = env.colors[Math.floor(Math.random() * env.colors.length)];
                    r = parseInt(baseColor.substr(1, 2), 16) + (Math.random() - 0.5) * 80;
                    g = parseInt(baseColor.substr(3, 2), 16) + (Math.random() - 0.5) * 80;
                    b = parseInt(baseColor.substr(5, 2), 16) + (Math.random() - 0.5) * 80;
                } else {
                    r = Math.random() * 255;
                    g = Math.random() * 255;
                    b = Math.random() * 255;
                }
            }

            r = Math.min(255, Math.max(0, r));
            g = Math.min(255, Math.max(0, g));
            b = Math.min(255, Math.max(0, b));

            return {
                x: 50 + Math.random() * (width - 100),
                y: 50 + Math.random() * (height - 100),
                r, g, b,
                alive: true,
                fitness: 0
            };
        }

        function init() {
            bugs = [];
            eatenThisGen = 0;

            for (let i = 0; i < params.population; i++) {
                bugs.push(createBug());
            }

            calculateFitness();
        }

        function calculateFitness() {
            // Fitness = how well bug color matches background at its position
            for (let bug of bugs) {
                if (!bug.alive) continue;

                let totalDiff = 0;
                let count = 0;

                for (let tile of bgColors) {
                    const dx = tile.x + 10 - bug.x;
                    const dy = tile.y + 10 - bug.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 100) {
                        const weight = 1 - dist / 100;
                        const colorDiff = Math.abs(bug.r - tile.r) +
                                         Math.abs(bug.g - tile.g) +
                                         Math.abs(bug.b - tile.b);
                        totalDiff += colorDiff * weight;
                        count += weight;
                    }
                }

                // Lower color difference = higher fitness
                bug.fitness = count > 0 ? Math.max(0, 1 - (totalDiff / count) / 400) : 0;
            }
        }

        function reproduce() {
            const survivors = bugs.filter(b => b.alive);

            if (survivors.length < 2) {
                // Everyone died, start fresh
                init();
                return;
            }

            // Sort by fitness (best adapted survive)
            survivors.sort((a, b) => b.fitness - a.fitness);

            bugs = [];
            eatenThisGen = 0;
            generation++;

            // Reproduce from survivors
            while (bugs.length < params.population) {
                // Fitness-proportional selection
                const totalFitness = survivors.reduce((sum, b) => sum + b.fitness + 0.1, 0);
                let r = Math.random() * totalFitness;
                let parent = survivors[0];

                for (let s of survivors) {
                    r -= (s.fitness + 0.1);
                    if (r <= 0) {
                        parent = s;
                        break;
                    }
                }

                bugs.push(createBug(parent));
            }

            calculateFitness();
        }

        function draw() {
            // Draw background tiles
            for (let tile of bgColors) {
                ctx.fillStyle = `rgb(${Math.round(tile.r)}, ${Math.round(tile.g)}, ${Math.round(tile.b)})`;
                ctx.fillRect(tile.x, tile.y, 22, 22);
            }

            // Draw bugs
            const aliveBugs = bugs.filter(b => b.alive);

            for (let bug of aliveBugs) {
                // Bug body
                ctx.fillStyle = flashMode ?
                    '#ff0000' :
                    `rgb(${Math.round(bug.r)}, ${Math.round(bug.g)}, ${Math.round(bug.b)})`;

                // Oval bug shape
                ctx.beginPath();
                ctx.ellipse(bug.x, bug.y, params.bugSize, params.bugSize * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                // Bug details (subtle when not flashing)
                if (!flashMode) {
                    // Darker edge
                    ctx.strokeStyle = `rgba(0, 0, 0, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Head
                    ctx.fillStyle = `rgba(0, 0, 0, 0.2)`;
                    ctx.beginPath();
                    ctx.arc(bug.x + params.bugSize * 0.7, bug.y, params.bugSize * 0.35, 0, Math.PI * 2);
                    ctx.fill();

                    // Wing line
                    ctx.strokeStyle = `rgba(0, 0, 0, 0.15)`;
                    ctx.beginPath();
                    ctx.moveTo(bug.x - params.bugSize * 0.5, bug.y);
                    ctx.lineTo(bug.x + params.bugSize * 0.3, bug.y);
                    ctx.stroke();
                } else {
                    // Flash mode - make very visible
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            // Flash timer
            if (flashMode) {
                flashTimer--;
                if (flashTimer <= 0) flashMode = false;
            }

            // Update stats
            document.getElementById('generation').textContent = generation;
            document.getElementById('alive').textContent = aliveBugs.length;
            document.getElementById('eaten').textContent = eatenThisGen;
            document.getElementById('totalHunted').textContent = totalHunted;

            if (aliveBugs.length > 0) {
                const avgFit = aliveBugs.reduce((s, b) => s + b.fitness, 0) / aliveBugs.length;
                document.getElementById('avgFitness').textContent = (avgFit * 100).toFixed(1) + '%';

                // Find dominant color
                const avgR = aliveBugs.reduce((s, b) => s + b.r, 0) / aliveBugs.length;
                const avgG = aliveBugs.reduce((s, b) => s + b.g, 0) / aliveBugs.length;
                const avgB = aliveBugs.reduce((s, b) => s + b.b, 0) / aliveBugs.length;
                const domColor = `rgb(${Math.round(avgR)}, ${Math.round(avgG)}, ${Math.round(avgB)})`;
                document.getElementById('colorSample').style.backgroundColor = domColor;
            }

            // Auto-reproduce when most bugs eaten
            if (aliveBugs.length <= params.population * 0.3) {
                reproduce();
            }
        }

        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicked on any bug
            for (let bug of bugs) {
                if (!bug.alive) continue;

                const dx = bug.x - x;
                const dy = bug.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < params.bugSize) {
                    bug.alive = false;
                    eatenThisGen++;
                    totalHunted++;
                    break;
                }
            }
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('environment').addEventListener('change', e => {
            params.environment = e.target.value;
            generateBackground();
            calculateFitness();
        });
        document.getElementById('population').addEventListener('input', e => {
            params.population = parseInt(e.target.value);
            document.getElementById('popValue').textContent = params.population;
        });
        document.getElementById('mutation').addEventListener('input', e => {
            params.mutation = parseFloat(e.target.value);
            document.getElementById('mutationValue').textContent = params.mutation.toFixed(2);
        });
        document.getElementById('bugSize').addEventListener('input', e => {
            params.bugSize = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = params.bugSize;
        });

        document.getElementById('reset').addEventListener('click', () => {
            generation = 1;
            totalHunted = 0;
            init();
        });
        document.getElementById('changeEnv').addEventListener('click', () => {
            const envKeys = Object.keys(environments);
            params.environment = envKeys[Math.floor(Math.random() * envKeys.length)];
            document.getElementById('environment').value = params.environment;
            generateBackground();
            calculateFitness();
        });
        document.getElementById('showBugs').addEventListener('click', () => {
            flashMode = true;
            flashTimer = 30;
        });

        canvas.addEventListener('click', handleClick);
        window.addEventListener('resize', resize);

        resize();

        // Modal functionality
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => {
            modal.classList.add('active');
        });
        modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
