<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standing Ovation Model - CCAB</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 10px;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        .controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 15px 0; color: #ffeaa7; }
        h3 { margin: 15px 0 8px 0; color: #fdcb6e; font-size: 14px; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 13px; }
        input[type="range"] { width: 100%; }
        .stats {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #ffeaa7;
            color: #1a1a2e;
            font-weight: bold;
        }
        button:hover { background: #fdcb6e; }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 12px;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 15px; height: 15px; border-radius: 3px; }
        .standing-count {
            font-size: 2rem;
            text-align: center;
            color: #ffeaa7;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.1); transition: all 0.3s ease;">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="canvas"></canvas>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #636e72;"></div> Seated</div>
                <div class="legend-item"><div class="legend-color" style="background: #ffeaa7;"></div> Standing</div>
                <div class="legend-item"><div class="legend-color" style="background: #00b894;"></div> Just Stood</div>
            </div>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>üëè Standing Ovation</h2>
            <p style="font-size: 12px; opacity: 0.8;">Social cascade model of audience behavior</p>

            <div class="standing-count"><span id="standingPercent">0</span>% Standing</div>

            <h3>Audience Size</h3>
            <div class="slider-group">
                <label>Rows: <span id="rowsVal">20</span></label>
                <input type="range" id="rows" min="5" max="40" step="1" value="20">
            </div>
            <div class="slider-group">
                <label>Columns: <span id="colsVal">30</span></label>
                <input type="range" id="cols" min="10" max="50" step="1" value="30">
            </div>

            <h3>Behavior Parameters</h3>
            <div class="slider-group">
                <label>Quality Threshold: <span id="qualityVal">0.5</span></label>
                <input type="range" id="quality" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div class="slider-group">
                <label>Social Threshold: <span id="socialVal">0.3</span></label>
                <input type="range" id="social" min="0" max="1" step="0.05" value="0.3">
            </div>
            <div class="slider-group">
                <label>Performance Quality: <span id="perfQualityVal">0.6</span></label>
                <input type="range" id="perfQuality" min="0" max="1" step="0.05" value="0.6">
            </div>

            <button onclick="reset()">New Audience</button>
            <button onclick="startPerformance()">End Show</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>

            <div class="stats">
                <div class="stat-row"><span>Total Audience:</span><span id="totalAudience">600</span></div>
                <div class="stat-row"><span>Standing:</span><span id="standingCount">0</span></div>
                <div class="stat-row"><span>Seated:</span><span id="seatedCount">600</span></div>
                <div class="stat-row"><span>Round:</span><span id="round">0</span></div>
                <div class="stat-row"><span>Cascade Active:</span><span id="cascadeActive">No</span></div>
            </div>

            <div class="description">
                <strong>Standing Ovation Problem:</strong><br>
                Models how audience members decide to stand based on:<br>
                1. Their personal threshold (how good the show must be)<br>
                2. Social influence (how many neighbors are standing)<br><br>
                <strong>Parameters:</strong><br>
                ‚Ä¢ <strong>Quality Threshold:</strong> Min performance quality to stand initially<br>
                ‚Ä¢ <strong>Social Threshold:</strong> Fraction of standing neighbors needed to join<br>
                ‚Ä¢ <strong>Performance Quality:</strong> How good the show was<br><br>
                Watch social cascades emerge from local interactions!
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        canvas.width = 700;
        canvas.height = 400;
        graphCanvas.width = 700;
        graphCanvas.height = 100;

        let rows = 20;
        let cols = 30;
        let qualityThreshold = 0.5;
        let socialThreshold = 0.3;
        let perfQuality = 0.6;

        let audience = [];
        let standing = [];
        let justStood = [];
        let paused = false;
        let round = 0;
        let history = [];
        let animationId = null;
        let performanceStarted = false;

        function createAudience() {
            audience = [];
            standing = [];
            justStood = [];
            history = [];
            round = 0;
            performanceStarted = false;

            for (let r = 0; r < rows; r++) {
                audience[r] = [];
                standing[r] = [];
                justStood[r] = [];
                for (let c = 0; c < cols; c++) {
                    // Each person has a random threshold between 0 and qualityThreshold*2
                    audience[r][c] = Math.random() * qualityThreshold * 2;
                    standing[r][c] = false;
                    justStood[r][c] = false;
                }
            }
        }

        function reset() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            rows = parseInt(document.getElementById('rows').value);
            cols = parseInt(document.getElementById('cols').value);
            qualityThreshold = parseFloat(document.getElementById('quality').value);
            socialThreshold = parseFloat(document.getElementById('social').value);
            perfQuality = parseFloat(document.getElementById('perfQuality').value);

            createAudience();
            updateStats();
            draw();
        }

        function getNeighborStandingFraction(r, c) {
            let standingNeighbors = 0;
            let totalNeighbors = 0;

            // Check all neighbors in a 3x3 area (including diagonals)
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        totalNeighbors++;
                        if (standing[nr][nc]) standingNeighbors++;
                    }
                }
            }

            // Also check people in front (they can see them better)
            if (r > 0) {
                for (let dc = -2; dc <= 2; dc++) {
                    const nc = c + dc;
                    if (nc >= 0 && nc < cols && !isNaN(standing[r-1][nc])) {
                        totalNeighbors++;
                        if (standing[r-1][nc]) standingNeighbors++;
                    }
                }
            }

            return totalNeighbors > 0 ? standingNeighbors / totalNeighbors : 0;
        }

        function simulateRound() {
            let anyChange = false;

            // Clear just stood flags
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    justStood[r][c] = false;
                }
            }

            // First, find who will stand this round (don't update until all checked)
            const willStand = [];
            for (let r = 0; r < rows; r++) {
                willStand[r] = [];
                for (let c = 0; c < cols; c++) {
                    willStand[r][c] = false;

                    if (standing[r][c]) continue; // Already standing

                    const neighborFraction = getNeighborStandingFraction(r, c);

                    // Stand if neighbors fraction exceeds social threshold
                    if (neighborFraction >= socialThreshold) {
                        willStand[r][c] = true;
                    }
                }
            }

            // Now apply changes
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (willStand[r][c]) {
                        standing[r][c] = true;
                        justStood[r][c] = true;
                        anyChange = true;
                    }
                }
            }

            return anyChange;
        }

        function startPerformance() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            // Initial standing based on performance quality vs personal threshold
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    standing[r][c] = false;
                    justStood[r][c] = false;

                    // Person stands if performance quality exceeds their threshold
                    if (perfQuality > audience[r][c]) {
                        standing[r][c] = true;
                        justStood[r][c] = true;
                    }
                }
            }

            round = 0;
            history = [];
            performanceStarted = true;
            updateStats();
            draw();

            // Start cascade simulation
            function step() {
                if (paused) {
                    animationId = requestAnimationFrame(step);
                    return;
                }

                round++;
                const changed = simulateRound();

                const standingCount = countStanding();
                history.push(standingCount);

                updateStats();
                draw();
                drawGraph();

                if (changed && round < 100) {
                    animationId = setTimeout(() => {
                        animationId = requestAnimationFrame(step);
                    }, 300);
                } else {
                    document.getElementById('cascadeActive').textContent = 'Complete';
                }
            }

            animationId = requestAnimationFrame(step);
        }

        function countStanding() {
            let count = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (standing[r][c]) count++;
                }
            }
            return count;
        }

        function updateStats() {
            const total = rows * cols;
            const standingCount = countStanding();
            const percent = ((standingCount / total) * 100).toFixed(1);

            document.getElementById('totalAudience').textContent = total;
            document.getElementById('standingCount').textContent = standingCount;
            document.getElementById('seatedCount').textContent = total - standingCount;
            document.getElementById('standingPercent').textContent = percent;
            document.getElementById('round').textContent = round;
            document.getElementById('cascadeActive').textContent = performanceStarted ? 'Yes' : 'No';
        }

        function draw() {
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cellWidth = (canvas.width - 20) / cols;
            const cellHeight = (canvas.height - 20) / rows;
            const size = Math.min(cellWidth, cellHeight) * 0.8;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const x = 10 + c * cellWidth + cellWidth / 2;
                    const y = 10 + r * cellHeight + cellHeight / 2;

                    // Draw person (circle for head, rectangle for body)
                    if (standing[r][c]) {
                        if (justStood[r][c]) {
                            ctx.fillStyle = '#00b894'; // Just stood - green
                        } else {
                            ctx.fillStyle = '#ffeaa7'; // Standing - yellow
                        }
                        // Standing figure (taller)
                        ctx.beginPath();
                        ctx.arc(x, y - size * 0.3, size * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(x - size * 0.15, y - size * 0.05, size * 0.3, size * 0.5);
                    } else {
                        ctx.fillStyle = '#636e72'; // Seated - gray
                        // Seated figure (shorter, wider)
                        ctx.beginPath();
                        ctx.arc(x, y - size * 0.1, size * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(x - size * 0.2, y + size * 0.1, size * 0.4, size * 0.2);
                    }
                }
            }

            // Draw stage at bottom
            ctx.fillStyle = '#74b9ff';
            ctx.fillRect(0, canvas.height - 5, canvas.width, 5);
        }

        function drawGraph() {
            graphCtx.fillStyle = '#1a1a2e';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (history.length < 2) return;

            const total = rows * cols;
            const maxHistory = 50;

            graphCtx.strokeStyle = '#ffeaa7';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();

            const startIdx = Math.max(0, history.length - maxHistory);
            for (let i = startIdx; i < history.length; i++) {
                const x = ((i - startIdx) / maxHistory) * graphCanvas.width;
                const y = graphCanvas.height - (history[i] / total) * graphCanvas.height;

                if (i === startIdx) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Label
            graphCtx.fillStyle = '#ffeaa7';
            graphCtx.font = '11px Arial';
            graphCtx.fillText('Standing over time', 5, 15);
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        }

        // Event listeners
        document.getElementById('rows').oninput = function() {
            document.getElementById('rowsVal').textContent = this.value;
        };
        document.getElementById('cols').oninput = function() {
            document.getElementById('colsVal').textContent = this.value;
        };
        document.getElementById('quality').oninput = function() {
            qualityThreshold = parseFloat(this.value);
            document.getElementById('qualityVal').textContent = this.value;
        };
        document.getElementById('social').oninput = function() {
            socialThreshold = parseFloat(this.value);
            document.getElementById('socialVal').textContent = this.value;
        };
        document.getElementById('perfQuality').oninput = function() {
            perfQuality = parseFloat(this.value);
            document.getElementById('perfQualityVal').textContent = this.value;
        };

        reset();
    </script>
</body>
</html>
