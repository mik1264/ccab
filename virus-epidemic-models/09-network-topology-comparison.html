<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Topology Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            width: 100vw;
            height: 100vh;
            gap: 2px;
            background: #000;
        }
        .network-panel {
            position: relative;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            font-weight: bold;
        }
        .stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 5px;
            font-size: 11px;
        }
        .stat-item {
            display: flex;
            gap: 10px;
            margin-bottom: 3px;
        }
        .susceptible { color: #4ade80; }
        .infected { color: #ef4444; }
        .recovered { color: #94a3b8; }
    </style>
</head>
<body>
    <div class="container">
        <div class="network-panel">
            <canvas id="canvas1"></canvas>
            <div class="label">Random (Erdős-Rényi)</div>
            <div class="stats" id="stats1"></div>
        </div>
        <div class="network-panel">
            <canvas id="canvas2"></canvas>
            <div class="label">Scale-Free (Barabási-Albert)</div>
            <div class="stats" id="stats2"></div>
        </div>
        <div class="network-panel">
            <canvas id="canvas3"></canvas>
            <div class="label">Small-World (Watts-Strogatz)</div>
            <div class="stats" id="stats3"></div>
        </div>
        <div class="network-panel">
            <canvas id="canvas4"></canvas>
            <div class="label">Regular Lattice</div>
            <div class="stats" id="stats4"></div>
        </div>
    </div>

    <script>
        const SUSCEPTIBLE = 0;
        const INFECTED = 1;
        const RECOVERED = 2;

        const params = {
            transmission: 6,
            recovery: 10
        };

        class Node {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.state = SUSCEPTIBLE;
                this.neighbors = [];
                this.radius = 4;
            }

            draw(ctx) {
                let color;
                switch (this.state) {
                    case SUSCEPTIBLE: color = '#4ade80'; break;
                    case INFECTED: color = '#ef4444'; break;
                    case RECOVERED: color = '#94a3b8'; break;
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createRandomNetwork(n, p, w, h) {
            const nodes = [];
            const edges = [];
            const cx = w / 2, cy = h / 2, r = Math.min(w, h) * 0.35;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push(new Node(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r, i));
            }

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) {
                        nodes[i].neighbors.push(nodes[j]);
                        nodes[j].neighbors.push(nodes[i]);
                        edges.push([i, j]);
                    }
                }
            }

            nodes[0].state = INFECTED;
            return { nodes, edges };
        }

        function createScaleFree(n, m, w, h) {
            const nodes = [];
            const edges = [];
            const cx = w / 2, cy = h / 2, r = Math.min(w, h) * 0.35;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push(new Node(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r, i));
            }

            for (let i = 0; i < m; i++) {
                for (let j = i + 1; j < m; j++) {
                    nodes[i].neighbors.push(nodes[j]);
                    nodes[j].neighbors.push(nodes[i]);
                    edges.push([i, j]);
                }
            }

            for (let i = m; i < n; i++) {
                const targets = new Set();
                while (targets.size < m) {
                    let r = Math.random();
                    let sum = 0;
                    for (let j = 0; j < i; j++) {
                        sum += nodes[j].neighbors.length;
                    }
                    let cumsum = 0;
                    for (let j = 0; j < i; j++) {
                        cumsum += nodes[j].neighbors.length / sum;
                        if (cumsum >= r && !targets.has(j)) {
                            targets.add(j);
                            break;
                        }
                    }
                }
                for (let t of targets) {
                    nodes[i].neighbors.push(nodes[t]);
                    nodes[t].neighbors.push(nodes[i]);
                    edges.push([i, t]);
                }
            }

            nodes[0].state = INFECTED;
            return { nodes, edges };
        }

        function createSmallWorld(n, k, p, w, h) {
            const nodes = [];
            const edges = [];
            const cx = w / 2, cy = h / 2, r = Math.min(w, h) * 0.35;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push(new Node(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r, i));
            }

            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= k; j++) {
                    const ni = (i + j) % n;
                    nodes[i].neighbors.push(nodes[ni]);
                    if (j === 1) edges.push([i, ni]);
                }
            }

            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= k; j++) {
                    if (Math.random() < p) {
                        const oldIdx = (i + j) % n;
                        const pos = nodes[i].neighbors.indexOf(nodes[oldIdx]);
                        if (pos > -1) nodes[i].neighbors.splice(pos, 1);

                        let newIdx;
                        do {
                            newIdx = Math.floor(Math.random() * n);
                        } while (newIdx === i || nodes[i].neighbors.includes(nodes[newIdx]));
                        nodes[i].neighbors.push(nodes[newIdx]);
                    }
                }
            }

            nodes[0].state = INFECTED;
            return { nodes, edges };
        }

        function createLattice(n, w, h) {
            const nodes = [];
            const edges = [];
            const size = Math.floor(Math.sqrt(n));
            const cellSize = Math.min(w, h) / (size + 2);

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const x = (j + 1) * cellSize;
                    const y = (i + 1) * cellSize;
                    nodes.push(new Node(x, y, i * size + j));
                }
            }

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const idx = i * size + j;
                    if (i > 0) {
                        nodes[idx].neighbors.push(nodes[(i - 1) * size + j]);
                        edges.push([idx, (i - 1) * size + j]);
                    }
                    if (j > 0) {
                        nodes[idx].neighbors.push(nodes[i * size + (j - 1)]);
                        edges.push([idx, i * size + (j - 1)]);
                    }
                }
            }

            nodes[Math.floor(n / 2)].state = INFECTED;
            return { nodes, edges };
        }

        function simulate(network, ctx) {
            const { nodes, edges } = network;

            // Transmission
            const newInfections = [];
            for (let node of nodes) {
                if (node.state !== INFECTED) continue;
                for (let neighbor of node.neighbors) {
                    if (neighbor.state === SUSCEPTIBLE && Math.random() * 100 < params.transmission) {
                        newInfections.push(neighbor);
                    }
                }
            }
            newInfections.forEach(n => n.state = INFECTED);

            // Recovery
            for (let node of nodes) {
                if (node.state === INFECTED && Math.random() * 100 < params.recovery) {
                    node.state = RECOVERED;
                }
            }

            return { s: nodes.filter(n => n.state === SUSCEPTIBLE).length,
                     i: nodes.filter(n => n.state === INFECTED).length,
                     r: nodes.filter(n => n.state === RECOVERED).length };
        }

        function draw(network, ctx, w, h) {
            const { nodes, edges } = network;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = 'rgba(100, 100, 100, 0.1)';
            ctx.lineWidth = 1;
            for (let [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            nodes.forEach(n => n.draw(ctx));
        }

        function updateStats(stats, id) {
            document.getElementById(id).innerHTML = `
                <div class="stat-item"><span class="susceptible">S:</span><span>${stats.s}</span></div>
                <div class="stat-item"><span class="infected">I:</span><span>${stats.i}</span></div>
                <div class="stat-item"><span class="recovered">R:</span><span>${stats.r}</span></div>
            `;
        }

        // Initialize
        const canvases = [
            document.getElementById('canvas1'),
            document.getElementById('canvas2'),
            document.getElementById('canvas3'),
            document.getElementById('canvas4')
        ];

        canvases.forEach(c => {
            c.width = c.offsetWidth;
            c.height = c.offsetHeight;
        });

        const networks = [
            createRandomNetwork(40, 0.1, canvases[0].width, canvases[0].height),
            createScaleFree(40, 2, canvases[1].width, canvases[1].height),
            createSmallWorld(40, 3, 0.1, canvases[2].width, canvases[2].height),
            createLattice(36, canvases[3].width, canvases[3].height)
        ];

        function animate() {
            canvases.forEach((canvas, i) => {
                const ctx = canvas.getContext('2d');
                draw(networks[i], ctx, canvas.width, canvas.height);
                const stats = simulate(networks[i], ctx);
                updateStats(stats, `stats${i + 1}`);
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
