<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Collision - N-Body Simulation - CCAB</title>
    <meta name="description" content="Mesmerizing N-body simulation of two spiral galaxies colliding. Watch gravitational interactions create tidal tails and merge galactic structures in real-time.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #ffd700;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            color: #ffd700;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stats {
            font-size: 11px;
            color: #ddd;
            margin-top: 10px;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 180px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #ffd700;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255, 215, 0, 0.3);
        }

        button.active {
            background: rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .control-group label {
            color: #ffd700;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #ffd700;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 18px;
            z-index: 2000;
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            color: #ddd;
            font-size: 11px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <div id="info">
        <h3>Galaxy Collision</h3>
        <div>Scenario: <span id="scenario-name">Collision Course</span></div>
        <div class="stats">
            <div>Stars: <span id="star-count">0</span></div>
            <div>Time: <span id="sim-time">0</span> Myr</div>
        </div>
        <p>N-body gravitational simulation of two spiral galaxies. Each star feels the gravitational pull of both galactic cores. Watch as tidal forces create beautiful spiraling tails.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="collision">Collision Course</button>
        <button data-preset="flyby">Flyby Encounter</button>
        <button data-preset="headon">Head-On Merger</button>
        <button data-preset="retrograde">Retrograde</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Time Scale: <span id="time-val">1.0</span>x</label>
            <input type="range" id="time-scale" min="0.1" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Star Size: <span id="size-val">1.0</span></label>
            <input type="range" id="star-size" min="0.5" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Trail: <span id="trail-val">0.92</span></label>
            <input type="range" id="trail" min="0.8" max="0.99" value="0.92" step="0.01">
        </div>
        <button id="reset">Reset</button>
        <button id="pause">Pause</button>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <div id="instructions">
        Drag to rotate view | Scroll to zoom
    </div>

    <div id="loading">Generating galaxies...</div>

    <canvas id="canvas"></canvas>

    <script>
        // Galaxy Collision N-body Simulation
        // Based on Daniel Price's simulation and Evgenii's JavaScript port

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loadingEl = document.getElementById('loading');

        // Configuration
        const config = {
            starsPerGalaxy: 8000,
            numRings: 25,
            coreMultiplier: 5,
            coreMass1: 1.0,
            coreMass2: 0.8,
            softening: 0.05,  // Softening parameter to prevent singularity
            dt: 0.002,       // Time step
            timeScale: 1.0,
            starSize: 1.0,
            trail: 0.92
        };

        // Scenario presets
        const presets = {
            collision: {
                name: "Collision Course",
                galaxy1: { x: -1.5, y: 0, z: 0, vx: 0.3, vy: 0.15, vz: 0, tilt: 0.3 },
                galaxy2: { x: 1.5, y: 0.3, z: 0, vx: -0.25, vy: -0.1, vz: 0, tilt: -0.2 }
            },
            flyby: {
                name: "Flyby Encounter",
                galaxy1: { x: -2, y: -0.8, z: 0, vx: 0.4, vy: 0.15, vz: 0, tilt: 0.1 },
                galaxy2: { x: 2, y: 0.8, z: 0, vx: -0.35, vy: -0.1, vz: 0, tilt: -0.5 }
            },
            headon: {
                name: "Head-On Merger",
                galaxy1: { x: -2, y: 0, z: 0, vx: 0.5, vy: 0, vz: 0, tilt: 0 },
                galaxy2: { x: 2, y: 0, z: 0, vx: -0.5, vy: 0, vz: 0, tilt: Math.PI }
            },
            retrograde: {
                name: "Retrograde",
                galaxy1: { x: -1.5, y: 0.5, z: 0, vx: 0.3, vy: -0.1, vz: 0, tilt: 0.4 },
                galaxy2: { x: 1.5, y: -0.5, z: 0, vx: -0.3, vy: 0.1, vz: 0, tilt: Math.PI + 0.4 }
            }
        };

        let currentPreset = 'collision';
        let paused = false;
        let simTime = 0;

        // Stars array: [x, y, z, vx, vy, vz, galaxy]
        let stars = [];
        let cores = [
            { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, mass: config.coreMass1 },
            { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, mass: config.coreMass2 }
        ];

        // Camera rotation
        let rotX = 0.3;
        let rotY = 0;
        let zoom = 200;
        let isDragging = false;
        let lastMouseX, lastMouseY;

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Create spiral galaxy
        function createGalaxy(centerX, centerY, centerZ, vx, vy, vz, tilt, mass, clockwise = true) {
            const galaxyStars = [];
            const direction = clockwise ? 1 : -1;

            for (let ring = 1; ring <= config.numRings; ring++) {
                const radius = ring * 0.04;  // Ring spacing
                const starsInRing = ring * config.coreMultiplier;
                const angleOffset = ring * 0.3;  // Spiral pattern

                for (let i = 0; i < starsInRing; i++) {
                    // Position in disk plane
                    const angle = (i / starsInRing) * Math.PI * 2 + angleOffset;
                    const jitter = (Math.random() - 0.5) * 0.02;  // Random scatter
                    const r = radius + jitter;

                    // Disk coordinates
                    let x = r * Math.cos(angle);
                    let y = (Math.random() - 0.5) * 0.02;  // Small vertical scatter
                    let z = r * Math.sin(angle);

                    // Apply tilt rotation around X axis
                    const cosT = Math.cos(tilt);
                    const sinT = Math.sin(tilt);
                    const newY = y * cosT - z * sinT;
                    const newZ = y * sinT + z * cosT;

                    // Orbital velocity (circular orbit around core)
                    const speed = Math.sqrt(mass / r) * 0.8;  // Slightly sub-Keplerian
                    let vxLocal = -direction * speed * Math.sin(angle);
                    let vzLocal = direction * speed * Math.cos(angle);

                    // Apply tilt to velocity
                    const vyLocal = -vzLocal * sinT;
                    const vzFinal = vzLocal * cosT;

                    galaxyStars.push({
                        x: centerX + x,
                        y: centerY + newY,
                        z: centerZ + newZ,
                        vx: vx + vxLocal,
                        vy: vy + vyLocal,
                        vz: vz + vzFinal,
                        galaxy: cores.length === 2 ? (mass === config.coreMass1 ? 0 : 1) : 0
                    });
                }
            }

            return galaxyStars;
        }

        // Initialize simulation
        function initSimulation(presetName) {
            const preset = presets[presetName];
            currentPreset = presetName;
            simTime = 0;

            // Reset cores
            const g1 = preset.galaxy1;
            const g2 = preset.galaxy2;

            cores[0] = { x: g1.x, y: g1.y, z: g1.z, vx: g1.vx, vy: g1.vy, vz: g1.vz, mass: config.coreMass1 };
            cores[1] = { x: g2.x, y: g2.y, z: g2.z, vx: g2.vx, vy: g2.vy, vz: g2.vz, mass: config.coreMass2 };

            // Create stars for both galaxies
            stars = [
                ...createGalaxy(g1.x, g1.y, g1.z, g1.vx, g1.vy, g1.vz, g1.tilt, config.coreMass1, true),
                ...createGalaxy(g2.x, g2.y, g2.z, g2.vx, g2.vy, g2.vz, g2.tilt, config.coreMass2, true)
            ];

            document.getElementById('scenario-name').textContent = preset.name;
            document.getElementById('star-count').textContent = stars.length.toLocaleString();

            // Update UI
            document.querySelectorAll('#presets button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === presetName);
            });
        }

        // Compute gravitational acceleration from cores
        function computeAcceleration(x, y, z) {
            let ax = 0, ay = 0, az = 0;

            for (const core of cores) {
                const dx = core.x - x;
                const dy = core.y - y;
                const dz = core.z - z;
                const r2 = dx * dx + dy * dy + dz * dz + config.softening * config.softening;
                const r = Math.sqrt(r2);
                const r3 = r2 * r;

                const force = core.mass / r3;
                ax += force * dx;
                ay += force * dy;
                az += force * dz;
            }

            return { ax, ay, az };
        }

        // Update simulation with Velocity Verlet integration
        function updateSimulation() {
            const dt = config.dt * config.timeScale;

            // Update cores (they attract each other)
            for (let i = 0; i < cores.length; i++) {
                let ax = 0, ay = 0, az = 0;

                for (let j = 0; j < cores.length; j++) {
                    if (i === j) continue;

                    const dx = cores[j].x - cores[i].x;
                    const dy = cores[j].y - cores[i].y;
                    const dz = cores[j].z - cores[i].z;
                    const r2 = dx * dx + dy * dy + dz * dz + config.softening * config.softening;
                    const r = Math.sqrt(r2);
                    const r3 = r2 * r;

                    const force = cores[j].mass / r3;
                    ax += force * dx;
                    ay += force * dy;
                    az += force * dz;
                }

                // Update core velocities and positions
                cores[i].vx += ax * dt;
                cores[i].vy += ay * dt;
                cores[i].vz += az * dt;
                cores[i].x += cores[i].vx * dt;
                cores[i].y += cores[i].vy * dt;
                cores[i].z += cores[i].vz * dt;
            }

            // Update stars (Leapfrog/Verlet)
            for (const star of stars) {
                // Compute acceleration at current position
                const { ax, ay, az } = computeAcceleration(star.x, star.y, star.z);

                // Update velocity (half step)
                star.vx += ax * dt;
                star.vy += ay * dt;
                star.vz += az * dt;

                // Update position
                star.x += star.vx * dt;
                star.y += star.vy * dt;
                star.z += star.vz * dt;
            }

            simTime += dt * 1000;  // Convert to Myr (approximate)
        }

        // 3D rotation and projection
        function project(x, y, z) {
            // Rotate around Y axis
            let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
            let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);

            // Rotate around X axis
            let y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
            let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);

            // Perspective projection
            const perspective = 5;
            const scale = zoom * perspective / (perspective + z2);

            return {
                x: canvas.width / 2 + x1 * scale,
                y: canvas.height / 2 - y1 * scale,
                z: z2,
                scale: scale / zoom
            };
        }

        // Render
        function render() {
            // Apply trail fade
            ctx.fillStyle = `rgba(0, 0, 0, ${1 - config.trail})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sort stars by depth for proper rendering
            const projected = stars.map((star, i) => ({
                ...project(star.x, star.y, star.z),
                galaxy: star.galaxy,
                index: i
            }));
            projected.sort((a, b) => b.z - a.z);

            // Draw stars
            for (const p of projected) {
                if (p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) continue;

                const size = Math.max(0.5, config.starSize * p.scale * 2);

                // Color based on galaxy
                if (p.galaxy === 0) {
                    ctx.fillStyle = `rgba(255, 220, 180, ${0.6 + 0.4 * p.scale})`;  // Warm white/yellow
                } else {
                    ctx.fillStyle = `rgba(180, 200, 255, ${0.6 + 0.4 * p.scale})`;  // Cool blue/white
                }

                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw galactic cores (bright centers)
            for (let i = 0; i < cores.length; i++) {
                const p = project(cores[i].x, cores[i].y, cores[i].z);

                // Glow effect
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 20 * p.scale);
                if (i === 0) {
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
                    gradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 150, 50, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(200, 220, 255, 1)');
                    gradient.addColorStop(0.3, 'rgba(100, 150, 255, 0.6)');
                    gradient.addColorStop(1, 'rgba(50, 100, 255, 0)');
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 25 * p.scale, 0, Math.PI * 2);
                ctx.fill();

                // Bright core
                ctx.fillStyle = i === 0 ? '#ffffcc' : '#ccddff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4 * p.scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // FPS counter
        let frameCount = 0;
        let lastFpsTime = performance.now();

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }
        }

        // Animation loop
        function animate() {
            updateFPS();

            if (!paused) {
                updateSimulation();
                document.getElementById('sim-time').textContent = Math.floor(simTime).toLocaleString();
            }

            render();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                initSimulation(btn.dataset.preset);
            });
        });

        document.getElementById('time-scale').addEventListener('input', e => {
            config.timeScale = parseFloat(e.target.value);
            document.getElementById('time-val').textContent = config.timeScale.toFixed(1);
        });

        document.getElementById('star-size').addEventListener('input', e => {
            config.starSize = parseFloat(e.target.value);
            document.getElementById('size-val').textContent = config.starSize.toFixed(1);
        });

        document.getElementById('trail').addEventListener('input', e => {
            config.trail = parseFloat(e.target.value);
            document.getElementById('trail-val').textContent = config.trail.toFixed(2);
        });

        document.getElementById('reset').addEventListener('click', () => {
            initSimulation(currentPreset);
        });

        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });

        // Mouse controls for rotation
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', e => {
            if (!isDragging) return;

            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;

            rotY += dx * 0.005;
            rotX += dy * 0.005;
            rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(50, Math.min(500, zoom));
        });

        // Touch controls
        let lastTouchDist = 0;
        canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.sqrt(dx * dx + dy * dy);
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - lastMouseX;
                const dy = e.touches[0].clientY - lastMouseY;

                rotY += dx * 0.005;
                rotX += dy * 0.005;
                rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));

                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (lastTouchDist > 0) {
                    zoom *= dist / lastTouchDist;
                    zoom = Math.max(50, Math.min(500, zoom));
                }
                lastTouchDist = dist;
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            lastTouchDist = 0;
        });

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = function() { initSimulation('collision'); };

        // Initialize and start
        initSimulation('collision');
        loadingEl.style.display = 'none';
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
