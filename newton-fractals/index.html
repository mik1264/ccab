<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton Fractals - CCAB</title>
    <meta name="description" content="Interactive Newton fractal visualization using WebGL. Explore the basins of attraction for polynomial root finding with draggable roots and real-time rendering.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #e91e63;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(233, 30, 99, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            color: #e91e63;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #aaa;
            font-size: 11px;
        }

        #info .stat-value {
            color: #e91e63;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 220px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(233, 30, 99, 0.15);
            border: 1px solid rgba(233, 30, 99, 0.4);
            color: #e91e63;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(233, 30, 99, 0.3);
        }

        button.active {
            background: rgba(233, 30, 99, 0.4);
            border-color: #e91e63;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.2);
        }

        .control-group label {
            color: #e91e63;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #e91e63;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #e91e63;
            font-size: 12px;
            z-index: 1000;
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(233, 30, 99, 0.6);
            font-size: 12px;
            z-index: 1000;
            text-align: center;
        }

        .root-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid white;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Newton Fractals</h3>
        <div class="stat">
            <span class="stat-label">Polynomial</span>
            <span class="stat-value" id="polynomial">z³ - 1</span>
        </div>
        <div class="stat">
            <span class="stat-label">Roots</span>
            <span class="stat-value" id="root-count">3</span>
        </div>
        <div class="stat">
            <span class="stat-label">Iterations</span>
            <span class="stat-value" id="iterations">50</span>
        </div>
        <p>Newton-Raphson root finding creates beautiful fractal basins of attraction. Drag the colored dots to move roots. Scroll to zoom, drag to pan.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="cubic">z³ - 1 (3 roots)</button>
        <button data-preset="quartic">z⁴ - 1 (4 roots)</button>
        <button data-preset="quintic">z⁵ - 1 (5 roots)</button>
        <button data-preset="custom">Custom (6 roots)</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Iterations: <span id="iter-val">50</span></label>
            <input type="range" id="iter" min="10" max="200" step="5" value="50">
        </div>
        <div class="control-group">
            <label>Color Mode: <span id="color-val">Smooth</span></label>
            <input type="range" id="color-mode" min="0" max="2" step="1" value="0">
        </div>
        <div class="control-group">
            <label>Zoom: <span id="zoom-val">1.0x</span></label>
            <input type="range" id="zoom" min="0.1" max="5" step="0.1" value="1">
        </div>
    </div>

    <div id="instructions">Drag roots to move them • Scroll to zoom • Drag background to pan</div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL2 not supported');
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', () => {
            resize();
            render();
        });

        // DOM elements
        const polynomialDisplay = document.getElementById('polynomial');
        const rootCountDisplay = document.getElementById('root-count');
        const iterationsDisplay = document.getElementById('iterations');
        const fpsDisplay = document.getElementById('fps');
        const iterSlider = document.getElementById('iter');
        const iterVal = document.getElementById('iter-val');
        const colorModeSlider = document.getElementById('color-mode');
        const colorVal = document.getElementById('color-val');
        const zoomSlider = document.getElementById('zoom');
        const zoomVal = document.getElementById('zoom-val');

        // Configuration
        let config = {
            iterations: 50,
            colorMode: 0,
            zoom: 1.0,
            centerX: 0,
            centerY: 0
        };

        // Root colors (up to 6)
        const ROOT_COLORS = [
            [1.0, 0.2, 0.4],   // Pink/Red
            [0.2, 0.8, 0.4],   // Green
            [0.2, 0.4, 1.0],   // Blue
            [1.0, 0.8, 0.2],   // Yellow
            [0.8, 0.2, 1.0],   // Purple
            [0.2, 0.9, 0.9],   // Cyan
        ];

        // Roots (complex numbers as [real, imag])
        let roots = [];
        let rootMarkers = [];

        // Preset configurations
        const presets = {
            cubic: {
                name: 'z³ - 1',
                roots: [
                    [1, 0],
                    [-0.5, Math.sqrt(3) / 2],
                    [-0.5, -Math.sqrt(3) / 2]
                ]
            },
            quartic: {
                name: 'z⁴ - 1',
                roots: [
                    [1, 0],
                    [0, 1],
                    [-1, 0],
                    [0, -1]
                ]
            },
            quintic: {
                name: 'z⁵ - 1',
                roots: Array.from({ length: 5 }, (_, i) => {
                    const angle = (2 * Math.PI * i) / 5;
                    return [Math.cos(angle), Math.sin(angle)];
                })
            },
            custom: {
                name: 'Custom',
                roots: [
                    [1.2, 0.3],
                    [-0.8, 0.9],
                    [-0.8, -0.9],
                    [0.5, 1.2],
                    [0.5, -1.2],
                    [-1.5, 0]
                ]
            }
        };

        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader
        const fragmentShaderSource = `#version 300 es
            precision highp float;

            in vec2 v_uv;
            out vec4 fragColor;

            uniform vec2 u_resolution;
            uniform float u_zoom;
            uniform vec2 u_center;
            uniform int u_iterations;
            uniform int u_colorMode;
            uniform int u_rootCount;
            uniform vec2 u_roots[6];
            uniform vec3 u_colors[6];

            // Complex multiplication
            vec2 cmul(vec2 a, vec2 b) {
                return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
            }

            // Complex division
            vec2 cdiv(vec2 a, vec2 b) {
                float denom = b.x * b.x + b.y * b.y;
                return vec2((a.x * b.x + a.y * b.y) / denom,
                           (a.y * b.x - a.x * b.y) / denom);
            }

            // Evaluate polynomial f(z) = (z - r1)(z - r2)...(z - rn)
            vec2 evalPoly(vec2 z) {
                vec2 result = vec2(1.0, 0.0);
                for (int i = 0; i < 6; i++) {
                    if (i >= u_rootCount) break;
                    result = cmul(result, z - u_roots[i]);
                }
                return result;
            }

            // Evaluate derivative f'(z)
            vec2 evalDerivative(vec2 z) {
                vec2 result = vec2(0.0, 0.0);
                for (int i = 0; i < 6; i++) {
                    if (i >= u_rootCount) break;
                    vec2 term = vec2(1.0, 0.0);
                    for (int j = 0; j < 6; j++) {
                        if (j >= u_rootCount) break;
                        if (j != i) {
                            term = cmul(term, z - u_roots[j]);
                        }
                    }
                    result += term;
                }
                return result;
            }

            void main() {
                // Map UV to complex plane
                float aspect = u_resolution.x / u_resolution.y;
                vec2 z;
                z.x = (v_uv.x - 0.5) * 4.0 * aspect / u_zoom + u_center.x;
                z.y = (v_uv.y - 0.5) * 4.0 / u_zoom + u_center.y;

                // Newton-Raphson iteration
                int iterations = 0;
                int convergedRoot = -1;
                float minDist = 1000.0;

                for (int i = 0; i < 200; i++) {
                    if (i >= u_iterations) break;

                    // Check convergence to any root
                    for (int r = 0; r < 6; r++) {
                        if (r >= u_rootCount) break;
                        float dist = length(z - u_roots[r]);
                        if (dist < minDist) {
                            minDist = dist;
                            convergedRoot = r;
                        }
                        if (dist < 0.0001) {
                            iterations = i;
                            break;
                        }
                    }

                    if (minDist < 0.0001) break;

                    // Newton step: z = z - f(z) / f'(z)
                    vec2 fz = evalPoly(z);
                    vec2 fpz = evalDerivative(z);

                    // Avoid division by zero
                    if (length(fpz) < 0.0001) break;

                    z = z - cdiv(fz, fpz);
                    iterations = i;
                }

                // Color based on which root was reached
                vec3 color = vec3(0.0);

                if (convergedRoot >= 0 && convergedRoot < u_rootCount) {
                    color = u_colors[convergedRoot];

                    if (u_colorMode == 0) {
                        // Smooth coloring based on iteration count
                        float t = float(iterations) / float(u_iterations);
                        color *= (1.0 - t * 0.7);
                    } else if (u_colorMode == 1) {
                        // Bands
                        float band = mod(float(iterations), 10.0) / 10.0;
                        color *= 0.5 + 0.5 * band;
                    } else {
                        // Distance-based shading
                        color *= 1.0 - minDist * 2.0;
                    }
                }

                // Add subtle glow at root locations
                for (int r = 0; r < 6; r++) {
                    if (r >= u_rootCount) break;
                    vec2 rootScreen;
                    rootScreen.x = (u_roots[r].x - u_center.x) * u_zoom / (4.0 * aspect) + 0.5;
                    rootScreen.y = (u_roots[r].y - u_center.y) * u_zoom / 4.0 + 0.5;
                    float dist = length(v_uv - rootScreen);
                    if (dist < 0.02) {
                        color = mix(color, u_colors[r], smoothstep(0.02, 0.005, dist));
                    }
                }

                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Create fullscreen quad
        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const uniforms = {
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            zoom: gl.getUniformLocation(program, 'u_zoom'),
            center: gl.getUniformLocation(program, 'u_center'),
            iterations: gl.getUniformLocation(program, 'u_iterations'),
            colorMode: gl.getUniformLocation(program, 'u_colorMode'),
            rootCount: gl.getUniformLocation(program, 'u_rootCount'),
            roots: gl.getUniformLocation(program, 'u_roots'),
            colors: gl.getUniformLocation(program, 'u_colors')
        };

        // Apply preset
        function applyPreset(presetName) {
            const preset = presets[presetName];
            roots = preset.roots.map(r => [...r]);
            polynomialDisplay.textContent = preset.name;
            rootCountDisplay.textContent = roots.length;
            config.centerX = 0;
            config.centerY = 0;
            config.zoom = 1.0;
            zoomSlider.value = 1.0;
            zoomVal.textContent = '1.0x';
            updateRootMarkers();
            render();
        }

        // Create root markers
        function updateRootMarkers() {
            // Remove existing markers
            rootMarkers.forEach(m => m.remove());
            rootMarkers = [];

            roots.forEach((root, i) => {
                const marker = document.createElement('div');
                marker.className = 'root-marker';
                marker.style.backgroundColor = `rgb(${ROOT_COLORS[i].map(c => Math.floor(c * 255)).join(',')})`;
                document.body.appendChild(marker);
                rootMarkers.push(marker);

                // Drag handling
                let dragging = false;

                marker.addEventListener('mousedown', (e) => {
                    dragging = true;
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;

                    // Convert screen to complex coordinates
                    const aspect = canvas.width / canvas.height;
                    const x = ((e.clientX / canvas.width) - 0.5) * 4 * aspect / config.zoom + config.centerX;
                    const y = (0.5 - (e.clientY / canvas.height)) * 4 / config.zoom + config.centerY;

                    roots[i] = [x, y];
                    updateMarkerPositions();
                    render();
                });

                window.addEventListener('mouseup', () => {
                    dragging = false;
                });
            });

            updateMarkerPositions();
        }

        function updateMarkerPositions() {
            const aspect = canvas.width / canvas.height;

            roots.forEach((root, i) => {
                if (rootMarkers[i]) {
                    const screenX = ((root[0] - config.centerX) * config.zoom / (4 * aspect) + 0.5) * canvas.width;
                    const screenY = (0.5 - (root[1] - config.centerY) * config.zoom / 4) * canvas.height;
                    rootMarkers[i].style.left = `${screenX}px`;
                    rootMarkers[i].style.top = `${screenY}px`;
                }
            });
        }

        // Render function
        function render() {
            gl.useProgram(program);

            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.zoom, config.zoom);
            gl.uniform2f(uniforms.center, config.centerX, config.centerY);
            gl.uniform1i(uniforms.iterations, config.iterations);
            gl.uniform1i(uniforms.colorMode, config.colorMode);
            gl.uniform1i(uniforms.rootCount, roots.length);

            // Set roots
            const rootsFlat = [];
            for (let i = 0; i < 6; i++) {
                if (i < roots.length) {
                    rootsFlat.push(roots[i][0], roots[i][1]);
                } else {
                    rootsFlat.push(0, 0);
                }
            }
            gl.uniform2fv(uniforms.roots, new Float32Array(rootsFlat));

            // Set colors
            const colorsFlat = [];
            for (let i = 0; i < 6; i++) {
                colorsFlat.push(...ROOT_COLORS[i]);
            }
            gl.uniform3fv(uniforms.colors, new Float32Array(colorsFlat));

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            updateMarkerPositions();
        }

        // Pan and zoom handling
        let isPanning = false;
        let lastMouseX, lastMouseY;

        canvas.addEventListener('mousedown', (e) => {
            // Check if clicking on a marker
            const clickedMarker = rootMarkers.some(m => {
                const rect = m.getBoundingClientRect();
                return e.clientX >= rect.left && e.clientX <= rect.right &&
                       e.clientY >= rect.top && e.clientY <= rect.bottom;
            });

            if (!clickedMarker) {
                isPanning = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;

            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;

            const aspect = canvas.width / canvas.height;
            config.centerX -= (dx / canvas.width) * 4 * aspect / config.zoom;
            config.centerY += (dy / canvas.height) * 4 / config.zoom;

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            render();
        });

        canvas.addEventListener('mouseup', () => {
            isPanning = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            config.zoom *= zoomFactor;
            config.zoom = Math.max(0.1, Math.min(50, config.zoom));
            zoomSlider.value = config.zoom;
            zoomVal.textContent = `${config.zoom.toFixed(1)}x`;
            render();
        });

        // Control handlers
        iterSlider.addEventListener('input', (e) => {
            config.iterations = parseInt(e.target.value);
            iterVal.textContent = config.iterations;
            iterationsDisplay.textContent = config.iterations;
            render();
        });

        const colorModes = ['Smooth', 'Bands', 'Distance'];
        colorModeSlider.addEventListener('input', (e) => {
            config.colorMode = parseInt(e.target.value);
            colorVal.textContent = colorModes[config.colorMode];
            render();
        });

        zoomSlider.addEventListener('input', (e) => {
            config.zoom = parseFloat(e.target.value);
            zoomVal.textContent = `${config.zoom.toFixed(1)}x`;
            render();
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyPreset(btn.dataset.preset);
            });
        });

        // FPS tracking
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }
        }

        // Initialize
        applyPreset('cubic');
        requestAnimationFrame(animate);
    </script>
</body>
</html>
