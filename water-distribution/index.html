<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Water Distribution Network</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 18px; font-family: sans-serif; z-index: 999; text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 999; }
.panel { background: rgba(0,0,0,0.75); color: #e0e0e0; padding: 12px 16px; border-radius: 8px; font-size: 13px; min-width: 210px; }
.panel label { display: block; margin: 6px 0 2px; color: #fbbf24; }
.panel input[type=range] { width: 100%; }
.panel button { background: #fbbf24; color: #0a0e1a; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 6px; width: 100%; }
.panel button:hover { background: #f59e0b; }
#stats { color: #aaa; margin-top: 8px; line-height: 1.6; }
.btn-group { display: flex; gap: 4px; margin-top: 6px; }
.btn-group button { flex: 1; font-size: 11px; }
.btn-active { background: #f59e0b !important; }
.info { color: #888; font-size: 11px; margin-top: 6px; line-height: 1.4; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Water Distribution Network</div>
<div id="ui">
    <div class="panel">
        <label>Pump Pressure: <span id="ppVal">80</span>%</label>
        <input type="range" id="pumpPressure" min="10" max="100" value="80">
        <label>Demand Level: <span id="dlVal">50</span>%</label>
        <input type="range" id="demand" min="10" max="100" value="50">
        <div class="btn-group">
            <button id="btnValve" class="btn-active">Toggle Valve</button>
            <button id="btnBreak">Break Pipe</button>
            <button id="btnRepair">Repair</button>
        </div>
        <button id="resetBtn">Reset Network</button>
        <div class="info">Click on pipes to toggle valves or break them. Click on junctions to see details.</div>
        <div id="stats"></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;

    let nodes = [];
    let pipes = [];
    let particles = [];
    let pumpPressure = 80;
    let demandLevel = 50;
    let clickMode = 'valve';
    let frame = 0;
    let hoveredPipe = -1;
    let hoveredNode = -1;

    document.getElementById('pumpPressure').addEventListener('input', function() {
        pumpPressure = parseInt(this.value);
        document.getElementById('ppVal').textContent = pumpPressure;
    });
    document.getElementById('demand').addEventListener('input', function() {
        demandLevel = parseInt(this.value);
        document.getElementById('dlVal').textContent = demandLevel;
    });
    document.getElementById('btnValve').addEventListener('click', function() {
        clickMode = 'valve'; setActive(this);
    });
    document.getElementById('btnBreak').addEventListener('click', function() {
        clickMode = 'break'; setActive(this);
    });
    document.getElementById('btnRepair').addEventListener('click', function() {
        clickMode = 'repair'; setActive(this);
    });
    document.getElementById('resetBtn').addEventListener('click', init);

    function setActive(btn) {
        document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('btn-active'));
        btn.classList.add('btn-active');
    }

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
    }

    function dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function init() {
        resize();
        nodes = [];
        pipes = [];
        particles = [];
        frame = 0;

        const margin = 100;
        const cx = W / 2, cy = H / 2;

        // Reservoir (source)
        nodes.push({ x: cx, y: margin, type: 'reservoir', pressure: 100, demand: 0, label: 'Reservoir' });

        // Pump station
        nodes.push({ x: cx, y: margin + 100, type: 'pump', pressure: 0, demand: 0, label: 'Pump' });

        // Main distribution junctions
        const junctions = [
            { x: cx - 200, y: cy - 80, label: 'J1' },
            { x: cx + 200, y: cy - 80, label: 'J2' },
            { x: cx, y: cy, label: 'J3' },
            { x: cx - 250, y: cy + 100, label: 'J4' },
            { x: cx + 250, y: cy + 100, label: 'J5' },
            { x: cx - 120, y: cy + 150, label: 'J6' },
            { x: cx + 120, y: cy + 150, label: 'J7' },
        ];
        junctions.forEach(j => {
            nodes.push({ x: j.x, y: j.y, type: 'junction', pressure: 0, demand: 0, label: j.label });
        });

        // Consumer buildings
        const consumers = [
            { x: cx - 320, y: cy - 40, label: 'B1' },
            { x: cx + 320, y: cy - 40, label: 'B2' },
            { x: cx - 350, y: cy + 160, label: 'B3' },
            { x: cx + 350, y: cy + 160, label: 'B4' },
            { x: cx - 160, y: cy + 250, label: 'B5' },
            { x: cx + 160, y: cy + 250, label: 'B6' },
            { x: cx, y: cy + 280, label: 'B7' },
            { x: cx - 80, y: cy - 150, label: 'B8' },
            { x: cx + 80, y: cy - 150, label: 'B9' },
        ];
        consumers.forEach(c => {
            nodes.push({ x: c.x, y: c.y, type: 'consumer', pressure: 0, demand: 20 + Math.random() * 30, label: c.label });
        });

        // Build pipe connections
        function addPipe(a, b, diameter) {
            pipes.push({
                from: a, to: b,
                diameter: diameter || 1,
                flow: 0,
                pressure: 0,
                open: true,
                broken: false,
                particles: []
            });
        }

        // Reservoir to pump
        addPipe(0, 1, 2);
        // Pump to main junctions
        addPipe(1, 2, 1.5); // To J1
        addPipe(1, 3, 1.5); // To J2
        addPipe(1, 4, 1.8); // To J3
        // Cross connections
        addPipe(2, 4, 1.2); // J1-J3
        addPipe(3, 4, 1.2); // J2-J3
        addPipe(2, 5, 1); // J1-J4
        addPipe(3, 6, 1); // J2-J5
        addPipe(4, 7, 1); // J3-J6
        addPipe(4, 8, 1); // J3-J7
        addPipe(5, 7, 0.8); // J4-J6
        addPipe(6, 8, 0.8); // J5-J7
        addPipe(7, 8, 0.8); // J6-J7
        // To consumers
        addPipe(2, 9, 0.6);   // J1-B1
        addPipe(3, 10, 0.6);  // J2-B2
        addPipe(5, 11, 0.6);  // J4-B3
        addPipe(6, 12, 0.6);  // J5-B4
        addPipe(7, 13, 0.6);  // J6-B5
        addPipe(8, 14, 0.6);  // J7-B6
        addPipe(7, 15, 0.5);  // J6-B7 (via center)
        addPipe(8, 15, 0.5);  // J7-B7
        addPipe(2, 16, 0.6);  // J1-B8
        addPipe(3, 17, 0.6);  // J2-B9
    }

    function simulatePressure() {
        // Reset pressures
        for (const n of nodes) {
            if (n.type === 'reservoir') {
                n.pressure = 100;
            } else if (n.type === 'pump') {
                n.pressure = pumpPressure;
            } else {
                n.pressure = 0;
            }
        }

        // Iterative pressure propagation
        for (let iter = 0; iter < 20; iter++) {
            for (const pipe of pipes) {
                if (!pipe.open || pipe.broken) {
                    pipe.flow = 0;
                    pipe.pressure = 0;
                    continue;
                }

                const fromNode = nodes[pipe.from];
                const toNode = nodes[pipe.to];
                const pDiff = fromNode.pressure - toNode.pressure;

                // Flow proportional to pressure difference and diameter
                pipe.flow = pDiff * pipe.diameter * 0.3;
                pipe.pressure = (fromNode.pressure + toNode.pressure) / 2;

                // Propagate pressure (simplified)
                if (toNode.type !== 'reservoir' && toNode.type !== 'pump') {
                    toNode.pressure += pDiff * 0.08 * pipe.diameter;
                }
                if (fromNode.type !== 'reservoir' && fromNode.type !== 'pump') {
                    fromNode.pressure -= pDiff * 0.02;
                }
            }

            // Consumer demand reduces pressure
            for (const n of nodes) {
                if (n.type === 'consumer') {
                    n.pressure -= n.demand * demandLevel * 0.003;
                    n.pressure = Math.max(0, n.pressure);
                }
            }
        }
    }

    function updateParticles() {
        for (const pipe of pipes) {
            if (!pipe.open || pipe.broken || Math.abs(pipe.flow) < 0.5) {
                pipe.particles = pipe.particles.filter(p => { p.alpha -= 0.05; return p.alpha > 0; });
                continue;
            }

            // Spawn particles
            if (frame % 3 === 0 && pipe.particles.length < 15) {
                const fromN = nodes[pipe.from];
                const toN = nodes[pipe.to];
                const reverse = pipe.flow < 0;
                pipe.particles.push({
                    t: reverse ? 1 : 0,
                    speed: Math.abs(pipe.flow) * 0.003,
                    reverse: reverse,
                    alpha: 1
                });
            }

            // Update
            pipe.particles = pipe.particles.filter(p => {
                if (p.reverse) {
                    p.t -= p.speed;
                    return p.t > 0;
                } else {
                    p.t += p.speed;
                    return p.t < 1;
                }
            });
        }
    }

    function draw() {
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, W, H);

        // Subtle grid
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        for (let x = 0; x < W; x += 40) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
        }
        for (let y = 0; y < H; y += 40) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
        }

        // Draw pipes
        for (let i = 0; i < pipes.length; i++) {
            const pipe = pipes[i];
            const fromN = nodes[pipe.from];
            const toN = nodes[pipe.to];
            const width = 2 + pipe.diameter * 3;

            // Pipe background
            ctx.lineWidth = width;
            if (pipe.broken) {
                ctx.strokeStyle = '#7f1d1d';
                ctx.setLineDash([4, 4]);
            } else if (!pipe.open) {
                ctx.strokeStyle = '#374151';
                ctx.setLineDash([]);
            } else {
                // Color by pressure
                const p = Math.max(0, Math.min(1, pipe.pressure / 100));
                const r = Math.floor((1 - p) * 200);
                const g = Math.floor(p * 100);
                const b = Math.floor(100 + p * 155);
                ctx.strokeStyle = `rgb(${r},${g},${b})`;
                ctx.setLineDash([]);
            }

            // Highlight hovered
            if (i === hoveredPipe) {
                ctx.lineWidth = width + 4;
                ctx.strokeStyle = '#fbbf24';
            }

            ctx.beginPath();
            ctx.moveTo(fromN.x, fromN.y);
            ctx.lineTo(toN.x, toN.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // Valve indicator
            if (!pipe.open && !pipe.broken) {
                const mx = (fromN.x + toN.x) / 2;
                const my = (fromN.y + toN.y) / 2;
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(mx, my, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(mx - 3, my - 3);
                ctx.lineTo(mx + 3, my + 3);
                ctx.moveTo(mx + 3, my - 3);
                ctx.lineTo(mx - 3, my + 3);
                ctx.stroke();
            }

            // Break indicator
            if (pipe.broken) {
                const mx = (fromN.x + toN.x) / 2;
                const my = (fromN.y + toN.y) / 2;
                // Leak particles
                for (let j = 0; j < 3; j++) {
                    const lx = mx + (Math.random() - 0.5) * 30;
                    const ly = my + Math.random() * 20;
                    ctx.fillStyle = `rgba(59, 130, 246, ${0.3 + Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(lx, ly, 1.5 + Math.random(), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('BREAK', mx, my - 12);
            }

            // Flow particles
            for (const p of pipe.particles) {
                const px = fromN.x + (toN.x - fromN.x) * p.t;
                const py = fromN.y + (toN.y - fromN.y) * p.t;
                ctx.fillStyle = `rgba(96, 165, 250, ${p.alpha * 0.8})`;
                ctx.shadowColor = '#60a5fa';
                ctx.shadowBlur = 4;
                ctx.beginPath();
                ctx.arc(px, py, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Draw nodes
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            let color, size, glowColor;

            if (node.type === 'reservoir') {
                color = '#3b82f6'; size = 18; glowColor = 'rgba(59,130,246,0.3)';
            } else if (node.type === 'pump') {
                color = '#22c55e'; size = 14; glowColor = 'rgba(34,197,94,0.3)';
            } else if (node.type === 'consumer') {
                const supplied = node.pressure > 20;
                color = supplied ? '#fbbf24' : '#ef4444';
                size = 10;
                glowColor = supplied ? 'rgba(251,191,36,0.2)' : 'rgba(239,68,68,0.2)';
            } else {
                color = '#94a3b8'; size = 8; glowColor = 'rgba(148,163,184,0.2)';
            }

            if (i === hoveredNode) {
                glowColor = 'rgba(251,191,36,0.4)';
            }

            // Glow
            const grad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, size * 2);
            grad.addColorStop(0, glowColor);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(node.x, node.y, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Node
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
            ctx.fill();

            // Pressure indicator
            if (node.type !== 'reservoir') {
                const pNorm = Math.max(0, Math.min(1, node.pressure / 100));
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size + 3, -Math.PI / 2, -Math.PI / 2 + pNorm * Math.PI * 2);
                ctx.stroke();
            }

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = node.type === 'reservoir' || node.type === 'pump' ? 'bold 10px sans-serif' : '9px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (node.type === 'reservoir') {
                ctx.fillText('RES', node.x, node.y);
            } else if (node.type === 'pump') {
                ctx.fillText('PUMP', node.x, node.y);
            }

            // Pressure text
            ctx.fillStyle = '#aaa';
            ctx.font = '10px sans-serif';
            ctx.fillText(Math.round(node.pressure) + '%', node.x, node.y + size + 14);
        }

        // Stats
        const consumers = nodes.filter(n => n.type === 'consumer');
        const supplied = consumers.filter(n => n.pressure > 20).length;
        const avgPressure = consumers.reduce((s, n) => s + n.pressure, 0) / consumers.length;
        const brokenPipes = pipes.filter(p => p.broken).length;
        const closedValves = pipes.filter(p => !p.open && !p.broken).length;
        const totalFlow = pipes.reduce((s, p) => s + Math.abs(p.flow), 0);

        document.getElementById('stats').innerHTML =
            `Buildings Supplied: ${supplied}/${consumers.length}<br>` +
            `Avg Pressure: ${avgPressure.toFixed(1)}%<br>` +
            `Total Flow: ${totalFlow.toFixed(1)}<br>` +
            `Broken Pipes: ${brokenPipes}<br>` +
            `Closed Valves: ${closedValves}<br>` +
            `Pump Output: ${pumpPressure}%`;
    }

    function findClosestPipe(mx, my) {
        let best = -1, bestDist = 20;
        for (let i = 0; i < pipes.length; i++) {
            const fromN = nodes[pipes[i].from];
            const toN = nodes[pipes[i].to];
            // Point-to-segment distance
            const dx = toN.x - fromN.x, dy = toN.y - fromN.y;
            const len2 = dx * dx + dy * dy;
            let t = Math.max(0, Math.min(1, ((mx - fromN.x) * dx + (my - fromN.y) * dy) / len2));
            const px = fromN.x + t * dx, py = fromN.y + t * dy;
            const d = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
            if (d < bestDist) {
                bestDist = d;
                best = i;
            }
        }
        return best;
    }

    canvas.addEventListener('mousemove', function(e) {
        hoveredPipe = findClosestPipe(e.clientX, e.clientY);
        hoveredNode = -1;
        for (let i = 0; i < nodes.length; i++) {
            if (dist(nodes[i], { x: e.clientX, y: e.clientY }) < 15) {
                hoveredNode = i;
                break;
            }
        }
    });

    canvas.addEventListener('click', function(e) {
        const pipeIdx = findClosestPipe(e.clientX, e.clientY);
        if (pipeIdx >= 0) {
            const pipe = pipes[pipeIdx];
            if (clickMode === 'valve') {
                if (!pipe.broken) pipe.open = !pipe.open;
            } else if (clickMode === 'break') {
                pipe.broken = true;
                pipe.open = false;
            } else if (clickMode === 'repair') {
                pipe.broken = false;
                pipe.open = true;
            }
        }
    });

    window.addEventListener('resize', function() { resize(); init(); });

    function animate() {
        frame++;
        simulatePressure();
        updateParticles();
        draw();
        requestAnimationFrame(animate);
    }

    init();
    animate();
})();
</script>
</body>
</html>
