<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Chain Patterns</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            width: 220px;
        }
        h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }
        button {
            width: 100%;
            padding: 8px;
            margin: 3px 0;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
        }
        button:hover {
            background: #764ba2;
        }
        .info {
            font-size: 10px;
            color: #aaa;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h4>Fractal Patterns</h4>
        <div class="info">Hierarchical chain branching with self-similar patterns at multiple scales</div>
        <button onclick="setPattern('tree')">Tree Branching</button>
        <button onclick="setPattern('spiral')">Fibonacci Spiral</button>
        <button onclick="setPattern('mandelbrot')">Mandelbrot Set</button>
        <button onclick="setPattern('koch')">Koch Snowflake</button>
        <button onclick="setPattern('sierpinski')">Sierpinski Triangle</button>
    </div>

    <script>
        /*
# Goal
Create fractal-inspired chain patterns where agents follow self-similar branching rules,
generating beautiful mathematical patterns through agent-based modeling.

# Approach
- Define fractal generation rules for different patterns
- Agents position based on fractal coordinates
- Hierarchical chain branching
- Self-similar patterns at multiple scales
- Mathematical beauty through emergence

# Key Features
- 5 fractal pattern types
- Hierarchical branching
- Self-similarity
- Mathematical precision
- Generative art aesthetic

# Innovation
- Combines fractals with agent systems
- Demonstrates mathematical beauty
- Educational for fractal geometry
- Unique visual aesthetic
        */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const POPULATION = 120;
        let pattern = 'tree';

        class Turtle {
            constructor(level = 0, angle = 0, parentX = null, parentY = null) {
                this.level = level;
                this.angle = angle;

                const center = { x: canvas.width / 2, y: canvas.height / 2 };

                // Position based on fractal pattern
                if (parentX === null || parentY === null) {
                    this.x = center.x;
                    this.y = center.y + 200;
                } else {
                    this.x = parentX;
                    this.y = parentY;
                }

                this.targetX = this.x;
                this.targetY = this.y;

                this.heading = angle;
                this.leader = null;
                this.follower = null;
                this.size = Math.max(3, 8 - level);
                this.chainHue = (level * 40) % 360;
            }

            calculateFractalPosition() {
                const center = { x: canvas.width / 2, y: canvas.height / 2 };

                switch (pattern) {
                    case 'tree':
                        const treeLength = 150 / (this.level + 1);
                        const treeAngle = this.angle + (this.level % 2 === 0 ? 0.5 : -0.5);
                        this.targetX = this.x + Math.cos(treeAngle) * treeLength;
                        this.targetY = this.y + Math.sin(treeAngle) * treeLength;
                        break;

                    case 'spiral':
                        const phi = 1.618033988749895; // Golden ratio
                        const spiralAngle = this.level * 2.399963;
                        const spiralRadius = phi * this.level * 5;
                        this.targetX = center.x + Math.cos(spiralAngle) * spiralRadius;
                        this.targetY = center.y + Math.sin(spiralAngle) * spiralRadius;
                        break;

                    case 'mandelbrot':
                        // Map to Mandelbrot interesting region
                        const scale = 0.003;
                        const offsetX = -0.5;
                        const offsetY = 0;
                        const mandX = (this.level * 137.5 % 360) * Math.PI / 180;
                        const mandY = this.level * 0.5;
                        this.targetX = center.x + Math.cos(mandX) * mandY * 3;
                        this.targetY = center.y + Math.sin(mandX) * mandY * 3;
                        break;

                    case 'koch':
                        // Koch snowflake vertices
                        const kochAngle = (this.level * 60) * Math.PI / 180;
                        const kochRadius = 150 + this.level * 3;
                        this.targetX = center.x + Math.cos(kochAngle) * kochRadius;
                        this.targetY = center.y + Math.sin(kochAngle) * kochRadius;
                        break;

                    case 'sierpinski':
                        // Sierpinski triangle
                        const sierpLevel = this.level % 3;
                        const sierpRadius = 200 - this.level * 2;
                        const sierpAngle = sierpLevel * Math.PI * 2 / 3 - Math.PI / 2;
                        this.targetX = center.x + Math.cos(sierpAngle) * sierpRadius;
                        this.targetY = center.y + Math.sin(sierpAngle) * sierpRadius;
                        break;
                }
            }

            update() {
                this.calculateFractalPosition();

                // Smoothly move to fractal position
                this.x += (this.targetX - this.x) * 0.05;
                this.y += (this.targetY - this.y) * 0.05;

                // Follow leader if attached
                if (this.leader) {
                    const dx = this.leader.x - this.x;
                    const dy = this.leader.y - this.y;

                    this.x += dx * 0.03;
                    this.y += dy * 0.03;
                }
            }

            draw() {
                const brightness = 70 - this.level * 5;
                const color = `hsl(${this.chainHue}, 100%, ${brightness}%)`;

                if (this.leader) {
                    const gradient = ctx.createLinearGradient(
                        this.x, this.y,
                        this.leader.x, this.leader.y
                    );
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, `hsl(${this.leader.chainHue}, 100%, ${70 - this.leader.level * 5}%)`);

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = this.size * 0.6;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.leader.x, this.leader.y);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        let turtles = [];

        function initFractal() {
            turtles = [];

            // Create hierarchical structure
            for (let level = 0; level < 8; level++) {
                const count = Math.floor(POPULATION / 8);
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const turtle = new Turtle(level, angle);
                    turtles.push(turtle);
                }
            }

            // Connect in hierarchical fashion
            for (let i = 1; i < turtles.length; i++) {
                const turtle = turtles[i];
                const level = turtle.level;

                if (level > 0) {
                    // Find parent from previous level
                    const prevLevel = turtles.filter(t => t.level === level - 1);
                    if (prevLevel.length > 0) {
                        const parent = prevLevel[Math.floor(Math.random() * prevLevel.length)];
                        parent.follower = turtle;
                        turtle.leader = parent;
                    }
                }
            }
        }

        function setPattern(p) {
            pattern = p;
            initFractal();
        }

        initFractal();

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let turtle of turtles) {
                turtle.update();
            }

            for (let turtle of turtles) {
                turtle.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
