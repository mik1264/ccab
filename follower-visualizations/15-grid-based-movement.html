<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid-Based Movement</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /*
# Goal
Constrain turtle movement to a grid, creating retro, digital-looking chains
reminiscent of early computer graphics.

# Approach
- Snap turtle positions to grid cells
- Move in cardinal/diagonal directions
- Smooth interpolation between grid cells
- Creates pixelated, retro aesthetic

# Key Features
- Grid-aligned movement
- Discrete directional changes
- Retro computer aesthetic
- Smooth grid transitions
        */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 900;
        canvas.height = 700;

        const POPULATION = 60;
        const GRID_SIZE = 20;
        const NEAR_RADIUS = 2; // in grid cells
        const FAR_RADIUS = 4;
        const MOVE_SPEED = 0.15;

        class Turtle {
            constructor() {
                this.gridX = Math.floor(Math.random() * (canvas.width / GRID_SIZE));
                this.gridY = Math.floor(Math.random() * (canvas.height / GRID_SIZE));
                this.x = this.gridX * GRID_SIZE + GRID_SIZE / 2;
                this.y = this.gridY * GRID_SIZE + GRID_SIZE / 2;
                this.targetX = this.x;
                this.targetY = this.y;
                this.leader = null;
                this.follower = null;
                this.chainHue = Math.random() * 360;
                this.size = 6;
                this.direction = Math.floor(Math.random() * 8); // 8 directions
            }

            attachTurtle(turtles) {
                if (this.leader !== null) return;

                const distance = NEAR_RADIUS + Math.floor(Math.random() * (FAR_RADIUS - NEAR_RADIUS + 1));
                const angle = Math.floor(Math.random() * 8); // 8 directions

                const directions = [
                    [1, 0], [1, 1], [0, 1], [-1, 1],
                    [-1, 0], [-1, -1], [0, -1], [1, -1]
                ];

                const [dx, dy] = directions[angle];
                const targetGridX = this.gridX + dx * distance;
                const targetGridY = this.gridY + dy * distance;

                let candidate = null;
                let minDist = 2;

                for (let turtle of turtles) {
                    if (turtle === this || turtle.follower !== null) continue;

                    const dist = Math.abs(turtle.gridX - targetGridX) +
                                Math.abs(turtle.gridY - targetGridY);

                    if (dist < minDist) {
                        candidate = turtle;
                        minDist = dist;
                    }
                }

                if (candidate) {
                    candidate.follower = this;
                    this.leader = candidate;
                    this.chainHue = candidate.chainHue;
                }
            }

            getColor() {
                if (this.leader === null && this.follower === null) {
                    return `hsl(0, 0%, 60%)`;
                } else {
                    return `hsl(${this.chainHue}, 100%, 60%)`;
                }
            }

            update() {
                // Smooth move to target position
                this.x += (this.targetX - this.x) * MOVE_SPEED;
                this.y += (this.targetY - this.y) * MOVE_SPEED;

                // Check if close enough to target to pick new one
                const dist = Math.sqrt((this.targetX - this.x) ** 2 + (this.targetY - this.y) ** 2);

                if (dist < 2) {
                    this.gridX = Math.round(this.x / GRID_SIZE);
                    this.gridY = Math.round(this.y / GRID_SIZE);

                    if (this.leader === null) {
                        // Random direction
                        if (Math.random() < 0.3) {
                            this.direction = Math.floor(Math.random() * 8);
                        }
                    } else {
                        // Move toward leader
                        const dx = this.leader.gridX - this.gridX;
                        const dy = this.leader.gridY - this.gridY;

                        if (Math.abs(dx) > Math.abs(dy)) {
                            this.direction = dx > 0 ? 0 : 4;
                        } else {
                            this.direction = dy > 0 ? 2 : 6;
                        }
                    }

                    const directions = [
                        [1, 0], [1, 1], [0, 1], [-1, 1],
                        [-1, 0], [-1, -1], [0, -1], [1, -1]
                    ];

                    const [dx, dy] = directions[this.direction];
                    let newGridX = this.gridX + dx;
                    let newGridY = this.gridY + dy;

                    // Wrap
                    newGridX = (newGridX + canvas.width / GRID_SIZE) % (canvas.width / GRID_SIZE);
                    newGridY = (newGridY + canvas.height / GRID_SIZE) % (canvas.height / GRID_SIZE);

                    this.targetX = newGridX * GRID_SIZE + GRID_SIZE / 2;
                    this.targetY = newGridY * GRID_SIZE + GRID_SIZE / 2;
                }
            }

            draw() {
                const color = this.getColor();

                if (this.leader) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.leader.x, this.leader.y);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Draw as square for grid aesthetic
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.fillRect(
                    this.x - this.size / 2,
                    this.y - this.size / 2,
                    this.size,
                    this.size
                );
                ctx.shadowBlur = 0;
            }
        }

        const turtles = [];
        for (let i = 0; i < POPULATION; i++) {
            turtles.push(new Turtle());
        }

        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            for (let turtle of turtles) {
                if (turtle.leader === null) {
                    turtle.attachTurtle(turtles);
                }
            }

            for (let turtle of turtles) {
                turtle.update();
            }

            for (let turtle of turtles) {
                turtle.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
