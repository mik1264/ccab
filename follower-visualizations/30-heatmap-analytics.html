<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time-Lapse Heatmap Analytics</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
        }
        #analysis {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }
        h3 {
            margin: 0 0 15px 0;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        .mode-btn {
            width: 100%;
            padding: 8px;
            margin: 3px 0;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
        }
        .mode-btn.active {
            background: #667eea;
        }
        .mode-btn:hover {
            background: #555;
        }
        .mode-btn.active:hover {
            background: #764ba2;
        }
        .metric {
            margin: 10px 0;
            padding: 10px;
            background: rgba(102, 126, 234, 0.2);
            border-radius: 5px;
            font-size: 11px;
        }
        .metric-label {
            color: #aaa;
            display: block;
            margin-bottom: 5px;
        }
        .metric-value {
            color: #667eea;
            font-size: 16px;
            font-weight: bold;
        }
        .legend {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 3px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <canvas id="heatmapCanvas"></canvas>
    <canvas id="agentCanvas"></canvas>
    <div id="analysis">
        <h3>ðŸ“Š Heatmap Analytics</h3>

        <button class="mode-btn active" onclick="setMode('density')">Density Heatmap</button>
        <button class="mode-btn" onclick="setMode('chain')">Chain Activity</button>
        <button class="mode-btn" onclick="setMode('velocity')">Velocity Field</button>
        <button class="mode-btn" onclick="setMode('connection')">Connection Frequency</button>

        <div class="metric">
            <span class="metric-label">Hotspot Temperature</span>
            <span class="metric-value" id="maxDensity">0</span>
        </div>

        <div class="metric">
            <span class="metric-label">Coverage Area</span>
            <span class="metric-value" id="coverage">0%</span>
        </div>

        <div class="metric">
            <span class="metric-label">Activity Centers</span>
            <span class="metric-value" id="centers">0</span>
        </div>

        <div class="legend">
            <div style="font-weight: bold; margin-bottom: 8px;">Heat Scale</div>
            <div class="legend-item">
                <div class="legend-color" style="background: #0000ff;"></div>
                <span>Low Activity</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff00;"></div>
                <span>Medium</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffff00;"></div>
                <span>High</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff0000;"></div>
                <span>Very High</span>
            </div>
        </div>
    </div>

    <script>
        /*
# Goal
Create comprehensive heatmap analytics showing spatial patterns of chain formation,
movement density, and activity over time with multiple visualization modes.

# Approach
- Dual-canvas rendering (heatmap + agents)
- Track spatial statistics over time
- Multiple heatmap modes (density, chain activity, velocity, connections)
- Real-time analytics with hotspot detection
- Color-coded intensity visualization

# Key Features
- 4 visualization modes
- Temporal heat accumulation
- Hotspot detection
- Coverage analysis
- Activity center identification

# Innovation
- Combines simulation with analytics
- Educational for data visualization
- Reveals emergent spatial patterns
- Research-quality visualization tool
        */

        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const agentCanvas = document.getElementById('agentCanvas');
        const heatCtx = heatmapCanvas.getContext('2d');
        const agentCtx = agentCanvas.getContext('2d');

        heatmapCanvas.width = agentCanvas.width = window.innerWidth - 320;
        heatmapCanvas.height = agentCanvas.height = window.innerHeight;

        heatmapCanvas.style.position = 'absolute';
        heatmapCanvas.style.left = '0';
        heatmapCanvas.style.top = '0';

        agentCanvas.style.position = 'absolute';
        agentCanvas.style.left = '0';
        agentCanvas.style.top = '0';

        const POPULATION = 90;
        const NEAR_RADIUS = 35;
        const FAR_RADIUS = 70;
        const SPEED = 1.5;
        const GRID_SIZE = 20;

        let heatmapMode = 'density';
        const heatGrid = {};

        class Turtle {
            constructor() {
                this.x = Math.random() * agentCanvas.width;
                this.y = Math.random() * agentCanvas.height;
                this.prevX = this.x;
                this.prevY = this.y;
                this.heading = Math.random() * Math.PI * 2;
                this.leader = null;
                this.follower = null;
                this.chainHue = Math.random() * 360;
                this.size = 5;
                this.connectionsMade = 0;
            }

            attachTurtle(turtles) {
                if (this.leader !== null) return;

                const distance = NEAR_RADIUS + Math.random() * (FAR_RADIUS - NEAR_RADIUS);
                const angle = Math.random() * Math.PI * 2;

                const targetX = this.x + Math.cos(angle) * distance;
                const targetY = this.y + Math.sin(angle) * distance;

                let candidate = null;
                let minDist = 20;

                for (let turtle of turtles) {
                    if (turtle === this || turtle.follower !== null) continue;

                    const dx = turtle.x - targetX;
                    const dy = turtle.y - targetY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < minDist) {
                        candidate = turtle;
                        minDist = dist;
                    }
                }

                if (candidate) {
                    candidate.follower = this;
                    this.leader = candidate;
                    this.chainHue = candidate.chainHue;
                    this.connectionsMade++;
                    recordHeat(this.x, this.y, 'connection', 10);
                }
            }

            update() {
                this.prevX = this.x;
                this.prevY = this.y;

                if (this.leader === null) {
                    this.heading += (Math.random() - 0.5) * 0.2;
                } else {
                    const dx = this.leader.x - this.x;
                    const dy = this.leader.y - this.y;
                    this.heading = Math.atan2(dy, dx);
                }

                this.x += Math.cos(this.heading) * SPEED;
                this.y += Math.sin(this.heading) * SPEED;

                if (this.x < 0) this.x = agentCanvas.width;
                if (this.x > agentCanvas.width) this.x = 0;
                if (this.y < 0) this.y = agentCanvas.height;
                if (this.y > agentCanvas.height) this.y = 0;

                // Record heat
                recordHeat(this.x, this.y, 'density', 1);

                if (this.leader || this.follower) {
                    recordHeat(this.x, this.y, 'chain', 2);
                }

                const velocity = Math.sqrt(
                    (this.x - this.prevX) ** 2 + (this.y - this.prevY) ** 2
                );
                recordHeat(this.x, this.y, 'velocity', velocity * 5);
            }

            draw() {
                const color = this.leader || this.follower ?
                    `hsl(${this.chainHue}, 100%, 55%)` : `hsl(0, 0%, 50%)`;

                if (this.leader) {
                    agentCtx.strokeStyle = color;
                    agentCtx.lineWidth = 2;
                    agentCtx.shadowBlur = 8;
                    agentCtx.shadowColor = color;
                    agentCtx.beginPath();
                    agentCtx.moveTo(this.x, this.y);
                    agentCtx.lineTo(this.leader.x, this.leader.y);
                    agentCtx.stroke();
                    agentCtx.shadowBlur = 0;
                }

                agentCtx.fillStyle = color;
                agentCtx.shadowBlur = 10;
                agentCtx.shadowColor = color;
                agentCtx.beginPath();
                agentCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                agentCtx.fill();
                agentCtx.shadowBlur = 0;
            }
        }

        const turtles = [];
        for (let i = 0; i < POPULATION; i++) {
            turtles.push(new Turtle());
        }

        function recordHeat(x, y, type, value) {
            const gridX = Math.floor(x / GRID_SIZE);
            const gridY = Math.floor(y / GRID_SIZE);
            const key = `${gridX},${gridY}`;

            if (!heatGrid[key]) {
                heatGrid[key] = { density: 0, chain: 0, velocity: 0, connection: 0 };
            }

            heatGrid[key][type] = (heatGrid[key][type] || 0) + value;
        }

        function drawHeatmap() {
            heatCtx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);

            let maxHeat = 0;
            const cellsWithHeat = [];

            for (let key in heatGrid) {
                const value = heatGrid[key][heatmapMode] || 0;
                maxHeat = Math.max(maxHeat, value);
                if (value > 0) {
                    cellsWithHeat.push(key);
                }
            }

            for (let key in heatGrid) {
                const [gridX, gridY] = key.split(',').map(Number);
                const value = heatGrid[key][heatmapMode] || 0;

                if (value > 0) {
                    const intensity = value / maxHeat;

                    // Color gradient: blue -> green -> yellow -> red
                    let r, g, b;
                    if (intensity < 0.25) {
                        const t = intensity / 0.25;
                        r = 0;
                        g = Math.floor(t * 255);
                        b = 255;
                    } else if (intensity < 0.5) {
                        const t = (intensity - 0.25) / 0.25;
                        r = 0;
                        g = 255;
                        b = Math.floor((1 - t) * 255);
                    } else if (intensity < 0.75) {
                        const t = (intensity - 0.5) / 0.25;
                        r = Math.floor(t * 255);
                        g = 255;
                        b = 0;
                    } else {
                        const t = (intensity - 0.75) / 0.25;
                        r = 255;
                        g = Math.floor((1 - t) * 255);
                        b = 0;
                    }

                    heatCtx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    heatCtx.fillRect(gridX * GRID_SIZE, gridY * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                }

                // Decay
                heatGrid[key][heatmapMode] *= 0.98;
            }

            // Update metrics
            document.getElementById('maxDensity').textContent = Math.round(maxHeat);
            const totalCells = (agentCanvas.width / GRID_SIZE) * (agentCanvas.height / GRID_SIZE);
            const coverage = (cellsWithHeat.length / totalCells * 100).toFixed(1);
            document.getElementById('coverage').textContent = `${coverage}%`;

            // Count activity centers (local maxima)
            const centers = cellsWithHeat.filter(key => {
                const value = heatGrid[key][heatmapMode];
                const [gx, gy] = key.split(',').map(Number);

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const nkey = `${gx + dx},${gy + dy}`;
                        if (heatGrid[nkey] && heatGrid[nkey][heatmapMode] > value) {
                            return false;
                        }
                    }
                }
                return value > maxHeat * 0.5;
            }).length;

            document.getElementById('centers').textContent = centers;
        }

        function setMode(mode) {
            heatmapMode = mode;

            const buttons = document.querySelectorAll('.mode-btn');
            buttons.forEach((btn, idx) => {
                const modes = ['density', 'chain', 'velocity', 'connection'];
                if (modes[idx] === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function animate() {
            agentCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            agentCtx.fillRect(0, 0, agentCanvas.width, agentCanvas.height);

            drawHeatmap();

            for (let turtle of turtles) {
                if (turtle.leader === null) {
                    turtle.attachTurtle(turtles);
                }
            }

            for (let turtle of turtles) {
                turtle.update();
            }

            for (let turtle of turtles) {
                turtle.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
