<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mirror Symmetry Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a18; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; cursor: crosshair; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(200,150,255,0.15); border: 1px solid rgba(200,150,255,0.5); color: #c9f; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(200,150,255,0.25); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(200,150,255,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #c9f; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Draw on one side • Notes mirror across axes</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="symmetryBtn">4-Fold</button>
        <button id="clearBtn">Clear</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        let symmetry = 2; // 2 = bilateral, 4 = 4-fold, 8 = 8-fold
        let angle = 0;
        const notes = [];

        const scale = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];

        class Note {
            constructor(x, y, isOriginal = true) {
                this.x = x;
                this.y = y;
                this.isOriginal = isOriginal;
                this.radius = 15;
                this.hue = Math.random() * 60 + 240; // Purple range
                this.glow = 0;
                this.noteIndex = Math.floor(((y / height) * scale.length));
            }

            play() {
                const freq = scale[Math.max(0, Math.min(scale.length - 1, this.noteIndex))];

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = this.isOriginal ? 'sine' : 'triangle';
                osc.frequency.value = freq;

                gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);

                this.glow = 1;
            }

            draw() {
                if (this.glow > 0) {
                    ctx.shadowColor = `hsl(${this.hue}, 70%, 60%)`;
                    ctx.shadowBlur = 25 * this.glow;
                    this.glow -= 0.03;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.isOriginal ?
                    `hsl(${this.hue}, 70%, 55%)` :
                    `hsla(${this.hue}, 60%, 50%, 0.6)`;
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        function createMirroredNotes(x, y) {
            const centerX = width / 2;
            const centerY = height / 2;
            const newNotes = [];

            // Original note
            newNotes.push(new Note(x, y, true));

            if (symmetry >= 2) {
                // Horizontal mirror
                newNotes.push(new Note(2 * centerX - x, y, false));
            }

            if (symmetry >= 4) {
                // Vertical mirror
                newNotes.push(new Note(x, 2 * centerY - y, false));
                newNotes.push(new Note(2 * centerX - x, 2 * centerY - y, false));
            }

            if (symmetry >= 8) {
                // Diagonal mirrors
                const dx = x - centerX;
                const dy = y - centerY;
                newNotes.push(new Note(centerX + dy, centerY + dx, false));
                newNotes.push(new Note(centerX - dy, centerY + dx, false));
                newNotes.push(new Note(centerX + dy, centerY - dx, false));
                newNotes.push(new Note(centerX - dy, centerY - dx, false));
            }

            return newNotes;
        }

        function drawAxes() {
            const centerX = width / 2;
            const centerY = height / 2;

            ctx.strokeStyle = 'rgba(200,150,255,0.2)';
            ctx.lineWidth = 1;

            // Horizontal axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();

            // Vertical axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();

            if (symmetry >= 4) {
                // Diagonal axes
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(width, height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(width, 0);
                ctx.lineTo(0, height);
                ctx.stroke();
            }

            if (symmetry >= 8) {
                // More diagonal axes
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(0, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(width, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX, height);
                ctx.lineTo(0, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX, height);
                ctx.lineTo(width, centerY);
                ctx.stroke();
            }

            // Draw symmetry indicator
            ctx.beginPath();
            ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(200,150,255,0.3)';
            ctx.stroke();

            ctx.font = 'bold 20px Segoe UI';
            ctx.fillStyle = 'rgba(200,150,255,0.5)';
            ctx.textAlign = 'center';
            ctx.fillText(`${symmetry}×`, centerX, centerY + 7);
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 24, 0.15)';
            ctx.fillRect(0, 0, width, height);

            drawAxes();

            // Draw playhead (rotating line from center)
            if (isPlaying) {
                const centerX = width / 2;
                const centerY = height / 2;
                const len = Math.max(width, height);

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * len,
                    centerY + Math.sin(angle) * len
                );
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Check for notes to trigger
                notes.forEach(note => {
                    const noteAngle = Math.atan2(note.y - centerY, note.x - centerX);
                    let normalizedNoteAngle = noteAngle;
                    if (normalizedNoteAngle < 0) normalizedNoteAngle += Math.PI * 2;

                    let normalizedPlayAngle = angle % (Math.PI * 2);
                    if (normalizedPlayAngle < 0) normalizedPlayAngle += Math.PI * 2;

                    const angleDiff = Math.abs(normalizedNoteAngle - normalizedPlayAngle);
                    if ((angleDiff < 0.03 || angleDiff > Math.PI * 2 - 0.03) && note.glow === 0) {
                        note.play();
                    }
                });

                angle += 0.02;
            }

            // Draw notes
            notes.forEach(note => note.draw());

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const newNotes = createMirroredNotes(e.clientX, e.clientY);
            notes.push(...newNotes);

            // Play original note
            newNotes[0].play();
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('symmetryBtn').addEventListener('click', function() {
            symmetry = symmetry === 2 ? 4 : (symmetry === 4 ? 8 : 2);
            this.textContent = `${symmetry}-Fold`;
            notes.length = 0; // Clear on symmetry change
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            notes.length = 0;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
