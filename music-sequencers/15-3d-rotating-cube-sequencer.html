<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotating Cube Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(0,255,200,0.15);
            border: 1px solid rgba(0,255,200,0.5);
            color: #0fc8;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,255,200,0.25); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0,255,200,0.8);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #0fc8; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click cube faces to toggle notes • Rotation creates patterns</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="randomBtn">Random</button>
        <button id="clearBtn">Clear</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        let rotationX = 0.3;
        let rotationY = 0;
        let rotationZ = 0;

        // 6 faces, each 4x4 grid of notes
        const gridSize = 4;
        const faces = [];
        const faceColors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#00d2d3'];
        const faceNames = ['Front', 'Back', 'Top', 'Bottom', 'Left', 'Right'];

        // Pentatonic scale across octaves
        const notes = [
            130.81, 146.83, 164.81, 196.00, 220.00,
            261.63, 293.66, 329.63, 392.00, 440.00,
            523.25, 587.33, 659.25, 783.99, 880.00,
            1046.50
        ];

        // Cube vertices
        const cubeSize = 150;
        const vertices = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ].map(v => v.map(c => c * cubeSize));

        // Face definitions (vertex indices)
        const faceVertices = [
            [4, 5, 6, 7], // Front
            [1, 0, 3, 2], // Back
            [3, 7, 6, 2], // Top
            [0, 4, 5, 1], // Bottom
            [0, 3, 7, 4], // Left
            [5, 6, 2, 1]  // Right
        ];

        function initFaces() {
            faces.length = 0;
            for (let f = 0; f < 6; f++) {
                faces[f] = [];
                for (let r = 0; r < gridSize; r++) {
                    faces[f][r] = [];
                    for (let c = 0; c < gridSize; c++) {
                        faces[f][r][c] = { active: false, glow: 0 };
                    }
                }
            }
        }

        function rotatePoint(point, rx, ry, rz) {
            let [x, y, z] = point;

            // Rotate X
            let temp = y;
            y = y * Math.cos(rx) - z * Math.sin(rx);
            z = temp * Math.sin(rx) + z * Math.cos(rx);

            // Rotate Y
            temp = x;
            x = x * Math.cos(ry) + z * Math.sin(ry);
            z = -temp * Math.sin(ry) + z * Math.cos(ry);

            // Rotate Z
            temp = x;
            x = x * Math.cos(rz) - y * Math.sin(rz);
            y = temp * Math.sin(rz) + y * Math.cos(rz);

            return [x, y, z];
        }

        function project(point) {
            const [x, y, z] = point;
            const scale = 400 / (400 + z);
            return {
                x: width / 2 + x * scale,
                y: height / 2 + y * scale,
                z: z,
                scale: scale
            };
        }

        function playNote(faceIndex, row, col) {
            const noteIndex = (faceIndex * 2 + row + col) % notes.length;
            const freq = notes[noteIndex];

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = faceIndex % 2 === 0 ? 'sine' : 'triangle';
            osc.frequency.value = freq;

            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);

            faces[faceIndex][row][col].glow = 1;
        }

        function draw() {
            ctx.fillStyle = 'rgba(12, 12, 30, 0.2)';
            ctx.fillRect(0, 0, width, height);

            if (isPlaying) {
                rotationY += 0.01;
                rotationX = Math.sin(Date.now() * 0.0005) * 0.3;
            }

            // Transform vertices
            const transformed = vertices.map(v => rotatePoint(v, rotationX, rotationY, rotationZ));
            const projected = transformed.map(v => project(v));

            // Calculate face z-order
            const faceDepths = faceVertices.map((indices, i) => {
                const avgZ = indices.reduce((sum, idx) => sum + transformed[idx][2], 0) / 4;
                return { index: i, z: avgZ };
            }).sort((a, b) => a.z - b.z);

            // Trigger notes for front-facing faces
            if (isPlaying) {
                const frontFaces = faceDepths.filter(f => f.z > 0);
                const scanLine = ((Date.now() / 200) % gridSize) | 0;

                frontFaces.forEach(({ index }) => {
                    for (let c = 0; c < gridSize; c++) {
                        if (faces[index][scanLine][c].active && !faces[index][scanLine][c].triggered) {
                            playNote(index, scanLine, c);
                            faces[index][scanLine][c].triggered = true;
                        }
                    }
                });

                // Reset triggers
                const prevLine = (scanLine - 1 + gridSize) % gridSize;
                frontFaces.forEach(({ index }) => {
                    for (let c = 0; c < gridSize; c++) {
                        faces[index][prevLine][c].triggered = false;
                    }
                });
            }

            // Draw faces (back to front)
            faceDepths.forEach(({ index }) => {
                const indices = faceVertices[index];
                const points = indices.map(i => projected[i]);

                // Draw face background
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fillStyle = faceColors[index] + '30';
                ctx.fill();
                ctx.strokeStyle = faceColors[index];
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw grid
                const faceData = faces[index];
                const scanLine = ((Date.now() / 200) % gridSize) | 0;

                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = faceData[r][c];
                        const u = (c + 0.5) / gridSize;
                        const v = (r + 0.5) / gridSize;

                        // Interpolate position on face
                        const x = points[0].x * (1 - u) * (1 - v) +
                                  points[1].x * u * (1 - v) +
                                  points[2].x * u * v +
                                  points[3].x * (1 - u) * v;
                        const y = points[0].y * (1 - u) * (1 - v) +
                                  points[1].y * u * (1 - v) +
                                  points[2].y * u * v +
                                  points[3].y * (1 - u) * v;

                        const size = 8 * points[0].scale;

                        if (cell.glow > 0) {
                            ctx.shadowColor = faceColors[index];
                            ctx.shadowBlur = 15 * cell.glow;
                            cell.glow -= 0.03;
                        }

                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fillStyle = cell.active ? faceColors[index] : 'rgba(255,255,255,0.2)';
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Scan line indicator
                        if (r === scanLine && isPlaying && faceDepths.find(f => f.index === index).z > 0) {
                            ctx.beginPath();
                            ctx.arc(x, y, size + 3, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                }
            });

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            // Simplified click detection - toggle random active face
            const visibleFaces = [];
            const transformed = vertices.map(v => rotatePoint(v, rotationX, rotationY, rotationZ));

            faceVertices.forEach((indices, i) => {
                const avgZ = indices.reduce((sum, idx) => sum + transformed[idx][2], 0) / 4;
                if (avgZ > 0) visibleFaces.push(i);
            });

            if (visibleFaces.length > 0) {
                const faceIndex = visibleFaces[Math.floor(Math.random() * visibleFaces.length)];
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
                faces[faceIndex][row][col].active = !faces[faceIndex][row][col].active;
                if (faces[faceIndex][row][col].active) {
                    if (audioCtx.state === 'suspended') audioCtx.resume();
                    playNote(faceIndex, row, col);
                }
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            for (let f = 0; f < 6; f++) {
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        faces[f][r][c].active = Math.random() < 0.25;
                    }
                }
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            initFaces();
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        initFaces();
        draw();
    </script>
</body>
</html>
