<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Field Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a15; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; cursor: pointer; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(200,50,100,0.2); border: 1px solid rgba(200,50,100,0.5); color: #e48; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(200,50,100,0.3); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(200,50,100,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #e48; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Particles are attracted to magnets • Collisions create notes</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="addMagnet">+ Magnet</button>
        <button id="clearBtn">Clear</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const particles = [];
        const magnets = [];
        let isPlaying = false;
        const notes = [196, 220, 261.63, 293.66, 329.63, 392, 440, 523.25];

        class Particle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.charge = Math.random() > 0.5 ? 1 : -1;
                this.hue = this.charge > 0 ? 0 : 200;
            }
            update() {
                magnets.forEach(m => {
                    const dx = m.x - this.x;
                    const dy = m.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 20 && dist < 300) {
                        const force = (m.strength * this.charge) / (dist * dist) * 500;
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                    if (dist < 30) {
                        m.playNote();
                        this.reset();
                    }
                });
                this.vx *= 0.99;
                this.vy *= 0.99;
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                ctx.fill();
            }
        }

        class Magnet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.strength = Math.random() > 0.5 ? 1 : -1;
                this.noteIndex = magnets.length % notes.length;
                this.glow = 0;
                this.cooldown = 0;
            }
            playNote() {
                if (this.cooldown > 0) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = notes[this.noteIndex];
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
                this.glow = 1;
                this.cooldown = 10;
            }
            update() {
                if (this.glow > 0) this.glow -= 0.02;
                if (this.cooldown > 0) this.cooldown--;
            }
            draw() {
                // Field lines
                for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                    ctx.beginPath();
                    for (let r = 30; r < 100; r += 5) {
                        const x = this.x + Math.cos(a) * r;
                        const y = this.y + Math.sin(a) * r;
                        if (r === 30) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = this.strength > 0 ? 'rgba(255,50,100,0.2)' : 'rgba(50,100,255,0.2)';
                    ctx.stroke();
                }

                if (this.glow > 0) {
                    ctx.shadowColor = this.strength > 0 ? '#f48' : '#48f';
                    ctx.shadowBlur = 30 * this.glow;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
                ctx.fillStyle = this.strength > 0 ? '#e48' : '#48e';
                ctx.fill();
                ctx.font = 'bold 20px Segoe UI';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(this.strength > 0 ? 'N' : 'S', this.x, this.y + 7);
                ctx.shadowBlur = 0;
            }
        }

        function init() {
            for (let i = 0; i < 50; i++) particles.push(new Particle());
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 21, 0.2)';
            ctx.fillRect(0, 0, width, height);

            if (isPlaying) {
                particles.forEach(p => { p.update(); p.draw(); });
            } else {
                particles.forEach(p => p.draw());
            }
            magnets.forEach(m => { m.update(); m.draw(); });

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            magnets.push(new Magnet(e.clientX, e.clientY));
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('addMagnet').addEventListener('click', () => {
            magnets.push(new Magnet(Math.random() * width, Math.random() * height));
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            magnets.length = 0;
        });

        window.addEventListener('resize', () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; });

        init();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
