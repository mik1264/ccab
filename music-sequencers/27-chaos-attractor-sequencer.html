<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Attractor Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button, select {
            background: rgba(255,100,100,0.15);
            border: 1px solid rgba(255,100,100,0.5);
            color: #f88;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover, select:hover { background: rgba(255,100,100,0.25); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,100,100,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #f88; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Strange attractors create chaotic but musical patterns</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <select id="attractorSelect">
            <option value="lorenz">Lorenz</option>
            <option value="rossler">Rössler</option>
            <option value="chen">Chen</option>
            <option value="halvorsen">Halvorsen</option>
        </select>
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        let attractorType = 'lorenz';
        let points = [];
        let time = 0;

        // State variables
        let x = 0.1, y = 0, z = 0;
        const dt = 0.005;

        const notes = [130.81, 146.83, 164.81, 196, 220, 261.63, 293.66, 329.63, 392, 440, 523.25, 587.33];

        let lastNote = 0;
        let noteThreshold = 0.5;

        const attractors = {
            lorenz: (x, y, z) => {
                const sigma = 10, rho = 28, beta = 8 / 3;
                return {
                    dx: sigma * (y - x),
                    dy: x * (rho - z) - y,
                    dz: x * y - beta * z
                };
            },
            rossler: (x, y, z) => {
                const a = 0.2, b = 0.2, c = 5.7;
                return {
                    dx: -y - z,
                    dy: x + a * y,
                    dz: b + z * (x - c)
                };
            },
            chen: (x, y, z) => {
                const a = 40, b = 3, c = 28;
                return {
                    dx: a * (y - x),
                    dy: (c - a) * x - x * z + c * y,
                    dz: x * y - b * z
                };
            },
            halvorsen: (x, y, z) => {
                const a = 1.89;
                return {
                    dx: -a * x - 4 * y - 4 * z - y * y,
                    dy: -a * y - 4 * z - 4 * x - z * z,
                    dz: -a * z - 4 * x - 4 * y - x * x
                };
            }
        };

        function resetState() {
            x = 0.1 + Math.random() * 0.01;
            y = Math.random() * 0.01;
            z = Math.random() * 0.01;
            points = [];
            time = 0;
        }

        function step() {
            const attractor = attractors[attractorType];
            const d = attractor(x, y, z);

            x += d.dx * dt;
            y += d.dy * dt;
            z += d.dz * dt;
            time += dt;
        }

        function project(x, y, z) {
            // Simple 3D to 2D projection
            const scale = 8;
            const angle = time * 0.1;

            const rotX = x * Math.cos(angle) - z * Math.sin(angle);
            const rotZ = x * Math.sin(angle) + z * Math.cos(angle);

            return {
                px: width / 2 + rotX * scale,
                py: height / 2 + y * scale,
                depth: rotZ
            };
        }

        function playNote(noteIndex, velocity) {
            const freq = notes[noteIndex % notes.length];

            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = 'sine';
            osc.frequency.value = freq;
            osc2.type = 'triangle';
            osc2.frequency.value = freq * 1.5;

            const gain2 = audioCtx.createGain();
            gain2.gain.value = 0.2;

            filter.type = 'lowpass';
            filter.frequency.value = 1500;

            const vol = 0.1 * velocity;
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);

            osc.connect(filter);
            osc2.connect(gain2);
            gain2.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc2.start();
            osc.stop(audioCtx.currentTime + 0.4);
            osc2.stop(audioCtx.currentTime + 0.4);
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);

            if (isPlaying) {
                for (let i = 0; i < 5; i++) {
                    step();

                    const proj = project(x, y, z);
                    const hue = (time * 20) % 360;

                    points.push({
                        x: proj.px,
                        y: proj.py,
                        hue,
                        depth: proj.depth
                    });

                    // Trigger notes based on coordinate thresholds
                    const absX = Math.abs(x);
                    const absY = Math.abs(y);

                    if (absX > 20 && time - lastNote > noteThreshold) {
                        const noteIndex = Math.floor((y + 30) / 5);
                        const velocity = Math.min(1, absX / 30);
                        playNote(noteIndex, velocity);
                        lastNote = time;

                        // Visual pulse
                        ctx.beginPath();
                        ctx.arc(proj.px, proj.py, 20, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
                        ctx.fill();
                    }
                }

                // Keep points limited
                if (points.length > 3000) {
                    points = points.slice(-3000);
                }
            }

            // Draw trail
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }

                ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw recent points with glow
                const recentCount = 100;
                const recent = points.slice(-recentCount);
                recent.forEach((p, i) => {
                    const alpha = i / recentCount;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${p.hue}, 80%, 60%, ${alpha})`;
                    ctx.fill();
                });

                // Current position
                const last = points[points.length - 1];
                ctx.beginPath();
                ctx.arc(last.x, last.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#f88';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            requestAnimationFrame(draw);
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('attractorSelect').addEventListener('change', function() {
            attractorType = this.value;
            resetState();
        });

        document.getElementById('resetBtn').addEventListener('click', resetState);

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        resetState();
        draw();
    </script>
</body>
</html>
