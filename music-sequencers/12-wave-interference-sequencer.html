<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Interference Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(0,150,255,0.2);
            border: 1px solid rgba(0,150,255,0.6);
            color: #09f;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,150,255,0.3); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0,150,255,0.8);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #09f; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click to create wave sources • Interference patterns create harmonics</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="clearBtn">Clear</button>
        <button id="modeBtn">Mode: Ripple</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const sources = [];
        let isPlaying = false;
        let time = 0;
        let mode = 'ripple'; // ripple, sine, pulse

        // Frequencies for interference-based music
        const baseFreqs = [220, 277.18, 329.63, 369.99, 440, 554.37, 659.25];

        class WaveSource {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.frequency = 0.02 + Math.random() * 0.03;
                this.phase = Math.random() * Math.PI * 2;
                this.amplitude = 1;
                this.noteFreq = baseFreqs[Math.floor(Math.random() * baseFreqs.length)];
                this.hue = Math.random() * 360;
                this.lastTrigger = 0;
            }

            getWaveValue(px, py, t) {
                const dist = Math.hypot(px - this.x, py - this.y);
                const value = Math.sin(dist * this.frequency - t * 2 + this.phase);
                const decay = Math.max(0, 1 - dist / 400);
                return value * this.amplitude * decay;
            }
        }

        function getInterferenceAt(x, y, t) {
            let sum = 0;
            sources.forEach(source => {
                sum += source.getWaveValue(x, y, t);
            });
            return sum / Math.max(1, sources.length);
        }

        function playInterferenceNote(x, y, value) {
            // Find which sources are contributing most
            const contributions = sources.map(source => ({
                source,
                contrib: source.getWaveValue(x, y, time)
            })).filter(c => Math.abs(c.contrib) > 0.5);

            if (contributions.length === 0) return;

            // Create chord from contributing sources
            contributions.forEach(({ source, contrib }) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = source.noteFreq * (1 + value * 0.1);

                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                const vol = 0.1 * Math.abs(contrib);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            });
        }

        const resolution = 8;
        const triggers = [];

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            if (isPlaying) {
                time += 0.1;

                // Draw interference pattern
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                for (let y = 0; y < height; y += resolution) {
                    for (let x = 0; x < width; x += resolution) {
                        const value = getInterferenceAt(x, y, time);
                        const normalized = (value + 1) / 2;

                        // Color based on interference
                        const r = Math.floor(normalized * 100);
                        const g = Math.floor(normalized * 200);
                        const b = Math.floor(200 + normalized * 55);

                        // Fill resolution block
                        for (let dy = 0; dy < resolution && y + dy < height; dy++) {
                            for (let dx = 0; dx < resolution && x + dx < width; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4;
                                data[i] = r;
                                data[i + 1] = g;
                                data[i + 2] = b;
                                data[i + 3] = Math.floor(normalized * 200);
                            }
                        }

                        // Trigger sounds at constructive interference peaks
                        const key = `${Math.floor(x / 50)}-${Math.floor(y / 50)}`;
                        if (value > 0.9 && !triggers[key]) {
                            playInterferenceNote(x, y, value);
                            triggers[key] = true;

                            // Visual burst
                            ctx.beginPath();
                            ctx.arc(x, y, 10, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.fill();
                        } else if (value < 0.5) {
                            triggers[key] = false;
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
            }

            // Draw sources
            sources.forEach(source => {
                // Pulsing ring
                const pulse = Math.sin(time * 2 + source.phase) * 0.3 + 1;

                ctx.beginPath();
                ctx.arc(source.x, source.y, 15 * pulse, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${source.hue}, 80%, 60%, 0.8)`;
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(source.x, source.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${source.hue}, 80%, 60%)`;
                ctx.fill();

                // Expanding rings
                if (isPlaying) {
                    for (let r = 0; r < 400; r += 50) {
                        const ringPhase = (r * source.frequency - time * 2 + source.phase) % (Math.PI * 2);
                        const alpha = (1 - r / 400) * 0.3 * (Math.sin(ringPhase) * 0.5 + 0.5);
                        ctx.beginPath();
                        ctx.arc(source.x, source.y, r, 0, Math.PI * 2);
                        ctx.strokeStyle = `hsla(${source.hue}, 60%, 50%, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            });

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            sources.push(new WaveSource(e.clientX, e.clientY));
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            sources.length = 0;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
        });

        document.getElementById('modeBtn').addEventListener('click', function() {
            const modes = ['ripple', 'sine', 'pulse'];
            mode = modes[(modes.indexOf(mode) + 1) % modes.length];
            this.textContent = `Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        draw();
    </script>
</body>
</html>
