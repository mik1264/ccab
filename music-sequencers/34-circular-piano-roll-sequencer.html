<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Piano Roll Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
        }
        canvas { display: block; cursor: pointer; }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(100,200,255,0.15);
            border: 1px solid rgba(100,200,255,0.5);
            color: #8cf;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(100,200,255,0.25); }
        .info { position: fixed; top: 20px; color: rgba(100,200,255,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #8cf; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click to toggle notes • Rotating playhead triggers sounds</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="clearBtn">Clear</button>
        <button id="presetBtn">Preset: Arpeggio</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const size = Math.min(window.innerWidth - 40, window.innerHeight - 150, 550);
        canvas.width = canvas.height = size;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const steps = 16;
        const pitches = 8;
        const grid = [];
        let isPlaying = false;
        let angle = 0;
        let lastStep = -1;

        const notes = [523.25, 493.88, 440, 392, 349.23, 329.63, 293.66, 261.63];
        const noteNames = ['C5', 'B4', 'A4', 'G4', 'F4', 'E4', 'D4', 'C4'];

        function initGrid() {
            for (let s = 0; s < steps; s++) {
                grid[s] = [];
                for (let p = 0; p < pitches; p++) {
                    grid[s][p] = { active: false, glow: 0 };
                }
            }
        }

        function playNote(pitch) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'sine';
            osc.frequency.value = notes[pitch];

            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        function draw() {
            const center = size / 2;
            const innerRadius = 80;
            const outerRadius = size / 2 - 30;
            const ringWidth = (outerRadius - innerRadius) / pitches;

            ctx.fillStyle = 'rgba(10, 10, 21, 0.2)';
            ctx.fillRect(0, 0, size, size);

            if (isPlaying) {
                angle += 0.02;
                if (angle >= Math.PI * 2) angle -= Math.PI * 2;

                const currentStep = Math.floor((angle / (Math.PI * 2)) * steps);
                if (currentStep !== lastStep) {
                    for (let p = 0; p < pitches; p++) {
                        if (grid[currentStep][p].active) {
                            playNote(p);
                            grid[currentStep][p].glow = 1;
                        }
                    }
                    lastStep = currentStep;
                }
            }

            // Draw rings and cells
            for (let p = 0; p < pitches; p++) {
                const r1 = innerRadius + p * ringWidth;
                const r2 = r1 + ringWidth;

                // Ring background
                ctx.beginPath();
                ctx.arc(center, center, (r1 + r2) / 2, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.1)';
                ctx.lineWidth = ringWidth - 2;
                ctx.stroke();

                for (let s = 0; s < steps; s++) {
                    const a1 = (s / steps) * Math.PI * 2 - Math.PI / 2;
                    const a2 = ((s + 1) / steps) * Math.PI * 2 - Math.PI / 2;
                    const cell = grid[s][p];

                    if (cell.active || cell.glow > 0) {
                        ctx.beginPath();
                        ctx.arc(center, center, r1 + ringWidth / 2, a1, a2);

                        if (cell.glow > 0) {
                            ctx.strokeStyle = `hsla(${200 + p * 15}, 80%, 60%, ${cell.glow})`;
                            cell.glow -= 0.03;
                        } else {
                            ctx.strokeStyle = `hsl(${200 + p * 15}, 70%, 50%)`;
                        }
                        ctx.lineWidth = ringWidth - 4;
                        ctx.stroke();
                    }

                    // Cell borders
                    ctx.beginPath();
                    ctx.moveTo(center + Math.cos(a1) * r1, center + Math.sin(a1) * r1);
                    ctx.lineTo(center + Math.cos(a1) * r2, center + Math.sin(a1) * r2);
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Note labels
            ctx.font = '11px Segoe UI';
            ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
            ctx.textAlign = 'right';
            for (let p = 0; p < pitches; p++) {
                const r = innerRadius + p * ringWidth + ringWidth / 2;
                ctx.fillText(noteNames[p], center - 5, center - r + 4);
            }

            // Playhead
            if (isPlaying) {
                const headAngle = angle - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(center + Math.cos(headAngle) * innerRadius, center + Math.sin(headAngle) * innerRadius);
                ctx.lineTo(center + Math.cos(headAngle) * outerRadius, center + Math.sin(headAngle) * outerRadius);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Center
            ctx.beginPath();
            ctx.arc(center, center, innerRadius - 10, 0, Math.PI * 2);
            ctx.fillStyle = isPlaying ? 'rgba(100, 200, 255, 0.3)' : 'rgba(100, 200, 255, 0.1)';
            ctx.fill();

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - size / 2;
            const y = e.clientY - rect.top - size / 2;
            const dist = Math.hypot(x, y);
            const clickAngle = (Math.atan2(y, x) + Math.PI / 2 + Math.PI * 2) % (Math.PI * 2);

            const innerRadius = 80;
            const outerRadius = size / 2 - 30;
            const ringWidth = (outerRadius - innerRadius) / pitches;

            if (dist >= innerRadius && dist <= outerRadius) {
                const pitch = Math.floor((dist - innerRadius) / ringWidth);
                const step = Math.floor((clickAngle / (Math.PI * 2)) * steps);

                if (pitch >= 0 && pitch < pitches && step >= 0 && step < steps) {
                    grid[step][pitch].active = !grid[step][pitch].active;
                    if (grid[step][pitch].active) {
                        if (audioCtx.state === 'suspended') audioCtx.resume();
                        playNote(pitch);
                    }
                }
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            grid.forEach(step => step.forEach(cell => cell.active = false));
        });

        document.getElementById('presetBtn').addEventListener('click', () => {
            grid.forEach(step => step.forEach(cell => cell.active = false));
            // Arpeggio pattern
            for (let s = 0; s < steps; s++) {
                grid[s][s % pitches].active = true;
            }
        });

        initGrid();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
