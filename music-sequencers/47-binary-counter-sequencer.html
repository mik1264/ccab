<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Counter Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #050510; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(0,255,150,0.15); border: 1px solid rgba(0,255,150,0.5); color: #0f9; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-family: monospace; }
        button:hover { background: rgba(0,255,150,0.25); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(0,255,150,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #0f9; text-decoration: none; }
        .counter { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); color: #0f9; font-size: 24px; font-family: monospace; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Binary counting creates rhythmic patterns • Each bit has its own pitch</div>
    <div class="counter" id="counter">00000000 = 0</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="bitsBtn">12 Bits</button>
        <button id="resetBtn">Reset</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        let counter = 0;
        let numBits = 8;
        let lastTime = 0;
        const bpm = 480;

        // Each bit gets a note from a pentatonic scale
        const notes = [130.81, 164.81, 196, 246.94, 261.63, 329.63, 392, 493.88, 523.25, 659.25, 783.99, 987.77];
        const bitGlows = [];

        function playBit(bitIndex, isOn) {
            if (!isOn) return;

            const freq = notes[bitIndex % notes.length];

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = bitIndex < 4 ? 'sine' : (bitIndex < 8 ? 'triangle' : 'square');
            osc.frequency.value = freq;

            const volume = 0.15 - (bitIndex * 0.01);
            gain.gain.setValueAtTime(Math.max(0.05, volume), audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);

            bitGlows[bitIndex] = 1;
        }

        function step() {
            const prevBits = counter.toString(2).padStart(numBits, '0');
            counter = (counter + 1) % Math.pow(2, numBits);
            const newBits = counter.toString(2).padStart(numBits, '0');

            // Find bits that changed from 0 to 1
            for (let i = 0; i < numBits; i++) {
                if (prevBits[i] === '0' && newBits[i] === '1') {
                    playBit(numBits - 1 - i, true);
                }
            }

            document.getElementById('counter').textContent = `${newBits} = ${counter}`;
        }

        function draw(timestamp) {
            ctx.fillStyle = 'rgba(5, 5, 16, 0.2)';
            ctx.fillRect(0, 0, width, height);

            const centerX = width / 2;
            const centerY = height / 2;
            const bitWidth = Math.min(80, (width - 100) / numBits);
            const startX = centerX - (numBits * bitWidth) / 2;

            const bits = counter.toString(2).padStart(numBits, '0');

            // Draw bits
            for (let i = 0; i < numBits; i++) {
                const x = startX + i * bitWidth + bitWidth / 2;
                const y = centerY;
                const isOn = bits[i] === '1';

                // Glow effect
                if (bitGlows[numBits - 1 - i] > 0) {
                    ctx.shadowColor = '#0f9';
                    ctx.shadowBlur = 30 * bitGlows[numBits - 1 - i];
                    bitGlows[numBits - 1 - i] -= 0.03;
                }

                // Bit circle
                ctx.beginPath();
                ctx.arc(x, y, bitWidth * 0.35, 0, Math.PI * 2);
                ctx.fillStyle = isOn ? '#0f9' : 'rgba(0,255,150,0.1)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,255,150,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Bit value
                ctx.font = 'bold 20px monospace';
                ctx.fillStyle = isOn ? '#000' : 'rgba(0,255,150,0.3)';
                ctx.textAlign = 'center';
                ctx.fillText(bits[i], x, y + 7);

                // Bit position label
                ctx.font = '12px monospace';
                ctx.fillStyle = 'rgba(0,255,150,0.5)';
                ctx.fillText(`2^${numBits - 1 - i}`, x, y + bitWidth * 0.6);

                // Frequency label
                ctx.fillText(`${Math.round(notes[(numBits - 1 - i) % notes.length])}Hz`, x, y - bitWidth * 0.5);
            }

            // Draw binary tree visualization
            const treeY = centerY + 150;
            const maxDepth = Math.min(5, numBits);

            for (let depth = 0; depth < maxDepth; depth++) {
                const nodesAtDepth = Math.pow(2, depth);
                const nodeWidth = (width - 100) / nodesAtDepth;

                for (let n = 0; n < nodesAtDepth; n++) {
                    const x = 50 + n * nodeWidth + nodeWidth / 2;
                    const y = treeY + depth * 40;

                    // Check if this path is active
                    const bitIndex = depth;
                    const pathValue = Math.floor(counter / Math.pow(2, numBits - depth - 1));
                    const isActive = n === pathValue % nodesAtDepth;

                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = isActive ? '#0f9' : 'rgba(0,255,150,0.2)';
                    ctx.fill();

                    // Draw connecting lines
                    if (depth > 0) {
                        const parentN = Math.floor(n / 2);
                        const parentX = 50 + parentN * nodeWidth * 2 + nodeWidth;
                        const parentY = treeY + (depth - 1) * 40;

                        ctx.beginPath();
                        ctx.moveTo(parentX, parentY + 10);
                        ctx.lineTo(x, y - 10);
                        ctx.strokeStyle = isActive ? 'rgba(0,255,150,0.5)' : 'rgba(0,255,150,0.1)';
                        ctx.stroke();
                    }
                }
            }

            // Timing
            if (isPlaying) {
                const interval = 60000 / bpm;
                if (timestamp - lastTime > interval) {
                    step();
                    lastTime = timestamp;
                }
            }

            requestAnimationFrame(draw);
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('bitsBtn').addEventListener('click', function() {
            numBits = numBits === 8 ? 12 : 8;
            counter = 0;
            this.textContent = numBits === 8 ? '12 Bits' : '8 Bits';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            counter = 0;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        // Initialize glow array
        for (let i = 0; i < 12; i++) bitGlows[i] = 0;

        requestAnimationFrame(draw);
    </script>
</body>
</html>
