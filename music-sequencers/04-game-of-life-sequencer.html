<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        button {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.5);
            color: #0f8;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,255,136,0.2); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0,255,136,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #0f8; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click/drag to draw cells • Each column is a step, rows are pitches</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="stepBtn">Step</button>
        <button id="clearBtn">Clear</button>
        <button id="randomBtn">Random</button>
        <button id="gliderBtn">Add Glider</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const cellSize = 15;
        let cols, rows;
        let grid = [];
        let isPlaying = false;
        let playColumn = 0;
        let lastStep = 0;
        const stepInterval = 150; // ms per step

        // Pentatonic scale
        const baseFreq = 880;
        const scale = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21, 24, 26, 28, 31, 33];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            initGrid();
        }

        function initGrid() {
            const oldGrid = grid;
            grid = [];
            for (let x = 0; x < cols; x++) {
                grid[x] = [];
                for (let y = 0; y < rows; y++) {
                    grid[x][y] = (oldGrid[x] && oldGrid[x][y]) ? oldGrid[x][y] : { alive: false, age: 0 };
                }
            }
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    if (grid[nx][ny].alive) count++;
                }
            }
            return count;
        }

        function step() {
            const newGrid = [];
            for (let x = 0; x < cols; x++) {
                newGrid[x] = [];
                for (let y = 0; y < rows; y++) {
                    const neighbors = countNeighbors(x, y);
                    const cell = grid[x][y];
                    let alive = cell.alive;

                    if (alive && (neighbors < 2 || neighbors > 3)) {
                        alive = false;
                    } else if (!alive && neighbors === 3) {
                        alive = true;
                    }

                    newGrid[x][y] = {
                        alive,
                        age: alive ? (cell.alive ? cell.age + 1 : 0) : 0
                    };
                }
            }
            grid = newGrid;
        }

        function playColumn(col) {
            const activeCells = [];
            for (let y = 0; y < rows; y++) {
                if (grid[col][y].alive) {
                    activeCells.push(y);
                }
            }

            activeCells.forEach((y, i) => {
                const semitone = scale[y % scale.length] + Math.floor(y / scale.length) * 12;
                const freq = baseFreq * Math.pow(2, -semitone / 12);

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = freq;

                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                const volume = 0.15 / Math.max(1, activeCells.length * 0.5);
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            });
        }

        function draw(timestamp) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    const cell = grid[x][y];
                    if (cell.alive) {
                        const hue = 140 + cell.age * 5;
                        const brightness = 50 + Math.min(cell.age * 3, 30);
                        ctx.fillStyle = `hsl(${hue}, 80%, ${brightness}%)`;

                        if (x === playColumn && isPlaying) {
                            ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
                            ctx.shadowBlur = 15;
                        }

                        ctx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Draw playhead
            if (isPlaying) {
                ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
                ctx.fillRect(playColumn * cellSize, 0, cellSize, canvas.height);

                ctx.strokeStyle = 'rgba(0, 255, 136, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playColumn * cellSize, 0);
                ctx.lineTo(playColumn * cellSize, canvas.height);
                ctx.stroke();

                if (timestamp - lastStep > stepInterval) {
                    playColumnFn(playColumn);
                    playColumn = (playColumn + 1) % cols;

                    // Step evolution every full cycle
                    if (playColumn === 0) {
                        step();
                    }

                    lastStep = timestamp;
                }
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellSize, 0);
                ctx.lineTo(x * cellSize, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellSize);
                ctx.lineTo(canvas.width, y * cellSize);
                ctx.stroke();
            }

            requestAnimationFrame(draw);
        }

        function playColumnFn(col) {
            playColumn(col);
        }

        function setCell(e) {
            const x = Math.floor(e.clientX / cellSize);
            const y = Math.floor(e.clientY / cellSize);
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                grid[x][y] = { alive: true, age: 0 };
            }
        }

        let isDrawing = false;
        canvas.addEventListener('mousedown', (e) => { isDrawing = true; setCell(e); });
        canvas.addEventListener('mousemove', (e) => { if (isDrawing) setCell(e); });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('stepBtn').addEventListener('click', () => step());

        document.getElementById('clearBtn').addEventListener('click', () => {
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    grid[x][y] = { alive: false, age: 0 };
                }
            }
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    grid[x][y] = { alive: Math.random() < 0.2, age: 0 };
                }
            }
        });

        document.getElementById('gliderBtn').addEventListener('click', () => {
            const gx = Math.floor(cols / 2);
            const gy = Math.floor(rows / 2);
            const glider = [[0,1], [1,2], [2,0], [2,1], [2,2]];
            glider.forEach(([dx, dy]) => {
                if (gx + dx < cols && gy + dy < rows) {
                    grid[gx + dx][gy + dy] = { alive: true, age: 0 };
                }
            });
        });

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(draw);
    </script>
</body>
</html>
