<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Superposition Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000510; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; cursor: pointer; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(100,200,255,0.15); border: 1px solid rgba(100,200,255,0.5); color: #6cf; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(100,200,255,0.25); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(100,200,255,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #6cf; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Notes exist in superposition until observed • Click to collapse the wave function</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="observeBtn">Observe All</button>
        <button id="resetBtn">Reset</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const numQubits = 8;
        const qubits = [];
        let isPlaying = false, currentQubit = 0, lastStep = 0;
        const notes = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];

        class Qubit {
            constructor(x, y, index) {
                this.x = x;
                this.y = y;
                this.index = index;
                this.collapsed = false;
                this.value = null;
                this.probability = 0.5; // Probability of being "1"
                this.phase = Math.random() * Math.PI * 2;
                this.waveAmplitude = 30;
            }

            observe() {
                if (!this.collapsed) {
                    this.collapsed = true;
                    this.value = Math.random() < this.probability ? 1 : 0;
                    if (this.value === 1) {
                        this.playNote();
                    }
                }
            }

            playNote() {
                const freq = notes[this.index];
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.4);
            }

            reset() {
                this.collapsed = false;
                this.value = null;
                this.probability = 0.3 + Math.random() * 0.4;
            }

            draw(time, isCurrent) {
                const baseY = this.y;

                if (!this.collapsed) {
                    // Draw wave function
                    ctx.beginPath();
                    for (let dx = -50; dx <= 50; dx++) {
                        const wave = Math.sin((dx + time * 50) * 0.1 + this.phase) * this.waveAmplitude;
                        const py = baseY + wave * this.probability;
                        if (dx === -50) ctx.moveTo(this.x + dx, py);
                        else ctx.lineTo(this.x + dx, py);
                    }
                    ctx.strokeStyle = `rgba(100, 200, 255, ${0.5 + Math.sin(time * 3) * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Probability cloud
                    ctx.beginPath();
                    ctx.arc(this.x, baseY, 40, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(100, 200, 255, ${0.1 + Math.sin(time * 2 + this.phase) * 0.1})`;
                    ctx.fill();

                    // Label
                    ctx.font = '14px Segoe UI';
                    ctx.fillStyle = '#6cf';
                    ctx.textAlign = 'center';
                    ctx.fillText(`|ψ⟩ = ${(this.probability * 100).toFixed(0)}%|1⟩`, this.x, baseY + 60);
                } else {
                    // Collapsed state
                    ctx.beginPath();
                    ctx.arc(this.x, baseY, 30, 0, Math.PI * 2);
                    ctx.fillStyle = this.value === 1 ? '#6cf' : 'rgba(100, 200, 255, 0.2)';
                    ctx.fill();

                    ctx.font = 'bold 24px Segoe UI';
                    ctx.fillStyle = this.value === 1 ? '#000' : 'rgba(255,255,255,0.4)';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.value, this.x, baseY + 8);
                }

                // Current indicator
                if (isCurrent && isPlaying) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, baseY, 45, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        function init() {
            qubits.length = 0;
            const spacing = (width - 200) / (numQubits - 1);
            for (let i = 0; i < numQubits; i++) {
                qubits.push(new Qubit(100 + i * spacing, height / 2, i));
            }
        }

        function draw(timestamp) {
            ctx.fillStyle = 'rgba(0, 5, 16, 0.15)';
            ctx.fillRect(0, 0, width, height);

            const time = timestamp / 1000;

            if (isPlaying && timestamp - lastStep > 400) {
                qubits[currentQubit].observe();
                currentQubit = (currentQubit + 1) % numQubits;
                if (currentQubit === 0) {
                    // Reset for next cycle
                    setTimeout(() => qubits.forEach(q => q.reset()), 500);
                }
                lastStep = timestamp;
            }

            qubits.forEach((q, i) => q.draw(time, i === currentQubit));

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            qubits.forEach(q => {
                if (Math.abs(e.clientX - q.x) < 50 && Math.abs(e.clientY - q.y) < 50) {
                    q.observe();
                }
            });
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('observeBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            qubits.forEach((q, i) => setTimeout(() => q.observe(), i * 100));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            qubits.forEach(q => q.reset());
            currentQubit = 0;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        });

        init();
        requestAnimationFrame(draw);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
