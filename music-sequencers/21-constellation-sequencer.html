<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(200,200,255,0.1);
            border: 1px solid rgba(200,200,255,0.4);
            color: #ccf;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(200,200,255,0.2); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(200,200,255,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #ccf; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click to place stars • Connect them to create constellations • Shooting stars trigger melodies</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="clearBtn">Clear</button>
        <button id="connectBtn">Auto-Connect</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        const stars = [];
        const connections = [];
        const shootingStars = [];
        const backgroundStars = [];

        const notes = [220, 261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25, 587.33];

        // Create background stars
        for (let i = 0; i < 200; i++) {
            backgroundStars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 1.5,
                twinkle: Math.random() * Math.PI * 2
            });
        }

        class Star {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 4;
                this.brightness = 0.8 + Math.random() * 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
                this.noteIndex = Math.floor((y / height) * notes.length);
                this.glow = 0;
            }

            draw() {
                const twinkleFactor = 0.7 + Math.sin(this.twinkle) * 0.3;
                this.twinkle += 0.05;

                if (this.glow > 0) {
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 20 * this.glow;
                    this.glow -= 0.02;
                }

                // Star glow
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 4);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.brightness * twinkleFactor})`);
                gradient.addColorStop(0.3, `rgba(200, 200, 255, ${this.brightness * 0.3 * twinkleFactor})`);
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Star core
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();

                ctx.shadowBlur = 0;
            }

            playNote() {
                const freq = notes[this.noteIndex];

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sine';
                osc.frequency.value = freq;

                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.8);

                this.glow = 1;
            }
        }

        class ShootingStar {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = 0;
                this.vx = 3 + Math.random() * 3;
                this.vy = 2 + Math.random() * 4;
                this.trail = [];
                this.life = 1;
                this.triggered = [];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                this.trail.unshift({ x: this.x, y: this.y });
                if (this.trail.length > 20) this.trail.pop();

                // Check star collisions
                stars.forEach((star, i) => {
                    const dist = Math.hypot(this.x - star.x, this.y - star.y);
                    if (dist < 30 && !this.triggered.includes(i)) {
                        star.playNote();
                        this.triggered.push(i);
                    }
                });

                // Check connection crossings
                connections.forEach(conn => {
                    if (this.crossesLine(conn.star1, conn.star2)) {
                        conn.star1.playNote();
                        setTimeout(() => conn.star2.playNote(), 100);
                    }
                });

                if (this.x > width + 50 || this.y > height + 50) {
                    this.reset();
                }
            }

            crossesLine(s1, s2) {
                // Simplified line crossing detection
                const prevX = this.trail[1]?.x || this.x;
                const prevY = this.trail[1]?.y || this.y;

                const d1 = (s2.x - s1.x) * (prevY - s1.y) - (s2.y - s1.y) * (prevX - s1.x);
                const d2 = (s2.x - s1.x) * (this.y - s1.y) - (s2.y - s1.y) * (this.x - s1.x);

                return d1 * d2 < 0;
            }

            draw() {
                if (this.trail.length < 2) return;

                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) {
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }

                const gradient = ctx.createLinearGradient(
                    this.trail[0].x, this.trail[0].y,
                    this.trail[this.trail.length - 1].x, this.trail[this.trail.length - 1].y
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(1, 'transparent');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 10, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Background stars
            backgroundStars.forEach(star => {
                star.twinkle += 0.02;
                const alpha = 0.3 + Math.sin(star.twinkle) * 0.3;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
            });

            // Draw connections
            connections.forEach(conn => {
                ctx.beginPath();
                ctx.moveTo(conn.star1.x, conn.star1.y);
                ctx.lineTo(conn.star2.x, conn.star2.y);
                ctx.strokeStyle = 'rgba(100, 100, 200, 0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw and update shooting stars
            if (isPlaying) {
                shootingStars.forEach(ss => {
                    ss.update();
                    ss.draw();
                });
            }

            // Draw stars
            stars.forEach(star => star.draw());

            requestAnimationFrame(draw);
        }

        let selectedStar = null;

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // Check if clicking on existing star
            const clickedStar = stars.find(s =>
                Math.hypot(e.clientX - s.x, e.clientY - s.y) < 20
            );

            if (clickedStar) {
                if (selectedStar && selectedStar !== clickedStar) {
                    // Create connection
                    const exists = connections.some(c =>
                        (c.star1 === selectedStar && c.star2 === clickedStar) ||
                        (c.star1 === clickedStar && c.star2 === selectedStar)
                    );
                    if (!exists) {
                        connections.push({ star1: selectedStar, star2: clickedStar });
                    }
                    selectedStar = null;
                } else {
                    selectedStar = clickedStar;
                    clickedStar.playNote();
                }
            } else {
                // Create new star
                const star = new Star(e.clientX, e.clientY);
                stars.push(star);
                star.playNote();
                selectedStar = null;
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';

            if (isPlaying && shootingStars.length === 0) {
                for (let i = 0; i < 3; i++) {
                    shootingStars.push(new ShootingStar());
                }
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            stars.length = 0;
            connections.length = 0;
            selectedStar = null;
        });

        document.getElementById('connectBtn').addEventListener('click', () => {
            // Auto-connect nearest stars
            connections.length = 0;
            stars.forEach((star, i) => {
                let nearest = null;
                let nearestDist = Infinity;

                stars.forEach((other, j) => {
                    if (i !== j) {
                        const dist = Math.hypot(star.x - other.x, star.y - other.y);
                        if (dist < nearestDist && dist < 200) {
                            nearest = other;
                            nearestDist = dist;
                        }
                    }
                });

                if (nearest) {
                    const exists = connections.some(c =>
                        (c.star1 === star && c.star2 === nearest) ||
                        (c.star1 === nearest && c.star2 === star)
                    );
                    if (!exists) {
                        connections.push({ star1: star, star2: nearest });
                    }
                }
            });
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
