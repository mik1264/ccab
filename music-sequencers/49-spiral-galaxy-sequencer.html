<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spiral Galaxy Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000008; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(180,150,255,0.15); border: 1px solid rgba(180,150,255,0.5); color: #b9f; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(180,150,255,0.25); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(180,150,255,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #b9f; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Stars orbit in spiral arms • Crossing the beam creates cosmic sounds</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="armsBtn">4 Arms</button>
        <button id="resetBtn">New Galaxy</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        let beamAngle = 0;
        let numArms = 2;
        const stars = [];

        const notes = [130.81, 146.83, 164.81, 196, 220, 261.63, 293.66, 329.63, 392, 440, 523.25, 587.33];

        class Star {
            constructor(arm, distance) {
                this.arm = arm;
                this.distance = distance;
                this.angle = (arm / numArms) * Math.PI * 2 + distance * 0.15;
                this.orbitSpeed = 0.0005 + (1 / distance) * 0.05;
                this.brightness = 0.3 + Math.random() * 0.7;
                this.size = 1 + Math.random() * 2;
                this.glow = 0;
                this.lastTriggered = 0;
                this.hue = 200 + Math.random() * 60;
            }

            update() {
                if (isPlaying) {
                    this.angle += this.orbitSpeed;
                }
                if (this.glow > 0) this.glow -= 0.02;
            }

            getPosition() {
                const centerX = width / 2;
                const centerY = height / 2;
                const r = this.distance;
                const spiralOffset = Math.log(r + 1) * 0.5;
                const a = this.angle + spiralOffset;

                return {
                    x: centerX + r * Math.cos(a),
                    y: centerY + r * Math.sin(a)
                };
            }

            play() {
                const now = Date.now();
                if (now - this.lastTriggered < 200) return;
                this.lastTriggered = now;

                const noteIndex = Math.floor((this.distance / 300) * notes.length);
                const freq = notes[Math.min(noteIndex, notes.length - 1)];

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sine';
                osc.frequency.value = freq;

                const vol = 0.08 * this.brightness;
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);

                this.glow = 1;
            }

            draw() {
                const pos = this.getPosition();

                if (this.glow > 0) {
                    ctx.shadowColor = `hsl(${this.hue}, 80%, 70%)`;
                    ctx.shadowBlur = 20 * this.glow;
                }

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.size + this.glow * 3, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 70%, ${50 + this.brightness * 30}%, ${this.brightness})`;
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        function createGalaxy() {
            stars.length = 0;

            // Core stars
            for (let i = 0; i < 100; i++) {
                const distance = Math.random() * 50;
                const arm = Math.floor(Math.random() * numArms);
                const star = new Star(arm, distance);
                star.angle = Math.random() * Math.PI * 2;
                star.hue = 220 + Math.random() * 40;
                star.brightness = 0.5 + Math.random() * 0.5;
                stars.push(star);
            }

            // Spiral arm stars
            for (let arm = 0; arm < numArms; arm++) {
                for (let i = 0; i < 150; i++) {
                    const distance = 50 + i * 2 + Math.random() * 30;
                    const star = new Star(arm, distance);
                    star.angle += (Math.random() - 0.5) * 0.3;
                    stars.push(star);
                }
            }

            // Random field stars
            for (let i = 0; i < 200; i++) {
                const distance = Math.random() * 350;
                const arm = Math.floor(Math.random() * numArms);
                const star = new Star(arm, distance);
                star.angle = Math.random() * Math.PI * 2;
                star.brightness = 0.2 + Math.random() * 0.3;
                star.size = 0.5 + Math.random();
                stars.push(star);
            }
        }

        function drawGalaxyCore() {
            const centerX = width / 2;
            const centerY = height / 2;

            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80);
            gradient.addColorStop(0, 'rgba(255,240,200,0.3)');
            gradient.addColorStop(0.3, 'rgba(255,200,150,0.15)');
            gradient.addColorStop(1, 'rgba(180,150,255,0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
            ctx.fill();
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 8, 0.15)';
            ctx.fillRect(0, 0, width, height);

            drawGalaxyCore();

            // Draw and update stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });

            // Draw scanning beam
            if (isPlaying) {
                const centerX = width / 2;
                const centerY = height / 2;
                const beamLength = 400;

                const gradient = ctx.createLinearGradient(
                    centerX, centerY,
                    centerX + Math.cos(beamAngle) * beamLength,
                    centerY + Math.sin(beamAngle) * beamLength
                );
                gradient.addColorStop(0, 'rgba(180,150,255,0.5)');
                gradient.addColorStop(1, 'rgba(180,150,255,0)');

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(beamAngle) * beamLength,
                    centerY + Math.sin(beamAngle) * beamLength
                );
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Check for star triggers
                stars.forEach(star => {
                    const pos = star.getPosition();
                    const starAngle = Math.atan2(pos.y - centerY, pos.x - centerX);
                    let normalizedStarAngle = starAngle;
                    if (normalizedStarAngle < 0) normalizedStarAngle += Math.PI * 2;

                    let normalizedBeamAngle = beamAngle % (Math.PI * 2);
                    if (normalizedBeamAngle < 0) normalizedBeamAngle += Math.PI * 2;

                    const angleDiff = Math.abs(normalizedStarAngle - normalizedBeamAngle);
                    if ((angleDiff < 0.02 || angleDiff > Math.PI * 2 - 0.02) && star.glow === 0) {
                        star.play();
                    }
                });

                beamAngle += 0.008;
            }

            requestAnimationFrame(draw);
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('armsBtn').addEventListener('click', function() {
            numArms = numArms === 2 ? 4 : (numArms === 4 ? 6 : 2);
            this.textContent = `${numArms} Arms`;
            createGalaxy();
        });

        document.getElementById('resetBtn').addEventListener('click', createGalaxy);

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        createGalaxy();
        draw();
    </script>
</body>
</html>
