<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Cell Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a12;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(200,100,255,0.1);
            border: 1px solid rgba(200,100,255,0.5);
            color: #c8f;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(200,100,255,0.2); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(200,100,255,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #c8f; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click to add cells • Cells pulse and trigger neighbors</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="clearBtn">Clear</button>
        <button id="randomBtn">Random</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const points = [];
        let isPlaying = false;

        // Pentatonic scale
        const scale = [220, 261.63, 293.66, 329.63, 392, 440, 523.25, 587.33, 659.25, 783.99];

        class VoronoiPoint {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.phase = Math.random() * Math.PI * 2;
                this.frequency = 0.02 + Math.random() * 0.03;
                this.active = false;
                this.pulseTime = 0;
                this.hue = Math.random() * 360;
                this.noteIndex = Math.floor(Math.random() * scale.length);
            }

            update() {
                if (!isPlaying) return;

                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x < 20 || this.x > width - 20) this.vx *= -1;
                if (this.y < 20 || this.y > height - 20) this.vy *= -1;

                this.phase += this.frequency;

                // Pulse on phase crossing
                if (Math.sin(this.phase - this.frequency) < 0 && Math.sin(this.phase) >= 0) {
                    if (this.active) {
                        this.pulse();
                    }
                }

                if (this.pulseTime > 0) this.pulseTime -= 0.03;
            }

            pulse() {
                this.pulseTime = 1;
                this.playNote();

                // Trigger nearby cells
                points.forEach(p => {
                    if (p !== this) {
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < 150 && !p.active) {
                            p.active = true;
                            setTimeout(() => {
                                p.pulse();
                            }, dist * 2);
                        }
                    }
                });
            }

            playNote() {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                const reverb = audioCtx.createConvolver();

                osc.type = 'sine';
                osc.frequency.value = scale[this.noteIndex];

                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.8);
            }
        }

        function getVoronoiCells() {
            // Simple Voronoi calculation
            const cells = [];
            const resolution = 5;

            for (let x = 0; x < width; x += resolution) {
                for (let y = 0; y < height; y += resolution) {
                    let minDist = Infinity;
                    let closest = null;

                    points.forEach(p => {
                        const dist = Math.hypot(x - p.x, y - p.y);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = p;
                        }
                    });

                    if (closest) {
                        if (!cells[points.indexOf(closest)]) {
                            cells[points.indexOf(closest)] = [];
                        }
                        cells[points.indexOf(closest)].push({ x, y, dist: minDist });
                    }
                }
            }

            return cells;
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 18, 0.1)';
            ctx.fillRect(0, 0, width, height);

            if (points.length > 0) {
                // Draw Voronoi edges approximation
                points.forEach((p1, i) => {
                    points.forEach((p2, j) => {
                        if (i < j) {
                            const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                            if (dist < 200) {
                                // Draw edge between cells
                                const midX = (p1.x + p2.x) / 2;
                                const midY = (p1.y + p2.y) / 2;

                                // Perpendicular line
                                const dx = p2.x - p1.x;
                                const dy = p2.y - p1.y;
                                const len = 100 * (1 - dist / 200);

                                ctx.beginPath();
                                ctx.moveTo(midX - dy / dist * len, midY + dx / dist * len);
                                ctx.lineTo(midX + dy / dist * len, midY - dx / dist * len);
                                ctx.strokeStyle = `rgba(200, 100, 255, ${0.3 * (1 - dist / 200)})`;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    });
                });
            }

            // Update and draw points
            points.forEach(point => {
                point.update();

                const pulseSize = 20 + point.pulseTime * 30;
                const alpha = 0.3 + point.pulseTime * 0.7;

                if (point.pulseTime > 0) {
                    // Pulse glow
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, pulseSize + 20, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${point.hue}, 80%, 60%, ${point.pulseTime * 0.3})`;
                    ctx.fill();
                }

                // Draw point
                ctx.beginPath();
                ctx.arc(point.x, point.y, point.active ? 12 : 8, 0, Math.PI * 2);

                if (point.active) {
                    ctx.shadowColor = `hsl(${point.hue}, 80%, 60%)`;
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = `hsl(${point.hue}, 70%, 60%)`;
                } else {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(200, 100, 255, 0.3)';
                }
                ctx.fill();
                ctx.shadowBlur = 0;

                // Draw oscillation indicator
                if (point.active && isPlaying) {
                    const waveY = point.y + Math.sin(point.phase) * 20;
                    ctx.beginPath();
                    ctx.arc(point.x, waveY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${point.hue}, 90%, 70%)`;
                    ctx.fill();
                }
            });

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const point = new VoronoiPoint(e.clientX, e.clientY);
            point.active = true;
            points.push(point);

            if (isPlaying) {
                point.pulse();
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';

            if (isPlaying && points.length > 0) {
                points[0].pulse();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            points.length = 0;
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            points.length = 0;
            for (let i = 0; i < 15; i++) {
                const point = new VoronoiPoint(
                    100 + Math.random() * (width - 200),
                    100 + Math.random() * (height - 200)
                );
                point.active = Math.random() < 0.5;
                points.push(point);
            }
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        draw();
    </script>
</body>
</html>
