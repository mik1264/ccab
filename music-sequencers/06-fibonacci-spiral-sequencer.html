<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fibonacci Spiral Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(218,165,32,0.15);
            border: 1px solid rgba(218,165,32,0.5);
            color: #daa520;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(218,165,32,0.25); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(218,165,32,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #daa520; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Golden ratio positions create harmonic sequences • Click to place notes</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="clearBtn">Clear</button>
        <button id="goldenBtn">Golden Pattern</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height, centerX, centerY;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const PHI = (1 + Math.sqrt(5)) / 2; // Golden ratio

        let isPlaying = false;
        let angle = 0;
        const nodes = [];
        const maxNodes = 144; // Fibonacci number
        const spiralTightness = 0.15;

        // Harmonic series based on golden ratio
        const baseFreq = 220;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }

        function getSpiralPosition(index) {
            const a = spiralTightness;
            const theta = index * 0.3;
            const r = a * Math.pow(PHI, theta / (Math.PI / 2)) * 8;
            return {
                x: centerX + r * Math.cos(theta),
                y: centerY + r * Math.sin(theta),
                theta,
                r
            };
        }

        function getFrequencyForPosition(pos) {
            // Use distance from center and angle to determine frequency
            const dist = pos.r;
            const octave = Math.floor(dist / 100);
            const semitone = Math.floor((pos.theta % (Math.PI * 2)) / (Math.PI * 2) * 12);
            return baseFreq * Math.pow(2, octave) * Math.pow(2, semitone / 12);
        }

        function playNote(node) {
            const freq = getFrequencyForPosition(node);

            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = 'sine';
            osc.frequency.value = freq;
            osc2.type = 'sine';
            osc2.frequency.value = freq * PHI; // Golden ratio harmonic

            filter.type = 'lowpass';
            filter.frequency.value = 2000;
            filter.Q.value = 1;

            const gain2 = audioCtx.createGain();
            gain2.gain.value = 0.15;

            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);

            osc.connect(filter);
            osc2.connect(gain2);
            gain2.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc2.start();
            osc.stop(audioCtx.currentTime + 0.6);
            osc2.stop(audioCtx.currentTime + 0.6);

            node.glow = 1;
        }

        function drawSpiral() {
            ctx.beginPath();
            for (let i = 0; i < 500; i++) {
                const pos = getSpiralPosition(i);
                if (i === 0) ctx.moveTo(pos.x, pos.y);
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.strokeStyle = 'rgba(218, 165, 32, 0.15)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw Fibonacci boxes
            let a = 1, b = 1;
            let x = centerX - 50;
            let y = centerY - 50;
            let size = 20;

            ctx.strokeStyle = 'rgba(218, 165, 32, 0.1)';
            for (let i = 0; i < 8; i++) {
                ctx.strokeRect(x, y, size * a, size * a);
                const temp = a;
                a = a + b;
                b = temp;
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 21, 0.15)';
            ctx.fillRect(0, 0, width, height);

            drawSpiral();

            // Draw nodes on spiral
            nodes.forEach((node, i) => {
                if (node.glow > 0) {
                    ctx.shadowColor = '#daa520';
                    ctx.shadowBlur = 30 * node.glow;
                    node.glow -= 0.02;
                }

                const size = 8 + (node.r / 100) * 4;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);

                const hue = 40 + (node.theta * 30) % 40;
                ctx.fillStyle = node.active ? `hsl(${hue}, 80%, 55%)` : 'rgba(218, 165, 32, 0.2)';
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Rotating playhead from center
            if (isPlaying) {
                const headLength = Math.max(width, height);
                const hx = centerX + Math.cos(angle) * headLength;
                const hy = centerY + Math.sin(angle) * headLength;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(hx, hy);
                ctx.strokeStyle = 'rgba(218, 165, 32, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Check for triggers
                nodes.forEach(node => {
                    if (!node.active) return;

                    // Normalize angles
                    let nodeAngle = node.theta % (Math.PI * 2);
                    let playAngle = angle % (Math.PI * 2);
                    if (nodeAngle < 0) nodeAngle += Math.PI * 2;
                    if (playAngle < 0) playAngle += Math.PI * 2;

                    const angleDiff = Math.abs(nodeAngle - playAngle);
                    if ((angleDiff < 0.05 || angleDiff > Math.PI * 2 - 0.05) && !node.triggered) {
                        playNote(node);
                        node.triggered = true;
                    }
                    if (angleDiff > 0.1 && angleDiff < Math.PI * 2 - 0.1) {
                        node.triggered = false;
                    }
                });

                angle += 0.02;
            }

            requestAnimationFrame(draw);
        }

        function initNodes() {
            nodes.length = 0;
            for (let i = 0; i < maxNodes; i++) {
                const pos = getSpiralPosition(i);
                if (pos.x > 0 && pos.x < width && pos.y > 0 && pos.y < height) {
                    nodes.push({
                        ...pos,
                        index: i,
                        active: false,
                        glow: 0,
                        triggered: false
                    });
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            const clickX = e.clientX;
            const clickY = e.clientY;

            // Find nearest node
            let nearest = null;
            let nearestDist = Infinity;

            nodes.forEach(node => {
                const dist = Math.hypot(clickX - node.x, clickY - node.y);
                if (dist < nearestDist && dist < 30) {
                    nearest = node;
                    nearestDist = dist;
                }
            });

            if (nearest) {
                nearest.active = !nearest.active;
                if (nearest.active) {
                    if (audioCtx.state === 'suspended') audioCtx.resume();
                    playNote(nearest);
                }
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            nodes.forEach(n => n.active = false);
        });

        document.getElementById('goldenBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            // Activate nodes at Fibonacci positions
            const fibs = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
            nodes.forEach((n, i) => {
                n.active = fibs.includes(i);
            });
        });

        window.addEventListener('resize', () => {
            resize();
            initNodes();
        });

        resize();
        initNodes();
        draw();
    </script>
</body>
</html>
