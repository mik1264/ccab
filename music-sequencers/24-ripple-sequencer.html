<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripple Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000810;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(0,200,255,0.15);
            border: 1px solid rgba(0,200,255,0.5);
            color: #0cf;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,200,255,0.25); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0,200,255,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #0cf; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click to create ripples • Ripples trigger sounds when colliding</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="autoBtn">Auto: Off</button>
        <button id="clearBtn">Clear</button>
        <button id="modeBtn">Mode: Collide</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const ripples = [];
        let autoMode = false;
        let mode = 'collide'; // collide, expand, interval

        const notes = [130.81, 164.81, 196, 246.94, 261.63, 329.63, 392, 493.88, 523.25, 659.25];

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 300;
                this.speed = 2 + Math.random();
                this.hue = Math.random() * 360;
                this.noteIndex = Math.floor(Math.random() * notes.length);
                this.collidedWith = new Set();
                this.expandSounds = [];
                this.life = 1;

                this.playInitialNote();
            }

            playInitialNote() {
                this.playNote(notes[this.noteIndex], 0.2);
            }

            playNote(freq, volume) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sine';
                osc.frequency.value = freq;

                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            }

            update() {
                this.radius += this.speed;
                this.life = 1 - (this.radius / this.maxRadius);

                // Mode: expand - play at intervals
                if (mode === 'expand') {
                    const interval = 50;
                    const currentInterval = Math.floor(this.radius / interval);
                    if (!this.expandSounds.includes(currentInterval) && this.radius < this.maxRadius) {
                        this.expandSounds.push(currentInterval);
                        const freq = notes[this.noteIndex] * (1 + currentInterval * 0.1);
                        this.playNote(freq, 0.1 * this.life);
                    }
                }

                return this.radius > this.maxRadius;
            }

            draw() {
                // Multiple rings
                for (let i = 0; i < 3; i++) {
                    const r = this.radius - i * 10;
                    if (r > 0) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                        ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${this.life * (1 - i * 0.3)})`;
                        ctx.lineWidth = 2 - i * 0.5;
                        ctx.stroke();
                    }
                }

                // Center point
                if (this.life > 0.8) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${this.hue}, 80%, 70%, ${this.life})`;
                    ctx.fill();
                }
            }

            checkCollision(other) {
                if (this === other || this.collidedWith.has(other)) return;

                const dist = Math.hypot(this.x - other.x, this.y - other.y);
                const touchDist = this.radius + other.radius;
                const overlapDist = Math.abs(this.radius - other.radius);

                // Check if circles are touching
                if (dist < touchDist && dist > overlapDist - 10) {
                    this.collidedWith.add(other);
                    other.collidedWith.add(this);

                    // Play collision sound
                    const avgFreq = (notes[this.noteIndex] + notes[other.noteIndex]) / 2;
                    this.playNote(avgFreq, 0.15 * Math.min(this.life, other.life));

                    // Create collision point
                    const angle = Math.atan2(other.y - this.y, other.x - this.x);
                    const collX = this.x + Math.cos(angle) * this.radius;
                    const collY = this.y + Math.sin(angle) * this.radius;

                    // Visual effect
                    ctx.beginPath();
                    ctx.arc(collX, collY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${(this.hue + other.hue) / 2}, 90%, 70%, 0.8)`;
                    ctx.fill();
                }
            }
        }

        function createRipple(x, y) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            ripples.push(new Ripple(x, y));
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 8, 16, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Auto create ripples
            if (autoMode && Math.random() < 0.02) {
                createRipple(
                    Math.random() * width,
                    Math.random() * height
                );
            }

            // Update and draw ripples
            for (let i = ripples.length - 1; i >= 0; i--) {
                const ripple = ripples[i];

                if (ripple.update()) {
                    ripples.splice(i, 1);
                    continue;
                }

                // Check collisions
                if (mode === 'collide') {
                    for (let j = i + 1; j < ripples.length; j++) {
                        ripple.checkCollision(ripples[j]);
                    }
                }

                ripple.draw();
            }

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            createRipple(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (e.buttons === 1 && Math.random() < 0.1) {
                createRipple(e.clientX, e.clientY);
            }
        });

        document.getElementById('autoBtn').addEventListener('click', function() {
            autoMode = !autoMode;
            this.textContent = `Auto: ${autoMode ? 'On' : 'Off'}`;
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            ripples.length = 0;
        });

        const modes = ['collide', 'expand', 'interval'];
        let modeIndex = 0;

        document.getElementById('modeBtn').addEventListener('click', function() {
            modeIndex = (modeIndex + 1) % modes.length;
            mode = modes[modeIndex];
            this.textContent = `Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        draw();
    </script>
</body>
</html>
