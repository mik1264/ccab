<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arpeggiator Grid Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: linear-gradient(135deg, #0a1a2a 0%, #1a2a3a 100%); min-height: 100vh; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        canvas { display: block; cursor: pointer; }
        .controls { margin-top: 20px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        button, select { background: rgba(100,200,150,0.15); border: 1px solid rgba(100,200,150,0.5); color: #8ca; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover, select:hover { background: rgba(100,200,150,0.25); }
        .info { position: fixed; top: 20px; color: rgba(100,200,150,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #8ca; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click cells to set chord roots • Arpeggiator patterns create melodies</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <select id="patternSelect"><option value="up">Up</option><option value="down">Down</option><option value="updown">Up/Down</option><option value="random">Random</option></select>
        <button id="clearBtn">Clear</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cols = 8, rows = 4, cellSize = 70;
        canvas.width = cols * cellSize + 40;
        canvas.height = rows * cellSize + 40;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const grid = Array(rows).fill(null).map(() => Array(cols).fill(false));
        const glows = Array(rows).fill(null).map(() => Array(cols).fill(0));
        let isPlaying = false, currentCol = 0, arpStep = 0, lastStepTime = 0;
        let pattern = 'up';

        const chordRoots = [523.25, 440, 349.23, 261.63]; // C5, A4, F4, C4
        const chordIntervals = [0, 4, 7, 12]; // Major chord + octave
        const rowColors = ['#ff6b6b', '#feca57', '#48dbfb', '#54a0ff'];

        function getArpNote(rootFreq) {
            let idx;
            switch(pattern) {
                case 'up': idx = arpStep % chordIntervals.length; break;
                case 'down': idx = (chordIntervals.length - 1) - (arpStep % chordIntervals.length); break;
                case 'updown':
                    const cycle = chordIntervals.length * 2 - 2;
                    const pos = arpStep % cycle;
                    idx = pos < chordIntervals.length ? pos : cycle - pos;
                    break;
                case 'random': idx = Math.floor(Math.random() * chordIntervals.length); break;
            }
            return rootFreq * Math.pow(2, chordIntervals[idx] / 12);
        }

        function playNote(freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function draw(timestamp) {
            ctx.fillStyle = 'rgba(10, 26, 42, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (isPlaying && timestamp - lastStepTime > 100) {
                let hasNotes = false;
                for (let r = 0; r < rows; r++) {
                    if (grid[r][currentCol]) {
                        const freq = getArpNote(chordRoots[r]);
                        playNote(freq);
                        glows[r][currentCol] = 1;
                        hasNotes = true;
                    }
                }
                arpStep++;
                if (arpStep % 4 === 0) {
                    currentCol = (currentCol + 1) % cols;
                    arpStep = 0;
                }
                lastStepTime = timestamp;
            }

            // Draw grid
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const x = 20 + c * cellSize;
                    const y = 20 + r * cellSize;

                    if (glows[r][c] > 0) {
                        ctx.shadowColor = rowColors[r];
                        ctx.shadowBlur = 20 * glows[r][c];
                        glows[r][c] -= 0.03;
                    }

                    ctx.fillStyle = grid[r][c] ? rowColors[r] + 'cc' : 'rgba(255,255,255,0.1)';
                    ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);

                    if (c === currentCol && isPlaying) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
                    }

                    ctx.shadowBlur = 0;
                }
            }

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 20;
            const y = e.clientY - rect.top - 20;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (col >= 0 && col < cols && row >= 0 && row < rows) {
                grid[row][col] = !grid[row][col];
                if (grid[row][col] && audioCtx.state !== 'suspended') {
                    playNote(chordRoots[row]);
                }
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            arpStep = 0;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('patternSelect').addEventListener('change', function() {
            pattern = this.value;
            arpStep = 0;
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    grid[r][c] = false;
                }
            }
        });

        requestAnimationFrame(draw);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
