<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic Drum Machine</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0a; min-height: 100vh; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        canvas { display: block; cursor: pointer; }
        .controls { margin-top: 20px; display: flex; gap: 15px; }
        button { background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.5); color: #f66; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(255,100,100,0.3); }
        .info { position: fixed; top: 20px; color: rgba(255,100,100,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #f66; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Drag vertically to set probability • Random triggers create organic rhythms</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="tempoBtn">120 BPM</button>
        <button id="randomBtn">Randomize</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const steps = 16;
        const tracks = 4;
        const cellW = 40, cellH = 60;
        canvas.width = steps * cellW + 100;
        canvas.height = tracks * cellH + 40;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const grid = [];
        const trackNames = ['Kick', 'Snare', 'HiHat', 'Perc'];
        const trackColors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3'];
        let isPlaying = false, currentStep = 0, bpm = 120, lastStep = 0;
        const triggers = [];

        for (let t = 0; t < tracks; t++) {
            grid[t] = [];
            triggers[t] = [];
            for (let s = 0; s < steps; s++) {
                grid[t][s] = 0;
                triggers[t][s] = 0;
            }
        }

        function playDrum(track) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const noise = audioCtx.createOscillator();
            const noiseGain = audioCtx.createGain();

            if (track === 0) { // Kick
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            } else if (track === 1) { // Snare
                osc.frequency.value = 200;
                osc.type = 'triangle';
                noise.frequency.value = 1000;
                noise.type = 'sawtooth';
                noiseGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noise.start();
                noise.stop(audioCtx.currentTime + 0.15);
            } else if (track === 2) { // HiHat
                osc.frequency.value = 800;
                osc.type = 'square';
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            } else { // Perc
                osc.frequency.value = 400;
                osc.type = 'triangle';
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            }

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        function draw(timestamp) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const stepTime = 60000 / bpm / 4;
            if (isPlaying && timestamp - lastStep > stepTime) {
                for (let t = 0; t < tracks; t++) {
                    if (Math.random() < grid[t][currentStep]) {
                        playDrum(t);
                        triggers[t][currentStep] = 1;
                    }
                }
                currentStep = (currentStep + 1) % steps;
                lastStep = timestamp;
            }

            // Draw grid
            for (let t = 0; t < tracks; t++) {
                // Track label
                ctx.font = '12px Segoe UI';
                ctx.fillStyle = trackColors[t];
                ctx.textAlign = 'right';
                ctx.fillText(trackNames[t], 70, t * cellH + 35);

                for (let s = 0; s < steps; s++) {
                    const x = 80 + s * cellW;
                    const y = t * cellH + 10;
                    const prob = grid[t][s];

                    // Trigger glow
                    if (triggers[t][s] > 0) {
                        ctx.shadowColor = trackColors[t];
                        ctx.shadowBlur = 15 * triggers[t][s];
                        triggers[t][s] -= 0.05;
                    }

                    // Probability bar
                    ctx.fillStyle = `rgba(255,255,255,0.1)`;
                    ctx.fillRect(x, y, cellW - 4, cellH - 10);
                    ctx.fillStyle = trackColors[t] + (prob > 0 ? 'cc' : '40');
                    ctx.fillRect(x, y + (cellH - 10) * (1 - prob), cellW - 4, (cellH - 10) * prob);

                    ctx.shadowBlur = 0;

                    // Current step
                    if (s === currentStep && isPlaying) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, cellW - 4, cellH - 10);
                    }

                    // Probability text
                    if (prob > 0) {
                        ctx.font = '10px Segoe UI';
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${Math.round(prob * 100)}%`, x + (cellW - 4) / 2, y + cellH / 2);
                    }
                }
            }

            requestAnimationFrame(draw);
        }

        let dragging = false, dragTrack = -1;
        canvas.addEventListener('mousedown', (e) => {
            dragging = true;
            updateCell(e);
        });
        canvas.addEventListener('mousemove', (e) => { if (dragging) updateCell(e); });
        canvas.addEventListener('mouseup', () => { dragging = false; dragTrack = -1; });
        canvas.addEventListener('mouseleave', () => { dragging = false; });

        function updateCell(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 80;
            const y = e.clientY - rect.top;
            const step = Math.floor(x / cellW);
            const track = Math.floor(y / cellH);

            if (step >= 0 && step < steps && track >= 0 && track < tracks) {
                const cellY = (y - track * cellH - 10) / (cellH - 10);
                grid[track][step] = Math.max(0, Math.min(1, 1 - cellY));
            }
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('tempoBtn').addEventListener('click', function() {
            bpm = bpm === 120 ? 140 : bpm === 140 ? 90 : 120;
            this.textContent = `${bpm} BPM`;
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            for (let t = 0; t < tracks; t++) {
                for (let s = 0; s < steps; s++) {
                    grid[t][s] = Math.random() < 0.3 ? Math.random() : 0;
                }
            }
        });

        requestAnimationFrame(draw);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
