<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Signature Morph Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a15; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(255,150,100,0.15); border: 1px solid rgba(255,150,100,0.5); color: #fa6; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(255,150,100,0.25); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(255,150,100,0.7); font-size: 14px; }
        .signature { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.8); font-size: 32px; font-weight: bold; }
        a.back { position: fixed; top: 20px; left: 20px; color: #fa6; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Time signature morphs over time • Patterns adapt to changing meters</div>
    <div class="signature" id="signature">4/4</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="morphBtn">Morph Now</button>
        <button id="resetBtn">Reset to 4/4</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const signatures = [[4,4], [3,4], [5,4], [7,8], [6,8], [5,8], [9,8], [11,8]];
        let currentSig = [4, 4];
        let targetSig = [4, 4];
        let morphProgress = 1;
        let isPlaying = false;
        let beat = 0, lastBeatTime = 0;
        const bpm = 120;

        const notes = [261.63, 329.63, 392, 523.25];
        const pattern = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]; // Extends to any meter
        const glows = [];

        function getBeatsInMeasure() {
            return Math.round(currentSig[0] + (targetSig[0] - currentSig[0]) * (1 - morphProgress));
        }

        function playBeat(beatNum) {
            const isDownbeat = beatNum === 0;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = isDownbeat ? 'triangle' : 'sine';
            osc.frequency.value = isDownbeat ? notes[3] : notes[beatNum % notes.length];

            gain.gain.setValueAtTime(isDownbeat ? 0.3 : 0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);

            glows[beatNum] = 1;
        }

        function morph() {
            const newSig = signatures[Math.floor(Math.random() * signatures.length)];
            targetSig = newSig;
            morphProgress = 0;
        }

        function draw(timestamp) {
            ctx.fillStyle = 'rgba(10, 10, 21, 0.15)';
            ctx.fillRect(0, 0, width, height);

            const beatsInMeasure = getBeatsInMeasure();
            const beatInterval = 60000 / bpm * (4 / currentSig[1]);

            if (isPlaying && timestamp - lastBeatTime > beatInterval) {
                playBeat(beat);
                beat = (beat + 1) % beatsInMeasure;
                lastBeatTime = timestamp;

                // Progress morph
                if (morphProgress < 1) {
                    morphProgress += 0.02;
                    if (morphProgress >= 1) {
                        currentSig = [...targetSig];
                        morphProgress = 1;
                    }
                }
            }

            // Update display
            const displayNum = Math.round(currentSig[0] + (targetSig[0] - currentSig[0]) * (1 - morphProgress));
            const displayDen = morphProgress < 0.5 ? currentSig[1] : targetSig[1];
            document.getElementById('signature').textContent = `${displayNum}/${displayDen}`;

            // Draw beats
            const centerY = height / 2;
            const maxBeats = 11;
            const beatWidth = (width - 200) / maxBeats;

            for (let i = 0; i < beatsInMeasure; i++) {
                const x = 100 + i * beatWidth + beatWidth / 2;
                const isActive = i === beat && isPlaying;
                const isDownbeat = i === 0;

                if (glows[i] > 0) {
                    ctx.shadowColor = isDownbeat ? '#fa6' : '#fff';
                    ctx.shadowBlur = 30 * glows[i];
                    glows[i] -= 0.03;
                }

                ctx.beginPath();
                ctx.arc(x, centerY, isDownbeat ? 35 : 25, 0, Math.PI * 2);
                ctx.fillStyle = isActive ? '#fff' : (isDownbeat ? '#fa6' : 'rgba(255,150,100,0.4)');
                ctx.fill();

                if (isActive) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;

                // Beat number
                ctx.font = 'bold 16px Segoe UI';
                ctx.fillStyle = isActive || isDownbeat ? '#000' : 'rgba(255,255,255,0.5)';
                ctx.textAlign = 'center';
                ctx.fillText(i + 1, x, centerY + 6);
            }

            // Morph progress bar
            if (morphProgress < 1) {
                ctx.fillStyle = 'rgba(255,150,100,0.3)';
                ctx.fillRect(100, height - 80, (width - 200) * morphProgress, 10);
                ctx.strokeStyle = 'rgba(255,150,100,0.5)';
                ctx.strokeRect(100, height - 80, width - 200, 10);
            }

            requestAnimationFrame(draw);
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            beat = 0;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('morphBtn').addEventListener('click', morph);

        document.getElementById('resetBtn').addEventListener('click', () => {
            currentSig = [4, 4];
            targetSig = [4, 4];
            morphProgress = 1;
            beat = 0;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        // Auto-morph every 8 measures
        setInterval(() => {
            if (isPlaying && morphProgress >= 1) {
                morph();
            }
        }, 8000);

        requestAnimationFrame(draw);
    </script>
</body>
</html>
