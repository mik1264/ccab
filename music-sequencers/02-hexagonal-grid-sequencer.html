<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Grid Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: rgba(255,255,255,0.2); }
        .info {
            position: fixed;
            top: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click hexagons to activate • Wave sweeps across the grid</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="clearBtn">Clear</button>
        <button id="randomBtn">Random</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isPlaying = false;
        let sweepX = 0;

        const hexSize = 35;
        const hexHeight = hexSize * 2;
        const hexWidth = Math.sqrt(3) * hexSize;
        const hexagons = [];

        // Chromatic scale
        const frequencies = [];
        for (let i = 0; i < 20; i++) {
            frequencies.push(220 * Math.pow(2, i / 12));
        }

        const hueOffset = Math.random() * 360;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initHexGrid();
        }

        function initHexGrid() {
            hexagons.length = 0;
            const cols = Math.ceil(width / hexWidth) + 2;
            const rows = Math.ceil(height / (hexHeight * 0.75)) + 2;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * hexWidth + (row % 2) * (hexWidth / 2);
                    const y = row * hexHeight * 0.75;
                    hexagons.push({
                        x, y,
                        active: false,
                        triggered: false,
                        glow: 0,
                        row, col
                    });
                }
            }
        }

        function drawHex(x, y, size, fill, stroke) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const px = x + size * Math.cos(angle);
                const py = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            if (fill) { ctx.fillStyle = fill; ctx.fill(); }
            if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
        }

        function playNote(hex) {
            const rowFreq = frequencies[hex.row % frequencies.length];

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = ['sine', 'triangle', 'square'][hex.col % 3];
            osc.frequency.value = rowFreq;

            filter.type = 'lowpass';
            filter.frequency.value = 3000;
            filter.Q.value = 2;

            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);

            hex.glow = 1;
        }

        function draw() {
            ctx.fillStyle = 'rgba(26, 26, 46, 0.2)';
            ctx.fillRect(0, 0, width, height);

            // Draw hexagons
            hexagons.forEach(hex => {
                const hue = (hex.row * 20 + hueOffset) % 360;

                if (hex.glow > 0) {
                    ctx.shadowColor = `hsl(${hue}, 80%, 60%)`;
                    ctx.shadowBlur = 30 * hex.glow;
                    hex.glow -= 0.02;
                }

                if (hex.active) {
                    drawHex(hex.x, hex.y, hexSize - 3, `hsla(${hue}, 70%, 50%, 0.8)`, `hsl(${hue}, 80%, 70%)`);
                } else {
                    drawHex(hex.x, hex.y, hexSize - 3, 'rgba(255,255,255,0.05)', 'rgba(255,255,255,0.15)');
                }
                ctx.shadowBlur = 0;
            });

            // Draw sweep line
            if (isPlaying) {
                ctx.beginPath();
                ctx.moveTo(sweepX, 0);
                ctx.lineTo(sweepX, height);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Create glow effect for sweep
                const gradient = ctx.createLinearGradient(sweepX - 50, 0, sweepX + 50, 0);
                gradient.addColorStop(0, 'rgba(100, 200, 255, 0)');
                gradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(sweepX - 50, 0, 100, height);

                // Trigger hexagons
                hexagons.forEach(hex => {
                    const dist = Math.abs(hex.x - sweepX);
                    if (dist < 5 && hex.active && !hex.triggered) {
                        playNote(hex);
                        hex.triggered = true;
                    }
                    if (dist > hexWidth) {
                        hex.triggered = false;
                    }
                });

                sweepX += 3;
                if (sweepX > width + 50) sweepX = -50;
            }

            requestAnimationFrame(draw);
        }

        function getHexAt(x, y) {
            return hexagons.find(hex => {
                const dx = x - hex.x;
                const dy = y - hex.y;
                return Math.sqrt(dx * dx + dy * dy) < hexSize - 5;
            });
        }

        canvas.addEventListener('click', (e) => {
            const hex = getHexAt(e.clientX, e.clientY);
            if (hex) {
                hex.active = !hex.active;
                if (hex.active) playNote(hex);
            }
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            hexagons.forEach(h => h.active = false);
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            hexagons.forEach(h => h.active = Math.random() < 0.15);
        });

        // Expose for enhance.js
        window.reset = function() { hexagons.forEach(h => h.active = false); sweepX = 0; };

        window.addEventListener('resize', resize);
        resize();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
