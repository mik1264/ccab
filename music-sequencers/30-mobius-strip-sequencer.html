<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Möbius Strip Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0f0a1a 0%, #1a0f2a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(180,100,255,0.15);
            border: 1px solid rgba(180,100,255,0.5);
            color: #b8f;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(180,100,255,0.25); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(180,100,255,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #b8f; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Notes on a Möbius strip • The sequence inverts when completing a loop</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="randomBtn">Randomize</button>
        <button id="speedBtn">Speed: Normal</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let isPlaying = false;
        let time = 0;
        let speed = 0.01;
        let position = 0;
        let loops = 0;

        const numSteps = 16;
        const notes = [];
        const noteFreqs = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];

        // Initialize notes
        for (let i = 0; i < numSteps; i++) {
            notes.push({
                active: Math.random() < 0.4,
                noteIndex: Math.floor(Math.random() * noteFreqs.length),
                glow: 0
            });
        }

        function getMobiusPoint(u, v) {
            // u is position along the strip (0 to 2π)
            // v is position across the strip (-0.5 to 0.5)

            const R = 120; // Major radius
            const w = 60;  // Half-width of strip

            const x = (R + w * v * Math.cos(u / 2)) * Math.cos(u);
            const y = (R + w * v * Math.cos(u / 2)) * Math.sin(u);
            const z = w * v * Math.sin(u / 2);

            return { x, y, z };
        }

        function project3D(x, y, z) {
            // Rotate the entire strip
            const rotX = time * 0.3;
            const rotY = time * 0.5;

            // Rotation around X
            let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
            let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);

            // Rotation around Y
            let x1 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
            let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

            // Perspective projection
            const scale = 400 / (400 + z2);
            return {
                px: width / 2 + x1 * scale,
                py: height / 2 + y1 * scale,
                scale,
                z: z2
            };
        }

        function playNote(noteIndex) {
            const freq = noteFreqs[noteIndex];

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // On alternate loops, play inverted notes
            const actualFreq = loops % 2 === 0 ? freq : noteFreqs[noteFreqs.length - 1 - noteIndex];

            osc.type = loops % 2 === 0 ? 'sine' : 'triangle';
            osc.frequency.value = actualFreq;

            filter.type = 'lowpass';
            filter.frequency.value = 2000;

            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
        }

        function draw() {
            ctx.fillStyle = 'rgba(15, 10, 26, 0.15)';
            ctx.fillRect(0, 0, width, height);

            time += 0.01;

            if (isPlaying) {
                const prevPosition = position;
                position += speed;

                if (position >= Math.PI * 2) {
                    position -= Math.PI * 2;
                    loops++;
                }

                // Check note triggers
                const currentStep = Math.floor((position / (Math.PI * 2)) * numSteps);
                const prevStep = Math.floor((prevPosition / (Math.PI * 2)) * numSteps);

                if (currentStep !== prevStep) {
                    // On odd loops, play sequence backwards
                    const actualStep = loops % 2 === 0 ? currentStep : (numSteps - 1 - currentStep);
                    const note = notes[actualStep];
                    if (note.active) {
                        playNote(note.noteIndex);
                        note.glow = 1;
                    }
                }
            }

            // Draw Möbius strip surface
            const segments = 60;
            const strips = 8;

            // Store points for depth sorting
            const points = [];

            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < strips; j++) {
                    const u1 = (i / segments) * Math.PI * 2;
                    const u2 = ((i + 1) / segments) * Math.PI * 2;
                    const v1 = (j / strips - 0.5);
                    const v2 = ((j + 1) / strips - 0.5);

                    const p1 = getMobiusPoint(u1, v1);
                    const p2 = getMobiusPoint(u2, v1);
                    const p3 = getMobiusPoint(u2, v2);
                    const p4 = getMobiusPoint(u1, v2);

                    const proj1 = project3D(p1.x, p1.y, p1.z);
                    const proj2 = project3D(p2.x, p2.y, p2.z);
                    const proj3 = project3D(p3.x, p3.y, p3.z);
                    const proj4 = project3D(p4.x, p4.y, p4.z);

                    const avgZ = (proj1.z + proj2.z + proj3.z + proj4.z) / 4;

                    points.push({
                        type: 'quad',
                        points: [proj1, proj2, proj3, proj4],
                        z: avgZ,
                        u: u1,
                        hue: (u1 / (Math.PI * 2)) * 360
                    });
                }
            }

            // Draw note markers
            for (let i = 0; i < numSteps; i++) {
                const u = (i / numSteps) * Math.PI * 2;
                const p = getMobiusPoint(u, 0);
                const proj = project3D(p.x, p.y, p.z);

                points.push({
                    type: 'note',
                    proj,
                    z: proj.z,
                    note: notes[i],
                    index: i,
                    u
                });
            }

            // Playhead
            const playheadP = getMobiusPoint(position, 0);
            const playheadProj = project3D(playheadP.x, playheadP.y, playheadP.z);
            points.push({
                type: 'playhead',
                proj: playheadProj,
                z: playheadProj.z + 1
            });

            // Sort by depth (back to front)
            points.sort((a, b) => a.z - b.z);

            // Draw sorted elements
            points.forEach(item => {
                if (item.type === 'quad') {
                    const [p1, p2, p3, p4] = item.points;
                    ctx.beginPath();
                    ctx.moveTo(p1.px, p1.py);
                    ctx.lineTo(p2.px, p2.py);
                    ctx.lineTo(p3.px, p3.py);
                    ctx.lineTo(p4.px, p4.py);
                    ctx.closePath();

                    const brightness = 30 + (item.z + 200) / 4;
                    ctx.fillStyle = `hsla(${item.hue}, 60%, ${brightness}%, 0.3)`;
                    ctx.fill();
                    ctx.strokeStyle = `hsla(${item.hue}, 70%, 50%, 0.3)`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                } else if (item.type === 'note') {
                    const { proj, note, index, u } = item;

                    if (note.glow > 0) {
                        ctx.shadowColor = `hsl(${(u / (Math.PI * 2)) * 360}, 80%, 60%)`;
                        ctx.shadowBlur = 20 * note.glow;
                        note.glow -= 0.02;
                    }

                    ctx.beginPath();
                    ctx.arc(proj.px, proj.py, note.active ? 10 * proj.scale : 6 * proj.scale, 0, Math.PI * 2);
                    ctx.fillStyle = note.active
                        ? `hsl(${(u / (Math.PI * 2)) * 360}, 70%, 60%)`
                        : 'rgba(255,255,255,0.2)';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (item.type === 'playhead') {
                    ctx.beginPath();
                    ctx.arc(item.proj.px, item.proj.py, 15, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 20;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            // Loop indicator
            ctx.font = '16px Segoe UI';
            ctx.fillStyle = 'rgba(180, 100, 255, 0.7)';
            ctx.textAlign = 'center';
            ctx.fillText(`Loop ${loops + 1} - ${loops % 2 === 0 ? 'Forward' : 'Inverted'}`, width / 2, 60);

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            // Simple toggle - find nearest note
            const centerX = width / 2;
            const centerY = height / 2;
            const clickAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
            const normalizedAngle = (clickAngle + Math.PI) / (Math.PI * 2);
            const noteIndex = Math.floor(normalizedAngle * numSteps) % numSteps;

            notes[noteIndex].active = !notes[noteIndex].active;
            if (notes[noteIndex].active) {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                playNote(notes[noteIndex].noteIndex);
                notes[noteIndex].glow = 1;
            }
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            notes.forEach(note => {
                note.active = Math.random() < 0.4;
                note.noteIndex = Math.floor(Math.random() * noteFreqs.length);
            });
        });

        document.getElementById('speedBtn').addEventListener('click', function() {
            speed = speed === 0.01 ? 0.02 : speed === 0.02 ? 0.005 : 0.01;
            const label = speed === 0.01 ? 'Normal' : speed === 0.02 ? 'Fast' : 'Slow';
            this.textContent = `Speed: ${label}`;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        draw();
    </script>
</body>
</html>
