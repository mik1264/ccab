<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pendulum Wave Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas { display: block; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        button, select {
            background: rgba(255,200,100,0.1);
            border: 1px solid rgba(255,200,100,0.5);
            color: #fc8;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover, select:hover { background: rgba(255,200,100,0.2); }
        .info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,200,100,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #fc8; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Pendulums with different lengths create evolving wave patterns</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Start</button>
        <button id="resetBtn">Reset</button>
        <select id="scaleSelect">
            <option value="pentatonic">Pentatonic</option>
            <option value="major">Major</option>
            <option value="minor">Minor</option>
            <option value="chromatic">Chromatic</option>
        </select>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const numPendulums = 15;
        const pendulums = [];
        let isPlaying = false;
        let startTime = 0;

        const scales = {
            pentatonic: [0, 2, 4, 7, 9],
            major: [0, 2, 4, 5, 7, 9, 11],
            minor: [0, 2, 3, 5, 7, 8, 10],
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        };
        let currentScale = 'pentatonic';

        const baseFreq = 440;
        const triggerZoneY = height * 0.85;

        class Pendulum {
            constructor(index, total) {
                this.index = index;
                this.x = width * 0.15 + (width * 0.7) * (index / (total - 1));
                this.pivotY = 50;
                // Varying lengths for wave effect
                this.length = 150 + index * 20;
                // Period varies with sqrt of length (physics!)
                this.period = 2 + index * 0.15;
                this.angle = Math.PI / 4;
                this.phase = 0;
                this.hue = (index / total) * 280 + 30;
                this.lastTriggered = -1;
                this.glow = 0;
            }

            update(time) {
                this.angle = Math.PI / 4 * Math.cos(2 * Math.PI * time / this.period + this.phase);
                this.bobX = this.x + Math.sin(this.angle) * this.length;
                this.bobY = this.pivotY + Math.cos(this.angle) * this.length;

                if (this.glow > 0) this.glow -= 0.03;

                // Check trigger zone crossing
                const prevY = this.pivotY + Math.cos(Math.PI / 4 * Math.cos(2 * Math.PI * (time - 0.016) / this.period + this.phase)) * this.length;

                if (prevY < triggerZoneY && this.bobY >= triggerZoneY && time - this.lastTriggered > 0.1) {
                    this.trigger();
                    this.lastTriggered = time;
                }
            }

            trigger() {
                const scale = scales[currentScale];
                const noteIndex = this.index % scale.length;
                const octave = Math.floor(this.index / scale.length);
                const semitone = scale[noteIndex] + octave * 12;
                const freq = baseFreq * Math.pow(2, semitone / 12);

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = freq;

                // Add slight detune for warmth
                const osc2 = audioCtx.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.value = freq * 1.002;
                const gain2 = audioCtx.createGain();
                gain2.gain.value = 0.1;

                filter.type = 'lowpass';
                filter.frequency.value = 1500 + this.index * 100;

                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

                osc.connect(filter);
                osc2.connect(gain2);
                gain2.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc2.start();
                osc.stop(audioCtx.currentTime + 0.5);
                osc2.stop(audioCtx.currentTime + 0.5);

                this.glow = 1;
            }

            draw() {
                // Draw string
                ctx.beginPath();
                ctx.moveTo(this.x, this.pivotY);
                ctx.lineTo(this.bobX, this.bobY);
                ctx.strokeStyle = `hsla(${this.hue}, 60%, 50%, 0.5)`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw bob
                if (this.glow > 0) {
                    ctx.shadowColor = `hsl(${this.hue}, 80%, 60%)`;
                    ctx.shadowBlur = 30 * this.glow;
                }

                ctx.beginPath();
                ctx.arc(this.bobX, this.bobY, 12, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(this.bobX - 3, this.bobY - 3, 0, this.bobX, this.bobY, 12);
                gradient.addColorStop(0, `hsl(${this.hue}, 70%, 70%)`);
                gradient.addColorStop(1, `hsl(${this.hue}, 70%, 40%)`);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function init() {
            pendulums.length = 0;
            for (let i = 0; i < numPendulums; i++) {
                pendulums.push(new Pendulum(i, numPendulums));
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(15, 15, 26, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Draw trigger zone
            ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(0, triggerZoneY);
            ctx.lineTo(width, triggerZoneY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw glow on trigger zone
            const gradient = ctx.createLinearGradient(0, triggerZoneY - 20, 0, triggerZoneY + 20);
            gradient.addColorStop(0, 'rgba(255, 200, 100, 0)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, triggerZoneY - 20, width, 40);

            // Update and draw pendulums
            const time = isPlaying ? (Date.now() - startTime) / 1000 : 0;

            pendulums.forEach(p => {
                if (isPlaying) p.update(time);
                p.draw();
            });

            // Draw trail effect connecting bobs
            ctx.beginPath();
            ctx.moveTo(pendulums[0].bobX, pendulums[0].bobY);
            for (let i = 1; i < pendulums.length; i++) {
                ctx.lineTo(pendulums[i].bobX, pendulums[i].bobY);
            }
            ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            requestAnimationFrame(draw);
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            if (isPlaying) startTime = Date.now();
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isPlaying = false;
            document.getElementById('playBtn').textContent = '▶ Start';
            init();
        });

        document.getElementById('scaleSelect').addEventListener('change', function() {
            currentScale = this.value;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        });

        init();
        draw();
    </script>
</body>
</html>
