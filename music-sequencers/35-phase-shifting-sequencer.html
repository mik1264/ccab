<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase Shifting Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a12; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { background: rgba(150,100,255,0.15); border: 1px solid rgba(150,100,255,0.5); color: #a8f; padding: 10px 20px; border-radius: 20px; cursor: pointer; }
        button:hover { background: rgba(150,100,255,0.25); }
        .info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(150,100,255,0.7); font-size: 14px; }
        a.back { position: fixed; top: 20px; left: 20px; color: #a8f; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Multiple loops run at slightly different speeds • They phase in and out of sync</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <button id="resetBtn">Reset Phase</button>
        <button id="patternBtn">Pattern: Simple</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const numLoops = 4;
        const stepsPerLoop = 8;
        const loops = [];
        let isPlaying = false;
        let patternType = 'simple';

        const patterns = {
            simple: [[1,0,0,0,1,0,0,0],[0,0,1,0,0,0,1,0],[0,1,0,1,0,1,0,1],[1,1,0,0,1,1,0,0]],
            complex: [[1,0,1,0,0,1,0,0],[0,1,0,0,1,0,1,0],[1,0,0,1,0,0,1,1],[0,0,1,1,1,0,0,1]]
        };
        const notes = [261.63, 329.63, 392, 523.25];
        const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3'];

        function initLoops() {
            loops.length = 0;
            for (let i = 0; i < numLoops; i++) {
                loops.push({
                    position: 0,
                    speed: 1 + i * 0.02, // Slightly different speeds
                    pattern: patterns[patternType][i],
                    lastStep: -1,
                    glow: Array(stepsPerLoop).fill(0)
                });
            }
        }

        function playNote(loopIndex) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = notes[loopIndex];
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 18, 0.15)';
            ctx.fillRect(0, 0, width, height);

            const centerY = height / 2;
            const loopHeight = 60;
            const loopSpacing = 80;
            const stepWidth = (width - 200) / stepsPerLoop;

            loops.forEach((loop, loopIdx) => {
                const y = centerY - (numLoops / 2 - loopIdx - 0.5) * loopSpacing;

                if (isPlaying) {
                    loop.position += 0.02 * loop.speed;
                    if (loop.position >= stepsPerLoop) loop.position -= stepsPerLoop;

                    const currentStep = Math.floor(loop.position);
                    if (currentStep !== loop.lastStep && loop.pattern[currentStep]) {
                        playNote(loopIdx);
                        loop.glow[currentStep] = 1;
                    }
                    loop.lastStep = currentStep;
                }

                // Draw steps
                for (let s = 0; s < stepsPerLoop; s++) {
                    const x = 100 + s * stepWidth;

                    if (loop.glow[s] > 0) {
                        ctx.shadowColor = colors[loopIdx];
                        ctx.shadowBlur = 20 * loop.glow[s];
                        loop.glow[s] -= 0.03;
                    }

                    ctx.fillStyle = loop.pattern[s] ? colors[loopIdx] : 'rgba(255,255,255,0.1)';
                    ctx.fillRect(x, y - loopHeight/2, stepWidth - 4, loopHeight);
                    ctx.shadowBlur = 0;

                    // Playhead
                    const playheadX = 100 + loop.position * stepWidth;
                    if (isPlaying && s === Math.floor(loop.position)) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, y - loopHeight/2, stepWidth - 4, loopHeight);
                    }
                }

                // Label
                ctx.font = '14px Segoe UI';
                ctx.fillStyle = colors[loopIdx];
                ctx.textAlign = 'right';
                ctx.fillText(`Loop ${loopIdx + 1} (${loop.speed.toFixed(2)}x)`, 90, y + 5);
            });

            requestAnimationFrame(draw);
        }

        document.getElementById('playBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            loops.forEach(l => { l.position = 0; l.lastStep = -1; });
        });

        document.getElementById('patternBtn').addEventListener('click', function() {
            patternType = patternType === 'simple' ? 'complex' : 'simple';
            this.textContent = `Pattern: ${patternType.charAt(0).toUpperCase() + patternType.slice(1)}`;
            initLoops();
        });

        window.addEventListener('resize', () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; });

        initLoops();
        draw();
    </script>
</body>
</html>
