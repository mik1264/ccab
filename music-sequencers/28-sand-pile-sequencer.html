<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sand Pile Sequencer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1510;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
        }
        canvas { display: block; border-radius: 10px; cursor: pointer; }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(210,180,140,0.2);
            border: 1px solid rgba(210,180,140,0.5);
            color: #d2b48c;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        button:hover { background: rgba(210,180,140,0.3); }
        .info {
            position: fixed;
            top: 20px;
            color: rgba(210,180,140,0.7);
            font-size: 14px;
        }
        a.back { position: fixed; top: 20px; left: 20px; color: #d2b48c; text-decoration: none; }
    </style>
</head>
<body>
    <a class="back" href="index.html">← Back</a>
    <div class="info">Click to drop sand • Avalanches create cascading notes</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="autoBtn">Auto Drop: Off</button>
        <button id="clearBtn">Clear</button>
        <button id="criticalBtn">To Critical</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const cellSize = 8;
        const cols = Math.floor(Math.min(window.innerWidth - 40, 600) / cellSize);
        const rows = Math.floor(Math.min(window.innerHeight - 150, 500) / cellSize);
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let grid = [];
        let autoMode = false;
        let avalancheSize = 0;

        const colors = ['#1a1510', '#4a3520', '#8b6914', '#d4a017', '#ffd700'];
        const notes = [196, 220, 246.94, 261.63, 293.66, 329.63, 349.23, 392, 440];

        function initGrid() {
            grid = Array(rows).fill(null).map(() => Array(cols).fill(0));
        }

        function addGrain(x, y) {
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                grid[y][x]++;
            }
        }

        function topple() {
            let toppled = false;
            const toppledCells = [];

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x] >= 4) {
                        toppled = true;
                        toppledCells.push({ x, y, count: grid[y][x] });

                        grid[y][x] -= 4;

                        // Distribute to neighbors
                        if (y > 0) grid[y - 1][x]++;
                        if (y < rows - 1) grid[y + 1][x]++;
                        if (x > 0) grid[y][x - 1]++;
                        if (x < cols - 1) grid[y][x + 1]++;
                    }
                }
            }

            if (toppled) {
                avalancheSize += toppledCells.length;
                playAvalanche(toppledCells);
            }

            return toppled;
        }

        function playAvalanche(cells) {
            if (cells.length === 0) return;

            // Play notes based on position
            const uniqueRows = [...new Set(cells.map(c => c.y))];

            uniqueRows.forEach((row, i) => {
                setTimeout(() => {
                    const noteIndex = Math.floor((row / rows) * notes.length);
                    const freq = notes[noteIndex];

                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    osc.type = 'triangle';
                    osc.frequency.value = freq;

                    const vol = 0.08 + Math.min(0.15, cells.length * 0.01);
                    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                }, i * 20);
            });
        }

        function draw() {
            ctx.fillStyle = '#1a1510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const val = Math.min(grid[y][x], 4);
                    if (val > 0) {
                        ctx.fillStyle = colors[val];
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);

                        // Glow for cells about to topple
                        if (grid[y][x] >= 3) {
                            ctx.shadowColor = colors[val];
                            ctx.shadowBlur = 5;
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }

            // Auto mode
            if (autoMode && Math.random() < 0.3) {
                const x = Math.floor(cols / 2 + (Math.random() - 0.5) * 10);
                const y = Math.floor(rows / 2 + (Math.random() - 0.5) * 10);
                addGrain(x, y);
            }

            // Topple
            if (topple()) {
                // Continue animation
            }

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);

            avalancheSize = 0;
            addGrain(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (e.buttons === 1) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / cellSize);
                const y = Math.floor((e.clientY - rect.top) / cellSize);
                if (Math.random() < 0.3) addGrain(x, y);
            }
        });

        document.getElementById('autoBtn').addEventListener('click', function() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            autoMode = !autoMode;
            this.textContent = `Auto Drop: ${autoMode ? 'On' : 'Off'}`;
        });

        document.getElementById('clearBtn').addEventListener('click', initGrid);

        document.getElementById('criticalBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            // Fill to near-critical state
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid[y][x] = Math.floor(Math.random() * 4);
                }
            }
        });

        initGrid();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
