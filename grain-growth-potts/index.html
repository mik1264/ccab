<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Grain Growth - Potts Model</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: bold; z-index: 10;
    text-shadow: 0 0 20px rgba(251,191,36,0.5);
    pointer-events: none;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 15px; align-items: center; z-index: 10;
    background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 10px;
}
#controls label { color: #fbbf24; font-size: 13px; }
#controls input[type=range] { width: 90px; cursor: pointer; }
#controls button {
    background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid #fbbf24;
    padding: 5px 12px; border-radius: 5px; cursor: pointer; font-size: 13px;
}
#controls button:hover { background: rgba(251,191,36,0.4); }
#info {
    position: fixed; top: 80px; right: 20px; color: #64748b; font-size: 12px;
    z-index: 10; text-align: right; line-height: 1.6;
}
#controls select {
    background: rgba(0,0,0,0.5); color: #fbbf24; border: 1px solid #fbbf24;
    padding: 3px 8px; border-radius: 4px; font-size: 13px; cursor: pointer;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title">Grain Growth (Potts Model)</div>
<div id="info">
    Step: <span id="stepCount">0</span><br>
    Grains: <span id="grainCount">0</span><br>
    Temperature: <span id="tempDisplay">0.5</span>
</div>
<div id="controls">
    <label>Temperature: <input type="range" id="temperature" min="1" max="10" value="5" step="1"></label>
    <label>Grains: <select id="numGrains">
        <option value="20">20</option>
        <option value="50" selected>50</option>
        <option value="100">100</option>
        <option value="200">200</option>
    </select></label>
    <label>Speed: <input type="range" id="speed" min="1" max="50" value="20" step="1"></label>
    <label>Boundaries: <input type="checkbox" id="showBounds" checked></label>
    <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H, gridW, gridH;
const CELL = 3;
let grid, grainColors;
let numGrains = 50;
let temperature = 0.5;
let speed = 20;
let stepCount = 0;
let showBoundaries = true;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    gridW = Math.floor(W / CELL);
    gridH = Math.floor(H / CELL);
}

function generateColors(n) {
    const colors = [];
    for (let i = 0; i < n; i++) {
        const hue = (i * 360 / n + Math.random() * 20) % 360;
        const sat = 50 + Math.random() * 40;
        const lit = 35 + Math.random() * 30;
        colors.push(hslToRgb(hue, sat, lit));
    }
    return colors;
}

function hslToRgb(h, s, l) {
    s /= 100; l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c / 2;
    let r, g, b;
    if (h < 60) { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    return [
        Math.floor((r + m) * 255),
        Math.floor((g + m) * 255),
        Math.floor((b + m) * 255)
    ];
}

function init() {
    resize();
    grid = new Uint16Array(gridW * gridH);
    grainColors = generateColors(numGrains);
    stepCount = 0;

    // Voronoi initialization: place random seed points
    const seeds = [];
    for (let i = 0; i < numGrains; i++) {
        seeds.push({
            x: Math.floor(Math.random() * gridW),
            y: Math.floor(Math.random() * gridH),
            id: i
        });
    }

    // Assign each cell to nearest seed
    for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
            let minDist = Infinity;
            let closest = 0;
            for (const seed of seeds) {
                const dx = x - seed.x;
                const dy = y - seed.y;
                const d = dx * dx + dy * dy;
                if (d < minDist) {
                    minDist = d;
                    closest = seed.id;
                }
            }
            grid[y * gridW + x] = closest;
        }
    }
}

function pottsStep(iterations) {
    const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];

    for (let iter = 0; iter < iterations; iter++) {
        // Pick random site
        const x = Math.floor(Math.random() * (gridW - 2)) + 1;
        const y = Math.floor(Math.random() * (gridH - 2)) + 1;
        const idx = y * gridW + x;
        const currentGrain = grid[idx];

        // Count neighbor grains
        const neighborGrains = new Map();
        let currentEnergy = 0;
        for (const [dx, dy] of dirs) {
            const nIdx = (y + dy) * gridW + (x + dx);
            const ng = grid[nIdx];
            neighborGrains.set(ng, (neighborGrains.get(ng) || 0) + 1);
            if (ng !== currentGrain) currentEnergy++;
        }

        // Pick a random neighbor grain to potentially switch to
        const nx = x + dirs[Math.floor(Math.random() * dirs.length)][0];
        const ny = y + dirs[Math.floor(Math.random() * dirs.length)][1];
        const newGrain = grid[ny * gridW + nx];

        if (newGrain === currentGrain) continue;

        // Calculate energy change
        let newEnergy = 0;
        for (const [dx, dy] of dirs) {
            const ng = grid[(y + dy) * gridW + (x + dx)];
            if (ng !== newGrain) newEnergy++;
        }

        const deltaE = newEnergy - currentEnergy;

        // Metropolis criterion
        if (deltaE <= 0 || Math.random() < Math.exp(-deltaE / temperature)) {
            grid[idx] = newGrain;
        }
    }
    stepCount += iterations;
}

function countGrains() {
    const present = new Set();
    for (let i = 0; i < grid.length; i++) {
        present.add(grid[i]);
    }
    return present.size;
}

function isBoundary(x, y) {
    const g = grid[y * gridW + x];
    if (x > 0 && grid[y * gridW + (x - 1)] !== g) return true;
    if (x < gridW - 1 && grid[y * gridW + (x + 1)] !== g) return true;
    if (y > 0 && grid[(y - 1) * gridW + x] !== g) return true;
    if (y < gridH - 1 && grid[(y + 1) * gridW + x] !== g) return true;
    return false;
}

function draw() {
    const imageData = ctx.createImageData(W, H);
    const data = imageData.data;

    for (let gy = 0; gy < gridH; gy++) {
        for (let gx = 0; gx < gridW; gx++) {
            const grainId = grid[gy * gridW + gx];
            let r, g, b;

            if (showBoundaries && isBoundary(gx, gy)) {
                r = 20; g = 20; b = 30;
            } else {
                const color = grainColors[grainId % grainColors.length];
                r = color[0]; g = color[1]; b = color[2];
            }

            for (let py = gy * CELL; py < Math.min((gy + 1) * CELL, H); py++) {
                for (let px = gx * CELL; px < Math.min((gx + 1) * CELL, W); px++) {
                    const idx = (py * W + px) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);

    document.getElementById('stepCount').textContent = stepCount;
    document.getElementById('grainCount').textContent = countGrains();
    document.getElementById('tempDisplay').textContent = temperature.toFixed(2);
}

function animate() {
    const iters = speed * 500;
    pottsStep(iters);
    draw();
    requestAnimationFrame(animate);
}

document.getElementById('temperature').addEventListener('input', (e) => {
    temperature = parseInt(e.target.value) / 10;
});
document.getElementById('numGrains').addEventListener('change', (e) => {
    numGrains = parseInt(e.target.value);
    init();
});
document.getElementById('speed').addEventListener('input', (e) => {
    speed = parseInt(e.target.value);
});
document.getElementById('showBounds').addEventListener('change', (e) => {
    showBoundaries = e.target.checked;
});
document.getElementById('resetBtn').addEventListener('click', init);
window.addEventListener('resize', () => { init(); });

init();
animate();
</script>
</body>
</html>
