<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rayleigh-Taylor Instability</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: bold; z-index: 999;
    text-shadow: 0 0 10px rgba(0,0,0,0.8); pointer-events: none;
}
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center; z-index: 999;
    background: rgba(0,0,0,0.7); padding: 12px 20px; border-radius: 10px;
    flex-wrap: wrap; justify-content: center;
}
.controls label { color: #ccc; font-size: 13px; }
.controls input[type=range] { width: 100px; cursor: pointer; }
.controls span { color: #fbbf24; font-size: 13px; min-width: 30px; }
.controls button {
    padding: 6px 14px; background: #fbbf24; color: #0a0e1a; border: none;
    border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold;
}
.controls button:hover { background: #f59e0b; }
.info {
    position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
    color: rgba(255,255,255,0.5); font-size: 12px; z-index: 999;
    pointer-events: none;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div class="title-overlay">Rayleigh-Taylor Instability</div>
<div class="info">Heavy fluid (orange) sinks into light fluid (blue) creating mushroom-shaped fingers</div>
<div class="controls">
    <label>Gravity</label>
    <input type="range" id="gravSlider" min="1" max="20" value="8" step="1">
    <span id="gravVal">8</span>
    <label>Perturbation</label>
    <input type="range" id="pertSlider" min="1" max="10" value="4" step="1">
    <span id="pertVal">4</span>
    <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const SCALE = 2;
let W, H, NX, NY;
let density, velocityX, velocityY, tempDensity;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    NX = Math.floor(W / SCALE);
    NY = Math.floor(H / SCALE);
    init();
}

function init() {
    const N = NX * NY;
    density = new Float32Array(N);
    velocityX = new Float32Array(N);
    velocityY = new Float32Array(N);
    tempDensity = new Float32Array(N);

    const pertAmp = parseInt(document.getElementById('pertSlider').value);
    const midY = NY / 2;

    for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
            const n = y * NX + x;
            // Interface with sinusoidal perturbation
            let interfaceY = midY;
            for (let k = 1; k <= 6; k++) {
                interfaceY += pertAmp * Math.sin(2 * Math.PI * k * x / NX + Math.random() * 0.5) / k;
            }
            interfaceY += (Math.random() - 0.5) * pertAmp * 0.5;

            density[n] = y < interfaceY ? 1.0 : 0.0; // Heavy on top
            velocityX[n] = 0;
            velocityY[n] = 0;
        }
    }
}

function idx(x, y) {
    x = Math.max(0, Math.min(NX - 1, x));
    y = Math.max(0, Math.min(NY - 1, y));
    return y * NX + x;
}

function step() {
    const gravity = parseInt(document.getElementById('gravSlider').value) * 0.0005;
    const dt = 1.0;
    const diffusion = 0.00005;

    // Advection + gravity
    for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
            const n = idx(x, y);
            const d = density[n];

            // Buoyancy force
            const buoyancy = (d - 0.5) * gravity;
            velocityY[n] += buoyancy;

            // Diffuse velocity (viscosity)
            if (x > 0 && x < NX - 1 && y > 0 && y < NY - 1) {
                const visc = 0.1;
                velocityX[n] += visc * (
                    velocityX[idx(x+1,y)] + velocityX[idx(x-1,y)] +
                    velocityX[idx(x,y+1)] + velocityX[idx(x,y-1)] - 4 * velocityX[n]
                );
                velocityY[n] += visc * (
                    velocityY[idx(x+1,y)] + velocityY[idx(x-1,y)] +
                    velocityY[idx(x,y+1)] + velocityY[idx(x,y-1)] - 4 * velocityY[n]
                );
            }

            // Damping
            velocityX[n] *= 0.999;
            velocityY[n] *= 0.999;
        }
    }

    // Semi-Lagrangian advection for density
    for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
            const n = idx(x, y);
            const srcX = x - velocityX[n] * dt;
            const srcY = y - velocityY[n] * dt;

            // Bilinear interpolation
            const x0 = Math.floor(srcX);
            const y0 = Math.floor(srcY);
            const fx = srcX - x0;
            const fy = srcY - y0;

            const d00 = density[idx(x0, y0)];
            const d10 = density[idx(x0 + 1, y0)];
            const d01 = density[idx(x0, y0 + 1)];
            const d11 = density[idx(x0 + 1, y0 + 1)];

            tempDensity[n] = (1 - fx) * (1 - fy) * d00 + fx * (1 - fy) * d10 +
                             (1 - fx) * fy * d01 + fx * fy * d11;

            // Small diffusion
            if (x > 0 && x < NX - 1 && y > 0 && y < NY - 1) {
                tempDensity[n] += diffusion * (
                    density[idx(x+1,y)] + density[idx(x-1,y)] +
                    density[idx(x,y+1)] + density[idx(x,y-1)] - 4 * density[n]
                );
            }
        }
    }

    // Swap
    const tmp = density;
    density = tempDensity;
    tempDensity = tmp;

    // Boundary
    for (let x = 0; x < NX; x++) {
        density[idx(x, 0)] = 1.0;
        density[idx(x, NY - 1)] = 0.0;
        velocityX[idx(x, 0)] = 0;
        velocityY[idx(x, 0)] = 0;
        velocityX[idx(x, NY-1)] = 0;
        velocityY[idx(x, NY-1)] = 0;
    }
    for (let y = 0; y < NY; y++) {
        velocityX[idx(0, y)] = 0;
        velocityX[idx(NX-1, y)] = 0;
    }
}

let imageData;
function render() {
    if (!imageData || imageData.width !== NX || imageData.height !== NY) {
        imageData = ctx.createImageData(NX, NY);
    }
    const data = imageData.data;
    for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
            const n = y * NX + x;
            const p = n * 4;
            const d = Math.max(0, Math.min(1, density[n]));
            const speed = Math.sqrt(velocityX[n] * velocityX[n] + velocityY[n] * velocityY[n]);
            const s = Math.min(1, speed * 30);

            // Heavy fluid: warm (orange/red), Light fluid: cool (blue/cyan)
            const r = d * 255 * (0.8 + 0.2 * s);
            const g = d * 140 * (0.6 + 0.4 * s) + (1 - d) * 60 * s;
            const b = (1 - d) * 220 + d * 30 + s * 60;

            data[p] = Math.min(255, r);
            data[p+1] = Math.min(255, g);
            data[p+2] = Math.min(255, b);
            data[p+3] = 255;
        }
    }
    // Draw to offscreen then scale
    const offscreen = document.createElement('canvas');
    offscreen.width = NX;
    offscreen.height = NY;
    offscreen.getContext('2d').putImageData(imageData, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, W, H);
}

document.getElementById('gravSlider').addEventListener('input', function() {
    document.getElementById('gravVal').textContent = this.value;
});
document.getElementById('pertSlider').addEventListener('input', function() {
    document.getElementById('pertVal').textContent = this.value;
});
document.getElementById('resetBtn').addEventListener('click', init);

function animate() {
    for (let i = 0; i < 4; i++) step();
    render();
    requestAnimationFrame(animate);
}

window.addEventListener('resize', resize);
resize();
animate();
</script>
</body>
</html>
