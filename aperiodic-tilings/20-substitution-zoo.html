<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Substitution Tiling Zoo - A Menagerie of Aperiodic Patterns</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff;
    max-height: calc(100vh - 60px); overflow-y: auto;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
input[type="range"] { width: 100%; accent-color: #8af; margin-top: 4px; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
.info {
    margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(100,140,255,0.2);
    font-size: 0.75em; color: #6a8; line-height: 1.5;
}
.section-label { color: #8af; font-size: 0.8em; margin: 10px 0 4px 0; font-weight: bold; }
select {
    background: rgba(20, 30, 60, 0.8); color: #c8d8ff; border: 1px solid rgba(100,140,255,0.3);
    padding: 6px 8px; border-radius: 4px; font-size: 0.85em; width: 100%; margin-bottom: 8px;
}
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 4px; }
label input { accent-color: #8af; }
#rulePanel {
    margin-top: 10px; padding: 10px; background: rgba(20, 30, 60, 0.5);
    border-radius: 8px; border: 1px solid rgba(100,140,255,0.15);
}
#rulePanel .rule-title { color: #ffd866; font-size: 0.85em; margin-bottom: 6px; }
#rulePanel .rule-desc { color: #8aa; font-size: 0.75em; line-height: 1.4; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>SUBSTITUTION TILING ZOO</h3>
    <div class="section-label">Tiling Type</div>
    <select id="tilingSelect">
        <option value="chair">Chair Tiling</option>
        <option value="sphinx">Sphinx Tiling</option>
        <option value="penrose">Penrose Rhombuses</option>
        <option value="pinwheel">Pinwheel Tiling</option>
        <option value="ammann">Ammann-Beenker</option>
        <option value="table">Table (T) Tiling</option>
    </select>
    <div class="section-label">Subdivision Level</div>
    <div class="ctrl-row"><span>Level:</span><span class="val" id="levelVal">3</span></div>
    <input type="range" id="levelSlider" min="1" max="6" value="3" step="1">
    <div class="ctrl-row"><span>Tiles:</span><span class="val" id="tileCount">0</span></div>
    <div class="btn-row">
        <button class="btn" id="subdivideBtn">Subdivide</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <label><input type="checkbox" id="colorByLevel" checked> Color by level</label>
    <label><input type="checkbox" id="showOutlines" checked> Show outlines</label>
    <label><input type="checkbox" id="animateSub"> Animate subdivision</label>
    <div id="rulePanel">
        <div class="rule-title" id="ruleName">Chair Tiling</div>
        <div class="rule-desc" id="ruleDesc">
            An L-shaped tromino subdivides into 4 smaller L-shaped trominoes.
            Scale factor: 2. Each chair tile is replaced by 4 rotated copies.
        </div>
    </div>
    <div class="info">
        A menagerie of substitution tilings. Each starts with a prototile that is
        recursively subdivided into smaller copies of itself. The result is always
        aperiodic - it never repeats by translation alone.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const PHI = (1 + Math.sqrt(5)) / 2;

let W, H;
let tiles = [];
let currentType = 'chair';
let level = 3;
let time = 0;
let animProgress = 1;
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, dragSX, dragSY, camSX, camSY;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const TILING_INFO = {
    chair: { name: 'Chair Tiling', desc: 'An L-shaped tromino subdivides into 4 smaller L-shaped trominoes. Scale factor: 2. Each chair tile is replaced by 4 rotated copies at half scale.' },
    sphinx: { name: 'Sphinx Tiling', desc: 'A sphinx hexiamond (6 equilateral triangles in an L-shape) subdivides into 4 smaller sphinxes. Scale factor: 2.' },
    penrose: { name: 'Penrose Rhombuses', desc: 'Thick (72-deg) and thin (36-deg) rhombuses. Robinson triangle decomposition with golden ratio scaling. Scale factor: phi.' },
    pinwheel: { name: 'Pinwheel Tiling', desc: 'A 1:2:sqrt(5) right triangle subdivides into 5 smaller copies. Uniquely, tiles appear in infinitely many orientations.' },
    ammann: { name: 'Ammann-Beenker', desc: 'Squares and 45-degree rhombuses with 8-fold symmetry. Related to octagonal quasicrystals. Scale factor: 1+sqrt(2).' },
    table: { name: 'Table (T) Tiling', desc: 'A T-shaped tile (4 unit squares in a T) subdivides into 4 smaller T-shaped tiles. Scale factor: 2.' }
};

// Color palettes per tiling type
const PALETTES = {
    chair: ['#4488cc', '#66aadd', '#3377bb', '#5599cc'],
    sphinx: ['#cc6644', '#dd8866', '#bb5533', '#cc7755'],
    penrose: ['#4488cc', '#cc7744'],
    pinwheel: ['#44aa88', '#66ccaa', '#339977', '#55bb99', '#77ddbb'],
    ammann: ['#8866cc', '#cc8844'],
    table: ['#cc4488', '#dd66aa', '#bb3377', '#cc5599']
};

const LEVEL_COLORS = [
    '#ff6666', '#ffaa44', '#ffdd44', '#66dd66', '#44aaff', '#aa66ff'
];

// Affine transform helpers
function transformPt(pt, mat) {
    // mat = [a, b, c, d, tx, ty]
    return [
        mat[0] * pt[0] + mat[1] * pt[1] + mat[4],
        mat[2] * pt[0] + mat[3] * pt[1] + mat[5]
    ];
}

function composeMat(m1, m2) {
    return [
        m1[0]*m2[0] + m1[1]*m2[2],
        m1[0]*m2[1] + m1[1]*m2[3],
        m1[2]*m2[0] + m1[3]*m2[2],
        m1[2]*m2[1] + m1[3]*m2[3],
        m1[0]*m2[4] + m1[1]*m2[5] + m1[4],
        m1[2]*m2[4] + m1[3]*m2[5] + m1[5]
    ];
}

function scaleMat(s) { return [s, 0, 0, s, 0, 0]; }
function transMat(tx, ty) { return [1, 0, 0, 1, tx, ty]; }
function rotMat(a) { let c = Math.cos(a), s = Math.sin(a); return [c, -s, s, c, 0, 0]; }
function flipYMat() { return [1, 0, 0, -1, 0, 0]; }

// CHAIR TILING
function chairProto() {
    // L-shaped: 3 unit squares forming an L
    return [[0,0],[2,0],[2,1],[1,1],[1,2],[0,2]];
}

function chairSubdivide(tile) {
    let poly = tile.poly;
    let mat = tile.mat || [1,0,0,1,0,0];
    let s = 0.5;
    let results = [];

    // 4 smaller L-shapes inside the larger one
    // Position them to fill the 2x scaled L-shape
    let transforms = [
        composeMat(transMat(0, 0), scaleMat(s)),                    // bottom-left, no rotation
        composeMat(transMat(1, 0), composeMat(rotMat(Math.PI/2), scaleMat(s))),  // bottom-right, rotated 90
        composeMat(transMat(0, 1), composeMat(rotMat(-Math.PI/2), scaleMat(s))), // top-left, rotated -90
        composeMat(transMat(1, 1), composeMat(rotMat(Math.PI), scaleMat(s)))     // top-right, rotated 180
    ];

    let proto = chairProto();
    for (let i = 0; i < transforms.length; i++) {
        let m = composeMat(mat, transforms[i]);
        let newPoly = proto.map(p => transformPt(p, m));
        results.push({ poly: newPoly, mat: m, type: 'chair', level: (tile.level || 0) + 1, subIdx: i });
    }
    return results;
}

// SPHINX TILING
function sphinxProto() {
    // Sphinx from equilateral triangles - simplified L-shape in triangular grid
    let h = Math.sqrt(3) / 2;
    return [[0,0],[3,0],[3,h],[1.5,h],[1,2*h],[0,2*h]];
}

function sphinxSubdivide(tile) {
    let mat = tile.mat || [1,0,0,1,0,0];
    let s = 0.5;
    let results = [];
    let proto = sphinxProto();

    let h = Math.sqrt(3) / 2;
    let transforms = [
        composeMat(transMat(0, 0), scaleMat(s)),
        composeMat(transMat(1.5, 0), composeMat(rotMat(0), scaleMat(s))),
        composeMat(transMat(0, h), composeMat(rotMat(0), scaleMat(s))),
        composeMat(transMat(1.5, h), composeMat(rotMat(Math.PI), composeMat(scaleMat(s), transMat(3, 2*h))))
    ];

    for (let i = 0; i < transforms.length; i++) {
        let m = composeMat(mat, transforms[i]);
        let newPoly = proto.map(p => transformPt(p, m));
        results.push({ poly: newPoly, mat: m, type: 'sphinx', level: (tile.level || 0) + 1, subIdx: i });
    }
    return results;
}

// PENROSE RHOMBUSES (Robinson triangles)
function penroseGenerate(level) {
    let tris = [];
    let r = 200;
    for (let i = 0; i < 10; i++) {
        let a1 = (2 * Math.PI * i) / 10 - Math.PI / 2;
        let a2 = (2 * Math.PI * (i + 1)) / 10 - Math.PI / 2;
        let A = [0, 0], B = [r * Math.cos(a1), r * Math.sin(a1)], C = [r * Math.cos(a2), r * Math.sin(a2)];
        tris.push(i % 2 === 0 ? [0, A, B, C] : [0, A, C, B]);
    }
    for (let i = 0; i < level; i++) {
        let next = [];
        for (let [type, A, B, C] of tris) {
            if (type === 0) {
                let P = [A[0]+(B[0]-A[0])/PHI, A[1]+(B[1]-A[1])/PHI];
                next.push([0, C, P, A], [1, C, B, P]);
            } else {
                let Q = [B[0]+(A[0]-B[0])/PHI, B[1]+(A[1]-B[1])/PHI];
                let R = [B[0]+(C[0]-B[0])/PHI, B[1]+(C[1]-B[1])/PHI];
                next.push([1, R, C, A], [0, Q, R, B], [1, R, Q, A]);
            }
        }
        tris = next;
    }
    return tris.map((t, i) => ({
        poly: [t[1], t[2], t[3]],
        type: t[0] === 0 ? 'thick' : 'thin',
        level: level,
        subIdx: t[0]
    }));
}

// PINWHEEL TILING
function pinwheelProto() {
    return [[0,0],[2,0],[0,1]];
}

function pinwheelSubdivide(tile) {
    let mat = tile.mat || [1,0,0,1,0,0];
    let results = [];
    let proto = pinwheelProto();
    let s5 = 1 / Math.sqrt(5);
    let a = Math.atan(0.5);

    // 5 sub-triangles of a 1:2:sqrt(5) right triangle
    let transforms = [
        composeMat(transMat(0, 0), composeMat(rotMat(a), scaleMat(s5))),
        composeMat(transMat(0, 1), composeMat(rotMat(-Math.PI/2 + a), scaleMat(s5))),
        composeMat(transMat(2, 0), composeMat(rotMat(Math.PI + a), scaleMat(s5))),
        composeMat(transMat(2, 0), composeMat(rotMat(Math.PI - a), composeMat(flipYMat(), scaleMat(s5)))),
        composeMat(transMat(1, 0.5), composeMat(rotMat(Math.PI/2 + a), scaleMat(s5)))
    ];

    for (let i = 0; i < transforms.length; i++) {
        let m = composeMat(mat, transforms[i]);
        let newPoly = proto.map(p => transformPt(p, m));
        results.push({ poly: newPoly, mat: m, type: 'pinwheel', level: (tile.level || 0) + 1, subIdx: i });
    }
    return results;
}

// AMMANN-BEENKER
function ammannGenerate(level) {
    // Start with octagonal arrangement, subdivide
    let tiles = [];
    let s = 150;
    // Central octagon with squares and rhombuses
    for (let i = 0; i < 8; i++) {
        let a1 = (i * Math.PI) / 4;
        let a2 = ((i + 1) * Math.PI) / 4;
        // Rhombus
        let c = [0, 0];
        let p1 = [s * Math.cos(a1), s * Math.sin(a1)];
        let p2 = [s * Math.cos(a2), s * Math.sin(a2)];
        let p3 = [p1[0] + p2[0], p1[1] + p2[1]];
        tiles.push({
            poly: [c, p1, p3, p2],
            type: i % 2 === 0 ? 'square' : 'rhombus',
            level: 0,
            subIdx: i % 2
        });
    }
    // Apply simple subdivision
    for (let l = 0; l < level; l++) {
        let next = [];
        let sc = 1 / (1 + Math.SQRT2);
        for (let t of tiles) {
            let cx = 0, cy = 0;
            for (let p of t.poly) { cx += p[0]; cy += p[1]; }
            cx /= t.poly.length; cy /= t.poly.length;
            // Split each tile into smaller pieces around center
            for (let i = 0; i < t.poly.length; i++) {
                let j = (i + 1) % t.poly.length;
                let mid = [(t.poly[i][0] + t.poly[j][0]) / 2, (t.poly[i][1] + t.poly[j][1]) / 2];
                next.push({
                    poly: [
                        [cx + (t.poly[i][0] - cx) * 1, cy + (t.poly[i][1] - cy) * 1],
                        [cx + (mid[0] - cx) * 1, cy + (mid[1] - cy) * 1],
                        [cx, cy]
                    ],
                    type: i % 2 === 0 ? 'square' : 'rhombus',
                    level: l + 1,
                    subIdx: i % 2
                });
                let k = (j + 1) % t.poly.length;
                let mid2 = [(t.poly[j][0] + t.poly[k][0]) / 2, (t.poly[j][1] + t.poly[k][1]) / 2];
                next.push({
                    poly: [
                        [cx + (mid[0] - cx) * 1, cy + (mid[1] - cy) * 1],
                        [cx + (t.poly[j][0] - cx) * 1, cy + (t.poly[j][1] - cy) * 1],
                        [cx, cy]
                    ],
                    type: j % 2 === 0 ? 'rhombus' : 'square',
                    level: l + 1,
                    subIdx: (i + 1) % 2
                });
            }
        }
        tiles = next;
    }
    return tiles;
}

// TABLE (T) TILING
function tableProto() {
    // T-shape: 4 unit squares
    return [[0,0],[3,0],[3,1],[2,1],[2,2],[1,2],[1,1],[0,1]];
}

function tableSubdivide(tile) {
    let mat = tile.mat || [1,0,0,1,0,0];
    let results = [];
    let proto = tableProto();
    let s = 0.5;

    let transforms = [
        composeMat(transMat(0, 0), scaleMat(s)),
        composeMat(transMat(1.5, 0), composeMat(rotMat(0), scaleMat(s))),
        composeMat(transMat(0.5, 1), composeMat(rotMat(Math.PI), composeMat(scaleMat(s), transMat(3, 2)))),
        composeMat(transMat(2, 1), composeMat(rotMat(-Math.PI/2), composeMat(scaleMat(s), transMat(0, 0))))
    ];

    for (let i = 0; i < transforms.length; i++) {
        let m = composeMat(mat, transforms[i]);
        let newPoly = proto.map(p => transformPt(p, m));
        results.push({ poly: newPoly, mat: m, type: 'table', level: (tile.level || 0) + 1, subIdx: i });
    }
    return results;
}

function generateTiling(type, lvl) {
    let scale;
    if (type === 'penrose') {
        return penroseGenerate(lvl);
    }
    if (type === 'ammann') {
        return ammannGenerate(lvl);
    }

    let proto, subdivideFn;
    switch (type) {
        case 'chair': proto = chairProto(); subdivideFn = chairSubdivide; scale = Math.pow(2, lvl) * 50; break;
        case 'sphinx': proto = sphinxProto(); subdivideFn = sphinxSubdivide; scale = Math.pow(2, lvl) * 40; break;
        case 'pinwheel': proto = pinwheelProto(); subdivideFn = pinwheelSubdivide; scale = Math.pow(Math.sqrt(5), lvl) * 60; break;
        case 'table': proto = tableProto(); subdivideFn = tableSubdivide; scale = Math.pow(2, lvl) * 40; break;
        default: return [];
    }

    let initMat = composeMat(transMat(-scale / 2, -scale / 2), scaleMat(scale / 3));
    let current = [{ poly: proto.map(p => transformPt(p, initMat)), mat: initMat, type: type, level: 0, subIdx: 0 }];

    for (let i = 0; i < lvl; i++) {
        let next = [];
        for (let tile of current) {
            next.push(...subdivideFn(tile));
        }
        current = next;
    }
    return current;
}

function generate() {
    currentType = document.getElementById('tilingSelect').value;
    level = parseInt(document.getElementById('levelSlider').value);
    tiles = generateTiling(currentType, level);

    // Center tiles
    if (tiles.length > 0) {
        let cx = 0, cy = 0, count = 0;
        for (let t of tiles) {
            for (let p of t.poly) { cx += p[0]; cy += p[1]; count++; }
        }
        cx /= count; cy /= count;
        for (let t of tiles) {
            t.poly = t.poly.map(p => [p[0] - cx, p[1] - cy]);
        }
    }

    document.getElementById('tileCount').textContent = tiles.length;
    document.getElementById('levelVal').textContent = level;

    let info = TILING_INFO[currentType];
    document.getElementById('ruleName').textContent = info.name;
    document.getElementById('ruleDesc').textContent = info.desc;

    camX = 0; camY = 0; camZoom = 1;
}

// Event handlers
document.getElementById('tilingSelect').addEventListener('change', generate);
document.getElementById('levelSlider').addEventListener('input', () => {
    level = parseInt(document.getElementById('levelSlider').value);
    document.getElementById('levelVal').textContent = level;
    generate();
});
document.getElementById('subdivideBtn').addEventListener('click', () => {
    let slider = document.getElementById('levelSlider');
    let val = Math.min(6, parseInt(slider.value) + 1);
    slider.value = val;
    generate();
});

window.reset = function() {
    document.getElementById('tilingSelect').value = 'chair';
    document.getElementById('levelSlider').value = 3;
    generate();
};
document.getElementById('resetBtn').addEventListener('click', window.reset);

// Pan and zoom
canvas.addEventListener('mousedown', e => {
    if (e.button === 0) { dragging = true; dragSX = e.clientX; dragSY = e.clientY; camSX = camX; camSY = camY; }
});
canvas.addEventListener('mousemove', e => {
    if (dragging) { camX = camSX + (e.clientX - dragSX) / camZoom; camY = camSY + (e.clientY - dragSY) / camZoom; }
});
canvas.addEventListener('mouseup', () => { dragging = false; });
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    let factor = e.deltaY > 0 ? 0.9 : 1.1;
    camZoom *= factor;
    camZoom = Math.max(0.05, Math.min(20, camZoom));
}, { passive: false });

function getColor(tile, idx) {
    let colorByLevel = document.getElementById('colorByLevel').checked;
    if (colorByLevel) {
        let lvl = tile.level || 0;
        let c = LEVEL_COLORS[lvl % LEVEL_COLORS.length];
        return c;
    }
    let palette = PALETTES[currentType] || PALETTES.chair;
    let subIdx = tile.subIdx || 0;
    return palette[subIdx % palette.length];
}

function hexToRgba(hex, alpha) {
    let r = parseInt(hex.slice(1, 3), 16);
    let g = parseInt(hex.slice(3, 5), 16);
    let b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${alpha})`;
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    ctx.save();
    ctx.translate(W / 2, H / 2);
    ctx.scale(camZoom, camZoom);
    ctx.translate(camX, camY);

    let showOutlines = document.getElementById('showOutlines').checked;

    for (let i = 0; i < tiles.length; i++) {
        let tile = tiles[i];
        let poly = tile.poly;

        ctx.beginPath();
        ctx.moveTo(poly[0][0], poly[0][1]);
        for (let j = 1; j < poly.length; j++) ctx.lineTo(poly[j][0], poly[j][1]);
        ctx.closePath();

        let color = getColor(tile, i);
        ctx.fillStyle = hexToRgba(color, 0.55);
        ctx.fill();

        if (showOutlines) {
            ctx.strokeStyle = hexToRgba(color, 0.8);
            ctx.lineWidth = 0.8 / camZoom;
            ctx.stroke();
        }
    }

    ctx.restore();

    // Draw prototile diagram in bottom-left
    drawProtoPanel();
}

function drawProtoPanel() {
    let panelW = 180, panelH = 140;
    let px = 20, py = H - panelH - 20;

    ctx.fillStyle = 'rgba(10, 14, 30, 0.85)';
    ctx.strokeStyle = 'rgba(100,140,255,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(px, py, panelW, panelH, 8);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#8af';
    ctx.font = '11px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Prototile', px + panelW / 2, py + 16);

    // Draw a small version of the prototile
    ctx.save();
    ctx.translate(px + panelW / 2, py + panelH / 2 + 10);

    let proto;
    let s = 20;
    switch (currentType) {
        case 'chair':
            proto = chairProto().map(p => [(p[0] - 1) * s, (p[1] - 1) * s]);
            break;
        case 'sphinx':
            proto = sphinxProto().map(p => [(p[0] - 1.5) * s * 0.8, (p[1] - 0.8) * s * 0.8]);
            break;
        case 'penrose':
            // Two rhombuses
            let a72 = 72 * Math.PI / 180;
            let a36 = 36 * Math.PI / 180;
            // Thick
            proto = [[0,0],[s*Math.cos(0), s*Math.sin(0)],[s*Math.cos(0)+s*Math.cos(a72), s*Math.sin(0)+s*Math.sin(a72)],[s*Math.cos(a72), s*Math.sin(a72)]];
            proto = proto.map(p => [p[0] - s * 0.7 - 20, p[1] - s * 0.3]);
            ctx.beginPath();
            ctx.moveTo(proto[0][0], proto[0][1]);
            for (let p of proto.slice(1)) ctx.lineTo(p[0], p[1]);
            ctx.closePath();
            ctx.fillStyle = 'rgba(68,136,204,0.6)';
            ctx.fill();
            ctx.strokeStyle = '#4488cc';
            ctx.lineWidth = 1;
            ctx.stroke();
            // Thin
            proto = [[0,0],[s*Math.cos(0), s*Math.sin(0)],[s*Math.cos(0)+s*Math.cos(a36), s*Math.sin(0)+s*Math.sin(a36)],[s*Math.cos(a36), s*Math.sin(a36)]];
            proto = proto.map(p => [p[0] + 10, p[1] - s * 0.2]);
            ctx.beginPath();
            ctx.moveTo(proto[0][0], proto[0][1]);
            for (let p of proto.slice(1)) ctx.lineTo(p[0], p[1]);
            ctx.closePath();
            ctx.fillStyle = 'rgba(204,119,68,0.6)';
            ctx.fill();
            ctx.strokeStyle = '#cc7744';
            ctx.stroke();
            ctx.fillStyle = '#8aa';
            ctx.font = '9px Segoe UI';
            ctx.fillText('thick', -30, s + 5);
            ctx.fillText('thin', 25, s + 5);
            ctx.restore();
            return;
        case 'pinwheel':
            proto = pinwheelProto().map(p => [(p[0] - 1) * s, (p[1] - 0.5) * s]);
            break;
        case 'ammann':
            // Square + rhombus
            let sq = [[-s/2,-s/2],[s/2,-s/2],[s/2,s/2],[-s/2,s/2]].map(p => [p[0] - 25, p[1]]);
            ctx.beginPath();
            ctx.moveTo(sq[0][0], sq[0][1]);
            for (let p of sq.slice(1)) ctx.lineTo(p[0], p[1]);
            ctx.closePath();
            ctx.fillStyle = 'rgba(136,102,204,0.6)';
            ctx.fill();
            ctx.strokeStyle = '#8866cc';
            ctx.lineWidth = 1;
            ctx.stroke();
            let a45 = Math.PI / 4;
            let rh = [[0,0],[s*Math.cos(0),s*Math.sin(0)],[s*Math.cos(0)+s*Math.cos(a45),s*Math.sin(0)+s*Math.sin(a45)],[s*Math.cos(a45),s*Math.sin(a45)]];
            rh = rh.map(p => [p[0] + 10, p[1] - s * 0.3]);
            ctx.beginPath();
            ctx.moveTo(rh[0][0], rh[0][1]);
            for (let p of rh.slice(1)) ctx.lineTo(p[0], p[1]);
            ctx.closePath();
            ctx.fillStyle = 'rgba(204,136,68,0.6)';
            ctx.fill();
            ctx.strokeStyle = '#cc8844';
            ctx.stroke();
            ctx.fillStyle = '#8aa';
            ctx.font = '9px Segoe UI';
            ctx.fillText('square', -25, s + 5);
            ctx.fillText('rhombus', 25, s + 5);
            ctx.restore();
            return;
        case 'table':
            proto = tableProto().map(p => [(p[0] - 1.5) * s * 0.7, (p[1] - 1) * s * 0.7]);
            break;
    }

    if (proto) {
        ctx.beginPath();
        ctx.moveTo(proto[0][0], proto[0][1]);
        for (let p of proto.slice(1)) ctx.lineTo(p[0], p[1]);
        ctx.closePath();
        let palette = PALETTES[currentType];
        ctx.fillStyle = hexToRgba(palette[0], 0.6);
        ctx.fill();
        ctx.strokeStyle = palette[0];
        ctx.lineWidth = 1.5;
        ctx.stroke();
    }

    ctx.restore();
}

function animate(t) {
    time = t / 1000;
    draw();
    requestAnimationFrame(animate);
}

generate();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>