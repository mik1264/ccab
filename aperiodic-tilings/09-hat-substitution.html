<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hat Substitution Rules</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(200, 140, 255, 0.2); border-radius: 12px;
    padding: 18px; color: #e0c8ff; min-width: 260px;
}
#controls h3 { color: #c8f; margin-bottom: 10px; font-size: 1em; }
#controls p { font-size: 0.78em; line-height: 1.5; margin-bottom: 8px; color: #a9b; }
.btn-row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
.btn {
    padding: 6px 14px; border: 1px solid rgba(200,140,255,0.3);
    background: rgba(200,140,255,0.1); color: #c8f; border-radius: 6px;
    cursor: pointer; font-size: 0.8em; transition: all 0.2s;
}
.btn:hover { background: rgba(200,140,255,0.25); }
.btn.active { background: rgba(200,140,255,0.35); border-color: #c8f; }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(200, 140, 255, 0.2); border-radius: 12px;
    padding: 16px; color: #a9b; font-size: 0.75em; max-width: 260px; line-height: 1.5;
}
#info strong { color: #c8f; }
#levelDisplay {
    font-size: 1.4em; color: #c8f; text-align: center; margin: 10px 0;
    font-weight: bold;
}
#tileStats { color: #c8f; font-size: 0.85em; margin-top: 8px; }
.legend { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
.legend-item { display: flex; align-items: center; gap: 4px; font-size: 0.72em; }
.legend-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.2); }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#c8f;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>

<div id="info">
    <strong>Hat Substitution Rules</strong><br>
    Hat tilings are generated by a hierarchical substitution system with <strong>4 metatile types</strong>:<br><br>
    <strong style="color:#6af">H</strong> - Reflected hat cluster<br>
    <strong style="color:#f86">T</strong> - Triangle cluster<br>
    <strong style="color:#6f8">P</strong> - Parallelogram cluster<br>
    <strong style="color:#fc6">F</strong> - Hat cluster (forward)<br><br>
    Each metatile subdivides into specific arrangements of smaller metatiles, creating an infinite hierarchy.
    <div id="tileStats"></div>
</div>

<div id="controls">
    <h3>Substitution Rules</h3>
    <div id="levelDisplay">Level 0</div>
    <p>Step through inflation levels to see hierarchical growth</p>
    <div class="btn-row">
        <button class="btn" onclick="changeLevel(-1)">&#9664; Level -</button>
        <button class="btn" onclick="changeLevel(1)">Level + &#9654;</button>
        <button class="btn" onclick="animateInflation()" id="btnAnimate">Animate</button>
    </div>
    <div class="btn-row">
        <button class="btn active" onclick="setView('meta')" id="btnMeta">Metatiles</button>
        <button class="btn" onclick="setView('hats')" id="btnHats">Hats</button>
        <button class="btn" onclick="setView('both')" id="btnBoth">Overlay</button>
    </div>
    <div class="legend">
        <div class="legend-item"><div class="legend-swatch" style="background:#4488ff"></div><span style="color:#6af">H</span></div>
        <div class="legend-item"><div class="legend-swatch" style="background:#ff6644"></div><span style="color:#f86">T</span></div>
        <div class="legend-item"><div class="legend-swatch" style="background:#44dd66"></div><span style="color:#6f8">P</span></div>
        <div class="legend-item"><div class="legend-swatch" style="background:#ffcc44"></div><span style="color:#fc6">F</span></div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const S3 = Math.sqrt(3);

// Metatile shapes (simplified polygons for each type)
const metaShapes = {
    H: [ // Hexagonal cluster shape
        {x: 0, y: -2}, {x: S3, y: -1}, {x: S3, y: 1},
        {x: 0, y: 2}, {x: -S3, y: 1}, {x: -S3, y: -1}
    ],
    T: [ // Triangle
        {x: 0, y: -1.5}, {x: 1.3, y: 0.75}, {x: -1.3, y: 0.75}
    ],
    P: [ // Parallelogram
        {x: -1, y: -0.8}, {x: 0.5, y: -0.8}, {x: 1, y: 0.8}, {x: -0.5, y: 0.8}
    ],
    F: [ // Hexagonal cluster (forward)
        {x: 0, y: -2}, {x: S3, y: -1}, {x: S3, y: 1},
        {x: 0, y: 2}, {x: -S3, y: 1}, {x: -S3, y: -1}
    ]
};

const metaColors = {
    H: {fill: 'rgba(68,136,255,0.35)', stroke: 'rgba(100,170,255,0.7)'},
    T: {fill: 'rgba(255,100,68,0.35)', stroke: 'rgba(255,130,100,0.7)'},
    P: {fill: 'rgba(68,220,100,0.35)', stroke: 'rgba(100,255,130,0.7)'},
    F: {fill: 'rgba(255,204,68,0.35)', stroke: 'rgba(255,220,100,0.7)'}
};

// Hat base
const hatBase = [
    {x: 0, y: 0}, {x: 1, y: 0}, {x: 1.5, y: S3/2},
    {x: 1, y: S3}, {x: 1.5, y: 3*S3/2}, {x: 1, y: 2*S3},
    {x: 0, y: 2*S3}, {x: -0.5, y: 3*S3/2}, {x: 0, y: S3},
    {x: -0.5, y: S3/2}, {x: -1, y: S3}, {x: -1.5, y: S3/2},
    {x: -1, y: 0}
];

// Substitution rules: each metatile type produces specific child arrangements
// [type, relative_x, relative_y, rotation]
const substitutionRules = {
    H: [
        {type: 'H', dx: 0, dy: 0, rot: 0},
        {type: 'T', dx: 2.5, dy: -1.5, rot: Math.PI/3},
        {type: 'P', dx: -2.5, dy: -1.5, rot: -Math.PI/3},
        {type: 'F', dx: 0, dy: 3, rot: Math.PI},
        {type: 'T', dx: 2.5, dy: 1.5, rot: 0},
        {type: 'P', dx: -2.5, dy: 1.5, rot: Math.PI/3},
        {type: 'T', dx: -2.5, dy: -1.5, rot: 2*Math.PI/3}
    ],
    T: [
        {type: 'H', dx: 0, dy: 0, rot: 0},
        {type: 'T', dx: 1.8, dy: -1.2, rot: Math.PI/3},
        {type: 'P', dx: -1.8, dy: -1.2, rot: -Math.PI/3}
    ],
    P: [
        {type: 'H', dx: 0, dy: 0, rot: 0},
        {type: 'T', dx: 1.5, dy: -1, rot: 0},
        {type: 'F', dx: -1.5, dy: 1, rot: Math.PI}
    ],
    F: [
        {type: 'F', dx: 0, dy: 0, rot: 0},
        {type: 'T', dx: 2.5, dy: -1.5, rot: -Math.PI/3},
        {type: 'P', dx: -2.5, dy: -1.5, rot: Math.PI/3},
        {type: 'H', dx: 0, dy: 3, rot: Math.PI},
        {type: 'T', dx: -2.5, dy: 1.5, rot: 0},
        {type: 'P', dx: 2.5, dy: 1.5, rot: -Math.PI/3}
    ]
};

// Generate metatile hierarchy
function generateLevel(level) {
    let metatiles = [{type: 'H', x: 0, y: 0, rot: 0, scale: 1}];

    const inflationFactor = 2.8;

    for (let l = 0; l < level; l++) {
        const nextTiles = [];
        const newScale = metatiles[0].scale * inflationFactor;

        for (const mt of metatiles) {
            const rules = substitutionRules[mt.type];
            if (!rules) continue;

            for (const rule of rules) {
                const cos = Math.cos(mt.rot), sin = Math.sin(mt.rot);
                const rdx = rule.dx * mt.scale;
                const rdy = rule.dy * mt.scale;

                nextTiles.push({
                    type: rule.type,
                    x: mt.x + rdx * cos - rdy * sin,
                    y: mt.y + rdx * sin + rdy * cos,
                    rot: mt.rot + rule.rot,
                    scale: mt.scale
                });
            }
        }

        metatiles = nextTiles;
    }

    return metatiles;
}

// Generate hat positions from metatiles
function hatsFromMetatiles(metatiles) {
    const hats = [];
    for (const mt of metatiles) {
        // Each metatile contains some hats at specific positions
        const numHats = mt.type === 'T' ? 1 : mt.type === 'P' ? 2 : 4;
        for (let h = 0; h < numHats; h++) {
            const angle = mt.rot + h * Math.PI / 3;
            const dist = h * 0.6 * mt.scale;
            hats.push({
                x: mt.x + Math.cos(angle) * dist,
                y: mt.y + Math.sin(angle) * dist,
                rot: angle,
                scale: mt.scale * 0.35,
                type: mt.type,
                mirrored: mt.type === 'H'
            });
        }
    }
    return hats;
}

let currentLevel = 0;
let maxLevel = 4;
let viewMode = 'meta'; // 'meta', 'hats', 'both'
let metatiles = generateLevel(0);
let hats = hatsFromMetatiles(metatiles);
let isAnimating = false;
let animStartTime = 0;
let transitionProgress = 1;
let prevMetatiles = [];
let targetLevel = 0;

let camX = 0, camY = 0, camZoom = 1;
let dragging = false, lastMx = 0, lastMy = 0;

// Camera controls
canvas.addEventListener('mousedown', e => { dragging = true; lastMx = e.clientX; lastMy = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX += (e.clientX - lastMx) / camZoom;
    camY += (e.clientY - lastMy) / camZoom;
    lastMx = e.clientX; lastMy = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camZoom *= e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.05, Math.min(10, camZoom));
}, {passive: false});

let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) { dragging = true; lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY; }
    else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
    }
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && dragging) {
        camX += (e.touches[0].clientX - lastMx) / camZoom;
        camY += (e.touches[0].clientY - lastMy) / camZoom;
        lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist > 0) camZoom *= dist / lastTouchDist;
        camZoom = Math.max(0.05, Math.min(10, camZoom));
        lastTouchDist = dist;
    }
}, {passive: false});
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

function changeLevel(delta) {
    const newLevel = Math.max(0, Math.min(maxLevel, currentLevel + delta));
    if (newLevel === currentLevel) return;

    prevMetatiles = metatiles;
    currentLevel = newLevel;
    metatiles = generateLevel(currentLevel);
    hats = hatsFromMetatiles(metatiles);
    transitionProgress = 0;
    animStartTime = performance.now();

    // Auto-adjust zoom
    const zoomForLevel = [1, 0.5, 0.2, 0.08, 0.03];
    camZoom = zoomForLevel[currentLevel] || 0.03;

    updateDisplay();
}

function animateInflation() {
    if (isAnimating) {
        isAnimating = false;
        document.getElementById('btnAnimate').classList.remove('active');
        return;
    }
    isAnimating = true;
    document.getElementById('btnAnimate').classList.add('active');
    currentLevel = 0;
    metatiles = generateLevel(0);
    hats = hatsFromMetatiles(metatiles);
    camZoom = 1;
    targetLevel = 0;
    updateDisplay();
}

function setView(v) {
    viewMode = v;
    document.querySelectorAll('.btn').forEach(b => {
        if (['btnMeta','btnHats','btnBoth'].includes(b.id)) b.classList.remove('active');
    });
    document.getElementById('btn' + v.charAt(0).toUpperCase() + v.slice(1)).classList.add('active');
}

function updateDisplay() {
    document.getElementById('levelDisplay').textContent = `Level ${currentLevel}`;

    const counts = {H: 0, T: 0, P: 0, F: 0};
    for (const mt of metatiles) counts[mt.type]++;
    document.getElementById('tileStats').innerHTML =
        `Metatiles: ${metatiles.length}<br>` +
        `<span style="color:#6af">H:${counts.H}</span> ` +
        `<span style="color:#f86">T:${counts.T}</span> ` +
        `<span style="color:#6f8">P:${counts.P}</span> ` +
        `<span style="color:#fc6">F:${counts.F}</span><br>` +
        `Hats: ~${hats.length}`;
}

updateDisplay();

function drawMetatile(mt, alpha) {
    const shape = metaShapes[mt.type];
    const colors = metaColors[mt.type];

    ctx.save();
    ctx.translate(mt.x, mt.y);
    ctx.rotate(mt.rot);
    ctx.scale(mt.scale, mt.scale);
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.moveTo(shape[0].x, shape[0].y);
    for (let i = 1; i < shape.length; i++) ctx.lineTo(shape[i].x, shape[i].y);
    ctx.closePath();

    ctx.fillStyle = colors.fill;
    ctx.fill();
    ctx.strokeStyle = colors.stroke;
    ctx.lineWidth = 0.1;
    ctx.stroke();

    // Label
    if (mt.scale * camZoom > 0.15) {
        ctx.fillStyle = colors.stroke;
        ctx.font = `${1.2}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(mt.type, 0, 0);
    }

    ctx.restore();
}

function drawHat(hat, alpha) {
    ctx.save();
    ctx.translate(hat.x, hat.y);
    ctx.rotate(hat.rot);
    ctx.scale(hat.scale, hat.scale);
    if (hat.mirrored) ctx.scale(-1, 1);
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.moveTo(hatBase[0].x, hatBase[0].y);
    for (let i = 1; i < hatBase.length; i++) ctx.lineTo(hatBase[i].x, hatBase[i].y);
    ctx.closePath();

    const colors = metaColors[hat.type];
    ctx.fillStyle = hat.mirrored ? 'rgba(255,130,180,0.35)' : colors.fill;
    ctx.fill();
    ctx.strokeStyle = hat.mirrored ? 'rgba(255,160,200,0.6)' : colors.stroke.replace('0.7', '0.5');
    ctx.lineWidth = 0.08 / hat.scale;
    ctx.stroke();

    ctx.restore();
}

function draw(time) {
    ctx.clearRect(0, 0, W, H);

    const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
    bgGrad.addColorStop(0, '#100a18');
    bgGrad.addColorStop(1, '#060410');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // Update transition
    if (transitionProgress < 1) {
        transitionProgress = Math.min(1, (time - animStartTime) / 1500);
    }

    // Auto-animate through levels
    if (isAnimating && transitionProgress >= 1) {
        const elapsed = time - animStartTime;
        if (elapsed > 2500) {
            if (currentLevel < maxLevel) {
                changeLevel(1);
            } else {
                isAnimating = false;
                document.getElementById('btnAnimate').classList.remove('active');
            }
        }
    }

    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(camZoom * 50, camZoom * 50);
    ctx.translate(camX / 50, camY / 50);

    const alpha = transitionProgress;

    // Draw based on view mode
    if (viewMode === 'meta' || viewMode === 'both') {
        for (const mt of metatiles) {
            drawMetatile(mt, alpha);
        }
    }

    if (viewMode === 'hats' || viewMode === 'both') {
        const hatAlpha = viewMode === 'both' ? 0.6 : alpha;
        for (const hat of hats) {
            drawHat(hat, hatAlpha);
        }
    }

    ctx.restore();

    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

window.reset = function() {
    currentLevel = 0;
    camX = 0; camY = 0; camZoom = 1;
    isAnimating = false;
    viewMode = 'meta';
    metatiles = generateLevel(0);
    hats = hatsFromMetatiles(metatiles);
    transitionProgress = 1;
    document.getElementById('btnAnimate').classList.remove('active');
    setView('meta');
    updateDisplay();
};
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
