<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fibonacci Chain</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff;
    max-height: calc(100vh - 40px); overflow-y: auto;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 6px; }
label input[type="checkbox"] { accent-color: #8af; }
label input[type="radio"] { accent-color: #8af; }
input[type="range"] { width: 100%; accent-color: #8af; margin: 4px 0; }
.section { border-top: 1px solid rgba(100,140,255,0.15); padding-top: 10px; margin-top: 10px; }
.section h4 { color: #8af; font-size: 0.85em; margin-bottom: 8px; }
.info-text { font-size: 0.72em; color: #6a8a9a; margin-top: 8px; line-height: 1.5; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>FIBONACCI CHAIN</h3>
    <div class="ctrl-row"><span>Generation:</span><span class="val" id="genVal">1</span></div>
    <input type="range" id="genSlider" min="1" max="15" value="1">
    <div class="ctrl-row"><span>Sequence Length:</span><span class="val" id="lenVal">1</span></div>
    <div class="ctrl-row"><span>A (Long) Count:</span><span class="val" id="aCount">1</span></div>
    <div class="ctrl-row"><span>B (Short) Count:</span><span class="val" id="bCount">0</span></div>
    <div class="ctrl-row"><span>A:B Ratio:</span><span class="val" id="ratioVal">-</span></div>
    <div class="ctrl-row"><span>Golden Ratio:</span><span class="val">1.6180339...</span></div>

    <div class="section">
        <h4>View Mode</h4>
        <label><input type="radio" name="viewMode" value="chain" checked> 1D Chain (stacked)</label>
        <label><input type="radio" name="viewMode" value="cutproject"> Cut & Project</label>
        <label><input type="radio" name="viewMode" value="diffraction"> Diffraction Pattern</label>
    </div>

    <div class="btn-row">
        <button class="btn" id="animateBtn">Animate Growth</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>

    <label><input type="checkbox" id="showSelfSim"> Highlight self-similarity</label>

    <div class="info-text">
        The Fibonacci word is the 1D quasicrystal: A, AB, ABA, ABAAB... The ratio of A:B approaches the golden ratio. It can be obtained by "cutting" a 2D lattice along an irrational slope.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

const PHI = (1 + Math.sqrt(5)) / 2;

// Generate Fibonacci words
const fibWords = ['B', 'A'];
for (let i = 2; i <= 16; i++) {
    fibWords.push(fibWords[i-1] + fibWords[i-2]);
}

let generation = 1;
let viewMode = 'chain';
let animatingGrowth = false;
let animGen = 1;
let animT = 0;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);

function getWord(gen) {
    return fibWords[Math.min(gen, fibWords.length - 1)];
}

function updateStats() {
    const word = getWord(generation);
    const aCount = (word.match(/A/g) || []).length;
    const bCount = (word.match(/B/g) || []).length;
    document.getElementById('genVal').textContent = generation;
    document.getElementById('lenVal').textContent = word.length;
    document.getElementById('aCount').textContent = aCount;
    document.getElementById('bCount').textContent = bCount;
    document.getElementById('ratioVal').textContent = bCount > 0 ? (aCount / bCount).toFixed(6) : '-';
}

function drawChainView() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const maxGen = generation;
    const displayGens = Math.min(maxGen, 12);
    const startGen = Math.max(1, maxGen - displayGens + 1);

    const rowHeight = Math.min(40, (H - 100) / displayGens);
    const startY = 60;

    const showSelfSim = document.getElementById('showSelfSim').checked;

    for (let g = startGen; g <= maxGen; g++) {
        const word = getWord(g);
        const y = startY + (g - startGen) * rowHeight;
        const maxChars = Math.min(word.length, Math.floor((W - 200) / 8));
        const segW = Math.min(12, (W - 200) / maxChars);

        // Label
        ctx.fillStyle = '#6a8a9a';
        ctx.font = '11px monospace';
        ctx.fillText(`Gen ${g}`, 10, y + rowHeight / 2 + 4);

        let x = 80;
        for (let i = 0; i < maxChars; i++) {
            const ch = word[i];
            const w = ch === 'A' ? segW * 1.0 : segW * 0.618;

            if (showSelfSim && i < word.length) {
                // Color by position in subsequence
                const hue = ch === 'A' ? 200 : 35;
                const lightness = 40 + (i % 5) * 5;
                ctx.fillStyle = `hsla(${hue}, 70%, ${lightness}%, 0.9)`;
            } else {
                ctx.fillStyle = ch === 'A' ? 'rgba(80, 160, 255, 0.85)' : 'rgba(255, 180, 60, 0.85)';
            }

            const h = rowHeight * 0.6;
            ctx.fillRect(x, y + (rowHeight - h) / 2, w - 1, h);

            if (segW > 6) {
                ctx.fillStyle = '#fff';
                ctx.font = `${Math.min(10, segW)}px monospace`;
                ctx.textAlign = 'center';
                ctx.fillText(ch, x + w / 2, y + rowHeight / 2 + 3);
                ctx.textAlign = 'left';
            }

            x += w;
        }

        if (maxChars < word.length) {
            ctx.fillStyle = '#6a8a9a';
            ctx.font = '11px monospace';
            ctx.fillText(`... (${word.length} total)`, x + 5, y + rowHeight / 2 + 4);
        }
    }

    // Title
    ctx.fillStyle = '#8af';
    ctx.font = '14px sans-serif';
    ctx.fillText('Fibonacci Word Generations', 80, 30);

    // Legend
    const ly = H - 40;
    ctx.fillStyle = 'rgba(80, 160, 255, 0.85)';
    ctx.fillRect(80, ly, 20, 12);
    ctx.fillStyle = '#c8d8ff';
    ctx.font = '11px sans-serif';
    ctx.fillText('A (Long)', 105, ly + 10);
    ctx.fillStyle = 'rgba(255, 180, 60, 0.85)';
    ctx.fillRect(180, ly, 12, 12);
    ctx.fillStyle = '#c8d8ff';
    ctx.fillText('B (Short)', 197, ly + 10);
}

function drawCutProjectView() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const cx = W * 0.4, cy = H * 0.5;
    const scale = Math.min(W, H) * 0.03;
    const angle = Math.atan(1 / PHI); // slope of the strip

    // Draw 2D lattice
    const range = 20;
    ctx.strokeStyle = 'rgba(100, 140, 255, 0.1)';
    ctx.lineWidth = 0.5;

    for (let i = -range; i <= range; i++) {
        // Vertical lines
        ctx.beginPath();
        ctx.moveTo(cx + i * scale, cy - range * scale);
        ctx.lineTo(cx + i * scale, cy + range * scale);
        ctx.stroke();
        // Horizontal lines
        ctx.beginPath();
        ctx.moveTo(cx - range * scale, cy + i * scale);
        ctx.lineTo(cx + range * scale, cy + i * scale);
        ctx.stroke();
    }

    // Draw the projection strip
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    const stripWidth = 1 + 1 / PHI; // width of acceptance window
    const halfW = stripWidth / 2;

    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#8af';

    // Draw strip as a parallelogram
    const len = range * 2;
    ctx.beginPath();
    ctx.moveTo(cx + (-len * cosA - halfW * sinA) * scale, cy + (-len * sinA + halfW * cosA) * scale);
    ctx.lineTo(cx + (len * cosA - halfW * sinA) * scale, cy + (len * sinA + halfW * cosA) * scale);
    ctx.lineTo(cx + (len * cosA + halfW * sinA) * scale, cy + (len * sinA - halfW * cosA) * scale);
    ctx.lineTo(cx + (-len * cosA + halfW * sinA) * scale, cy + (-len * sinA - halfW * cosA) * scale);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Draw strip edges
    ctx.strokeStyle = 'rgba(138, 170, 255, 0.5)';
    ctx.lineWidth = 1;
    for (const sign of [-1, 1]) {
        ctx.beginPath();
        ctx.moveTo(cx + (-len * cosA + sign * halfW * sinA) * scale, cy + (-len * sinA - sign * halfW * cosA) * scale);
        ctx.lineTo(cx + (len * cosA + sign * halfW * sinA) * scale, cy + (len * sinA - sign * halfW * cosA) * scale);
        ctx.stroke();
    }

    // Find lattice points inside the strip and project them
    const projectedPoints = [];
    for (let i = -range; i <= range; i++) {
        for (let j = -range; j <= range; j++) {
            // Point (i, j) in lattice
            // Distance from the strip center line (along perpendicular)
            const perpDist = -i * sinA + j * cosA;
            if (Math.abs(perpDist) <= halfW) {
                // This point is inside the strip
                const px = cx + i * scale;
                const py = cy + j * scale;
                ctx.fillStyle = '#ffd866';
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();

                // Project onto the strip line
                const projDist = i * cosA + j * sinA;
                projectedPoints.push({ dist: projDist, x: i, y: j });
            } else {
                // Draw dim lattice point
                ctx.fillStyle = 'rgba(100, 140, 255, 0.15)';
                ctx.beginPath();
                ctx.arc(cx + i * scale, cy + j * scale, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // Sort by projection distance
    projectedPoints.sort((a, b) => a.dist - b.dist);

    // Draw the 1D chain at the bottom
    const chainY = H - 80;
    const chainScale = Math.min(W * 0.7, projectedPoints.length * 15) / (projectedPoints.length || 1);
    const chainStart = W * 0.15;

    ctx.strokeStyle = 'rgba(255, 216, 102, 0.3)';
    ctx.lineWidth = 1;

    // Draw projection lines
    for (let i = 0; i < projectedPoints.length; i++) {
        const p = projectedPoints[i];
        const px = cx + p.x * scale;
        const py = cy + p.y * scale;
        const cx2 = chainStart + i * chainScale;

        ctx.strokeStyle = 'rgba(255, 216, 102, 0.15)';
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(cx2, chainY);
        ctx.stroke();
    }

    // Draw 1D chain segments
    for (let i = 0; i < projectedPoints.length - 1; i++) {
        const gap = projectedPoints[i + 1].dist - projectedPoints[i].dist;
        const isLong = gap > 0.9; // Long = A, Short = B
        const x1 = chainStart + i * chainScale;
        const x2 = chainStart + (i + 1) * chainScale;

        ctx.strokeStyle = isLong ? 'rgba(80, 160, 255, 0.9)' : 'rgba(255, 180, 60, 0.9)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(x1, chainY);
        ctx.lineTo(x2, chainY);
        ctx.stroke();

        ctx.fillStyle = '#ffd866';
        ctx.beginPath();
        ctx.arc(x1, chainY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    if (projectedPoints.length > 0) {
        ctx.fillStyle = '#ffd866';
        ctx.beginPath();
        ctx.arc(chainStart + (projectedPoints.length - 1) * chainScale, chainY, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Labels
    ctx.fillStyle = '#8af';
    ctx.font = '14px sans-serif';
    ctx.fillText('Cut & Project Method', 20, 30);
    ctx.fillStyle = '#6a8a9a';
    ctx.font = '11px sans-serif';
    ctx.fillText('2D square lattice with irrational-slope strip', 20, 50);
    ctx.fillText('1D Fibonacci chain (projected)', chainStart, chainY - 15);
}

function drawDiffractionView() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const word = getWord(generation);
    // Build positions: A = length PHI, B = length 1
    const positions = [0];
    let x = 0;
    for (let i = 0; i < word.length; i++) {
        x += word[i] === 'A' ? PHI : 1;
        positions.push(x);
    }

    // Compute diffraction: I(k) = |sum exp(i*k*x_n)|^2
    const numK = Math.min(W - 100, 800);
    const kMax = 20;
    const intensity = new Float64Array(numK);
    let maxI = 0;

    for (let ki = 0; ki < numK; ki++) {
        const k = (ki / numK) * kMax * 2 - kMax;
        let re = 0, im = 0;
        for (let n = 0; n < positions.length; n++) {
            const phase = k * positions[n];
            re += Math.cos(phase);
            im += Math.sin(phase);
        }
        intensity[ki] = (re * re + im * im) / positions.length;
        if (intensity[ki] > maxI) maxI = intensity[ki];
    }

    // Draw diffraction pattern
    const plotX = 50, plotY = 80;
    const plotW = W - 150, plotH = H - 200;

    // Axes
    ctx.strokeStyle = 'rgba(100, 140, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(plotX, plotY + plotH);
    ctx.lineTo(plotX + plotW, plotY + plotH);
    ctx.moveTo(plotX, plotY);
    ctx.lineTo(plotX, plotY + plotH);
    ctx.stroke();

    // Bars / line
    for (let ki = 0; ki < numK; ki++) {
        const px = plotX + (ki / numK) * plotW;
        const h = (intensity[ki] / maxI) * plotH * 0.9;
        const hue = 200 + (intensity[ki] / maxI) * 60;
        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
        ctx.fillRect(px, plotY + plotH - h, Math.max(plotW / numK, 1), h);
    }

    // Also draw as 2D intensity bar at top
    const barY = 30;
    const barH = 30;
    for (let ki = 0; ki < numK; ki++) {
        const px = plotX + (ki / numK) * plotW;
        const val = intensity[ki] / maxI;
        const brightness = Math.pow(val, 0.5) * 255;
        ctx.fillStyle = `rgb(${brightness * 0.6}, ${brightness * 0.8}, ${brightness})`;
        ctx.fillRect(px, barY, Math.max(plotW / numK, 1), barH);
    }

    // Labels
    ctx.fillStyle = '#8af';
    ctx.font = '14px sans-serif';
    ctx.fillText('Fibonacci Chain Diffraction Pattern', plotX, 22);
    ctx.fillStyle = '#6a8a9a';
    ctx.font = '11px sans-serif';
    ctx.fillText('Wavevector k', plotX + plotW / 2 - 30, plotY + plotH + 25);
    ctx.save();
    ctx.translate(plotX - 15, plotY + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Intensity', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#c8d8ff';
    ctx.font = '11px sans-serif';
    ctx.fillText('Sharp Bragg peaks reveal quasicrystalline order', plotX, plotY + plotH + 45);
    ctx.fillText(`Gen ${generation}: ${positions.length} atoms`, plotX, plotY + plotH + 62);

    // Draw the chain at bottom
    const chainY = plotY + plotH + 90;
    const chainLen = Math.min(word.length, 200);
    const segW = Math.min(8, plotW / chainLen);
    let cx = plotX;
    for (let i = 0; i < chainLen; i++) {
        ctx.fillStyle = word[i] === 'A' ? 'rgba(80, 160, 255, 0.85)' : 'rgba(255, 180, 60, 0.85)';
        const w = word[i] === 'A' ? segW : segW * 0.618;
        ctx.fillRect(cx, chainY, w - 0.5, 10);
        cx += w;
    }
}

function draw() {
    switch (viewMode) {
        case 'chain': drawChainView(); break;
        case 'cutproject': drawCutProjectView(); break;
        case 'diffraction': drawDiffractionView(); break;
    }
}

let lastTime = 0;
function animate(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;

    if (animatingGrowth) {
        animT += dt;
        if (animT > 1.0) {
            animT = 0;
            animGen++;
            if (animGen > 12) {
                animatingGrowth = false;
                animGen = 12;
            }
            generation = animGen;
            document.getElementById('genSlider').value = generation;
            updateStats();
        }
    }

    draw();
    requestAnimationFrame(animate);
}

document.getElementById('genSlider').addEventListener('input', e => {
    generation = parseInt(e.target.value);
    animatingGrowth = false;
    updateStats();
});

document.querySelectorAll('input[name="viewMode"]').forEach(r => {
    r.addEventListener('change', e => {
        viewMode = e.target.value;
    });
});

document.getElementById('animateBtn').addEventListener('click', () => {
    generation = 1;
    animGen = 1;
    animT = 0;
    animatingGrowth = true;
    document.getElementById('genSlider').value = 1;
    updateStats();
});

document.getElementById('resetBtn').addEventListener('click', () => {
    generation = 1;
    animatingGrowth = false;
    document.getElementById('genSlider').value = 1;
    updateStats();
});

window.reset = function() {
    generation = 1;
    animatingGrowth = false;
    document.getElementById('genSlider').value = 1;
    viewMode = 'chain';
    document.querySelector('input[name="viewMode"][value="chain"]').checked = true;
    updateStats();
};

resize();
updateStats();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>