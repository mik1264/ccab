<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Penrose P2: Kites & Darts</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 220px; color: #c8d8ff;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; }
label input { accent-color: #8af; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>KITES &amp; DARTS (P2)</h3>
    <div class="ctrl-row"><span>Level:</span><span class="val" id="levelVal">5</span></div>
    <div class="btn-row">
        <button class="btn" id="deflateBtn">- Deflate</button>
        <button class="btn" id="inflateBtn">+ Inflate</button>
    </div>
    <div class="ctrl-row"><span>Kites:</span><span class="val" id="kiteCount">0</span></div>
    <div class="ctrl-row"><span>Darts:</span><span class="val" id="dartCount">0</span></div>
    <div class="ctrl-row"><span>Ratio K/D:</span><span class="val" id="ratioVal">0</span></div>
    <div class="ctrl-row"><span>Golden ratio:</span><span class="val">1.6180...</span></div>
    <label><input type="checkbox" id="showArcs" checked> Matching arcs</label>
    <label><input type="checkbox" id="showAxes"> Symmetry axes</label>
    <label><input type="checkbox" id="showGlow" checked> Glow effects</label>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;

let level = 5;
let triangles = [];
let tiles = [];
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, dragStartX, dragStartY, camStartX, camStartY;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function lerp(p1, p2, t) {
    return [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];
}

function makeInitialTriangles() {
    let tris = [];
    for (let i = 0; i < 10; i++) {
        let angle1 = (2 * Math.PI * i) / 10 - Math.PI / 2;
        let angle2 = (2 * Math.PI * (i + 1)) / 10 - Math.PI / 2;
        let r = 300;
        let a = [0, 0];
        let b = [r * Math.cos(angle1), r * Math.sin(angle1)];
        let c = [r * Math.cos(angle2), r * Math.sin(angle2)];
        if (i % 2 === 0) {
            tris.push({ type: 'B', vertices: [a, b, c] });
        } else {
            tris.push({ type: 'B', vertices: [a, c, b] });
        }
    }
    return tris;
}

function subdivide(triangles) {
    let result = [];
    for (let t of triangles) {
        let [a, b, c] = t.vertices;
        if (t.type === 'B') {
            let p = lerp(a, c, INV_PHI);
            let q = lerp(b, a, INV_PHI);
            result.push({ type: 'B', vertices: [q, p, b] });
            result.push({ type: 'B', vertices: [p, q, a] });
            result.push({ type: 'A', vertices: [c, p, b] });
        } else {
            let p = lerp(b, a, INV_PHI);
            result.push({ type: 'A', vertices: [p, c, a] });
            result.push({ type: 'B', vertices: [c, p, b] });
        }
    }
    return result;
}

function generateTiling(lev) {
    let tris = makeInitialTriangles();
    for (let i = 0; i < lev; i++) {
        tris = subdivide(tris);
    }
    triangles = tris;
    pairTrianglesIntoTiles();
}

function edgeKey(p1, p2) {
    let ax = Math.round(p1[0] * 100) / 100;
    let ay = Math.round(p1[1] * 100) / 100;
    let bx = Math.round(p2[0] * 100) / 100;
    let by = Math.round(p2[1] * 100) / 100;
    if (ax < bx || (ax === bx && ay < by)) return `${ax},${ay}-${bx},${by}`;
    return `${bx},${by}-${ax},${ay}`;
}

function pairTrianglesIntoTiles() {
    tiles = [];
    let edgeMap = new Map();
    for (let i = 0; i < triangles.length; i++) {
        let t = triangles[i];
        let [a, b, c] = t.vertices;
        let key = edgeKey(b, c);
        if (edgeMap.has(key)) {
            let j = edgeMap.get(key);
            let t2 = triangles[j];
            if (t.type === t2.type) {
                if (t.type === 'B') {
                    tiles.push({ kind: 'kite', triangles: [t, t2] });
                } else {
                    tiles.push({ kind: 'dart', triangles: [t, t2] });
                }
                edgeMap.delete(key);
            } else {
                edgeMap.set(key, i);
            }
        } else {
            edgeMap.set(key, i);
        }
    }
    let remaining = new Set(edgeMap.values());
    for (let idx of remaining) {
        let t = triangles[idx];
        tiles.push({ kind: t.type === 'B' ? 'kite' : 'dart', triangles: [t], single: true });
    }
    updateStats();
}

function updateStats() {
    let kites = 0, darts = 0;
    for (let tile of tiles) {
        if (tile.kind === 'kite') kites++;
        else darts++;
    }
    document.getElementById('kiteCount').textContent = kites;
    document.getElementById('dartCount').textContent = darts;
    document.getElementById('ratioVal').textContent = darts > 0 ? (kites / darts).toFixed(4) : '-';
    document.getElementById('levelVal').textContent = level;
}

function worldToScreen(x, y) {
    let sx = (x - camX) * camZoom + canvas.width / 2;
    let sy = (y - camY) * camZoom + canvas.height / 2;
    return [sx, sy];
}

function drawTile(tile) {
    let showGlow = document.getElementById('showGlow').checked;
    let showArcsFlag = document.getElementById('showArcs').checked;

    for (let tri of tile.triangles) {
        let [a, b, c] = tri.vertices;
        let [sx0, sy0] = worldToScreen(a[0], a[1]);
        let [sx1, sy1] = worldToScreen(b[0], b[1]);
        let [sx2, sy2] = worldToScreen(c[0], c[1]);

        ctx.beginPath();
        ctx.moveTo(sx0, sy0);
        ctx.lineTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
        ctx.closePath();

        if (tile.kind === 'kite') {
            ctx.fillStyle = 'rgba(20, 50, 120, 0.85)';
        } else {
            ctx.fillStyle = 'rgba(160, 120, 20, 0.85)';
        }
        ctx.fill();
        ctx.strokeStyle = 'rgba(100, 160, 255, 0.3)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
    }

    if (showGlow) {
        for (let tri of tile.triangles) {
            let [a, b, c] = tri.vertices;
            let [sx0, sy0] = worldToScreen(a[0], a[1]);
            let [sx1, sy1] = worldToScreen(b[0], b[1]);
            let [sx2, sy2] = worldToScreen(c[0], c[1]);
            ctx.beginPath();
            ctx.moveTo(sx0, sy0);
            ctx.lineTo(sx1, sy1);
            ctx.lineTo(sx2, sy2);
            ctx.closePath();
            ctx.strokeStyle = tile.kind === 'kite' ? 'rgba(80, 140, 255, 0.15)' : 'rgba(255, 200, 80, 0.15)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    if (showArcsFlag && tile.triangles.length === 2) {
        drawMatchingArcs(tile);
    }
}

function drawMatchingArcs(tile) {
    let t1 = tile.triangles[0];
    let t2 = tile.triangles[1];
    let [a1] = t1.vertices;
    let [a2] = t2.vertices;

    let [sx1, sy1] = worldToScreen(a1[0], a1[1]);
    let [sx2, sy2] = worldToScreen(a2[0], a2[1]);

    let r = 6 * camZoom;
    if (r < 1.5) return;

    if (tile.kind === 'kite') {
        ctx.beginPath();
        ctx.arc(sx1, sy1, r, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(sx2, sy2, r * 0.6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(100, 255, 100, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(sx1, sy1, r, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(100, 255, 100, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(sx2, sy2, r * 0.6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
    }
}

function drawSymmetryAxes() {
    if (!document.getElementById('showAxes').checked) return;
    ctx.save();
    ctx.setLineDash([8, 8]);
    for (let i = 0; i < 5; i++) {
        let angle = (Math.PI * i) / 5 - Math.PI / 2;
        let dx = Math.cos(angle) * 2000;
        let dy = Math.sin(angle) * 2000;
        let [sx1, sy1] = worldToScreen(-dx, -dy);
        let [sx2, sy2] = worldToScreen(dx, dy);
        ctx.beginPath();
        ctx.moveTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
        ctx.strokeStyle = 'rgba(255, 255, 100, 0.25)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    ctx.restore();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let tile of tiles) {
        drawTile(tile);
    }
    drawSymmetryAxes();
    requestAnimationFrame(draw);
}

canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) {
        dragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        camStartX = camX;
        camStartY = camY;
    }
});
canvas.addEventListener('mousemove', (e) => {
    if (dragging) {
        camX = camStartX - (e.clientX - dragStartX) / camZoom;
        camY = camStartY - (e.clientY - dragStartY) / camZoom;
    }
});
canvas.addEventListener('mouseup', () => { dragging = false; });
canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    let factor = e.deltaY > 0 ? 0.9 : 1.1;
    let mx = (e.clientX - canvas.width / 2) / camZoom + camX;
    let my = (e.clientY - canvas.height / 2) / camZoom + camY;
    camZoom *= factor;
    camZoom = Math.max(0.05, Math.min(50, camZoom));
    camX = mx - (e.clientX - canvas.width / 2) / camZoom;
    camY = my - (e.clientY - canvas.height / 2) / camZoom;
}, { passive: false });

document.getElementById('inflateBtn').addEventListener('click', () => {
    if (level < 9) {
        level++;
        generateTiling(level);
    }
});
document.getElementById('deflateBtn').addEventListener('click', () => {
    if (level > 1) {
        level--;
        generateTiling(level);
    }
});

window.reset = function() {
    level = 5;
    camX = 0; camY = 0; camZoom = 1;
    generateTiling(level);
};

generateTiling(level);
requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
