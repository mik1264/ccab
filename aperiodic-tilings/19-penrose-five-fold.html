<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Five-Fold Symmetry - The Impossible Symmetry</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff;
    max-height: calc(100vh - 60px); overflow-y: auto;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
input[type="range"] { width: 100%; accent-color: #8af; margin-top: 4px; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
button.btn.active { background: rgba(80, 200, 120, 0.3); border-color: rgba(80, 200, 120, 0.5); color: #8fa; }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
.info {
    margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(100,140,255,0.2);
    font-size: 0.75em; color: #6a8; line-height: 1.5;
}
.section-label { color: #8af; font-size: 0.8em; margin: 10px 0 4px 0; font-weight: bold; }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 4px; }
label input { accent-color: #8af; }
select {
    background: rgba(20, 30, 60, 0.8); color: #c8d8ff; border: 1px solid rgba(100,140,255,0.3);
    padding: 4px 8px; border-radius: 4px; font-size: 0.85em; width: 100%; margin-bottom: 8px;
}
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>FIVE-FOLD SYMMETRY</h3>
    <div class="section-label">Demo Mode</div>
    <select id="modeSelect">
        <option value="penrose">Penrose Tiling (5-fold)</option>
        <option value="square">Square Tiling (4-fold)</option>
        <option value="attempt5">Periodic 5-fold? (Impossible!)</option>
        <option value="compare">Compare All</option>
    </select>
    <div class="section-label">Rotation</div>
    <div class="ctrl-row"><span>Angle:</span><span class="val" id="rotVal">0.0&deg;</span></div>
    <input type="range" id="rotSlider" min="0" max="3600" value="0">
    <div class="btn-row">
        <button class="btn" id="rotate72">Rotate 72&deg;</button>
        <button class="btn" id="rotate90">Rotate 90&deg;</button>
    </div>
    <label><input type="checkbox" id="showAxes" checked> Show symmetry axes</label>
    <label><input type="checkbox" id="showOverlay"> Show rotated overlay</label>
    <label><input type="checkbox" id="animateRot"> Animate rotation</label>
    <div class="ctrl-row"><span>Tiles:</span><span class="val" id="tileCount">0</span></div>
    <div class="ctrl-row"><span>Kites:</span><span class="val" id="kiteCount">0</span></div>
    <div class="ctrl-row"><span>Darts:</span><span class="val" id="dartCount">0</span></div>
    <div class="btn-row">
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="info" id="infoText">
        Classical crystals can only have 2, 3, 4, or 6-fold rotational symmetry
        (crystallographic restriction theorem). Penrose tilings break this rule with
        5-fold symmetry - because they are NOT periodic! Rotate by 72&deg; and see the
        pattern match itself, yet it never repeats translationally.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const PHI = (1 + Math.sqrt(5)) / 2;

let W, H;
let time = 0;
let rotation = 0;
let targetRotation = 0;
let triangles = [];
let mode = 'penrose';

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    generate();
}
window.addEventListener('resize', resize);

// Robinson triangle subdivision
function subdivide(tris) {
    let result = [];
    for (let [type, A, B, C] of tris) {
        if (type === 0) { // Half-kite
            let P = [A[0] + (B[0] - A[0]) / PHI, A[1] + (B[1] - A[1]) / PHI];
            result.push([0, C, P, A]);
            result.push([1, C, B, P]);
        } else { // Half-dart
            let Q = [B[0] + (A[0] - B[0]) / PHI, B[1] + (A[1] - B[1]) / PHI];
            let R = [B[0] + (C[0] - B[0]) / PHI, B[1] + (C[1] - B[1]) / PHI];
            result.push([1, R, C, A]);
            result.push([0, Q, R, B]);
            result.push([1, R, Q, A]);
        }
    }
    return result;
}

function generatePenrose() {
    let tris = [];
    let r = Math.max(W, H) * 0.6;
    for (let i = 0; i < 10; i++) {
        let a1 = (2 * Math.PI * i) / 10 - Math.PI / 2;
        let a2 = (2 * Math.PI * (i + 1)) / 10 - Math.PI / 2;
        let A = [0, 0];
        let B = [r * Math.cos(a1), r * Math.sin(a1)];
        let C = [r * Math.cos(a2), r * Math.sin(a2)];
        if (i % 2 === 0) tris.push([0, A, B, C]);
        else tris.push([0, A, C, B]);
    }
    for (let i = 0; i < 5; i++) tris = subdivide(tris);
    return tris;
}

function generate() {
    if (!W) return;
    triangles = generatePenrose();
    updateCounts();
}

function updateCounts() {
    let kites = 0, darts = 0;
    for (let t of triangles) {
        if (t[0] === 0) kites++;
        else darts++;
    }
    kites = Math.floor(kites / 2);
    darts = Math.floor(darts / 2);
    document.getElementById('tileCount').textContent = kites + darts;
    document.getElementById('kiteCount').textContent = kites;
    document.getElementById('dartCount').textContent = darts;
}

document.getElementById('modeSelect').addEventListener('change', e => {
    mode = e.target.value;
    rotation = 0;
    targetRotation = 0;
    document.getElementById('rotSlider').value = 0;
    document.getElementById('rotVal').textContent = '0.0\u00B0';
    updateInfoText();
});

function updateInfoText() {
    let el = document.getElementById('infoText');
    if (mode === 'square') {
        el.textContent = 'Square tilings have 4-fold symmetry: rotation by 90 degrees maps the tiling to itself. They are periodic and fill the plane by translation.';
    } else if (mode === 'attempt5') {
        el.textContent = 'IMPOSSIBLE: No periodic tiling can have 5-fold rotational symmetry. If you try to tile with regular pentagons, gaps always appear. This is the crystallographic restriction theorem.';
    } else if (mode === 'compare') {
        el.textContent = 'Left: Square (4-fold, periodic). Center: Penrose (5-fold, aperiodic!). Right: Pentagon attempt (fails). Only aperiodic tilings can have 5-fold symmetry.';
    } else {
        el.textContent = 'Classical crystals can only have 2, 3, 4, or 6-fold rotational symmetry (crystallographic restriction theorem). Penrose tilings break this rule with 5-fold symmetry - because they are NOT periodic!';
    }
}

document.getElementById('rotSlider').addEventListener('input', e => {
    rotation = parseFloat(e.value) / 10;
    targetRotation = rotation;
    document.getElementById('rotVal').textContent = rotation.toFixed(1) + '\u00B0';
});

document.getElementById('rotate72').addEventListener('click', () => {
    targetRotation = rotation + 72;
});
document.getElementById('rotate90').addEventListener('click', () => {
    targetRotation = rotation + 90;
});

window.reset = function() {
    rotation = 0; targetRotation = 0;
    mode = 'penrose';
    document.getElementById('modeSelect').value = 'penrose';
    document.getElementById('rotSlider').value = 0;
    document.getElementById('rotVal').textContent = '0.0\u00B0';
    generate();
};
document.getElementById('resetBtn').addEventListener('click', window.reset);

function drawPenroseTiling(cx, cy, scale, rot, alpha) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rot * Math.PI / 180);
    ctx.scale(scale, scale);

    for (let [type, A, B, C] of triangles) {
        ctx.beginPath();
        ctx.moveTo(A[0], A[1]);
        ctx.lineTo(B[0], B[1]);
        ctx.lineTo(C[0], C[1]);
        ctx.closePath();
        if (type === 0) {
            ctx.fillStyle = `rgba(60, 140, 220, ${0.5 * alpha})`;
        } else {
            ctx.fillStyle = `rgba(220, 120, 60, ${0.4 * alpha})`;
        }
        ctx.fill();
        ctx.strokeStyle = `rgba(150, 180, 240, ${0.2 * alpha})`;
        ctx.lineWidth = 0.5 / scale;
        ctx.stroke();
    }
    ctx.restore();
}

function drawSquareTiling(cx, cy, size, rot, alpha) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rot * Math.PI / 180);

    let range = Math.ceil(Math.max(W, H) / size) + 2;
    let colors = ['rgba(60, 140, 220, 0.5)', 'rgba(100, 180, 120, 0.4)'];

    for (let i = -range; i <= range; i++) {
        for (let j = -range; j <= range; j++) {
            let x = i * size;
            let y = j * size;
            if (Math.abs(x) > W && Math.abs(y) > H) continue;
            ctx.fillStyle = colors[(i + j + 200) % 2].replace(/[\d.]+\)$/, (0.5 * alpha) + ')');
            ctx.fillRect(x, y, size - 1, size - 1);
            ctx.strokeStyle = `rgba(150, 180, 240, ${0.15 * alpha})`;
            ctx.lineWidth = 0.5;
            ctx.strokeRect(x, y, size - 1, size - 1);
        }
    }
    ctx.restore();
}

function drawPentagonAttempt(cx, cy, size, rot, alpha) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rot * Math.PI / 180);

    // Try to tile with pentagons - show they don't fit
    let placed = [];
    let r = size;

    function drawPentagon(px, py, pr, angle, color) {
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            let a = angle + (i * 2 * Math.PI) / 5 - Math.PI / 2;
            let x = px + pr * Math.cos(a);
            let y = py + pr * Math.sin(a);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = `rgba(150, 180, 240, ${0.3 * alpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Central pentagon
    drawPentagon(0, 0, r, 0, `rgba(140, 100, 220, ${0.5 * alpha})`);

    // Ring of 5 around center - these don't perfectly tile!
    for (let i = 0; i < 5; i++) {
        let a = (i * 2 * Math.PI) / 5 - Math.PI / 2;
        let dist = r * 2 * Math.cos(Math.PI / 5);
        let px = dist * Math.cos(a);
        let py = dist * Math.sin(a);
        drawPentagon(px, py, r, Math.PI / 5, `rgba(100, 160, 200, ${0.4 * alpha})`);
    }

    // Draw gap markers
    for (let i = 0; i < 5; i++) {
        let a1 = (i * 2 * Math.PI) / 5 - Math.PI / 2;
        let a2 = ((i + 1) * 2 * Math.PI) / 5 - Math.PI / 2;
        let dist = r * 2 * Math.cos(Math.PI / 5);
        let gx = (dist * Math.cos(a1) + dist * Math.cos(a2)) / 2;
        let gy = (dist * Math.sin(a1) + dist * Math.sin(a2)) / 2;
        let gd = Math.hypot(gx, gy);
        gx = gx / gd * (gd + r * 0.3);
        gy = gy / gd * (gd + r * 0.3);

        ctx.fillStyle = `rgba(255, 60, 60, ${0.4 * alpha + 0.2 * Math.sin(time * 3) * alpha})`;
        ctx.font = `${r * 0.5}px Segoe UI`;
        ctx.textAlign = 'center';
        ctx.fillText('GAP', gx, gy + r * 0.15);
    }

    ctx.restore();
}

function drawSymmetryAxes(cx, cy, n, color, len) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.setLineDash([8, 4]);

    for (let i = 0; i < n; i++) {
        let a = (i * Math.PI) / n;
        ctx.beginPath();
        ctx.moveTo(-len * Math.cos(a), -len * Math.sin(a));
        ctx.lineTo(len * Math.cos(a), len * Math.sin(a));
        ctx.stroke();
    }

    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
    ctx.restore();
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    let showAxes = document.getElementById('showAxes').checked;
    let showOverlay = document.getElementById('showOverlay').checked;

    if (mode === 'penrose') {
        drawPenroseTiling(W / 2, H / 2, 1, 0, 1);
        if (showOverlay && Math.abs(rotation) > 0.5) {
            drawPenroseTiling(W / 2, H / 2, 1, rotation, 0.4);
        }
        if (showAxes) drawSymmetryAxes(W / 2, H / 2, 5, 'rgba(255,200,80,0.5)', Math.min(W, H) * 0.45);

        // Label
        ctx.fillStyle = '#8af';
        ctx.font = '16px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('Penrose Tiling: 5-fold rotational symmetry (aperiodic)', W / 2, H - 30);

    } else if (mode === 'square') {
        drawSquareTiling(W / 2, H / 2, 40, 0, 1);
        if (showOverlay && Math.abs(rotation) > 0.5) {
            drawSquareTiling(W / 2, H / 2, 40, rotation, 0.4);
        }
        if (showAxes) drawSymmetryAxes(W / 2, H / 2, 4, 'rgba(100,255,150,0.5)', Math.min(W, H) * 0.45);

        ctx.fillStyle = '#8af';
        ctx.font = '16px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('Square Tiling: 4-fold rotational symmetry (periodic)', W / 2, H - 30);

    } else if (mode === 'attempt5') {
        drawPentagonAttempt(W / 2, H / 2, 60, rotation, 1);
        if (showAxes) drawSymmetryAxes(W / 2, H / 2, 5, 'rgba(255,80,80,0.5)', Math.min(W, H) * 0.35);

        ctx.fillStyle = '#f88';
        ctx.font = '18px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('IMPOSSIBLE: Periodic 5-fold tiling cannot exist!', W / 2, H - 50);
        ctx.fillStyle = '#8aa';
        ctx.font = '14px Segoe UI';
        ctx.fillText('Pentagons leave gaps - the crystallographic restriction theorem', W / 2, H - 28);

    } else if (mode === 'compare') {
        let third = W / 3;
        let midY = H / 2;

        // Square (left)
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, third, H);
        ctx.clip();
        drawSquareTiling(third / 2, midY, 30, rotation, 1);
        if (showAxes) drawSymmetryAxes(third / 2, midY, 4, 'rgba(100,255,150,0.4)', third * 0.4);
        ctx.restore();

        // Penrose (center)
        ctx.save();
        ctx.beginPath();
        ctx.rect(third, 0, third, H);
        ctx.clip();
        drawPenroseTiling(third * 1.5, midY, 0.7, 0, 1);
        if (showOverlay && Math.abs(rotation) > 0.5) {
            drawPenroseTiling(third * 1.5, midY, 0.7, rotation, 0.4);
        }
        if (showAxes) drawSymmetryAxes(third * 1.5, midY, 5, 'rgba(255,200,80,0.4)', third * 0.4);
        ctx.restore();

        // Pentagon attempt (right)
        ctx.save();
        ctx.beginPath();
        ctx.rect(third * 2, 0, third, H);
        ctx.clip();
        drawPentagonAttempt(third * 2.5, midY, 40, rotation, 1);
        if (showAxes) drawSymmetryAxes(third * 2.5, midY, 5, 'rgba(255,80,80,0.4)', third * 0.35);
        ctx.restore();

        // Dividing lines
        ctx.strokeStyle = 'rgba(100,140,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(third, 0); ctx.lineTo(third, H); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(third * 2, 0); ctx.lineTo(third * 2, H); ctx.stroke();

        // Labels
        ctx.fillStyle = '#8fa';
        ctx.font = '14px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('4-fold (periodic)', third / 2, 50);
        ctx.fillStyle = '#8af';
        ctx.fillText('5-fold (aperiodic!)', third * 1.5, 50);
        ctx.fillStyle = '#f88';
        ctx.fillText('5-fold periodic: IMPOSSIBLE', third * 2.5, 50);
    }

    // Rotation indicator
    ctx.fillStyle = 'rgba(10,14,30,0.7)';
    ctx.fillRect(W / 2 - 80, 10, 160, 30);
    ctx.fillStyle = '#ffd866';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Rotation: ' + rotation.toFixed(1) + '\u00B0', W / 2, 30);
}

function animate(t) {
    time = t / 1000;

    if (document.getElementById('animateRot').checked) {
        targetRotation += 0.3;
    }

    // Smooth rotation
    if (Math.abs(targetRotation - rotation) > 0.1) {
        rotation += (targetRotation - rotation) * 0.08;
    } else {
        rotation = targetRotation;
    }

    // Keep slider in sync
    let sliderVal = ((rotation % 360) + 360) % 360;
    document.getElementById('rotSlider').value = Math.round(sliderVal * 10);
    document.getElementById('rotVal').textContent = (sliderVal).toFixed(1) + '\u00B0';

    draw();
    requestAnimationFrame(animate);
}

resize();
generate();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>