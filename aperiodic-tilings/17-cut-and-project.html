<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cut-and-Project Method - Aperiodicity from Higher Dimensions</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff;
    max-height: calc(100vh - 60px); overflow-y: auto;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
input[type="range"] { width: 100%; accent-color: #8af; margin-top: 4px; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s; white-space: nowrap;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
.info {
    margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(100,140,255,0.2);
    font-size: 0.75em; color: #6a8; line-height: 1.5;
}
.section-label { color: #8af; font-size: 0.8em; margin: 10px 0 4px 0; font-weight: bold; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>CUT-AND-PROJECT</h3>
    <div class="section-label">Projection Angle</div>
    <div class="ctrl-row"><span>Angle:</span><span class="val" id="angleVal">31.72&deg;</span></div>
    <input type="range" id="angleSlider" min="0" max="9000" value="3172">
    <div class="btn-row">
        <button class="btn" id="goldenBtn">1/&phi; (aperiodic)</button>
        <button class="btn" id="rationalBtn">1/3 (periodic)</button>
    </div>
    <div class="section-label">Strip Width</div>
    <div class="ctrl-row"><span>Width:</span><span class="val" id="widthVal">1.00</span></div>
    <input type="range" id="widthSlider" min="30" max="200" value="100">
    <div class="section-label">Strip Offset</div>
    <div class="ctrl-row"><span>Offset:</span><span class="val" id="offsetVal">0.00</span></div>
    <input type="range" id="offsetSlider" min="-500" max="500" value="0">
    <div class="ctrl-row"><span>Points in strip:</span><span class="val" id="pointCount">0</span></div>
    <div class="ctrl-row"><span>L intervals:</span><span class="val" id="longCount">0</span></div>
    <div class="ctrl-row"><span>S intervals:</span><span class="val" id="shortCount">0</span></div>
    <div class="ctrl-row"><span>L/S ratio:</span><span class="val" id="ratioVal">--</span></div>
    <div class="ctrl-row"><span>&phi; = 1.618...</span><span class="val" style="color:#6a8">golden ratio</span></div>
    <label style="font-size:0.8em;color:#8aa;display:flex;align-items:center;gap:6px;cursor:pointer;margin-top:6px">
        <input type="checkbox" id="animateOffset" style="accent-color:#8af"> Animate offset
    </label>
    <div class="btn-row" style="margin-top:10px">
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="info">
        Penrose tilings are 2D slices of a 5D periodic lattice. Here we show the 1D analogue:
        projecting a 2D square lattice at angle arctan(1/&phi;) produces a Fibonacci sequence
        of Long and Short intervals. Rational angles give periodic patterns; irrational angles
        (like 1/&phi;) give aperiodic patterns with sharp diffraction peaks.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const PHI = (1 + Math.sqrt(5)) / 2;

let W, H;
let angle = Math.atan(1 / PHI);
let stripWidth = 1.0;
let stripOffset = 0;
let time = 0;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const angleSlider = document.getElementById('angleSlider');
const widthSlider = document.getElementById('widthSlider');
const offsetSlider = document.getElementById('offsetSlider');

function updateAngle() {
    angle = (parseFloat(angleSlider.value) / 10000) * (Math.PI / 2);
    document.getElementById('angleVal').textContent = (angle * 180 / Math.PI).toFixed(2) + '\u00B0';
}
function updateWidth() {
    stripWidth = parseFloat(widthSlider.value) / 100;
    document.getElementById('widthVal').textContent = stripWidth.toFixed(2);
}
function updateOffset() {
    stripOffset = parseFloat(offsetSlider.value) / 100;
    document.getElementById('offsetVal').textContent = stripOffset.toFixed(2);
}

angleSlider.addEventListener('input', updateAngle);
widthSlider.addEventListener('input', updateWidth);
offsetSlider.addEventListener('input', updateOffset);

document.getElementById('goldenBtn').addEventListener('click', () => {
    let a = Math.atan(1 / PHI);
    angleSlider.value = Math.round(a / (Math.PI / 2) * 10000);
    updateAngle();
});
document.getElementById('rationalBtn').addEventListener('click', () => {
    let a = Math.atan(1 / 3);
    angleSlider.value = Math.round(a / (Math.PI / 2) * 10000);
    updateAngle();
});

function reset() {
    angleSlider.value = Math.round(Math.atan(1 / PHI) / (Math.PI / 2) * 10000);
    widthSlider.value = 100;
    offsetSlider.value = 0;
    updateAngle();
    updateWidth();
    updateOffset();
}
window.reset = reset;
document.getElementById('resetBtn').addEventListener('click', reset);

function getProjection() {
    let cosA = Math.cos(angle);
    let sinA = Math.sin(angle);
    // Direction along the strip
    let dx = cosA, dy = sinA;
    // Normal to the strip
    let nx = -sinA, ny = cosA;

    // Effective strip half-width in the perpendicular direction
    let halfW = (Math.abs(cosA) + Math.abs(sinA)) * stripWidth * 0.5;

    let range = 30;
    let insidePoints = [];

    for (let i = -range; i <= range; i++) {
        for (let j = -range; j <= range; j++) {
            // Perpendicular distance to strip center line (offset by stripOffset along normal)
            let perpDist = i * nx + j * ny - stripOffset;
            if (Math.abs(perpDist) <= halfW) {
                // Project onto strip axis
                let proj = i * dx + j * dy;
                insidePoints.push({ i, j, proj, perpDist });
            }
        }
    }

    insidePoints.sort((a, b) => a.proj - b.proj);
    return { insidePoints, cosA, sinA, dx, dy, nx, ny, halfW };
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    let leftW = W * 0.55;
    let rightW = W * 0.45;
    let latticeX = leftW / 2;
    let latticeY = H / 2;
    let scale = Math.min(leftW, H) / 22;

    let { insidePoints, cosA, sinA, dx, dy, nx, ny, halfW } = getProjection();

    // Draw dividing line
    ctx.strokeStyle = 'rgba(100,140,255,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(leftW, 0);
    ctx.lineTo(leftW, H);
    ctx.stroke();

    // LEFT PANEL: 2D lattice with strip
    ctx.save();
    ctx.translate(latticeX, latticeY);

    // Draw grid
    let range = 16;
    ctx.strokeStyle = 'rgba(80, 100, 140, 0.15)';
    ctx.lineWidth = 0.5;
    for (let i = -range; i <= range; i++) {
        ctx.beginPath();
        ctx.moveTo(i * scale, -range * scale);
        ctx.lineTo(i * scale, range * scale);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-range * scale, i * scale);
        ctx.lineTo(range * scale, i * scale);
        ctx.stroke();
    }

    // Draw strip
    let stripLen = range * scale * 2;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#4af';
    ctx.beginPath();
    let sx1 = -stripLen * dx + halfW * nx * scale + stripOffset * nx * scale;
    let sy1 = -stripLen * dy + halfW * ny * scale + stripOffset * ny * scale;
    let sx2 = stripLen * dx + halfW * nx * scale + stripOffset * nx * scale;
    let sy2 = stripLen * dy + halfW * ny * scale + stripOffset * ny * scale;
    let sx3 = stripLen * dx - halfW * nx * scale + stripOffset * nx * scale;
    let sy3 = stripLen * dy - halfW * ny * scale + stripOffset * ny * scale;
    let sx4 = -stripLen * dx - halfW * nx * scale + stripOffset * nx * scale;
    let sy4 = -stripLen * dy - halfW * ny * scale + stripOffset * ny * scale;
    ctx.moveTo(sx1, sy1);
    ctx.lineTo(sx2, sy2);
    ctx.lineTo(sx3, sy3);
    ctx.lineTo(sx4, sy4);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Strip edges
    ctx.strokeStyle = 'rgba(80, 160, 255, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.moveTo(sx1, sy1); ctx.lineTo(sx2, sy2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(sx4, sy4); ctx.lineTo(sx3, sy3);
    ctx.stroke();
    ctx.setLineDash([]);

    // Strip center axis
    ctx.strokeStyle = 'rgba(255, 200, 80, 0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(-stripLen * dx + stripOffset * nx * scale, -stripLen * dy + stripOffset * ny * scale);
    ctx.lineTo(stripLen * dx + stripOffset * nx * scale, stripLen * dy + stripOffset * ny * scale);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw lattice points
    for (let i = -range; i <= range; i++) {
        for (let j = -range; j <= range; j++) {
            let px = i * scale, py = j * scale;
            if (Math.abs(px) > leftW / 2 + 10 || Math.abs(py) > H / 2 + 10) continue;

            let perpDist = i * nx + j * ny - stripOffset;
            let inside = Math.abs(perpDist) <= halfW;

            if (inside) {
                ctx.fillStyle = '#ffd866';
                ctx.shadowColor = '#ffd866';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Projection line
                let proj = i * dx + j * dy;
                let projX = proj * dx * scale / scale + stripOffset * nx * scale;
                // Actually project onto axis
                let tX = proj * dx * scale + stripOffset * nx * scale;
                let tY = proj * dy * scale + stripOffset * ny * scale;
                ctx.strokeStyle = 'rgba(255,216,100,0.2)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(tX, tY);
                ctx.stroke();
            } else {
                ctx.fillStyle = 'rgba(100, 120, 160, 0.3)';
                ctx.beginPath();
                ctx.arc(px, py, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    ctx.restore();

    // Labels
    ctx.fillStyle = '#8af';
    ctx.font = '14px Segoe UI';
    ctx.fillText('2D Square Lattice', 20, H - 30);
    ctx.fillText('1D Projected Chain', leftW + 20, H - 30);

    // RIGHT PANEL: 1D projection
    let projX = leftW + rightW / 2;
    let projTop = 60;
    let projH = H - 120;

    if (insidePoints.length > 1) {
        let minP = insidePoints[0].proj;
        let maxP = insidePoints[insidePoints.length - 1].proj;
        let pRange = maxP - minP || 1;

        // Draw the chain
        let intervals = [];
        let prevY = null;
        for (let k = 0; k < insidePoints.length; k++) {
            let t = (insidePoints[k].proj - minP) / pRange;
            let py = projTop + t * projH;

            // Point on chain
            ctx.fillStyle = '#ffd866';
            ctx.shadowColor = '#ffd866';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.arc(projX, py, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            if (prevY !== null) {
                let gap = py - prevY;
                intervals.push(gap);

                // Draw segment
                let isLong = gap > (projH / insidePoints.length) * 1.3;
                ctx.strokeStyle = isLong ? 'rgba(100,200,255,0.7)' : 'rgba(255,140,80,0.7)';
                ctx.lineWidth = isLong ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(projX, prevY);
                ctx.lineTo(projX, py);
                ctx.stroke();

                // Label
                let label = isLong ? 'L' : 'S';
                ctx.fillStyle = isLong ? '#4cf' : '#fa8';
                ctx.font = '11px monospace';
                ctx.fillText(label, projX + 12, (py + prevY) / 2 + 4);
            }
            prevY = py;
        }

        // Count L and S
        if (intervals.length > 0) {
            let median = [...intervals].sort((a, b) => a - b)[Math.floor(intervals.length / 2)];
            let longCount = intervals.filter(g => g > median * 0.9).length;
            let shortCount = intervals.length - longCount;
            document.getElementById('longCount').textContent = longCount;
            document.getElementById('shortCount').textContent = shortCount;
            document.getElementById('ratioVal').textContent = shortCount > 0 ? (longCount / shortCount).toFixed(4) : '--';
        }
    }

    document.getElementById('pointCount').textContent = insidePoints.length;

    // Draw conceptual diagram at bottom right
    ctx.fillStyle = 'rgba(100,140,255,0.08)';
    ctx.fillRect(leftW + 10, projTop - 40, rightW - 20, 30);
    ctx.fillStyle = '#6a8';
    ctx.font = '11px Segoe UI';
    let isIrrational = Math.abs(Math.tan(angle) - 1 / PHI) < 0.01;
    let patternType = isIrrational ? 'APERIODIC (Fibonacci)' : (Math.abs(Math.tan(angle) % 0.01) < 0.005 ? 'PERIODIC' : 'QUASIPERIODIC');
    ctx.fillText('Pattern: ' + patternType, leftW + 20, projTop - 22);
}

function animate(t) {
    time = t / 1000;
    if (document.getElementById('animateOffset').checked) {
        stripOffset = Math.sin(time * 0.3) * 2;
        offsetSlider.value = Math.round(stripOffset * 100);
        document.getElementById('offsetVal').textContent = stripOffset.toFixed(2);
    }
    draw();
    requestAnimationFrame(animate);
}

updateAngle();
updateWidth();
updateOffset();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>