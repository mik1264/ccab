<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ammann-Beenker Tiling</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.2); border-radius: 12px;
    padding: 18px; color: #c0d0ff; min-width: 260px;
}
#controls h3 { color: #88aaff; margin-bottom: 10px; font-size: 1em; }
#controls p { font-size: 0.78em; line-height: 1.5; margin-bottom: 8px; color: #8899bb; }
.slider-row { margin: 8px 0; }
.slider-row label { font-size: 0.8em; color: #88aaff; display: block; margin-bottom: 4px; }
.slider-row input[type="range"] {
    width: 100%; -webkit-appearance: none; height: 6px;
    background: linear-gradient(90deg, #448, #88f, #c8f);
    border-radius: 3px; outline: none;
}
.slider-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 16px; height: 16px;
    background: #88aaff; border-radius: 50%; cursor: pointer;
    border: 2px solid #0a0e1a;
}
.btn-row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
.btn {
    padding: 6px 12px; border: 1px solid rgba(100,140,255,0.3);
    background: rgba(100,140,255,0.1); color: #88aaff; border-radius: 6px;
    cursor: pointer; font-size: 0.8em; transition: all 0.2s;
}
.btn:hover { background: rgba(100,140,255,0.25); }
.btn.active { background: rgba(100,140,255,0.35); border-color: #88aaff; }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.2); border-radius: 12px;
    padding: 16px; color: #8899bb; font-size: 0.75em; max-width: 260px; line-height: 1.5;
}
#info strong { color: #88aaff; }
#tileStats { color: #88aaff; font-size: 0.85em; margin-top: 6px; }
.legend { display: flex; gap: 12px; margin-top: 10px; }
.legend-item { display: flex; align-items: center; gap: 4px; font-size: 0.75em; color: #99aacc; }
.legend-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.15); }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#88aaff;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>

<div id="info">
    <strong>Ammann-Beenker Tiling</strong><br>
    An aperiodic tiling with <strong>8-fold rotational symmetry</strong> using just two tile types:<br><br>
    <strong style="color:#6688ff">Squares</strong> and <strong style="color:#cc88ff">45-degree Rhombuses</strong><br><br>
    Discovered independently by Robert Ammann and F.P.M. Beenker in the 1970s-80s, this tiling is related to octagonal quasicrystals.<br><br>
    <strong>Ammann bars</strong> are straight lines that cross all tile boundaries, revealing the hidden long-range order.
    <div id="tileStats"></div>
</div>

<div id="controls">
    <h3>Ammann-Beenker Tiling</h3>
    <div class="slider-row">
        <label>Subdivision Level: <span id="levelDisplay">3</span></label>
        <input type="range" id="levelSlider" min="1" max="5" step="1" value="3">
    </div>
    <div class="btn-row">
        <button class="btn active" onclick="setStyle('filled')" id="btnFilled">Filled</button>
        <button class="btn" onclick="setStyle('outline')" id="btnOutline">Outline</button>
        <button class="btn" onclick="setStyle('gradient')" id="btnGradient">Gradient</button>
    </div>
    <div class="btn-row">
        <button class="btn" onclick="toggleAmmann()" id="btnAmmann">Ammann Bars</button>
        <button class="btn" onclick="toggleRotation()" id="btnRotate">Rotate</button>
    </div>
    <div class="legend">
        <div class="legend-item">
            <div class="legend-swatch" style="background:rgba(80,120,255,0.6)"></div> Square
        </div>
        <div class="legend-item">
            <div class="legend-swatch" style="background:rgba(180,100,255,0.6)"></div> Rhombus
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    regenerate();
}
resize();
window.addEventListener('resize', resize);

const SQRT2 = Math.sqrt(2);
const PI = Math.PI;
const PI4 = PI / 4;

// Ammann-Beenker tiling via substitution
// Two tile types: square and 45-degree rhombus

// Square vertices (unit edge)
function squareVerts(cx, cy, size, angle) {
    const verts = [];
    for (let i = 0; i < 4; i++) {
        const a = angle + i * PI / 2 + PI / 4;
        verts.push({
            x: cx + size * Math.cos(a) * SQRT2 / 2,
            y: cy + size * Math.sin(a) * SQRT2 / 2
        });
    }
    return verts;
}

// Rhombus vertices (45 degree, unit edge)
function rhombusVerts(cx, cy, size, angle) {
    const short = size * Math.sin(PI / 8);
    const long_ = size * Math.cos(PI / 8);
    return [
        {x: cx + long_ * Math.cos(angle), y: cy + long_ * Math.sin(angle)},
        {x: cx + short * Math.cos(angle + PI/2), y: cy + short * Math.sin(angle + PI/2)},
        {x: cx - long_ * Math.cos(angle), y: cy - long_ * Math.sin(angle)},
        {x: cx - short * Math.cos(angle + PI/2), y: cy - short * Math.sin(angle + PI/2)}
    ];
}

// Generate tiles using the dual-grid (de Bruijn) method for Ammann-Beenker
// 4 families of parallel lines at 0, 45, 90, 135 degrees
function generateDualGrid(level) {
    const tiles = [];
    const spacing = Math.max(W, H) / (level * 4 + 2);
    const range = level * 4 + 3;
    const offset = 0.1234; // Irrational offset for aperiodicity

    const directions = [
        {dx: 1, dy: 0},                    // 0 degrees
        {dx: SQRT2/2, dy: SQRT2/2},       // 45 degrees
        {dx: 0, dy: 1},                    // 90 degrees
        {dx: -SQRT2/2, dy: SQRT2/2}       // 135 degrees
    ];

    // For each pair of grid families, compute intersection points
    for (let f1 = 0; f1 < 4; f1++) {
        for (let f2 = f1 + 1; f2 < 4; f2++) {
            const d1 = directions[f1];
            const d2 = directions[f2];

            for (let i = -range; i <= range; i++) {
                for (let j = -range; j <= range; j++) {
                    // Line i from family f1 intersects line j from family f2
                    const n1x = -d1.dy, n1y = d1.dx;
                    const n2x = -d2.dy, n2y = d2.dx;

                    const off1 = (i + offset) * spacing;
                    const off2 = (j + offset * SQRT2) * spacing;

                    // Solve: n1.(p) = off1, n2.(p) = off2
                    const det = n1x * n2y - n1y * n2x;
                    if (Math.abs(det) < 1e-10) continue;

                    const px = (off1 * n2y - off2 * n1y) / det;
                    const py = (n1x * off2 - n2x * off1) / det;

                    // Determine tile type based on angle between grid families
                    const angleDiff = (f2 - f1) * PI / 4;
                    const isSquare = Math.abs(Math.abs(angleDiff) - PI/2) < 0.01;

                    const tileAngle = (f1 + f2) * PI / 8;
                    const size = spacing * 0.48;

                    let verts;
                    if (isSquare) {
                        verts = squareVerts(px, py, size, tileAngle);
                    } else {
                        verts = rhombusVerts(px, py, size, tileAngle);
                    }

                    // Check if tile is on screen (with margin)
                    const margin = spacing * 2;
                    const cx = px, cy = py;
                    if (cx > -W/2 - margin && cx < W/2 + margin &&
                        cy > -H/2 - margin && cy < H/2 + margin) {
                        tiles.push({
                            verts,
                            type: isSquare ? 'square' : 'rhombus',
                            cx: px, cy: py,
                            angle: tileAngle,
                            size,
                            gridI: i, gridJ: j,
                            families: [f1, f2]
                        });
                    }
                }
            }
        }
    }

    return tiles;
}

// Generate Ammann bars
function generateAmmannBars(tiles, level) {
    const bars = [];
    const spacing = Math.max(W, H) / (level * 4 + 2);
    const range = level * 4 + 3;
    const offset = 0.1234;
    const len = Math.max(W, H);

    const directions = [
        {dx: 1, dy: 0},
        {dx: SQRT2/2, dy: SQRT2/2},
        {dx: 0, dy: 1},
        {dx: -SQRT2/2, dy: SQRT2/2}
    ];

    for (let f = 0; f < 4; f++) {
        const d = directions[f];
        for (let i = -range; i <= range; i++) {
            const off = (i + offset) * spacing;
            const nx = -d.dy, ny = d.dx;
            const bx = nx * off;
            const by = ny * off;

            bars.push({
                x1: bx - d.dx * len,
                y1: by - d.dy * len,
                x2: bx + d.dx * len,
                y2: by + d.dy * len,
                family: f
            });
        }
    }

    return bars;
}

let tiles = [];
let ammannBars = [];
let currentLevel = 3;
let colorStyle = 'filled';
let showAmmann = false;
let rotating = false;
let rotationAngle = 0;

let camX = 0, camY = 0, camZoom = 1;
let dragging = false, lastMx = 0, lastMy = 0;

function regenerate() {
    tiles = generateDualGrid(currentLevel);
    ammannBars = generateAmmannBars(tiles, currentLevel);
    updateStats();
}

function updateStats() {
    const squares = tiles.filter(t => t.type === 'square').length;
    const rhombuses = tiles.filter(t => t.type === 'rhombus').length;
    document.getElementById('tileStats').innerHTML =
        `Total: ${tiles.length} tiles<br>` +
        `<span style="color:#6688ff">Squares: ${squares}</span> | ` +
        `<span style="color:#cc88ff">Rhombuses: ${rhombuses}</span>`;
}

// Pan/zoom
canvas.addEventListener('mousedown', e => { dragging = true; lastMx = e.clientX; lastMy = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX += (e.clientX - lastMx) / camZoom;
    camY += (e.clientY - lastMy) / camZoom;
    lastMx = e.clientX; lastMy = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camZoom *= e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.2, Math.min(5, camZoom));
}, {passive: false});

let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) { dragging = true; lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY; }
    else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
    }
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && dragging) {
        camX += (e.touches[0].clientX - lastMx) / camZoom;
        camY += (e.touches[0].clientY - lastMy) / camZoom;
        lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist > 0) camZoom *= dist / lastTouchDist;
        camZoom = Math.max(0.2, Math.min(5, camZoom));
        lastTouchDist = dist;
    }
}, {passive: false});
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

// Controls
const levelSlider = document.getElementById('levelSlider');
levelSlider.addEventListener('input', () => {
    currentLevel = parseInt(levelSlider.value);
    document.getElementById('levelDisplay').textContent = currentLevel;
    regenerate();
});

function setStyle(s) {
    colorStyle = s;
    document.querySelectorAll('.btn').forEach(b => {
        if (['btnFilled','btnOutline','btnGradient'].includes(b.id)) b.classList.remove('active');
    });
    document.getElementById('btn' + s.charAt(0).toUpperCase() + s.slice(1)).classList.add('active');
}

function toggleAmmann() {
    showAmmann = !showAmmann;
    document.getElementById('btnAmmann').classList.toggle('active');
}

function toggleRotation() {
    rotating = !rotating;
    document.getElementById('btnRotate').classList.toggle('active');
}

function drawTile(tile, time) {
    const verts = tile.verts;

    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i].x, verts[i].y);
    ctx.closePath();

    if (colorStyle === 'filled' || colorStyle === 'gradient') {
        if (colorStyle === 'gradient') {
            const grad = ctx.createRadialGradient(tile.cx, tile.cy, 0, tile.cx, tile.cy, tile.size);
            if (tile.type === 'square') {
                grad.addColorStop(0, 'rgba(100, 150, 255, 0.7)');
                grad.addColorStop(1, 'rgba(40, 60, 180, 0.4)');
            } else {
                grad.addColorStop(0, 'rgba(200, 130, 255, 0.7)');
                grad.addColorStop(1, 'rgba(120, 40, 200, 0.4)');
            }
            ctx.fillStyle = grad;
        } else {
            if (tile.type === 'square') {
                const hue = 220 + tile.angle * 20;
                ctx.fillStyle = `hsla(${hue}, 60%, 45%, 0.6)`;
            } else {
                const hue = 280 + tile.angle * 20;
                ctx.fillStyle = `hsla(${hue}, 55%, 50%, 0.6)`;
            }
        }
        ctx.fill();
    }

    if (tile.type === 'square') {
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.5)';
    } else {
        ctx.strokeStyle = 'rgba(200, 130, 255, 0.5)';
    }
    ctx.lineWidth = colorStyle === 'outline' ? 1.5 / camZoom : 0.8 / camZoom;
    ctx.stroke();
}

function draw(time) {
    ctx.clearRect(0, 0, W, H);

    // Background
    const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
    bgGrad.addColorStop(0, '#0c0e20');
    bgGrad.addColorStop(1, '#04050c');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // 8-fold symmetry radial lines (subtle)
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.globalAlpha = 0.04;
    for (let i = 0; i < 8; i++) {
        const a = i * PI / 4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * Math.max(W,H), Math.sin(a) * Math.max(W,H));
        ctx.strokeStyle = '#88aaff';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.restore();

    if (rotating) {
        rotationAngle += 0.002;
    }

    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.rotate(rotationAngle);
    ctx.scale(camZoom, camZoom);
    ctx.translate(camX, camY);

    // Draw tiles
    for (const tile of tiles) {
        drawTile(tile, time);
    }

    // Draw Ammann bars
    if (showAmmann) {
        ctx.globalAlpha = 0.25;
        const barColors = ['#ff6644', '#44ff88', '#4488ff', '#ffcc44'];
        for (const bar of ammannBars) {
            ctx.beginPath();
            ctx.moveTo(bar.x1, bar.y1);
            ctx.lineTo(bar.x2, bar.y2);
            ctx.strokeStyle = barColors[bar.family];
            ctx.lineWidth = 0.8 / camZoom;
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    ctx.restore();

    requestAnimationFrame(draw);
}

regenerate();
requestAnimationFrame(draw);

window.reset = function() {
    camX = 0; camY = 0; camZoom = 1;
    rotationAngle = 0;
    rotating = false;
    showAmmann = false;
    colorStyle = 'filled';
    currentLevel = 3;
    levelSlider.value = 3;
    document.getElementById('levelDisplay').textContent = '3';
    document.getElementById('btnAmmann').classList.remove('active');
    document.getElementById('btnRotate').classList.remove('active');
    setStyle('filled');
    regenerate();
};
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
