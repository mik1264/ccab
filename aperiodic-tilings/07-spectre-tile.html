<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Spectre Tile</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 255, 180, 0.2); border-radius: 12px;
    padding: 18px; color: #c8ffd8; min-width: 250px;
}
#controls h3 { color: #6fv; margin-bottom: 10px; font-size: 1em; color: #8fa; }
#controls p { font-size: 0.78em; line-height: 1.5; margin-bottom: 8px; color: #9ba; }
.btn-row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
.btn {
    padding: 6px 12px; border: 1px solid rgba(138,255,180,0.3);
    background: rgba(138,255,180,0.1); color: #8fa; border-radius: 6px;
    cursor: pointer; font-size: 0.8em; transition: all 0.2s;
}
.btn:hover { background: rgba(138,255,180,0.25); }
.btn.active { background: rgba(138,255,180,0.35); border-color: #8fa; }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 255, 180, 0.2); border-radius: 12px;
    padding: 16px; color: #9ba; font-size: 0.75em; max-width: 270px; line-height: 1.5;
}
#info strong { color: #8fa; }
#compare {
    position: fixed; top: 70px; left: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.9); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 255, 180, 0.2); border-radius: 12px;
    padding: 12px; display: none;
}
#compare canvas { border-radius: 8px; }
#tileCount { color: #8fa; font-size: 0.85em; margin-top: 6px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8fa;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>

<div id="info">
    <strong>The Spectre Tile</strong><br>
    A modification of the Hat monotile family with <strong>curved edges</strong> that eliminates the need for reflections.<br><br>
    Every Spectre tile has the <strong style="color:#ff8">same chirality</strong> -- this is the true "einstein" (one stone). No mirrors required!<br><br>
    <strong>Chirality:</strong> Like left and right hands, the Spectre cannot be superimposed on its mirror image.
    <div id="tileCount"></div>
</div>

<div id="compare">
    <canvas id="compareCanvas" width="200" height="200"></canvas>
</div>

<div id="controls">
    <h3>Spectre Tile</h3>
    <p>Pan: drag | Zoom: scroll<br>All tiles same chirality - no reflections!</p>
    <div class="btn-row">
        <button class="btn active" onclick="setStyle('rainbow')" id="btnRainbow">Rainbow</button>
        <button class="btn" onclick="setStyle('mono')" id="btnMono">Monochrome</button>
        <button class="btn" onclick="setStyle('glow')" id="btnGlow">Glow</button>
    </div>
    <div class="btn-row">
        <button class="btn" onclick="toggleCompare()" id="btnCompare">Hat vs Spectre</button>
        <button class="btn" onclick="togglePulse()" id="btnPulse">Pulse</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const S3 = Math.sqrt(3);

// Hat base vertices
const hatBase = [
    {x: 0, y: 0}, {x: 1, y: 0}, {x: 1.5, y: S3/2},
    {x: 1, y: S3}, {x: 1.5, y: 3*S3/2}, {x: 1, y: 2*S3},
    {x: 0, y: 2*S3}, {x: -0.5, y: 3*S3/2}, {x: 0, y: S3},
    {x: -0.5, y: S3/2}, {x: -1, y: S3}, {x: -1.5, y: S3/2},
    {x: -1, y: 0}
];

// Spectre: curved edges on the hat shape
// We'll draw the spectre by curving each edge with a consistent bulge direction
function drawSpectrePath(ctx, verts, curvature) {
    ctx.beginPath();
    for (let i = 0; i < verts.length; i++) {
        const p0 = verts[i];
        const p1 = verts[(i + 1) % verts.length];

        if (i === 0) ctx.moveTo(p0.x, p0.y);

        // Curve each edge with alternating bulge
        const mx = (p0.x + p1.x) / 2;
        const my = (p0.y + p1.y) / 2;
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const len = Math.sqrt(dx*dx + dy*dy);

        // Normal direction, alternating sign for chirality
        const sign = (i % 2 === 0) ? 1 : -1;
        const nx = -dy / len * curvature * len * 0.2 * sign;
        const ny = dx / len * curvature * len * 0.2 * sign;

        ctx.quadraticCurveTo(mx + nx, my + ny, p1.x, p1.y);
    }
    ctx.closePath();
}

function transformVerts(verts, angle, tx, ty, scale) {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    return verts.map(v => {
        const vx = v.x * scale, vy = v.y * scale;
        return {
            x: vx * cos - vy * sin + tx,
            y: vx * sin + vy * cos + ty
        };
    });
}

// Generate spectre tile patch
function generateSpectrePatch() {
    const tiles = [];
    const scale = 28;
    const rings = 6;

    for (let ring = 0; ring <= rings; ring++) {
        for (let i = -ring; i <= ring; i++) {
            for (let j = -ring; j <= ring; j++) {
                if (ring > 0 && Math.abs(i) !== ring && Math.abs(j) !== ring) continue;

                const cx = i * 3 * scale + j * 1.5 * scale;
                const cy = j * S3 * 1.5 * scale;

                const rot = ((i * 2 + j * 3) % 6 + 6) % 6;
                const angle = rot * Math.PI / 3;

                tiles.push({x: cx, y: cy, angle, ring});

                if ((i + j) % 2 === 0) {
                    const a2 = angle + Math.PI / 3;
                    const ox = 2.2 * scale * Math.cos(angle + Math.PI/6);
                    const oy = 2.2 * scale * Math.sin(angle + Math.PI/6);
                    tiles.push({x: cx + ox, y: cy + oy, angle: a2, ring});
                }

                if ((i - j) % 3 === 0) {
                    const a3 = angle + 2 * Math.PI / 3;
                    const ox = 2.5 * scale * Math.cos(angle - Math.PI/3);
                    const oy = 2.5 * scale * Math.sin(angle - Math.PI/3);
                    tiles.push({x: cx + ox, y: cy + oy, angle: a3, ring});
                }
            }
        }
    }

    // Remove overlapping
    const used = [];
    const result = [];
    for (const p of tiles) {
        let overlap = false;
        for (const u of used) {
            const dx = p.x - u.x, dy = p.y - u.y;
            if (dx*dx + dy*dy < (scale * 1.8) * (scale * 1.8)) {
                overlap = true; break;
            }
        }
        if (!overlap) {
            const verts = transformVerts(hatBase, p.angle, p.x, p.y, scale);
            const dist = Math.sqrt(p.x*p.x + p.y*p.y);
            result.push({
                verts,
                angle: p.angle,
                dist,
                hue: (p.angle / (2*Math.PI) * 360 + dist * 0.3) % 360
            });
            used.push(p);
        }
    }

    result.sort((a, b) => a.dist - b.dist);
    return result;
}

let tiles = generateSpectrePatch();
let colorStyle = 'rainbow';
let showCompare = false;
let pulseEnabled = false;
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, lastMx = 0, lastMy = 0;

// Pan/zoom
canvas.addEventListener('mousedown', e => { dragging = true; lastMx = e.clientX; lastMy = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX += (e.clientX - lastMx) / camZoom;
    camY += (e.clientY - lastMy) / camZoom;
    lastMx = e.clientX; lastMy = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camZoom *= e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.1, Math.min(5, camZoom));
}, {passive: false});

// Touch
let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) { dragging = true; lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY; }
    else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
    }
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && dragging) {
        camX += (e.touches[0].clientX - lastMx) / camZoom;
        camY += (e.touches[0].clientY - lastMy) / camZoom;
        lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist > 0) camZoom *= dist / lastTouchDist;
        camZoom = Math.max(0.1, Math.min(5, camZoom));
        lastTouchDist = dist;
    }
}, {passive: false});
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

function setStyle(s) {
    colorStyle = s;
    document.querySelectorAll('.btn').forEach(b => {
        if (['btnRainbow','btnMono','btnGlow'].includes(b.id)) b.classList.remove('active');
    });
    document.getElementById('btn' + s.charAt(0).toUpperCase() + s.slice(1)).classList.add('active');
}

function toggleCompare() {
    showCompare = !showCompare;
    document.getElementById('compare').style.display = showCompare ? 'block' : 'none';
    document.getElementById('btnCompare').classList.toggle('active');
    if (showCompare) drawComparison();
}

function togglePulse() {
    pulseEnabled = !pulseEnabled;
    document.getElementById('btnPulse').classList.toggle('active');
}

// Draw comparison inset: Hat vs Spectre
function drawComparison() {
    const cc = document.getElementById('compareCanvas');
    const c2 = cc.getContext('2d');
    const w = 200, h = 200;
    c2.clearRect(0, 0, w, h);
    c2.fillStyle = '#0a0e1a';
    c2.fillRect(0, 0, w, h);

    // Hat (left side)
    const hatV = transformVerts(hatBase, 0, 45, 100, 12);
    c2.beginPath();
    c2.moveTo(hatV[0].x, hatV[0].y);
    for (let i = 1; i < hatV.length; i++) c2.lineTo(hatV[i].x, hatV[i].y);
    c2.closePath();
    c2.fillStyle = 'rgba(138,170,255,0.3)';
    c2.fill();
    c2.strokeStyle = '#8af';
    c2.lineWidth = 1.5;
    c2.stroke();

    // Mirror hat
    const mirV = transformVerts(hatBase, 0, 45, 100, 12);
    c2.save();
    c2.scale(-1, 1);
    c2.translate(-90, 0);
    c2.beginPath();
    c2.moveTo(hatV[0].x, hatV[0].y);
    for (let i = 1; i < hatV.length; i++) c2.lineTo(hatV[i].x, hatV[i].y);
    c2.closePath();
    c2.strokeStyle = '#f8a';
    c2.lineWidth = 1;
    c2.setLineDash([3,3]);
    c2.stroke();
    c2.setLineDash([]);
    c2.restore();

    // Spectre (right side)
    const specV = transformVerts(hatBase, 0, 150, 100, 12);
    drawSpectrePath(c2, specV, 1);
    c2.fillStyle = 'rgba(138,255,180,0.3)';
    c2.fill();
    c2.strokeStyle = '#8fa';
    c2.lineWidth = 1.5;
    c2.stroke();

    // Labels
    c2.font = '11px sans-serif';
    c2.fillStyle = '#8af';
    c2.textAlign = 'center';
    c2.fillText('Hat', 45, 20);
    c2.fillStyle = '#f8a';
    c2.fillText('+ mirror', 45, 34);
    c2.fillStyle = '#8fa';
    c2.fillText('Spectre', 150, 20);
    c2.fillStyle = '#ff8';
    c2.fillText('no mirror!', 150, 34);
}

function draw(time) {
    ctx.clearRect(0, 0, W, H);

    const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
    bgGrad.addColorStop(0, '#0c1420');
    bgGrad.addColorStop(1, '#050810');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(camZoom, camZoom);
    ctx.translate(camX, camY);

    const pulse = pulseEnabled ? 0.08 * Math.sin(time * 0.002) : 0;

    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        const verts = tile.verts;

        const tileAlpha = pulseEnabled ? 0.7 + 0.3 * Math.sin(time * 0.003 + tile.dist * 0.01) : 1;
        ctx.globalAlpha = tileAlpha;

        drawSpectrePath(ctx, verts, 1 + pulse);

        if (colorStyle === 'rainbow') {
            ctx.fillStyle = `hsla(${tile.hue}, 65%, 50%, 0.7)`;
        } else if (colorStyle === 'mono') {
            const l = 30 + (tile.dist % 200) / 200 * 25;
            ctx.fillStyle = `hsla(160, 50%, ${l}%, 0.75)`;
        } else { // glow
            const cx = verts.reduce((s,v) => s+v.x, 0) / verts.length;
            const cy = verts.reduce((s,v) => s+v.y, 0) / verts.length;
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 35);
            const h = tile.hue;
            grad.addColorStop(0, `hsla(${h}, 80%, 65%, 0.9)`);
            grad.addColorStop(1, `hsla(${h+40}, 60%, 30%, 0.5)`);
            ctx.fillStyle = grad;
        }
        ctx.fill();

        ctx.strokeStyle = `rgba(138, 255, 180, ${0.4 * tileAlpha})`;
        ctx.lineWidth = 1 / camZoom;
        ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();

    document.getElementById('tileCount').textContent = `Tiles: ${tiles.length} (0 reflected)`;

    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

window.reset = function() {
    camX = 0; camY = 0; camZoom = 1;
    colorStyle = 'rainbow';
    pulseEnabled = false;
    showCompare = false;
    document.getElementById('compare').style.display = 'none';
    tiles = generateSpectrePatch();
};
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
