<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>De Bruijn's Grid Method</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff;
    max-height: calc(100vh - 40px); overflow-y: auto;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
button.btn.active { background: rgba(80, 120, 255, 0.5); border-color: #8af; }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 4px; }
label input { accent-color: #8af; }
input[type="range"] { width: 100%; accent-color: #8af; margin: 2px 0; }
.section { border-top: 1px solid rgba(100,140,255,0.15); padding-top: 10px; margin-top: 10px; }
.section h4 { color: #8af; font-size: 0.85em; margin-bottom: 8px; }
.gamma-label { font-size: 0.8em; color: #8aa; margin-top: 2px; }
.gamma-row { margin-bottom: 6px; }
.info-text { font-size: 0.72em; color: #6a8a9a; margin-top: 10px; line-height: 1.5; border-top: 1px solid rgba(100,140,255,0.15); padding-top: 8px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>DE BRUIJN'S GRID METHOD</h3>
    <div class="ctrl-row"><span>Rhombuses:</span><span class="val" id="rhombCount">0</span></div>

    <div class="section">
        <h4>Display</h4>
        <div class="btn-row">
            <button class="btn" id="btnGrid">Grid</button>
            <button class="btn active" id="btnTiling">Tiling</button>
            <button class="btn" id="btnBoth">Both</button>
        </div>
    </div>

    <div class="section">
        <h4>Offsets (gamma)</h4>
        <div class="gamma-row">
            <div class="gamma-label">Family 1 (0deg): <span class="val" id="g0v">0.00</span></div>
            <input type="range" id="gamma0" min="-100" max="100" value="0" class="gamma-slider">
        </div>
        <div class="gamma-row">
            <div class="gamma-label">Family 2 (36deg): <span class="val" id="g1v">0.00</span></div>
            <input type="range" id="gamma1" min="-100" max="100" value="0" class="gamma-slider">
        </div>
        <div class="gamma-row">
            <div class="gamma-label">Family 3 (72deg): <span class="val" id="g2v">0.00</span></div>
            <input type="range" id="gamma2" min="-100" max="100" value="0" class="gamma-slider">
        </div>
        <div class="gamma-row">
            <div class="gamma-label">Family 4 (108deg): <span class="val" id="g3v">0.00</span></div>
            <input type="range" id="gamma3" min="-100" max="100" value="0" class="gamma-slider">
        </div>
        <div class="gamma-row">
            <div class="gamma-label">Family 5 (144deg): <span class="val" id="g4v">0.00</span></div>
            <input type="range" id="gamma4" min="-100" max="100" value="0" class="gamma-slider">
        </div>
    </div>

    <label><input type="checkbox" id="animateOffset"> Animate offset shift</label>
    <label><input type="checkbox" id="showColors" checked> Color by rhombus type</label>

    <div class="btn-row">
        <button class="btn" id="randomBtn">Random Offsets</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>

    <div class="info-text">
        De Bruijn proved Penrose tilings arise from 5 families of parallel lines at 36deg apart. Changing the offsets produces different Penrose tilings -- there are uncountably many!
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

const N_FAMILIES = 5;
const gammas = [0, 0, 0, 0, 0];
let displayMode = 'tiling';
let rhombuses = [];
let animatingOffset = false;
let animTime = 0;

// Camera
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, dragSX, dragSY, camSX, camSY;

// 5 family directions at 36-degree intervals
const dirs = [];
const normals = [];
for (let k = 0; k < N_FAMILIES; k++) {
    const angle = k * Math.PI / N_FAMILIES;
    dirs.push([Math.cos(angle), Math.sin(angle)]);
    normals.push([-Math.sin(angle), Math.cos(angle)]);
}

// Family colors
const familyColors = [
    'rgba(255, 80, 80, 0.4)',
    'rgba(80, 180, 255, 0.4)',
    'rgba(80, 255, 120, 0.4)',
    'rgba(255, 200, 60, 0.4)',
    'rgba(200, 80, 255, 0.4)'
];

const familyStroke = [
    'rgba(255, 80, 80, 0.7)',
    'rgba(80, 180, 255, 0.7)',
    'rgba(80, 255, 120, 0.7)',
    'rgba(255, 200, 60, 0.7)',
    'rgba(200, 80, 255, 0.7)'
];

// Rhombus type colors (thick vs thin)
const thickColor = 'rgba(40, 80, 180, 0.75)';
const thinColor = 'rgba(180, 50, 40, 0.75)';

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);

function computeGridIndex(k, point) {
    // For family k, compute which "strip" the point is in
    // The grid lines are: normal_k . point = n + gamma_k
    const d = normals[k][0] * point[0] + normals[k][1] * point[1];
    return Math.floor(d - gammas[k]);
}

function lineIntersection(k1, n1, k2, n2) {
    // Line k1: normal_k1 . p = n1 + gamma_k1
    // Line k2: normal_k2 . p = n2 + gamma_k2
    const nx1 = normals[k1][0], ny1 = normals[k1][1];
    const nx2 = normals[k2][0], ny2 = normals[k2][1];
    const det = nx1 * ny2 - nx2 * ny1;
    if (Math.abs(det) < 1e-10) return null;
    const c1 = n1 + gammas[k1];
    const c2 = n2 + gammas[k2];
    const x = (c1 * ny2 - c2 * ny1) / det;
    const y = (nx1 * c2 - nx2 * c1) / det;
    return [x, y];
}

function computeDualVertex(indices) {
    // The dual vertex corresponding to grid indices K[0..4]
    // is the sum of K[k] * e_k where e_k = direction of family k
    let x = 0, y = 0;
    for (let k = 0; k < N_FAMILIES; k++) {
        x += (indices[k] + 0.5 + gammas[k]) * dirs[k][0];
        y += (indices[k] + 0.5 + gammas[k]) * dirs[k][1];
    }
    return [x, y];
}

function generateRhombuses() {
    rhombuses = [];
    const range = 8; // number of lines per family
    const scale = 40; // visual scale for the dual

    // For each pair of families (k1, k2) and each intersection of their grid lines,
    // we get a rhombus in the dual
    for (let k1 = 0; k1 < N_FAMILIES; k1++) {
        for (let k2 = k1 + 1; k2 < N_FAMILIES; k2++) {
            for (let n1 = -range; n1 <= range; n1++) {
                for (let n2 = -range; n2 <= range; n2++) {
                    // Intersection point of line n1 of family k1 and line n2 of family k2
                    const pt = lineIntersection(k1, n1, k2, n2);
                    if (!pt) continue;

                    // Check if intersection is within reasonable bounds
                    if (Math.abs(pt[0]) > 15 || Math.abs(pt[1]) > 15) continue;

                    // Compute grid indices at this intersection
                    const indices = [];
                    let valid = true;
                    for (let k = 0; k < N_FAMILIES; k++) {
                        if (k === k1) {
                            indices.push(n1);
                        } else if (k === k2) {
                            indices.push(n2);
                        } else {
                            const d = normals[k][0] * pt[0] + normals[k][1] * pt[1];
                            const idx = Math.floor(d - gammas[k]);
                            if (Math.abs(idx) > range + 2) { valid = false; break; }
                            indices.push(idx);
                        }
                    }
                    if (!valid) continue;

                    // The four dual vertices of the rhombus
                    const i00 = indices.slice();
                    const i10 = indices.slice(); i10[k1]++;
                    const i01 = indices.slice(); i01[k2]++;
                    const i11 = indices.slice(); i11[k1]++; i11[k2]++;

                    const v00 = computeDualVertex(i00);
                    const v10 = computeDualVertex(i10);
                    const v01 = computeDualVertex(i01);
                    const v11 = computeDualVertex(i11);

                    // Determine thick vs thin
                    const angleDiff = Math.abs(k2 - k1);
                    const isThick = angleDiff === 1 || angleDiff === 4; // adjacent families

                    rhombuses.push({
                        verts: [
                            [v00[0] * scale, v00[1] * scale],
                            [v10[0] * scale, v10[1] * scale],
                            [v11[0] * scale, v11[1] * scale],
                            [v01[0] * scale, v01[1] * scale]
                        ],
                        k1, k2,
                        thick: isThick
                    });
                }
            }
        }
    }

    document.getElementById('rhombCount').textContent = rhombuses.length;
}

function drawGridLines(ox, oy, w, h) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(ox, oy, w, h);
    ctx.clip();

    const cx = ox + w / 2, cy = oy + h / 2;
    const range = 8;
    const lineScale = 40;

    for (let k = 0; k < N_FAMILIES; k++) {
        ctx.strokeStyle = familyStroke[k];
        ctx.lineWidth = 0.8;

        for (let n = -range; n <= range; n++) {
            // Line: normal_k . p = n + gamma_k
            // Parameterize as p = (n + gamma_k) * normal_k + t * dir_k
            const base_x = (n + gammas[k]) * normals[k][0];
            const base_y = (n + gammas[k]) * normals[k][1];

            const t = 20;
            const x1 = cx + (base_x - t * dirs[k][0]) * lineScale;
            const y1 = cy + (base_y - t * dirs[k][1]) * lineScale;
            const x2 = cx + (base_x + t * dirs[k][0]) * lineScale;
            const y2 = cy + (base_y + t * dirs[k][1]) * lineScale;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }

    // Label families
    ctx.font = '11px sans-serif';
    for (let k = 0; k < N_FAMILIES; k++) {
        ctx.fillStyle = familyStroke[k];
        const angle = k * 36;
        ctx.fillText(`Family ${k + 1} (${angle}\u00B0)`, ox + 10, oy + 20 + k * 16);
    }

    ctx.restore();
}

function drawTiling(ox, oy, w, h) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(ox, oy, w, h);
    ctx.clip();

    const cx = ox + w / 2 + camX;
    const cy = oy + h / 2 + camY;

    const showColors = document.getElementById('showColors').checked;

    for (const rhomb of rhombuses) {
        const [v0, v1, v2, v3] = rhomb.verts;

        ctx.beginPath();
        ctx.moveTo(cx + v0[0] * camZoom, cy + v0[1] * camZoom);
        ctx.lineTo(cx + v1[0] * camZoom, cy + v1[1] * camZoom);
        ctx.lineTo(cx + v2[0] * camZoom, cy + v2[1] * camZoom);
        ctx.lineTo(cx + v3[0] * camZoom, cy + v3[1] * camZoom);
        ctx.closePath();

        if (showColors) {
            if (rhomb.thick) {
                const hue = (rhomb.k1 * 72 + rhomb.k2 * 36) % 360;
                ctx.fillStyle = `hsla(${hue}, 60%, 35%, 0.85)`;
            } else {
                const hue = (rhomb.k1 * 72 + rhomb.k2 * 36 + 180) % 360;
                ctx.fillStyle = `hsla(${hue}, 50%, 25%, 0.85)`;
            }
        } else {
            ctx.fillStyle = rhomb.thick ? thickColor : thinColor;
        }
        ctx.fill();

        ctx.strokeStyle = 'rgba(138, 170, 255, 0.35)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
    }

    ctx.restore();
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    if (displayMode === 'grid') {
        drawGridLines(0, 0, W, H);
    } else if (displayMode === 'tiling') {
        drawTiling(0, 0, W, H);
    } else {
        const hw = Math.floor(W / 2);
        drawGridLines(0, 0, hw, H);
        drawTiling(hw, 0, W - hw, H);

        ctx.strokeStyle = 'rgba(100, 140, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(hw, 0);
        ctx.lineTo(hw, H);
        ctx.stroke();

        // Labels
        ctx.fillStyle = 'rgba(10, 14, 30, 0.7)';
        ctx.fillRect(0, H - 30, hw, 30);
        ctx.fillRect(hw, H - 30, W - hw, 30);
        ctx.fillStyle = '#8af';
        ctx.font = '12px sans-serif';
        ctx.fillText('Grid Lines (5 families at 36\u00B0)', 10, H - 10);
        ctx.fillText('Penrose Tiling (dual construction)', hw + 10, H - 10);
    }
}

let lastTime = 0;

function animate(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;

    if (document.getElementById('animateOffset').checked) {
        animTime += dt * 0.3;
        gammas[0] = Math.sin(animTime) * 0.3;
        updateSliders();
        generateRhombuses();
    }

    draw();
    requestAnimationFrame(animate);
}

function updateSliders() {
    for (let k = 0; k < N_FAMILIES; k++) {
        document.getElementById(`gamma${k}`).value = Math.round(gammas[k] * 100);
        document.getElementById(`g${k}v`).textContent = gammas[k].toFixed(2);
    }
}

// Slider events
for (let k = 0; k < N_FAMILIES; k++) {
    document.getElementById(`gamma${k}`).addEventListener('input', e => {
        gammas[k] = parseInt(e.target.value) / 100;
        document.getElementById(`g${k}v`).textContent = gammas[k].toFixed(2);
        generateRhombuses();
    });
}

// Mode buttons
['btnGrid', 'btnTiling', 'btnBoth'].forEach(id => {
    document.getElementById(id).addEventListener('click', () => {
        document.querySelectorAll('#controls .btn').forEach(b => b.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        const modes = { btnGrid: 'grid', btnTiling: 'tiling', btnBoth: 'both' };
        displayMode = modes[id];
    });
});

document.getElementById('randomBtn').addEventListener('click', () => {
    for (let k = 0; k < N_FAMILIES; k++) {
        gammas[k] = (Math.random() - 0.5) * 0.8;
    }
    updateSliders();
    generateRhombuses();
});

document.getElementById('resetBtn').addEventListener('click', () => {
    for (let k = 0; k < N_FAMILIES; k++) gammas[k] = 0;
    camX = camY = 0; camZoom = 1;
    updateSliders();
    generateRhombuses();
});

// Pan/zoom
canvas.addEventListener('mousedown', e => {
    dragging = true;
    dragSX = e.clientX; dragSY = e.clientY;
    camSX = camX; camSY = camY;
});
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX = camSX + (e.clientX - dragSX);
    camY = camSY + (e.clientY - dragSY);
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const f = e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.2, Math.min(10, camZoom * f));
}, { passive: false });

// Touch
let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        dragging = true;
        dragSX = e.touches[0].clientX; dragSY = e.touches[0].clientY;
        camSX = camX; camSY = camY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    }
    e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && dragging) {
        camX = camSX + (e.touches[0].clientX - dragSX);
        camY = camSY + (e.touches[0].clientY - dragSY);
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (lastTouchDist > 0) camZoom = Math.max(0.2, Math.min(10, camZoom * dist / lastTouchDist));
        lastTouchDist = dist;
    }
    e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

window.reset = function() {
    for (let k = 0; k < N_FAMILIES; k++) gammas[k] = 0;
    camX = camY = 0; camZoom = 1;
    displayMode = 'tiling';
    document.querySelectorAll('#controls .btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btnTiling').classList.add('active');
    updateSliders();
    generateRhombuses();
};

resize();
generateRhombuses();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>