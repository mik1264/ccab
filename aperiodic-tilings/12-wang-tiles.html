<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wang Tiles</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 6px; }
label input { accent-color: #8af; }
input[type="range"] { width: 100%; accent-color: #8af; margin: 4px 0; }
.info-text { font-size: 0.72em; color: #6a8a9a; margin-top: 10px; line-height: 1.5; border-top: 1px solid rgba(100,140,255,0.15); padding-top: 8px; }
#tileSet {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 12px;
}
#tileSet h4 { color: #8af; font-size: 0.8em; margin-bottom: 8px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>WANG TILES</h3>
    <div class="ctrl-row"><span>Tiles Placed:</span><span class="val" id="placedVal">0</span></div>
    <div class="ctrl-row"><span>Backtracks:</span><span class="val" id="backtrackVal">0</span></div>
    <div class="ctrl-row"><span>Grid Size:</span><span class="val" id="gridVal">30x30</span></div>
    <div class="ctrl-row"><span>Speed:</span></div>
    <input type="range" id="speedSlider" min="1" max="200" value="20">
    <div class="btn-row">
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <label><input type="checkbox" id="showEdges" checked> Show edge colors</label>
    <label><input type="checkbox" id="showGrid"> Show grid lines</label>
    <div class="info-text">
        Wang tiles are unit squares with colored edges. Adjacent tiles must have matching colors. Some tile sets can ONLY tile the plane aperiodically -- this is connected to the Halting Problem!
    </div>
</div>
<div id="tileSet">
    <h4>Tile Set (13 tiles, 5 colors)</h4>
    <canvas id="tileCanvas" width="280" height="80"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tileCanvas = document.getElementById('tileCanvas');
const tileCtx = tileCanvas.getContext('2d');

let W, H;
// Wang tile: [top, right, bottom, left] - edge colors
// An aperiodic set of 13 tiles with 5 colors (Kari's simplified set)
const COLORS = ['#ff4466', '#44bbff', '#66ff88', '#ffaa33', '#cc66ff'];
const COLOR_NAMES = ['red', 'blue', 'green', 'orange', 'purple'];

// 13-tile aperiodic set (simplified Kari-Culik style)
// Each tile: [top, right, bottom, left]
const TILE_SET = [
    [0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0],
    [0, 2, 1, 4], [1, 3, 0, 4], [2, 0, 3, 4], [4, 1, 4, 0],
    [3, 4, 2, 1], [4, 3, 4, 2], [0, 4, 1, 3], [2, 1, 4, 3],
    [4, 0, 3, 1]
];

const TILE_FILLS = [];
for (let i = 0; i < TILE_SET.length; i++) {
    const h = (i / TILE_SET.length) * 360;
    TILE_FILLS.push(`hsla(${h}, 40%, 25%, 0.9)`);
}

let GRID_W = 40, GRID_H = 30;
let grid = []; // grid[y][x] = tile index or -1
let cellSize;
let placing = false;
let paused = false;
let placeQueue = [];
let currentX = 0, currentY = 0;
let placedCount = 0;
let backtrackCount = 0;
let failCell = null;
let failTimer = 0;
let speed = 20;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cellSize = Math.min(Math.floor((W - 40) / GRID_W), Math.floor((H - 40) / GRID_H), 28);
    draw();
}
window.addEventListener('resize', resize);

function initGrid() {
    grid = [];
    for (let y = 0; y < GRID_H; y++) {
        grid.push(new Array(GRID_W).fill(-1));
    }
    currentX = 0;
    currentY = 0;
    placedCount = 0;
    backtrackCount = 0;
    failCell = null;
    placing = false;
    paused = false;
    updateStats();
}

function getValidTiles(x, y) {
    const valid = [];
    for (let i = 0; i < TILE_SET.length; i++) {
        const tile = TILE_SET[i];
        let ok = true;
        // Check top neighbor
        if (y > 0 && grid[y-1][x] >= 0) {
            const neighbor = TILE_SET[grid[y-1][x]];
            if (tile[0] !== neighbor[2]) ok = false; // my top must match neighbor's bottom
        }
        // Check left neighbor
        if (x > 0 && grid[y][x-1] >= 0) {
            const neighbor = TILE_SET[grid[y][x-1]];
            if (tile[3] !== neighbor[1]) ok = false; // my left must match neighbor's right
        }
        // Check bottom neighbor
        if (y < GRID_H - 1 && grid[y+1][x] >= 0) {
            const neighbor = TILE_SET[grid[y+1][x]];
            if (tile[2] !== neighbor[0]) ok = false;
        }
        // Check right neighbor
        if (x < GRID_W - 1 && grid[y][x+1] >= 0) {
            const neighbor = TILE_SET[grid[y][x+1]];
            if (tile[1] !== neighbor[3]) ok = false;
        }
        if (ok) valid.push(i);
    }
    return valid;
}

// Stack for backtracking
let stack = [];

function stepPlace() {
    if (currentY >= GRID_H) {
        placing = false;
        return;
    }

    const valid = getValidTiles(currentX, currentY);

    if (valid.length === 0) {
        // Backtrack
        failCell = { x: currentX, y: currentY };
        failTimer = 0.3;
        backtrackCount++;

        if (stack.length === 0) {
            // Total failure - restart
            initGrid();
            return;
        }

        const prev = stack.pop();
        grid[prev.y][prev.x] = -1;
        placedCount--;
        currentX = prev.x;
        currentY = prev.y;

        // Remove the previously chosen tile from options
        prev.remaining.splice(prev.remaining.indexOf(prev.chosen), 1);
        if (prev.remaining.length > 0) {
            const choice = prev.remaining[Math.floor(Math.random() * prev.remaining.length)];
            grid[currentY][currentX] = choice;
            stack.push({ x: currentX, y: currentY, chosen: choice, remaining: prev.remaining.slice() });
            placedCount++;
            advanceCursor();
        }
        // If no remaining, we'll backtrack again on next step
    } else {
        // Place a random valid tile
        const choice = valid[Math.floor(Math.random() * valid.length)];
        grid[currentY][currentX] = choice;
        stack.push({ x: currentX, y: currentY, chosen: choice, remaining: valid.slice() });
        placedCount++;
        advanceCursor();
    }

    updateStats();
}

function advanceCursor() {
    currentX++;
    if (currentX >= GRID_W) {
        currentX = 0;
        currentY++;
    }
}

function updateStats() {
    document.getElementById('placedVal').textContent = placedCount;
    document.getElementById('backtrackVal').textContent = backtrackCount;
    document.getElementById('gridVal').textContent = `${GRID_W}x${GRID_H}`;
}

function drawTile(context, x, y, size, tileIdx, showEdgeColors) {
    const tile = TILE_SET[tileIdx];

    // Fill interior
    context.fillStyle = TILE_FILLS[tileIdx];
    context.fillRect(x, y, size, size);

    if (showEdgeColors) {
        const s = size;
        const m = s * 0.2;

        // Top edge triangle
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo(x + s, y);
        context.lineTo(x + s/2, y + m);
        context.closePath();
        context.fillStyle = COLORS[tile[0]];
        context.fill();

        // Right edge triangle
        context.beginPath();
        context.moveTo(x + s, y);
        context.lineTo(x + s, y + s);
        context.lineTo(x + s - m, y + s/2);
        context.closePath();
        context.fillStyle = COLORS[tile[1]];
        context.fill();

        // Bottom edge triangle
        context.beginPath();
        context.moveTo(x, y + s);
        context.lineTo(x + s, y + s);
        context.lineTo(x + s/2, y + s - m);
        context.closePath();
        context.fillStyle = COLORS[tile[2]];
        context.fill();

        // Left edge triangle
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo(x, y + s);
        context.lineTo(x + m, y + s/2);
        context.closePath();
        context.fillStyle = COLORS[tile[3]];
        context.fill();
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const offsetX = (W - GRID_W * cellSize) / 2;
    const offsetY = (H - GRID_H * cellSize) / 2;
    const showEdges = document.getElementById('showEdges').checked;
    const showGrid = document.getElementById('showGrid').checked;

    for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
            const px = offsetX + x * cellSize;
            const py = offsetY + y * cellSize;

            if (grid[y][x] >= 0) {
                drawTile(ctx, px, py, cellSize, grid[y][x], showEdges);
            }

            if (showGrid) {
                ctx.strokeStyle = 'rgba(100,140,255,0.1)';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(px, py, cellSize, cellSize);
            }
        }
    }

    // Highlight current placement position
    if (placing && currentY < GRID_H) {
        const px = offsetX + currentX * cellSize;
        const py = offsetY + currentY * cellSize;
        ctx.strokeStyle = '#8af';
        ctx.lineWidth = 2;
        ctx.strokeRect(px - 1, py - 1, cellSize + 2, cellSize + 2);
    }

    // Highlight fail cell
    if (failCell && failTimer > 0) {
        const px = offsetX + failCell.x * cellSize;
        const py = offsetY + failCell.y * cellSize;
        ctx.fillStyle = `rgba(255, 40, 40, ${failTimer})`;
        ctx.fillRect(px, py, cellSize, cellSize);
    }
}

function drawTileSet() {
    const tc = tileCtx;
    tc.clearRect(0, 0, tileCanvas.width, tileCanvas.height);
    const s = 18;
    const gap = 3;
    const cols = 7;

    for (let i = 0; i < TILE_SET.length; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = col * (s + gap) + 4;
        const y = row * (s + gap) + 4;
        drawTile(tc, x, y, s, i, true);
        tc.strokeStyle = 'rgba(100,140,255,0.3)';
        tc.lineWidth = 0.5;
        tc.strokeRect(x, y, s, s);
    }
}

let lastTime = 0;
let stepAccum = 0;

function animate(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;

    if (failTimer > 0) failTimer -= dt * 3;

    if (placing && !paused) {
        speed = parseInt(document.getElementById('speedSlider').value);
        stepAccum += dt * speed;
        while (stepAccum >= 1 && placing) {
            stepPlace();
            stepAccum -= 1;
        }
    }

    draw();
    requestAnimationFrame(animate);
}

document.getElementById('startBtn').addEventListener('click', () => {
    if (!placing) {
        initGrid();
        stack = [];
    }
    placing = true;
    paused = false;
});
document.getElementById('pauseBtn').addEventListener('click', () => {
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
});
document.getElementById('resetBtn').addEventListener('click', () => {
    initGrid();
    stack = [];
});

window.reset = function() {
    initGrid();
    stack = [];
};

resize();
initGrid();
drawTileSet();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>