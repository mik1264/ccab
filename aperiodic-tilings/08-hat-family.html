<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Hat Family Continuum</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 200, 100, 0.2); border-radius: 12px;
    padding: 18px; color: #ffe0b0; min-width: 280px;
}
#controls h3 { color: #fc8; margin-bottom: 10px; font-size: 1em; }
#controls p { font-size: 0.78em; line-height: 1.5; margin-bottom: 8px; color: #ba9; }
.slider-row { margin: 10px 0; }
.slider-row label { font-size: 0.8em; color: #fc8; display: block; margin-bottom: 4px; }
.slider-row input[type="range"] {
    width: 100%; -webkit-appearance: none; height: 6px;
    background: linear-gradient(90deg, #f84, #fc8, #8f4);
    border-radius: 3px; outline: none;
}
.slider-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 18px; height: 18px;
    background: #fc8; border-radius: 50%; cursor: pointer;
    border: 2px solid #0a0e1a;
}
#paramDisplay { font-size: 1.1em; color: #fc8; font-weight: bold; text-align: center; margin: 6px 0; }
.btn-row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
.btn {
    padding: 6px 12px; border: 1px solid rgba(255,200,100,0.3);
    background: rgba(255,200,100,0.1); color: #fc8; border-radius: 6px;
    cursor: pointer; font-size: 0.8em; transition: all 0.2s;
}
.btn:hover { background: rgba(255,200,100,0.25); }
.btn.active { background: rgba(255,200,100,0.35); border-color: #fc8; }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 200, 100, 0.2); border-radius: 12px;
    padding: 16px; color: #ba9; font-size: 0.75em; max-width: 270px; line-height: 1.5;
}
#info strong { color: #fc8; }
.liminal-marker {
    position: absolute; top: -18px; font-size: 0.65em; color: #f84;
    transform: translateX(-50%); white-space: nowrap;
}
#sliderContainer { position: relative; margin-top: 20px; }
#tileInset {
    position: fixed; top: 70px; left: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.9); backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 200, 100, 0.2); border-radius: 12px;
    padding: 8px;
}
#tileInset canvas { border-radius: 8px; }
#tileName { color: #fc8; font-size: 0.8em; text-align: center; margin-top: 4px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#fc8;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>

<div id="tileInset">
    <canvas id="insetCanvas" width="150" height="150"></canvas>
    <div id="tileName">Hat (a = 1.73)</div>
</div>

<div id="info">
    <strong>The Hat Family</strong><br>
    The Hat is one member of a continuous family of aperiodic monotiles parameterized by edge length ratio <strong>a</strong>.<br><br>
    <strong style="color:#f84">a = 0</strong>: Chevron shape<br>
    <strong style="color:#fc8">a = sqrt(3)</strong>: The Hat<br>
    <strong style="color:#8f4">a = 3</strong>: Comet shape<br><br>
    At exactly <strong style="color:#f44">a = 0</strong> and <strong style="color:#f44">a = sqrt(3)*2</strong>, the tile can tile periodically (liminal cases).
</div>

<div id="controls">
    <h3>Hat Family Continuum</h3>
    <p>Morph between tile shapes. The parameter controls edge length ratios.</p>
    <div id="sliderContainer">
        <div class="slider-row">
            <label>Parameter a: <span id="paramDisplay">1.73</span></label>
            <input type="range" id="paramSlider" min="0" max="3" step="0.01" value="1.73">
        </div>
    </div>
    <div class="btn-row">
        <button class="btn" onclick="toggleAnimate()" id="btnAnimate">Auto-Oscillate</button>
        <button class="btn" onclick="setParam(0)" >Chevron</button>
        <button class="btn" onclick="setParam(1.732)">Hat</button>
        <button class="btn" onclick="setParam(3)">Comet</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const S3 = Math.sqrt(3);
let param = S3; // sqrt(3) = Hat
let animating = false;

// Generate hat-family tile shape based on parameter 'a'
// The hat family interpolates between different shapes by adjusting certain edge lengths
// 'a' controls the ratio of two edge types: type-a edges and type-b edges
// When a=sqrt(3), it's the Hat. When a=0, Chevron. When a large, Comet-like.
function getHatFamilyVerts(a) {
    // The hat-family tile is built on a hex grid where some edges have length 'a'
    // and others have length 'b' = sqrt(3). We parameterize as a ratio.
    const b = 1;
    const s = a / S3; // normalized parameter

    // Interpolate vertices between the known shapes
    // Base hat vertices at a=sqrt(3) (s=1)
    const hat = [
        {x: 0, y: 0}, {x: 1, y: 0}, {x: 1.5, y: S3/2},
        {x: 1, y: S3}, {x: 1.5, y: 3*S3/2}, {x: 1, y: 2*S3},
        {x: 0, y: 2*S3}, {x: -0.5, y: 3*S3/2}, {x: 0, y: S3},
        {x: -0.5, y: S3/2}, {x: -1, y: S3}, {x: -1.5, y: S3/2},
        {x: -1, y: 0}
    ];

    // Chevron-like at a=0 (s=0): vertices collapse inward
    const chevron = [
        {x: 0, y: 0}, {x: 0.5, y: 0}, {x: 1.0, y: S3/3},
        {x: 0.5, y: 2*S3/3}, {x: 1.0, y: S3}, {x: 0.5, y: 4*S3/3},
        {x: 0, y: 4*S3/3}, {x: -0.5, y: S3}, {x: 0, y: 2*S3/3},
        {x: -0.5, y: S3/3}, {x: -0.5, y: 2*S3/3}, {x: -1, y: S3/3},
        {x: -0.5, y: 0}
    ];

    // Comet-like at a=3 (s=sqrt(3)): vertices extend outward
    const comet = [
        {x: 0, y: 0}, {x: 1.8, y: 0}, {x: 2.2, y: S3*0.8},
        {x: 1.5, y: S3*1.3}, {x: 2.0, y: S3*2}, {x: 1.3, y: S3*2.5},
        {x: 0, y: S3*2.5}, {x: -0.7, y: S3*2}, {x: 0, y: S3*1.3},
        {x: -0.7, y: S3*0.8}, {x: -1.5, y: S3*1.3}, {x: -2.2, y: S3*0.8},
        {x: -1.8, y: 0}
    ];

    // Interpolate based on parameter
    return hat.map((v, i) => {
        let target;
        if (s <= 1) {
            // Interpolate chevron -> hat
            target = {
                x: chevron[i].x + (hat[i].x - chevron[i].x) * s,
                y: chevron[i].y + (hat[i].y - chevron[i].y) * s
            };
        } else {
            // Interpolate hat -> comet
            const t = (s - 1) / (S3 - 1);
            target = {
                x: hat[i].x + (comet[i].x - hat[i].x) * Math.min(1, t),
                y: hat[i].y + (comet[i].y - hat[i].y) * Math.min(1, t)
            };
        }
        return target;
    });
}

function transformVerts(verts, angle, tx, ty, scale) {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    return verts.map(v => ({
        x: v.x * scale * cos - v.y * scale * sin + tx,
        y: v.x * scale * sin + v.y * scale * cos + ty
    }));
}

function generateTiling(baseVerts) {
    const tiles = [];
    const scale = 28;
    const rings = 6;

    for (let ring = 0; ring <= rings; ring++) {
        for (let i = -ring; i <= ring; i++) {
            for (let j = -ring; j <= ring; j++) {
                if (ring > 0 && Math.abs(i) !== ring && Math.abs(j) !== ring) continue;

                const cx = i * 3 * scale + j * 1.5 * scale;
                const cy = j * S3 * 1.5 * scale;
                const rot = ((i * 2 + j * 3) % 6 + 6) % 6;
                const angle = rot * Math.PI / 3;

                const placement = {x: cx, y: cy, angle};
                tiles.push(placement);

                if ((i + j) % 2 === 0) {
                    tiles.push({
                        x: cx + 2.2*scale*Math.cos(angle+Math.PI/6),
                        y: cy + 2.2*scale*Math.sin(angle+Math.PI/6),
                        angle: angle + Math.PI/3
                    });
                }
                if ((i - j) % 3 === 0) {
                    tiles.push({
                        x: cx + 2.5*scale*Math.cos(angle-Math.PI/3),
                        y: cy + 2.5*scale*Math.sin(angle-Math.PI/3),
                        angle: angle + 2*Math.PI/3
                    });
                }
            }
        }
    }

    // Remove overlapping
    const used = [];
    const result = [];
    for (const p of tiles) {
        let overlap = false;
        for (const u of used) {
            const dx = p.x - u.x, dy = p.y - u.y;
            if (dx*dx + dy*dy < (scale*1.8)*(scale*1.8)) { overlap = true; break; }
        }
        if (!overlap) {
            const verts = transformVerts(baseVerts, p.angle, p.x, p.y, scale);
            const dist = Math.sqrt(p.x*p.x + p.y*p.y);
            result.push({ verts, angle: p.angle, dist, hue: (p.angle/(2*Math.PI)*360 + dist*0.2) % 360 });
            used.push(p);
        }
    }
    return result;
}

let tiles = generateTiling(getHatFamilyVerts(param));
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, lastMx = 0, lastMy = 0;

canvas.addEventListener('mousedown', e => { dragging = true; lastMx = e.clientX; lastMy = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX += (e.clientX - lastMx) / camZoom;
    camY += (e.clientY - lastMy) / camZoom;
    lastMx = e.clientX; lastMy = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camZoom *= e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.1, Math.min(5, camZoom));
}, {passive: false});

let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) { dragging = true; lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY; }
    else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
    }
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && dragging) {
        camX += (e.touches[0].clientX - lastMx) / camZoom;
        camY += (e.touches[0].clientY - lastMy) / camZoom;
        lastMx = e.touches[0].clientX; lastMy = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist > 0) camZoom *= dist / lastTouchDist;
        camZoom = Math.max(0.1, Math.min(5, camZoom));
        lastTouchDist = dist;
    }
}, {passive: false});
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

const slider = document.getElementById('paramSlider');
slider.addEventListener('input', () => {
    param = parseFloat(slider.value);
    updateTiling();
});

function setParam(val) {
    param = val;
    slider.value = val;
    updateTiling();
}

function updateTiling() {
    const verts = getHatFamilyVerts(param);
    tiles = generateTiling(verts);
    document.getElementById('paramDisplay').textContent = param.toFixed(2);

    // Update tile name
    let name = 'Intermediate';
    if (Math.abs(param) < 0.05) name = 'Chevron (liminal)';
    else if (Math.abs(param - S3) < 0.05) name = 'The Hat';
    else if (Math.abs(param - 2*S3) < 0.1) name = 'Liminal';
    else if (param > 2.8) name = 'Comet-like';
    document.getElementById('tileName').textContent = `${name} (a = ${param.toFixed(2)})`;

    drawInset();
}

function toggleAnimate() {
    animating = !animating;
    document.getElementById('btnAnimate').classList.toggle('active');
}

function drawInset() {
    const ic = document.getElementById('insetCanvas');
    const c2 = ic.getContext('2d');
    c2.clearRect(0, 0, 150, 150);
    c2.fillStyle = '#0a0e1a';
    c2.fillRect(0, 0, 150, 150);

    const verts = getHatFamilyVerts(param);
    const tv = transformVerts(verts, 0, 75, 75, 18);

    c2.beginPath();
    c2.moveTo(tv[0].x, tv[0].y);
    for (let i = 1; i < tv.length; i++) c2.lineTo(tv[i].x, tv[i].y);
    c2.closePath();

    // Color based on parameter
    const hue = param / 3 * 120;
    c2.fillStyle = `hsla(${hue}, 60%, 45%, 0.6)`;
    c2.fill();
    c2.strokeStyle = `hsl(${hue}, 80%, 65%)`;
    c2.lineWidth = 2;
    c2.stroke();

    // Draw vertices
    for (const v of tv) {
        c2.beginPath();
        c2.arc(v.x, v.y, 2, 0, Math.PI * 2);
        c2.fillStyle = '#fc8';
        c2.fill();
    }
}

drawInset();

function draw(time) {
    ctx.clearRect(0, 0, W, H);

    const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
    bgGrad.addColorStop(0, '#14100a');
    bgGrad.addColorStop(1, '#080604');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // Auto-oscillate
    if (animating) {
        param = 1.5 + 1.5 * Math.sin(time * 0.0005);
        slider.value = param;
        updateTiling();
    }

    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(camZoom, camZoom);
    ctx.translate(camX, camY);

    const hue = param / 3 * 120;

    for (const tile of tiles) {
        const verts = tile.verts;
        ctx.beginPath();
        ctx.moveTo(verts[0].x, verts[0].y);
        for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i].x, verts[i].y);
        ctx.closePath();

        const tHue = (hue + tile.hue * 0.3) % 360;
        const cx = verts.reduce((s,v) => s+v.x, 0) / verts.length;
        const cy = verts.reduce((s,v) => s+v.y, 0) / verts.length;
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 35);
        grad.addColorStop(0, `hsla(${tHue}, 65%, 55%, 0.8)`);
        grad.addColorStop(1, `hsla(${tHue+20}, 55%, 30%, 0.5)`);
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.strokeStyle = `hsla(${hue}, 70%, 65%, 0.4)`;
        ctx.lineWidth = 1 / camZoom;
        ctx.stroke();
    }

    ctx.restore();

    // Draw liminal markers on slider track
    const isLiminal = Math.abs(param) < 0.05 || Math.abs(param - 2*S3) < 0.1;
    if (isLiminal) {
        ctx.fillStyle = 'rgba(255, 80, 80, 0.3)';
        ctx.fillRect(0, 0, W, H);
        ctx.font = '14px sans-serif';
        ctx.fillStyle = '#f84';
        ctx.textAlign = 'center';
        ctx.fillText('LIMINAL VALUE - Periodic tiling possible!', W/2, 40);
    }

    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

window.reset = function() {
    camX = 0; camY = 0; camZoom = 1;
    param = S3;
    slider.value = S3;
    animating = false;
    document.getElementById('btnAnimate').classList.remove('active');
    updateTiling();
};
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
