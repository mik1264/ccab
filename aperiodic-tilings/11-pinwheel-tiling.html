<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pinwheel Tiling</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 240px; color: #c8d8ff;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 6px; }
label input { accent-color: #8af; }
input[type="range"] { width: 100%; accent-color: #8af; }
#histogram {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 12px;
}
#histogram h4 { color: #8af; font-size: 0.8em; margin-bottom: 6px; text-align: center; }
.info-text { font-size: 0.75em; color: #6a8a9a; margin-top: 8px; line-height: 1.4; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>PINWHEEL TILING</h3>
    <div class="ctrl-row"><span>Subdivision Level:</span><span class="val" id="levelVal">0</span></div>
    <div class="ctrl-row"><span>Triangles:</span><span class="val" id="triCount">1</span></div>
    <div class="ctrl-row"><span>Unique Angles:</span><span class="val" id="angleCount">0</span></div>
    <div class="btn-row">
        <button class="btn" id="subdivBtn">Subdivide +</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <label><input type="checkbox" id="autoAnimate"> Auto-animate subdivision</label>
    <label><input type="checkbox" id="showOutlines" checked> Show outlines</label>
    <label><input type="checkbox" id="groupMode"> Group into larger shapes</label>
    <div class="info-text">
        Unlike Penrose tilings (10 orientations), pinwheel tiles appear in infinitely many orientations. Each subdivision rotates some tiles by arctan(1/2).
    </div>
</div>
<div id="histogram">
    <h4>Orientation Distribution</h4>
    <canvas id="histCanvas" width="220" height="100"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');

let W, H;
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, dragSX, dragSY, camSX, camSY;
let triangles = [];
let level = 0;
let animating = false;
let animLevel = 0;
let animProgress = 0;
let prevTriangles = [];
let nextTriangles = [];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    draw();
}
window.addEventListener('resize', resize);

// A pinwheel triangle has vertices A, B, C where
// AB = 1 (short leg), AC = 2 (long leg), BC = sqrt(5) (hypotenuse)
// The right angle is at A.

function subdivide(tris) {
    const result = [];
    for (const tri of tris) {
        const [A, B, C] = tri.verts; // right angle at A, AB=short, AC=long
        // Lengths: AB = 1 unit, AC = 2 units, BC = sqrt(5)
        // We need 5 sub-triangles
        // Key points:
        const dx_AB = B[0] - A[0], dy_AB = B[1] - A[1];
        const dx_AC = C[0] - A[0], dy_AC = C[1] - A[1];
        const dx_BC = C[0] - B[0], dy_BC = C[1] - B[1];

        // M = midpoint of AC (long leg)
        const M = [(A[0] + C[0]) / 2, (A[1] + C[1]) / 2];
        // P = point on BC such that BP/BC = 1/sqrt(5), i.e., BP = 1
        // Actually for proper pinwheel: P divides BC at ratio 2/sqrt(5) from B
        const t1 = 2 / 5; // BP/BC = 2/sqrt(5) * 1/sqrt(5) = 2/5
        const P = [B[0] + dx_BC * t1, B[1] + dy_BC * t1];
        // Q = point on BC such that BQ/BC = 4/5
        const t2 = 4 / 5;
        const Q = [B[0] + dx_BC * t2, B[1] + dy_BC * t2];
        // R = foot of perpendicular from A to BC
        const dot = (-dx_BC * (B[0] - A[0]) + -dy_BC * (B[1] - A[1])) / (dx_BC * dx_BC + dy_BC * dy_BC);
        const foot = [B[0] + dx_BC * (-dot), B[1] + dy_BC * (-dot)];
        // Actually let me use exact pinwheel subdivision
        // Standard pinwheel: triangle with legs 1 and 2
        // Sub-triangles (using Conway-Radin decomposition):

        // Let me use a cleaner parameterization
        // E = point on hyp at distance 2/sqrt(5) from B along BC direction
        // F = projection of A onto BC

        // Projection of A onto line BC
        const BAx = A[0] - B[0], BAy = A[1] - B[1];
        const BCx = dx_BC, BCy = dy_BC;
        const BClen2 = BCx * BCx + BCy * BCy;
        const projT = (BAx * BCx + BAy * BCy) / BClen2;
        const F = [B[0] + BCx * projT, B[1] + BCy * projT]; // foot of altitude from A

        // 5 sub-triangles of the pinwheel:
        // Triangle 1: (A, B, F) - right angle at F
        // But we need to orient them as pinwheel triangles (short:long = 1:2)
        // Actually the correct Conway-Radin subdivision:

        // Using the standard decomposition from the paper:
        // Given right triangle with vertices at right angle R, short leg end S, long leg end L
        // Short leg RS = s, Long leg RL = 2s, Hypotenuse SL = s*sqrt(5)

        // Midpoint of long leg
        const ML = M; // midpoint of AC
        // Point on hyp at 2/5 from short-leg vertex
        const E = [B[0] + dx_BC * (2/5), B[1] + dy_BC * (2/5)];
        // Point on hyp at 1/5 from long-leg vertex
        const G = [B[0] + dx_BC * (4/5), B[1] + dy_BC * (4/5)];

        // The 5 sub-triangles (each similar to original with scale 1/sqrt(5)):
        // Using right-angle vertex, then short leg end, then long leg end
        const orient = tri.orient || 1;

        result.push({ verts: [F, B, A], orient: orient });
        result.push({ verts: [F, A, ML], orient: -orient });
        result.push({ verts: [E, F, ML], orient: orient });
        result.push({ verts: [E, ML, C], orient: -orient });
        result.push({ verts: [E, B, F], orient: -orient });
    }
    return result;
}

function getAngle(tri) {
    const [A, B, C] = tri.verts;
    const dx = B[0] - A[0], dy = B[1] - A[1];
    let a = Math.atan2(dy, dx);
    if (a < 0) a += Math.PI * 2;
    return a;
}

function initTriangle() {
    const s = Math.min(W, H) * 0.35;
    const cx = 0, cy = 0;
    // Right angle at A, short leg AB=s, long leg AC=2s
    const A = [cx - s, cy + s * 0.5];
    const B = [cx - s, cy - s * 0.5];
    const C = [cx + s, cy + s * 0.5];
    triangles = [{ verts: [A, B, C], orient: 1 }];
    level = 0;
    updateStats();
}

function doSubdivide() {
    if (level >= 7) return;
    prevTriangles = triangles.slice();
    triangles = subdivide(triangles);
    level++;
    animProgress = 0;
    animating = true;
    animLevel = level;
    updateStats();
}

function updateStats() {
    document.getElementById('levelVal').textContent = level;
    document.getElementById('triCount').textContent = triangles.length;
    const angles = new Set();
    triangles.forEach(t => {
        angles.add(Math.round(getAngle(t) * 1000) / 1000);
    });
    document.getElementById('angleCount').textContent = angles.size;
    drawHistogram();
}

function drawHistogram() {
    const hw = histCanvas.width, hh = histCanvas.height;
    histCtx.clearRect(0, 0, hw, hh);

    const bins = 36;
    const counts = new Array(bins).fill(0);
    triangles.forEach(t => {
        const a = getAngle(t);
        const bin = Math.floor((a / (Math.PI * 2)) * bins) % bins;
        counts[bin]++;
    });

    const maxCount = Math.max(...counts, 1);
    const barW = hw / bins;

    for (let i = 0; i < bins; i++) {
        const h = (counts[i] / maxCount) * (hh - 15);
        const hue = (i / bins) * 360;
        histCtx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
        histCtx.fillRect(i * barW, hh - h, barW - 1, h);
    }

    histCtx.fillStyle = '#6a8a9a';
    histCtx.font = '9px sans-serif';
    histCtx.fillText('0°', 0, 10);
    histCtx.fillText('180°', hw / 2 - 10, 10);
    histCtx.fillText('360°', hw - 20, 10);
}

function draw() {
    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.translate(W / 2 + camX, H / 2 + camY);
    ctx.scale(camZoom, camZoom);

    const showOutlines = document.getElementById('showOutlines').checked;
    const groupMode = document.getElementById('groupMode').checked;

    const toDraw = animating ? lerpTriangles(prevTriangles, triangles, Math.min(animProgress, 1)) : triangles;

    for (let i = 0; i < toDraw.length; i++) {
        const tri = toDraw[i];
        const [A, B, C] = tri.verts;
        const angle = getAngle(tri);
        const hue = (angle / (Math.PI * 2)) * 360;

        ctx.beginPath();
        ctx.moveTo(A[0], A[1]);
        ctx.lineTo(B[0], B[1]);
        ctx.lineTo(C[0], C[1]);
        ctx.closePath();

        if (groupMode && i % 5 < 3) {
            ctx.fillStyle = `hsla(${hue}, 60%, 35%, 0.85)`;
        } else {
            ctx.fillStyle = `hsla(${hue}, 70%, 45%, 0.85)`;
        }
        ctx.fill();

        if (showOutlines) {
            ctx.strokeStyle = `hsla(${hue}, 80%, 70%, 0.5)`;
            ctx.lineWidth = 0.5 / camZoom;
            ctx.stroke();
        }
    }

    ctx.restore();
}

function lerpTriangles(prev, next, t) {
    if (t >= 1) return next;
    // Fade in the new triangles with scale
    const result = [];
    for (const tri of next) {
        const [A, B, C] = tri.verts;
        const cx = (A[0] + B[0] + C[0]) / 3;
        const cy = (A[1] + B[1] + C[1]) / 3;
        const s = 0.3 + 0.7 * t;
        result.push({
            verts: [
                [cx + (A[0] - cx) * s, cy + (A[1] - cy) * s],
                [cx + (B[0] - cx) * s, cy + (B[1] - cy) * s],
                [cx + (C[0] - cx) * s, cy + (C[1] - cy) * s]
            ],
            orient: tri.orient
        });
    }
    return result;
}

let lastTime = 0;
let autoTimer = 0;

function animate(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;

    if (animating) {
        animProgress += dt * 2;
        if (animProgress >= 1) {
            animating = false;
            animProgress = 1;
        }
    }

    if (document.getElementById('autoAnimate').checked && !animating && level < 7) {
        autoTimer += dt;
        if (autoTimer > 1.5) {
            autoTimer = 0;
            doSubdivide();
        }
    }

    draw();
    requestAnimationFrame(animate);
}

// Pan and zoom
canvas.addEventListener('mousedown', e => {
    dragging = true;
    dragSX = e.clientX; dragSY = e.clientY;
    camSX = camX; camSY = camY;
});
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX = camSX + (e.clientX - dragSX);
    camY = camSY + (e.clientY - dragSY);
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    camZoom *= factor;
    camZoom = Math.max(0.1, Math.min(50, camZoom));
}, { passive: false });

// Touch support
let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        dragging = true;
        dragSX = e.touches[0].clientX; dragSY = e.touches[0].clientY;
        camSX = camX; camSY = camY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    }
    e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && dragging) {
        camX = camSX + (e.touches[0].clientX - dragSX);
        camY = camSY + (e.touches[0].clientY - dragSY);
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (lastTouchDist > 0) {
            camZoom *= dist / lastTouchDist;
            camZoom = Math.max(0.1, Math.min(50, camZoom));
        }
        lastTouchDist = dist;
    }
    e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

document.getElementById('subdivBtn').addEventListener('click', doSubdivide);
document.getElementById('resetBtn').addEventListener('click', () => {
    camX = camY = 0; camZoom = 1;
    initTriangle();
    autoTimer = 0;
});

window.reset = function() {
    camX = camY = 0; camZoom = 1;
    initTriangle();
    autoTimer = 0;
};

resize();
initTriangle();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>