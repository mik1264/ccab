<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phason Flips - Rearranging Penrose Tilings</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 240px; color: #c8d8ff;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
input[type="range"] { width: 100%; accent-color: #8af; margin-top: 4px; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
.btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
.info {
    margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(100,140,255,0.2);
    font-size: 0.75em; color: #6a8; line-height: 1.5;
}
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; }
label input { accent-color: #8af; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>PHASON FLIPS</h3>
    <div class="ctrl-row"><span>Flips performed:</span><span class="val" id="flipCount">0</span></div>
    <div class="ctrl-row"><span>Flippable regions:</span><span class="val" id="flippableCount">0</span></div>
    <div class="ctrl-row"><span>Thick tiles:</span><span class="val" id="thickCount">0</span></div>
    <div class="ctrl-row"><span>Thin tiles:</span><span class="val" id="thinCount">0</span></div>
    <div class="ctrl-row"><span>Auto-flip speed:</span></div>
    <input type="range" id="speedSlider" min="0" max="100" value="40">
    <div class="btn-row" style="margin-top:10px">
        <button class="btn" id="flipOneBtn">Flip One</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <label><input type="checkbox" id="showFlippable" checked> Highlight flippable</label>
    <label><input type="checkbox" id="autoFlip" checked> Auto-flip</label>
    <div class="info">
        Every Penrose tiling can be transformed into any other through a sequence of phason flips.
        Click on a glowing hexagonal region to flip it manually.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const PHI = (1 + Math.sqrt(5)) / 2;

let W, H;
let rhombuses = [];
let flippableGroups = [];
let flipCount = 0;
let animatingFlip = null;
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, dragSX, dragSY, camSX, camSY;
let lastFlipTime = 0;
let time = 0;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Robinson triangle decomposition for Penrose P3 rhombuses
// type 0 = half of thick rhombus, type 1 = half of thin rhombus
function subdivide(triangles) {
    let result = [];
    for (let tri of triangles) {
        let [type, A, B, C] = tri;
        if (type === 0) {
            let P = [A[0] + (B[0] - A[0]) / PHI, A[1] + (B[1] - A[1]) / PHI];
            result.push([0, C, P, A]);
            result.push([1, C, B, P]);
        } else {
            let Q = [B[0] + (A[0] - B[0]) / PHI, B[1] + (A[1] - B[1]) / PHI];
            let R = [B[0] + (C[0] - B[0]) / PHI, B[1] + (C[1] - B[1]) / PHI];
            result.push([1, R, C, A]);
            result.push([0, Q, R, B]);
            result.push([1, R, Q, A]);
        }
    }
    return result;
}

function generateTiling(level) {
    let triangles = [];
    let r = Math.max(W, H) * 0.8;
    for (let i = 0; i < 10; i++) {
        let a1 = (2 * Math.PI * i) / 10 - Math.PI / 2;
        let a2 = (2 * Math.PI * (i + 1)) / 10 - Math.PI / 2;
        let A = [0, 0];
        let B = [r * Math.cos(a1), r * Math.sin(a1)];
        let C = [r * Math.cos(a2), r * Math.sin(a2)];
        if (i % 2 === 0) {
            triangles.push([0, A, B, C]);
        } else {
            triangles.push([0, A, C, B]);
        }
    }
    for (let i = 0; i < level; i++) {
        triangles = subdivide(triangles);
    }
    return triangles;
}

function trianglesToRhombuses(triangles) {
    let paired = new Set();
    let rh = [];
    let eps = 0.5;

    function key(p) { return Math.round(p[0] * 10) + ',' + Math.round(p[1] * 10); }
    function midKey(a, b) {
        return key([(a[0] + b[0]) / 2, (a[1] + b[1]) / 2]);
    }

    let byEdge = {};
    for (let i = 0; i < triangles.length; i++) {
        let [type, A, B, C] = triangles[i];
        let mk = type + '_' + midKey(A, C);
        if (!byEdge[mk]) byEdge[mk] = [];
        byEdge[mk].push(i);
    }

    for (let k in byEdge) {
        let indices = byEdge[k];
        if (indices.length === 2 && !paired.has(indices[0]) && !paired.has(indices[1])) {
            let i = indices[0], j = indices[1];
            let [t1, A1, B1, C1] = triangles[i];
            let [t2, A2, B2, C2] = triangles[j];
            paired.add(i);
            paired.add(j);
            rh.push({
                type: t1 === 0 ? 'thick' : 'thin',
                verts: [B1, A1, B2, C1],
                cx: (B1[0] + A1[0] + B2[0] + C1[0]) / 4,
                cy: (B1[1] + A1[1] + B2[1] + C1[1]) / 4,
                id: rh.length
            });
        }
    }

    // Unpaired triangles as degenerate rhombuses
    for (let i = 0; i < triangles.length; i++) {
        if (!paired.has(i)) {
            let [type, A, B, C] = triangles[i];
            rh.push({
                type: type === 0 ? 'thick' : 'thin',
                verts: [A, B, C, A],
                cx: (A[0] + B[0] + C[0]) / 3,
                cy: (A[1] + B[1] + C[1]) / 3,
                id: rh.length
            });
        }
    }
    return rh;
}

function dist(a, b) { return Math.hypot(a[0] - b[0], a[1] - b[1]); }
function vEq(a, b) { return dist(a, b) < 1.5; }

function findFlippableGroups() {
    // Find groups of 3 rhombuses sharing a vertex that form a hexagonal region
    let vertMap = {};
    function vKey(p) { return Math.round(p[0] / 2) + ',' + Math.round(p[1] / 2); }

    for (let i = 0; i < rhombuses.length; i++) {
        for (let v of rhombuses[i].verts) {
            let k = vKey(v);
            if (!vertMap[k]) vertMap[k] = [];
            if (!vertMap[k].includes(i)) vertMap[k].push(i);
        }
    }

    let groups = [];
    let seen = new Set();

    for (let k in vertMap) {
        let indices = vertMap[k];
        if (indices.length >= 3) {
            // Try all combinations of 3
            for (let a = 0; a < indices.length - 2; a++) {
                for (let b = a + 1; b < indices.length - 1; b++) {
                    for (let c = b + 1; c < indices.length; c++) {
                        let tri = [indices[a], indices[b], indices[c]];
                        let types = tri.map(i => rhombuses[i].type);
                        // A valid phason flip: 3 tiles of same type around a vertex
                        let allSame = types[0] === types[1] && types[1] === types[2];
                        if (allSame) {
                            let key = tri.sort().join(',');
                            if (!seen.has(key)) {
                                seen.add(key);
                                groups.push({ indices: tri, center: k.split(',').map(Number).map(n => n * 2) });
                            }
                        }
                    }
                }
            }
        }
    }
    return groups;
}

function performFlip(group) {
    // Simple phason flip: toggle types of the 3 tiles
    for (let idx of group.indices) {
        if (rhombuses[idx]) {
            rhombuses[idx].type = rhombuses[idx].type === 'thick' ? 'thin' : 'thick';
            rhombuses[idx].flipTime = time;
        }
    }
    flipCount++;
    document.getElementById('flipCount').textContent = flipCount;
    flippableGroups = findFlippableGroups();
    updateCounts();
}

function updateCounts() {
    let thick = rhombuses.filter(r => r.type === 'thick').length;
    let thin = rhombuses.filter(r => r.type === 'thin').length;
    document.getElementById('thickCount').textContent = thick;
    document.getElementById('thinCount').textContent = thin;
    document.getElementById('flippableCount').textContent = flippableGroups.length;
}

function initTiling() {
    let level = 6;
    let triangles = generateTiling(level);
    rhombuses = trianglesToRhombuses(triangles);
    // Center
    let cx = W / 2, cy = H / 2;
    for (let r of rhombuses) {
        for (let v of r.verts) {
            v[0] += cx;
            v[1] += cy;
        }
        r.cx += cx;
        r.cy += cy;
        r.flipTime = -999;
    }
    flippableGroups = findFlippableGroups();
    flipCount = 0;
    document.getElementById('flipCount').textContent = 0;
    updateCounts();
}

window.reset = function() { initTiling(); };
document.getElementById('resetBtn').addEventListener('click', () => initTiling());
document.getElementById('flipOneBtn').addEventListener('click', () => {
    if (flippableGroups.length > 0) {
        let g = flippableGroups[Math.floor(Math.random() * flippableGroups.length)];
        performFlip(g);
    }
});

// Pan and zoom
canvas.addEventListener('mousedown', e => {
    if (e.button === 0) {
        dragging = true;
        dragSX = e.clientX; dragSY = e.clientY;
        camSX = camX; camSY = camY;
    }
});
canvas.addEventListener('mousemove', e => {
    if (dragging) {
        camX = camSX + (e.clientX - dragSX) / camZoom;
        camY = camSY + (e.clientY - dragSY) / camZoom;
    }
});
canvas.addEventListener('mouseup', () => { dragging = false; });
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camZoom *= e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.2, Math.min(5, camZoom));
}, { passive: false });

// Click to flip
canvas.addEventListener('click', e => {
    if (!document.getElementById('showFlippable').checked) return;
    let mx = (e.clientX - W / 2) / camZoom - camX + W / 2;
    let my = (e.clientY - H / 2) / camZoom - camY + H / 2;

    for (let g of flippableGroups) {
        let gcx = 0, gcy = 0, count = 0;
        for (let idx of g.indices) {
            gcx += rhombuses[idx].cx;
            gcy += rhombuses[idx].cy;
            count++;
        }
        gcx /= count; gcy /= count;
        if (dist([mx, my], [gcx, gcy]) < 40) {
            performFlip(g);
            return;
        }
    }
});

function drawRhombus(r, highlight) {
    let v = r.verts;
    ctx.beginPath();
    ctx.moveTo(v[0][0], v[0][1]);
    for (let i = 1; i < 4; i++) ctx.lineTo(v[i][0], v[i][1]);
    ctx.closePath();

    let flipAge = time - (r.flipTime || -999);
    let flash = Math.max(0, 1 - flipAge / 0.5);

    if (r.type === 'thick') {
        let base = `rgba(60, 130, 220, ${0.6 + flash * 0.3})`;
        ctx.fillStyle = base;
    } else {
        let base = `rgba(220, 100, 60, ${0.5 + flash * 0.3})`;
        ctx.fillStyle = base;
    }
    ctx.fill();

    if (flash > 0) {
        ctx.shadowColor = r.type === 'thick' ? '#4af' : '#fa4';
        ctx.shadowBlur = 20 * flash;
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    ctx.strokeStyle = `rgba(180, 200, 255, ${0.25 + flash * 0.3})`;
    ctx.lineWidth = 0.8;
    ctx.stroke();

    if (highlight) {
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 15 + 5 * Math.sin(time * 4);
        ctx.strokeStyle = `rgba(255, 255, 100, ${0.5 + 0.3 * Math.sin(time * 4)})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    ctx.save();
    ctx.translate(W / 2, H / 2);
    ctx.scale(camZoom, camZoom);
    ctx.translate(camX - W / 2, camY - H / 2);

    let showFlippable = document.getElementById('showFlippable').checked;
    let flippableSet = new Set();
    if (showFlippable) {
        for (let g of flippableGroups) {
            for (let idx of g.indices) flippableSet.add(idx);
        }
    }

    for (let i = 0; i < rhombuses.length; i++) {
        drawRhombus(rhombuses[i], flippableSet.has(i));
    }

    ctx.restore();
}

function animate(t) {
    time = t / 1000;

    let autoFlipOn = document.getElementById('autoFlip').checked;
    let speed = document.getElementById('speedSlider').value;
    let interval = Math.max(0.05, 3 - speed * 0.029);

    if (autoFlipOn && flippableGroups.length > 0 && time - lastFlipTime > interval) {
        let g = flippableGroups[Math.floor(Math.random() * flippableGroups.length)];
        performFlip(g);
        lastFlipTime = time;
    }

    draw();
    requestAnimationFrame(animate);
}

initTiling();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>