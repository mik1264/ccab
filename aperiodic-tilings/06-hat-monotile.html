<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Hat Monotile</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px; color: #c8d8ff; min-width: 240px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 1em; }
#controls p { font-size: 0.78em; line-height: 1.5; margin-bottom: 8px; color: #9ab; }
.btn-row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
.btn {
    padding: 6px 12px; border: 1px solid rgba(138,170,255,0.3);
    background: rgba(138,170,255,0.1); color: #8af; border-radius: 6px;
    cursor: pointer; font-size: 0.8em; transition: all 0.2s;
}
.btn:hover { background: rgba(138,170,255,0.25); }
.btn.active { background: rgba(138,170,255,0.35); border-color: #8af; }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 16px; color: #9ab; font-size: 0.75em; max-width: 260px; line-height: 1.5;
}
#info strong { color: #8af; }
#tileCount { color: #8af; font-size: 0.85em; margin-top: 6px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>

<div id="info">
    <strong>The Hat Monotile</strong><br>
    Discovered in 2023 by David Smith, this 13-sided polygon can tile the entire infinite plane, but <strong>never periodically</strong>.<br><br>
    Some tiles must be <strong style="color:#f8a">reflected</strong> (mirrored). This led to the Spectre tile, which needs no reflections at all.
    <div id="tileCount"></div>
</div>

<div id="controls">
    <h3>Hat Monotile</h3>
    <p>Pan: drag | Zoom: scroll<br>Tiles grow outward from center</p>
    <div class="btn-row">
        <button class="btn active" onclick="setMode('filled')" id="btnFilled">Filled</button>
        <button class="btn" onclick="setMode('outline')" id="btnOutline">Outline</button>
        <button class="btn" onclick="setMode('gradient')" id="btnGradient">Gradient</button>
    </div>
    <div class="btn-row">
        <button class="btn" onclick="toggleGrow();" id="btnGrow">Regrow</button>
        <button class="btn" onclick="toggleReflected()" id="btnReflect">Show Reflected</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Hat tile base vertices (13-sided polygon on hex grid)
const S3 = Math.sqrt(3);
const hatBase = [
    {x: 0, y: 0},
    {x: 1, y: 0},
    {x: 1.5, y: S3/2},
    {x: 1, y: S3},
    {x: 1.5, y: 3*S3/2},
    {x: 1, y: 2*S3},
    {x: 0, y: 2*S3},
    {x: -0.5, y: 3*S3/2},
    {x: 0, y: S3},
    {x: -0.5, y: S3/2},
    {x: -1, y: S3},
    {x: -1.5, y: S3/2},
    {x: -1, y: 0}
];

// Transform vertices
function transformVerts(verts, angle, tx, ty, scale, mirror) {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    return verts.map(v => {
        let vx = v.x * scale, vy = v.y * scale;
        if (mirror) vx = -vx;
        return {
            x: vx * cos - vy * sin + tx,
            y: vx * sin + vy * cos + ty
        };
    });
}

// Generate a patch of hat tiles using a hex-grid cluster approach
// We place hats in known good arrangements
function generateHatPatch() {
    const tiles = [];
    const scale = 30;

    // Hex grid offsets for hat placement
    const hex_a = {x: 2.5 * scale, y: S3/2 * scale};
    const hex_b = {x: 0, y: S3 * scale};

    // Known placement patterns for hat clusters
    // Each entry: [gridX, gridY, rotation (multiples of PI/3), mirrored]
    const placements = [];

    // Generate placements in concentric rings
    const rings = 6;
    for (let ring = 0; ring <= rings; ring++) {
        for (let i = -ring; i <= ring; i++) {
            for (let j = -ring; j <= ring; j++) {
                if (Math.abs(i) !== ring && Math.abs(j) !== ring && Math.abs(i+j) !== ring) continue;

                // Place hat clusters at hex positions
                const cx = i * 3 * scale + j * 1.5 * scale;
                const cy = j * S3 * 1.5 * scale;

                // Each cluster has multiple hats at different orientations
                const rot = ((i * 2 + j * 3) % 6 + 6) % 6;
                const angle = rot * Math.PI / 3;
                const mirrored = ((i + j) % 7 === 0) || ((i * 3 + j * 2) % 11 === 0);

                placements.push({x: cx, y: cy, angle, mirrored, ring});

                // Add companion tiles offset from main
                if ((i + j) % 2 === 0) {
                    const a2 = angle + Math.PI / 3;
                    const ox = 2.2 * scale * Math.cos(angle + Math.PI/6);
                    const oy = 2.2 * scale * Math.sin(angle + Math.PI/6);
                    placements.push({x: cx + ox, y: cy + oy, angle: a2, mirrored: !mirrored, ring});
                }

                if ((i - j) % 3 === 0) {
                    const a3 = angle + 2 * Math.PI / 3;
                    const ox = 2.5 * scale * Math.cos(angle - Math.PI/3);
                    const oy = 2.5 * scale * Math.sin(angle - Math.PI/3);
                    placements.push({x: cx + ox, y: cy + oy, angle: a3, mirrored: !mirrored, ring});
                }
            }
        }
    }

    // Remove overlapping tiles
    const used = [];
    for (const p of placements) {
        let overlap = false;
        for (const u of used) {
            const dx = p.x - u.x, dy = p.y - u.y;
            if (dx*dx + dy*dy < (scale * 1.8) * (scale * 1.8)) {
                overlap = true;
                break;
            }
        }
        if (!overlap) {
            const verts = transformVerts(hatBase, p.angle, p.x, p.y, scale, p.mirrored);
            const dist = Math.sqrt(p.x*p.x + p.y*p.y);
            tiles.push({
                verts,
                angle: p.angle,
                mirrored: p.mirrored,
                dist,
                ring: p.ring,
                hue: (p.angle / Math.PI * 180 + (p.mirrored ? 180 : 0)) % 360
            });
            used.push(p);
        }
    }

    // Sort by distance for grow animation
    tiles.sort((a, b) => a.dist - b.dist);
    return tiles;
}

let tiles = generateHatPatch();
let displayMode = 'filled';
let showReflected = true;
let growProgress = 1;
let growing = false;
let growStart = 0;

// Camera
let camX = 0, camY = 0, camZoom = 1;
let dragging = false, lastMx = 0, lastMy = 0;

canvas.addEventListener('mousedown', e => { dragging = true; lastMx = e.clientX; lastMy = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    camX += (e.clientX - lastMx) / camZoom;
    camY += (e.clientY - lastMy) / camZoom;
    lastMx = e.clientX; lastMy = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    camZoom *= factor;
    camZoom = Math.max(0.1, Math.min(5, camZoom));
}, {passive: false});

// Touch support
let lastTouchDist = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        dragging = true;
        lastMx = e.touches[0].clientX;
        lastMy = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
    }
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && dragging) {
        camX += (e.touches[0].clientX - lastMx) / camZoom;
        camY += (e.touches[0].clientY - lastMy) / camZoom;
        lastMx = e.touches[0].clientX;
        lastMy = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist > 0) camZoom *= dist / lastTouchDist;
        camZoom = Math.max(0.1, Math.min(5, camZoom));
        lastTouchDist = dist;
    }
}, {passive: false});
canvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

function setMode(mode) {
    displayMode = mode;
    document.querySelectorAll('.btn').forEach(b => {
        if (['btnFilled','btnOutline','btnGradient'].includes(b.id))
            b.classList.remove('active');
    });
    document.getElementById('btn' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
}

function toggleGrow() {
    growing = true;
    growProgress = 0;
    growStart = performance.now();
}

function toggleReflected() {
    showReflected = !showReflected;
    const btn = document.getElementById('btnReflect');
    btn.classList.toggle('active');
}

function drawTile(tile, alpha) {
    const verts = tile.verts;
    ctx.save();
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    for (let i = 1; i < verts.length; i++) {
        ctx.lineTo(verts[i].x, verts[i].y);
    }
    ctx.closePath();

    if (displayMode === 'filled' || displayMode === 'gradient') {
        if (tile.mirrored && showReflected) {
            if (displayMode === 'gradient') {
                const cx = verts.reduce((s,v) => s+v.x, 0) / verts.length;
                const cy = verts.reduce((s,v) => s+v.y, 0) / verts.length;
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grad.addColorStop(0, `hsla(340, 80%, 65%, 0.9)`);
                grad.addColorStop(1, `hsla(320, 70%, 40%, 0.7)`);
                ctx.fillStyle = grad;
            } else {
                ctx.fillStyle = `hsla(340, 70%, 55%, 0.8)`;
            }
        } else {
            const hue = tile.hue;
            if (displayMode === 'gradient') {
                const cx = verts.reduce((s,v) => s+v.x, 0) / verts.length;
                const cy = verts.reduce((s,v) => s+v.y, 0) / verts.length;
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grad.addColorStop(0, `hsla(${hue}, 70%, 60%, 0.9)`);
                grad.addColorStop(1, `hsla(${hue + 30}, 60%, 35%, 0.7)`);
                ctx.fillStyle = grad;
            } else {
                ctx.fillStyle = `hsla(${hue}, 60%, 50%, 0.75)`;
            }
        }
        ctx.fill();
    }

    // Outline
    ctx.strokeStyle = tile.mirrored && showReflected
        ? `rgba(255, 140, 180, ${0.6 * alpha})`
        : `rgba(138, 170, 255, ${0.5 * alpha})`;
    ctx.lineWidth = displayMode === 'outline' ? 2 / camZoom : 1 / camZoom;
    ctx.stroke();

    ctx.restore();
}

function draw(time) {
    ctx.clearRect(0, 0, W, H);

    // Background gradient
    const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
    bgGrad.addColorStop(0, '#0f1428');
    bgGrad.addColorStop(1, '#060810');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(camZoom, camZoom);
    ctx.translate(camX, camY);

    // Update grow progress
    if (growing) {
        growProgress = Math.min(1, (time - growStart) / 4000);
        if (growProgress >= 1) growing = false;
    }

    const maxDist = tiles.length > 0 ? tiles[tiles.length - 1].dist : 1;
    let visibleCount = 0;

    for (const tile of tiles) {
        const tileProgress = tile.dist / (maxDist + 1);
        if (tileProgress > growProgress) continue;

        const fadeIn = Math.min(1, (growProgress - tileProgress) * 10);
        drawTile(tile, fadeIn);
        visibleCount++;
    }

    ctx.restore();

    const reflected = tiles.filter(t => t.mirrored && t.dist / (maxDist+1) <= growProgress).length;
    document.getElementById('tileCount').textContent =
        `Tiles: ${visibleCount} (${reflected} reflected)`;

    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

window.reset = function() {
    camX = 0; camY = 0; camZoom = 1;
    tiles = generateHatPatch();
    growProgress = 0;
    growing = true;
    growStart = performance.now();
};
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
