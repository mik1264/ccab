<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Golden Ratio Connection</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.3); border-radius: 12px;
    padding: 18px; min-width: 260px; color: #c8d8ff; max-height: 90vh; overflow-y: auto;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row span { color: #8aa; }
.ctrl-row .val { color: #ffd866; font-weight: bold; }
.ctrl-row .phi { color: #f8a; font-weight: bold; }
button.btn {
    background: rgba(80, 120, 255, 0.2); border: 1px solid rgba(100, 140, 255, 0.4);
    color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 0.85em; transition: all 0.2s; width: 100%; margin-bottom: 6px;
}
button.btn:hover { background: rgba(80, 120, 255, 0.4); }
label { font-size: 0.8em; color: #8aa; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 6px; }
label input { accent-color: #8af; }
.section { border-top: 1px solid rgba(100, 140, 255, 0.15); padding-top: 10px; margin-top: 10px; }
.fib-chart { margin-top: 10px; }
.fib-bar { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; font-size: 0.75em; }
.fib-bar .bar { height: 10px; background: linear-gradient(90deg, rgba(80,140,255,0.7), rgba(255,180,80,0.7)); border-radius: 3px; transition: width 0.5s; min-width: 2px; }
.fib-bar .lbl { color: #8aa; min-width: 30px; text-align: right; }
.fib-bar .cnt { color: #ffd866; min-width: 40px; }
.info-box {
    font-size: 0.75em; color: #9ab; line-height: 1.5; padding: 8px;
    background: rgba(80, 120, 255, 0.08); border-radius: 6px; margin-top: 8px;
}
.info-box .highlight { color: #ffd866; }
#tileInfo {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(10, 14, 30, 0.9); backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 200, 80, 0.4); border-radius: 10px;
    padding: 14px 20px; color: #ffd866; z-index: 100;
    font-size: 0.9em; display: none; max-width: 400px; text-align: center;
}
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="canvas"></canvas>
<div id="controls">
    <h3>THE GOLDEN RATIO</h3>
    <div class="ctrl-row"><span>phi =</span><span class="phi" id="phiVal">1.6180339887...</span></div>
    <div class="section">
        <label><input type="checkbox" id="showTiling" checked> Penrose tiling</label>
        <label><input type="checkbox" id="showSpiral" checked> Golden spiral</label>
        <label><input type="checkbox" id="showAnnotations" checked> Annotations</label>
        <label><input type="checkbox" id="showFibHighlight"> Fibonacci highlight</label>
    </div>
    <div class="section">
        <h3>TILE COUNTS PER LEVEL</h3>
        <div class="fib-chart" id="fibChart"></div>
    </div>
    <div class="section">
        <h3>RATIOS</h3>
        <div id="ratioTable"></div>
    </div>
    <div class="info-box">
        Angles: <span class="highlight">36 = pi/5</span>, <span class="highlight">72 = 2pi/5</span><br>
        Kite sides: <span class="highlight">1 : phi</span><br>
        Dart sides: <span class="highlight">1 : phi</span><br>
        Thick/Thin ratio -> <span class="highlight">phi</span><br>
        Click any tile to see its measurements.
    </div>
    <button class="btn" id="resetBtn">Reset View</button>
</div>
<div id="tileInfo"></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;

let camX = 0, camY = 0, camZoom = 1;
let dragging = false, dragStartX, dragStartY, camStartX, camStartY;
let allTiles = [];
let trianglesPerLevel = [];
let spiralPoints = [];
let selectedTile = null;
let animTime = 0;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function lerp(p1, p2, t) {
    return [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];
}
function dist(a, b) {
    return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
}

function makeInitial() {
    let tris = [];
    for (let i = 0; i < 10; i++) {
        let a1 = (2 * Math.PI * i) / 10 - Math.PI / 2;
        let a2 = (2 * Math.PI * (i + 1)) / 10 - Math.PI / 2;
        let r = 250;
        let a = [0, 0];
        let b = [r * Math.cos(a1), r * Math.sin(a1)];
        let c = [r * Math.cos(a2), r * Math.sin(a2)];
        if (i % 2 === 0) tris.push({ type: 'B', vertices: [a, b, c] });
        else tris.push({ type: 'B', vertices: [a, c, b] });
    }
    return tris;
}

function subdivide(tris) {
    let result = [];
    for (let t of tris) {
        let [a, b, c] = t.vertices;
        if (t.type === 'B') {
            let p = lerp(a, c, INV_PHI);
            let q = lerp(b, a, INV_PHI);
            result.push({ type: 'B', vertices: [q, p, b] });
            result.push({ type: 'B', vertices: [p, q, a] });
            result.push({ type: 'A', vertices: [c, p, b] });
        } else {
            let p = lerp(b, a, INV_PHI);
            result.push({ type: 'A', vertices: [p, c, a] });
            result.push({ type: 'B', vertices: [c, p, b] });
        }
    }
    return result;
}

function edgeKey(p1, p2) {
    let ax = Math.round(p1[0] * 100) / 100;
    let ay = Math.round(p1[1] * 100) / 100;
    let bx = Math.round(p2[0] * 100) / 100;
    let by = Math.round(p2[1] * 100) / 100;
    if (ax < bx || (ax === bx && ay < by)) return `${ax},${ay}-${bx},${by}`;
    return `${bx},${by}-${ax},${ay}`;
}

function generateAll() {
    let tris = makeInitial();
    trianglesPerLevel = [{ total: 10, typeB: 10, typeA: 0 }];
    let maxLevel = 6;

    for (let i = 0; i < maxLevel; i++) {
        tris = subdivide(tris);
        let bCount = 0, aCount = 0;
        for (let t of tris) {
            if (t.type === 'B') bCount++;
            else aCount++;
        }
        trianglesPerLevel.push({ total: tris.length, typeB: bCount, typeA: aCount });
    }

    // Pair into tiles
    allTiles = [];
    let eMap = new Map();
    let paired = new Set();

    for (let i = 0; i < tris.length; i++) {
        let t = tris[i];
        let key = edgeKey(t.vertices[1], t.vertices[2]);
        if (eMap.has(key)) {
            let j = eMap.get(key);
            if (!paired.has(j) && tris[j].type === t.type) {
                let kind = t.type === 'B' ? 'kite' : 'dart';
                let verts = [t.vertices[0], t.vertices[1], tris[j].vertices[0], t.vertices[2]];
                let cx = verts.reduce((s, v) => s + v[0], 0) / 4;
                let cy = verts.reduce((s, v) => s + v[1], 0) / 4;
                allTiles.push({ kind, vertices: verts, center: [cx, cy] });
                paired.add(i);
                paired.add(j);
            } else {
                eMap.set(key, i);
            }
        } else {
            eMap.set(key, i);
        }
    }

    generateSpiral();
    buildFibChart();
    buildRatioTable();
}

function generateSpiral() {
    spiralPoints = [];
    let cx = 0, cy = 0;
    let angle = 0;
    let r = 2;
    for (let i = 0; i < 300; i++) {
        let x = cx + r * Math.cos(angle);
        let y = cy + r * Math.sin(angle);
        spiralPoints.push([x, y]);
        angle += 0.1;
        r *= 1.005;
    }
}

function buildFibChart() {
    let container = document.getElementById('fibChart');
    container.innerHTML = '';
    let fib = [10];
    for (let i = 1; i < trianglesPerLevel.length; i++) {
        fib.push(trianglesPerLevel[i].total);
    }
    let maxCount = Math.max(...fib);

    for (let i = 0; i < fib.length; i++) {
        let div = document.createElement('div');
        div.className = 'fib-bar';
        let w = Math.max(2, (fib[i] / maxCount) * 120);
        div.innerHTML = `<span class="lbl">L${i}</span><div class="bar" style="width:${w}px"></div><span class="cnt">${fib[i]}</span>`;
        container.appendChild(div);
    }
}

function buildRatioTable() {
    let container = document.getElementById('ratioTable');
    container.innerHTML = '';

    let kites = 0, darts = 0;
    for (let t of allTiles) {
        if (t.kind === 'kite') kites++;
        else darts++;
    }

    let rows = [
        ['Kites', kites],
        ['Darts', darts],
        ['K/D ratio', darts > 0 ? (kites / darts).toFixed(6) : '-'],
        ['phi', PHI.toFixed(6)]
    ];

    for (let [label, val] of rows) {
        let div = document.createElement('div');
        div.className = 'ctrl-row';
        div.innerHTML = `<span>${label}:</span><span class="val">${val}</span>`;
        container.appendChild(div);
    }
}

function worldToScreen(x, y) {
    return [(x - camX) * camZoom + canvas.width / 2, (y - camY) * camZoom + canvas.height / 2];
}

function screenToWorld(sx, sy) {
    return [(sx - canvas.width / 2) / camZoom + camX, (sy - canvas.height / 2) / camZoom + camY];
}

function pointInPoly(px, py, verts) {
    let inside = false;
    for (let i = 0, j = verts.length - 1; i < verts.length; j = i++) {
        let xi = verts[i][0], yi = verts[i][1];
        let xj = verts[j][0], yj = verts[j][1];
        if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    return inside;
}

function drawTiling() {
    if (!document.getElementById('showTiling').checked) return;

    let showFibHL = document.getElementById('showFibHighlight').checked;
    let fibIdx = Math.floor(animTime * 0.5) % allTiles.length;

    for (let i = 0; i < allTiles.length; i++) {
        let tile = allTiles[i];
        let verts = tile.vertices;
        let [sx0, sy0] = worldToScreen(verts[0][0], verts[0][1]);

        ctx.beginPath();
        ctx.moveTo(sx0, sy0);
        for (let j = 1; j < verts.length; j++) {
            let [sx, sy] = worldToScreen(verts[j][0], verts[j][1]);
            ctx.lineTo(sx, sy);
        }
        ctx.closePath();

        let isSelected = (selectedTile === tile);
        let isFibHL = showFibHL && i <= fibIdx;

        if (isSelected) {
            ctx.fillStyle = tile.kind === 'kite' ? 'rgba(60, 120, 255, 0.9)' : 'rgba(255, 180, 40, 0.9)';
        } else if (isFibHL) {
            let t = 0.5 + 0.5 * Math.sin(animTime * 3 + i * 0.1);
            ctx.fillStyle = tile.kind === 'kite' ? `rgba(40, 90, 200, ${0.5 + 0.4 * t})` : `rgba(200, 140, 30, ${0.5 + 0.4 * t})`;
        } else {
            ctx.fillStyle = tile.kind === 'kite' ? 'rgba(15, 40, 90, 0.8)' : 'rgba(90, 60, 15, 0.8)';
        }
        ctx.fill();

        ctx.strokeStyle = isSelected ? 'rgba(255, 255, 255, 0.7)' : 'rgba(80, 130, 220, 0.25)';
        ctx.lineWidth = isSelected ? 2 : 0.6;
        ctx.stroke();
    }
}

function drawAnnotations() {
    if (!document.getElementById('showAnnotations').checked) return;
    if (!selectedTile) return;

    let tile = selectedTile;
    let verts = tile.vertices;

    // Draw side lengths
    for (let i = 0; i < verts.length; i++) {
        let j = (i + 1) % verts.length;
        let d = dist(verts[i], verts[j]);
        let mx = (verts[i][0] + verts[j][0]) / 2;
        let my = (verts[i][1] + verts[j][1]) / 2;
        let [sx, sy] = worldToScreen(mx, my);

        ctx.font = `${Math.max(10, 12 * camZoom)}px monospace`;
        ctx.fillStyle = '#ffd866';
        ctx.textAlign = 'center';
        ctx.fillText(d.toFixed(1), sx, sy - 6 * camZoom);
    }

    // Draw angles at vertices
    for (let i = 0; i < verts.length; i++) {
        let prev = verts[(i + verts.length - 1) % verts.length];
        let curr = verts[i];
        let next = verts[(i + 1) % verts.length];

        let a1 = Math.atan2(prev[1] - curr[1], prev[0] - curr[0]);
        let a2 = Math.atan2(next[1] - curr[1], next[0] - curr[0]);
        let angle = a2 - a1;
        if (angle < 0) angle += 2 * Math.PI;
        if (angle > Math.PI) angle = 2 * Math.PI - angle;
        let deg = Math.round(angle * 180 / Math.PI);

        let [sx, sy] = worldToScreen(curr[0], curr[1]);
        let midAngle = (a1 + a2) / 2;
        let off = 20 * camZoom;
        ctx.font = `bold ${Math.max(9, 11 * camZoom)}px monospace`;
        ctx.fillStyle = '#f8a';
        ctx.textAlign = 'center';
        ctx.fillText(deg + '\u00B0', sx + Math.cos(midAngle) * off, sy + Math.sin(midAngle) * off);
    }

    // Golden ratio annotation near tile
    let [scx, scy] = worldToScreen(tile.center[0], tile.center[1]);
    ctx.font = `bold ${Math.max(10, 13 * camZoom)}px monospace`;
    ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';
    ctx.textAlign = 'center';
    ctx.fillText(tile.kind === 'kite' ? 'KITE' : 'DART', scx, scy + 4);

    // Side ratio annotation
    if (verts.length === 4) {
        let s1 = dist(verts[0], verts[1]);
        let s2 = dist(verts[1], verts[2]);
        let ratio = Math.max(s1, s2) / Math.min(s1, s2);
        ctx.font = `${Math.max(9, 11 * camZoom)}px monospace`;
        ctx.fillStyle = '#8f8';
        ctx.fillText('ratio: ' + ratio.toFixed(4) + ' (phi=' + PHI.toFixed(4) + ')', scx, scy + 20 * camZoom);
    }
}

function drawSpiral() {
    if (!document.getElementById('showSpiral').checked) return;
    if (spiralPoints.length < 2) return;

    ctx.beginPath();
    let [sx, sy] = worldToScreen(spiralPoints[0][0], spiralPoints[0][1]);
    ctx.moveTo(sx, sy);
    for (let i = 1; i < spiralPoints.length; i++) {
        let [sx2, sy2] = worldToScreen(spiralPoints[i][0], spiralPoints[i][1]);
        ctx.lineTo(sx2, sy2);
    }
    ctx.strokeStyle = 'rgba(255, 200, 80, 0.5)';
    ctx.lineWidth = 2;
    ctx.shadowColor = 'rgba(255, 200, 80, 0.4)';
    ctx.shadowBlur = 8;
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function draw(time) {
    animTime = time / 1000;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawTiling();
    drawSpiral();
    drawAnnotations();

    requestAnimationFrame(draw);
}

canvas.addEventListener('click', (e) => {
    let [wx, wy] = screenToWorld(e.clientX, e.clientY);
    selectedTile = null;

    for (let tile of allTiles) {
        if (pointInPoly(wx, wy, tile.vertices)) {
            selectedTile = tile;
            break;
        }
    }

    let info = document.getElementById('tileInfo');
    if (selectedTile) {
        let verts = selectedTile.vertices;
        let sides = [];
        for (let i = 0; i < verts.length; i++) {
            sides.push(dist(verts[i], verts[(i + 1) % verts.length]).toFixed(2));
        }
        let s1 = parseFloat(sides[0]);
        let s2 = parseFloat(sides[1]);
        let ratio = (Math.max(s1, s2) / Math.min(s1, s2)).toFixed(4);
        info.innerHTML = `<strong>${selectedTile.kind.toUpperCase()}</strong> | Sides: ${sides.join(', ')} | Side ratio: ${ratio} | phi: ${PHI.toFixed(4)}`;
        info.style.display = 'block';
    } else {
        info.style.display = 'none';
    }
});

canvas.addEventListener('mousedown', (e) => {
    if (e.button === 2 || e.button === 1) {
        dragging = true;
        dragStartX = e.clientX; dragStartY = e.clientY;
        camStartX = camX; camStartY = camY;
    }
});
canvas.addEventListener('mousemove', (e) => {
    if (dragging) {
        camX = camStartX - (e.clientX - dragStartX) / camZoom;
        camY = camStartY - (e.clientY - dragStartY) / camZoom;
    }
});
canvas.addEventListener('mouseup', () => { dragging = false; });
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    let factor = e.deltaY > 0 ? 0.9 : 1.1;
    let mx = (e.clientX - canvas.width / 2) / camZoom + camX;
    let my = (e.clientY - canvas.height / 2) / camZoom + camY;
    camZoom *= factor;
    camZoom = Math.max(0.05, Math.min(30, camZoom));
    camX = mx - (e.clientX - canvas.width / 2) / camZoom;
    camY = my - (e.clientY - canvas.height / 2) / camZoom;
}, { passive: false });

document.getElementById('resetBtn').addEventListener('click', () => { window.reset(); });

window.reset = function() {
    camX = 0; camY = 0; camZoom = 1;
    selectedTile = null;
    document.getElementById('tileInfo').style.display = 'none';
};

generateAll();
requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
