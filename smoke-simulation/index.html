<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smoke Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(150, 100, 200, 0.4);
            z-index: 100;
            min-width: 260px;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            color: #c8a0ff;
        }

        .subtitle {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 6px;
            background: rgba(40, 30, 60, 0.8);
            border: 1px solid rgba(150, 100, 200, 0.4);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #c8a0ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 8px;
            background: linear-gradient(135deg, #6a3093, #a044ff);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(160, 68, 255, 0.4);
        }

        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 6px;
            font-size: 0.75em;
            background: rgba(60, 40, 90, 0.8);
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.9);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #888;
            border: 1px solid rgba(150, 100, 200, 0.3);
            font-family: 'Segoe UI', sans-serif;
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #c8a0ff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(10, 10, 20, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(150, 100, 200, 0.3);
            font-family: 'Segoe UI', sans-serif;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(100, 50, 150, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üí® Smoke Simulation</h1>
        <p class="subtitle">GPU Fluid Dynamics</p>

        <div class="control-group">
            <label>Color Mode</label>
            <select id="colorMode">
                <option value="smoke">Classic Smoke</option>
                <option value="fire">Fire</option>
                <option value="rainbow">Rainbow Velocity</option>
                <option value="ink">Ink Drop</option>
                <option value="thermal">Thermal</option>
            </select>
        </div>

        <div class="control-group">
            <label>Viscosity: <span id="viscVal">0.00005</span></label>
            <input type="range" id="viscosity" min="0" max="0.001" step="0.00001" value="0.00005">
        </div>

        <div class="control-group">
            <label>Diffusion: <span id="diffVal">0.0001</span></label>
            <input type="range" id="diffusion" min="0" max="0.001" step="0.00001" value="0.0001">
        </div>

        <div class="control-group">
            <label>Buoyancy: <span id="buoyVal">0.5</span></label>
            <input type="range" id="buoyancy" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Vorticity: <span id="vortVal">0.3</span></label>
            <input type="range" id="vorticity" min="0" max="1" step="0.05" value="0.3">
        </div>

        <div class="btn-row">
            <button onclick="clearSimulation()">Clear</button>
            <button onclick="addBurst()">Add Burst</button>
        </div>

        <div class="presets">
            <button class="preset-btn" onclick="loadPreset('steam')">Steam</button>
            <button class="preset-btn" onclick="loadPreset('thick')">Thick</button>
            <button class="preset-btn" onclick="loadPreset('wispy')">Wispy</button>
            <button class="preset-btn" onclick="loadPreset('turbulent')">Turbulent</button>
        </div>
    </div>

    <div class="instructions">
        <strong>Drag</strong> to add smoke ‚Ä¢ <strong>Shift+Drag</strong> for continuous source
    </div>

    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { antialias: false, alpha: false });

        if (!gl) {
            alert('WebGL 2 not supported');
            throw new Error('WebGL 2 not supported');
        }

        // Simulation parameters
        let viscosity = 0.00005;
        let diffusion = 0.0001;
        let buoyancy = 0.5;
        let vorticityStrength = 0.3;
        let colorMode = 'smoke';

        // Grid size (lower for performance)
        const SCALE = 2;
        let width, height;

        // Textures
        let velocityTextures = [];
        let densityTextures = [];
        let pressureTextures = [];
        let divergenceTexture;
        let vorticityTexture;
        let currentVel = 0;
        let currentDen = 0;
        let currentPres = 0;

        // Framebuffers
        let framebuffers = {};

        // Shaders
        const vertexShader = `#version 300 es
            in vec2 position;
            out vec2 vUv;
            void main() {
                vUv = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0, 1);
            }
        `;

        const advectShader = `#version 300 es
            precision highp float;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform float uDt;
            uniform float uDissipation;
            uniform vec2 uTexelSize;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                vec2 vel = texture(uVelocity, vUv).xy;
                vec2 pos = vUv - vel * uDt * uTexelSize;
                fragColor = uDissipation * texture(uSource, pos);
            }
        `;

        const divergenceShader = `#version 300 es
            precision highp float;
            uniform sampler2D uVelocity;
            uniform vec2 uTexelSize;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                float L = texture(uVelocity, vUv - vec2(uTexelSize.x, 0)).x;
                float R = texture(uVelocity, vUv + vec2(uTexelSize.x, 0)).x;
                float T = texture(uVelocity, vUv + vec2(0, uTexelSize.y)).y;
                float B = texture(uVelocity, vUv - vec2(0, uTexelSize.y)).y;
                float div = 0.5 * (R - L + T - B);
                fragColor = vec4(div, 0, 0, 1);
            }
        `;

        const pressureShader = `#version 300 es
            precision highp float;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
            uniform vec2 uTexelSize;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                float L = texture(uPressure, vUv - vec2(uTexelSize.x, 0)).x;
                float R = texture(uPressure, vUv + vec2(uTexelSize.x, 0)).x;
                float T = texture(uPressure, vUv + vec2(0, uTexelSize.y)).x;
                float B = texture(uPressure, vUv - vec2(0, uTexelSize.y)).x;
                float div = texture(uDivergence, vUv).x;
                fragColor = vec4((L + R + T + B - div) * 0.25, 0, 0, 1);
            }
        `;

        const gradientSubtractShader = `#version 300 es
            precision highp float;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
            uniform vec2 uTexelSize;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                float L = texture(uPressure, vUv - vec2(uTexelSize.x, 0)).x;
                float R = texture(uPressure, vUv + vec2(uTexelSize.x, 0)).x;
                float T = texture(uPressure, vUv + vec2(0, uTexelSize.y)).x;
                float B = texture(uPressure, vUv - vec2(0, uTexelSize.y)).x;
                vec2 vel = texture(uVelocity, vUv).xy;
                vel -= 0.5 * vec2(R - L, T - B);
                fragColor = vec4(vel, 0, 1);
            }
        `;

        const vorticityShader = `#version 300 es
            precision highp float;
            uniform sampler2D uVelocity;
            uniform vec2 uTexelSize;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                float L = texture(uVelocity, vUv - vec2(uTexelSize.x, 0)).y;
                float R = texture(uVelocity, vUv + vec2(uTexelSize.x, 0)).y;
                float T = texture(uVelocity, vUv + vec2(0, uTexelSize.y)).x;
                float B = texture(uVelocity, vUv - vec2(0, uTexelSize.y)).x;
                float vorticity = R - L - T + B;
                fragColor = vec4(vorticity, 0, 0, 1);
            }
        `;

        const vorticityForceShader = `#version 300 es
            precision highp float;
            uniform sampler2D uVelocity;
            uniform sampler2D uVorticity;
            uniform float uStrength;
            uniform float uDt;
            uniform vec2 uTexelSize;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                float L = texture(uVorticity, vUv - vec2(uTexelSize.x, 0)).x;
                float R = texture(uVorticity, vUv + vec2(uTexelSize.x, 0)).x;
                float T = texture(uVorticity, vUv + vec2(0, uTexelSize.y)).x;
                float B = texture(uVorticity, vUv - vec2(0, uTexelSize.y)).x;
                float C = texture(uVorticity, vUv).x;

                vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                force /= length(force) + 0.0001;
                force *= uStrength * C;
                force.y *= -1.0;

                vec2 vel = texture(uVelocity, vUv).xy + force * uDt;
                fragColor = vec4(vel, 0, 1);
            }
        `;

        const buoyancyShader = `#version 300 es
            precision highp float;
            uniform sampler2D uVelocity;
            uniform sampler2D uDensity;
            uniform float uBuoyancy;
            uniform float uDt;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                vec2 vel = texture(uVelocity, vUv).xy;
                float density = texture(uDensity, vUv).x;
                vel.y -= uBuoyancy * density * uDt;
                fragColor = vec4(vel, 0, 1);
            }
        `;

        const splatShader = `#version 300 es
            precision highp float;
            uniform sampler2D uTarget;
            uniform vec2 uPoint;
            uniform vec3 uColor;
            uniform float uRadius;
            uniform float uAspect;
            in vec2 vUv;
            out vec4 fragColor;

            void main() {
                vec2 p = vUv - uPoint;
                p.x *= uAspect;
                float splat = exp(-dot(p, p) / uRadius);
                vec3 base = texture(uTarget, vUv).xyz;
                fragColor = vec4(base + uColor * splat, 1);
            }
        `;

        const displayShader = `#version 300 es
            precision highp float;
            uniform sampler2D uDensity;
            uniform sampler2D uVelocity;
            uniform int uMode;
            in vec2 vUv;
            out vec4 fragColor;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                float d = texture(uDensity, vUv).x;
                vec2 v = texture(uVelocity, vUv).xy;

                vec3 color;

                if (uMode == 0) {
                    // Classic smoke
                    color = vec3(d * 0.8, d * 0.85, d * 0.9);
                } else if (uMode == 1) {
                    // Fire
                    color = vec3(d * 1.2, d * 0.5, d * 0.1);
                    color = pow(color, vec3(0.8));
                } else if (uMode == 2) {
                    // Rainbow velocity
                    float angle = atan(v.y, v.x) / 6.28318 + 0.5;
                    float mag = length(v) * 10.0;
                    color = hsv2rgb(vec3(angle, 0.8, min(1.0, mag + d * 0.5)));
                } else if (uMode == 3) {
                    // Ink
                    color = vec3(0.1, 0.1 + d * 0.3, 0.2 + d * 0.6);
                } else {
                    // Thermal
                    float t = d;
                    if (t < 0.5) {
                        color = mix(vec3(0, 0, 0.2), vec3(1, 0.3, 0), t * 2.0);
                    } else {
                        color = mix(vec3(1, 0.3, 0), vec3(1, 1, 0.5), (t - 0.5) * 2.0);
                    }
                }

                fragColor = vec4(color, 1);
            }
        `;

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vs));
            gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fs));
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Programs
        let programs = {};

        function initPrograms() {
            programs.advect = createProgram(vertexShader, advectShader);
            programs.divergence = createProgram(vertexShader, divergenceShader);
            programs.pressure = createProgram(vertexShader, pressureShader);
            programs.gradientSubtract = createProgram(vertexShader, gradientSubtractShader);
            programs.vorticity = createProgram(vertexShader, vorticityShader);
            programs.vorticityForce = createProgram(vertexShader, vorticityForceShader);
            programs.buoyancy = createProgram(vertexShader, buoyancyShader);
            programs.splat = createProgram(vertexShader, splatShader);
            programs.display = createProgram(vertexShader, displayShader);
        }

        // Create texture
        function createTexture(w, h) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return tex;
        }

        // Create framebuffer
        function createFBO(tex) {
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            return fbo;
        }

        // Quad
        let quadVAO;

        function initQuad() {
            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            quadVAO = gl.createVertexArray();
            gl.bindVertexArray(quadVAO);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = Math.floor(canvas.width / SCALE);
            height = Math.floor(canvas.height / SCALE);

            // Recreate textures
            velocityTextures = [createTexture(width, height), createTexture(width, height)];
            densityTextures = [createTexture(width, height), createTexture(width, height)];
            pressureTextures = [createTexture(width, height), createTexture(width, height)];
            divergenceTexture = createTexture(width, height);
            vorticityTexture = createTexture(width, height);

            framebuffers = {
                velocity: [createFBO(velocityTextures[0]), createFBO(velocityTextures[1])],
                density: [createFBO(densityTextures[0]), createFBO(densityTextures[1])],
                pressure: [createFBO(pressureTextures[0]), createFBO(pressureTextures[1])],
                divergence: createFBO(divergenceTexture),
                vorticity: createFBO(vorticityTexture)
            };

            currentVel = 0;
            currentDen = 0;
            currentPres = 0;
        }

        function drawQuad() {
            gl.bindVertexArray(quadVAO);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function advect(fbo, texTarget, velTex, sourceTex, dissipation) {
            const prog = programs.advect;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(prog, 'uSource'), 1);
            gl.uniform1f(gl.getUniformLocation(prog, 'uDt'), 0.016);
            gl.uniform1f(gl.getUniformLocation(prog, 'uDissipation'), dissipation);
            gl.uniform2f(gl.getUniformLocation(prog, 'uTexelSize'), 1 / width, 1 / height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velTex);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, sourceTex);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            drawQuad();
        }

        function splat(fbo, tex, x, y, dx, dy, color) {
            const prog = programs.splat;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uTarget'), 0);
            gl.uniform2f(gl.getUniformLocation(prog, 'uPoint'), x / canvas.width, 1 - y / canvas.height);
            gl.uniform3f(gl.getUniformLocation(prog, 'uColor'), color[0], color[1], color[2]);
            gl.uniform1f(gl.getUniformLocation(prog, 'uRadius'), 0.0003);
            gl.uniform1f(gl.getUniformLocation(prog, 'uAspect'), canvas.width / canvas.height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            drawQuad();
        }

        function computeDivergence() {
            const prog = programs.divergence;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 0);
            gl.uniform2f(gl.getUniformLocation(prog, 'uTexelSize'), 1 / width, 1 / height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocityTextures[currentVel]);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.divergence);
            drawQuad();
        }

        function solvePressure() {
            const prog = programs.pressure;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uPressure'), 0);
            gl.uniform1i(gl.getUniformLocation(prog, 'uDivergence'), 1);
            gl.uniform2f(gl.getUniformLocation(prog, 'uTexelSize'), 1 / width, 1 / height);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, divergenceTexture);

            for (let i = 0; i < 20; i++) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, pressureTextures[currentPres]);

                gl.viewport(0, 0, width, height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.pressure[1 - currentPres]);
                drawQuad();
                currentPres = 1 - currentPres;
            }
        }

        function subtractGradient() {
            const prog = programs.gradientSubtract;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uPressure'), 0);
            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 1);
            gl.uniform2f(gl.getUniformLocation(prog, 'uTexelSize'), 1 / width, 1 / height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressureTextures[currentPres]);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocityTextures[currentVel]);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.velocity[1 - currentVel]);
            drawQuad();
            currentVel = 1 - currentVel;
        }

        function computeVorticity() {
            const prog = programs.vorticity;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 0);
            gl.uniform2f(gl.getUniformLocation(prog, 'uTexelSize'), 1 / width, 1 / height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocityTextures[currentVel]);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.vorticity);
            drawQuad();
        }

        function applyVorticityForce() {
            const prog = programs.vorticityForce;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(prog, 'uVorticity'), 1);
            gl.uniform1f(gl.getUniformLocation(prog, 'uStrength'), vorticityStrength);
            gl.uniform1f(gl.getUniformLocation(prog, 'uDt'), 0.016);
            gl.uniform2f(gl.getUniformLocation(prog, 'uTexelSize'), 1 / width, 1 / height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocityTextures[currentVel]);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, vorticityTexture);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.velocity[1 - currentVel]);
            drawQuad();
            currentVel = 1 - currentVel;
        }

        function applyBuoyancy() {
            const prog = programs.buoyancy;
            gl.useProgram(prog);

            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(prog, 'uDensity'), 1);
            gl.uniform1f(gl.getUniformLocation(prog, 'uBuoyancy'), buoyancy);
            gl.uniform1f(gl.getUniformLocation(prog, 'uDt'), 0.016);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocityTextures[currentVel]);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, densityTextures[currentDen]);

            gl.viewport(0, 0, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.velocity[1 - currentVel]);
            drawQuad();
            currentVel = 1 - currentVel;
        }

        function display() {
            const prog = programs.display;
            gl.useProgram(prog);

            const modes = { smoke: 0, fire: 1, rainbow: 2, ink: 3, thermal: 4 };
            gl.uniform1i(gl.getUniformLocation(prog, 'uDensity'), 0);
            gl.uniform1i(gl.getUniformLocation(prog, 'uVelocity'), 1);
            gl.uniform1i(gl.getUniformLocation(prog, 'uMode'), modes[colorMode] || 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, densityTextures[currentDen]);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocityTextures[currentVel]);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            drawQuad();
        }

        // Mouse handling
        let mouse = { x: 0, y: 0, prevX: 0, prevY: 0, down: false };

        canvas.addEventListener('mousedown', (e) => {
            mouse.down = true;
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.prevX = e.clientX;
            mouse.prevY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (mouse.down) {
                const dx = (mouse.x - mouse.prevX) * 5;
                const dy = (mouse.y - mouse.prevY) * 5;

                // Add velocity
                splat(
                    framebuffers.velocity[1 - currentVel],
                    velocityTextures[currentVel],
                    mouse.x, mouse.y, dx, dy,
                    [dx, -dy, 0]
                );
                currentVel = 1 - currentVel;

                // Add density
                splat(
                    framebuffers.density[1 - currentDen],
                    densityTextures[currentDen],
                    mouse.x, mouse.y, dx, dy,
                    [0.8, 0.8, 0.8]
                );
                currentDen = 1 - currentDen;
            }
        });

        canvas.addEventListener('mouseup', () => mouse.down = false);
        canvas.addEventListener('mouseleave', () => mouse.down = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.down = true;
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
            mouse.prevX = touch.clientX;
            mouse.prevY = touch.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;

            if (mouse.down) {
                const dx = (mouse.x - mouse.prevX) * 5;
                const dy = (mouse.y - mouse.prevY) * 5;

                splat(
                    framebuffers.velocity[1 - currentVel],
                    velocityTextures[currentVel],
                    mouse.x, mouse.y, dx, dy,
                    [dx, -dy, 0]
                );
                currentVel = 1 - currentVel;

                splat(
                    framebuffers.density[1 - currentDen],
                    densityTextures[currentDen],
                    mouse.x, mouse.y, dx, dy,
                    [0.8, 0.8, 0.8]
                );
                currentDen = 1 - currentDen;
            }
        });

        canvas.addEventListener('touchend', () => mouse.down = false);

        function clearSimulation() {
            resize();
        }

        function addBurst() {
            const cx = canvas.width / 2;
            const cy = canvas.height * 0.7;

            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const x = cx + Math.cos(angle) * 50;
                const y = cy + Math.sin(angle) * 50;

                splat(
                    framebuffers.velocity[1 - currentVel],
                    velocityTextures[currentVel],
                    x, y, 0, 0,
                    [0, -30, 0]
                );
                currentVel = 1 - currentVel;

                splat(
                    framebuffers.density[1 - currentDen],
                    densityTextures[currentDen],
                    x, y, 0, 0,
                    [1, 1, 1]
                );
                currentDen = 1 - currentDen;
            }
        }

        function loadPreset(name) {
            const presets = {
                steam: { visc: 0.00002, diff: 0.00005, buoy: 0.8, vort: 0.2 },
                thick: { visc: 0.0002, diff: 0.0003, buoy: 0.3, vort: 0.1 },
                wispy: { visc: 0.00001, diff: 0.00001, buoy: 0.6, vort: 0.5 },
                turbulent: { visc: 0.00003, diff: 0.00008, buoy: 0.4, vort: 0.8 }
            };

            const p = presets[name];
            viscosity = p.visc;
            diffusion = p.diff;
            buoyancy = p.buoy;
            vorticityStrength = p.vort;

            document.getElementById('viscosity').value = p.visc;
            document.getElementById('diffusion').value = p.diff;
            document.getElementById('buoyancy').value = p.buoy;
            document.getElementById('vorticity').value = p.vort;

            document.getElementById('viscVal').textContent = p.visc.toFixed(5);
            document.getElementById('diffVal').textContent = p.diff.toFixed(4);
            document.getElementById('buoyVal').textContent = p.buoy.toFixed(1);
            document.getElementById('vortVal').textContent = p.vort.toFixed(1);
        }

        // UI handlers
        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscVal').textContent = viscosity.toFixed(5);
        });

        document.getElementById('diffusion').addEventListener('input', (e) => {
            diffusion = parseFloat(e.target.value);
            document.getElementById('diffVal').textContent = diffusion.toFixed(4);
        });

        document.getElementById('buoyancy').addEventListener('input', (e) => {
            buoyancy = parseFloat(e.target.value);
            document.getElementById('buoyVal').textContent = buoyancy.toFixed(1);
        });

        document.getElementById('vorticity').addEventListener('input', (e) => {
            vorticityStrength = parseFloat(e.target.value);
            document.getElementById('vortVal').textContent = vorticityStrength.toFixed(1);
        });

        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
        });

        function step() {
            // Advect velocity
            advect(
                framebuffers.velocity[1 - currentVel],
                velocityTextures[1 - currentVel],
                velocityTextures[currentVel],
                velocityTextures[currentVel],
                1 - viscosity * 100
            );
            currentVel = 1 - currentVel;

            // Advect density
            advect(
                framebuffers.density[1 - currentDen],
                densityTextures[1 - currentDen],
                velocityTextures[currentVel],
                densityTextures[currentDen],
                1 - diffusion * 100
            );
            currentDen = 1 - currentDen;

            // Vorticity confinement
            computeVorticity();
            applyVorticityForce();

            // Buoyancy
            applyBuoyancy();

            // Pressure solve for incompressibility
            computeDivergence();
            solvePressure();
            subtractGradient();
        }

        function animate() {
            step();
            display();
            requestAnimationFrame(animate);
        }

        // Initialize
        window.addEventListener('resize', resize);
        initQuad();
        initPrograms();
        resize();
        animate();
    </script>
</body>
</html>
