<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Body Physics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a0a2e 0%, #16132b 100%);
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(26, 10, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(180, 100, 255, 0.3);
            z-index: 100;
            min-width: 260px;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            color: #b464ff;
        }

        .subtitle {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            padding: 0;
            background: rgba(60, 40, 90, 0.8);
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #b464ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #7b2cbf, #b464ff);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(180, 100, 255, 0.4);
        }

        .physics {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 10, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(180, 100, 255, 0.3);
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            max-width: 250px;
        }

        .physics h3 {
            color: #b464ff;
            margin-bottom: 10px;
        }

        .physics p {
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.5;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 10, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.85em;
            border: 1px solid rgba(180, 100, 255, 0.3);
            color: #aaa;
            font-family: 'Segoe UI', sans-serif;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            gap: 15px;
        }

        .info-value {
            color: #b464ff;
            font-family: 'Consolas', monospace;
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #b464ff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(26, 10, 46, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(180, 100, 255, 0.3);
            font-family: 'Segoe UI', sans-serif;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(180, 100, 255, 0.1);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>ü´ß Soft Body Physics</h1>
        <p class="subtitle">Pressure-Based Deformation</p>

        <div class="control-group">
            <label>Stiffness: <span id="stiffValue">100</span></label>
            <input type="range" id="stiffness" min="20" max="300" value="100">
        </div>

        <div class="control-group">
            <label>Pressure: <span id="pressValue">50</span></label>
            <input type="range" id="pressure" min="0" max="150" value="50">
        </div>

        <div class="control-group">
            <label>Damping: <span id="dampValue">0.98</span></label>
            <input type="range" id="damping" min="0.9" max="1" step="0.005" value="0.98">
        </div>

        <div class="control-group">
            <label>Gravity: <span id="gravValue">0.5</span></label>
            <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="btn-row">
            <button onclick="addBlob()">Add Blob</button>
            <button onclick="addCube()">Add Cube</button>
        </div>
        <div class="btn-row">
            <button onclick="reset()">Reset</button>
            <button onclick="shake()">Shake!</button>
        </div>
    </div>

    <div class="physics">
        <h3>How It Works</h3>
        <p>Each soft body is a mesh of mass points connected by springs. Internal pressure pushes outward, maintaining volume while allowing deformation.</p>
        <p style="margin-top: 10px; color: #b464ff;">Click and drag to interact!</p>
    </div>

    <div class="info">
        <div class="info-row">
            <span>Bodies:</span>
            <span class="info-value" id="bodyCount">0</span>
        </div>
        <div class="info-row">
            <span>Particles:</span>
            <span class="info-value" id="particleCount">0</span>
        </div>
        <div class="info-row">
            <span>FPS:</span>
            <span class="info-value" id="fps">60</span>
        </div>
    </div>

    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let stiffness = 100;
        let pressure = 50;
        let damping = 0.98;
        let gravity = 0.5;

        let softBodies = [];
        let dragging = null;
        let dragOffset = { x: 0, y: 0 };

        let frameCount = 0;
        let lastFpsTime = performance.now();

        class SoftBody {
            constructor(x, y, radius, sides, color) {
                this.points = [];
                this.springs = [];
                this.color = color;
                this.restArea = 0;

                // Create perimeter points
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    this.points.push({
                        x: x + Math.cos(angle) * radius,
                        y: y + Math.sin(angle) * radius,
                        prevX: x + Math.cos(angle) * radius,
                        prevY: y + Math.sin(angle) * radius,
                        mass: 1
                    });
                }

                // Add center point for stability
                this.points.push({
                    x: x,
                    y: y,
                    prevX: x,
                    prevY: y,
                    mass: 2
                });

                const centerIdx = this.points.length - 1;

                // Create springs
                for (let i = 0; i < sides; i++) {
                    // Edge springs
                    const next = (i + 1) % sides;
                    const restLen = this.distance(this.points[i], this.points[next]);
                    this.springs.push({
                        a: i,
                        b: next,
                        restLength: restLen
                    });

                    // Springs to center
                    const centerLen = this.distance(this.points[i], this.points[centerIdx]);
                    this.springs.push({
                        a: i,
                        b: centerIdx,
                        restLength: centerLen
                    });

                    // Cross springs for stability
                    const across = (i + Math.floor(sides / 2)) % sides;
                    const acrossLen = this.distance(this.points[i], this.points[across]);
                    this.springs.push({
                        a: i,
                        b: across,
                        restLength: acrossLen
                    });
                }

                this.restArea = this.calculateArea();
            }

            distance(a, b) {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            calculateArea() {
                let area = 0;
                const n = this.points.length - 1; // Exclude center
                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += this.points[i].x * this.points[j].y;
                    area -= this.points[j].x * this.points[i].y;
                }
                return Math.abs(area) / 2;
            }

            getCenter() {
                let cx = 0, cy = 0;
                for (const p of this.points) {
                    cx += p.x;
                    cy += p.y;
                }
                return {
                    x: cx / this.points.length,
                    y: cy / this.points.length
                };
            }

            containsPoint(px, py) {
                const center = this.getCenter();
                const dx = px - center.x;
                const dy = py - center.y;
                return Math.sqrt(dx * dx + dy * dy) < 80;
            }

            update() {
                // Verlet integration
                for (const p of this.points) {
                    const vx = (p.x - p.prevX) * damping;
                    const vy = (p.y - p.prevY) * damping;

                    p.prevX = p.x;
                    p.prevY = p.y;

                    p.x += vx;
                    p.y += vy + gravity;
                }

                // Apply spring constraints
                for (let iter = 0; iter < 3; iter++) {
                    for (const spring of this.springs) {
                        const a = this.points[spring.a];
                        const b = this.points[spring.b];

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist === 0) continue;

                        const diff = (dist - spring.restLength) / dist;
                        const force = diff * stiffness * 0.01;

                        const fx = dx * force;
                        const fy = dy * force;

                        const totalMass = a.mass + b.mass;
                        a.x += fx * (b.mass / totalMass);
                        a.y += fy * (b.mass / totalMass);
                        b.x -= fx * (a.mass / totalMass);
                        b.y -= fy * (a.mass / totalMass);
                    }
                }

                // Apply pressure
                const currentArea = this.calculateArea();
                const areaDiff = this.restArea - currentArea;
                const pressureForce = pressure * 0.001 * Math.sign(areaDiff) * Math.sqrt(Math.abs(areaDiff));

                const center = this.getCenter();
                const n = this.points.length - 1;

                for (let i = 0; i < n; i++) {
                    const p = this.points[i];
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        p.x += (dx / dist) * pressureForce;
                        p.y += (dy / dist) * pressureForce;
                    }
                }

                // Boundary constraints
                for (const p of this.points) {
                    if (p.y > canvas.height - 20) {
                        p.y = canvas.height - 20;
                        p.prevY = p.y + (p.y - p.prevY) * 0.3;
                    }
                    if (p.x < 20) {
                        p.x = 20;
                        p.prevX = p.x + (p.x - p.prevX) * 0.3;
                    }
                    if (p.x > canvas.width - 20) {
                        p.x = canvas.width - 20;
                        p.prevX = p.x + (p.x - p.prevX) * 0.3;
                    }
                    if (p.y < 20) {
                        p.y = 20;
                        p.prevY = p.y + (p.y - p.prevY) * 0.3;
                    }
                }
            }

            draw() {
                const n = this.points.length - 1;

                // Draw fill
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < n; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();

                // Gradient fill
                const center = this.getCenter();
                const gradient = ctx.createRadialGradient(
                    center.x - 20, center.y - 20, 0,
                    center.x, center.y, 80
                );
                gradient.addColorStop(0, this.color.replace('0.6', '0.8'));
                gradient.addColorStop(1, this.color);

                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw outline
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw internal structure
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;

                const centerPt = this.points[n];
                for (let i = 0; i < n; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[i].x, this.points[i].y);
                    ctx.lineTo(centerPt.x, centerPt.y);
                    ctx.stroke();
                }

                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.ellipse(center.x - 15, center.y - 15, 15, 10, -0.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function randomColor() {
            const hues = [280, 320, 200, 160, 30]; // Purple, pink, cyan, green, orange
            const hue = hues[Math.floor(Math.random() * hues.length)];
            return `hsla(${hue}, 70%, 50%, 0.6)`;
        }

        function addBlob() {
            const x = 100 + Math.random() * (canvas.width - 200);
            const y = 100 + Math.random() * 200;
            const radius = 40 + Math.random() * 30;
            const sides = 12 + Math.floor(Math.random() * 8);
            softBodies.push(new SoftBody(x, y, radius, sides, randomColor()));
        }

        function addCube() {
            const x = 100 + Math.random() * (canvas.width - 200);
            const y = 100 + Math.random() * 200;
            const radius = 40 + Math.random() * 20;
            softBodies.push(new SoftBody(x, y, radius, 4, randomColor()));
        }

        function reset() {
            softBodies = [];
            for (let i = 0; i < 5; i++) {
                addBlob();
            }
        }

        function shake() {
            for (const body of softBodies) {
                for (const p of body.points) {
                    p.x += (Math.random() - 0.5) * 50;
                    p.y += (Math.random() - 0.5) * 50 - 30;
                }
            }
        }

        // Collision between soft bodies
        function checkSoftBodyCollisions() {
            for (let i = 0; i < softBodies.length; i++) {
                for (let j = i + 1; j < softBodies.length; j++) {
                    const bodyA = softBodies[i];
                    const bodyB = softBodies[j];

                    // Check point-to-boundary collisions
                    const nA = bodyA.points.length - 1;
                    const nB = bodyB.points.length - 1;

                    for (let pi = 0; pi < nA; pi++) {
                        const p = bodyA.points[pi];
                        if (pointInPolygon(p, bodyB.points.slice(0, nB))) {
                            // Push out
                            const center = bodyB.getCenter();
                            const dx = p.x - center.x;
                            const dy = p.y - center.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                const push = 2;
                                p.x += (dx / dist) * push;
                                p.y += (dy / dist) * push;
                            }
                        }
                    }

                    for (let pi = 0; pi < nB; pi++) {
                        const p = bodyB.points[pi];
                        if (pointInPolygon(p, bodyA.points.slice(0, nA))) {
                            const center = bodyA.getCenter();
                            const dx = p.x - center.x;
                            const dy = p.y - center.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                const push = 2;
                                p.x += (dx / dist) * push;
                                p.y += (dy / dist) * push;
                            }
                        }
                    }
                }
            }
        }

        function pointInPolygon(point, vertices) {
            let inside = false;
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                const xi = vertices[i].x, yi = vertices[i].y;
                const xj = vertices[j].x, yj = vertices[j].y;
                if (((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            for (const body of softBodies) {
                if (body.containsPoint(mx, my)) {
                    dragging = body;
                    const center = body.getCenter();
                    dragOffset = { x: mx - center.x, y: my - center.y };
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (dragging) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                const targetX = mx - dragOffset.x;
                const targetY = my - dragOffset.y;
                const center = dragging.getCenter();

                const dx = targetX - center.x;
                const dy = targetY - center.y;

                for (const p of dragging.points) {
                    p.x += dx * 0.5;
                    p.y += dy * 0.5;
                    p.prevX = p.x;
                    p.prevY = p.y;
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = null;
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;

            for (const body of softBodies) {
                if (body.containsPoint(mx, my)) {
                    dragging = body;
                    const center = body.getCenter();
                    dragOffset = { x: mx - center.x, y: my - center.y };
                    break;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (dragging) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const mx = touch.clientX - rect.left;
                const my = touch.clientY - rect.top;

                const targetX = mx - dragOffset.x;
                const targetY = my - dragOffset.y;
                const center = dragging.getCenter();

                const dx = targetX - center.x;
                const dy = targetY - center.y;

                for (const p of dragging.points) {
                    p.x += dx * 0.5;
                    p.y += dy * 0.5;
                    p.prevX = p.x;
                    p.prevY = p.y;
                }
            }
        });

        canvas.addEventListener('touchend', () => {
            dragging = null;
        });

        // UI handlers
        document.getElementById('stiffness').addEventListener('input', (e) => {
            stiffness = parseFloat(e.target.value);
            document.getElementById('stiffValue').textContent = stiffness;
        });

        document.getElementById('pressure').addEventListener('input', (e) => {
            pressure = parseFloat(e.target.value);
            document.getElementById('pressValue').textContent = pressure;
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            damping = parseFloat(e.target.value);
            document.getElementById('dampValue').textContent = damping.toFixed(3);
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravValue').textContent = gravity.toFixed(1);
        });

        function draw() {
            ctx.fillStyle = '#1a0a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = 'rgba(180, 100, 255, 0.1)';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

            // Draw soft bodies
            for (const body of softBodies) {
                body.draw();
            }

            // Stats
            let totalParticles = 0;
            for (const body of softBodies) {
                totalParticles += body.points.length;
            }
            document.getElementById('bodyCount').textContent = softBodies.length;
            document.getElementById('particleCount').textContent = totalParticles;
        }

        function update() {
            for (const body of softBodies) {
                body.update();
            }
            checkSoftBodyCollisions();
        }

        function animate() {
            update();
            draw();

            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(animate);
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = reset;

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        reset();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
