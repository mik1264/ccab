<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Colony Optimization - Traveling Salesman - CCAB</title>
    <meta name="description" content="Watch virtual ants solve the Traveling Salesman Problem using pheromone trails. Interactive visualization of the Ant Colony Optimization algorithm.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #8bc34a;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 195, 74, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(139, 195, 74, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            color: #8bc34a;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 195, 74, 0.2);
            z-index: 1000;
            max-width: 300px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #aaa;
            font-size: 11px;
        }

        #info .stat-value {
            color: #8bc34a;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 280px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(139, 195, 74, 0.15);
            border: 1px solid rgba(139, 195, 74, 0.4);
            color: #8bc34a;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(139, 195, 74, 0.3);
        }

        button.active {
            background: rgba(139, 195, 74, 0.4);
            border-color: #8bc34a;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 195, 74, 0.2);
        }

        .control-group label {
            color: #8bc34a;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #8bc34a;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #8bc34a;
            font-size: 12px;
            z-index: 1000;
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(139, 195, 74, 0.6);
            font-size: 12px;
            z-index: 1000;
            text-align: center;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Ant Colony Optimization</h3>
        <div class="stat">
            <span class="stat-label">Cities</span>
            <span class="stat-value" id="city-count">20</span>
        </div>
        <div class="stat">
            <span class="stat-label">Ants</span>
            <span class="stat-value" id="ant-count">30</span>
        </div>
        <div class="stat">
            <span class="stat-label">Iteration</span>
            <span class="stat-value" id="iteration">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Best Tour Length</span>
            <span class="stat-value" id="best-length">-</span>
        </div>
        <div class="stat">
            <span class="stat-label">Improvement</span>
            <span class="stat-value" id="improvement">0%</span>
        </div>
        <p>Virtual ants deposit pheromones on paths. Shorter paths get more pheromone, attracting more ants. Click to add cities.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="small">Small (15 cities)</button>
        <button data-preset="medium">Medium (25 cities)</button>
        <button data-preset="large">Large (40 cities)</button>
        <button data-preset="circle">Circle Pattern</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Evaporation (ρ): <span id="rho-val">0.1</span></label>
            <input type="range" id="rho" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>
        <div class="control-group">
            <label>Alpha (α): <span id="alpha-val">1.0</span></label>
            <input type="range" id="alpha" min="0.5" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Beta (β): <span id="beta-val">2.0</span></label>
            <input type="range" id="beta" min="0.5" max="5" step="0.1" value="2">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-val">1x</span></label>
            <input type="range" id="speed" min="1" max="10" step="1" value="1">
        </div>
    </div>

    <div id="instructions">Click to add cities • Press R to reset</div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // DOM elements
        const cityCountDisplay = document.getElementById('city-count');
        const antCountDisplay = document.getElementById('ant-count');
        const iterationDisplay = document.getElementById('iteration');
        const bestLengthDisplay = document.getElementById('best-length');
        const improvementDisplay = document.getElementById('improvement');
        const fpsDisplay = document.getElementById('fps');
        const rhoSlider = document.getElementById('rho');
        const rhoVal = document.getElementById('rho-val');
        const alphaSlider = document.getElementById('alpha');
        const alphaVal = document.getElementById('alpha-val');
        const betaSlider = document.getElementById('beta');
        const betaVal = document.getElementById('beta-val');
        const speedSlider = document.getElementById('speed');
        const speedVal = document.getElementById('speed-val');

        // Configuration
        let config = {
            rho: 0.1,      // Evaporation rate
            alpha: 1.0,    // Pheromone influence
            beta: 2.0,     // Distance influence
            Q: 100,        // Pheromone deposit constant
            speed: 1,
            numAnts: 30
        };

        // State
        let cities = [];
        let pheromone = [];
        let distance = [];
        let ants = [];
        let bestTour = null;
        let bestLength = Infinity;
        let initialBestLength = Infinity;
        let iteration = 0;
        let running = true;

        // City class
        class City {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
            }
        }

        // Ant class
        class Ant {
            constructor(startCity) {
                this.tour = [startCity];
                this.visited = new Set([startCity]);
                this.tourLength = 0;
                this.currentCity = startCity;
                this.progress = 0; // Animation progress
                this.nextCity = null;
            }

            reset(startCity) {
                this.tour = [startCity];
                this.visited = new Set([startCity]);
                this.tourLength = 0;
                this.currentCity = startCity;
                this.progress = 0;
                this.nextCity = null;
            }

            selectNextCity() {
                const current = this.currentCity;
                const unvisited = [];
                const probabilities = [];
                let total = 0;

                // Calculate probabilities for unvisited cities
                for (let i = 0; i < cities.length; i++) {
                    if (!this.visited.has(i)) {
                        const tau = Math.pow(pheromone[current][i], config.alpha);
                        const eta = Math.pow(1 / distance[current][i], config.beta);
                        const prob = tau * eta;
                        unvisited.push(i);
                        probabilities.push(prob);
                        total += prob;
                    }
                }

                if (unvisited.length === 0) {
                    // Return to start
                    this.nextCity = this.tour[0];
                    return;
                }

                // Roulette wheel selection
                let rand = Math.random() * total;
                let cumulative = 0;
                for (let i = 0; i < unvisited.length; i++) {
                    cumulative += probabilities[i];
                    if (rand <= cumulative) {
                        this.nextCity = unvisited[i];
                        return;
                    }
                }

                this.nextCity = unvisited[unvisited.length - 1];
            }

            moveToNext() {
                if (this.nextCity === null) return;

                this.tourLength += distance[this.currentCity][this.nextCity];
                this.tour.push(this.nextCity);
                this.visited.add(this.nextCity);
                this.currentCity = this.nextCity;
                this.nextCity = null;
                this.progress = 0;
            }

            isComplete() {
                return this.tour.length === cities.length + 1;
            }
        }

        // Initialize cities
        function initCities(preset) {
            cities = [];
            const margin = 100;
            const w = canvas.width - margin * 2;
            const h = canvas.height - margin * 2;

            let numCities;
            switch (preset) {
                case 'small': numCities = 15; break;
                case 'medium': numCities = 25; break;
                case 'large': numCities = 40; break;
                case 'circle': numCities = 20; break;
                default: numCities = 20;
            }

            if (preset === 'circle') {
                // Arrange in circle
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const radius = Math.min(w, h) / 2.5;
                for (let i = 0; i < numCities; i++) {
                    const angle = (2 * Math.PI * i) / numCities;
                    cities.push(new City(
                        cx + Math.cos(angle) * radius,
                        cy + Math.sin(angle) * radius,
                        i
                    ));
                }
            } else {
                // Random placement
                for (let i = 0; i < numCities; i++) {
                    cities.push(new City(
                        margin + Math.random() * w,
                        margin + Math.random() * h,
                        i
                    ));
                }
            }

            initMatrices();
            initAnts();
            bestTour = null;
            bestLength = Infinity;
            initialBestLength = Infinity;
            iteration = 0;
        }

        // Initialize distance and pheromone matrices
        function initMatrices() {
            const n = cities.length;
            distance = Array(n).fill(null).map(() => Array(n).fill(0));
            pheromone = Array(n).fill(null).map(() => Array(n).fill(1));

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const dx = cities[i].x - cities[j].x;
                        const dy = cities[i].y - cities[j].y;
                        distance[i][j] = Math.sqrt(dx * dx + dy * dy);
                    }
                }
            }
        }

        // Initialize ants
        function initAnts() {
            ants = [];
            config.numAnts = Math.max(10, Math.floor(cities.length * 1.5));
            for (let i = 0; i < config.numAnts; i++) {
                const startCity = Math.floor(Math.random() * cities.length);
                ants.push(new Ant(startCity));
            }
        }

        // Update pheromones
        function updatePheromones() {
            const n = cities.length;

            // Evaporation
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    pheromone[i][j] *= (1 - config.rho);
                    // Minimum pheromone level
                    pheromone[i][j] = Math.max(0.01, pheromone[i][j]);
                }
            }

            // Deposit pheromones
            for (const ant of ants) {
                if (ant.isComplete()) {
                    const deposit = config.Q / ant.tourLength;
                    for (let i = 0; i < ant.tour.length - 1; i++) {
                        const from = ant.tour[i];
                        const to = ant.tour[i + 1];
                        pheromone[from][to] += deposit;
                        pheromone[to][from] += deposit;
                    }

                    // Track best tour
                    if (ant.tourLength < bestLength) {
                        bestLength = ant.tourLength;
                        bestTour = [...ant.tour];
                        if (initialBestLength === Infinity) {
                            initialBestLength = bestLength;
                        }
                    }
                }
            }
        }

        // Run one iteration
        function runIteration() {
            // Reset ants
            for (const ant of ants) {
                const startCity = Math.floor(Math.random() * cities.length);
                ant.reset(startCity);
            }

            // Each ant builds a complete tour
            for (let step = 0; step < cities.length; step++) {
                for (const ant of ants) {
                    if (!ant.isComplete()) {
                        ant.selectNextCity();
                        ant.moveToNext();
                    }
                }
            }

            // Close tours (return to start)
            for (const ant of ants) {
                if (ant.tour.length === cities.length) {
                    ant.tourLength += distance[ant.currentCity][ant.tour[0]];
                    ant.tour.push(ant.tour[0]);
                }
            }

            updatePheromones();
            iteration++;
        }

        // Draw function
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (cities.length < 2) return;

            // Draw pheromone trails
            const maxPheromone = Math.max(...pheromone.flat());
            for (let i = 0; i < cities.length; i++) {
                for (let j = i + 1; j < cities.length; j++) {
                    const strength = pheromone[i][j] / maxPheromone;
                    if (strength > 0.1) {
                        ctx.strokeStyle = `rgba(139, 195, 74, ${strength * 0.5})`;
                        ctx.lineWidth = 1 + strength * 3;
                        ctx.beginPath();
                        ctx.moveTo(cities[i].x, cities[i].y);
                        ctx.lineTo(cities[j].x, cities[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw best tour
            if (bestTour && bestTour.length > 1) {
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(cities[bestTour[0]].x, cities[bestTour[0]].y);
                for (let i = 1; i < bestTour.length; i++) {
                    ctx.lineTo(cities[bestTour[i]].x, cities[bestTour[i]].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw cities
            for (const city of cities) {
                // Outer glow
                ctx.fillStyle = 'rgba(139, 195, 74, 0.3)';
                ctx.beginPath();
                ctx.arc(city.x, city.y, 15, 0, Math.PI * 2);
                ctx.fill();

                // City circle
                ctx.fillStyle = '#8bc34a';
                ctx.beginPath();
                ctx.arc(city.x, city.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // City number
                ctx.fillStyle = '#1a1a2e';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(city.id + 1, city.x, city.y);
            }

            // Draw ants
            for (const ant of ants) {
                if (ant.tour.length > 0 && !ant.isComplete()) {
                    const fromCity = cities[ant.currentCity];
                    let toCity = ant.nextCity !== null ? cities[ant.nextCity] : fromCity;

                    const x = fromCity.x + (toCity.x - fromCity.x) * ant.progress;
                    const y = fromCity.y + (toCity.y - fromCity.y) * ant.progress;

                    // Ant body
                    ctx.fillStyle = '#ff5722';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Update stats
            cityCountDisplay.textContent = cities.length;
            antCountDisplay.textContent = config.numAnts;
            iterationDisplay.textContent = iteration;
            bestLengthDisplay.textContent = bestLength === Infinity ? '-' : Math.round(bestLength);

            if (initialBestLength !== Infinity && bestLength !== Infinity) {
                const improvement = ((initialBestLength - bestLength) / initialBestLength * 100).toFixed(1);
                improvementDisplay.textContent = `${improvement}%`;
            }
        }

        // Animation loop
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        let iterationAccum = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            if (running && cities.length >= 2) {
                iterationAccum += config.speed;
                while (iterationAccum >= 10) {
                    runIteration();
                    iterationAccum -= 10;
                }
            }

            draw();
        }

        // Event listeners
        rhoSlider.addEventListener('input', (e) => {
            config.rho = parseFloat(e.target.value);
            rhoVal.textContent = config.rho.toFixed(2);
        });

        alphaSlider.addEventListener('input', (e) => {
            config.alpha = parseFloat(e.target.value);
            alphaVal.textContent = config.alpha.toFixed(1);
        });

        betaSlider.addEventListener('input', (e) => {
            config.beta = parseFloat(e.target.value);
            betaVal.textContent = config.beta.toFixed(1);
        });

        speedSlider.addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            speedVal.textContent = `${config.speed}x`;
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                initCities(btn.dataset.preset);
            });
        });

        // Click to add city
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Don't add if clicking near UI
            if (x > canvas.width - 320) return;

            cities.push(new City(x, y, cities.length));
            initMatrices();
            initAnts();
            // Don't reset best tour to show improvement
        });

        // Reset on R key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                initCities('small');
            }
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { initCities('small'); };
        window.init = function() { initCities('small'); };

        // Initialize
        initCities('small');
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
