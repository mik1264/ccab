<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Emergency Evacuation Routes</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 18px; font-family: sans-serif; z-index: 999; text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 999; }
.panel { background: rgba(0,0,0,0.75); color: #e0e0e0; padding: 12px 16px; border-radius: 8px; font-size: 13px; min-width: 210px; }
.panel label { display: block; margin: 6px 0 2px; color: #fbbf24; }
.panel input[type=range] { width: 100%; }
.panel button { background: #fbbf24; color: #0a0e1a; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 6px; width: 100%; }
.panel button:hover { background: #f59e0b; }
#stats { color: #aaa; margin-top: 8px; line-height: 1.6; }
.btn-group { display: flex; gap: 4px; margin-top: 6px; }
.btn-group button { flex: 1; font-size: 11px; }
.btn-active { background: #f59e0b !important; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Emergency Evacuation Routes</div>
<div id="ui">
    <div class="panel">
        <label>Agents: <span id="acVal">200</span></label>
        <input type="range" id="agentCount" min="50" max="500" value="200" step="10">
        <label>Panic Level: <span id="plVal">20</span>%</label>
        <input type="range" id="panicLevel" min="0" max="100" value="20">
        <label>Exit Width: <span id="ewVal">40</span></label>
        <input type="range" id="exitWidth" min="15" max="80" value="40">
        <div class="btn-group">
            <button id="btnCalm" class="btn-active">Calm</button>
            <button id="btnPanic">Full Panic</button>
        </div>
        <button id="startEvac">Start Evacuation</button>
        <button id="resetBtn">Reset</button>
        <div id="stats"></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;

    let agentCount = 200;
    let panicLevel = 20;
    let exitWidth = 40;
    let agents = [];
    let walls = [];
    let exits = [];
    let evacuating = false;
    let startTime = 0;
    let evacuatedCount = 0;
    let frame = 0;
    let evacuatedTimes = [];
    let buildingScale = 1;
    let buildingOffsetX = 0, buildingOffsetY = 0;

    // Building dimensions in abstract units
    const BW = 600, BH = 500;

    document.getElementById('agentCount').addEventListener('input', function() {
        agentCount = parseInt(this.value);
        document.getElementById('acVal').textContent = agentCount;
    });
    document.getElementById('panicLevel').addEventListener('input', function() {
        panicLevel = parseInt(this.value);
        document.getElementById('plVal').textContent = panicLevel;
    });
    document.getElementById('exitWidth').addEventListener('input', function() {
        exitWidth = parseInt(this.value);
        document.getElementById('ewVal').textContent = exitWidth;
        buildLayout();
    });
    document.getElementById('btnCalm').addEventListener('click', function() {
        panicLevel = 0;
        document.getElementById('panicLevel').value = 0;
        document.getElementById('plVal').textContent = '0';
        setActive(this);
    });
    document.getElementById('btnPanic').addEventListener('click', function() {
        panicLevel = 90;
        document.getElementById('panicLevel').value = 90;
        document.getElementById('plVal').textContent = '90';
        setActive(this);
    });
    document.getElementById('startEvac').addEventListener('click', function() {
        evacuating = true;
        startTime = frame;
    });
    document.getElementById('resetBtn').addEventListener('click', init);

    function setActive(btn) {
        document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('btn-active'));
        btn.classList.add('btn-active');
    }

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        // Scale building to fit
        const scaleX = (W - 100) / BW;
        const scaleY = (H - 100) / BH;
        buildingScale = Math.min(scaleX, scaleY, 1.5);
        buildingOffsetX = (W - BW * buildingScale) / 2;
        buildingOffsetY = (H - BH * buildingScale) / 2;
    }

    function toScreen(x, y) {
        return {
            x: buildingOffsetX + x * buildingScale,
            y: buildingOffsetY + y * buildingScale
        };
    }

    function buildLayout() {
        walls = [];
        exits = [];

        const ew = exitWidth;

        // Outer walls with exits
        // Top wall with exit
        walls.push({ x1: 0, y1: 0, x2: BW / 2 - ew / 2, y2: 0 });
        walls.push({ x1: BW / 2 + ew / 2, y1: 0, x2: BW, y2: 0 });
        exits.push({ x: BW / 2, y: -5, width: ew, dir: 'up', label: 'Exit A' });

        // Bottom wall with exit
        walls.push({ x1: 0, y1: BH, x2: BW / 3 - ew / 2, y2: BH });
        walls.push({ x1: BW / 3 + ew / 2, y1: BH, x2: 2 * BW / 3 - ew / 2, y2: BH });
        exits.push({ x: BW / 3, y: BH + 5, width: ew, dir: 'down', label: 'Exit B' });
        walls.push({ x1: 2 * BW / 3 + ew / 2, y1: BH, x2: BW, y2: BH });
        exits.push({ x: 2 * BW / 3, y: BH + 5, width: ew, dir: 'down', label: 'Exit C' });

        // Left wall with exit
        walls.push({ x1: 0, y1: 0, x2: 0, y2: BH / 2 - ew / 2 });
        walls.push({ x1: 0, y1: BH / 2 + ew / 2, x2: 0, y2: BH });
        exits.push({ x: -5, y: BH / 2, width: ew, dir: 'left', label: 'Exit D' });

        // Right wall
        walls.push({ x1: BW, y1: 0, x2: BW, y2: BH });

        // Internal walls (rooms/corridors)
        // Horizontal internal walls with gaps
        walls.push({ x1: 100, y1: 170, x2: 250, y2: 170 });
        walls.push({ x1: 290, y1: 170, x2: 450, y2: 170 });

        walls.push({ x1: 150, y1: 330, x2: 300, y2: 330 });
        walls.push({ x1: 340, y1: 330, x2: 500, y2: 330 });

        // Vertical internal walls
        walls.push({ x1: 200, y1: 50, x2: 200, y2: 130 });
        walls.push({ x1: 400, y1: 50, x2: 400, y2: 130 });
        walls.push({ x1: 200, y1: 370, x2: 200, y2: 460 });
        walls.push({ x1: 400, y1: 200, x2: 400, y2: 300 });

        // Obstacles (pillars/furniture)
        walls.push({ x1: 290, y1: 240, x2: 310, y2: 260 }); // Center pillar
    }

    function init() {
        resize();
        buildLayout();
        agents = [];
        evacuating = false;
        evacuatedCount = 0;
        evacuatedTimes = [];
        frame = 0;

        for (let i = 0; i < agentCount; i++) {
            let x, y, valid;
            do {
                x = 20 + Math.random() * (BW - 40);
                y = 20 + Math.random() * (BH - 40);
                valid = true;
                // Don't spawn inside walls
                for (const w of walls) {
                    if (isHorizontal(w)) {
                        if (Math.abs(y - w.y1) < 8 && x > Math.min(w.x1, w.x2) - 5 && x < Math.max(w.x1, w.x2) + 5) valid = false;
                    } else if (isVertical(w)) {
                        if (Math.abs(x - w.x1) < 8 && y > Math.min(w.y1, w.y2) - 5 && y < Math.max(w.y1, w.y2) + 5) valid = false;
                    }
                }
            } while (!valid);

            agents.push({
                x: x, y: y,
                vx: 0, vy: 0,
                radius: 3 + Math.random() * 1.5,
                speed: 1.2 + Math.random() * 0.8,
                targetExit: null,
                evacuated: false,
                panic: Math.random() < panicLevel / 100,
                color: `hsl(${30 + Math.random() * 30}, 70%, ${50 + Math.random() * 20}%)`
            });
        }
    }

    function isHorizontal(w) { return Math.abs(w.y1 - w.y2) < 1; }
    function isVertical(w) { return Math.abs(w.x1 - w.x2) < 1; }

    function findNearestExit(agent) {
        let best = null, bestDist = Infinity;
        for (const exit of exits) {
            const dx = exit.x - agent.x;
            const dy = exit.y - agent.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < bestDist) {
                bestDist = d;
                best = exit;
            }
        }
        return best;
    }

    function wallRepulsion(agent) {
        let fx = 0, fy = 0;

        for (const w of walls) {
            let closestX, closestY;

            if (isHorizontal(w)) {
                closestX = Math.max(Math.min(w.x1, w.x2), Math.min(Math.max(w.x1, w.x2), agent.x));
                closestY = w.y1;
            } else if (isVertical(w)) {
                closestX = w.x1;
                closestY = Math.max(Math.min(w.y1, w.y2), Math.min(Math.max(w.y1, w.y2), agent.y));
            } else {
                // Rectangular obstacle
                closestX = Math.max(Math.min(w.x1, w.x2), Math.min(Math.max(w.x1, w.x2), agent.x));
                closestY = Math.max(Math.min(w.y1, w.y2), Math.min(Math.max(w.y1, w.y2), agent.y));
            }

            const dx = agent.x - closestX;
            const dy = agent.y - closestY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 15 && dist > 0) {
                const strength = 30 / (dist * dist + 1);
                fx += (dx / dist) * strength;
                fy += (dy / dist) * strength;
            }
        }
        return { fx, fy };
    }

    function update() {
        if (!evacuating) return;
        frame++;

        const dt = 0.4;
        // Spatial hash for agent-agent interaction
        const cellSz = 20;
        const hash = {};

        for (const a of agents) {
            if (a.evacuated) continue;
            const cx = Math.floor(a.x / cellSz);
            const cy = Math.floor(a.y / cellSz);
            const key = cx + ',' + cy;
            if (!hash[key]) hash[key] = [];
            hash[key].push(a);
        }

        for (const a of agents) {
            if (a.evacuated) continue;

            // Find target exit
            if (!a.targetExit) a.targetExit = findNearestExit(a);

            // Update panic based on global level and crowd density
            a.panic = Math.random() < panicLevel / 100;

            const exit = a.targetExit;
            const dx = exit.x - a.x;
            const dy = exit.y - a.y;
            const d = Math.sqrt(dx * dx + dy * dy);

            // Speed factor: panic agents move faster but less efficiently
            const speedMult = a.panic ? 1.6 : 1.0;
            const randomMult = a.panic ? 0.5 : 0.05;

            // Desired velocity toward exit
            let desVx = d > 0 ? (dx / d) * a.speed * speedMult : 0;
            let desVy = d > 0 ? (dy / d) * a.speed * speedMult : 0;

            // Add randomness (more for panicked agents)
            desVx += (Math.random() - 0.5) * randomMult * a.speed;
            desVy += (Math.random() - 0.5) * randomMult * a.speed;

            // Social force
            let sfx = (desVx - a.vx) * 1.5;
            let sfy = (desVy - a.vy) * 1.5;

            // Agent repulsion
            const cx2 = Math.floor(a.x / cellSz);
            const cy2 = Math.floor(a.y / cellSz);
            for (let ddx = -1; ddx <= 1; ddx++) {
                for (let ddy = -1; ddy <= 1; ddy++) {
                    const key = (cx2 + ddx) + ',' + (cy2 + ddy);
                    if (!hash[key]) continue;
                    for (const b of hash[key]) {
                        if (b === a) continue;
                        const px = a.x - b.x;
                        const py = a.y - b.y;
                        const dist = Math.sqrt(px * px + py * py);
                        const minDist = a.radius + b.radius;

                        if (dist < minDist * 3 && dist > 0) {
                            const overlap = minDist - dist;
                            const repulsion = a.panic ? 8 : 12;
                            const strength = overlap > 0 ? repulsion + overlap * 5 : 2.5 * Math.exp(-dist / minDist);
                            sfx += (px / dist) * strength;
                            sfy += (py / dist) * strength;
                        }
                    }
                }
            }

            // Wall repulsion
            const wf = wallRepulsion(a);
            sfx += wf.fx;
            sfy += wf.fy;

            a.vx += sfx * dt;
            a.vy += sfy * dt;

            // Clamp
            const spd = Math.sqrt(a.vx * a.vx + a.vy * a.vy);
            const maxSpd = a.speed * speedMult * 1.5;
            if (spd > maxSpd) {
                a.vx = (a.vx / spd) * maxSpd;
                a.vy = (a.vy / spd) * maxSpd;
            }

            a.x += a.vx * dt;
            a.y += a.vy * dt;

            // Check if reached exit
            if (d < exitWidth * 0.6) {
                a.evacuated = true;
                evacuatedCount++;
                evacuatedTimes.push(frame - startTime);
            }

            // Bounds
            a.x = Math.max(-10, Math.min(BW + 10, a.x));
            a.y = Math.max(-10, Math.min(BH + 10, a.y));
        }
    }

    function draw() {
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, W, H);

        ctx.save();
        ctx.translate(buildingOffsetX, buildingOffsetY);
        ctx.scale(buildingScale, buildingScale);

        // Floor
        ctx.fillStyle = '#1a1f2e';
        ctx.fillRect(-5, -5, BW + 10, BH + 10);

        // Room shading
        ctx.fillStyle = '#151928';
        ctx.fillRect(0, 0, 200, 170);
        ctx.fillRect(200, 0, 200, 170);
        ctx.fillRect(400, 0, 200, 170);
        ctx.fillRect(0, 330, 200, 170);
        ctx.fillRect(200, 330, 200, 170);

        // Grid pattern on floor
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 0.5;
        for (let x = 0; x < BW; x += 20) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, BH); ctx.stroke();
        }
        for (let y = 0; y < BH; y += 20) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(BW, y); ctx.stroke();
        }

        // Draw walls
        ctx.strokeStyle = '#64748b';
        ctx.lineWidth = 4;
        for (const w of walls) {
            ctx.beginPath();
            ctx.moveTo(w.x1, w.y1);
            ctx.lineTo(w.x2, w.y2);
            ctx.stroke();
        }

        // Draw exits
        for (const exit of exits) {
            const half = exit.width / 2;
            ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';

            if (exit.dir === 'up' || exit.dir === 'down') {
                ctx.fillRect(exit.x - half, exit.y - 10, exit.width, 20);
            } else {
                ctx.fillRect(exit.x - 10, exit.y - half, 20, exit.width);
            }

            // Exit sign
            ctx.fillStyle = '#22c55e';
            ctx.shadowColor = '#22c55e';
            ctx.shadowBlur = 10;
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(exit.label, exit.x, exit.y);
            ctx.shadowBlur = 0;

            // Flashing arrow
            if (evacuating && Math.floor(frame / 20) % 2 === 0) {
                ctx.fillStyle = '#22c55e';
                const arrowX = exit.x;
                const arrowY = exit.y + (exit.dir === 'down' ? 18 : exit.dir === 'up' ? -18 : 0);
                const arrowXa = exit.x + (exit.dir === 'left' ? -18 : exit.dir === 'right' ? 18 : 0);
                ctx.beginPath();
                if (exit.dir === 'up') {
                    ctx.moveTo(arrowX, arrowY); ctx.lineTo(arrowX - 5, arrowY + 8); ctx.lineTo(arrowX + 5, arrowY + 8);
                } else if (exit.dir === 'down') {
                    ctx.moveTo(arrowX, arrowY); ctx.lineTo(arrowX - 5, arrowY - 8); ctx.lineTo(arrowX + 5, arrowY - 8);
                } else {
                    ctx.moveTo(arrowXa, exit.y); ctx.lineTo(arrowXa + 8, exit.y - 5); ctx.lineTo(arrowXa + 8, exit.y + 5);
                }
                ctx.fill();
            }
        }

        // Density heat map near exits (bottleneck visualization)
        if (evacuating) {
            for (const exit of exits) {
                let nearby = 0;
                for (const a of agents) {
                    if (a.evacuated) continue;
                    const dx = a.x - exit.x;
                    const dy = a.y - exit.y;
                    if (dx * dx + dy * dy < 3000) nearby++;
                }
                if (nearby > 5) {
                    const grad = ctx.createRadialGradient(exit.x, exit.y, 0, exit.x, exit.y, 60);
                    const intensity = Math.min(0.3, nearby * 0.015);
                    grad.addColorStop(0, `rgba(239, 68, 68, ${intensity})`);
                    grad.addColorStop(1, 'rgba(239, 68, 68, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(exit.x, exit.y, 60, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Draw agents
        for (const a of agents) {
            if (a.evacuated) continue;

            const spd = Math.sqrt(a.vx * a.vx + a.vy * a.vy);

            // Color based on state
            let color;
            if (!evacuating) {
                color = '#60a5fa';
            } else if (a.panic) {
                color = '#ef4444';
            } else {
                color = '#4ade80';
            }

            // Glow
            ctx.fillStyle = color + '22';
            ctx.beginPath();
            ctx.arc(a.x, a.y, a.radius * 2.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(a.x, a.y, a.radius, 0, Math.PI * 2);
            ctx.fill();

            // Direction indicator
            if (evacuating && spd > 0.3) {
                ctx.strokeStyle = color + '88';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(a.x + (a.vx / spd) * a.radius * 2, a.y + (a.vy / spd) * a.radius * 2);
                ctx.stroke();
            }
        }

        ctx.restore();

        // Fire/emergency indicator when evacuating
        if (evacuating) {
            ctx.fillStyle = `rgba(239, 68, 68, ${0.02 + Math.sin(frame * 0.1) * 0.01})`;
            ctx.fillRect(0, 0, W, H);
        }

        // Stats
        const remaining = agents.filter(a => !a.evacuated).length;
        const elapsed = evacuating ? ((frame - startTime) / 60).toFixed(1) : '0.0';
        const avgEvacTime = evacuatedTimes.length > 0 ?
            (evacuatedTimes.reduce((a, b) => a + b, 0) / evacuatedTimes.length / 60).toFixed(1) : 'N/A';
        const panicked = agents.filter(a => !a.evacuated && a.panic).length;

        document.getElementById('stats').innerHTML =
            `Status: ${evacuating ? 'EVACUATING' : 'Standby'}<br>` +
            `Evacuated: ${evacuatedCount}/${agents.length}<br>` +
            `Remaining: ${remaining}<br>` +
            `Panicked: ${panicked}<br>` +
            `Time: ${elapsed}s<br>` +
            `Avg Evac Time: ${avgEvacTime}s<br>` +
            `Panic Level: ${panicLevel}%`;
    }

    window.addEventListener('resize', function() { resize(); });

    function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
    }

    init();
    animate();
})();
</script>
</body>
</html>
