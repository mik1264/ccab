<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voting/Majority Rules CA - Interactive Visualization - CCAB</title>
    <meta name="description" content="Interactive visualization of voting and majority rule cellular automata. Watch cells adopt the majority state of their neighborhood, forming geographically separated patches.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #415a77;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(65, 90, 119, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(65, 90, 119, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            color: #778da9;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(119, 141, 169, 0.2);
            z-index: 1000;
            max-width: 300px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #e0e1dd;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #888;
            font-size: 11px;
        }

        #info .stat-value {
            color: #778da9;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #aaa;
        }

        .population-bar {
            display: flex;
            height: 20px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .pop-segment {
            height: 100%;
            transition: width 0.3s;
        }

        .rule-display {
            background: rgba(119, 141, 169, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 11px;
            color: #e0e1dd;
        }

        #presets {
            position: fixed;
            top: 360px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1000;
        }

        button {
            background: rgba(119, 141, 169, 0.15);
            border: 1px solid rgba(119, 141, 169, 0.4);
            color: #778da9;
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            text-align: left;
        }

        button:hover {
            background: rgba(119, 141, 169, 0.3);
        }

        button.active {
            background: rgba(119, 141, 169, 0.4);
            border-color: #778da9;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(119, 141, 169, 0.2);
        }

        .control-group label {
            color: #778da9;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 80px;
            accent-color: #778da9;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        .control-btn {
            padding: 10px 16px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #778da9;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Voting / Majority Rules</h3>
        <div class="stat">
            <span class="stat-label">Rule Type</span>
            <span class="stat-value" id="rule-type">Standard Vote</span>
        </div>
        <div class="stat">
            <span class="stat-label">Neighborhood</span>
            <span class="stat-value" id="neighborhood">Moore (8)</span>
        </div>
        <div class="stat">
            <span class="stat-label">Threshold</span>
            <span class="stat-value" id="threshold">5</span>
        </div>
        <div class="stat">
            <span class="stat-label">Generation</span>
            <span class="stat-value" id="generation">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">States (k)</span>
            <span class="stat-value" id="states">2</span>
        </div>
        <div class="population-bar" id="pop-bar"></div>
        <div class="rule-display" id="rule-info">
            Each cell adopts the majority state of its neighborhood. With threshold 5, a cell becomes state 1 if 5+ of its 9-cell neighborhood are state 1.
        </div>
        <p>Majority voting rules form "gerrymandered" regions. Higher thresholds increase stability. Multi-state systems show complex competition dynamics.</p>
    </div>

    <div id="presets">
        <button class="active" data-rule="vote9" data-states="2">Standard Vote (Moore)</button>
        <button data-rule="vote5" data-states="2">Von Neumann Vote</button>
        <button data-rule="vote4" data-states="2">Low Threshold (4/9)</button>
        <button data-rule="vote6" data-states="2">High Threshold (6/9)</button>
        <button data-rule="multi3" data-states="3">3-State Vote</button>
        <button data-rule="multi4" data-states="4">4-State Vote</button>
        <button data-rule="async" data-states="2">Async Update</button>
        <button data-rule="anneal" data-states="2">Annealing (4,5,6)</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>States: <span id="states-val">2</span></label>
            <input type="range" id="states-slider" min="2" max="6" value="2">
        </div>
        <div class="control-group">
            <label>Density: <span id="density-val">50</span>%</label>
            <input type="range" id="density" min="20" max="80" value="50">
        </div>
        <div class="control-group">
            <label>Cell Size: <span id="size-val">4</span>px</label>
            <input type="range" id="size" min="2" max="8" value="4">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-val">50</span>ms</label>
            <input type="range" id="speed" min="10" max="200" value="50">
        </div>
        <button class="control-btn" id="start-btn">Start</button>
        <button class="control-btn" id="step-btn">Step</button>
        <button class="control-btn" id="reset-btn">Reset</button>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let cellSize = 4;
        let speed = 50;
        let numStates = 2;
        let density = 50;
        let gridWidth, gridHeight;
        let grid, nextGrid;
        let generation = 0;
        let running = false;

        // Rule type
        let ruleType = 'vote9';
        let threshold = 5;
        let useMoore = true;
        let async = false;

        // Color palettes
        const stateColors = {
            2: ['#0d1b2a', '#e63946'],
            3: ['#0d1b2a', '#e63946', '#457b9d'],
            4: ['#0d1b2a', '#e63946', '#457b9d', '#f4a261'],
            5: ['#0d1b2a', '#e63946', '#457b9d', '#f4a261', '#2a9d8f'],
            6: ['#0d1b2a', '#e63946', '#457b9d', '#f4a261', '#2a9d8f', '#9b59b6']
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gridWidth = Math.floor(canvas.width / cellSize);
            gridHeight = Math.floor(canvas.height / cellSize);
            initGrid();
        }

        function initGrid() {
            grid = [];
            nextGrid = [];
            generation = 0;

            for (let y = 0; y < gridHeight; y++) {
                grid[y] = [];
                nextGrid[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    if (numStates === 2) {
                        grid[y][x] = Math.random() * 100 < density ? 1 : 0;
                    } else {
                        grid[y][x] = Math.floor(Math.random() * numStates);
                    }
                    nextGrid[y][x] = 0;
                }
            }

            render();
            updateStats();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const deltas = useMoore
                ? [[-1, -1], [0, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]
                : [[0, -1], [-1, 0], [0, 0], [1, 0], [0, 1]];

            for (const [dx, dy] of deltas) {
                const nx = (x + dx + gridWidth) % gridWidth;
                const ny = (y + dy + gridHeight) % gridHeight;
                neighbors.push(grid[ny][nx]);
            }

            return neighbors;
        }

        function countStates(neighbors) {
            const counts = new Array(numStates).fill(0);
            for (const state of neighbors) {
                counts[state]++;
            }
            return counts;
        }

        function applyRule(x, y) {
            const neighbors = getNeighbors(x, y);
            const counts = countStates(neighbors);
            const current = grid[y][x];

            switch (ruleType) {
                case 'vote9': // Standard Moore neighborhood vote
                case 'vote5': // Von Neumann
                    // Find majority
                    let maxCount = 0, majority = current;
                    for (let s = 0; s < numStates; s++) {
                        if (counts[s] > maxCount) {
                            maxCount = counts[s];
                            majority = s;
                        }
                    }
                    return majority;

                case 'vote4': // Low threshold (4 of 9)
                    if (numStates === 2) {
                        return counts[1] >= 4 ? 1 : 0;
                    }
                    return counts.indexOf(Math.max(...counts));

                case 'vote6': // High threshold (6 of 9)
                    if (numStates === 2) {
                        return counts[1] >= 6 ? 1 : 0;
                    }
                    return counts.indexOf(Math.max(...counts));

                case 'multi3':
                case 'multi4':
                    // Multi-state majority
                    let max = 0, winner = current;
                    for (let s = 0; s < numStates; s++) {
                        if (counts[s] > max || (counts[s] === max && Math.random() < 0.5)) {
                            max = counts[s];
                            winner = s;
                        }
                    }
                    return winner;

                case 'async':
                    // Only update some cells each generation
                    if (Math.random() > 0.3) return current;
                    return counts[1] >= 5 ? 1 : 0;

                case 'anneal':
                    // Annealing: birth at 4,6, survival at 3,5,6
                    const sum = counts[1];
                    if (current === 0) {
                        return (sum === 4 || sum === 6) ? 1 : 0;
                    } else {
                        return (sum === 3 || sum === 5 || sum === 6) ? 1 : 0;
                    }

                default:
                    return counts[1] >= threshold ? 1 : 0;
            }
        }

        function update() {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    nextGrid[y][x] = applyRule(x, y);
                }
            }

            // Swap buffers
            [grid, nextGrid] = [nextGrid, grid];
            generation++;
        }

        function render() {
            const colors = stateColors[numStates] || stateColors[2];
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const state = grid[y][x];
                    const color = colors[state];

                    // Parse hex color
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);

                    // Fill cell
                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx;
                            const py = y * cellSize + dy;
                            if (px < canvas.width && py < canvas.height) {
                                const i = (py * canvas.width + px) * 4;
                                imageData.data[i] = r;
                                imageData.data[i + 1] = g;
                                imageData.data[i + 2] = b;
                                imageData.data[i + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation.toLocaleString();
            document.getElementById('states').textContent = numStates;
            document.getElementById('neighborhood').textContent = useMoore ? 'Moore (8)' : 'Von Neumann (4)';
            document.getElementById('threshold').textContent = threshold;

            // Update population bar
            const counts = new Array(numStates).fill(0);
            const total = gridWidth * gridHeight;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    counts[grid[y][x]]++;
                }
            }

            const colors = stateColors[numStates] || stateColors[2];
            const popBar = document.getElementById('pop-bar');
            popBar.innerHTML = counts.map((c, i) =>
                `<div class="pop-segment" style="width: ${(c / total * 100).toFixed(1)}%; background: ${colors[i]};" title="State ${i}: ${(c / total * 100).toFixed(1)}%"></div>`
            ).join('');
        }

        // FPS tracking
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        let lastUpdateTime = 0;

        function animate(currentTime) {
            if (!running) return;

            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = fps;
            }

            // Update based on speed
            if (currentTime - lastUpdateTime >= speed) {
                update();
                render();
                updateStats();
                lastUpdateTime = currentTime;
            }
        }

        function setRule(rule, states) {
            ruleType = rule;
            numStates = states;

            // Update rule-specific settings
            switch (rule) {
                case 'vote9':
                    threshold = 5;
                    useMoore = true;
                    document.getElementById('rule-type').textContent = 'Standard Vote';
                    document.getElementById('rule-info').textContent = 'Each cell adopts the majority state. Threshold 5/9 means 5+ neighbors needed.';
                    break;
                case 'vote5':
                    threshold = 3;
                    useMoore = false;
                    document.getElementById('rule-type').textContent = 'Von Neumann Vote';
                    document.getElementById('rule-info').textContent = 'Uses 4-neighbor Von Neumann neighborhood. Threshold 3/5 for majority.';
                    break;
                case 'vote4':
                    threshold = 4;
                    useMoore = true;
                    document.getElementById('rule-type').textContent = 'Low Threshold';
                    document.getElementById('rule-info').textContent = 'Lower threshold (4/9) makes it easier to become state 1. More expansive growth.';
                    break;
                case 'vote6':
                    threshold = 6;
                    useMoore = true;
                    document.getElementById('rule-type').textContent = 'High Threshold';
                    document.getElementById('rule-info').textContent = 'Higher threshold (6/9) makes state 1 harder to maintain. More stable patterns.';
                    break;
                case 'multi3':
                case 'multi4':
                    threshold = Math.ceil((useMoore ? 9 : 5) / numStates);
                    useMoore = true;
                    document.getElementById('rule-type').textContent = `${numStates}-State Vote`;
                    document.getElementById('rule-info').textContent = `Multi-state majority voting. Each cell joins the locally dominant faction.`;
                    break;
                case 'async':
                    threshold = 5;
                    useMoore = true;
                    document.getElementById('rule-type').textContent = 'Async Update';
                    document.getElementById('rule-info').textContent = 'Not all cells update each step. Creates more organic, gradual transitions.';
                    break;
                case 'anneal':
                    threshold = 5;
                    useMoore = true;
                    document.getElementById('rule-type').textContent = 'Annealing';
                    document.getElementById('rule-info').textContent = 'Birth at 4,6 neighbors. Survival at 3,5,6. Creates crystalline structures.';
                    break;
            }

            document.getElementById('states-slider').value = numStates;
            document.getElementById('states-val').textContent = numStates;
        }

        // Event listeners
        document.getElementById('states-slider').addEventListener('input', (e) => {
            numStates = parseInt(e.target.value);
            document.getElementById('states-val').textContent = numStates;
            initGrid();
        });

        document.getElementById('density').addEventListener('input', (e) => {
            density = parseInt(e.target.value);
            document.getElementById('density-val').textContent = density;
        });

        document.getElementById('size').addEventListener('input', (e) => {
            cellSize = parseInt(e.target.value);
            document.getElementById('size-val').textContent = cellSize;
            resize();
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speed-val').textContent = speed;
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (running) {
                running = false;
                document.getElementById('start-btn').textContent = 'Start';
            } else {
                running = true;
                document.getElementById('start-btn').textContent = 'Pause';
                requestAnimationFrame(animate);
            }
        });

        document.getElementById('step-btn').addEventListener('click', () => {
            update();
            render();
            updateStats();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            running = false;
            document.getElementById('start-btn').textContent = 'Start';
            initGrid();
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                setRule(btn.dataset.rule, parseInt(btn.dataset.states));
                initGrid();
            });
        });

        // Initialize
        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
