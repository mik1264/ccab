<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>City Growth DLA</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 999; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 18px; font-family: sans-serif; z-index: 999; text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none; }
.panel { background: rgba(0,0,0,0.75); color: #e0e0e0; padding: 12px 16px; border-radius: 8px; font-size: 13px; margin-bottom: 8px; min-width: 180px; }
.panel label { display: block; margin: 6px 0 2px; color: #fbbf24; }
.panel input[type=range] { width: 100%; }
.panel button { background: #fbbf24; color: #0a0e1a; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 6px; width: 100%; }
.panel button:hover { background: #f59e0b; }
#stats { color: #aaa; margin-top: 6px; line-height: 1.6; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">City Growth DLA</div>
<div id="ui">
    <div class="panel">
        <label>Particles per Frame: <span id="pVal">20</span></label>
        <input type="range" id="particleRate" min="1" max="100" value="20">
        <label>Walk Steps: <span id="wVal">500</span></label>
        <input type="range" id="walkSteps" min="100" max="2000" value="500" step="50">
        <button id="resetBtn">Reset Simulation</button>
        <div id="stats"></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H, gridW, gridH, cellSize;
    let grid, distGrid, maxDist;
    let particleRate = 20;
    let walkSteps = 500;
    let totalCells = 0;
    let generation = 0;

    const particleRateSlider = document.getElementById('particleRate');
    const walkStepsSlider = document.getElementById('walkSteps');
    const pVal = document.getElementById('pVal');
    const wVal = document.getElementById('wVal');
    const statsEl = document.getElementById('stats');

    particleRateSlider.addEventListener('input', function() {
        particleRate = parseInt(this.value);
        pVal.textContent = particleRate;
    });
    walkStepsSlider.addEventListener('input', function() {
        walkSteps = parseInt(this.value);
        wVal.textContent = walkSteps;
    });
    document.getElementById('resetBtn').addEventListener('click', init);

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        cellSize = 3;
        gridW = Math.floor(W / cellSize);
        gridH = Math.floor(H / cellSize);
    }

    function init() {
        resize();
        grid = new Uint8Array(gridW * gridH);
        distGrid = new Float32Array(gridW * gridH);
        maxDist = 0;
        totalCells = 0;
        generation = 0;

        // Seed: city center cross
        const cx = Math.floor(gridW / 2);
        const cy = Math.floor(gridH / 2);
        for (let dx = -3; dx <= 3; dx++) {
            for (let dy = -3; dy <= 3; dy++) {
                const idx = (cy + dy) * gridW + (cx + dx);
                if (idx >= 0 && idx < grid.length) {
                    grid[idx] = 1;
                    distGrid[idx] = 0;
                    totalCells++;
                }
            }
        }
        // Roads from center
        for (let i = -15; i <= 15; i++) {
            let idx = cy * gridW + (cx + i);
            if (idx >= 0 && idx < grid.length) { grid[idx] = 1; distGrid[idx] = 0; totalCells++; }
            idx = (cy + i) * gridW + cx;
            if (idx >= 0 && idx < grid.length) { grid[idx] = 1; distGrid[idx] = 0; totalCells++; }
        }
    }

    function distFromCenter(gx, gy) {
        const cx = gridW / 2;
        const cy = gridH / 2;
        return Math.sqrt((gx - cx) * (gx - cx) + (gy - cy) * (gy - cy));
    }

    function hasNeighbor(gx, gy) {
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                if (dx === 0 && dy === 0) continue;
                const nx = gx + dx, ny = gy + dy;
                if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                    if (grid[ny * gridW + nx]) return true;
                }
            }
        }
        return false;
    }

    function simulate() {
        const cx = Math.floor(gridW / 2);
        const cy = Math.floor(gridH / 2);
        const maxR = Math.min(gridW, gridH) * 0.45;

        for (let p = 0; p < particleRate; p++) {
            // Launch from random position on circle
            const angle = Math.random() * Math.PI * 2;
            const r = maxR * (0.3 + Math.random() * 0.7);
            let px = Math.floor(cx + Math.cos(angle) * r);
            let py = Math.floor(cy + Math.sin(angle) * r);

            for (let step = 0; step < walkSteps; step++) {
                // Random walk with slight drift toward center
                const toCx = cx - px;
                const toCy = cy - py;
                const d = Math.sqrt(toCx * toCx + toCy * toCy);
                const bias = 0.15;

                let dx = (Math.random() < 0.5 ? 1 : -1);
                let dy = (Math.random() < 0.5 ? 1 : -1);
                if (d > 0) {
                    if (Math.random() < bias) dx = toCx > 0 ? 1 : -1;
                    if (Math.random() < bias) dy = toCy > 0 ? 1 : -1;
                }

                px += dx;
                py += dy;

                if (px < 1 || px >= gridW - 1 || py < 1 || py >= gridH - 1) break;

                if (hasNeighbor(px, py) && !grid[py * gridW + px]) {
                    grid[py * gridW + px] = 1;
                    const dist = distFromCenter(px, py);
                    distGrid[py * gridW + px] = dist;
                    if (dist > maxDist) maxDist = dist;
                    totalCells++;
                    break;
                }
            }
        }
        generation++;
    }

    function getColor(dist) {
        const t = maxDist > 0 ? dist / maxDist : 0;
        // Center: warm yellow -> mid: orange -> outer: deep blue/purple
        if (t < 0.2) {
            const s = t / 0.2;
            return `rgb(${255}, ${Math.floor(220 - s * 80)}, ${Math.floor(50 - s * 30)})`;
        } else if (t < 0.5) {
            const s = (t - 0.2) / 0.3;
            return `rgb(${Math.floor(255 - s * 100)}, ${Math.floor(140 - s * 80)}, ${Math.floor(20 + s * 60)})`;
        } else if (t < 0.8) {
            const s = (t - 0.5) / 0.3;
            return `rgb(${Math.floor(155 - s * 100)}, ${Math.floor(60 + s * 20)}, ${Math.floor(80 + s * 100)})`;
        } else {
            const s = (t - 0.8) / 0.2;
            return `rgb(${Math.floor(55 - s * 30)}, ${Math.floor(80 - s * 30)}, ${Math.floor(180 + s * 50)})`;
        }
    }

    function draw() {
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, W, H);

        // Draw glow behind city
        const cx = gridW / 2 * cellSize;
        const cy = gridH / 2 * cellSize;
        const glowR = maxDist * cellSize * 1.2;
        if (glowR > 10) {
            const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
            glow.addColorStop(0, 'rgba(251, 191, 36, 0.06)');
            glow.addColorStop(0.5, 'rgba(200, 100, 30, 0.03)');
            glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, W, H);
        }

        // Draw cells
        for (let y = 0; y < gridH; y++) {
            for (let x = 0; x < gridW; x++) {
                if (grid[y * gridW + x]) {
                    const dist = distGrid[y * gridW + x];
                    ctx.fillStyle = getColor(dist);
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        statsEl.innerHTML = `Cells: ${totalCells.toLocaleString()}<br>Generation: ${generation}`;
    }

    function animate() {
        simulate();
        draw();
        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', function() {
        const oldGrid = grid;
        const oldDist = distGrid;
        const oldW = gridW, oldH = gridH;
        resize();
        grid = new Uint8Array(gridW * gridH);
        distGrid = new Float32Array(gridW * gridH);
        const copyW = Math.min(oldW, gridW);
        const copyH = Math.min(oldH, gridH);
        for (let y = 0; y < copyH; y++) {
            for (let x = 0; x < copyW; x++) {
                grid[y * gridW + x] = oldGrid[y * oldW + x];
                distGrid[y * gridW + x] = oldDist[y * oldW + x];
            }
        }
    });

    init();
    animate();
})();
</script>
</body>
</html>
