<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convex Hull Algorithms - Interactive Visualization - CCAB</title>
    <meta name="description" content="Interactive visualization of convex hull algorithms including Graham Scan, Jarvis March (Gift Wrapping), and QuickHull. Watch step-by-step hull construction.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a1a2e 0%, #1a2e3e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #03a9f4;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(3, 169, 244, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(3, 169, 244, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            color: #03a9f4;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(3, 169, 244, 0.2);
            z-index: 1000;
            max-width: 300px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #888;
            font-size: 11px;
        }

        #info .stat-value {
            color: #03a9f4;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #aaa;
        }

        .step-display {
            background: rgba(3, 169, 244, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
            color: #4fc3f7;
            min-height: 40px;
        }

        #algorithms {
            position: fixed;
            top: 280px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1000;
        }

        button {
            background: rgba(3, 169, 244, 0.15);
            border: 1px solid rgba(3, 169, 244, 0.4);
            color: #03a9f4;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            text-align: left;
        }

        button:hover {
            background: rgba(3, 169, 244, 0.3);
        }

        button.active {
            background: rgba(3, 169, 244, 0.4);
            border-color: #03a9f4;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(3, 169, 244, 0.2);
        }

        .control-group label {
            color: #03a9f4;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 80px;
            accent-color: #03a9f4;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        .control-btn {
            padding: 10px 16px;
        }

        .complexity {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Convex Hull Algorithms</h3>
        <div class="stat">
            <span class="stat-label">Algorithm</span>
            <span class="stat-value" id="algo-name">Graham Scan</span>
        </div>
        <div class="stat">
            <span class="stat-label">Total Points</span>
            <span class="stat-value" id="total-points">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Hull Points</span>
            <span class="stat-value" id="hull-points">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Comparisons</span>
            <span class="stat-value" id="comparisons">0</span>
        </div>
        <div class="step-display" id="step-info">Click "Start" to begin visualization</div>
        <p>The convex hull is the smallest convex polygon containing all points. Click canvas to add points, or use "Random" to generate them.</p>
    </div>

    <div id="algorithms">
        <button class="active" data-algo="graham">
            Graham Scan
            <div class="complexity">O(n log n)</div>
        </button>
        <button data-algo="jarvis">
            Jarvis March
            <div class="complexity">O(nh)</div>
        </button>
        <button data-algo="quickhull">
            QuickHull
            <div class="complexity">O(n log n) avg</div>
        </button>
        <button data-algo="monotone">
            Monotone Chain
            <div class="complexity">O(n log n)</div>
        </button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Points: <span id="points-val">50</span></label>
            <input type="range" id="points" min="10" max="200" value="50">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-val">50</span>ms</label>
            <input type="range" id="speed" min="10" max="500" value="50">
        </div>
        <button class="control-btn" id="random-btn">Random</button>
        <button class="control-btn" id="start-btn">Start</button>
        <button class="control-btn" id="step-btn">Step</button>
        <button class="control-btn" id="clear-btn">Clear</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }
        window.addEventListener('resize', resize);

        // State
        let points = [];
        let hull = [];
        let currentStep = 0;
        let isRunning = false;
        let algorithm = 'graham';
        let stepDelay = 50;
        let numPoints = 50;
        let comparisons = 0;

        // Visualization state
        let highlightedPoints = [];
        let currentLine = null;
        let testingPoints = [];
        let stepInfo = "Click 'Start' to begin";

        // Generate random points
        function generateRandom() {
            const padding = 100;
            points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: padding + Math.random() * (canvas.width - 2 * padding),
                    y: padding + Math.random() * (canvas.height - 2 * padding)
                });
            }
            hull = [];
            highlightedPoints = [];
            currentLine = null;
            testingPoints = [];
            comparisons = 0;
            stepInfo = "Click 'Start' to begin";
            render();
            updateStats();
        }

        // Cross product of vectors OA and OB
        function cross(O, A, B) {
            comparisons++;
            return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
        }

        // Distance between two points
        function dist(A, B) {
            return Math.sqrt((A.x - B.x) ** 2 + (A.y - B.y) ** 2);
        }

        // Angle from origin point
        function angle(origin, point) {
            return Math.atan2(point.y - origin.y, point.x - origin.x);
        }

        // ============ GRAHAM SCAN ============
        async function grahamScan() {
            if (points.length < 3) return;

            // Find lowest point (break ties by x)
            let lowest = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].y > points[lowest].y ||
                    (points[i].y === points[lowest].y && points[i].x < points[lowest].x)) {
                    lowest = i;
                }
            }

            // Move lowest to front
            [points[0], points[lowest]] = [points[lowest], points[0]];
            const origin = points[0];
            highlightedPoints = [0];
            stepInfo = "Found starting point (lowest)";
            render();
            await delay();

            // Sort by polar angle
            const sorted = points.slice(1).sort((a, b) => {
                const angleA = angle(origin, a);
                const angleB = angle(origin, b);
                if (angleA !== angleB) return angleA - angleB;
                return dist(origin, a) - dist(origin, b);
            });
            sorted.unshift(origin);

            stepInfo = "Sorted points by polar angle";
            render();
            await delay();

            // Build hull
            const stack = [sorted[0], sorted[1]];
            hull = [...stack];
            render();
            await delay();

            for (let i = 2; i < sorted.length; i++) {
                if (!isRunning) return;

                testingPoints = [sorted[i]];
                stepInfo = `Testing point ${i + 1}`;

                while (stack.length > 1 && cross(stack[stack.length - 2], stack[stack.length - 1], sorted[i]) <= 0) {
                    currentLine = { from: stack[stack.length - 2], to: sorted[i] };
                    stack.pop();
                    hull = [...stack];
                    render();
                    await delay();
                }

                stack.push(sorted[i]);
                hull = [...stack];
                currentLine = null;
                render();
                await delay();
            }

            testingPoints = [];
            stepInfo = "Hull complete!";
            render();
        }

        // ============ JARVIS MARCH ============
        async function jarvisMarch() {
            if (points.length < 3) return;

            // Find leftmost point
            let leftmost = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].x < points[leftmost].x) leftmost = i;
            }

            hull = [];
            let current = leftmost;
            highlightedPoints = [current];
            stepInfo = "Found leftmost point";
            render();
            await delay();

            do {
                if (!isRunning) return;

                hull.push(points[current]);
                let next = (current + 1) % points.length;

                for (let i = 0; i < points.length; i++) {
                    if (!isRunning) return;
                    if (i === current) continue;

                    testingPoints = [points[i]];
                    currentLine = { from: points[current], to: points[i] };
                    stepInfo = `Testing point ${i + 1} from current hull vertex`;
                    render();
                    await delay();

                    if (cross(points[current], points[next], points[i]) < 0) {
                        next = i;
                    }
                }

                current = next;
                highlightedPoints = [current];
                testingPoints = [];
                currentLine = null;
                render();
                await delay();

            } while (current !== leftmost);

            stepInfo = "Hull complete!";
            render();
        }

        // ============ QUICKHULL ============
        async function quickHull() {
            if (points.length < 3) return;

            // Find leftmost and rightmost
            let minX = 0, maxX = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].x < points[minX].x) minX = i;
                if (points[i].x > points[maxX].x) maxX = i;
            }

            hull = [points[minX], points[maxX]];
            highlightedPoints = [minX, maxX];
            currentLine = { from: points[minX], to: points[maxX] };
            stepInfo = "Found extreme points (leftmost, rightmost)";
            render();
            await delay();

            // Split points into two sets
            const upper = [], lower = [];
            for (let i = 0; i < points.length; i++) {
                if (i === minX || i === maxX) continue;
                if (cross(points[minX], points[maxX], points[i]) > 0) {
                    upper.push(points[i]);
                } else {
                    lower.push(points[i]);
                }
            }

            hull = [];
            await quickHullRecursive(points[minX], points[maxX], upper);
            await quickHullRecursive(points[maxX], points[minX], lower);

            stepInfo = "Hull complete!";
            currentLine = null;
            render();
        }

        async function quickHullRecursive(A, B, pointSet) {
            if (!isRunning || pointSet.length === 0) return;

            // Find farthest point from line AB
            let maxDist = -1, farthest = null;
            for (const p of pointSet) {
                const d = Math.abs(cross(A, B, p));
                if (d > maxDist) {
                    maxDist = d;
                    farthest = p;
                }
            }

            if (!farthest) return;

            testingPoints = [farthest];
            currentLine = { from: A, to: B };
            stepInfo = "Found farthest point from dividing line";
            render();
            await delay();

            // Add to hull (in correct position)
            const idx = hull.indexOf(B);
            if (idx >= 0) {
                hull.splice(idx, 0, farthest);
            } else {
                hull.push(farthest);
            }
            render();
            await delay();

            // Split remaining points
            const leftOfAF = [], leftOfFB = [];
            for (const p of pointSet) {
                if (p === farthest) continue;
                if (cross(A, farthest, p) > 0) leftOfAF.push(p);
                if (cross(farthest, B, p) > 0) leftOfFB.push(p);
            }

            await quickHullRecursive(A, farthest, leftOfAF);
            await quickHullRecursive(farthest, B, leftOfFB);
        }

        // ============ MONOTONE CHAIN ============
        async function monotoneChain() {
            if (points.length < 3) return;

            // Sort by x, then by y
            const sorted = [...points].sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);
            stepInfo = "Sorted points by x-coordinate";
            render();
            await delay();

            // Build lower hull
            const lower = [];
            stepInfo = "Building lower hull (left to right)";
            for (let i = 0; i < sorted.length; i++) {
                if (!isRunning) return;

                testingPoints = [sorted[i]];
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], sorted[i]) <= 0) {
                    lower.pop();
                    hull = [...lower];
                    render();
                    await delay();
                }
                lower.push(sorted[i]);
                hull = [...lower];
                render();
                await delay();
            }

            // Build upper hull
            const upper = [];
            stepInfo = "Building upper hull (right to left)";
            for (let i = sorted.length - 1; i >= 0; i--) {
                if (!isRunning) return;

                testingPoints = [sorted[i]];
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], sorted[i]) <= 0) {
                    upper.pop();
                    hull = [...lower.slice(0, -1), ...upper];
                    render();
                    await delay();
                }
                upper.push(sorted[i]);
                hull = [...lower.slice(0, -1), ...upper];
                render();
                await delay();
            }

            // Remove last point of each half (duplicated)
            lower.pop();
            upper.pop();
            hull = [...lower, ...upper];
            testingPoints = [];
            stepInfo = "Hull complete!";
            render();
        }

        // Delay function
        function delay() {
            return new Promise(resolve => setTimeout(resolve, stepDelay));
        }

        // Run selected algorithm
        async function runAlgorithm() {
            if (points.length < 3) {
                stepInfo = "Need at least 3 points!";
                render();
                return;
            }

            isRunning = true;
            hull = [];
            comparisons = 0;
            document.getElementById('start-btn').textContent = 'Stop';

            switch (algorithm) {
                case 'graham': await grahamScan(); break;
                case 'jarvis': await jarvisMarch(); break;
                case 'quickhull': await quickHull(); break;
                case 'monotone': await monotoneChain(); break;
            }

            isRunning = false;
            document.getElementById('start-btn').textContent = 'Start';
            updateStats();
        }

        // Render
        function render() {
            ctx.fillStyle = '#0a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw testing line
            if (currentLine) {
                ctx.beginPath();
                ctx.moveTo(currentLine.from.x, currentLine.from.y);
                ctx.lineTo(currentLine.to.x, currentLine.to.y);
                ctx.strokeStyle = 'rgba(255, 193, 7, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw hull
            if (hull.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(hull[0].x, hull[0].y);
                for (let i = 1; i < hull.length; i++) {
                    ctx.lineTo(hull[i].x, hull[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(3, 169, 244, 0.15)';
                ctx.fill();
                ctx.strokeStyle = '#03a9f4';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw all points
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const isHighlighted = highlightedPoints.includes(i);
                const isTesting = testingPoints.some(tp => tp.x === p.x && tp.y === p.y);
                const isHull = hull.some(hp => hp.x === p.x && hp.y === p.y);

                ctx.beginPath();
                ctx.arc(p.x, p.y, isTesting ? 10 : (isHull ? 8 : 5), 0, 2 * Math.PI);

                if (isTesting) {
                    ctx.fillStyle = '#ffc107';
                } else if (isHighlighted) {
                    ctx.fillStyle = '#ff5722';
                } else if (isHull) {
                    ctx.fillStyle = '#03a9f4';
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                }
                ctx.fill();
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('total-points').textContent = points.length;
            document.getElementById('hull-points').textContent = hull.length;
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('step-info').textContent = stepInfo;
        }

        // Event listeners
        document.getElementById('points').addEventListener('input', (e) => {
            numPoints = parseInt(e.target.value);
            document.getElementById('points-val').textContent = numPoints;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            stepDelay = parseInt(e.target.value);
            document.getElementById('speed-val').textContent = stepDelay;
        });

        document.getElementById('random-btn').addEventListener('click', () => {
            isRunning = false;
            generateRandom();
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (isRunning) {
                isRunning = false;
                document.getElementById('start-btn').textContent = 'Start';
            } else {
                runAlgorithm();
            }
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
            isRunning = false;
            points = [];
            hull = [];
            highlightedPoints = [];
            testingPoints = [];
            currentLine = null;
            comparisons = 0;
            stepInfo = "Click to add points, or use 'Random'";
            render();
        });

        // Algorithm selection
        document.querySelectorAll('#algorithms button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (isRunning) return;
                document.querySelectorAll('#algorithms button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                algorithm = btn.dataset.algo;

                const names = {
                    graham: 'Graham Scan',
                    jarvis: 'Jarvis March',
                    quickhull: 'QuickHull',
                    monotone: 'Monotone Chain'
                };
                document.getElementById('algo-name').textContent = names[algorithm];
            });
        });

        // Click to add points
        canvas.addEventListener('click', (e) => {
            if (isRunning) return;
            const rect = canvas.getBoundingClientRect();
            points.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
            hull = [];
            stepInfo = `Added point (${points.length} total)`;
            render();
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = generateRandom;
        window.init = generateRandom;

        // Initialize
        resize();
        generateRandom();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
