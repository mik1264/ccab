<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manifold Explorer â€” Interactive Dimensionality Reduction</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
            --light-sage: rgba(138, 154, 91, 0.15);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            color: var(--dark-moss);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .organic-shape {
            position: fixed;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.3;
            z-index: 0;
            pointer-events: none;
        }
        .shape-1 {
            width: 600px; height: 600px;
            background: radial-gradient(circle, var(--sage), transparent);
            top: -200px; right: -100px;
            animation: morph 30s ease-in-out infinite;
        }
        .shape-2 {
            width: 500px; height: 500px;
            background: radial-gradient(circle, var(--earth), transparent);
            bottom: -150px; left: -100px;
            animation: morph 25s ease-in-out infinite reverse;
        }
        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
            50% { border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; }
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--terracotta);
            text-decoration: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: var(--earth);
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

        .app-container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .app-header h1 {
            font-family: 'Lora', serif;
            font-size: 2.4rem;
            color: var(--moss);
            margin-bottom: 8px;
        }
        .app-header .subtitle {
            font-size: 1.1rem;
            color: var(--sage);
            font-weight: 400;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 10px 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--dark-moss);
            transition: all 0.3s ease;
        }
        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            border-color: var(--earth);
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: var(--moss);
            color: var(--cream);
            border-color: var(--moss);
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.3);
        }

        /* Panels */
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }

        /* Glass Card */
        .glass-card {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(138, 154, 91, 0.2);
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(96, 108, 56, 0.08);
        }
        .glass-card h2 {
            font-family: 'Lora', serif;
            color: var(--moss);
            font-size: 1.5rem;
            margin-bottom: 12px;
        }
        .glass-card h3 {
            font-family: 'Lora', serif;
            color: var(--dark-moss);
            font-size: 1.15rem;
            margin-bottom: 8px;
        }

        /* Layout */
        .split-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            align-items: start;
        }
        @media (max-width: 900px) {
            .split-layout { grid-template-columns: 1fr; }
        }

        /* Controls */
        .control-group {
            margin-bottom: 16px;
        }
        .control-group label {
            display: block;
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--moss);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .control-group select,
        .control-group input[type="file"] {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            font-family: 'Nunito', sans-serif;
            font-size: 0.9rem;
            color: var(--dark-moss);
            transition: border-color 0.3s;
        }
        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: var(--earth);
        }
        .range-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .range-row input[type="range"] {
            flex: 1;
            accent-color: var(--moss);
        }
        .range-val {
            font-weight: 700;
            font-size: 0.9rem;
            min-width: 40px;
            text-align: right;
            color: var(--terracotta);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: var(--moss);
            color: var(--cream);
        }
        .btn-primary:hover {
            background: var(--dark-moss);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(96, 108, 56, 0.3);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: rgba(138, 154, 91, 0.15);
            color: var(--moss);
            border: 2px solid rgba(138, 154, 91, 0.3);
        }
        .btn-secondary:hover {
            background: rgba(138, 154, 91, 0.25);
        }
        .btn-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Viz Area */
        .viz-container {
            position: relative;
            width: 100%;
            min-height: 500px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            border: 1px solid rgba(138, 154, 91, 0.15);
            overflow: hidden;
        }
        .viz-container svg {
            width: 100%;
            height: 100%;
        }

        /* Status bar */
        .status-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            background: rgba(138, 154, 91, 0.08);
            border-radius: 10px;
            margin-top: 12px;
            font-size: 0.85rem;
        }
        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: var(--sage);
        }
        .status-dot.running {
            background: var(--earth);
            animation: pulse 1s ease-in-out infinite;
        }
        .status-dot.done {
            background: var(--moss);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Progress bar */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(138, 154, 91, 0.15);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--sage), var(--earth));
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(61, 68, 35, 0.95);
            color: var(--cream);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
            max-width: 200px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .legend-dot {
            width: 12px; height: 12px;
            border-radius: 50%;
        }

        /* Scree plot */
        .scree-container {
            width: 100%;
            height: 200px;
            margin-top: 16px;
        }
        .scree-container svg {
            width: 100%;
            height: 100%;
        }

        /* Diagnostic Results */
        .diagnostic-result {
            padding: 20px;
            border-radius: 16px;
            margin-top: 16px;
        }
        .diagnostic-result.manifold-yes {
            background: rgba(138, 154, 91, 0.15);
            border: 2px solid var(--sage);
        }
        .diagnostic-result.manifold-maybe {
            background: rgba(221, 161, 94, 0.15);
            border: 2px solid var(--earth);
        }
        .diagnostic-result.manifold-no {
            background: rgba(188, 108, 37, 0.15);
            border: 2px solid var(--terracotta);
        }
        .diagnostic-verdict {
            font-family: 'Lora', serif;
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 8px;
        }
        .diagnostic-score {
            display: flex;
            gap: 24px;
            margin: 16px 0;
            flex-wrap: wrap;
        }
        .score-item {
            text-align: center;
        }
        .score-value {
            font-size: 2rem;
            font-weight: 700;
            font-family: 'Lora', serif;
        }
        .score-label {
            font-size: 0.8rem;
            color: var(--sage);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Complexity Economics Section */
        .framework-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }
        .framework-card {
            padding: 20px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 14px;
            border: 1px solid rgba(138, 154, 91, 0.2);
        }
        .framework-card h4 {
            font-family: 'Lora', serif;
            color: var(--moss);
            margin-bottom: 6px;
        }
        .framework-card p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--dark-moss);
        }
        .framework-icon {
            font-size: 1.6rem;
            margin-bottom: 8px;
        }

        /* Data table preview */
        .data-preview {
            max-height: 200px;
            overflow: auto;
            border-radius: 10px;
            margin-top: 12px;
        }
        .data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        .data-preview th {
            background: var(--moss);
            color: var(--cream);
            padding: 6px 10px;
            text-align: left;
            position: sticky;
            top: 0;
        }
        .data-preview td {
            padding: 4px 10px;
            border-bottom: 1px solid rgba(138, 154, 91, 0.15);
        }
        .data-preview tr:nth-child(even) {
            background: rgba(138, 154, 91, 0.05);
        }

        /* Info box */
        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border-left: 4px solid var(--sage);
            padding: 12px 16px;
            border-radius: 0 10px 10px 0;
            margin: 12px 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* Step indicator */
        .step-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }
        .step {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--sage);
            opacity: 0.5;
        }
        .step.active {
            color: var(--moss);
            opacity: 1;
        }
        .step.completed {
            color: var(--moss);
            opacity: 0.8;
        }
        .step-num {
            width: 24px; height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            background: rgba(138, 154, 91, 0.2);
        }
        .step.active .step-num {
            background: var(--moss);
            color: var(--cream);
        }
        .step.completed .step-num {
            background: var(--sage);
            color: var(--cream);
        }
        .step-line {
            width: 30px;
            height: 2px;
            background: rgba(138, 154, 91, 0.2);
        }

        /* Metrics row */
        .metrics-row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin: 12px 0;
        }
        .metric {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(138, 154, 91, 0.15);
        }
        .metric-value {
            font-weight: 700;
            font-size: 1.2rem;
            color: var(--moss);
        }
        .metric-label {
            font-size: 0.75rem;
            color: var(--sage);
            text-transform: uppercase;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <a href="../index.html" class="organic-back-link">
        <span class="back-arrow">&#8592;</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="app-container">
        <header class="app-header">
            <h1>Manifold Explorer</h1>
            <p class="subtitle">Interactive dimensionality reduction &mdash; watch PCA, t-SNE &amp; UMAP unfold step by step</p>
        </header>

        <nav class="tab-nav">
            <button class="tab-btn active" data-tab="data">Data</button>
            <button class="tab-btn" data-tab="pca">PCA</button>
            <button class="tab-btn" data-tab="tsne">t-SNE</button>
            <button class="tab-btn" data-tab="umap">UMAP</button>
            <button class="tab-btn" data-tab="diagnostic">Diagnostic</button>
            <button class="tab-btn" data-tab="strategy">Strategy</button>
        </nav>

        <!-- ==================== DATA TAB ==================== -->
        <div class="tab-panel active" id="panel-data">
            <div class="split-layout">
                <div>
                    <div class="glass-card">
                        <h3>Load Dataset</h3>
                        <div class="control-group">
                            <label>Built-in Datasets</label>
                            <select id="dataset-select">
                                <option value="">-- Choose a dataset --</option>
                                <option value="iris" selected>Iris (4D, 3 classes)</option>
                                <option value="swiss-roll">Swiss Roll (3D manifold)</option>
                                <option value="s-curve">S-Curve (3D manifold)</option>
                                <option value="concentric">Concentric Spheres (3D)</option>
                                <option value="clusters">Gaussian Clusters (10D, 5 classes)</option>
                                <option value="helix">Double Helix (3D)</option>
                                <option value="moons">Two Moons (2D)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Sample Size</label>
                            <div class="range-row">
                                <input type="range" id="sample-size" min="50" max="1000" value="300" step="50">
                                <span class="range-val" id="sample-size-val">300</span>
                            </div>
                        </div>
                        <div class="btn-row" style="margin-top:12px">
                            <button class="btn btn-primary" id="btn-load-dataset">Generate Dataset</button>
                        </div>
                    </div>
                    <div class="glass-card">
                        <h3>Upload CSV</h3>
                        <div class="control-group">
                            <label>Your data file</label>
                            <input type="file" id="csv-upload" accept=".csv,.tsv,.txt">
                        </div>
                        <div class="info-box">
                            Numeric columns will be used as features. The last non-numeric column will be used as labels.
                        </div>
                    </div>
                    <div class="glass-card" id="data-stats-card" style="display:none">
                        <h3>Dataset Summary</h3>
                        <div class="metrics-row" id="data-metrics"></div>
                    </div>
                </div>
                <div>
                    <div class="glass-card">
                        <h2>Data Preview</h2>
                        <div id="data-preview-container">
                            <p style="color:var(--sage);text-align:center;padding:40px 0;">Select or upload a dataset to begin exploring.</p>
                        </div>
                        <div class="viz-container" id="data-viz" style="min-height:400px;margin-top:16px;display:none">
                            <svg id="data-svg"></svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== PCA TAB ==================== -->
        <div class="tab-panel" id="panel-pca">
            <div class="split-layout">
                <div>
                    <div class="glass-card">
                        <h3>PCA Controls</h3>
                        <div class="step-indicator" id="pca-steps">
                            <div class="step active" data-step="1"><span class="step-num">1</span> Center</div>
                            <div class="step-line"></div>
                            <div class="step" data-step="2"><span class="step-num">2</span> Covariance</div>
                            <div class="step-line"></div>
                            <div class="step" data-step="3"><span class="step-num">3</span> Eigenvectors</div>
                            <div class="step-line"></div>
                            <div class="step" data-step="4"><span class="step-num">4</span> Project</div>
                        </div>
                        <div class="btn-row">
                            <button class="btn btn-primary" id="btn-pca-step">Next Step</button>
                            <button class="btn btn-secondary" id="btn-pca-auto">Auto-Play</button>
                            <button class="btn btn-secondary" id="btn-pca-reset">Reset</button>
                        </div>
                        <div class="status-bar" style="margin-top:12px">
                            <div class="status-dot" id="pca-status-dot"></div>
                            <span id="pca-status-text">Load a dataset to begin</span>
                        </div>
                    </div>
                    <div class="glass-card" id="pca-info-card" style="display:none">
                        <h3>Explained Variance</h3>
                        <div class="scree-container" id="scree-plot"></div>
                        <div class="metrics-row" id="pca-metrics"></div>
                    </div>
                </div>
                <div>
                    <div class="glass-card">
                        <h2>PCA Projection</h2>
                        <div class="info-box" id="pca-explanation">
                            PCA finds the directions of maximum variance in your data. Each step reveals a principal component &mdash; an axis along which data varies the most.
                        </div>
                        <div class="viz-container" id="pca-viz" style="min-height:500px">
                            <svg id="pca-svg"></svg>
                        </div>
                        <div class="legend" id="pca-legend"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== t-SNE TAB ==================== -->
        <div class="tab-panel" id="panel-tsne">
            <div class="split-layout">
                <div>
                    <div class="glass-card">
                        <h3>t-SNE Controls</h3>
                        <div class="control-group">
                            <label>Perplexity</label>
                            <div class="range-row">
                                <input type="range" id="tsne-perplexity" min="5" max="100" value="30" step="5">
                                <span class="range-val" id="tsne-perplexity-val">30</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Learning Rate</label>
                            <div class="range-row">
                                <input type="range" id="tsne-lr" min="10" max="500" value="200" step="10">
                                <span class="range-val" id="tsne-lr-val">200</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Iterations</label>
                            <div class="range-row">
                                <input type="range" id="tsne-iters" min="100" max="1500" value="500" step="100">
                                <span class="range-val" id="tsne-iters-val">500</span>
                            </div>
                        </div>
                        <div class="btn-row">
                            <button class="btn btn-primary" id="btn-tsne-run">Run t-SNE</button>
                            <button class="btn btn-secondary" id="btn-tsne-stop">Stop</button>
                            <button class="btn btn-secondary" id="btn-tsne-reset">Reset</button>
                        </div>
                        <div class="progress-bar" style="margin-top:12px">
                            <div class="progress-fill" id="tsne-progress"></div>
                        </div>
                        <div class="status-bar">
                            <div class="status-dot" id="tsne-status-dot"></div>
                            <span id="tsne-status-text">Ready</span>
                        </div>
                    </div>
                    <div class="glass-card">
                        <h3>How t-SNE Works</h3>
                        <div class="info-box">
                            t-SNE models pairwise similarities as probabilities. In high-D, nearby points have high probability; far points have low. It then arranges points in 2D to match these probabilities, using gradient descent to minimize their divergence.
                        </div>
                        <div class="metrics-row" id="tsne-metrics"></div>
                    </div>
                </div>
                <div>
                    <div class="glass-card">
                        <h2>t-SNE Embedding</h2>
                        <div class="viz-container" id="tsne-viz" style="min-height:500px">
                            <svg id="tsne-svg"></svg>
                        </div>
                        <div class="legend" id="tsne-legend"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== UMAP TAB ==================== -->
        <div class="tab-panel" id="panel-umap">
            <div class="split-layout">
                <div>
                    <div class="glass-card">
                        <h3>UMAP Controls</h3>
                        <div class="control-group">
                            <label>N Neighbors</label>
                            <div class="range-row">
                                <input type="range" id="umap-neighbors" min="5" max="100" value="15" step="5">
                                <span class="range-val" id="umap-neighbors-val">15</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Min Distance</label>
                            <div class="range-row">
                                <input type="range" id="umap-min-dist" min="0" max="1" value="0.1" step="0.05">
                                <span class="range-val" id="umap-min-dist-val">0.10</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Iterations</label>
                            <div class="range-row">
                                <input type="range" id="umap-iters" min="100" max="1000" value="300" step="50">
                                <span class="range-val" id="umap-iters-val">300</span>
                            </div>
                        </div>
                        <div class="btn-row">
                            <button class="btn btn-primary" id="btn-umap-run">Run UMAP</button>
                            <button class="btn btn-secondary" id="btn-umap-stop">Stop</button>
                            <button class="btn btn-secondary" id="btn-umap-reset">Reset</button>
                        </div>
                        <div class="progress-bar" style="margin-top:12px">
                            <div class="progress-fill" id="umap-progress"></div>
                        </div>
                        <div class="status-bar">
                            <div class="status-dot" id="umap-status-dot"></div>
                            <span id="umap-status-text">Ready</span>
                        </div>
                    </div>
                    <div class="glass-card">
                        <h3>How UMAP Works</h3>
                        <div class="info-box">
                            UMAP builds a fuzzy topological representation of data in high dimensions, then optimizes a low-dimensional layout to have the closest possible equivalent fuzzy structure. It preserves both local and global structure.
                        </div>
                        <div class="metrics-row" id="umap-metrics"></div>
                    </div>
                </div>
                <div>
                    <div class="glass-card">
                        <h2>UMAP Embedding</h2>
                        <div class="viz-container" id="umap-viz" style="min-height:500px">
                            <svg id="umap-svg"></svg>
                        </div>
                        <div class="legend" id="umap-legend"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== DIAGNOSTIC TAB ==================== -->
        <div class="tab-panel" id="panel-diagnostic">
            <div class="glass-card">
                <h2>Does My Data Live on a Manifold?</h2>
                <p style="margin-bottom:16px;color:var(--sage)">Run automated diagnostics to determine whether dimensionality reduction is appropriate for your dataset.</p>
                <div class="btn-row">
                    <button class="btn btn-primary" id="btn-run-diagnostic">Run Full Diagnostic</button>
                </div>
                <div class="progress-bar" style="margin-top:12px">
                    <div class="progress-fill" id="diagnostic-progress"></div>
                </div>
                <div class="status-bar">
                    <div class="status-dot" id="diag-status-dot"></div>
                    <span id="diag-status-text">Load a dataset first</span>
                </div>
            </div>

            <div id="diagnostic-results" style="display:none">
                <div class="diagnostic-result" id="diag-result-box">
                    <div class="diagnostic-verdict" id="diag-verdict"></div>
                    <p id="diag-explanation"></p>
                    <div class="diagnostic-score" id="diag-scores"></div>
                </div>

                <div class="glass-card" style="margin-top:20px">
                    <h3>Diagnostic Details</h3>
                    <div class="framework-grid" id="diag-details"></div>
                </div>
            </div>
        </div>

        <!-- ==================== STRATEGY TAB ==================== -->
        <div class="tab-panel" id="panel-strategy">
            <div class="glass-card">
                <h2>The Manifold Hypothesis &amp; Complexity Economics</h2>
                <p style="margin-bottom:12px">Connecting dimensionality reduction to Eric Beinhocker's <em>The Origin of Wealth</em> complexity economics framework.</p>
                <div class="info-box">
                    <strong>Core insight:</strong> Just as high-dimensional data often lies on a lower-dimensional manifold, market dynamics and strategic options &mdash; seemingly infinite &mdash; often inhabit a lower-dimensional "strategy space" shaped by a few key driving forces.
                </div>
            </div>

            <div class="framework-grid">
                <div class="glass-card framework-card">
                    <div class="framework-icon">&#127758;</div>
                    <h4>Fitness Landscapes</h4>
                    <p>Beinhocker describes businesses navigating rugged fitness landscapes. Dimensionality reduction reveals the <strong>true dimensionality</strong> of your competitive landscape &mdash; how many independent factors actually drive success. If PCA shows 90% variance in 2-3 components, your strategic space is simpler than it appears.</p>
                </div>
                <div class="glass-card framework-card">
                    <div class="framework-icon">&#127793;</div>
                    <h4>Deductive Tinkering</h4>
                    <p>Rather than predicting the future, Beinhocker advocates exploring the adjacent possible through many small experiments. Manifold structure tells you <strong>where to tinker</strong>: along the manifold surface where variation matters, not orthogonal to it where changes are noise.</p>
                </div>
                <div class="glass-card framework-card">
                    <div class="framework-icon">&#128200;</div>
                    <h4>Business Plan Populations</h4>
                    <p>In complexity economics, firms maintain populations of business plans competing for resources. t-SNE/UMAP reveal the <strong>clusters and gaps</strong> in your strategy portfolio &mdash; are your plans diverse enough to cover the landscape, or dangerously concentrated?</p>
                </div>
                <div class="glass-card framework-card">
                    <div class="framework-icon">&#128300;</div>
                    <h4>When Reduction Works</h4>
                    <p>If your data lives on a manifold, it means <strong>latent structure</strong> governs apparent complexity. For business: customer segments, market dynamics, and operational metrics that look independent may be driven by a few hidden factors. Finding them is the key to strategy.</p>
                </div>
                <div class="glass-card framework-card">
                    <div class="framework-icon">&#9888;</div>
                    <h4>When Reduction Fails</h4>
                    <p>If the diagnostic says &ldquo;no manifold,&rdquo; your domain may be <strong>genuinely high-dimensional</strong> &mdash; like early-stage markets with no established structure. In Beinhocker's terms, the fitness landscape is so rugged that no simple map captures it. You need more data or a different framing.</p>
                </div>
                <div class="glass-card framework-card">
                    <div class="framework-icon">&#128161;</div>
                    <h4>Practical Application</h4>
                    <p><strong>Step 1:</strong> Gather your key business metrics (customer data, operational KPIs, market signals).<br>
                    <strong>Step 2:</strong> Run them through this explorer.<br>
                    <strong>Step 3:</strong> If a manifold exists, the principal components ARE your strategic dimensions.<br>
                    <strong>Step 4:</strong> Use cluster structure to identify strategic positions and white space.</p>
                </div>
            </div>

            <div class="glass-card" style="margin-top:20px" id="strategy-dynamic">
                <h3>Your Data &amp; Strategy</h3>
                <div id="strategy-content">
                    <p style="color:var(--sage);text-align:center;padding:20px 0;">Load a dataset and run the diagnostic to see strategy insights tailored to your data.</p>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
    (function() {
        'use strict';

        // ========== STATE ==========
        const state = {
            data: null,       // { X: number[][], labels: string[], featureNames: string[] }
            pca: null,        // PCA results
            tsne: null,       // t-SNE state
            umap: null,       // UMAP state
            diagnostic: null, // Diagnostic results
            running: { tsne: false, umap: false }
        };

        const CLASS_COLORS = ['#606C38','#DDA15E','#BC6C25','#8A9A5B','#7B2D8E','#2D6A8E','#D4543A','#3A8E6A','#8E6A3A','#3A3A8E'];

        // ========== UTILITIES ==========
        function mean(arr) { return arr.reduce((a,b) => a+b, 0) / arr.length; }
        function std(arr) { const m = mean(arr); return Math.sqrt(arr.reduce((a,b) => a + (b-m)*(b-m), 0) / arr.length); }

        function transpose(M) {
            const rows = M.length, cols = M[0].length;
            const T = Array.from({length: cols}, () => new Float64Array(rows));
            for (let i = 0; i < rows; i++)
                for (let j = 0; j < cols; j++)
                    T[j][i] = M[i][j];
            return T;
        }

        function matMul(A, B) {
            const m = A.length, n = B[0].length, p = B.length;
            const C = Array.from({length: m}, () => new Float64Array(n));
            for (let i = 0; i < m; i++)
                for (let k = 0; k < p; k++) {
                    const a = A[i][k];
                    for (let j = 0; j < n; j++)
                        C[i][j] += a * B[k][j];
                }
            return C;
        }

        function euclidean(a, b) {
            let s = 0;
            for (let i = 0; i < a.length; i++) { const d = a[i] - b[i]; s += d*d; }
            return Math.sqrt(s);
        }

        function distanceMatrix(X) {
            const n = X.length;
            const D = Array.from({length: n}, () => new Float64Array(n));
            for (let i = 0; i < n; i++)
                for (let j = i+1; j < n; j++) {
                    const d = euclidean(X[i], X[j]);
                    D[i][j] = d;
                    D[j][i] = d;
                }
            return D;
        }

        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // ========== DATASET GENERATORS ==========
        function generateIris(n) {
            // Simulated Iris-like data with 4 features and 3 classes
            const X = [], labels = [];
            const centers = [[5.0,3.4,1.5,0.2],[5.9,2.8,4.3,1.3],[6.6,3.0,5.6,2.0]];
            const stds = [[0.35,0.38,0.17,0.1],[0.52,0.31,0.47,0.2],[0.64,0.32,0.55,0.27]];
            const names = ['Setosa','Versicolor','Virginica'];
            const perClass = Math.floor(n / 3);
            for (let c = 0; c < 3; c++) {
                for (let i = 0; i < (c < 2 ? perClass : n - 2*perClass); i++) {
                    X.push(centers[c].map((m, j) => m + randn() * stds[c][j]));
                    labels.push(names[c]);
                }
            }
            return { X, labels, featureNames: ['Sepal Length','Sepal Width','Petal Length','Petal Width'] };
        }

        function generateSwissRoll(n) {
            const X = [], labels = [];
            for (let i = 0; i < n; i++) {
                const t = 1.5 * Math.PI * (1 + 2 * Math.random());
                const y = 21 * Math.random();
                X.push([t * Math.cos(t), y, t * Math.sin(t)]);
                labels.push(t < 7 ? 'Inner' : t < 11 ? 'Middle' : 'Outer');
            }
            return { X, labels, featureNames: ['X','Y','Z'] };
        }

        function generateSCurve(n) {
            const X = [], labels = [];
            for (let i = 0; i < n; i++) {
                const t = 3 * Math.PI * (Math.random() - 0.5);
                const y = 2 * Math.random();
                X.push([Math.sin(t), y, Math.sign(t) * (Math.cos(t) - 1)]);
                labels.push(t < -1 ? 'Lower' : t < 1 ? 'Middle' : 'Upper');
            }
            return { X, labels, featureNames: ['X','Y','Z'] };
        }

        function generateConcentric(n) {
            const X = [], labels = [];
            const perShell = Math.floor(n / 2);
            for (let i = 0; i < perShell; i++) {
                const phi = Math.random() * Math.PI * 2;
                const cosTheta = 2 * Math.random() - 1;
                const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                const r = 1 + randn() * 0.1;
                X.push([r*sinTheta*Math.cos(phi), r*sinTheta*Math.sin(phi), r*cosTheta]);
                labels.push('Inner');
            }
            for (let i = 0; i < n - perShell; i++) {
                const phi = Math.random() * Math.PI * 2;
                const cosTheta = 2 * Math.random() - 1;
                const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                const r = 3 + randn() * 0.1;
                X.push([r*sinTheta*Math.cos(phi), r*sinTheta*Math.sin(phi), r*cosTheta]);
                labels.push('Outer');
            }
            return { X, labels, featureNames: ['X','Y','Z'] };
        }

        function generateClusters(n) {
            const dim = 10, k = 5;
            const X = [], labels = [];
            const classNames = ['Alpha','Beta','Gamma','Delta','Epsilon'];
            const centers = Array.from({length: k}, () => Array.from({length: dim}, () => randn() * 5));
            const perClass = Math.floor(n / k);
            for (let c = 0; c < k; c++) {
                for (let i = 0; i < (c < k-1 ? perClass : n - (k-1)*perClass); i++) {
                    X.push(centers[c].map(m => m + randn() * 0.8));
                    labels.push(classNames[c]);
                }
            }
            return { X, labels, featureNames: Array.from({length: dim}, (_, i) => `Dim ${i+1}`) };
        }

        function generateHelix(n) {
            const X = [], labels = [];
            const half = Math.floor(n / 2);
            for (let i = 0; i < half; i++) {
                const t = i / half * 4 * Math.PI;
                X.push([Math.cos(t) + randn()*0.1, t/2 + randn()*0.1, Math.sin(t) + randn()*0.1]);
                labels.push('Helix A');
            }
            for (let i = 0; i < n - half; i++) {
                const t = i / (n - half) * 4 * Math.PI;
                X.push([Math.cos(t + Math.PI) + randn()*0.1, t/2 + randn()*0.1, Math.sin(t + Math.PI) + randn()*0.1]);
                labels.push('Helix B');
            }
            return { X, labels, featureNames: ['X','Y','Z'] };
        }

        function generateMoons(n) {
            const X = [], labels = [];
            const half = Math.floor(n / 2);
            for (let i = 0; i < half; i++) {
                const a = Math.PI * i / half;
                X.push([Math.cos(a) + randn()*0.1, Math.sin(a) + randn()*0.1]);
                labels.push('Moon A');
            }
            for (let i = 0; i < n - half; i++) {
                const a = Math.PI * i / (n - half);
                X.push([1 - Math.cos(a) + randn()*0.1, 0.5 - Math.sin(a) + randn()*0.1]);
                labels.push('Moon B');
            }
            return { X, labels, featureNames: ['X','Y'] };
        }

        const GENERATORS = {
            'iris': generateIris,
            'swiss-roll': generateSwissRoll,
            's-curve': generateSCurve,
            'concentric': generateConcentric,
            'clusters': generateClusters,
            'helix': generateHelix,
            'moons': generateMoons
        };

        // ========== DATA LOADING ==========
        function loadBuiltinDataset() {
            const name = document.getElementById('dataset-select').value;
            const n = parseInt(document.getElementById('sample-size').value);
            if (!name || !GENERATORS[name]) return;
            const data = GENERATORS[name](n);
            setData(data);
        }

        function loadCSV(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const lines = e.target.result.trim().split('\n');
                if (lines.length < 2) return;
                const headers = lines[0].split(/[,\t]/);
                const rows = lines.slice(1).map(l => l.split(/[,\t]/));

                // Detect numeric columns
                const isNumeric = headers.map((_, j) => rows.every(r => !isNaN(parseFloat(r[j]))));
                const numericCols = headers.map((h, i) => ({name: h, idx: i})).filter((_, i) => isNumeric[i]);
                const labelCol = headers.map((h, i) => ({name: h, idx: i})).filter((_, i) => !isNumeric[i]).pop();

                if (numericCols.length < 2) { alert('Need at least 2 numeric columns.'); return; }

                const X = rows.map(r => numericCols.map(c => parseFloat(r[c.idx])));
                const labels = labelCol ? rows.map(r => r[labelCol.idx]) : rows.map((_, i) => 'Point');
                const featureNames = numericCols.map(c => c.name);

                setData({ X, labels, featureNames });
            };
            reader.readAsText(file);
        }

        function setData(data) {
            state.data = data;
            state.pca = null;
            state.tsne = null;
            state.umap = null;
            state.diagnostic = null;

            showDataPreview();
            showDataStats();
            updateAllLegends();
            document.getElementById('data-viz').style.display = 'block';
            showDataScatter();
        }

        function showDataPreview() {
            const { X, labels, featureNames } = state.data;
            const container = document.getElementById('data-preview-container');
            const rows = Math.min(X.length, 10);
            let html = '<div class="data-preview"><table><tr><th>#</th>';
            featureNames.forEach(f => html += `<th>${f}</th>`);
            html += '<th>Label</th></tr>';
            for (let i = 0; i < rows; i++) {
                html += `<tr><td>${i+1}</td>`;
                X[i].forEach(v => html += `<td>${v.toFixed(3)}</td>`);
                html += `<td>${labels[i]}</td></tr>`;
            }
            if (X.length > 10) html += `<tr><td colspan="${featureNames.length+2}" style="text-align:center;color:var(--sage)">... ${X.length - 10} more rows</td></tr>`;
            html += '</table></div>';
            container.innerHTML = html;
        }

        function showDataStats() {
            const { X, labels, featureNames } = state.data;
            const uniqueLabels = [...new Set(labels)];
            document.getElementById('data-stats-card').style.display = 'block';
            document.getElementById('data-metrics').innerHTML = `
                <div class="metric"><div class="metric-value">${X.length}</div><div class="metric-label">Samples</div></div>
                <div class="metric"><div class="metric-value">${featureNames.length}</div><div class="metric-label">Dimensions</div></div>
                <div class="metric"><div class="metric-value">${uniqueLabels.length}</div><div class="metric-label">Classes</div></div>
            `;
        }

        // ========== SCATTER PLOT ==========
        function createScatter(svgId, containerId, points2d, labels, title) {
            const container = document.getElementById(containerId);
            const width = container.clientWidth || 600;
            const height = container.clientHeight || 500;
            const margin = { top: 10, right: 20, bottom: 30, left: 40 };

            const svg = d3.select('#' + svgId);
            svg.selectAll('*').remove();
            svg.attr('viewBox', `0 0 ${width} ${height}`);

            if (!points2d || points2d.length === 0) return;

            const xExt = d3.extent(points2d, d => d[0]);
            const yExt = d3.extent(points2d, d => d[1]);
            const xPad = (xExt[1] - xExt[0]) * 0.08 || 1;
            const yPad = (yExt[1] - yExt[0]) * 0.08 || 1;

            const x = d3.scaleLinear()
                .domain([xExt[0] - xPad, xExt[1] + xPad])
                .range([margin.left, width - margin.right]);
            const y = d3.scaleLinear()
                .domain([yExt[0] - yPad, yExt[1] + yPad])
                .range([height - margin.bottom, margin.top]);

            const uniqueLabels = [...new Set(labels)];
            const color = (label) => CLASS_COLORS[uniqueLabels.indexOf(label) % CLASS_COLORS.length];

            const g = svg.append('g');

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(6).tickSize(-height + margin.top + margin.bottom))
                .selectAll('line').attr('stroke', 'rgba(138,154,91,0.15)');
            g.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(6).tickSize(-width + margin.left + margin.right))
                .selectAll('line').attr('stroke', 'rgba(138,154,91,0.15)');

            svg.selectAll('.domain').attr('stroke', 'rgba(138,154,91,0.3)');
            svg.selectAll('.tick text').attr('fill', 'var(--sage)').attr('font-size', '10px');

            // Points
            const circles = g.selectAll('circle')
                .data(points2d.map((p, i) => ({ x: p[0], y: p[1], label: labels[i], idx: i })))
                .enter().append('circle')
                .attr('cx', d => x(d.x))
                .attr('cy', d => y(d.y))
                .attr('r', 0)
                .attr('fill', d => color(d.label))
                .attr('opacity', 0.7)
                .attr('stroke', 'white')
                .attr('stroke-width', 0.5);

            circles.transition()
                .duration(600)
                .delay((d, i) => i * 1.5)
                .attr('r', Math.max(2, Math.min(5, 1500 / points2d.length)));

            // Tooltip
            const tooltip = document.getElementById('tooltip');
            circles.on('mouseenter', function(event, d) {
                d3.select(this).attr('r', 8).attr('opacity', 1);
                tooltip.style.opacity = 1;
                const feat = state.data ? state.data.featureNames : [];
                const vals = state.data ? state.data.X[d.idx] : [];
                let html = `<strong>${d.label}</strong><br>`;
                feat.forEach((f, i) => { if (vals[i] !== undefined) html += `${f}: ${vals[i].toFixed(2)}<br>`; });
                tooltip.innerHTML = html;
            }).on('mousemove', function(event) {
                tooltip.style.left = (event.pageX + 12) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            }).on('mouseleave', function() {
                const r = Math.max(2, Math.min(5, 1500 / points2d.length));
                d3.select(this).attr('r', r).attr('opacity', 0.7);
                tooltip.style.opacity = 0;
            });

            return { svg, x, y, g, circles };
        }

        function animateScatter(svgId, containerId, oldPoints, newPoints, labels, duration) {
            duration = duration || 800;
            const container = document.getElementById(containerId);
            const width = container.clientWidth || 600;
            const height = container.clientHeight || 500;
            const margin = { top: 10, right: 20, bottom: 30, left: 40 };

            if (!newPoints || newPoints.length === 0) return;

            const xExt = d3.extent(newPoints, d => d[0]);
            const yExt = d3.extent(newPoints, d => d[1]);
            const xPad = (xExt[1] - xExt[0]) * 0.08 || 1;
            const yPad = (yExt[1] - yExt[0]) * 0.08 || 1;

            const x = d3.scaleLinear()
                .domain([xExt[0] - xPad, xExt[1] + xPad])
                .range([margin.left, width - margin.right]);
            const y = d3.scaleLinear()
                .domain([yExt[0] - yPad, yExt[1] + yPad])
                .range([height - margin.bottom, margin.top]);

            const svg = d3.select('#' + svgId);
            svg.selectAll('circle')
                .data(newPoints.map((p, i) => ({ x: p[0], y: p[1], label: labels[i], idx: i })))
                .transition()
                .duration(duration)
                .ease(d3.easeCubicInOut)
                .attr('cx', d => x(d.x))
                .attr('cy', d => y(d.y));

            // Update axes
            svg.select('g').selectAll('g').remove();
            const g = svg.select('g');
            g.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(6).tickSize(-height + margin.top + margin.bottom))
                .selectAll('line').attr('stroke', 'rgba(138,154,91,0.15)');
            g.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(6).tickSize(-width + margin.left + margin.right))
                .selectAll('line').attr('stroke', 'rgba(138,154,91,0.15)');
            svg.selectAll('.domain').attr('stroke', 'rgba(138,154,91,0.3)');
            svg.selectAll('.tick text').attr('fill', 'var(--sage)').attr('font-size', '10px');
        }

        function showDataScatter() {
            if (!state.data) return;
            const { X, labels } = state.data;
            // Quick PCA to 2D for preview
            const proj = quickPCA(X, 2);
            createScatter('data-svg', 'data-viz', proj, labels);
        }

        function updateLegend(containerId, labels) {
            const el = document.getElementById(containerId);
            if (!el) return;
            const unique = [...new Set(labels)];
            el.innerHTML = unique.map((l, i) =>
                `<div class="legend-item"><div class="legend-dot" style="background:${CLASS_COLORS[i % CLASS_COLORS.length]}"></div>${l}</div>`
            ).join('');
        }

        function updateAllLegends() {
            if (!state.data) return;
            ['pca-legend','tsne-legend','umap-legend'].forEach(id => updateLegend(id, state.data.labels));
        }

        // ========== PCA ==========
        function centerData(X) {
            const d = X[0].length;
            const means = new Float64Array(d);
            for (let i = 0; i < X.length; i++)
                for (let j = 0; j < d; j++)
                    means[j] += X[i][j];
            for (let j = 0; j < d; j++) means[j] /= X.length;

            return {
                centered: X.map(row => row.map((v, j) => v - means[j])),
                means: Array.from(means)
            };
        }

        function covarianceMatrix(Xc) {
            const n = Xc.length, d = Xc[0].length;
            const C = Array.from({length: d}, () => new Float64Array(d));
            for (let i = 0; i < d; i++)
                for (let j = i; j < d; j++) {
                    let s = 0;
                    for (let k = 0; k < n; k++) s += Xc[k][i] * Xc[k][j];
                    C[i][j] = s / (n - 1);
                    C[j][i] = C[i][j];
                }
            return C;
        }

        // Power iteration for eigendecomposition
        function eigenDecomposition(C, numComponents) {
            const d = C.length;
            numComponents = Math.min(numComponents, d);
            const eigenvalues = [];
            const eigenvectors = [];
            let A = C.map(row => [...row]);

            for (let comp = 0; comp < numComponents; comp++) {
                let v = Array.from({length: d}, () => randn());
                let norm = Math.sqrt(v.reduce((s, x) => s + x*x, 0));
                v = v.map(x => x / norm);

                for (let iter = 0; iter < 200; iter++) {
                    const Av = new Float64Array(d);
                    for (let i = 0; i < d; i++)
                        for (let j = 0; j < d; j++)
                            Av[i] += A[i][j] * v[j];
                    norm = Math.sqrt(Av.reduce((s, x) => s + x*x, 0));
                    if (norm < 1e-10) break;
                    const newV = Array.from(Av).map(x => x / norm);

                    let diff = 0;
                    for (let i = 0; i < d; i++) diff += (newV[i] - v[i]) ** 2;
                    v = newV;
                    if (diff < 1e-12) break;
                }

                const eigenvalue = norm;
                eigenvalues.push(eigenvalue);
                eigenvectors.push([...v]);

                // Deflate
                for (let i = 0; i < d; i++)
                    for (let j = 0; j < d; j++)
                        A[i][j] -= eigenvalue * v[i] * v[j];
            }

            return { eigenvalues, eigenvectors };
        }

        function projectPCA(Xc, eigenvectors, numComponents) {
            const V = eigenvectors.slice(0, numComponents);
            return Xc.map(row => V.map(v => row.reduce((s, x, j) => s + x * v[j], 0)));
        }

        function quickPCA(X, dims) {
            const { centered } = centerData(X);
            const cov = covarianceMatrix(centered);
            const { eigenvectors } = eigenDecomposition(cov, dims);
            return projectPCA(centered, eigenvectors, dims);
        }

        // Step-by-step PCA
        let pcaStep = 0;
        let pcaAutoPlaying = false;

        function resetPCA() {
            pcaStep = 0;
            pcaAutoPlaying = false;
            state.pca = null;
            document.getElementById('pca-info-card').style.display = 'none';
            updatePCASteps();
            setStatus('pca', 'idle', 'Load a dataset to begin');
            d3.select('#pca-svg').selectAll('*').remove();
            document.getElementById('pca-explanation').innerHTML = 'PCA finds the directions of maximum variance in your data. Each step reveals a principal component &mdash; an axis along which data varies the most.';
        }

        function updatePCASteps() {
            const steps = document.querySelectorAll('#pca-steps .step');
            steps.forEach((el, i) => {
                el.classList.remove('active', 'completed');
                if (i + 1 < pcaStep) el.classList.add('completed');
                else if (i + 1 === pcaStep) el.classList.add('active');
            });
        }

        function runPCAStep() {
            if (!state.data) { alert('Load a dataset first.'); return; }
            pcaStep++;
            if (pcaStep > 4) { pcaStep = 4; return; }
            updatePCASteps();

            const { X, labels } = state.data;

            if (pcaStep === 1) {
                // Step 1: Center data
                setStatus('pca', 'running', 'Centering data (subtracting means)...');
                document.getElementById('pca-explanation').innerHTML = '<strong>Step 1 â€” Centering:</strong> Subtract the mean of each feature so the data is centered at the origin. This ensures PCA captures variance, not position.';

                const { centered, means } = centerData(X);
                state.pca = { centered, means };

                const proj = quickPCA(X, 2);
                createScatter('pca-svg', 'pca-viz', proj, labels);
                setTimeout(() => {
                    const centeredProj = centered.map(row => [row[0], row.length > 1 ? row[1] : 0]);
                    animateScatter('pca-svg', 'pca-viz', proj, centeredProj, labels, 1000);
                    setStatus('pca', 'done', 'Data centered');
                }, 200);
            }
            else if (pcaStep === 2) {
                // Step 2: Covariance matrix
                setStatus('pca', 'running', 'Computing covariance matrix...');
                document.getElementById('pca-explanation').innerHTML = '<strong>Step 2 â€” Covariance:</strong> Compute the covariance matrix, which describes how each pair of features varies together. This is the heart of PCA &mdash; eigenvectors of this matrix give the principal components.';

                const cov = covarianceMatrix(state.pca.centered);
                state.pca.covariance = cov;

                setTimeout(() => setStatus('pca', 'done', `Covariance matrix: ${cov.length}Ã—${cov.length}`), 300);
            }
            else if (pcaStep === 3) {
                // Step 3: Eigendecomposition
                setStatus('pca', 'running', 'Finding eigenvectors (principal components)...');
                document.getElementById('pca-explanation').innerHTML = '<strong>Step 3 â€” Eigenvectors:</strong> Extract eigenvalues and eigenvectors from the covariance matrix. Each eigenvector is a principal component; its eigenvalue tells you how much variance it captures.';

                const numComp = Math.min(state.data.featureNames.length, 10);
                const { eigenvalues, eigenvectors } = eigenDecomposition(state.pca.covariance, numComp);
                state.pca.eigenvalues = eigenvalues;
                state.pca.eigenvectors = eigenvectors;

                // Show scree plot
                showScreePlot(eigenvalues);
                document.getElementById('pca-info-card').style.display = 'block';

                const totalVar = eigenvalues.reduce((a, b) => a + b, 0);
                const explained2 = ((eigenvalues[0] + (eigenvalues[1] || 0)) / totalVar * 100).toFixed(1);
                document.getElementById('pca-metrics').innerHTML = `
                    <div class="metric"><div class="metric-value">${numComp}</div><div class="metric-label">Components</div></div>
                    <div class="metric"><div class="metric-value">${explained2}%</div><div class="metric-label">Variance (PC1+2)</div></div>
                `;
                setStatus('pca', 'done', `${numComp} eigenvectors found`);
            }
            else if (pcaStep === 4) {
                // Step 4: Project
                setStatus('pca', 'running', 'Projecting data onto top 2 components...');
                document.getElementById('pca-explanation').innerHTML = '<strong>Step 4 â€” Projection:</strong> Project each data point onto the top 2 principal components. The result is the best 2D view of your data that preserves maximum variance.';

                const projected = projectPCA(state.pca.centered, state.pca.eigenvectors, 2);
                state.pca.projected = projected;

                createScatter('pca-svg', 'pca-viz', projected, labels);
                setStatus('pca', 'done', 'PCA projection complete');
            }
        }

        function autoPCA() {
            if (!state.data) { alert('Load a dataset first.'); return; }
            if (pcaAutoPlaying) { pcaAutoPlaying = false; return; }
            pcaAutoPlaying = true;
            pcaStep = 0;
            resetPCA();

            function nextStep() {
                if (!pcaAutoPlaying || pcaStep >= 4) { pcaAutoPlaying = false; return; }
                runPCAStep();
                setTimeout(nextStep, 1500);
            }
            setTimeout(nextStep, 300);
        }

        function showScreePlot(eigenvalues) {
            const container = document.getElementById('scree-plot');
            const width = container.clientWidth || 280;
            const height = 180;
            const margin = { top: 10, right: 10, bottom: 30, left: 40 };

            container.innerHTML = '<svg></svg>';
            const svg = d3.select('#scree-plot svg')
                .attr('viewBox', `0 0 ${width} ${height}`);

            const totalVar = eigenvalues.reduce((a, b) => a + b, 0);
            const explained = eigenvalues.map(e => e / totalVar * 100);
            const cumulative = explained.reduce((acc, v) => { acc.push((acc.length ? acc[acc.length-1] : 0) + v); return acc; }, []);

            const x = d3.scaleBand()
                .domain(explained.map((_, i) => i+1))
                .range([margin.left, width - margin.right])
                .padding(0.3);
            const y = d3.scaleLinear()
                .domain([0, 100])
                .range([height - margin.bottom, margin.top]);

            // Bars
            svg.selectAll('rect')
                .data(explained)
                .enter().append('rect')
                .attr('x', (d, i) => x(i+1))
                .attr('y', d => y(d))
                .attr('width', x.bandwidth())
                .attr('height', d => y(0) - y(d))
                .attr('fill', 'var(--sage)')
                .attr('rx', 3)
                .attr('opacity', 0.8);

            // Cumulative line
            const line = d3.line()
                .x((d, i) => x(i+1) + x.bandwidth()/2)
                .y(d => y(d));
            svg.append('path')
                .datum(cumulative)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', 'var(--terracotta)')
                .attr('stroke-width', 2);

            svg.selectAll('.cum-dot')
                .data(cumulative)
                .enter().append('circle')
                .attr('cx', (d, i) => x(i+1) + x.bandwidth()/2)
                .attr('cy', d => y(d))
                .attr('r', 3)
                .attr('fill', 'var(--terracotta)');

            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x))
                .selectAll('text').attr('fill', 'var(--sage)').attr('font-size', '9px');
            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(5).tickFormat(d => d + '%'))
                .selectAll('text').attr('fill', 'var(--sage)').attr('font-size', '9px');
            svg.selectAll('.domain').attr('stroke', 'rgba(138,154,91,0.3)');
        }

        // ========== t-SNE ==========
        function computeHighDimProbs(X, perplexity) {
            const n = X.length;
            const D = distanceMatrix(X);
            const P = Array.from({length: n}, () => new Float64Array(n));

            for (let i = 0; i < n; i++) {
                let lo = 1e-10, hi = 1e4, sigma = 1;

                for (let iter = 0; iter < 50; iter++) {
                    sigma = (lo + hi) / 2;
                    let sumP = 0;
                    for (let j = 0; j < n; j++) {
                        if (j === i) continue;
                        P[i][j] = Math.exp(-D[i][j] * D[i][j] / (2 * sigma * sigma));
                        sumP += P[i][j];
                    }
                    if (sumP < 1e-10) sumP = 1e-10;
                    for (let j = 0; j < n; j++) P[i][j] /= sumP;

                    let H = 0;
                    for (let j = 0; j < n; j++) {
                        if (j === i || P[i][j] < 1e-10) continue;
                        H -= P[i][j] * Math.log2(P[i][j]);
                    }

                    const perpCurr = Math.pow(2, H);
                    if (Math.abs(perpCurr - perplexity) < 0.01) break;
                    if (perpCurr > perplexity) hi = sigma;
                    else lo = sigma;
                }
            }

            // Symmetrize
            const Psym = Array.from({length: n}, () => new Float64Array(n));
            for (let i = 0; i < n; i++)
                for (let j = i+1; j < n; j++) {
                    const val = (P[i][j] + P[j][i]) / (2 * n);
                    Psym[i][j] = val;
                    Psym[j][i] = val;
                }

            return Psym;
        }

        function tsneInit(X, perplexity) {
            const n = X.length;
            const P = computeHighDimProbs(X, perplexity);

            // Initialize Y randomly
            const Y = Array.from({length: n}, () => [randn() * 0.01, randn() * 0.01]);
            const gains = Array.from({length: n}, () => [1, 1]);
            const ystep = Array.from({length: n}, () => [0, 0]);

            return { P, Y, gains, ystep, iter: 0 };
        }

        function tsneStep(tsneState, lr, momentum) {
            const { P, Y, gains, ystep } = tsneState;
            const n = Y.length;

            // Compute Q (Student t-distribution)
            const Q = Array.from({length: n}, () => new Float64Array(n));
            let sumQ = 0;
            for (let i = 0; i < n; i++)
                for (let j = i+1; j < n; j++) {
                    const dx = Y[i][0] - Y[j][0], dy = Y[i][1] - Y[j][1];
                    const q = 1 / (1 + dx*dx + dy*dy);
                    Q[i][j] = q;
                    Q[j][i] = q;
                    sumQ += 2 * q;
                }
            if (sumQ < 1e-10) sumQ = 1e-10;

            // Compute gradients
            const grad = Array.from({length: n}, () => [0, 0]);
            let cost = 0;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i === j) continue;
                    const qij = Q[i][j] / sumQ;
                    const pij = P[i][j];
                    if (pij > 1e-10) cost += pij * Math.log(pij / Math.max(qij, 1e-10));

                    const mult = 4 * (pij - qij) * Q[i][j];
                    grad[i][0] += mult * (Y[i][0] - Y[j][0]);
                    grad[i][1] += mult * (Y[i][1] - Y[j][1]);
                }
            }

            // Update
            for (let i = 0; i < n; i++) {
                for (let d = 0; d < 2; d++) {
                    gains[i][d] = Math.max(0.01,
                        (Math.sign(grad[i][d]) !== Math.sign(ystep[i][d])) ? gains[i][d] + 0.2 : gains[i][d] * 0.8);
                    ystep[i][d] = momentum * ystep[i][d] - lr * gains[i][d] * grad[i][d];
                    Y[i][d] += ystep[i][d];
                }
            }

            // Center
            const meanY = [mean(Y.map(p => p[0])), mean(Y.map(p => p[1]))];
            for (let i = 0; i < n; i++) { Y[i][0] -= meanY[0]; Y[i][1] -= meanY[1]; }

            tsneState.iter++;
            return cost;
        }

        async function runTSNE() {
            if (!state.data) { alert('Load a dataset first.'); return; }
            if (state.running.tsne) return;
            state.running.tsne = true;

            const perplexity = parseInt(document.getElementById('tsne-perplexity').value);
            const lr = parseInt(document.getElementById('tsne-lr').value);
            const maxIter = parseInt(document.getElementById('tsne-iters').value);

            setStatus('tsne', 'running', 'Computing pairwise similarities...');
            document.getElementById('tsne-progress').style.width = '0%';

            await new Promise(r => setTimeout(r, 50));

            const tsneState = tsneInit(state.data.X, perplexity);
            state.tsne = tsneState;

            createScatter('tsne-svg', 'tsne-viz', tsneState.Y, state.data.labels);

            setStatus('tsne', 'running', 'Optimizing embedding...');

            const batchSize = 5;
            let lastCost = 0;

            for (let i = 0; i < maxIter && state.running.tsne; i += batchSize) {
                for (let b = 0; b < batchSize && i + b < maxIter; b++) {
                    const momentum = (tsneState.iter < 250) ? 0.5 : 0.8;
                    const earlyExag = (tsneState.iter < 100) ? 4 : 1;
                    if (earlyExag > 1) {
                        // Temporarily amplify P
                        const n = tsneState.P.length;
                        for (let ii = 0; ii < n; ii++)
                            for (let jj = 0; jj < n; jj++)
                                tsneState.P[ii][jj] *= earlyExag;
                        lastCost = tsneStep(tsneState, lr, momentum);
                        for (let ii = 0; ii < n; ii++)
                            for (let jj = 0; jj < n; jj++)
                                tsneState.P[ii][jj] /= earlyExag;
                    } else {
                        lastCost = tsneStep(tsneState, lr, momentum);
                    }
                }

                const progress = ((i + batchSize) / maxIter * 100).toFixed(0);
                document.getElementById('tsne-progress').style.width = progress + '%';
                setStatus('tsne', 'running', `Iteration ${Math.min(i + batchSize, maxIter)}/${maxIter} â€” KL: ${lastCost.toFixed(3)}`);

                animateScatter('tsne-svg', 'tsne-viz', null, tsneState.Y, state.data.labels, 80);
                await new Promise(r => setTimeout(r, 30));
            }

            state.running.tsne = false;
            document.getElementById('tsne-progress').style.width = '100%';
            setStatus('tsne', 'done', `Complete â€” KL divergence: ${lastCost.toFixed(4)}`);

            document.getElementById('tsne-metrics').innerHTML = `
                <div class="metric"><div class="metric-value">${tsneState.iter}</div><div class="metric-label">Iterations</div></div>
                <div class="metric"><div class="metric-value">${lastCost.toFixed(3)}</div><div class="metric-label">KL Divergence</div></div>
                <div class="metric"><div class="metric-value">${perplexity}</div><div class="metric-label">Perplexity</div></div>
            `;
        }

        // ========== UMAP (Simplified) ==========
        function knnGraph(X, k) {
            const n = X.length;
            const D = distanceMatrix(X);
            const neighbors = Array.from({length: n}, () => []);

            for (let i = 0; i < n; i++) {
                const dists = D[i].map((d, j) => ({j, d})).filter(x => x.j !== i).sort((a,b) => a.d - b.d);
                neighbors[i] = dists.slice(0, k).map(x => ({ idx: x.j, dist: x.d }));
            }
            return { neighbors, D };
        }

        function umapInit(X, nNeighbors, minDist) {
            const n = X.length;
            const { neighbors, D } = knnGraph(X, nNeighbors);

            // Compute fuzzy simplicial set (simplified)
            const sigma = new Float64Array(n);
            for (let i = 0; i < n; i++) {
                const nn = neighbors[i];
                if (nn.length === 0) { sigma[i] = 1; continue; }
                const rho = nn[0].dist;
                let lo = 0, hi = 100, mid = 1;
                for (let iter = 0; iter < 64; iter++) {
                    mid = (lo + hi) / 2;
                    let s = 0;
                    for (let j = 0; j < nn.length; j++) {
                        const d = Math.max(0, nn[j].dist - rho);
                        s += Math.exp(-d / mid);
                    }
                    if (Math.abs(s - Math.log2(nNeighbors)) < 0.01) break;
                    if (s > Math.log2(nNeighbors)) hi = mid;
                    else lo = mid;
                }
                sigma[i] = mid;
            }

            // Build edge weights
            const edges = [];
            const edgeSet = new Set();
            for (let i = 0; i < n; i++) {
                const nn = neighbors[i];
                const rho = nn.length > 0 ? nn[0].dist : 0;
                for (let j = 0; j < nn.length; j++) {
                    const idx = nn[j].idx;
                    const w = Math.exp(-Math.max(0, nn[j].dist - rho) / sigma[i]);
                    const key = Math.min(i, idx) + ',' + Math.max(i, idx);
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        edges.push({ i, j: idx, w });
                    }
                }
            }

            // Initialize embedding with spectral-like init (use PCA)
            const proj = quickPCA(X, 2);
            const Y = proj.map(p => [p[0] * 0.01, p[1] * 0.01]);

            // Precompute a, b parameters for min_dist
            const a = 1.929, b = 0.7915; // Approximate for min_dist ~0.1

            return { Y, edges, n, minDist, a, b, iter: 0 };
        }

        function umapStep(umapState, lr) {
            const { Y, edges, n, a, b } = umapState;
            const grad = Array.from({length: n}, () => [0, 0]);

            // Attractive forces
            for (const edge of edges) {
                const dx = Y[edge.i][0] - Y[edge.j][0];
                const dy = Y[edge.i][1] - Y[edge.j][1];
                const distSq = dx*dx + dy*dy + 1e-6;
                const gradCoeff = -2 * a * b * Math.pow(distSq, b - 1) / (1 + a * Math.pow(distSq, b));

                grad[edge.i][0] += gradCoeff * dx * edge.w;
                grad[edge.i][1] += gradCoeff * dy * edge.w;
                grad[edge.j][0] -= gradCoeff * dx * edge.w;
                grad[edge.j][1] -= gradCoeff * dy * edge.w;
            }

            // Repulsive forces (negative sampling)
            const nNeg = 5;
            for (let i = 0; i < n; i++) {
                for (let s = 0; s < nNeg; s++) {
                    const j = Math.floor(Math.random() * n);
                    if (j === i) continue;
                    const dx = Y[i][0] - Y[j][0];
                    const dy = Y[i][1] - Y[j][1];
                    const distSq = dx*dx + dy*dy + 1e-6;
                    const gradCoeff = 2 * b / ((0.001 + distSq) * (1 + a * Math.pow(distSq, b)));

                    grad[i][0] += gradCoeff * dx;
                    grad[i][1] += gradCoeff * dy;
                }
            }

            // Apply gradients
            const clampVal = 4;
            for (let i = 0; i < n; i++) {
                grad[i][0] = Math.max(-clampVal, Math.min(clampVal, grad[i][0]));
                grad[i][1] = Math.max(-clampVal, Math.min(clampVal, grad[i][1]));
                Y[i][0] += lr * grad[i][0];
                Y[i][1] += lr * grad[i][1];
            }

            umapState.iter++;
        }

        async function runUMAP() {
            if (!state.data) { alert('Load a dataset first.'); return; }
            if (state.running.umap) return;
            state.running.umap = true;

            const nNeighbors = parseInt(document.getElementById('umap-neighbors').value);
            const minDist = parseFloat(document.getElementById('umap-min-dist').value);
            const maxIter = parseInt(document.getElementById('umap-iters').value);

            setStatus('umap', 'running', 'Building k-NN graph...');
            document.getElementById('umap-progress').style.width = '0%';

            await new Promise(r => setTimeout(r, 50));

            const umapState = umapInit(state.data.X, nNeighbors, minDist);
            state.umap = umapState;

            createScatter('umap-svg', 'umap-viz', umapState.Y, state.data.labels);

            setStatus('umap', 'running', 'Optimizing layout...');

            const batchSize = 5;
            for (let i = 0; i < maxIter && state.running.umap; i += batchSize) {
                const lr = 1.0 * (1 - i / maxIter);
                for (let b = 0; b < batchSize && i + b < maxIter; b++) {
                    umapStep(umapState, lr);
                }

                const progress = ((i + batchSize) / maxIter * 100).toFixed(0);
                document.getElementById('umap-progress').style.width = progress + '%';
                setStatus('umap', 'running', `Iteration ${Math.min(i + batchSize, maxIter)}/${maxIter}`);

                animateScatter('umap-svg', 'umap-viz', null, umapState.Y, state.data.labels, 80);
                await new Promise(r => setTimeout(r, 30));
            }

            state.running.umap = false;
            document.getElementById('umap-progress').style.width = '100%';
            setStatus('umap', 'done', `Complete â€” ${umapState.iter} iterations`);

            document.getElementById('umap-metrics').innerHTML = `
                <div class="metric"><div class="metric-value">${umapState.iter}</div><div class="metric-label">Iterations</div></div>
                <div class="metric"><div class="metric-value">${nNeighbors}</div><div class="metric-label">Neighbors</div></div>
                <div class="metric"><div class="metric-value">${minDist.toFixed(2)}</div><div class="metric-label">Min Distance</div></div>
            `;
        }

        // ========== DIAGNOSTIC ==========
        async function runDiagnostic() {
            if (!state.data) { alert('Load a dataset first.'); return; }

            setStatus('diag', 'running', 'Running manifold diagnostic...');
            document.getElementById('diagnostic-progress').style.width = '10%';

            await new Promise(r => setTimeout(r, 100));

            const { X, labels, featureNames } = state.data;
            const n = X.length;
            const d = featureNames.length;

            // 1. PCA variance analysis
            const { centered } = centerData(X);
            const cov = covarianceMatrix(centered);
            const { eigenvalues } = eigenDecomposition(cov, d);
            const totalVar = eigenvalues.reduce((a,b) => a + Math.max(0, b), 0);
            const explainedRatios = eigenvalues.map(e => Math.max(0, e) / totalVar);
            const cumExplained = explainedRatios.reduce((acc, v) => { acc.push((acc.length ? acc[acc.length-1] : 0) + v); return acc; }, []);

            // Intrinsic dimensionality estimate: smallest k where cumulative >= 0.9
            let intrinsicDim = d;
            for (let k = 0; k < cumExplained.length; k++) {
                if (cumExplained[k] >= 0.9) { intrinsicDim = k + 1; break; }
            }

            document.getElementById('diagnostic-progress').style.width = '40%';
            setStatus('diag', 'running', 'Estimating intrinsic dimensionality...');
            await new Promise(r => setTimeout(r, 100));

            // 2. Correlation dimension estimation (simplified)
            const D = distanceMatrix(X);
            const allDists = [];
            for (let i = 0; i < n; i++)
                for (let j = i+1; j < n; j++)
                    allDists.push(D[i][j]);
            allDists.sort((a,b) => a - b);

            const nPairs = allDists.length;
            const rValues = [];
            const cValues = [];
            for (let p = 10; p <= 90; p += 5) {
                const idx = Math.floor(p / 100 * nPairs);
                const r = allDists[idx];
                const c = (idx + 1) / nPairs;
                if (r > 0 && c > 0) { rValues.push(Math.log(r)); cValues.push(Math.log(c)); }
            }

            // Linear regression for correlation dimension
            let corrDim = d;
            if (rValues.length >= 3) {
                const n2 = rValues.length;
                const sumX = rValues.reduce((a,b) => a+b, 0);
                const sumY = cValues.reduce((a,b) => a+b, 0);
                const sumXY = rValues.reduce((a, x, i) => a + x * cValues[i], 0);
                const sumX2 = rValues.reduce((a, x) => a + x*x, 0);
                corrDim = Math.max(1, (n2 * sumXY - sumX * sumY) / (n2 * sumX2 - sumX * sumX));
            }

            document.getElementById('diagnostic-progress').style.width = '70%';
            setStatus('diag', 'running', 'Computing neighborhood preservation...');
            await new Promise(r => setTimeout(r, 100));

            // 3. Neighborhood preservation (PCA 2D)
            const proj2d = quickPCA(X, 2);
            const D2 = distanceMatrix(proj2d);
            const k = Math.min(10, n - 1);
            let trustworthiness = 0;

            for (let i = 0; i < n; i++) {
                const origNeighbors = D[i].map((dd, j) => ({j, d: dd}))
                    .filter(x => x.j !== i).sort((a,b) => a.d - b.d).slice(0, k).map(x => x.j);
                const projNeighbors = D2[i].map((dd, j) => ({j, d: dd}))
                    .filter(x => x.j !== i).sort((a,b) => a.d - b.d).slice(0, k).map(x => x.j);

                const origSet = new Set(origNeighbors);
                let preserved = 0;
                for (const j of projNeighbors) if (origSet.has(j)) preserved++;
                trustworthiness += preserved / k;
            }
            trustworthiness /= n;

            document.getElementById('diagnostic-progress').style.width = '100%';

            // 4. Variance concentration (how concentrated is variance in top components)
            const top2Var = cumExplained[Math.min(1, cumExplained.length - 1)];
            const varianceConcentration = top2Var;

            // 5. Dimensionality ratio
            const dimRatio = intrinsicDim / d;

            // Score computation
            const manifoldScore = (
                (1 - dimRatio) * 30 +
                varianceConcentration * 30 +
                trustworthiness * 20 +
                (corrDim < d * 0.5 ? 20 : corrDim < d * 0.75 ? 10 : 0)
            );

            state.diagnostic = {
                intrinsicDim, corrDim, trustworthiness, varianceConcentration,
                dimRatio, manifoldScore, explainedRatios, cumExplained, d, eigenvalues
            };

            // Display results
            showDiagnosticResults();
            updateStrategySection();
        }

        function showDiagnosticResults() {
            const diag = state.diagnostic;
            const { d } = state.data.featureNames.length ? state.data : { d: 1 };

            document.getElementById('diagnostic-results').style.display = 'block';
            const box = document.getElementById('diag-result-box');
            const verdict = document.getElementById('diag-verdict');
            const explanation = document.getElementById('diag-explanation');
            const scores = document.getElementById('diag-scores');

            box.className = 'diagnostic-result';

            if (diag.manifoldScore >= 65) {
                box.classList.add('manifold-yes');
                verdict.textContent = 'Yes â€” your data likely lives on a manifold.';
                verdict.style.color = 'var(--moss)';
                explanation.textContent = `Your data shows strong low-dimensional structure. The intrinsic dimensionality (${diag.intrinsicDim}) is much lower than the ambient dimensionality (${diag.d}). Dimensionality reduction will work well for this dataset.`;
                setStatus('diag', 'done', 'Manifold detected');
            } else if (diag.manifoldScore >= 40) {
                box.classList.add('manifold-maybe');
                verdict.textContent = 'Maybe â€” partial manifold structure detected.';
                verdict.style.color = 'var(--earth)';
                explanation.textContent = `Your data has some low-dimensional structure, but it's not clear-cut. The intrinsic dimensionality (${diag.intrinsicDim}) captures most variance from ${diag.d} dimensions. Dimensionality reduction may help, but interpret results carefully.`;
                setStatus('diag', 'done', 'Partial manifold structure');
            } else {
                box.classList.add('manifold-no');
                verdict.textContent = 'No â€” your data appears genuinely high-dimensional.';
                verdict.style.color = 'var(--terracotta)';
                explanation.textContent = `Variance is spread across many dimensions. The correlation dimension (${diag.corrDim.toFixed(1)}) is close to the ambient dimensionality (${diag.d}). Simple dimensionality reduction will lose significant information.`;
                setStatus('diag', 'done', 'No clear manifold');
            }

            scores.innerHTML = `
                <div class="score-item">
                    <div class="score-value" style="color:${diag.manifoldScore >= 65 ? 'var(--moss)' : diag.manifoldScore >= 40 ? 'var(--earth)' : 'var(--terracotta)'}">${diag.manifoldScore.toFixed(0)}</div>
                    <div class="score-label">Manifold Score</div>
                </div>
                <div class="score-item">
                    <div class="score-value">${diag.intrinsicDim}/${diag.d}</div>
                    <div class="score-label">Intrinsic / Ambient Dims</div>
                </div>
                <div class="score-item">
                    <div class="score-value">${(diag.trustworthiness * 100).toFixed(1)}%</div>
                    <div class="score-label">Neighborhood Preserved</div>
                </div>
                <div class="score-item">
                    <div class="score-value">${(diag.varianceConcentration * 100).toFixed(1)}%</div>
                    <div class="score-label">Variance in Top 2</div>
                </div>
            `;

            const details = document.getElementById('diag-details');
            details.innerHTML = `
                <div class="framework-card">
                    <h4>PCA Variance Analysis</h4>
                    <p>${(diag.cumExplained[0]*100).toFixed(1)}% of variance captured by PC1 alone.
                    ${diag.intrinsicDim} components needed for 90% of total variance (out of ${diag.d} dimensions).</p>
                </div>
                <div class="framework-card">
                    <h4>Correlation Dimension</h4>
                    <p>Estimated at ${diag.corrDim.toFixed(2)}, compared to ambient dimensionality of ${diag.d}.
                    ${diag.corrDim < diag.d * 0.5 ? 'This suggests strong low-dimensional structure.' : diag.corrDim < diag.d * 0.75 ? 'Moderate dimensional reduction may be useful.' : 'The data fills most of its ambient space.'}</p>
                </div>
                <div class="framework-card">
                    <h4>Neighborhood Trustworthiness</h4>
                    <p>${(diag.trustworthiness*100).toFixed(1)}% of k=10 nearest neighbors are preserved when projecting to 2D.
                    ${diag.trustworthiness > 0.7 ? 'Excellent â€” local structure survives projection well.' : diag.trustworthiness > 0.4 ? 'Moderate â€” some local structure is distorted.' : 'Low â€” 2D projection significantly distorts neighborhoods.'}</p>
                </div>
                <div class="framework-card">
                    <h4>Recommendation</h4>
                    <p>${diag.manifoldScore >= 65
                        ? 'Use PCA for quick exploratory analysis. t-SNE/UMAP will reveal cluster structure. Your data is amenable to dimensionality reduction in production pipelines.'
                        : diag.manifoldScore >= 40
                        ? 'PCA may miss nonlinear structure â€” try t-SNE/UMAP. Consider feature engineering to reduce noise dimensions before applying reduction.'
                        : 'Dimensionality reduction will lose significant information. Consider feature selection instead, or domain-specific approaches. More data collection in targeted areas may reveal latent structure.'
                    }</p>
                </div>
            `;
        }

        function updateStrategySection() {
            if (!state.diagnostic) return;
            const diag = state.diagnostic;
            const el = document.getElementById('strategy-content');

            let html = '';

            if (diag.manifoldScore >= 65) {
                html = `
                    <div class="info-box" style="border-color:var(--moss)">
                        <strong>Your strategic landscape has hidden simplicity.</strong>
                    </div>
                    <p style="margin:12px 0;line-height:1.6">
                        With a manifold score of <strong>${diag.manifoldScore.toFixed(0)}</strong> and intrinsic dimensionality of <strong>${diag.intrinsicDim}</strong>
                        (from ${diag.d} measured dimensions), your data reveals that apparent complexity is governed by a few latent factors.
                    </p>
                    <div class="framework-grid">
                        <div class="framework-card">
                            <h4>Beinhocker Implication</h4>
                            <p>Your fitness landscape has <strong>ridgelines</strong> â€” paths of high performance that follow the manifold surface. Strategy should focus on navigating these ridges rather than exploring the full ${diag.d}-dimensional space. The ${diag.intrinsicDim} principal components ARE your strategic dimensions.</p>
                        </div>
                        <div class="framework-card">
                            <h4>Action: Deductive Tinkering</h4>
                            <p>Focus your experiments along the manifold surface. Variation perpendicular to the manifold is noise â€” don't waste resources there. The top ${diag.intrinsicDim} components explain ${(diag.cumExplained[diag.intrinsicDim-1]*100).toFixed(0)}% of meaningful variation.</p>
                        </div>
                    </div>
                `;
            } else if (diag.manifoldScore >= 40) {
                html = `
                    <div class="info-box" style="border-color:var(--earth)">
                        <strong>Your strategic landscape has moderate structure â€” proceed with nuance.</strong>
                    </div>
                    <p style="margin:12px 0;line-height:1.6">
                        Manifold score: <strong>${diag.manifoldScore.toFixed(0)}</strong>. Some low-dimensional structure exists, but ${(100 - diag.varianceConcentration*100).toFixed(0)}% of variance escapes the top 2 dimensions.
                    </p>
                    <div class="framework-grid">
                        <div class="framework-card">
                            <h4>Beinhocker Implication</h4>
                            <p>Your fitness landscape is <strong>moderately rugged</strong>. Some strategic patterns exist (the manifold portion), but significant complexity remains. Maintain a diverse portfolio of business plans â€” don't over-concentrate on the patterns you've found.</p>
                        </div>
                        <div class="framework-card">
                            <h4>Action: Balanced Exploration</h4>
                            <p>Use the low-dimensional structure for <em>efficiency</em> (focus resources on the ${diag.intrinsicDim} key dimensions), but maintain strategic optionality in the remaining dimensions. The landscape may shift.</p>
                        </div>
                    </div>
                `;
            } else {
                html = `
                    <div class="info-box" style="border-color:var(--terracotta)">
                        <strong>Your domain is genuinely complex â€” simple maps will mislead.</strong>
                    </div>
                    <p style="margin:12px 0;line-height:1.6">
                        Manifold score: <strong>${diag.manifoldScore.toFixed(0)}</strong>. Variance is distributed across many dimensions, with no clear low-dimensional structure.
                    </p>
                    <div class="framework-grid">
                        <div class="framework-card">
                            <h4>Beinhocker Implication</h4>
                            <p>Your fitness landscape is <strong>highly rugged</strong> with many independent factors. This is typical of emerging markets, novel technologies, or domains where the rules are still being written. Simple dimensionality reduction will create false confidence.</p>
                        </div>
                        <div class="framework-card">
                            <h4>Action: Broad Tinkering</h4>
                            <p>Maintain maximum diversity in your strategy portfolio. Invest in many small experiments across all dimensions. The goal is to <em>discover</em> structure, not exploit structure that may not yet exist. Consider gathering more data or reframing your feature space.</p>
                        </div>
                    </div>
                `;
            }

            el.innerHTML = html;
        }

        // ========== UI HELPERS ==========
        function setStatus(prefix, statusType, text) {
            const dot = document.getElementById(prefix + '-status-dot');
            const textEl = document.getElementById(prefix + '-status-text');
            if (dot) {
                dot.className = 'status-dot';
                if (statusType === 'running') dot.classList.add('running');
                else if (statusType === 'done') dot.classList.add('done');
            }
            if (textEl) textEl.textContent = text;
        }

        // ========== TABS ==========
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('panel-' + btn.dataset.tab).classList.add('active');
            });
        });

        // ========== RANGE INPUTS ==========
        function bindRange(inputId, valId, formatter) {
            const input = document.getElementById(inputId);
            const val = document.getElementById(valId);
            if (!input || !val) return;
            input.addEventListener('input', () => {
                val.textContent = formatter ? formatter(input.value) : input.value;
            });
        }
        bindRange('sample-size', 'sample-size-val');
        bindRange('tsne-perplexity', 'tsne-perplexity-val');
        bindRange('tsne-lr', 'tsne-lr-val');
        bindRange('tsne-iters', 'tsne-iters-val');
        bindRange('umap-neighbors', 'umap-neighbors-val');
        bindRange('umap-min-dist', 'umap-min-dist-val', v => parseFloat(v).toFixed(2));
        bindRange('umap-iters', 'umap-iters-val');

        // ========== EVENT LISTENERS ==========
        document.getElementById('btn-load-dataset').addEventListener('click', loadBuiltinDataset);
        document.getElementById('csv-upload').addEventListener('change', function(e) {
            if (e.target.files.length) loadCSV(e.target.files[0]);
        });

        document.getElementById('btn-pca-step').addEventListener('click', runPCAStep);
        document.getElementById('btn-pca-auto').addEventListener('click', autoPCA);
        document.getElementById('btn-pca-reset').addEventListener('click', resetPCA);

        document.getElementById('btn-tsne-run').addEventListener('click', runTSNE);
        document.getElementById('btn-tsne-stop').addEventListener('click', () => { state.running.tsne = false; });
        document.getElementById('btn-tsne-reset').addEventListener('click', () => {
            state.running.tsne = false;
            state.tsne = null;
            d3.select('#tsne-svg').selectAll('*').remove();
            document.getElementById('tsne-progress').style.width = '0%';
            document.getElementById('tsne-metrics').innerHTML = '';
            setStatus('tsne', 'idle', 'Ready');
        });

        document.getElementById('btn-umap-run').addEventListener('click', runUMAP);
        document.getElementById('btn-umap-stop').addEventListener('click', () => { state.running.umap = false; });
        document.getElementById('btn-umap-reset').addEventListener('click', () => {
            state.running.umap = false;
            state.umap = null;
            d3.select('#umap-svg').selectAll('*').remove();
            document.getElementById('umap-progress').style.width = '0%';
            document.getElementById('umap-metrics').innerHTML = '';
            setStatus('umap', 'idle', 'Ready');
        });

        document.getElementById('btn-run-diagnostic').addEventListener('click', runDiagnostic);

        // Load default dataset on start
        loadBuiltinDataset();

    })();
    </script>
</body>
</html>
