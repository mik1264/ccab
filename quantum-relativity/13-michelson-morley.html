<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michelson-Morley Experiment - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #000;
            color: #ccc;
            font-family: 'Segoe UI', system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            border: 1px solid #333;
            background: #111;
        }
        
        .controls {
            margin: 20px;
            padding: 20px;
            background: #222;
            border-radius: 8px;
            display: inline-block;
        }
        
        button {
            padding: 10px 20px;
            background: #444;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover { background: #555; }
        button.active { background: #0ea5e9; }
        
        .readout {
            font-family: monospace;
            font-size: 1.2rem;
            margin-top: 10px;
            color: #0ea5e9;
        }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">← Back to Gallery</a>
    <h1>Michelson-Morley Experiment</h1>
    <p>Searching for the Luminiferous Ether. <br>The null result (no fringe shift) implied the speed of light is constant in all frames.</p>
    
    <div class="controls">
        <button id="rotate-btn" onclick="toggleRotation()">Rotate Apparatus</button>
        <button id="ether-btn" onclick="toggleEther()">Simulate "Ether" Wind</button>
        <div class="readout" id="shift-val">Fringe Shift: 0.00 λ</div>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Config
    const CX = 400, CY = 300;
    const ARM_LENGTH = 200;
    
    let angle = 0;
    let rotating = false;
    let etherEnabled = false;
    let time = 0;
    
    // Photons state
    // We simulate phase difference directly rather than tracking individual photons
    // Phase diff = 2 * L * (v^2 / c^2) for ether theory
    // With no ether, phase diff is constant (0 ideally if arms equal)
    
    // But for visual, we draw the apparatus and light beams
    
    function toggleRotation() {
        rotating = !rotating;
        document.getElementById('rotate-btn').classList.toggle('active', rotating);
    }
    
    function toggleEther() {
        etherEnabled = !etherEnabled;
        document.getElementById('ether-btn').classList.toggle('active', etherEnabled);
    }
    
    function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        time += 0.05;
        
        if (rotating) {
            angle += 0.005;
        }
        
        // Calculate Arm Endpoints
        // Arm 1 (Initially Horizontal)
        const x1 = CX + Math.cos(angle) * ARM_LENGTH;
        const y1 = CY + Math.sin(angle) * ARM_LENGTH;
        
        // Arm 2 (Initially Vertical)
        const x2 = CX + Math.cos(angle - Math.PI/2) * ARM_LENGTH;
        const y2 = CY + Math.sin(angle - Math.PI/2) * ARM_LENGTH;
        
        // Source and Detector (Opposite to mirrors)
        const srcX = CX + Math.cos(angle + Math.PI) * (ARM_LENGTH * 0.5);
        const srcY = CY + Math.sin(angle + Math.PI) * (ARM_LENGTH * 0.5);
        
        const detX = CX + Math.cos(angle + Math.PI/2) * (ARM_LENGTH * 0.5);
        const detY = CY + Math.sin(angle + Math.PI/2) * (ARM_LENGTH * 0.5);
        
        // Draw Table
        ctx.save();
        ctx.translate(CX, CY);
        ctx.rotate(angle);
        ctx.fillStyle = '#222';
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 20;
        // Cross shape
        ctx.beginPath();
        ctx.moveTo(-ARM_LENGTH/2, 0); ctx.lineTo(ARM_LENGTH, 0);
        ctx.moveTo(0, -ARM_LENGTH); ctx.lineTo(0, ARM_LENGTH/2);
        ctx.stroke();
        
        // Mirrors
        ctx.fillStyle = '#888';
        // M1 (Right)
        ctx.fillRect(ARM_LENGTH-5, -20, 10, 40);
        // M2 (Top)
        ctx.fillRect(-20, -ARM_LENGTH-5, 40, 10);
        // Splitter (Center) - Half silvered, 45 deg relative to table
        ctx.save();
        ctx.rotate(-Math.PI/4); // 45 deg relative to cross
        ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.fillRect(-25, -2, 50, 4);
        ctx.restore();
        
        ctx.restore();
        
        // Draw Light Beams (in global coords)
        // Source -> Center
        drawBeam(srcX, srcY, CX, CY, 'yellow');
        
        // Center -> M1 -> Center
        drawBeam(CX, CY, x1, y1, 'cyan');
        drawBeam(x1, y1, CX, CY, 'cyan');
        
        // Center -> M2 -> Center
        drawBeam(CX, CY, x2, y2, 'magenta');
        drawBeam(x2, y2, CX, CY, 'magenta');
        
        // Center -> Detector (Combined)
        drawBeam(CX, CY, detX, detY, 'white');
        
        // Calculate Interference
        // If ether is enabled, assume "wind" is horizontal (along X axis)
        // v/c ratio
        const beta = 0.1; // exaggerating for visibility
        
        let deltaPhase = 0;
        
        if (etherEnabled) {
            // Theoretical shift based on angle relative to ether wind
            // Delta t = (L / c) * beta^2 * cos(2 * angle)
            // It varies sinusoidally with rotation
            deltaPhase = 20 * Math.cos(2 * angle);
        }
        
        document.getElementById('shift-val').textContent = `Fringe Shift: ${Math.abs(deltaPhase).toFixed(2)} λ`;
        
        // Draw Interference Pattern at Detector
        drawInterference(detX, detY, deltaPhase);
        
        requestAnimationFrame(loop);
    }
    
    function drawBeam(x1, y1, x2, y2, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        
        // Moving pulses
        const dist = Math.hypot(x2-x1, y2-y1);
        const angle = Math.atan2(y2-y1, x2-x1);
        const speed = 5;
        const offset = (time * speed) % 50;
        
        ctx.fillStyle = color;
        for (let d = offset; d < dist; d += 50) {
            const px = x1 + Math.cos(angle) * d;
            const py = y1 + Math.sin(angle) * d;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI*2);
            ctx.fill();
        }
    }
    
    function drawInterference(x, y, phase) {
        // Draw a small box with fringes
        // Ideally perpendicular to beam
        // Just draw it offset
        
        const size = 60;
        const startX = x + 40;
        const startY = y + 40;
        
        ctx.fillStyle = '#000';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.fillRect(startX, startY, size, size);
        ctx.strokeRect(startX, startY, size, size);
        
        // Draw rings/fringes
        ctx.beginPath();
        ctx.rect(startX, startY, size, size);
        ctx.clip();
        
        const centerX = startX + size/2;
        const centerY = startY + size/2;
        
        ctx.lineWidth = 4;
        for (let r = 0; r < 50; r+=8) {
            const effectiveR = r + phase; // Shift radius by phase
            if (effectiveR > 0) {
                ctx.strokeStyle = `rgba(0, 255, 0, ${Math.max(0, 1 - r/40)})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, effectiveR, 0, Math.PI*2);
                ctx.stroke();
            }
        }
        ctx.restore(); // remove clip
    }
    
    requestAnimationFrame(loop);

</script>
</body>
</html>
