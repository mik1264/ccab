<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Body Radiation - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #111;
            color: #ddd;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
        }
        
        .controls {
            margin: 20px auto;
            background: #222;
            padding: 20px;
            border-radius: 8px;
            max-width: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        input[type=range] { width: 300px; }
        
        .temp-display {
            font-size: 2rem;
            font-weight: bold;
            font-family: monospace;
            color: #fcd34d;
        }
        
        .color-patch {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 4px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: background 0.2s;
            margin: 0 auto 20px;
        }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Black Body Radiation</h1>
    <p>Planck's Law: As temperature increases, the peak wavelength shifts to the blue (Wien's Law) and total power increases (Stefan-Boltzmann Law).</p>
    
    <div class="color-patch" id="color-patch"></div>
    <div class="temp-display" id="temp-val">5000 K</div>
    
    <div class="controls">
        <label>Temperature (K):</label>
        <input type="range" id="t-slider" min="1000" max="12000" value="5000" step="100">
    </div>

    <canvas id="canvas" width="800" height="400"></canvas>
    
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPatch = document.getElementById('color-patch');
    const tempDisplay = document.getElementById('temp-val');
    
    // Constants (scaled for visualization)
    // Planck's law B(lambda, T) = (2hc^2 / lambda^5) * (1 / (e^(hc/lambda*k*T) - 1))
    // x = hc / (lambda * k * T)
    // We simplify to B(x) ~ (1/x^5) / (e^(C/xT) - 1)
    
    // Wavelengths in nm
    const minLambda = 100; // UV
    const maxLambda = 3000; // IR
    
    let T = 5000;
    
    function kelvinToRGB(k) {
        // Approximate algorithm for color temperature
        let r, g, b;
        let temp = k / 100;
        
        if (temp <= 66) {
            r = 255;
            g = temp;
            g = 99.4708025861 * Math.log(g) - 161.1195681661;
            
            if (temp <= 19) b = 0;
            else {
                b = temp - 10;
                b = 138.5177312231 * Math.log(b) - 305.0447927307;
            }
        } else {
            r = temp - 60;
            r = 329.698727446 * Math.pow(r, -0.1332047592);
            
            g = temp - 60;
            g = 288.1221695283 * Math.pow(g, -0.0755148492);
            
            b = 255;
        }
        
        return {
            r: Math.max(0, Math.min(255, r)),
            g: Math.max(0, Math.min(255, g)),
            b: Math.max(0, Math.min(255, b))
        };
    }

    function planck(lambdaNm, T) {
        const lambda = lambdaNm * 1e-9;
        const h = 6.626e-34;
        const c = 3.0e8;
        const k = 1.38e-23;
        
        const c1 = 2 * h * c * c;
        const c2 = h * c / k;
        
        const val = (c1 / Math.pow(lambda, 5)) * (1 / (Math.exp(c2 / (lambda * T)) - 1));
        return val;
    }

    function update() {
        T = parseInt(document.getElementById('t-slider').value);
        tempDisplay.textContent = T + " K";
        
        // Update Color Patch
        const rgb = kelvinToRGB(T);
        const color = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        colorPatch.style.backgroundColor = color;
        colorPatch.style.boxShadow = `0 0 40px ${color}`;
        
        drawGraph();
    }
    
    function drawGraph() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const w = canvas.width;
        const h = canvas.height;
        const padding = 50;
        
        // Draw Spectrum Background (Visible Range 380-750nm)
        const visibleStart = mapX(380);
        const visibleEnd = mapX(750);
        
        const grad = ctx.createLinearGradient(visibleStart, 0, visibleEnd, 0);
        grad.addColorStop(0, 'rgba(100,0,255,0.2)'); // Violet
        grad.addColorStop(0.2, 'rgba(0,0,255,0.2)'); // Blue
        grad.addColorStop(0.4, 'rgba(0,255,0,0.2)'); // Green
        grad.addColorStop(0.6, 'rgba(255,255,0,0.2)'); // Yellow
        grad.addColorStop(0.8, 'rgba(255,165,0,0.2)'); // Orange
        grad.addColorStop(1, 'rgba(255,0,0,0.2)'); // Red
        
        ctx.fillStyle = grad;
        ctx.fillRect(visibleStart, 0, visibleEnd - visibleStart, h - padding);
        
        // Draw Visible Labels
        ctx.fillStyle = '#888';
        ctx.textAlign = 'center';
        ctx.fillText("Visible", (visibleStart + visibleEnd)/2, 20);
        
        // Calculate Scale
        // Peak is at lambda_max = 2.898e-3 / T (Wien's Law)
        // Peak value scales with T^5? Or B scales with T^5? 
        // Stefan-Boltzmann (Integral) is T^4. Peak is T^5.
        // So graph grows VERY fast. We need dynamic scaling or log scale?
        // Let's use linear Y but auto-scale to peak of 12000K or current T?
        // If we auto-scale to current T, shape looks same.
        // Users want to see it grow. So let's scale to max T (12000K).
        
        const maxPeak = planck(2.898e6 / 12000, 12000); // peak at 12000K
        const scaleY = (h - padding*2) / maxPeak;
        
        // Draw Curve
        ctx.beginPath();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        
        for (let x = 0; x < w - padding; x++) {
            const lambda = mapXInv(x);
            const intensity = planck(lambda, T);
            const y = (h - padding) - (intensity * scaleY); // Standard scale
            
            // To make lower temps visible, maybe non-linear Y?
            // Or just scale to current T but show "Zoom" factor?
            // Let's try scaling to current T * 1.2 to keep it in view always, 
            // but indicate intensity via glow/text?
            // Actually, showing the growth is key. 
            // Let's us a logarithmic Y scale? Or sqrt?
            // Let's use sqrt scale for Y to compress dynamic range.
            
            // Re-calc scale with sqrt
            // const yVal = Math.sqrt(intensity);
            // const maxRoot = Math.sqrt(maxPeak);
            // const y = (h - padding) - (yVal / maxRoot) * (h - padding*2);
            
            if (x === 0) ctx.moveTo(x + padding, y);
            else ctx.lineTo(x + padding, y);
        }
        ctx.stroke();
        
        // Draw Axes
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, 0);
        ctx.lineTo(padding, h - padding);
        ctx.lineTo(w, h - padding);
        ctx.stroke();
        
        // Labels
        ctx.fillStyle = '#aaa';
        ctx.fillText("0", padding - 10, h - padding);
        ctx.fillText("3000 nm", w - 30, h - padding + 20);
        ctx.save();
        ctx.rotate(-Math.PI/2);
        ctx.fillText("Intensity / Power Density", -h/2, 20);
        ctx.restore();
        
        // Wien's Peak Marker
        const peakLambda = 2.898e6 / T;
        const peakX = mapX(peakLambda);
        const peakY = (h - padding) - (planck(peakLambda, T) * scaleY);
        
        if (peakX > padding && peakX < w) {
            ctx.fillStyle = '#fcd34d';
            ctx.beginPath();
            ctx.arc(peakX, peakY, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.fillText(`${peakLambda.toFixed(0)} nm`, peakX, peakY - 10);
        }
    }
    
    function mapX(lambda) {
        const w = canvas.width;
        const padding = 50;
        // Map 0 - 3000 nm to padding - w
        return padding + (lambda / 3000) * (w - padding);
    }
    
    function mapXInv(x) {
        const w = canvas.width;
        const padding = 50;
        return ((x - padding) / (w - padding)) * 3000;
    }
    
    document.getElementById('t-slider').addEventListener('input', update);
    update();

</script>
</body>
</html>
