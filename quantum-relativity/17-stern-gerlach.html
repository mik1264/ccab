<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stern-Gerlach Experiment - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #111;
            color: #ddd;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
        }
        
        .controls {
            margin-top: 20px;
            background: #222;
            padding: 15px;
            border-radius: 8px;
            display: inline-flex;
            gap: 15px;
            align-items: center;
        }
        
        button {
            padding: 8px 16px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #555; }
        
        select {
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }
        
        .stats {
            margin-top: 20px;
            font-family: monospace;
            font-size: 1.1rem;
            display: flex;
            justify-content: center;
            gap: 30px;
        }
        .stat-box {
            background: #333;
            padding: 10px 20px;
            border-radius: 4px;
            border-top: 3px solid #666;
        }
        .stat-box.up { border-color: #10b981; }
        .stat-box.down { border-color: #ef4444; }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Stern-Gerlach Experiment</h1>
    <p>Quantum measurement of Spin. Silver atoms pass through an inhomogeneous magnetic field.</p>
    
    <div class="controls">
        <label>Measurement Axis:</label>
        <select id="axis-select">
            <option value="Z">Z-Axis (Vertical)</option>
            <option value="X">X-Axis (Horizontal)</option>
        </select>
        
        <button onclick="fireAtom()">Fire Single Atom</button>
        <button onclick="toggleAuto()">Auto Fire</button>
        <button onclick="reset()">Reset</button>
    </div>
    
    <canvas id="canvas" width="800" height="400"></canvas>
    
    <div class="stats">
        <div class="stat-box up">
            Up (+): <span id="count-up">0</span>
        </div>
        <div class="stat-box down">
            Down (-): <span id="count-down">0</span>
        </div>
    </div>
    
    <p style="color: #666; font-size: 0.9rem; margin-top: 20px;">
        Note: In a sequence of SG magnets (SG-Z -> SG-X -> SG-Z), measuring X resets the Z spin information (uncertainty principle).
        <br>This demo simulates a single stage. Imagine the input stream comes from a previous measurement to see correlations.
    </p>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let atoms = [];
    let countUp = 0;
    let countDown = 0;
    let autoInterval = null;
    
    // Magnet properties
    const MAGNET_X = 300;
    const MAGNET_W = 200;
    const SCREEN_X = 700;
    
    // Initial State of atoms coming in
    // Let's assume they are "unpolarized" (random spin) or prepared?
    // For single stage demo, random spin vector is fine.
    
    class Atom {
        constructor() {
            this.x = 0;
            this.y = 200;
            this.vx = 5;
            this.vy = 0;
            
            // Random spin state on Bloch sphere
            const theta = Math.random() * Math.PI; // 0 to PI
            const phi = Math.random() * Math.PI * 2;
            this.spinTheta = theta;
            this.spinPhi = phi;
            
            this.measured = false;
            this.result = 0; // +1 or -1
            this.color = '#fff';
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            
            // Entering Magnet Field
            if (this.x > MAGNET_X && this.x < MAGNET_X + MAGNET_W && !this.measured) {
                this.measure();
            }
            
            // Inside Magnet: Deflect based on result
            if (this.x > MAGNET_X && this.x < MAGNET_X + MAGNET_W) {
                // Force F is proportional to spin projection
                // For Z axis: Fz ~ Sz
                // Since we "collapsed" to +1 or -1, deflection is constant up or down
                const force = 0.2 * this.result; 
                this.vy += force; 
            }
            
            // Hitting Screen
            if (this.x > SCREEN_X) {
                this.vx = 0;
                this.vy = 0;
                this.dead = true;
                
                // Record stat
                if (this.result === 1) {
                    countUp++;
                    document.getElementById('count-up').textContent = countUp;
                } else {
                    countDown++;
                    document.getElementById('count-down').textContent = countDown;
                }
                
                // Leave a mark?
                drawSplatter(this.x, this.y, this.result === 1 ? '#10b981' : '#ef4444');
            }
        }
        
        measure() {
            const axis = document.getElementById('axis-select').value;
            let probUp = 0;
            
            // Projection probability: |<+|psi>|^2
            // State: cos(t/2)|0> + e^ip sin(t/2)|1>
            
            if (axis === 'Z') {
                // Prob Up = cos^2(theta/2)
                probUp = Math.cos(this.spinTheta/2) ** 2;
            } else if (axis === 'X') {
                // Prob Up in X basis (|+>)
                // |+> = 1/sqrt(2) (|0> + |1>)
                // <+|psi> = 1/sqrt(2) (cos(t/2) + e^ip sin(t/2))
                // Prob = 0.5 * |cos(t/2) + e^ip sin(t/2)|^2
                // = 0.5 * (1 + sin(theta)cos(phi))
                probUp = 0.5 * (1 + Math.sin(this.spinTheta) * Math.cos(this.spinPhi));
            }
            
            // Collapse
            if (Math.random() < probUp) {
                this.result = 1; // Up
                this.color = '#10b981';
            } else {
                this.result = -1; // Down
                this.color = '#ef4444';
            }
            this.measured = true;
        }
        
        draw() {
            if (this.dead) return;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
            ctx.fill();
        }
    }
    
    let splatters = [];
    function drawSplatter(x, y, color) {
        splatters.push({x, y, color, alpha: 1.0});
    }
    
    function reset() {
        atoms = [];
        splatters = [];
        countUp = 0;
        countDown = 0;
        document.getElementById('count-up').textContent = 0;
        document.getElementById('count-down').textContent = 0;
    }
    
    function fireAtom() {
        atoms.push(new Atom());
    }
    
    function toggleAuto() {
        if (autoInterval) {
            clearInterval(autoInterval);
            autoInterval = null;
        } else {
            fireAtom();
            autoInterval = setInterval(fireAtom, 200);
        }
    }

    function loop() {
        // Draw scene
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw Magnet
        ctx.fillStyle = '#333';
        // Top Pole (N)
        ctx.fillRect(MAGNET_X, 50, MAGNET_W, 100);
        ctx.fillStyle = '#999';
        ctx.font = '20px Arial';
        ctx.fillText("N", MAGNET_X + MAGNET_W/2 - 10, 140);
        
        // Bottom Pole (S) - pointed for gradient?
        ctx.fillStyle = '#333';
        ctx.fillRect(MAGNET_X, 250, MAGNET_W, 100);
        ctx.fillStyle = '#999';
        ctx.fillText("S", MAGNET_X + MAGNET_W/2 - 10, 280);
        
        // Screen
        ctx.fillStyle = '#555';
        ctx.fillRect(SCREEN_X, 50, 10, 300);
        
        // Draw Splatters
        splatters.forEach(s => {
            ctx.globalAlpha = s.alpha;
            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.arc(s.x, s.y, 6, 0, Math.PI*2);
            ctx.fill();
            s.alpha *= 0.995;
        });
        ctx.globalAlpha = 1.0;
        splatters = splatters.filter(s => s.alpha > 0.05);
        
        // Update/Draw Atoms
        atoms.forEach(a => {
            a.update();
            a.draw();
        });
        atoms = atoms.filter(a => !a.dead);
        
        requestAnimationFrame(loop);
    }
    
    requestAnimationFrame(loop);

</script>
</body>
</html>
