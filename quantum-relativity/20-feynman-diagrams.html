<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feynman Diagram Constructor - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #fff;
            color: #333;
            font-family: 'Segoe UI', system-ui;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container { max-width: 1000px; width: 100%; }
        
        .toolbar {
            background: #f3f4f6;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
        }
        
        .tool {
            padding: 8px 12px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .tool:hover { background: #e5e7eb; }
        .tool.active { background: #dbeafe; border-color: #3b82f6; color: #1e40af; }
        
        .canvas-area {
            position: relative;
            width: 100%;
            height: 500px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            cursor: crosshair;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        .line-fermion { stroke: #374151; stroke-width: 2; fill: none; marker-mid: url(#arrow); }
        .line-photon { stroke: #eab308; stroke-width: 2; fill: none; }
        .line-gluon { stroke: #ef4444; stroke-width: 2; fill: none; }
        .line-dashed { stroke: #9ca3af; stroke-width: 2; stroke-dasharray: 5,5; fill: none; }
        
        .vertex { fill: #1f2937; }
        
        .preview-line { stroke: #3b82f6; stroke-width: 2; stroke-dasharray: 4; opacity: 0.5; }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">← Back to Gallery</a>
    <h1>Feynman Diagram Constructor</h1>
    <p>Draw particle interactions. Select a tool and drag between points.</p>
    
    <div class="toolbar">
        <div class="tool active" onclick="setTool('fermion')">
            <span style="font-weight:bold">─</span> Fermion (e, μ, q)
        </div>
        <div class="tool" onclick="setTool('photon')">
            <span style="font-weight:bold; color:#eab308">~</span> Photon (γ)
        </div>
        <div class="tool" onclick="setTool('gluon')">
            <span style="font-weight:bold; color:#ef4444">➿</span> Gluon (g)
        </div>
        <div class="tool" onclick="setTool('scalar')">
            <span style="font-weight:bold; color:#9ca3af">- -</span> Scalar (H)
        </div>
        <div class="tool" onclick="clearCanvas()" style="margin-left:auto; color:red;">
            Clear
        </div>
    </div>

    <div class="canvas-area" id="draw-area">
        <svg id="svg">
            <defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
                    <path d="M0,0 L10,5 L0,10" fill="#374151" />
                </marker>
            </defs>
            <g id="layer-lines"></g>
            <g id="layer-points"></g>
            <line id="preview" class="preview-line" x1="0" y1="0" x2="0" y2="0" style="display:none" />
        </svg>
    </div>
    
    <p style="color:#666; font-size:0.9rem; margin-top:10px;">
        Tip: Drag to create lines. Lines snap to existing endpoints (vertices).
    </p>
</div>

<script>
    const svg = document.getElementById('svg');
    const layerLines = document.getElementById('layer-lines');
    const layerPoints = document.getElementById('layer-points');
    const preview = document.getElementById('preview');
    const drawArea = document.getElementById('draw-area');
    
    let currentTool = 'fermion';
    let isDrawing = false;
    let startX = 0, startY = 0;
    
    // Snap threshold
    const SNAP_DIST = 15;
    let points = []; // {x, y}
    
    function setTool(tool) {
        currentTool = tool;
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
        // Find the button (hacky but works for demo)
        const buttons = document.querySelectorAll('.tool');
        if(tool === 'fermion') buttons[0].classList.add('active');
        if(tool === 'photon') buttons[1].classList.add('active');
        if(tool === 'gluon') buttons[2].classList.add('active');
        if(tool === 'scalar') buttons[3].classList.add('active');
    }
    
    function clearCanvas() {
        layerLines.innerHTML = '';
        layerPoints.innerHTML = '';
        points = [];
    }
    
    drawArea.addEventListener('mousedown', e => {
        const rect = svg.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        
        // Snap to existing
        const snap = findSnap(x, y);
        if (snap) { x = snap.x; y = snap.y; }
        else {
            // New point
            points.push({x, y});
            drawPoint(x, y);
        }
        
        startX = x;
        startY = y;
        isDrawing = true;
        
        preview.setAttribute('x1', x);
        preview.setAttribute('y1', y);
        preview.setAttribute('x2', x);
        preview.setAttribute('y2', y);
        preview.style.display = 'block';
    });
    
    window.addEventListener('mouseup', e => {
        if (!isDrawing) return;
        
        const rect = svg.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        
        // Snap
        const snap = findSnap(x, y);
        if (snap) { x = snap.x; y = snap.y; }
        else {
            points.push({x, y});
            drawPoint(x, y);
        }
        
        // Add Line
        if (Math.hypot(x-startX, y-startY) > 5) {
            createPath(startX, startY, x, y, currentTool);
        }
        
        isDrawing = false;
        preview.style.display = 'none';
    });
    
    drawArea.addEventListener('mousemove', e => {
        if (!isDrawing) return;
        const rect = svg.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        preview.setAttribute('x2', x);
        preview.setAttribute('y2', y);
    });
    
    function findSnap(x, y) {
        let best = null;
        let minDist = SNAP_DIST;
        points.forEach(p => {
            const d = Math.hypot(p.x - x, p.y - y);
            if (d < minDist) {
                minDist = d;
                best = p;
            }
        });
        return best;
    }
    
    function drawPoint(x, y) {
        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        c.setAttribute('cx', x);
        c.setAttribute('cy', y);
        c.setAttribute('r', 4);
        c.setAttribute('class', 'vertex');
        layerPoints.appendChild(c);
    }
    
    function createPath(x1, y1, x2, y2, type) {
        if (type === 'fermion') {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'line-fermion');
            // Hack for mid-marker orientation: SVG 1.1 doesn't orient marker-mid automatically along path well
            // We usually need path.
            // Let's use path
            layerLines.appendChild(line);
            
            // Add Arrow explicitly in middle
            const midX = (x1+x2)/2;
            const midY = (y1+y2)/2;
            const angle = Math.atan2(y2-y1, x2-x1) * 180 / Math.PI;
            
            // Create arrow usage
            // Actually simple line marker-mid works in many browsers if vertex in middle? 
            // Standard SVG doesn't put marker in middle of segment easily without extra vertex.
            // Let's draw a separate polygon for arrow
            
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrow.setAttribute('d', 'M-5,-5 L5,0 L-5,5'); // Arrow shape
            arrow.setAttribute('fill', '#374151');
            arrow.setAttribute('transform', `translate(${midX},${midY}) rotate(${angle})`);
            layerLines.appendChild(arrow);
            
        } else if (type === 'photon') {
            // Wavy line (Sine wave)
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = getWavyPath(x1, y1, x2, y2);
            path.setAttribute('d', d);
            path.setAttribute('class', 'line-photon');
            layerLines.appendChild(path);
        } else if (type === 'gluon') {
            // Curly line (Cycloid/Spring)
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = getCurlyPath(x1, y1, x2, y2);
            path.setAttribute('d', d);
            path.setAttribute('class', 'line-gluon');
            layerLines.appendChild(path);
        } else {
            // Scalar (Dashed)
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'line-dashed');
            layerLines.appendChild(line);
        }
    }
    
    function getWavyPath(x1, y1, x2, y2) {
        const dist = Math.hypot(x2-x1, y2-y1);
        const angle = Math.atan2(y2-y1, x2-x1);
        
        let path = `M ${x1} ${y1} `;
        
        const freq = 0.2; // loops per pixel?
        const amp = 5;
        
        // Rotate points
        // Easier to generate horizontal wave then rotate
        const steps = dist / 2; // resolution
        
        for (let i = 0; i <= steps; i++) {
            const x = (i / steps) * dist;
            const y = Math.sin(x * freq * Math.PI) * amp;
            
            // Rotate back
            const rx = x * Math.cos(angle) - y * Math.sin(angle) + x1;
            const ry = x * Math.sin(angle) + y * Math.cos(angle) + y1;
            
            path += `L ${rx} ${ry} `;
        }
        
        return path;
    }
    
    function getCurlyPath(x1, y1, x2, y2) {
        const dist = Math.hypot(x2-x1, y2-y1);
        const angle = Math.atan2(y2-y1, x2-x1);
        
        let path = `M ${x1} ${y1} `;
        
        const loops = Math.floor(dist / 10);
        const r = 5;
        
        for (let i = 0; i <= loops * 10; i++) {
            const t = i / 10; // 0 to loops
            // Cycloid-ish
            const x = t * 10; // Linear progress
            // Parametric loop:
            // x = t + r*cos(t), y = r*sin(t)
            
            const lx = (i / (loops*10)) * dist + Math.cos(i) * 3 - 3; 
            const ly = Math.sin(i) * 5;
            
            // This loop needs to be continuous spirals
            // Let's use simple logic:
            // Center moves linearly. Point orbits center.
            const cx = (i / (loops*10)) * dist;
            const theta = (i / 10) * Math.PI * 2 * loops; // full rotations
            
            const px = cx + Math.cos(theta) * 3; // squashed x loop
            const py = Math.sin(theta) * 5;
            
            // Rotate
            const rx = px * Math.cos(angle) - py * Math.sin(angle) + x1;
            const ry = px * Math.sin(angle) + py * Math.cos(angle) + y1;
            
            path += `L ${rx} ${ry} `;
        }
        return path;
    }

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
