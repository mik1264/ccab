<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloch Sphere Playground - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #111;
            color: #eee;
            font-family: 'Segoe UI', system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            cursor: move;
        }
        
        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        button {
            padding: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover { background: #444; }
        
        .state-info {
            margin-top: 20px;
            font-family: monospace;
            font-size: 1.2rem;
        }
        
        .bra-ket {
            color: #0ea5e9;
        }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">← Back to Gallery</a>
    <h1>Bloch Sphere Visualization</h1>
    <p>Visualizing a Single Qubit State \( |\psi\rangle = \cos(\theta/2)|0\rangle + e^{i\phi}\sin(\theta/2)|1\rangle \)</p>
    
    <canvas id="canvas" width="600" height="600"></canvas>
    
    <div class="state-info" id="state-display">
        |ψ⟩ = 1.00|0⟩ + 0.00|1⟩
    </div>
    
    <div class="controls">
        <button onclick="applyGate('X')">Gate X (NOT)</button>
        <button onclick="applyGate('Y')">Gate Y</button>
        <button onclick="applyGate('Z')">Gate Z</button>
        <button onclick="applyGate('H')">Hadamard (H)</button>
        <button onclick="resetState()">Reset |0⟩</button>
    </div>
    
    <p style="color: #666; font-size: 0.9rem; margin-top: 20px;">
        Click and drag to rotate camera.
    </p>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // State: theta, phi (Spherical coords)
    // |0> is North Pole (theta=0)
    // |1> is South Pole (theta=PI)
    let theta = 0;
    let phi = 0;
    
    // Camera
    let camRotX = 0;
    let camRotY = 0;
    
    // Interaction
    let isDragging = false;
    let lastX = 0, lastY = 0;
    
    function init() {
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        window.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                camRotY += dx * 0.01;
                camRotX += dy * 0.01;
                lastX = e.clientX;
                lastY = e.clientY;
                requestAnimationFrame(draw);
            }
        });
        
        draw();
    }
    
    // 3D Point Projection
    function project(x, y, z) {
        // Rotate Y
        let x1 = x * Math.cos(camRotY) - z * Math.sin(camRotY);
        let z1 = x * Math.sin(camRotY) + z * Math.cos(camRotY);
        // Rotate X
        let y2 = y * Math.cos(camRotX) - z1 * Math.sin(camRotX);
        let z2 = y * Math.sin(camRotX) + z1 * Math.cos(camRotX);
        
        // Perspective
        const scale = 400 / (4 + z2); // fov / (dist + z)
        return {
            x: canvas.width/2 + x1 * scale * 200,
            y: canvas.height/2 + y2 * scale * 200,
            z: z2,
            scale: scale
        };
    }
    
    function drawLine3D(x1, y1, z1, x2, y2, z2, color, width=1) {
        const p1 = project(x1, y1, z1);
        const p2 = project(x2, y2, z2);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    }
    
    function drawSphere() {
        const res = 20;
        ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';
        ctx.lineWidth = 1;
        
        // Latitudes
        for (let i = 0; i <= res; i++) {
            const lat = (i / res) * Math.PI;
            const y = Math.cos(lat);
            const r = Math.sin(lat);
            
            let firstP = null;
            ctx.beginPath();
            for (let j = 0; j <= res*2; j++) {
                const lon = (j / (res*2)) * Math.PI * 2;
                const x = r * Math.cos(lon);
                const z = r * Math.sin(lon);
                const p = project(x, -y, z); // Flip Y so North is Up
                if (j===0) { ctx.moveTo(p.x, p.y); firstP = p; }
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        }
        
        // Longitudes
        // Only a few
        for (let j = 0; j < 8; j++) {
            const lon = (j / 8) * Math.PI * 2;
            ctx.beginPath();
            for (let i = 0; i <= res*2; i++) {
                const lat = (i / (res*2)) * Math.PI * 2;
                const x = Math.sin(lat) * Math.cos(lon);
                const y = Math.cos(lat);
                const z = Math.sin(lat) * Math.sin(lon);
                const p = project(x, -y, z);
                if (i===0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        }
    }
    
    function drawAxes() {
        // |0> (Up)
        drawLine3D(0, -1.2, 0, 0, 1.2, 0, '#444');
        const p0 = project(0, -1.3, 0);
        ctx.fillStyle = '#fff'; ctx.fillText("|0⟩", p0.x, p0.y);
        const p1 = project(0, 1.3, 0);
        ctx.fillText("|1⟩", p1.x, p1.y);
        
        // X
        drawLine3D(-1.2, 0, 0, 1.2, 0, 0, '#444');
        const px = project(1.3, 0, 0);
        ctx.fillText("+", px.x, px.y);
        
        // Y
        drawLine3D(0, 0, -1.2, 0, 0, 1.2, '#444');
        const py = project(0, 0, 1.3);
        ctx.fillText("i", py.x, py.y);
    }
    
    function drawVector() {
        // Convert theta, phi to Cartesian
        // y is up (cos theta)
        const y = Math.cos(theta); // Actually we inverted Y in projection, so let's stick to standard math
        const r = Math.sin(theta);
        const x = r * Math.cos(phi);
        const z = r * Math.sin(phi);
        
        // We project(x, -y, z) because canvas Y is down
        drawLine3D(0, 0, 0, x, -y, z, '#0ea5e9', 4);
        
        // Dot at end
        const p = project(x, -y, z);
        ctx.fillStyle = '#0ea5e9';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
        ctx.fill();
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawSphere();
        drawAxes();
        drawVector();
        updateText();
    }
    
    function updateText() {
        // Calculate coeffs
        // alpha = cos(theta/2)
        // beta = e^iphi * sin(theta/2)
        const alpha = Math.cos(theta/2);
        const betaMag = Math.sin(theta/2);
        
        let betaStr = "";
        if (Math.abs(betaMag) < 0.001) betaStr = "0.00";
        else {
            // Euler form
            betaStr = `${betaMag.toFixed(2)}`;
            if (Math.abs(phi) > 0.01) betaStr += `e^${(phi/Math.PI).toFixed(2)}πi`;
        }
        
        document.getElementById('state-display').textContent = 
            `|ψ⟩ = ${alpha.toFixed(2)}|0⟩ + ${betaStr}|1⟩`;
    }
    
    // Gate Logic
    // We treat state as vector (x,y,z) on sphere and rotate it
    // Or just update theta/phi directly
    
    function applyGate(gate) {
        // Convert to Cartesian
        let y = Math.cos(theta);
        let r = Math.sin(theta);
        let x = r * Math.cos(phi);
        let z = r * Math.sin(phi);
        
        let nx=x, ny=y, nz=z;
        
        if (gate === 'X') {
            // Rotation 180 deg around X axis
            // (x, y, z) -> (x, -y, -z)
            nx = x; ny = -y; nz = -z;
        } else if (gate === 'Y') {
            // Rotation 180 deg around Y axis
            // (x, y, z) -> (-x, y, -z) (Wait, Y gate maps Z to -Z, X to -X)
            // Pauli Y = [0 -i; i 0]
            // Applies to Bloch vector: 180 deg rotation around Y axis.
            nx = -x; ny = -y; nz = -z; // Wait, Pauli Y sends |0> to i|1>, |1> to -i|0>.
            // On Bloch sphere: (0,0,1) -> (0,0,-1). 
            // Rotation is about Y axis. (x,y,z) -> (-x, y, -z) is wrong for Y rotation?
            // Rotation 180 about Y: x->-x, z->-z. y->y?
            // Wait, standard Bloch vector is (x,y,z) = ( <X>, <Y>, <Z> )?
            // Actually commonly Z is up.
            // Let's stick to geometry.
            // X gate: 180 deg around X-axis. (x,y,z) -> (x, -y, -z). Correct.
            // Z gate: 180 deg around Z-axis. (x,y,z) -> (-x, -y, z).
            // Y gate: 180 deg around Y-axis. (x,y,z) -> (-x, y, -z).
            // Hadamard: 180 deg around (X+Z)/sqrt(2) axis? No, H swaps X and Z.
            // H: X->Z, Z->X, Y->-Y.
            nx = -x; ny = -y; nz = -z; // This logic above for Y is rotation about origin? No.
            // Let's redo.
        } 
        
        if (gate === 'Y') {
            nx = -x; ny = -y; nz = -z; // Placeholder, let's correct.
            // Actually Pauli Y corresponds to rotation around Y axis.
            // (x, y, z) -> (-x, y, -z)?
            // |0> (z=1) -> |1> (z=-1)? No. Y|0> = i|1>.
            // z=1 (North) -> z=-1 (South). So Y flips Z.
            // x (state |+>) -> Y|+> = -i|->. (-x).
            // y (state |i>) -> Y|i> = |i>. (y).
            // So (-x, y, -z) IS correct for 180 deg rotation about Y axis.
            // WAIT! My code uses Y as Up (cos theta). 
            // So my axes are: Y=Up (Z in physics), X=Right, Z=Depth (Y in physics).
            // Let's re-map to standard physics notation for sanity.
            // Physics: Z=Up. X=Forward/Right. Y=Sideways.
            // My code: y=cos(theta) -> Up. So my 'y' variable is Physics-Z.
            // My 'x' variable is Physics-X.
            // My 'z' variable is Physics-Y.
            
            // So:
            // Gate X (Physics X): Rotates around Physics-X (my x).
            // Physics Z (my y) -> -Z. Physics Y (my z) -> -Y.
            // (x, y, z) -> (x, -y, -z). Correct.
            
            // Gate Z (Physics Z): Rotates around Physics-Z (my y).
            // Physics X (my x) -> -X. Physics Y (my z) -> -Y.
            // (x, y, z) -> (-x, y, -z). 
            nx = -x; ny = y; nz = -z; 
        }
        
        if (gate === 'Z') {
            // Physics Z rotation (around my y)
            nx = -x; ny = y; nz = -z;
        }
        
        if (gate === 'Y') {
            // Physics Y rotation (around my z)
            // Physics X (my x) -> -X. Physics Z (my y) -> -Z.
            // (x, y, z) -> (-x, -y, z).
            nx = -x; ny = -y; nz = z;
        }
        
        if (gate === 'H') {
            // Hadamard: Swaps X and Z axes (Physics X and Z). Flips Y (Physics Y).
            // Physics X (my x) <-> Physics Z (my y).
            // Physics Y (my z) -> -Physics Y (-my z).
            // (x, y, z) -> (y, x, -z).
            nx = y; ny = x; nz = -z;
        }

        // Convert back to spherical
        // r = 1 always
        // y = cos(theta) -> theta = acos(y)
        theta = Math.acos(Math.max(-1, Math.min(1, ny)));
        phi = Math.atan2(nz, nx);
        
        draw();
    }
    
    function resetState() {
        theta = 0;
        phi = 0;
        draw();
    }
    
    init();

</script>
</body>
</html>
