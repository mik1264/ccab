<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Swarm Robot Formation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
a.back { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #fbbf24; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; font-family: sans-serif; }
a.back:hover { background: rgba(0,0,0,0.9); }
.title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #e2e8f0; font-size: 22px; font-weight: 700; z-index: 999; text-shadow: 0 2px 8px rgba(0,0,0,0.8); pointer-events: none; }
.controls { position: fixed; right: 15px; top: 15px; background: rgba(10,14,26,0.92); border: 1px solid rgba(251,191,36,0.25); border-radius: 12px; padding: 18px; z-index: 999; color: #cbd5e1; font-size: 13px; width: 210px; }
.controls h3 { color: #fbbf24; margin-bottom: 10px; font-size: 15px; }
.btn { display: inline-block; padding: 7px 12px; background: rgba(251,191,36,0.15); border: 1px solid rgba(251,191,36,0.4); border-radius: 6px; color: #fbbf24; cursor: pointer; font-size: 12px; margin: 3px 2px; }
.btn:hover { background: rgba(251,191,36,0.3); }
.btn.active { background: rgba(251,191,36,0.4); border-color: #fbbf24; }
.info { margin-top: 10px; font-size: 11px; line-height: 1.7; border-top: 1px solid rgba(251,191,36,0.15); padding-top: 8px; }
.info .label { color: #94a3b8; }
.info .value { color: #fbbf24; font-weight: 600; }
.section-label { color: #94a3b8; font-size: 11px; margin-bottom: 4px; margin-top: 8px; }
</style>
</head>
<body>
<a href="../index.html" class="back">&#8592; Back to Gallery</a>
<div class="title">Swarm Robot Formation</div>
<div class="controls">
    <h3>Swarm Control</h3>
    <div class="section-label">Formation:</div>
    <span class="btn active" id="circleBtn">Circle</span>
    <span class="btn" id="lineBtn">Line</span>
    <span class="btn" id="squareBtn">Square</span>
    <span class="btn" id="starBtn">Star</span>
    <span class="btn" id="heartBtn">Heart</span>
    <span class="btn" id="vBtn">V-Shape</span>
    <div style="margin-top:8px;">
        <span class="btn" id="scrambleBtn">Scramble</span>
        <span class="btn" id="addBtn">+5 Robots</span>
    </div>
    <div class="info">
        <div><span class="label">Robots: </span><span class="value" id="countStat">24</span></div>
        <div><span class="label">Formation: </span><span class="value" id="formStat">Circle</span></div>
        <div><span class="label">Convergence: </span><span class="value" id="convStat">0%</span></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    const numInitial = 24;
    let robots = [];
    let targetPositions = [];
    let currentFormation = 'circle';
    let trails = [];

    class Robot {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.targetX = x;
            this.targetY = y;
            this.angle = Math.random() * Math.PI * 2;
            this.id = Math.random();
            this.trail = [];
            this.color = `hsl(${Math.random()*60 + 20}, 80%, 60%)`;
        }

        update() {
            // Move toward assigned target
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // Attraction to target
            const attractForce = 0.03;
            this.vx += dx * attractForce;
            this.vy += dy * attractForce;

            // Repulsion from nearby robots (collision avoidance)
            for (const other of robots) {
                if (other === this) continue;
                const rx = this.x - other.x;
                const ry = this.y - other.y;
                const rd = Math.sqrt(rx*rx + ry*ry);
                if (rd < 30 && rd > 0.1) {
                    const repel = 2.0 / (rd * rd);
                    this.vx += (rx / rd) * repel;
                    this.vy += (ry / rd) * repel;
                }
            }

            // Damping
            this.vx *= 0.9;
            this.vy *= 0.9;

            // Speed limit
            const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            const maxSpeed = 4;
            if (speed > maxSpeed) {
                this.vx = (this.vx / speed) * maxSpeed;
                this.vy = (this.vy / speed) * maxSpeed;
            }

            this.x += this.vx;
            this.y += this.vy;

            // Update angle
            if (speed > 0.2) {
                this.angle = Math.atan2(this.vy, this.vx);
            }

            // Trail
            this.trail.push({x: this.x, y: this.y});
            if (this.trail.length > 40) this.trail.shift();
        }

        draw() {
            // Trail
            if (this.trail.length > 1) {
                for (let i = 1; i < this.trail.length; i++) {
                    const alpha = (i / this.trail.length) * 0.2;
                    ctx.strokeStyle = `rgba(251,191,36,${alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[i-1].x, this.trail[i-1].y);
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    ctx.stroke();
                }
            }

            // Communication links to nearby robots
            for (const other of robots) {
                if (other === this) continue;
                const d = Math.sqrt((this.x - other.x)**2 + (this.y - other.y)**2);
                if (d < 80) {
                    ctx.strokeStyle = `rgba(96,165,250,${0.06 * (1 - d/80)})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(other.x, other.y);
                    ctx.stroke();
                }
            }

            // Robot body (triangle pointing in direction of movement)
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            // Glow
            ctx.fillStyle = 'rgba(251,191,36,0.1)';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.fillStyle = '#1e293b';
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-6, -6);
            ctx.lineTo(-3, 0);
            ctx.lineTo(-6, 6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Eye/sensor
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(4, 0, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }

    function generateFormation(name, count) {
        const cx = W / 2;
        const cy = H / 2;
        const positions = [];
        const radius = Math.min(W, H) * 0.3;

        switch (name) {
            case 'circle':
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    positions.push({ x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius });
                }
                break;

            case 'line':
                const lineLen = radius * 2;
                for (let i = 0; i < count; i++) {
                    const t = count === 1 ? 0 : (i / (count - 1)) - 0.5;
                    positions.push({ x: cx + t * lineLen, y: cy });
                }
                break;

            case 'square': {
                const side = Math.ceil(count / 4);
                const sideLen = radius * 1.4;
                const half = sideLen / 2;
                let idx = 0;
                // Top
                for (let i = 0; i < side && idx < count; i++, idx++) {
                    positions.push({ x: cx - half + (i / Math.max(side-1, 1)) * sideLen, y: cy - half });
                }
                // Right
                for (let i = 0; i < side && idx < count; i++, idx++) {
                    positions.push({ x: cx + half, y: cy - half + (i / Math.max(side-1, 1)) * sideLen });
                }
                // Bottom
                for (let i = 0; i < side && idx < count; i++, idx++) {
                    positions.push({ x: cx + half - (i / Math.max(side-1, 1)) * sideLen, y: cy + half });
                }
                // Left
                for (let i = 0; i < side && idx < count; i++, idx++) {
                    positions.push({ x: cx - half, y: cy + half - (i / Math.max(side-1, 1)) * sideLen });
                }
                break;
            }

            case 'star': {
                const points = 5;
                const outerR = radius;
                const innerR = radius * 0.4;
                for (let i = 0; i < count; i++) {
                    const starAngle = (i / count) * Math.PI * 2 - Math.PI / 2;
                    const pointIdx = Math.floor((i / count) * points * 2);
                    const r = pointIdx % 2 === 0 ? outerR : innerR;
                    const a = (pointIdx / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    // Interpolate along star edges
                    const nextIdx = (pointIdx + 1) % (points * 2);
                    const r1 = pointIdx % 2 === 0 ? outerR : innerR;
                    const r2 = nextIdx % 2 === 0 ? outerR : innerR;
                    const a1 = (pointIdx / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    const a2 = (nextIdx / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    const frac = (i / count * points * 2) - pointIdx;
                    const px = cx + Math.cos(a1) * r1 * (1-frac) + Math.cos(a2) * r2 * frac;
                    const py = cy + Math.sin(a1) * r1 * (1-frac) + Math.sin(a2) * r2 * frac;
                    positions.push({ x: px, y: py });
                }
                break;
            }

            case 'heart': {
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * Math.PI * 2;
                    const scale = radius * 0.012;
                    const hx = 16 * Math.pow(Math.sin(t), 3);
                    const hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    positions.push({ x: cx + hx * scale, y: cy + hy * scale });
                }
                break;
            }

            case 'v': {
                const armLen = radius;
                const angle = Math.PI / 6;
                for (let i = 0; i < count; i++) {
                    const side = i % 2 === 0 ? -1 : 1;
                    const idx = Math.floor(i / 2);
                    const t = idx / Math.max(Math.floor(count/2) - 1, 1);
                    positions.push({
                        x: cx + side * Math.sin(angle) * t * armLen,
                        y: cy + Math.cos(angle) * t * armLen - armLen * 0.3
                    });
                }
                break;
            }
        }
        return positions;
    }

    function assignTargets() {
        targetPositions = generateFormation(currentFormation, robots.length);

        // Hungarian-like greedy assignment (assign closest unassigned target to each robot)
        const assigned = new Set();
        const robotOrder = robots.map((r, i) => i).sort((a, b) => {
            // Sort by distance to center
            const da = (robots[a].x - W/2)**2 + (robots[a].y - H/2)**2;
            const db = (robots[b].x - W/2)**2 + (robots[b].y - H/2)**2;
            return da - db;
        });

        for (const ri of robotOrder) {
            let bestDist = Infinity, bestIdx = 0;
            for (let j = 0; j < targetPositions.length; j++) {
                if (assigned.has(j)) continue;
                const d = (robots[ri].x - targetPositions[j].x)**2 + (robots[ri].y - targetPositions[j].y)**2;
                if (d < bestDist) { bestDist = d; bestIdx = j; }
            }
            assigned.add(bestIdx);
            robots[ri].targetX = targetPositions[bestIdx].x;
            robots[ri].targetY = targetPositions[bestIdx].y;
        }
    }

    function initRobots() {
        robots = [];
        for (let i = 0; i < numInitial; i++) {
            robots.push(new Robot(
                W * 0.2 + Math.random() * W * 0.6,
                H * 0.2 + Math.random() * H * 0.6
            ));
        }
        assignTargets();
    }

    function setFormation(name) {
        currentFormation = name;
        document.querySelectorAll('.controls .btn').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById(name + 'Btn');
        if (btn) btn.classList.add('active');
        assignTargets();
        document.getElementById('formStat').textContent = name.charAt(0).toUpperCase() + name.slice(1);
    }

    document.getElementById('circleBtn').onclick = () => setFormation('circle');
    document.getElementById('lineBtn').onclick = () => setFormation('line');
    document.getElementById('squareBtn').onclick = () => setFormation('square');
    document.getElementById('starBtn').onclick = () => setFormation('star');
    document.getElementById('heartBtn').onclick = () => setFormation('heart');
    document.getElementById('vBtn').onclick = () => setFormation('v');

    document.getElementById('scrambleBtn').onclick = function() {
        robots.forEach(r => {
            r.x = W * 0.1 + Math.random() * W * 0.8;
            r.y = H * 0.1 + Math.random() * H * 0.8;
            r.vx = (Math.random() - 0.5) * 4;
            r.vy = (Math.random() - 0.5) * 4;
            r.trail = [];
        });
        assignTargets();
    };

    document.getElementById('addBtn').onclick = function() {
        for (let i = 0; i < 5; i++) {
            robots.push(new Robot(
                W * 0.2 + Math.random() * W * 0.6,
                H * 0.2 + Math.random() * H * 0.6
            ));
        }
        assignTargets();
    };

    initRobots();

    function drawTargetGhosts() {
        ctx.globalAlpha = 0.15;
        targetPositions.forEach(tp => {
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(tp.x, tp.y, 8, 0, Math.PI * 2);
            ctx.stroke();
        });
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;

        // Formation outline
        if (targetPositions.length > 2) {
            ctx.strokeStyle = 'rgba(251,191,36,0.06)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(targetPositions[0].x, targetPositions[0].y);
            for (let i = 1; i < targetPositions.length; i++) {
                ctx.lineTo(targetPositions[i].x, targetPositions[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        }
    }

    function animate() {
        ctx.clearRect(0, 0, W, H);

        const bg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.7);
        bg.addColorStop(0, '#111827');
        bg.addColorStop(1, '#0a0e1a');
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);

        // Grid
        ctx.strokeStyle = 'rgba(100,120,180,0.04)';
        ctx.lineWidth = 1;
        for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
        for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

        drawTargetGhosts();

        // Update and draw robots
        robots.forEach(r => r.update());
        robots.forEach(r => r.draw());

        // Compute convergence
        let totalDist = 0;
        robots.forEach(r => {
            totalDist += Math.sqrt((r.x - r.targetX)**2 + (r.y - r.targetY)**2);
        });
        const avgDist = totalDist / robots.length;
        const convergence = Math.max(0, Math.min(100, 100 * (1 - avgDist / 200)));

        document.getElementById('countStat').textContent = robots.length;
        document.getElementById('convStat').textContent = convergence.toFixed(0) + '%';

        requestAnimationFrame(animate);
    }

    animate();
})();
</script>
</body>
</html>
