<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rigid Body Collision</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0d1117;
            overflow: hidden;
        }

        #canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(88, 166, 255, 0.3);
            z-index: 100;
            min-width: 260px;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            color: #58a6ff;
        }

        .subtitle {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(30, 40, 60, 0.8);
            border: 1px solid rgba(88, 166, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #58a6ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #1f6feb, #58a6ff);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(88, 166, 255, 0.4);
        }

        .physics {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(88, 166, 255, 0.3);
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            max-width: 240px;
        }

        .physics h3 {
            color: #58a6ff;
            margin-bottom: 10px;
        }

        .physics p {
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.5;
        }

        .formula {
            font-family: 'Georgia', serif;
            color: #fff;
            margin: 8px 0;
            text-align: center;
            font-size: 0.9em;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.85em;
            border: 1px solid rgba(88, 166, 255, 0.3);
            color: #aaa;
            font-family: 'Segoe UI', sans-serif;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            gap: 15px;
        }

        .info-value {
            color: #58a6ff;
            font-family: 'Consolas', monospace;
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #58a6ff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(13, 17, 23, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(88, 166, 255, 0.3);
            font-family: 'Segoe UI', sans-serif;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(88, 166, 255, 0.1);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üì¶ Rigid Body Collision</h1>
        <p class="subtitle">Impulse-Based Physics</p>

        <div class="control-group">
            <label>Gravity: <span id="gravValue">0.5</span></label>
            <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Restitution: <span id="restValue">0.7</span></label>
            <input type="range" id="restitution" min="0" max="1" step="0.05" value="0.7">
        </div>

        <div class="control-group">
            <label>Friction: <span id="fricValue">0.3</span></label>
            <input type="range" id="friction" min="0" max="1" step="0.05" value="0.3">
        </div>

        <div class="control-group">
            <label>Angular Damping: <span id="dampValue">0.98</span></label>
            <input type="range" id="damping" min="0.9" max="1" step="0.01" value="0.98">
        </div>

        <div class="btn-row">
            <button onclick="addBox()">Add Box</button>
            <button onclick="addPolygon()">Add Polygon</button>
        </div>
        <div class="btn-row">
            <button onclick="reset()">Reset</button>
            <button onclick="explosion()">Explosion!</button>
        </div>
    </div>

    <div class="physics">
        <h3>Physics Equations</h3>
        <div class="formula">J = -(1+e)v¬∑n / (1/m‚ÇÅ + 1/m‚ÇÇ + ...)</div>
        <p>Impulse-based collision response with rotational inertia. Bodies conserve momentum and angular momentum.</p>
    </div>

    <div class="info">
        <div class="info-row">
            <span>Bodies:</span>
            <span class="info-value" id="bodyCount">0</span>
        </div>
        <div class="info-row">
            <span>Collisions/s:</span>
            <span class="info-value" id="collisions">0</span>
        </div>
        <div class="info-row">
            <span>FPS:</span>
            <span class="info-value" id="fps">60</span>
        </div>
    </div>

    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let gravity = 0.5;
        let restitution = 0.7;
        let friction = 0.3;
        let angularDamping = 0.98;

        let bodies = [];
        let collisionCount = 0;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let lastCollisionTime = performance.now();
        let collisionsPerSecond = 0;

        // Vector math helpers
        const vec = {
            add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
            sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
            mul: (a, s) => ({ x: a.x * s, y: a.y * s }),
            dot: (a, b) => a.x * b.x + a.y * b.y,
            cross: (a, b) => a.x * b.y - a.y * b.x,
            crossVS: (v, s) => ({ x: s * v.y, y: -s * v.x }),
            crossSV: (s, v) => ({ x: -s * v.y, y: s * v.x }),
            len: (v) => Math.sqrt(v.x * v.x + v.y * v.y),
            normalize: (v) => {
                const l = Math.sqrt(v.x * v.x + v.y * v.y);
                return l > 0 ? { x: v.x / l, y: v.y / l } : { x: 0, y: 0 };
            },
            rotate: (v, angle) => ({
                x: v.x * Math.cos(angle) - v.y * Math.sin(angle),
                y: v.x * Math.sin(angle) + v.y * Math.cos(angle)
            })
        };

        class RigidBody {
            constructor(x, y, vertices, color) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.angularVel = (Math.random() - 0.5) * 0.2;

                this.localVertices = vertices;
                this.color = color;

                // Calculate mass and moment of inertia
                this.calculateMassProperties();
            }

            calculateMassProperties() {
                let area = 0;
                let cx = 0, cy = 0;
                const n = this.localVertices.length;

                for (let i = 0; i < n; i++) {
                    const v1 = this.localVertices[i];
                    const v2 = this.localVertices[(i + 1) % n];
                    const cross = v1.x * v2.y - v2.x * v1.y;
                    area += cross;
                    cx += (v1.x + v2.x) * cross;
                    cy += (v1.y + v2.y) * cross;
                }

                area /= 2;
                this.mass = Math.abs(area) * 0.01;
                this.invMass = 1 / this.mass;

                // Moment of inertia for polygon
                let I = 0;
                for (let i = 0; i < n; i++) {
                    const v1 = this.localVertices[i];
                    const v2 = this.localVertices[(i + 1) % n];
                    const cross = Math.abs(v1.x * v2.y - v2.x * v1.y);
                    I += cross * (vec.dot(v1, v1) + vec.dot(v1, v2) + vec.dot(v2, v2));
                }
                this.inertia = I / 12 * this.mass;
                this.invInertia = 1 / this.inertia;
            }

            getWorldVertices() {
                return this.localVertices.map(v => {
                    const rotated = vec.rotate(v, this.angle);
                    return { x: rotated.x + this.x, y: rotated.y + this.y };
                });
            }

            getAxes() {
                const verts = this.getWorldVertices();
                const axes = [];
                for (let i = 0; i < verts.length; i++) {
                    const v1 = verts[i];
                    const v2 = verts[(i + 1) % verts.length];
                    const edge = vec.sub(v2, v1);
                    const normal = vec.normalize({ x: -edge.y, y: edge.x });
                    axes.push(normal);
                }
                return axes;
            }

            project(axis) {
                const verts = this.getWorldVertices();
                let min = vec.dot(verts[0], axis);
                let max = min;
                for (let i = 1; i < verts.length; i++) {
                    const p = vec.dot(verts[i], axis);
                    if (p < min) min = p;
                    if (p > max) max = p;
                }
                return { min, max };
            }

            update(dt) {
                // Apply gravity
                this.vy += gravity * dt * 60;

                // Update position
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.angle += this.angularVel * dt * 60;

                // Angular damping
                this.angularVel *= angularDamping;

                // Boundary collisions
                const verts = this.getWorldVertices();
                for (const v of verts) {
                    if (v.y > canvas.height - 10) {
                        const penetration = v.y - (canvas.height - 10);
                        this.y -= penetration;

                        // Apply impulse at contact point
                        const r = vec.sub(v, { x: this.x, y: this.y });
                        const vp = vec.add({ x: this.vx, y: this.vy }, vec.crossSV(this.angularVel, r));

                        if (vp.y > 0) {
                            const n = { x: 0, y: -1 };
                            const j = -(1 + restitution) * vec.dot(vp, n) /
                                     (this.invMass + this.invInertia * Math.pow(vec.cross(r, n), 2));

                            this.vx += j * n.x * this.invMass;
                            this.vy += j * n.y * this.invMass;
                            this.angularVel += this.invInertia * vec.cross(r, vec.mul(n, j));

                            // Friction
                            const t = { x: 1, y: 0 };
                            const jt = -friction * Math.abs(j) * Math.sign(vec.dot(vp, t));
                            this.vx += jt * this.invMass;
                            this.angularVel += this.invInertia * vec.cross(r, { x: jt, y: 0 });
                        }
                    }

                    // Side walls
                    if (v.x < 10) {
                        this.x += 10 - v.x;
                        this.vx = Math.abs(this.vx) * restitution;
                    }
                    if (v.x > canvas.width - 10) {
                        this.x -= v.x - (canvas.width - 10);
                        this.vx = -Math.abs(this.vx) * restitution;
                    }
                }
            }

            draw() {
                const verts = this.getWorldVertices();

                ctx.save();
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < verts.length; i++) {
                    ctx.lineTo(verts[i].x, verts[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw center and rotation indicator
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * 20,
                    this.y + Math.sin(this.angle) * 20
                );
                ctx.stroke();

                ctx.restore();
            }
        }

        function checkCollision(a, b) {
            const axesA = a.getAxes();
            const axesB = b.getAxes();
            const axes = [...axesA, ...axesB];

            let minOverlap = Infinity;
            let smallestAxis = null;

            for (const axis of axes) {
                const projA = a.project(axis);
                const projB = b.project(axis);

                const overlap = Math.min(projA.max - projB.min, projB.max - projA.min);

                if (overlap <= 0) {
                    return null; // No collision
                }

                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    smallestAxis = axis;
                }
            }

            // Find collision point (approximate)
            const vertsA = a.getWorldVertices();
            const vertsB = b.getWorldVertices();
            let contactPoint = { x: 0, y: 0 };
            let contactCount = 0;

            for (const v of vertsA) {
                if (pointInPolygon(v, vertsB)) {
                    contactPoint.x += v.x;
                    contactPoint.y += v.y;
                    contactCount++;
                }
            }
            for (const v of vertsB) {
                if (pointInPolygon(v, vertsA)) {
                    contactPoint.x += v.x;
                    contactPoint.y += v.y;
                    contactCount++;
                }
            }

            if (contactCount > 0) {
                contactPoint.x /= contactCount;
                contactPoint.y /= contactCount;
            } else {
                contactPoint = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
            }

            // Ensure normal points from A to B
            const d = vec.sub({ x: b.x, y: b.y }, { x: a.x, y: a.y });
            if (vec.dot(d, smallestAxis) < 0) {
                smallestAxis = vec.mul(smallestAxis, -1);
            }

            return {
                normal: smallestAxis,
                depth: minOverlap,
                point: contactPoint
            };
        }

        function pointInPolygon(point, vertices) {
            let inside = false;
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                const xi = vertices[i].x, yi = vertices[i].y;
                const xj = vertices[j].x, yj = vertices[j].y;
                if (((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function resolveCollision(a, b, collision) {
            const { normal, depth, point } = collision;

            // Separate bodies
            const totalMass = a.mass + b.mass;
            a.x -= normal.x * depth * (b.mass / totalMass);
            a.y -= normal.y * depth * (b.mass / totalMass);
            b.x += normal.x * depth * (a.mass / totalMass);
            b.y += normal.y * depth * (a.mass / totalMass);

            // Calculate relative velocity at contact point
            const rA = vec.sub(point, { x: a.x, y: a.y });
            const rB = vec.sub(point, { x: b.x, y: b.y });

            const vpA = vec.add({ x: a.vx, y: a.vy }, vec.crossSV(a.angularVel, rA));
            const vpB = vec.add({ x: b.vx, y: b.vy }, vec.crossSV(b.angularVel, rB));
            const relVel = vec.sub(vpA, vpB);

            const relVelNormal = vec.dot(relVel, normal);

            if (relVelNormal > 0) return; // Moving apart

            // Calculate impulse
            const raCrossN = vec.cross(rA, normal);
            const rbCrossN = vec.cross(rB, normal);
            const denom = a.invMass + b.invMass +
                         raCrossN * raCrossN * a.invInertia +
                         rbCrossN * rbCrossN * b.invInertia;

            const j = -(1 + restitution) * relVelNormal / denom;
            const impulse = vec.mul(normal, j);

            // Apply impulse
            a.vx += impulse.x * a.invMass;
            a.vy += impulse.y * a.invMass;
            a.angularVel += a.invInertia * vec.cross(rA, impulse);

            b.vx -= impulse.x * b.invMass;
            b.vy -= impulse.y * b.invMass;
            b.angularVel -= b.invInertia * vec.cross(rB, impulse);

            // Friction impulse
            const tangent = vec.normalize({
                x: relVel.x - relVelNormal * normal.x,
                y: relVel.y - relVelNormal * normal.y
            });

            const relVelTangent = vec.dot(relVel, tangent);
            const raCrossT = vec.cross(rA, tangent);
            const rbCrossT = vec.cross(rB, tangent);
            const denomT = a.invMass + b.invMass +
                          raCrossT * raCrossT * a.invInertia +
                          rbCrossT * rbCrossT * b.invInertia;

            let jt = -relVelTangent / denomT;
            const maxFriction = friction * Math.abs(j);
            jt = Math.max(-maxFriction, Math.min(maxFriction, jt));

            const frictionImpulse = vec.mul(tangent, jt);

            a.vx += frictionImpulse.x * a.invMass;
            a.vy += frictionImpulse.y * a.invMass;
            a.angularVel += a.invInertia * vec.cross(rA, frictionImpulse);

            b.vx -= frictionImpulse.x * b.invMass;
            b.vy -= frictionImpulse.y * b.invMass;
            b.angularVel -= b.invInertia * vec.cross(rB, frictionImpulse);

            collisionCount++;
        }

        function createBox(x, y, w, h, color) {
            const hw = w / 2, hh = h / 2;
            return new RigidBody(x, y, [
                { x: -hw, y: -hh },
                { x: hw, y: -hh },
                { x: hw, y: hh },
                { x: -hw, y: hh }
            ], color);
        }

        function createPolygon(x, y, r, sides, color) {
            const verts = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                verts.push({
                    x: Math.cos(angle) * r,
                    y: Math.sin(angle) * r
                });
            }
            return new RigidBody(x, y, verts, color);
        }

        function randomColor() {
            const hue = Math.random() * 360;
            return `hsla(${hue}, 70%, 50%, 0.8)`;
        }

        function addBox() {
            const w = 40 + Math.random() * 60;
            const h = 40 + Math.random() * 60;
            const x = 100 + Math.random() * (canvas.width - 200);
            const y = 50 + Math.random() * 100;
            bodies.push(createBox(x, y, w, h, randomColor()));
        }

        function addPolygon() {
            const r = 30 + Math.random() * 40;
            const sides = 3 + Math.floor(Math.random() * 5);
            const x = 100 + Math.random() * (canvas.width - 200);
            const y = 50 + Math.random() * 100;
            bodies.push(createPolygon(x, y, r, sides, randomColor()));
        }

        function reset() {
            bodies = [];
            // Add initial bodies
            for (let i = 0; i < 8; i++) {
                if (Math.random() > 0.5) {
                    addBox();
                } else {
                    addPolygon();
                }
            }
        }

        function explosion() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            for (const body of bodies) {
                const dx = body.x - cx;
                const dy = body.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                const force = 500 / dist;
                body.vx += (dx / dist) * force;
                body.vy += (dy / dist) * force;
                body.angularVel += (Math.random() - 0.5) * 0.5;
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function update(dt) {
            // Update bodies
            for (const body of bodies) {
                body.update(dt);
            }

            // Check collisions
            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const collision = checkCollision(bodies[i], bodies[j]);
                    if (collision) {
                        resolveCollision(bodies[i], bodies[j], collision);
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = 'rgba(88, 166, 255, 0.1)';
            ctx.fillRect(0, canvas.height - 10, canvas.width, 10);

            // Draw walls
            ctx.fillRect(0, 0, 10, canvas.height);
            ctx.fillRect(canvas.width - 10, 0, 10, canvas.height);

            // Draw bodies
            for (const body of bodies) {
                body.draw();
            }

            // Update stats
            document.getElementById('bodyCount').textContent = bodies.length;
        }

        // UI handlers
        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravValue').textContent = gravity.toFixed(1);
        });

        document.getElementById('restitution').addEventListener('input', (e) => {
            restitution = parseFloat(e.target.value);
            document.getElementById('restValue').textContent = restitution.toFixed(2);
        });

        document.getElementById('friction').addEventListener('input', (e) => {
            friction = parseFloat(e.target.value);
            document.getElementById('fricValue').textContent = friction.toFixed(2);
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            angularDamping = parseFloat(e.target.value);
            document.getElementById('dampValue').textContent = angularDamping.toFixed(2);
        });

        let lastTime = performance.now();

        function animate() {
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.05);
            lastTime = now;

            update(dt);
            draw();

            // FPS counter
            frameCount++;
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                document.getElementById('collisions').textContent = collisionCount;
                frameCount = 0;
                collisionCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(animate);
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = reset;

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        reset();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
