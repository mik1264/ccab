<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theo Jansen Tribute - Jensen Linkage - CCAB</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #87ceeb 0%, #e0f0ff 50%, #f5deb3 100%);
        }
        #canvas { display: block; }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.8);
            color: #5d4e37;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .tribute {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            font-family: Georgia, serif;
            color: #5d4e37;
        }
        .tribute h3 { margin: 0 0 5px 0; font-size: 16px; }
        .tribute p { margin: 0; font-size: 12px; opacity: 0.8; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="tribute">
        <h3>Inspired by Theo Jansen</h3>
        <p>Creator of the Strandbeest walking sculptures</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Theo Jansen "holy numbers" - the magic ratios
        const JANSEN = {
            a: 38,    // Crank
            b: 41.5,  //
            c: 39.3,  //
            d: 40.1,  //
            e: 55.8,  //
            f: 39.4,  //
            g: 36.7,  //
            h: 65.7,  //
            i: 49,    //
            j: 50,    //
            k: 61.9,  //
            l: 7.8,   //
            m: 15     // Ground offset
        };

        // Scale factor
        const scale = 2.5;

        let angle = 0;

        class JansenLeg {
            constructor(x, y, phase, flip = false) {
                this.x = x;
                this.y = y;
                this.phase = phase;
                this.flip = flip;
            }

            solve(angle) {
                const a = angle + this.phase;
                const s = scale;
                const f = this.flip ? -1 : 1;

                // Crank position
                const crankX = Math.cos(a) * JANSEN.a * s * f;
                const crankY = Math.sin(a) * JANSEN.a * s;

                // Simplified Jansen linkage calculation
                // This is an approximation of the full mechanism
                const hipOffset = JANSEN.l * s;

                // Calculate intermediate points
                const mx = crankX + hipOffset * f;
                const my = crankY;

                // Upper triangle
                const upperLen = JANSEN.j * s;
                const lowerLen = JANSEN.k * s;

                // Calculate knee position using geometric constraints
                const dist = Math.sqrt(mx * mx + my * my);
                if (dist > upperLen + lowerLen * 0.8) return null;

                const kneeAngle = Math.atan2(my, mx) - Math.acos(Math.min(1, (upperLen * upperLen + dist * dist - lowerLen * lowerLen * 0.5) / (2 * upperLen * dist)));

                const kneeX = Math.cos(kneeAngle) * upperLen * f;
                const kneeY = Math.sin(kneeAngle) * upperLen;

                // Foot position
                const legAngle = Math.atan2(kneeY, kneeX * f);
                const footX = kneeX + Math.cos(legAngle + 0.2) * lowerLen * f;
                const footY = kneeY + Math.sin(legAngle + 0.2) * lowerLen;

                return {
                    crank: { x: crankX, y: crankY },
                    knee: { x: kneeX, y: kneeY },
                    foot: { x: footX, y: footY }
                };
            }

            draw(ctx, angle) {
                const p = this.solve(angle);
                if (!p) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw tubes (PVC pipe style)
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Beige/cream color for PVC pipes
                const tubeColor = '#d4c4a8';
                const shadowColor = '#a89878';

                // Shadow
                ctx.strokeStyle = shadowColor;
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(p.crank.x, p.crank.y);
                ctx.lineTo(p.knee.x, p.knee.y);
                ctx.lineTo(p.foot.x, p.foot.y);
                ctx.stroke();

                // Main tubes
                ctx.strokeStyle = tubeColor;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(p.crank.x, p.crank.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p.crank.x, p.crank.y);
                ctx.lineTo(p.knee.x, p.knee.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(p.knee.x, p.knee.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p.knee.x, p.knee.y);
                ctx.lineTo(p.foot.x, p.foot.y);
                ctx.stroke();

                // Joints (zip tie style)
                [[0, 0], [p.crank.x, p.crank.y], [p.knee.x, p.knee.y], [p.foot.x, p.foot.y]]
                    .forEach(([jx, jy]) => {
                        ctx.beginPath();
                        ctx.arc(jx, jy, 6, 0, Math.PI * 2);
                        ctx.fillStyle = '#888';
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(jx, jy, 4, 0, Math.PI * 2);
                        ctx.fillStyle = tubeColor;
                        ctx.fill();
                    });

                ctx.restore();
            }
        }

        // Create a Strandbeest-like creature with multiple legs
        const bodyY = canvas.height * 0.5;
        const legSpacing = 100;
        const legs = [];

        function createLegs() {
            legs.length = 0;
            const centerX = canvas.width / 2;
            const bodyY = canvas.height * 0.5;

            for (let i = 0; i < 6; i++) {
                const x = centerX - 250 + i * legSpacing;
                const phase = (i % 2) * Math.PI; // Alternating phases
                legs.push(new JansenLeg(x, bodyY, phase, false));
            }
        }

        createLegs();
        window.addEventListener('resize', () => {
            resize();
            createLegs();
        });

        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87ceeb');
            gradient.addColorStop(0.5, '#e0f0ff');
            gradient.addColorStop(0.7, '#f5deb3');
            gradient.addColorStop(1, '#deb887');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawBeach() {
            const beachY = canvas.height * 0.7;

            // Sand
            ctx.fillStyle = '#f5deb3';
            ctx.fillRect(0, beachY, canvas.width, canvas.height - beachY);

            // Sand texture
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * canvas.width;
                const y = beachY + Math.random() * (canvas.height - beachY);
                ctx.fillStyle = `rgba(210, 180, 140, ${Math.random() * 0.3})`;
                ctx.fillRect(x, y, 3, 2);
            }
        }

        function animate() {
            drawSky();
            drawBeach();

            const centerX = canvas.width / 2;
            const bodyY = canvas.height * 0.5;

            // Draw body (sail-like structure)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#d4c4a8';
            ctx.lineWidth = 4;

            ctx.beginPath();
            ctx.moveTo(centerX - 200, bodyY);
            ctx.lineTo(centerX, bodyY - 150);
            ctx.lineTo(centerX + 200, bodyY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Body frame
            ctx.strokeStyle = '#a89878';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(centerX - 250, bodyY);
            ctx.lineTo(centerX + 250, bodyY);
            ctx.stroke();

            // Draw legs
            legs.forEach(leg => {
                leg.x = centerX - 250 + legs.indexOf(leg) * legSpacing;
                leg.y = bodyY;
                leg.draw(ctx, angle);
            });

            // Wind indicator
            ctx.save();
            ctx.translate(50, 50);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '12px sans-serif';
            ctx.fillText('WIND →', 0, 0);
            ctx.restore();

            angle += 0.02;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
