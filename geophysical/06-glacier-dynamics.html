<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glacier Dynamics Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #8A9A5B;
            text-decoration: none;
            font-size: 18px;
            font-weight: 600;
            z-index: 100;
            background: rgba(10, 14, 26, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #8A9A5B;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: #8A9A5B;
            color: #0a0e1a;
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 14, 26, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #606C38;
            z-index: 100;
            max-width: 300px;
        }

        .controls h3 {
            color: #DDA15E;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #8A9A5B;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .control-group .value {
            color: #DDA15E;
            font-weight: bold;
            font-size: 14px;
        }

        button {
            background: #606C38;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover {
            background: #8A9A5B;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 14, 26, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #BC6C25;
            max-width: 400px;
            z-index: 100;
        }

        .info h3 {
            color: #DDA15E;
            margin-bottom: 10px;
        }

        .info p {
            line-height: 1.6;
            font-size: 14px;
            color: #e0e0e0;
        }

        .stats {
            margin-top: 10px;
            font-size: 12px;
            color: #DDA15E;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Geophysical</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h3>Glacier Controls</h3>

        <div class="control-group">
            <label>Snowfall: <span class="value" id="snowValue">50%</span></label>
            <input type="range" id="snowfall" min="0" max="100" step="5" value="50">
        </div>

        <div class="control-group">
            <label>Temperature: <span class="value" id="tempValue">0°C</span></label>
            <input type="range" id="temperature" min="-20" max="20" step="1" value="0">
        </div>

        <div class="control-group">
            <label>Flow Speed: <span class="value" id="flowValue">1.0x</span></label>
            <input type="range" id="flow" min="0" max="3" step="0.1" value="1">
        </div>

        <button id="resetBtn">Reset Glacier</button>
    </div>

    <div class="info">
        <h3>Glacier Dynamics</h3>
        <p>Ice accumulates at high elevations and flows downward under gravity. Watch accumulation zones (blue), ablation zones (melting), and calving events at the terminus.</p>
        <div class="stats">
            <div>Ice Volume: <span id="volumeStat">0</span> km³</div>
            <div>Flow Rate: <span id="flowStat">0</span> m/year</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Grid for ice thickness
        const gridW = 150;
        const gridH = 100;
        let iceThickness = [];
        let bedrock = [];
        let velocity = [];

        // Initialize terrain
        function initTerrain() {
            iceThickness = [];
            bedrock = [];
            velocity = [];

            for (let y = 0; y < gridH; y++) {
                iceThickness[y] = [];
                bedrock[y] = [];
                velocity[y] = [];

                for (let x = 0; x < gridW; x++) {
                    // Create mountain profile
                    const xNorm = x / gridW;
                    const yNorm = y / gridH;

                    // Elevation increases toward the left (accumulation zone)
                    let elevation = (1 - xNorm) * 60;
                    elevation += Math.sin(xNorm * Math.PI * 3) * 10;
                    elevation += (Math.random() - 0.5) * 5;

                    // Valley shape
                    const valleyDepth = (0.5 - Math.abs(yNorm - 0.5)) * 20;
                    elevation -= valleyDepth;

                    bedrock[y][x] = Math.max(0, elevation);
                    iceThickness[y][x] = xNorm < 0.3 ? (Math.random() * 10) : 0;
                    velocity[y][x] = 0;
                }
            }
        }

        // Ice particle for visualization
        class IceParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.age = 0;
            }

            update() {
                const gx = Math.floor(this.x);
                const gy = Math.floor(this.y);

                if (gx >= 0 && gx < gridW - 1 && gy >= 0 && gy < gridH - 1) {
                    // Move with glacier flow
                    const vx = velocity[gy][gx];
                    this.x += vx;

                    // Slight downslope movement
                    const slope = (bedrock[gy][Math.min(gx + 1, gridW - 1)] - bedrock[gy][gx]);
                    this.y -= slope * 0.01;

                    this.age++;

                    // Check if still on ice
                    return iceThickness[gy][gx] > 1 && this.x < gridW;
                }
                return false;
            }

            draw(ctx, cellW, cellH) {
                const alpha = Math.min(1, this.age / 100);
                ctx.fillStyle = `rgba(180, 220, 255, ${alpha * 0.4})`;
                ctx.beginPath();
                ctx.arc(this.x * cellW, this.y * cellH, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Simulation parameters
        let snowfall = 0.5;
        let temperature = 0;
        let flowSpeed = 1;
        let particles = [];
        let time = 0;

        // Update glacier physics
        function updateGlacier() {
            const newThickness = JSON.parse(JSON.stringify(iceThickness));
            const newVelocity = JSON.parse(JSON.stringify(velocity));

            let totalVolume = 0;
            let totalFlow = 0;

            for (let y = 1; y < gridH - 1; y++) {
                for (let x = 1; x < gridW - 1; x++) {
                    const xNorm = x / gridW;

                    // Accumulation zone (left side, high elevation)
                    if (xNorm < 0.3 && temperature < 5) {
                        iceThickness[y][x] += snowfall * 0.02;
                    }

                    // Ablation (melting) - right side and warm temps
                    if (temperature > -5) {
                        const meltRate = Math.max(0, (temperature + 5) * 0.001 * (xNorm * 2));
                        iceThickness[y][x] -= meltRate;
                    }

                    // Ice flow - gravity driven
                    if (iceThickness[y][x] > 1) {
                        const surface = bedrock[y][x] + iceThickness[y][x];

                        // Calculate pressure and slope
                        const thickness = iceThickness[y][x];
                        const slopeX = x < gridW - 1 ?
                            (bedrock[y][x + 1] + iceThickness[y][x + 1]) - surface : 0;

                        // Flow velocity (simplified)
                        const flowRate = Math.pow(thickness, 2) * slopeX * 0.0001 * flowSpeed;
                        velocity[y][x] = flowRate;

                        // Redistribute ice
                        if (x < gridW - 1 && flowRate > 0) {
                            const transfer = Math.min(thickness * 0.02, Math.abs(flowRate) * 0.5);
                            newThickness[y][x] -= transfer;
                            newThickness[y][x + 1] += transfer * 0.9; // Some mass loss
                        }

                        totalVolume += thickness;
                        totalFlow += Math.abs(flowRate);
                    }

                    // Calving at terminus (where ice meets edge or warm water)
                    if (x > gridW * 0.7 && iceThickness[y][x] > 5 && Math.random() < 0.01) {
                        iceThickness[y][x] *= 0.8;
                        // Create calving particles
                        for (let i = 0; i < 5; i++) {
                            particles.push(new IceParticle(x + Math.random(), y + Math.random()));
                        }
                    }

                    // Ensure non-negative
                    iceThickness[y][x] = Math.max(0, iceThickness[y][x]);
                }
            }

            // Apply updates
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    iceThickness[y][x] = Math.max(0, newThickness[y][x]);
                    velocity[y][x] = newVelocity[y][x];
                }
            }

            // Update stats
            document.getElementById('volumeStat').textContent = (totalVolume / 100).toFixed(1);
            document.getElementById('flowStat').textContent = (totalFlow * 1000).toFixed(0);
        }

        // Draw glacier
        function drawGlacier() {
            const cellW = width / gridW;
            const cellH = height / gridH;

            // Draw bedrock and ice
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const screenX = x * cellW;
                    const screenY = y * cellH;

                    // Bedrock
                    const elevation = bedrock[y][x];
                    const bedrockColor = elevation > 40 ? '#8B7D6B' : '#5D4E37';
                    ctx.fillStyle = bedrockColor;
                    ctx.fillRect(screenX, screenY, cellW + 1, cellH + 1);

                    // Ice
                    if (iceThickness[y][x] > 0.5) {
                        const thickness = iceThickness[y][x];
                        const alpha = Math.min(0.9, thickness / 30);

                        // Ice color - blue, darker with depth
                        const blue = 200 + Math.floor(thickness * 2);
                        ctx.fillStyle = `rgba(180, 220, ${Math.min(255, blue)}, ${alpha})`;
                        ctx.fillRect(screenX, screenY, cellW + 1, cellH + 1);

                        // Crevasses in areas of high stress
                        if (velocity[y][x] > 0.5 && Math.random() < 0.02) {
                            ctx.strokeStyle = 'rgba(100, 150, 200, 0.5)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(screenX + Math.random() * cellW, screenY);
                            ctx.lineTo(screenX + Math.random() * cellW, screenY + cellH);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw flow vectors
            for (let y = 5; y < gridH; y += 10) {
                for (let x = 5; x < gridW; x += 10) {
                    if (iceThickness[y][x] > 2 && velocity[y][x] > 0.05) {
                        const screenX = x * cellW;
                        const screenY = y * cellH;
                        const vx = velocity[y][x] * 20;

                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX + vx * cellW, screenY);
                        ctx.stroke();
                    }
                }
            }

            // Draw ice particles (calving/debris)
            particles = particles.filter(p => {
                const alive = p.update();
                if (alive) p.draw(ctx, cellW, cellH);
                return alive;
            });

            // Add accumulation particles occasionally
            if (snowfall > 0.1 && temperature < 5 && Math.random() < snowfall * 0.1) {
                particles.push(new IceParticle(
                    Math.random() * gridW * 0.3,
                    Math.random() * gridH
                ));
            }
        }

        // Animation loop
        function animate() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            updateGlacier();
            drawGlacier();

            time++;

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('snowfall').addEventListener('input', (e) => {
            snowfall = parseInt(e.target.value) / 100;
            document.getElementById('snowValue').textContent = e.target.value + '%';
        });

        document.getElementById('temperature').addEventListener('input', (e) => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempValue').textContent = temperature + '°C';
        });

        document.getElementById('flow').addEventListener('input', (e) => {
            flowSpeed = parseFloat(e.target.value);
            document.getElementById('flowValue').textContent = flowSpeed.toFixed(1) + 'x';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initTerrain();
            particles = [];
        });

        // Initialize
        initTerrain();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
