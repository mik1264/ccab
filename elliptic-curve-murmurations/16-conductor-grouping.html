<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor Grouping Analysis | CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            background: rgba(255,255,255,0.05);
            padding: 16px 24px;
            border-radius: 8px;
        }
        label {
            font-size: 0.85rem;
            color: #888;
            display: block;
            margin-bottom: 8px;
        }
        select {
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 1rem;
        }
        .main-canvas {
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(102, 126, 234, 0.3);
        }
        .legend {
            display: flex;
            gap: 24px;
            justify-content: center;
            margin-top: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 24px;
        }
        .info-card {
            background: rgba(255,255,255,0.03);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .info-card h3 {
            color: #667eea;
            margin-bottom: 8px;
            font-size: 1rem;
        }
        .info-card p {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.6;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #667eea;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            z-index: 100;
        }
        .back-link:hover { opacity: 1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <h1>Conductor Grouping Analysis</h1>
    <p class="subtitle">How grouping by conductor reveals murmuration patterns</p>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label>Conductor Range</label>
                <select id="conductorRange">
                    <option value="100">N ≤ 100</option>
                    <option value="500" selected>N ≤ 500</option>
                    <option value="1000">N ≤ 1000</option>
                    <option value="5000">N ≤ 5000</option>
                </select>
            </div>
            <div class="control-group">
                <label>Grouping Method</label>
                <select id="groupMethod">
                    <option value="individual">Individual conductors</option>
                    <option value="ranges" selected>Conductor ranges</option>
                    <option value="prime">Prime conductors only</option>
                </select>
            </div>
            <div class="control-group">
                <label>Display Mode</label>
                <select id="displayMode">
                    <option value="overlay" selected>Overlay all groups</option>
                    <option value="stacked">Stacked view</option>
                    <option value="difference">Rank difference</option>
                </select>
            </div>
        </div>

        <canvas id="canvas" class="main-canvas"></canvas>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4ade80"></div>
                <span>Rank 0 average</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #60a5fa"></div>
                <span>Rank 1 average</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,255,255,0.3)"></div>
                <span>Individual groups</span>
            </div>
        </div>

        <div class="info-grid">
            <div class="info-card">
                <h3>Why Group by Conductor?</h3>
                <p>The conductor N summarizes "bad" primes for a curve. Grouping by N normalizes curves so their aₚ values become comparable, revealing statistical patterns.</p>
            </div>
            <div class="info-card">
                <h3>The Discovery Key</h3>
                <p>Pozdnyakov's crucial insight was to NOT normalize aₚ values by √p, which experts traditionally did. This preserved the oscillations that became visible as murmurations.</p>
            </div>
            <div class="info-card">
                <h3>LMFDB Data</h3>
                <p>The original discovery used data from the LMFDB (L-functions and Modular Forms Database), which conveniently pre-sorts curves by conductor.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let conductorMax = 500;
        let groupMethod = 'ranges';
        let displayMode = 'overlay';

        function resize() {
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 1000;
        }
        resize();
        window.addEventListener('resize', () => { resize(); draw(); });

        function generateGroupData(conductorRange, numGroups) {
            const groups = [];

            for (let g = 0; g < numGroups; g++) {
                const rank0Data = [];
                const rank1Data = [];
                const numPoints = 100;

                // Each group has slightly different murmuration phase
                const groupPhase = g * 0.1;

                for (let i = 0; i < numPoints; i++) {
                    const t = i / numPoints;
                    const decay = Math.exp(-t * 2);

                    // Rank 0 wave
                    const r0 = (
                        0.5 * Math.sin(2 * Math.PI * t * 5 + groupPhase) +
                        0.3 * Math.sin(2 * Math.PI * t * 8 + groupPhase)
                    ) * decay + 0.2 * decay;

                    // Rank 1 wave (opposite phase)
                    const r1 = (
                        -0.5 * Math.sin(2 * Math.PI * t * 5 + groupPhase + Math.PI * 0.3) +
                        -0.3 * Math.sin(2 * Math.PI * t * 8 + groupPhase + Math.PI * 0.3)
                    ) * decay - 0.2 * decay;

                    // Add noise proportional to group size
                    const noise = 0.15 / Math.sqrt(numGroups);
                    rank0Data.push(r0 + (Math.random() - 0.5) * noise);
                    rank1Data.push(r1 + (Math.random() - 0.5) * noise);
                }

                groups.push({ rank0Data, rank1Data, conductorStart: (g / numGroups) * conductorRange });
            }

            return groups;
        }

        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const margin = { top: 60, right: 60, bottom: 80, left: 80 };

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;

            // Grid
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = margin.left + (i / 10) * plotW;
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, h - margin.bottom);
                ctx.stroke();
            }
            for (let i = 0; i <= 8; i++) {
                const y = margin.top + (i / 8) * plotH;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }

            // Zero line
            const zeroY = margin.top + plotH / 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, zeroY);
            ctx.lineTo(w - margin.right, zeroY);
            ctx.stroke();

            // Generate data
            const numGroups = groupMethod === 'individual' ? 20 : groupMethod === 'prime' ? 8 : 10;
            const groups = generateGroupData(conductorMax, numGroups);

            // Calculate averages
            const numPoints = groups[0].rank0Data.length;
            const avgRank0 = new Array(numPoints).fill(0);
            const avgRank1 = new Array(numPoints).fill(0);

            groups.forEach(group => {
                group.rank0Data.forEach((v, i) => avgRank0[i] += v);
                group.rank1Data.forEach((v, i) => avgRank1[i] += v);
            });

            avgRank0.forEach((_, i) => avgRank0[i] /= groups.length);
            avgRank1.forEach((_, i) => avgRank1[i] /= groups.length);

            if (displayMode === 'overlay') {
                // Draw individual group lines (faded)
                groups.forEach((group, gIdx) => {
                    const alpha = 0.15;

                    // Rank 0
                    ctx.strokeStyle = `rgba(74, 222, 128, ${alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    group.rank0Data.forEach((v, i) => {
                        const x = margin.left + (i / numPoints) * plotW;
                        const y = zeroY - v * (plotH / 3);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();

                    // Rank 1
                    ctx.strokeStyle = `rgba(96, 165, 250, ${alpha})`;
                    ctx.beginPath();
                    group.rank1Data.forEach((v, i) => {
                        const x = margin.left + (i / numPoints) * plotW;
                        const y = zeroY - v * (plotH / 3);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                });

                // Draw averages
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 4;
                ctx.beginPath();
                avgRank0.forEach((v, i) => {
                    const x = margin.left + (i / numPoints) * plotW;
                    const y = zeroY - v * (plotH / 3);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                ctx.strokeStyle = '#60a5fa';
                ctx.beginPath();
                avgRank1.forEach((v, i) => {
                    const x = margin.left + (i / numPoints) * plotW;
                    const y = zeroY - v * (plotH / 3);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

            } else if (displayMode === 'difference') {
                // Show difference between rank 0 and rank 1
                const diff = avgRank0.map((v, i) => v - avgRank1[i]);

                ctx.strokeStyle = '#f472b6';
                ctx.lineWidth = 4;
                ctx.beginPath();
                diff.forEach((v, i) => {
                    const x = margin.left + (i / numPoints) * plotW;
                    const y = zeroY - v * (plotH / 4);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Fill area
                ctx.fillStyle = 'rgba(244, 114, 182, 0.2)';
                ctx.beginPath();
                ctx.moveTo(margin.left, zeroY);
                diff.forEach((v, i) => {
                    const x = margin.left + (i / numPoints) * plotW;
                    const y = zeroY - v * (plotH / 4);
                    ctx.lineTo(x, y);
                });
                ctx.lineTo(w - margin.right, zeroY);
                ctx.closePath();
                ctx.fill();

            } else {
                // Stacked view
                const sectionH = plotH / groups.length;

                groups.forEach((group, gIdx) => {
                    const baseY = margin.top + (gIdx + 0.5) * sectionH;

                    ctx.strokeStyle = '#4ade80';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    group.rank0Data.forEach((v, i) => {
                        const x = margin.left + (i / numPoints) * plotW;
                        const y = baseY - v * (sectionH * 0.3);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();

                    ctx.strokeStyle = '#60a5fa';
                    ctx.beginPath();
                    group.rank1Data.forEach((v, i) => {
                        const x = margin.left + (i / numPoints) * plotW;
                        const y = baseY - v * (sectionH * 0.3);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#666';
                    ctx.font = '16px system-ui';
                    ctx.textAlign = 'right';
                    ctx.fillText(`N≈${Math.round(group.conductorStart)}`, margin.left - 10, baseY + 5);
                });
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '24px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText('Prime p', w / 2, h - 20);

            ctx.save();
            ctx.translate(25, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Average aₚ', 0, 0);
            ctx.restore();

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px system-ui';
            ctx.fillText(`Conductor Range: N ≤ ${conductorMax}`, w / 2, 35);
        }

        document.getElementById('conductorRange').addEventListener('change', (e) => {
            conductorMax = parseInt(e.target.value);
            draw();
        });

        document.getElementById('groupMethod').addEventListener('change', (e) => {
            groupMethod = e.target.value;
            draw();
        });

        document.getElementById('displayMode').addEventListener('change', (e) => {
            displayMode = e.target.value;
            draw();
        });

        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
