<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliptic Curve Point Addition | CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        canvas {
            background: #000;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(102, 126, 234, 0.3);
            cursor: crosshair;
        }
        .sidebar {
            width: 340px;
            padding: 24px;
            background: rgba(255,255,255,0.05);
            border-left: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 24px;
        }
        .point-display {
            background: rgba(0,0,0,0.3);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .point-label {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 4px;
        }
        .point-coords {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
        }
        .point-p { color: #4ade80; }
        .point-q { color: #60a5fa; }
        .point-r { color: #f472b6; }
        .formula {
            background: rgba(102, 126, 234, 0.1);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        .formula-title {
            font-size: 0.9rem;
            color: #667eea;
            margin-bottom: 8px;
        }
        .formula-text {
            font-family: 'Times New Roman', serif;
            font-size: 0.95rem;
            line-height: 1.8;
        }
        .instructions {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.6;
            margin-top: 16px;
            padding: 16px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-top: 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #667eea;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            z-index: 100;
        }
        .back-link:hover { opacity: 1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="sidebar">
        <h1>Point Addition</h1>
        <p class="subtitle">Visualizing the elliptic curve group operation</p>

        <div class="point-display">
            <div class="point-label">Point P (click to place)</div>
            <div class="point-coords point-p" id="pointP">Not set</div>
        </div>

        <div class="point-display">
            <div class="point-label">Point Q (click to place)</div>
            <div class="point-coords point-q" id="pointQ">Not set</div>
        </div>

        <div class="point-display">
            <div class="point-label">Result P + Q = R</div>
            <div class="point-coords point-r" id="pointR">-</div>
        </div>

        <div class="formula">
            <div class="formula-title">Addition Formula</div>
            <div class="formula-text">
                λ = (y₂ - y₁) / (x₂ - x₁)<br>
                x₃ = λ² - x₁ - x₂<br>
                y₃ = λ(x₁ - x₃) - y₁
            </div>
        </div>

        <div class="formula">
            <div class="formula-title">Curve: y² = x³ - x + 1</div>
            <div class="formula-text">
                To add P and Q:<br>
                1. Draw line through P and Q<br>
                2. Find third intersection R'<br>
                3. Reflect R' over x-axis to get R
            </div>
        </div>

        <button id="resetBtn">Reset Points</button>
        <button id="animateBtn">Animate Addition</button>

        <div class="instructions">
            Click on the curve to place points P and Q. The visualization will
            show the geometric construction of their sum.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const A = -1, B = 1;
        let zoom = 60;
        let P = null, Q = null, R = null;
        let animating = false;
        let animProgress = 0;

        function resize() {
            const size = Math.min(window.innerWidth - 380, window.innerHeight - 40);
            canvas.width = size;
            canvas.height = size;
        }
        resize();
        window.addEventListener('resize', () => { resize(); draw(); });

        const cx = () => canvas.width / 2;
        const cy = () => canvas.height / 2;

        function curveY(x) {
            const rhs = x * x * x + A * x + B;
            return rhs >= 0 ? Math.sqrt(rhs) : null;
        }

        function screenToMath(sx, sy) {
            return [(sx - cx()) / zoom, (cy() - sy) / zoom];
        }

        function mathToScreen(x, y) {
            return [cx() + x * zoom, cy() - y * zoom];
        }

        function findClosestPointOnCurve(mx, my) {
            let bestDist = Infinity;
            let bestPoint = null;

            for (let x = -5; x <= 5; x += 0.01) {
                const y = curveY(x);
                if (y !== null) {
                    for (const yy of [y, -y]) {
                        const d = Math.hypot(x - mx, yy - my);
                        if (d < bestDist) {
                            bestDist = d;
                            bestPoint = [x, yy];
                        }
                    }
                }
            }
            return bestPoint;
        }

        function addPoints(p1, p2) {
            if (!p1 || !p2) return null;

            const [x1, y1] = p1;
            const [x2, y2] = p2;

            let lambda;
            if (Math.abs(x1 - x2) < 0.0001) {
                if (Math.abs(y1 + y2) < 0.0001) return null; // Point at infinity
                lambda = (3 * x1 * x1 + A) / (2 * y1);
            } else {
                lambda = (y2 - y1) / (x2 - x1);
            }

            const x3 = lambda * lambda - x1 - x2;
            const y3 = lambda * (x1 - x3) - y1;

            return [x3, -y3]; // Reflected
        }

        function draw() {
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.1)';
            ctx.lineWidth = 1;
            for (let i = -10; i <= 10; i++) {
                const x = cx() + i * zoom;
                const y = cy() + i * zoom;
                ctx.beginPath();
                ctx.moveTo(x, 0); ctx.lineTo(x, h);
                ctx.moveTo(0, y); ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy()); ctx.lineTo(w, cy());
            ctx.moveTo(cx(), 0); ctx.lineTo(cx(), h);
            ctx.stroke();

            // Draw curve
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;

            for (const sign of [1, -1]) {
                ctx.beginPath();
                let started = false;
                for (let px = 0; px < w; px++) {
                    const [mx] = screenToMath(px, 0);
                    const y = curveY(mx);
                    if (y !== null) {
                        const [, sy] = mathToScreen(mx, sign * y);
                        if (!started) {
                            ctx.moveTo(px, sy);
                            started = true;
                        } else {
                            ctx.lineTo(px, sy);
                        }
                    } else {
                        started = false;
                    }
                }
                ctx.stroke();
            }

            // Draw construction if both points exist
            if (P && Q) {
                const R_prime = addPoints(P, Q);
                if (R_prime) {
                    R = [R_prime[0], -R_prime[1]];

                    // Line through P and Q
                    const progress = animating ? Math.min(animProgress, 1) : 1;

                    if (progress > 0) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();

                        const dx = Q[0] - P[0];
                        const dy = Q[1] - P[1];
                        const len = Math.hypot(dx, dy);
                        const ext = 10 / len;

                        const [sx1, sy1] = mathToScreen(P[0] - dx * ext, P[1] - dy * ext);
                        const [sx2, sy2] = mathToScreen(Q[0] + dx * ext * 2, Q[1] + dy * ext * 2);

                        ctx.moveTo(sx1, sy1);
                        ctx.lineTo(sx1 + (sx2 - sx1) * progress, sy1 + (sy2 - sy1) * progress);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // R' (before reflection)
                    if (progress > 0.5) {
                        const [rx, ry] = mathToScreen(R_prime[0], R_prime[1]);
                        ctx.fillStyle = 'rgba(244, 114, 182, 0.5)';
                        ctx.beginPath();
                        ctx.arc(rx, ry, 8, 0, Math.PI * 2);
                        ctx.fill();

                        // Vertical line for reflection
                        if (progress > 0.7) {
                            ctx.strokeStyle = 'rgba(244, 114, 182, 0.3)';
                            ctx.setLineDash([3, 3]);
                            ctx.beginPath();
                            const [rx2, ry2] = mathToScreen(R[0], R[1]);
                            ctx.moveTo(rx, ry);
                            ctx.lineTo(rx2, ry2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }

                    // Final R
                    if (progress >= 1) {
                        const [rx, ry] = mathToScreen(R[0], R[1]);
                        ctx.fillStyle = '#f472b6';
                        ctx.beginPath();
                        ctx.arc(rx, ry, 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px system-ui';
                        ctx.textAlign = 'center';
                        ctx.fillText('R', rx, ry + 5);

                        document.getElementById('pointR').textContent =
                            `(${R[0].toFixed(3)}, ${R[1].toFixed(3)})`;
                    }
                }
            }

            // Draw P
            if (P) {
                const [px, py] = mathToScreen(P[0], P[1]);
                ctx.fillStyle = '#4ade80';
                ctx.beginPath();
                ctx.arc(px, py, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('P', px, py + 5);
            }

            // Draw Q
            if (Q) {
                const [qx, qy] = mathToScreen(Q[0], Q[1]);
                ctx.fillStyle = '#60a5fa';
                ctx.beginPath();
                ctx.arc(qx, qy, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Q', qx, qy + 5);
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;
            const [mx, my] = screenToMath(sx, sy);

            const point = findClosestPointOnCurve(mx, my);
            if (point && Math.hypot(point[0] - mx, point[1] - my) < 0.5) {
                if (!P) {
                    P = point;
                    document.getElementById('pointP').textContent =
                        `(${P[0].toFixed(3)}, ${P[1].toFixed(3)})`;
                } else if (!Q) {
                    Q = point;
                    document.getElementById('pointQ').textContent =
                        `(${Q[0].toFixed(3)}, ${Q[1].toFixed(3)})`;
                }
                draw();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            P = null; Q = null; R = null;
            animating = false;
            animProgress = 0;
            document.getElementById('pointP').textContent = 'Not set';
            document.getElementById('pointQ').textContent = 'Not set';
            document.getElementById('pointR').textContent = '-';
            draw();
        });

        document.getElementById('animateBtn').addEventListener('click', () => {
            if (P && Q) {
                animating = true;
                animProgress = 0;

                function animate() {
                    animProgress += 0.02;
                    draw();
                    if (animProgress < 1.2) {
                        requestAnimationFrame(animate);
                    } else {
                        animating = false;
                    }
                }
                animate();
            }
        });

        draw();
    </script>
</body>
</html>
