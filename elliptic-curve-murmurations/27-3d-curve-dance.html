<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Curve Dance | CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
        }
        canvas { display: block; }
        .overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            max-width: 280px;
        }
        h1 {
            font-size: 1.2rem;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 16px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: block;
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 4px;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        .legend {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.75rem;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .info {
            margin-top: 12px;
            font-size: 0.7rem;
            color: #666;
            line-height: 1.4;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #667eea;
            text-decoration: none;
            font-size: 0.9rem;
            font-family: 'Segoe UI', system-ui, sans-serif;
            opacity: 0.8;
        }
        .back-link:hover { opacity: 1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="overlay">
        <h1>3D Curve Dance</h1>
        <p class="subtitle">Elliptic curves dancing in 3D space</p>

        <div class="control-group">
            <label>Rotation Speed</label>
            <input type="range" id="rotSpeed" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Curve Count</label>
            <input type="range" id="curveCount" min="5" max="30" value="15">
        </div>

        <div class="control-group">
            <label>Wave Amplitude</label>
            <input type="range" id="amplitude" min="0.2" max="2" step="0.1" value="1">
        </div>

        <div class="control-group">
            <label>Depth</label>
            <input type="range" id="depth" min="0.5" max="3" step="0.1" value="1.5">
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #4ade80"></div>
                <span>Rank 0 curves</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #60a5fa"></div>
                <span>Rank 1 curves</span>
            </div>
        </div>

        <div class="info">
            Multiple elliptic curves rotate through space, their parameters modulated by murmuration wave patterns. Drag to rotate view.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let rotX = 0.3, rotY = 0, rotZ = 0;
        let rotSpeed = 0.5;
        let curveCount = 15;
        let amplitude = 1;
        let depthFactor = 1.5;
        let time = 0;

        let isDragging = false;
        let lastX, lastY;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resize();
        window.addEventListener('resize', resize);

        function project(x, y, z) {
            // Rotate
            const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY), sinY = Math.sin(rotY);

            let y1 = y * cosX - z * sinX;
            let z1 = y * sinX + z * cosX;
            let x1 = x * cosY + z1 * sinY;
            let z2 = -x * sinY + z1 * cosY;

            // Perspective
            const scale = 200 / (3 + z2 * depthFactor);
            return {
                x: width / 2 + x1 * scale,
                y: height / 2 + y1 * scale,
                z: z2,
                scale: scale
            };
        }

        function generateCurvePoints(A, B, zOffset) {
            const points = [];
            const resolution = 100;

            for (let i = 0; i < resolution; i++) {
                const t = (i / resolution - 0.5) * 4;
                const rhs = t * t * t + A * t + B;

                if (rhs >= 0) {
                    const y = Math.sqrt(rhs);
                    points.push({ x: t, y: y, z: zOffset });
                    points.push({ x: t, y: -y, z: zOffset });
                }
            }

            return points;
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Auto rotate
            rotY += 0.005 * rotSpeed;

            // Generate curves with murmuration-modulated parameters
            const curves = [];

            for (let i = 0; i < curveCount; i++) {
                const t = i / curveCount;
                const phase = time * 0.02 + t * Math.PI * 2;
                const isRank0 = i % 2 === 0;

                // Murmuration wave modulates curve parameters
                const decay = Math.exp(-Math.abs(t - 0.5) * 2);
                const wave = amplitude * (
                    0.5 * Math.sin(phase * 2) +
                    0.3 * Math.sin(phase * 3)
                ) * decay;

                const A = -1 + wave * (isRank0 ? 1 : -1);
                const B = 1 + wave * 0.5 * (isRank0 ? 1 : -1);
                const z = (t - 0.5) * 4;

                const points = generateCurvePoints(A, B, z);
                curves.push({
                    points,
                    isRank0,
                    z: z + Math.sin(phase) * 0.5
                });
            }

            // Sort by z for proper depth ordering
            curves.sort((a, b) => b.z - a.z);

            // Draw curves
            curves.forEach(curve => {
                const projected = curve.points.map(p => project(p.x, p.y, p.z));

                const color = curve.isRank0 ? [74, 222, 128] : [96, 165, 250];
                const alpha = 0.3 + (1 - (curve.z + 2) / 4) * 0.5;

                // Sort points by x for proper line drawing
                const upper = projected.filter((_, i) => curve.points[i]?.y >= 0)
                    .sort((a, b) => curve.points[projected.indexOf(a)]?.x - curve.points[projected.indexOf(b)]?.x);
                const lower = projected.filter((_, i) => curve.points[i]?.y < 0)
                    .sort((a, b) => curve.points[projected.indexOf(a)]?.x - curve.points[projected.indexOf(b)]?.x);

                [upper, lower].forEach(branch => {
                    if (branch.length < 2) return;

                    ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
                    ctx.lineWidth = 2 * (0.5 + alpha);
                    ctx.beginPath();

                    branch.forEach((p, idx) => {
                        if (idx === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    });
                    ctx.stroke();
                });
            });

            // Draw central axis glow
            const gradient = ctx.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, 300
            );
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.1)');
            gradient.addColorStop(1, 'rgba(102, 126, 234, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, 300, 0, Math.PI * 2);
            ctx.fill();

            time++;
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;

                rotY += dx * 0.01;
                rotX += dy * 0.01;

                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        document.getElementById('rotSpeed').addEventListener('input', (e) => {
            rotSpeed = parseFloat(e.target.value);
        });

        document.getElementById('curveCount').addEventListener('input', (e) => {
            curveCount = parseInt(e.target.value);
        });

        document.getElementById('amplitude').addEventListener('input', (e) => {
            amplitude = parseFloat(e.target.value);
        });

        document.getElementById('depth').addEventListener('input', (e) => {
            depthFactor = parseFloat(e.target.value);
        });

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
