<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Complete History of Computational Visualizations and Simulations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --dark: #1a1a2e;
            --light: #f8f9fa;
            --accent: #f97316;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            line-height: 1.7;
            color: var(--dark);
            background: var(--light);
            overflow-x: hidden;
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.1;
            pointer-events: none;
        }

        .hero h1 {
            font-size: clamp(2rem, 5vw, 4rem);
            font-weight: 800;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .hero-subtitle {
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            text-align: center;
            max-width: 900px;
            margin-bottom: 2rem;
            opacity: 0.95;
            z-index: 1;
        }

        .hero-meta {
            font-size: 1rem;
            opacity: 0.8;
            text-align: center;
            z-index: 1;
        }

        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
            z-index: 1;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-10px); }
            60% { transform: translateX(-50%) translateY(-5px); }
        }

        /* Timeline */
        .timeline {
            background: white;
            padding: 4rem 2rem;
        }

        .timeline-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .timeline h2 {
            text-align: center;
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 3rem;
        }

        #timeline-canvas {
            width: 100%;
            height: 400px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        /* Content Sections */
        .section {
            min-height: 100vh;
            padding: 4rem 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .section:nth-child(even) {
            background: white;
        }

        .section:nth-child(odd) {
            background: var(--light);
        }

        .section-content {
            max-width: 1400px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4rem;
            align-items: center;
        }

        .section-text h2 {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .section-text h3 {
            font-size: 1.8rem;
            color: var(--secondary);
            margin: 2rem 0 1rem;
        }

        .section-text p {
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            color: #333;
        }

        .section-text strong {
            color: var(--primary);
        }

        .section-text em {
            color: var(--secondary);
        }

        .section-viz {
            position: sticky;
            top: 2rem;
        }

        .viz-container {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        .viz-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 1rem;
            text-align: center;
        }

        .viz-canvas {
            width: 100%;
            border-radius: 10px;
            background: #000;
            display: block;
        }

        .viz-controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .viz-controls button, .viz-controls select {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 5px;
            background: var(--primary);
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .viz-controls button:hover {
            background: var(--secondary);
        }

        .viz-controls select {
            background: white;
            color: var(--dark);
            border: 2px solid var(--primary);
        }

        .viz-caption {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #666;
            text-align: center;
            font-style: italic;
        }

        /* Full Width Sections */
        .section-full {
            min-height: 100vh;
            padding: 4rem 2rem;
        }

        .section-full .section-content {
            grid-template-columns: 1fr;
            max-width: 1600px;
        }

        /* References */
        .references {
            background: var(--dark);
            color: white;
            padding: 4rem 2rem;
        }

        .references-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .references h2 {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 2rem;
        }

        .ref-category {
            margin-bottom: 2rem;
        }

        .ref-category h3 {
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .ref-category ul {
            list-style: none;
            padding-left: 1rem;
        }

        .ref-category li {
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }

        .ref-category li::before {
            content: "→ ";
            color: var(--primary);
            margin-right: 0.5rem;
        }

        /* Back to Top */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.3s, background 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .back-to-top.visible {
            opacity: 1;
        }

        .back-to-top:hover {
            background: var(--secondary);
        }

        /* Responsive */
        @media (max-width: 968px) {
            .section-content {
                grid-template-columns: 1fr;
                gap: 2rem;
            }

            .section-viz {
                position: relative;
                top: 0;
            }

            .section-text h2 {
                font-size: 2rem;
            }

            .section-text h3 {
                font-size: 1.5rem;
            }
        }

        /* Loading indicator */
        .loading {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <!-- Hero Section -->
    <div class="hero">
        <canvas id="hero-canvas"></canvas>
        <h1>The Complete History of Computational Visualizations and Simulations</h1>
        <p class="hero-subtitle">From Turing's morphogenesis to modern WebGL: How simple rules generate complex beauty</p>
        <div class="hero-meta">A visual journey through 75 years of computational science</div>
        <div class="scroll-indicator">↓</div>
    </div>

    <!-- Interactive Timeline -->
    <div class="timeline">
        <div class="timeline-container">
            <h2>Timeline of Computational Discoveries</h2>
            <canvas id="timeline-canvas"></canvas>
        </div>
    </div>

    <!-- Section 1: Introduction -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>From Theory to Interactive Reality</h2>
                <p>The evolution of computational science from simple automata to complex systems modeling represents one of the most profound intellectual achievements of the 20th century. Beginning with <strong>Alan Turing's 1952 morphogenesis paper</strong> and <strong>John von Neumann's self-replicating automata</strong>, computational visualizations transformed from theoretical curiosities into essential tools spanning biology, physics, sociology, and computer graphics.</p>
                <p>These simulations became canonical educational examples because they demonstrated <em>emergence</em>—how simple local rules generate complex global behavior—while remaining accessible enough for students to implement and explore.</p>
                <p>From Conway's Game of Life running on 1970 minicomputers to today's browser-based WebGL simulations, this democratization of computational tools enabled millions to experience firsthand the mathematical principles underlying natural phenomena.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Conway's Game of Life (1970)</div>
                    <canvas id="life-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <button onclick="lifeReset()">Reset</button>
                        <button onclick="lifeRandomize()">Randomize</button>
                        <button onclick="lifeTogglePlay()">Play/Pause</button>
                        <button onclick="lifeStep()">Step</button>
                    </div>
                    <div class="viz-caption">Click cells to toggle. Three rules: survive with 2-3 neighbors, birth with 3, death otherwise.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 2: Theoretical Foundations -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Theoretical Biology to Visual Computing</h2>
                <h3>Von Neumann & Ulam (1940s-1950s)</h3>
                <p><strong>John von Neumann</strong> and <strong>Stanisław Ulam</strong> at Los Alamos pioneered cellular automata while investigating self-replicating machines. Von Neumann's 1966 posthumous publication <em>"Theory of Self-Reproducing Automata"</em> established the theoretical framework.</p>

                <h3>Turing's Morphogenesis (1952)</h3>
                <p><strong>Alan Turing's</strong> paper <em>"The Chemical Basis of Morphogenesis"</em> proposed that two diffusing chemicals (morphogens) with different diffusion rates could spontaneously generate patterns from uniform states. These works remained largely dormant until computing power advanced in the 1960s-1970s.</p>

                <h3>Conway's Breakthrough (1970)</h3>
                <p>The breakthrough came with <strong>John Horton Conway's Game of Life</strong>, popularized by Martin Gardner's Scientific American column. Bill Gosper's discovery of the glider gun proved unlimited growth possible and established Life's Turing completeness.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Wolfram's Elementary Cellular Automata</div>
                    <canvas id="wolfram-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <select id="rule-select" onchange="wolframChangeRule()">
                            <option value="30">Rule 30 (Random)</option>
                            <option value="110">Rule 110 (Turing Complete)</option>
                            <option value="90">Rule 90 (Sierpinski)</option>
                            <option value="184">Rule 184 (Traffic)</option>
                        </select>
                        <button onclick="wolframReset()">Reset</button>
                    </div>
                    <div class="viz-caption">Stephen Wolfram classified all 256 elementary CA rules into 4 classes (1983)</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 3: Chaos Theory -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Chaos Theory Reveals Fundamental Limits</h2>
                <h3>Lorenz's Discovery (1961-1963)</h3>
                <p><strong>Edward Lorenz</strong> discovered sensitive dependence on initial conditions in winter 1961 when rounding .506127 to .506 produced drastically different weather simulations on his Royal McBee computer.</p>
                <p>His 1963 paper <em>"Deterministic Nonperiodic Flow"</em> introduced the <strong>Lorenz attractor</strong>—three differential equations with parameters σ=10, ρ=28, β=8/3 creating a butterfly-shaped attractor in 3D phase space.</p>

                <h3>The Butterfly Effect</h3>
                <p>His 1972 talk <em>"Predictability: Does the Flap of a Butterfly's Wings in Brazil Set Off a Tornado in Texas?"</em> popularized the "butterfly effect"—demonstrating how determinism doesn't imply predictability.</p>

                <h3>Universal Constants</h3>
                <p><strong>Mitchell Feigenbaum</strong> discovered the universal period-doubling route to chaos using an HP-65 calculator, calculating his constant δ ≈ 4.669 appearing across different chaotic systems.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Lorenz Attractor (1963)</div>
                    <canvas id="lorenz-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <button onclick="lorenzReset()">Reset</button>
                        <button onclick="lorenzTogglePlay()">Play/Pause</button>
                    </div>
                    <div class="viz-caption">The iconic butterfly-shaped strange attractor demonstrating deterministic chaos</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 4: Reaction-Diffusion -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Chemical Reactions Generate Biological Patterns</h2>
                <h3>Belousov-Zhabotinsky Reaction (1951-1964)</h3>
                <p><strong>Boris Belousov</strong> discovered oscillating chemical reactions in 1951, but journal editors rejected his submissions claiming the phenomenon "theoretically impossible." <strong>Anatoly Zhabotinsky</strong> refined the reaction in 1964, creating the widely-used BZ reaction.</p>

                <h3>Gray-Scott Model (1983-1985)</h3>
                <p>P. Gray and S.K. Scott developed their reaction-diffusion model describing autocatalytic reaction U + 2V → 3V with feed rate F and kill rate k parameters. Different F-k combinations produce vastly different behaviors.</p>

                <h3>Turing Patterns in Nature</h3>
                <p><strong>Shigeru Kondo's</strong> 2006+ zebrafish research demonstrated that three pigment cell types interact through short-range repulsion and long-range attraction, confirming Turing-like pattern formation at cellular level.</p>
                <p>Applications extend to hair follicle distribution, palate ridges, lymphatic vessels, and plant phyllotaxis.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Gray-Scott Reaction-Diffusion</div>
                    <canvas id="grayscott-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <select id="pattern-select" onchange="grayScottChangePattern()">
                            <option value="spots">Spots</option>
                            <option value="stripes">Stripes</option>
                            <option value="waves">Waves</option>
                            <option value="coral">Coral</option>
                        </select>
                        <button onclick="grayScottReset()">Reset</button>
                    </div>
                    <div class="viz-caption">Self-replicating spots, coral growth, mazes emerge from simple chemistry</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 5: Agent-Based Modeling -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Agent-Based Modeling Transforms Social Science</h2>
                <h3>Schelling's Segregation (1971)</h3>
                <p><strong>Thomas Schelling's</strong> segregation model demonstrated how mild individual preferences for same-group neighbors (30-50% tolerance) produce extreme macro-level segregation. Using just coins and graph paper, Schelling created a foundational model for understanding emergent social phenomena, contributing to his 2005 Nobel Prize in Economics.</p>

                <h3>Reynolds' Boids (1987)</h3>
                <p><strong>Craig Reynolds</strong> revolutionized computer animation with boids at SIGGRAPH 1987. His three steering behaviors—<strong>separation</strong> (avoid crowding), <strong>alignment</strong> (match neighbors' heading), and <strong>cohesion</strong> (move toward neighbors' center)—produced realistic flocking from local rules alone.</p>
                <p>First demonstrated in "Stanley and Stella in: Breaking the Ice" (1987), boids made their feature film debut in Tim Burton's "Batman Returns" (1992). Reynolds received an Academy Award for technical achievement in 1998.</p>

                <h3>Sugarscape (1996)</h3>
                <p>Joshua Epstein and Robert Axtell's <em>Sugarscape</em> model featured agents with vision, metabolism, and lifespan competing for resources, demonstrating emergence of wealth distributions, market formation, and population dynamics.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Boids Flocking Simulation (1987)</div>
                    <canvas id="boids-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <button onclick="boidsReset()">Reset</button>
                        <button onclick="boidsAddPredator()">Add Predator</button>
                    </div>
                    <div class="viz-caption">Three simple rules create realistic flocking behavior</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 6: Fractals -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Fractals Bridge Mathematics and Nature</h2>
                <h3>Mandelbrot's Vision (1980)</h3>
                <p><strong>Benoit Mandelbrot</strong> first visualized the Mandelbrot set on March 1, 1980 at IBM's Watson Research Center using computer graphics. His 1982 masterwork <em>"The Fractal Geometry of Nature"</em> made fractals accessible worldwide.</p>
                <p>The Mandelbrot set M = {c ∈ ℂ : sequence z₀=0, z_{n+1}=z_n² + c remains bounded} exhibits uncountable complexity with infinitely many self-similar miniature copies.</p>

                <h3>Julia Sets (1918-1980)</h3>
                <p><strong>Gaston Julia's</strong> 1918 masterpiece remained forgotten until Mandelbrot's 1970s revival. Each point in the Mandelbrot set corresponds to a different Julia set—connected inside M, disconnected "Cantor dust" outside.</p>

                <h3>Public Engagement</h3>
                <p>Scientific American's August 1985 cover article introduced the algorithm to home computer users, triggering widespread public engagement. The visual beauty—infinite complexity from simple equations—combined with accessibility through personal computers democratized fractal exploration.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Mandelbrot Set Explorer</div>
                    <canvas id="mandelbrot-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <button onclick="mandelbrotReset()">Reset View</button>
                        <button onclick="mandelbrotZoomIn()">Zoom In</button>
                        <button onclick="mandelbrotZoomOut()">Zoom Out</button>
                    </div>
                    <div class="viz-caption">Click to zoom. Infinite detail from z_{n+1} = z_n² + c</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 7: L-Systems -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>L-Systems Model Plant Growth Algorithmically</h2>
                <h3>Lindenmayer's Breakthrough (1968)</h3>
                <p><strong>Aristid Lindenmayer's</strong> 1968 papers in Journal of Theoretical Biology introduced L-systems for modeling filamentous organisms. The Hungarian theoretical biologist developed parallel rewriting systems where productions apply simultaneously—matching biological reality of multiple cell divisions.</p>

                <h3>Prusinkiewicz's Visualization (1980s-1990)</h3>
                <p><strong>Przemyslaw Prusinkiewicz</strong> transformed L-systems into practical computer graphics tools using turtle interpretation methods. His 1990 book <em>"The Algorithmic Beauty of Plants"</em> became the field's seminal reference.</p>

                <h3>Extensions and Applications</h3>
                <p><strong>Parametric L-systems</strong> model growth rates, <strong>stochastic L-systems</strong> add variation, and <strong>context-sensitive L-systems</strong> simulate signal propagation. Applications extend to music composition, urban planning, procedural game content, and computer graphics.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">L-System Plant Growth</div>
                    <canvas id="lsystem-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <select id="lsystem-select" onchange="lsystemChange()">
                            <option value="tree">Tree</option>
                            <option value="bush">Bush</option>
                            <option value="fern">Fern</option>
                            <option value="weed">Weed</option>
                        </select>
                        <button onclick="lsystemGrow()">Grow</button>
                        <button onclick="lsystemReset()">Reset</button>
                    </div>
                    <div class="viz-caption">Parallel string rewriting creates realistic plant morphology</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 8: Networks -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Networks Reveal Universal Organizational Principles</h2>
                <h3>Small-World Networks (1998)</h3>
                <p><strong>Duncan Watts</strong> and <strong>Steven Strogatz's</strong> June 1998 Nature paper resolved the dichotomy between regular and random networks. For intermediate rewiring probability, networks exhibit short path lengths (like random graphs) while maintaining high clustering (like regular lattices).</p>
                <p>Validation using C. elegans neural networks, Western US power grid, and film actor collaborations demonstrated universality across biological, technological, and social domains.</p>

                <h3>Scale-Free Networks (1999)</h3>
                <p><strong>Albert-László Barabási</strong> and <strong>Réka Albert's</strong> October 1999 Science paper established scale-free networks through growth and preferential attachment. Their model produces power-law degree distribution with natural emergence of "hubs."</p>

                <h3>Epidemic Modeling</h3>
                <p>The <strong>SIR model</strong> (Kermack & McKendrick, 1927) divided populations into Susceptible, Infectious, and Recovered compartments. Network-based implementations revealed how topology critically affects epidemic dynamics.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Network Evolution & Epidemics</div>
                    <canvas id="network-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <select id="network-type" onchange="networkChangeType()">
                            <option value="smallworld">Small-World</option>
                            <option value="scalefree">Scale-Free</option>
                            <option value="sir">SIR Epidemic</option>
                        </select>
                        <button onclick="networkReset()">Reset</button>
                    </div>
                    <div class="viz-caption">Six degrees of separation and preferential attachment</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 9: Swarm Intelligence -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Swarm Intelligence: From Biology to Algorithms</h2>
                <h3>Ant Colony Optimization (1992)</h3>
                <p><strong>Marco Dorigo's</strong> PhD thesis translated ant foraging behavior into computational algorithms. Inspired by experiments on Argentine ants finding shortest paths using pheromone trails, ACO features artificial ants depositing pheromone with evaporation and probabilistic selection.</p>
                <p>Applications span traveling salesman problems, vehicle routing, network routing, scheduling, and protein folding.</p>

                <h3>Particle Swarm Optimization (1995)</h3>
                <p><strong>James Kennedy</strong> (social psychologist) and <strong>Russell Eberhart</strong> (electrical engineer) created PSO from simulations of bird flocks searching for food. Particles move through search space tracking personal best and global best positions.</p>

                <h3>Langton's Ant (1986)</h3>
                <p><strong>Christopher Langton's</strong> Ant follows two rules: on white squares turn right and flip color, on black squares turn left and flip color. After ~10,000 steps of chaos, the ant spontaneously constructs a repeating 104-step "highway" pattern.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Langton's Ant (1986)</div>
                    <canvas id="ant-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <button onclick="antReset()">Reset</button>
                        <button onclick="antTogglePlay()">Play/Pause</button>
                        <button onclick="antFast()">Fast Forward</button>
                    </div>
                    <div class="viz-caption">Two rules produce 10,000 steps of chaos, then infinite highway</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 10: Evolutionary Algorithms -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Evolutionary Algorithms Optimize Through Natural Selection</h2>
                <h3>Genetic Algorithms (1975)</h3>
                <p><strong>John Holland's</strong> book <em>"Adaptation in Natural and Artificial Systems"</em> introduced genetic algorithms as mathematical idealizations of adaptive systems. Populations of chromosomes (bit strings) undergo artificial selection through crossover, mutation, and reproduction.</p>
                <p>Holland's <strong>Schema Theorem</strong> explains "implicit parallelism" where GAs process ~n³ schemas with n individuals.</p>

                <h3>Evolution Strategies (1963+)</h3>
                <p><strong>Ingo Rechenberg</strong> and <strong>Hans-Paul Schwefel</strong> developed evolution strategies from wind tunnel optimization. Classical gradient methods failed on noisy data, inspiring random mutations following biological principles.</p>

                <h3>Genetic Programming (1992)</h3>
                <p><strong>John Koza's</strong> genetic programming extends GAs where structures are computer programs themselves using tree-based representations. The NASA ST5 spacecraft antenna was designed using genetic algorithms, flying on the 2006 mission.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Genetic Algorithm Evolution</div>
                    <canvas id="genetic-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-controls">
                        <button onclick="geneticReset()">New Population</button>
                        <button onclick="geneticEvolve()">Evolve Generation</button>
                        <button onclick="geneticTogglePlay()">Auto-Evolve</button>
                    </div>
                    <div class="viz-caption">Population evolves toward target through selection, crossover, mutation</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 11: Visualization Technologies -->
    <div class="section">
        <div class="section-content">
            <div class="section-text">
                <h2>Visualization Technologies Democratize Computational Science</h2>
                <h3>Sketchpad (1963)</h3>
                <p><strong>Ivan Sutherland's</strong> Sketchpad pioneered interactive computer graphics as his MIT PhD thesis. Featuring real-time drawing, object manipulation, geometric constraints, and the first GUI, Sutherland became "Father of Computer Graphics" (1988 Turing Award).</p>

                <h3>OpenGL (1992)</h3>
                <p>Silicon Graphics released <strong>OpenGL</strong> as cross-platform graphics standard. OpenGL 2.0 (2004) introduced programmable shaders (GLSL), moving graphics from fixed to programmable pipelines.</p>

                <h3>Three.js (2010)</h3>
                <p><strong>Ricardo Cabello (Mr.doob)</strong> released Three.js, built on WebGL to abstract complexity. Used by Google, NYTimes, Airbnb, and MTV, Three.js enabled browser-based 3D without plugins.</p>

                <h3>WebGL & WebAssembly (2011-2017)</h3>
                <p><strong>WebGL</strong> (2011) provides GPU-accelerated graphics in browsers. <strong>WebAssembly</strong> (2017) achieves near-native performance, enabling high-performance web computations and scientific simulations.</p>
            </div>
            <div class="section-viz">
                <div class="viz-container">
                    <div class="viz-title">Technology Evolution Timeline</div>
                    <canvas id="tech-timeline-canvas" class="viz-canvas" width="600" height="600"></canvas>
                    <div class="viz-caption">From million-dollar mainframes to free browser-based tools</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 12: Conclusion -->
    <div class="section-full">
        <div class="section-content">
            <div class="section-text">
                <h2>Why These Visualizations Became Canonical</h2>
                <p>These computational visualizations achieved canonical status through converging factors transcending individual technical merit:</p>

                <h3>Pedagogical Accessibility</h3>
                <p>Game of Life's three rules, Schelling's segregation with coins on paper, and boids' three steering laws provided intuitive entry points requiring minimal mathematical sophistication. Students could implement these in single programming sessions while exploring enough depth for advanced research.</p>

                <h3>Historical Timing</h3>
                <p>Conway's Life appeared precisely when 1970 minicomputers enabled overnight simulations. NetLogo's 1999 release coincided with classroom computing becoming standard. WebGL's 2011 specification arrived as JavaScript performance enabled sophisticated browser applications. Each breakthrough lowered entry barriers.</p>

                <h3>Visual Appeal and Emergence</h3>
                <p>Mandelbrot set's infinite detail, Lorenz attractor's butterfly wings, reaction-diffusion's organic patterns, and double pendulum's chaotic paths provided aesthetic hooks capturing imagination beyond technical audiences. The gap between simple rules and complex outcomes—<strong>emergence</strong>—became directly observable.</p>

                <h3>Interdisciplinary Relevance</h3>
                <p>Turing patterns explain zebrafish stripes and seashells, evolutionary algorithms optimize NASA antennas and financial portfolios, network models apply to neural connectivity and epidemic spread, L-systems generate plant morphology and game levels. Single implementations teach transferable principles across domains.</p>

                <h3>Open-Source Culture</h3>
                <p>Processing, NetLogo, D3.js, Three.js, and most frameworks provide free access with extensive documentation and active communities. The 600+ NetLogo models, thousands of Processing sketches, and abundant D3 examples created scaffolding enabling progressive mastery.</p>

                <h3>Convergence Enables Modern Education</h3>
                <p>A 2025 student with browser access can implement Conway's Life, visualize Lorenz attractors, simulate disease spread on networks, evolve L-system plants, and animate boids flocking—activities requiring million-dollar equipment decades ago.</p>
                <p>The <strong>10,000× cost reduction</strong> and accessibility transformation from 1970s minicomputers to modern browsers fundamentally changed computational science education from elite specialization to universal access.</p>

                <h3>Continuing Importance</h3>
                <p>Modern research employs these same principles: COVID-19 modeling uses SEIR on networks, climate science applies CFD, neuroscience analyzes brain networks, synthetic biology engineers L-system-like gene circuits, and AI training uses evolutionary algorithms.</p>
                <p>Educational tools became research instruments, and research advances continue feeding back into refined educational implementations—a virtuous cycle where accessibility enhances understanding, enabling innovation, producing more powerful yet accessible tools for the next generation.</p>
            </div>
        </div>
    </div>

    <!-- References Section -->
    <div class="references">
        <div class="references-content">
            <h2>Key References & Milestones</h2>

            <div class="ref-category">
                <h3>Foundational Papers</h3>
                <ul>
                    <li>Turing, A. M. (1952). "The Chemical Basis of Morphogenesis" - Philosophical Transactions B</li>
                    <li>Von Neumann, J. (1966). "Theory of Self-Reproducing Automata" - University of Illinois Press</li>
                    <li>Gardner, M. (1970). "Mathematical Games: The fantastic combinations of John Conway's new solitaire game 'life'" - Scientific American</li>
                    <li>Wolfram, S. (1983). "Statistical Mechanics of Cellular Automata" - Reviews of Modern Physics</li>
                    <li>Lorenz, E. N. (1963). "Deterministic Nonperiodic Flow" - Journal of the Atmospheric Sciences</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Agent-Based Modeling</h3>
                <ul>
                    <li>Schelling, T. C. (1971). "Dynamic Models of Segregation" - Journal of Mathematical Sociology</li>
                    <li>Reynolds, C. W. (1987). "Flocks, Herds, and Schools: A Distributed Behavioral Model" - SIGGRAPH</li>
                    <li>Epstein, J. M. & Axtell, R. (1996). "Growing Artificial Societies" - MIT Press</li>
                    <li>Wilensky, U. (1999). NetLogo - Northwestern University</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Pattern Formation</h3>
                <ul>
                    <li>Gray, P. & Scott, S. K. (1985). "Autocatalytic reactions in the isothermal, continuous stirred tank reactor" - Chemical Engineering Science</li>
                    <li>Pearson, J. E. (1993). "Complex Patterns in a Simple System" - Science</li>
                    <li>Kondo, S. & Miura, T. (2010). "Reaction-Diffusion Model as a Framework for Understanding Biological Pattern Formation" - Science</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Fractals & Chaos</h3>
                <ul>
                    <li>Mandelbrot, B. B. (1982). "The Fractal Geometry of Nature" - W. H. Freeman</li>
                    <li>Dewdney, A. K. (1985). "Computer Recreations: A computer microscope zooms in for a look at the most complex object in mathematics" - Scientific American</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Networks & Complexity</h3>
                <ul>
                    <li>Watts, D. J. & Strogatz, S. H. (1998). "Collective dynamics of 'small-world' networks" - Nature</li>
                    <li>Barabási, A.-L. & Albert, R. (1999). "Emergence of scaling in random networks" - Science</li>
                    <li>Kermack, W. O. & McKendrick, A. G. (1927). "A contribution to the mathematical theory of epidemics" - Proceedings of the Royal Society A</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Evolutionary Computation</h3>
                <ul>
                    <li>Holland, J. H. (1975). "Adaptation in Natural and Artificial Systems" - University of Michigan Press</li>
                    <li>Dorigo, M. (1992). "Optimization, Learning and Natural Algorithms" - PhD Thesis, Politecnico di Milano</li>
                    <li>Kennedy, J. & Eberhart, R. (1995). "Particle Swarm Optimization" - IEEE International Conference on Neural Networks</li>
                    <li>Koza, J. R. (1992). "Genetic Programming" - MIT Press</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>L-Systems & Procedural Generation</h3>
                <ul>
                    <li>Lindenmayer, A. (1968). "Mathematical models for cellular interactions in development" - Journal of Theoretical Biology</li>
                    <li>Prusinkiewicz, P. & Lindenmayer, A. (1990). "The Algorithmic Beauty of Plants" - Springer-Verlag</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Visualization Technologies</h3>
                <ul>
                    <li>Sutherland, I. E. (1963). "Sketchpad: A Man-Machine Graphical Communication System" - MIT PhD Thesis</li>
                    <li>Stam, J. (1999). "Stable Fluids" - SIGGRAPH</li>
                    <li>Bostock, M., Ogievetsky, V., & Heer, J. (2011). "D³: Data-Driven Documents" - IEEE InfoVis</li>
                    <li>Cabello, R. (2010). Three.js - GitHub</li>
                </ul>
            </div>

            <div class="ref-category">
                <h3>Artificial Life</h3>
                <ul>
                    <li>Langton, C. G. (1986). "Studying Artificial Life with Cellular Automata" - Physica D</li>
                    <li>Ray, T. S. (1991). "An Approach to the Synthesis of Life" - Artificial Life II</li>
                    <li>Bonabeau, E., Dorigo, M., & Theraulaz, G. (1999). "Swarm Intelligence" - Oxford University Press</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Back to Top Button -->
    <button class="back-to-top" onclick="scrollToTop()">↑</button>

    <script>
        // ============================================
        // UTILITIES
        // ============================================
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Show/hide back to top button
        window.addEventListener('scroll', () => {
            const button = document.querySelector('.back-to-top');
            if (window.scrollY > 500) {
                button.classList.add('visible');
            } else {
                button.classList.remove('visible');
            }
        });

        // ============================================
        // HERO CANVAS - Particle System
        // ============================================
        const heroCanvas = document.getElementById('hero-canvas');
        const heroCtx = heroCanvas.getContext('2d');

        function resizeHeroCanvas() {
            heroCanvas.width = heroCanvas.offsetWidth;
            heroCanvas.height = heroCanvas.offsetHeight;
        }
        resizeHeroCanvas();
        window.addEventListener('resize', resizeHeroCanvas);

        const heroParticles = [];
        for (let i = 0; i < 100; i++) {
            heroParticles.push({
                x: Math.random() * heroCanvas.width,
                y: Math.random() * heroCanvas.height,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                radius: Math.random() * 2 + 1
            });
        }

        function animateHero() {
            heroCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            heroCtx.fillRect(0, 0, heroCanvas.width, heroCanvas.height);

            heroParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;

                if (p.x < 0 || p.x > heroCanvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > heroCanvas.height) p.vy *= -1;

                heroCtx.beginPath();
                heroCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                heroCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                heroCtx.fill();
            });

            // Draw connections
            heroParticles.forEach((p1, i) => {
                heroParticles.slice(i + 1).forEach(p2 => {
                    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    if (dist < 100) {
                        heroCtx.beginPath();
                        heroCtx.moveTo(p1.x, p1.y);
                        heroCtx.lineTo(p2.x, p2.y);
                        heroCtx.strokeStyle = `rgba(255, 255, 255, ${0.2 * (1 - dist / 100)})`;
                        heroCtx.lineWidth = 0.5;
                        heroCtx.stroke();
                    }
                });
            });

            requestAnimationFrame(animateHero);
        }
        animateHero();

        // ============================================
        // TIMELINE CANVAS
        // ============================================
        const timelineCanvas = document.getElementById('timeline-canvas');
        const timelineCtx = timelineCanvas.getContext('2d');

        function resizeTimelineCanvas() {
            timelineCanvas.width = timelineCanvas.offsetWidth;
            timelineCanvas.height = 400;
            if (typeof drawTimeline === 'function') drawTimeline();
        }
        window.addEventListener('resize', resizeTimelineCanvas);

        const milestones = [
            { year: 1952, label: "Turing's Morphogenesis", color: "#667eea" },
            { year: 1963, label: "Lorenz Attractor", color: "#764ba2" },
            { year: 1966, label: "Von Neumann Automata", color: "#667eea" },
            { year: 1968, label: "L-Systems", color: "#f97316" },
            { year: 1970, label: "Conway's Life", color: "#667eea" },
            { year: 1971, label: "Schelling Model", color: "#764ba2" },
            { year: 1975, label: "Genetic Algorithms", color: "#f97316" },
            { year: 1980, label: "Mandelbrot Set", color: "#667eea" },
            { year: 1983, label: "Wolfram CA", color: "#764ba2" },
            { year: 1986, label: "Langton's Ant", color: "#f97316" },
            { year: 1987, label: "Boids", color: "#667eea" },
            { year: 1990, label: "Algorithmic Plants", color: "#764ba2" },
            { year: 1992, label: "OpenGL", color: "#f97316" },
            { year: 1993, label: "Gray-Scott", color: "#667eea" },
            { year: 1996, label: "Sugarscape", color: "#764ba2" },
            { year: 1998, label: "Small-World Networks", color: "#f97316" },
            { year: 1999, label: "Scale-Free Networks", color: "#667eea" },
            { year: 1999, label: "NetLogo", color: "#764ba2" },
            { year: 2010, label: "Three.js", color: "#f97316" },
            { year: 2011, label: "WebGL", color: "#667eea" },
            { year: 2017, label: "WebAssembly", color: "#764ba2" }
        ];

        function drawTimeline() {
            const w = timelineCanvas.width;
            const h = timelineCanvas.height;
            const padding = 40;
            const minYear = 1950;
            const maxYear = 2020;

            timelineCtx.clearRect(0, 0, w, h);

            // Draw timeline axis
            const y = h / 2;
            timelineCtx.beginPath();
            timelineCtx.moveTo(padding, y);
            timelineCtx.lineTo(w - padding, y);
            timelineCtx.strokeStyle = '#667eea';
            timelineCtx.lineWidth = 3;
            timelineCtx.stroke();

            // Draw milestones
            milestones.forEach((m, i) => {
                const x = padding + ((m.year - minYear) / (maxYear - minYear)) * (w - 2 * padding);
                const offset = (i % 2 === 0) ? -80 : 80;

                // Line
                timelineCtx.beginPath();
                timelineCtx.moveTo(x, y);
                timelineCtx.lineTo(x, y + offset);
                timelineCtx.strokeStyle = m.color;
                timelineCtx.lineWidth = 2;
                timelineCtx.stroke();

                // Circle
                timelineCtx.beginPath();
                timelineCtx.arc(x, y, 8, 0, Math.PI * 2);
                timelineCtx.fillStyle = m.color;
                timelineCtx.fill();
                timelineCtx.strokeStyle = 'white';
                timelineCtx.lineWidth = 2;
                timelineCtx.stroke();

                // Text
                timelineCtx.save();
                timelineCtx.translate(x, y + offset + (offset > 0 ? 20 : -20));
                timelineCtx.rotate(offset > 0 ? Math.PI / 6 : -Math.PI / 6);
                timelineCtx.textAlign = 'center';
                timelineCtx.font = 'bold 11px sans-serif';
                timelineCtx.fillStyle = m.color;
                timelineCtx.fillText(m.label, 0, 0);
                timelineCtx.fillStyle = '#666';
                timelineCtx.font = '10px sans-serif';
                timelineCtx.fillText(m.year, 0, 14);
                timelineCtx.restore();
            });

            // Draw decade markers
            for (let year = 1950; year <= 2020; year += 10) {
                const x = padding + ((year - minYear) / (maxYear - minYear)) * (w - 2 * padding);
                timelineCtx.fillStyle = '#999';
                timelineCtx.font = '12px sans-serif';
                timelineCtx.textAlign = 'center';
                timelineCtx.fillText(year, x, y + 25);
            }
        }

        // Initial draw
        resizeTimelineCanvas();

        // ============================================
        // GAME OF LIFE
        // ============================================
        const lifeCanvas = document.getElementById('life-canvas');
        const lifeCtx = lifeCanvas.getContext('2d');
        const lifeSize = 100;
        const lifeCellSize = lifeCanvas.width / lifeSize;
        let lifeGrid = Array(lifeSize).fill().map(() => Array(lifeSize).fill(0));
        let lifePlaying = false;
        let lifeInterval;

        function lifeRandomize() {
            for (let i = 0; i < lifeSize; i++) {
                for (let j = 0; j < lifeSize; j++) {
                    lifeGrid[i][j] = Math.random() > 0.7 ? 1 : 0;
                }
            }
            lifeDraw();
        }

        function lifeReset() {
            lifeGrid = Array(lifeSize).fill().map(() => Array(lifeSize).fill(0));
            // Add glider
            lifeGrid[10][10] = 1;
            lifeGrid[11][11] = 1;
            lifeGrid[11][12] = 1;
            lifeGrid[10][12] = 1;
            lifeGrid[9][12] = 1;
            lifeDraw();
        }

        function lifeDraw() {
            lifeCtx.fillStyle = '#000';
            lifeCtx.fillRect(0, 0, lifeCanvas.width, lifeCanvas.height);
            lifeCtx.fillStyle = '#667eea';
            for (let i = 0; i < lifeSize; i++) {
                for (let j = 0; j < lifeSize; j++) {
                    if (lifeGrid[i][j]) {
                        lifeCtx.fillRect(j * lifeCellSize, i * lifeCellSize, lifeCellSize - 1, lifeCellSize - 1);
                    }
                }
            }
        }

        function lifeStep() {
            const newGrid = Array(lifeSize).fill().map(() => Array(lifeSize).fill(0));
            for (let i = 0; i < lifeSize; i++) {
                for (let j = 0; j < lifeSize; j++) {
                    const neighbors = lifeCountNeighbors(i, j);
                    if (lifeGrid[i][j]) {
                        newGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        newGrid[i][j] = neighbors === 3 ? 1 : 0;
                    }
                }
            }
            lifeGrid = newGrid;
            lifeDraw();
        }

        function lifeCountNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const ni = (x + i + lifeSize) % lifeSize;
                    const nj = (y + j + lifeSize) % lifeSize;
                    count += lifeGrid[ni][nj];
                }
            }
            return count;
        }

        function lifeTogglePlay() {
            lifePlaying = !lifePlaying;
            if (lifePlaying) {
                lifeInterval = setInterval(lifeStep, 100);
            } else {
                clearInterval(lifeInterval);
            }
        }

        lifeCanvas.addEventListener('click', (e) => {
            const rect = lifeCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientY - rect.top) / lifeCellSize);
            const y = Math.floor((e.clientX - rect.left) / lifeCellSize);
            lifeGrid[x][y] = 1 - lifeGrid[x][y];
            lifeDraw();
        });

        lifeReset();

        // ============================================
        // WOLFRAM CA
        // ============================================
        const wolframCanvas = document.getElementById('wolfram-canvas');
        const wolframCtx = wolframCanvas.getContext('2d');
        let wolframRule = 30;
        let wolframCells = [];
        let wolframGeneration = 0;
        const wolframWidth = 200;
        const wolframCellSize = wolframCanvas.width / wolframWidth;

        function wolframReset() {
            wolframCells = Array(wolframWidth).fill(0);
            wolframCells[Math.floor(wolframWidth / 2)] = 1;
            wolframGeneration = 0;
            wolframCtx.fillStyle = '#000';
            wolframCtx.fillRect(0, 0, wolframCanvas.width, wolframCanvas.height);
            wolframAnimate();
        }

        function wolframAnimate() {
            if (wolframGeneration >= wolframCanvas.height / wolframCellSize) return;

            // Draw current generation
            for (let i = 0; i < wolframWidth; i++) {
                wolframCtx.fillStyle = wolframCells[i] ? '#667eea' : '#000';
                wolframCtx.fillRect(i * wolframCellSize, wolframGeneration * wolframCellSize, wolframCellSize, wolframCellSize);
            }

            // Calculate next generation
            const newCells = Array(wolframWidth).fill(0);
            for (let i = 0; i < wolframWidth; i++) {
                const left = wolframCells[(i - 1 + wolframWidth) % wolframWidth];
                const center = wolframCells[i];
                const right = wolframCells[(i + 1) % wolframWidth];
                const config = (left << 2) | (center << 1) | right;
                newCells[i] = (wolframRule >> config) & 1;
            }
            wolframCells = newCells;
            wolframGeneration++;

            setTimeout(wolframAnimate, 20);
        }

        function wolframChangeRule() {
            wolframRule = parseInt(document.getElementById('rule-select').value);
            wolframReset();
        }

        wolframReset();

        // ============================================
        // LORENZ ATTRACTOR
        // ============================================
        const lorenzCanvas = document.getElementById('lorenz-canvas');
        const lorenzCtx = lorenzCanvas.getContext('2d');
        let lorenzPoints = [];
        let lorenzPlaying = true;
        const lorenzParams = { sigma: 10, rho: 28, beta: 8/3, dt: 0.005 };
        let lorenzState = { x: 0.1, y: 0, z: 0 };

        function lorenzReset() {
            lorenzPoints = [];
            lorenzState = { x: 0.1, y: 0, z: 0 };
        }

        function lorenzStep() {
            const { x, y, z } = lorenzState;
            const { sigma, rho, beta, dt } = lorenzParams;

            const dx = sigma * (y - x);
            const dy = x * (rho - z) - y;
            const dz = x * y - beta * z;

            lorenzState.x += dx * dt;
            lorenzState.y += dy * dt;
            lorenzState.z += dz * dt;

            lorenzPoints.push({ ...lorenzState });
            if (lorenzPoints.length > 3000) lorenzPoints.shift();
        }

        function lorenzDraw() {
            const w = lorenzCanvas.width;
            const h = lorenzCanvas.height;

            lorenzCtx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            lorenzCtx.fillRect(0, 0, w, h);

            if (lorenzPoints.length < 2) return;

            lorenzCtx.strokeStyle = '#667eea';
            lorenzCtx.lineWidth = 1;
            lorenzCtx.beginPath();

            for (let i = 0; i < lorenzPoints.length; i++) {
                const p = lorenzPoints[i];
                const px = w/2 + p.x * 8;
                const py = h/2 - p.z * 4 + 100;

                if (i === 0) {
                    lorenzCtx.moveTo(px, py);
                } else {
                    lorenzCtx.lineTo(px, py);
                }
            }
            lorenzCtx.stroke();

            // Draw current point
            const last = lorenzPoints[lorenzPoints.length - 1];
            const px = w/2 + last.x * 8;
            const py = h/2 - last.z * 4 + 100;
            lorenzCtx.beginPath();
            lorenzCtx.arc(px, py, 3, 0, Math.PI * 2);
            lorenzCtx.fillStyle = '#f97316';
            lorenzCtx.fill();
        }

        function lorenzAnimate() {
            if (lorenzPlaying) {
                lorenzStep();
                lorenzDraw();
            }
            requestAnimationFrame(lorenzAnimate);
        }

        function lorenzTogglePlay() {
            lorenzPlaying = !lorenzPlaying;
        }

        lorenzAnimate();

        // ============================================
        // GRAY-SCOTT REACTION-DIFFUSION
        // ============================================
        const grayScottCanvas = document.getElementById('grayscott-canvas');
        const grayScottCtx = grayScottCanvas.getContext('2d');
        const grayScottSize = 200;
        let grayScottU = Array(grayScottSize).fill().map(() => Array(grayScottSize).fill(1));
        let grayScottV = Array(grayScottSize).fill().map(() => Array(grayScottSize).fill(0));
        let grayScottParams = { F: 0.055, k: 0.062 }; // Spots pattern

        const patterns = {
            spots: { F: 0.055, k: 0.062 },
            stripes: { F: 0.035, k: 0.065 },
            waves: { F: 0.014, k: 0.054 },
            coral: { F: 0.062, k: 0.061 }
        };

        function grayScottReset() {
            grayScottU = Array(grayScottSize).fill().map(() => Array(grayScottSize).fill(1));
            grayScottV = Array(grayScottSize).fill().map(() => Array(grayScottSize).fill(0));

            // Add some initial perturbation
            for (let i = 90; i < 110; i++) {
                for (let j = 90; j < 110; j++) {
                    grayScottV[i][j] = 1;
                    grayScottU[i][j] = 0;
                }
            }

            // Random seeds
            for (let n = 0; n < 10; n++) {
                const i = Math.floor(Math.random() * grayScottSize);
                const j = Math.floor(Math.random() * grayScottSize);
                for (let di = -2; di <= 2; di++) {
                    for (let dj = -2; dj <= 2; dj++) {
                        const ni = (i + di + grayScottSize) % grayScottSize;
                        const nj = (j + dj + grayScottSize) % grayScottSize;
                        grayScottV[ni][nj] = 1;
                        grayScottU[ni][nj] = 0;
                    }
                }
            }

            grayScottAnimate();
        }

        function grayScottStep() {
            const newU = Array(grayScottSize).fill().map(() => Array(grayScottSize).fill(0));
            const newV = Array(grayScottSize).fill().map(() => Array(grayScottSize).fill(0));
            const Du = 0.16;
            const Dv = 0.08;
            const { F, k } = grayScottParams;

            for (let i = 0; i < grayScottSize; i++) {
                for (let j = 0; j < grayScottSize; j++) {
                    const u = grayScottU[i][j];
                    const v = grayScottV[i][j];

                    // Laplacian
                    const laplaceU = -u + 0.2 * (
                        grayScottU[(i-1+grayScottSize)%grayScottSize][j] +
                        grayScottU[(i+1)%grayScottSize][j] +
                        grayScottU[i][(j-1+grayScottSize)%grayScottSize] +
                        grayScottU[i][(j+1)%grayScottSize]
                    ) + 0.05 * (
                        grayScottU[(i-1+grayScottSize)%grayScottSize][(j-1+grayScottSize)%grayScottSize] +
                        grayScottU[(i-1+grayScottSize)%grayScottSize][(j+1)%grayScottSize] +
                        grayScottU[(i+1)%grayScottSize][(j-1+grayScottSize)%grayScottSize] +
                        grayScottU[(i+1)%grayScottSize][(j+1)%grayScottSize]
                    );

                    const laplaceV = -v + 0.2 * (
                        grayScottV[(i-1+grayScottSize)%grayScottSize][j] +
                        grayScottV[(i+1)%grayScottSize][j] +
                        grayScottV[i][(j-1+grayScottSize)%grayScottSize] +
                        grayScottV[i][(j+1)%grayScottSize]
                    ) + 0.05 * (
                        grayScottV[(i-1+grayScottSize)%grayScottSize][(j-1+grayScottSize)%grayScottSize] +
                        grayScottV[(i-1+grayScottSize)%grayScottSize][(j+1)%grayScottSize] +
                        grayScottV[(i+1)%grayScottSize][(j-1+grayScottSize)%grayScottSize] +
                        grayScottV[(i+1)%grayScottSize][(j+1)%grayScottSize]
                    );

                    const uvv = u * v * v;
                    newU[i][j] = u + (Du * laplaceU - uvv + F * (1 - u));
                    newV[i][j] = v + (Dv * laplaceV + uvv - (F + k) * v);

                    newU[i][j] = Math.max(0, Math.min(1, newU[i][j]));
                    newV[i][j] = Math.max(0, Math.min(1, newV[i][j]));
                }
            }

            grayScottU = newU;
            grayScottV = newV;
        }

        function grayScottDraw() {
            const cellSize = grayScottCanvas.width / grayScottSize;
            const imageData = grayScottCtx.createImageData(grayScottCanvas.width, grayScottCanvas.height);

            for (let i = 0; i < grayScottSize; i++) {
                for (let j = 0; j < grayScottSize; j++) {
                    const v = grayScottV[i][j];
                    const val = Math.floor(v * 255);

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = Math.floor(j * cellSize + dx);
                            const py = Math.floor(i * cellSize + dy);
                            const idx = (py * grayScottCanvas.width + px) * 4;

                            // Purple gradient
                            imageData.data[idx] = Math.floor(102 + val * 0.4);
                            imageData.data[idx + 1] = Math.floor(126 + val * 0.5);
                            imageData.data[idx + 2] = Math.floor(234 + val * 0.08);
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            grayScottCtx.putImageData(imageData, 0, 0);
        }

        let grayScottAnimating = true;
        function grayScottAnimate() {
            if (grayScottAnimating) {
                for (let i = 0; i < 10; i++) {
                    grayScottStep();
                }
                grayScottDraw();
                requestAnimationFrame(grayScottAnimate);
            }
        }

        function grayScottChangePattern() {
            const pattern = document.getElementById('pattern-select').value;
            grayScottParams = patterns[pattern];
            grayScottReset();
        }

        grayScottReset();

        // ============================================
        // BOIDS
        // ============================================
        const boidsCanvas = document.getElementById('boids-canvas');
        const boidsCtx = boidsCanvas.getContext('2d');
        let boids = [];
        let predators = [];
        const boidsCount = 100;

        class Boid {
            constructor(x, y, isPredator = false) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.isPredator = isPredator;
                this.maxSpeed = isPredator ? 4 : 3;
                this.maxForce = isPredator ? 0.2 : 0.1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around
                if (this.x < 0) this.x = boidsCanvas.width;
                if (this.x > boidsCanvas.width) this.x = 0;
                if (this.y < 0) this.y = boidsCanvas.height;
                if (this.y > boidsCanvas.height) this.y = 0;

                // Limit speed
                const speed = Math.hypot(this.vx, this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }
            }

            draw() {
                boidsCtx.save();
                boidsCtx.translate(this.x, this.y);
                const angle = Math.atan2(this.vy, this.vx);
                boidsCtx.rotate(angle);

                boidsCtx.beginPath();
                boidsCtx.moveTo(8, 0);
                boidsCtx.lineTo(-4, 4);
                boidsCtx.lineTo(-4, -4);
                boidsCtx.closePath();

                boidsCtx.fillStyle = this.isPredator ? '#f97316' : '#667eea';
                boidsCtx.fill();
                boidsCtx.restore();
            }

            flock(boids) {
                if (this.isPredator) {
                    this.chase(boids);
                    return;
                }

                let sepX = 0, sepY = 0, aliX = 0, aliY = 0, cohX = 0, cohY = 0;
                let sepCount = 0, aliCount = 0, cohCount = 0;
                const sepDist = 25, aliDist = 50, cohDist = 50;

                // Avoid predators
                predators.forEach(p => {
                    const dist = Math.hypot(this.x - p.x, this.y - p.y);
                    if (dist < 100 && dist > 0) {
                        const dx = this.x - p.x;
                        const dy = this.y - p.y;
                        sepX += dx / dist;
                        sepY += dy / dist;
                        sepCount++;
                    }
                });

                boids.forEach(other => {
                    if (other === this || other.isPredator) return;
                    const dist = Math.hypot(this.x - other.x, this.y - other.y);

                    if (dist < sepDist && dist > 0) {
                        const dx = this.x - other.x;
                        const dy = this.y - other.y;
                        sepX += dx / dist;
                        sepY += dy / dist;
                        sepCount++;
                    }

                    if (dist < aliDist) {
                        aliX += other.vx;
                        aliY += other.vy;
                        aliCount++;
                    }

                    if (dist < cohDist) {
                        cohX += other.x;
                        cohY += other.y;
                        cohCount++;
                    }
                });

                if (sepCount > 0) {
                    sepX /= sepCount;
                    sepY /= sepCount;
                    this.applyForce(sepX * 1.5, sepY * 1.5);
                }

                if (aliCount > 0) {
                    aliX /= aliCount;
                    aliY /= aliCount;
                    this.applyForce((aliX - this.vx) * 0.1, (aliY - this.vy) * 0.1);
                }

                if (cohCount > 0) {
                    cohX /= cohCount;
                    cohY /= cohCount;
                    const dx = cohX - this.x;
                    const dy = cohY - this.y;
                    this.applyForce(dx * 0.01, dy * 0.01);
                }
            }

            chase(boids) {
                let nearestDist = Infinity;
                let nearest = null;

                boids.forEach(b => {
                    if (b.isPredator) return;
                    const dist = Math.hypot(this.x - b.x, this.y - b.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = b;
                    }
                });

                if (nearest) {
                    const dx = nearest.x - this.x;
                    const dy = nearest.y - this.y;
                    this.applyForce(dx * 0.01, dy * 0.01);
                }
            }

            applyForce(fx, fy) {
                const mag = Math.hypot(fx, fy);
                if (mag > this.maxForce) {
                    fx = (fx / mag) * this.maxForce;
                    fy = (fy / mag) * this.maxForce;
                }
                this.vx += fx;
                this.vy += fy;
            }
        }

        function boidsReset() {
            boids = [];
            predators = [];
            for (let i = 0; i < boidsCount; i++) {
                boids.push(new Boid(
                    Math.random() * boidsCanvas.width,
                    Math.random() * boidsCanvas.height
                ));
            }
        }

        function boidsAddPredator() {
            predators.push(new Boid(
                Math.random() * boidsCanvas.width,
                Math.random() * boidsCanvas.height,
                true
            ));
        }

        function boidsAnimate() {
            boidsCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            boidsCtx.fillRect(0, 0, boidsCanvas.width, boidsCanvas.height);

            const allBoids = [...boids, ...predators];
            allBoids.forEach(b => {
                b.flock(allBoids);
                b.update();
                b.draw();
            });

            requestAnimationFrame(boidsAnimate);
        }

        boidsReset();
        boidsAnimate();

        // ============================================
        // MANDELBROT SET
        // ============================================
        const mandelbrotCanvas = document.getElementById('mandelbrot-canvas');
        const mandelbrotCtx = mandelbrotCanvas.getContext('2d');
        let mandelbrotView = { centerX: -0.5, centerY: 0, zoom: 200 };
        const mandelbrotMaxIter = 100;

        function mandelbrotDraw() {
            const w = mandelbrotCanvas.width;
            const h = mandelbrotCanvas.height;
            const imageData = mandelbrotCtx.createImageData(w, h);

            for (let px = 0; px < w; px++) {
                for (let py = 0; py < h; py++) {
                    const x0 = mandelbrotView.centerX + (px - w/2) / mandelbrotView.zoom;
                    const y0 = mandelbrotView.centerY + (py - h/2) / mandelbrotView.zoom;

                    let x = 0, y = 0, iter = 0;
                    while (x*x + y*y <= 4 && iter < mandelbrotMaxIter) {
                        const xtemp = x*x - y*y + x0;
                        y = 2*x*y + y0;
                        x = xtemp;
                        iter++;
                    }

                    const idx = (py * w + px) * 4;
                    if (iter === mandelbrotMaxIter) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 0;
                        imageData.data[idx + 2] = 0;
                    } else {
                        const hue = (iter / mandelbrotMaxIter) * 360;
                        const sat = 100;
                        const light = iter < mandelbrotMaxIter ? 50 : 0;
                        const rgb = hslToRgb(hue, sat, light);
                        imageData.data[idx] = rgb[0];
                        imageData.data[idx + 1] = rgb[1];
                        imageData.data[idx + 2] = rgb[2];
                    }
                    imageData.data[idx + 3] = 255;
                }
            }

            mandelbrotCtx.putImageData(imageData, 0, 0);
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c/2;
            let r = 0, g = 0, b = 0;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return [Math.floor((r + m) * 255), Math.floor((g + m) * 255), Math.floor((b + m) * 255)];
        }

        function mandelbrotReset() {
            mandelbrotView = { centerX: -0.5, centerY: 0, zoom: 200 };
            mandelbrotDraw();
        }

        function mandelbrotZoomIn() {
            mandelbrotView.zoom *= 1.5;
            mandelbrotDraw();
        }

        function mandelbrotZoomOut() {
            mandelbrotView.zoom /= 1.5;
            mandelbrotDraw();
        }

        mandelbrotCanvas.addEventListener('click', (e) => {
            const rect = mandelbrotCanvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            mandelbrotView.centerX += (px - mandelbrotCanvas.width/2) / mandelbrotView.zoom;
            mandelbrotView.centerY += (py - mandelbrotCanvas.height/2) / mandelbrotView.zoom;
            mandelbrotView.zoom *= 2;
            mandelbrotDraw();
        });

        mandelbrotDraw();

        // ============================================
        // L-SYSTEMS
        // ============================================
        const lsystemCanvas = document.getElementById('lsystem-canvas');
        const lsystemCtx = lsystemCanvas.getContext('2d');
        let lsystemIteration = 0;
        let lsystemType = 'tree';

        const lsystems = {
            tree: {
                axiom: 'X',
                rules: { X: 'F+[[X]-X]-F[-FX]+X', F: 'FF' },
                angle: 25,
                length: 3,
                iterations: 6
            },
            bush: {
                axiom: 'F',
                rules: { F: 'FF+[+F-F-F]-[-F+F+F]' },
                angle: 22.5,
                length: 2,
                iterations: 4
            },
            fern: {
                axiom: 'X',
                rules: { X: 'F+[[X]-X]-F[-FX]+X', F: 'FF' },
                angle: 20,
                length: 2,
                iterations: 6
            },
            weed: {
                axiom: 'F',
                rules: { F: 'F[+F]F[-F]F' },
                angle: 25.7,
                length: 2,
                iterations: 5
            }
        };

        function lsystemGenerate(system, iterations) {
            let current = system.axiom;
            for (let i = 0; i < iterations; i++) {
                let next = '';
                for (let char of current) {
                    next += system.rules[char] || char;
                }
                current = next;
            }
            return current;
        }

        function lsystemDraw() {
            const system = lsystems[lsystemType];
            const instructions = lsystemGenerate(system, lsystemIteration);

            lsystemCtx.fillStyle = '#000';
            lsystemCtx.fillRect(0, 0, lsystemCanvas.width, lsystemCanvas.height);

            lsystemCtx.strokeStyle = '#667eea';
            lsystemCtx.lineWidth = 1;

            const stack = [];
            let x = lsystemCanvas.width / 2;
            let y = lsystemCanvas.height - 50;
            let angle = -90;

            for (let char of instructions) {
                if (char === 'F') {
                    const newX = x + system.length * Math.cos(angle * Math.PI / 180);
                    const newY = y + system.length * Math.sin(angle * Math.PI / 180);
                    lsystemCtx.beginPath();
                    lsystemCtx.moveTo(x, y);
                    lsystemCtx.lineTo(newX, newY);
                    lsystemCtx.stroke();
                    x = newX;
                    y = newY;
                } else if (char === '+') {
                    angle += system.angle;
                } else if (char === '-') {
                    angle -= system.angle;
                } else if (char === '[') {
                    stack.push({ x, y, angle });
                } else if (char === ']') {
                    const state = stack.pop();
                    x = state.x;
                    y = state.y;
                    angle = state.angle;
                }
            }
        }

        function lsystemReset() {
            lsystemIteration = 0;
            lsystemDraw();
        }

        function lsystemGrow() {
            const system = lsystems[lsystemType];
            if (lsystemIteration < system.iterations) {
                lsystemIteration++;
                lsystemDraw();
            }
        }

        function lsystemChange() {
            lsystemType = document.getElementById('lsystem-select').value;
            lsystemReset();
        }

        lsystemDraw();

        // ============================================
        // NETWORK VISUALIZATION
        // ============================================
        const networkCanvas = document.getElementById('network-canvas');
        const networkCtx = networkCanvas.getContext('2d');
        let networkNodes = [];
        let networkEdges = [];
        let networkType = 'smallworld';

        class NetworkNode {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.vx = 0;
                this.vy = 0;
                this.state = 'S'; // S, I, R for SIR
            }

            draw() {
                networkCtx.beginPath();
                networkCtx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                if (networkType === 'sir') {
                    networkCtx.fillStyle = this.state === 'S' ? '#667eea' :
                                          this.state === 'I' ? '#f97316' : '#4ade80';
                } else if (networkType === 'scalefree') {
                    const degree = networkEdges.filter(e => e[0] === this.id || e[1] === this.id).length;
                    networkCtx.fillStyle = degree > 5 ? '#f97316' : '#667eea';
                } else {
                    networkCtx.fillStyle = '#667eea';
                }
                networkCtx.fill();
            }
        }

        function networkCreateSmallWorld() {
            networkNodes = [];
            networkEdges = [];
            const n = 50;
            const k = 4;
            const p = 0.1;

            // Ring lattice
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                const r = 250;
                networkNodes.push(new NetworkNode(
                    networkCanvas.width/2 + r * Math.cos(angle),
                    networkCanvas.height/2 + r * Math.sin(angle),
                    i
                ));

                // Connect to k nearest neighbors
                for (let j = 1; j <= k/2; j++) {
                    networkEdges.push([i, (i + j) % n]);
                }
            }

            // Rewire with probability p
            const newEdges = [];
            networkEdges.forEach(edge => {
                if (Math.random() < p) {
                    const newTarget = Math.floor(Math.random() * n);
                    newEdges.push([edge[0], newTarget]);
                } else {
                    newEdges.push(edge);
                }
            });
            networkEdges = newEdges;
        }

        function networkCreateScaleFree() {
            networkNodes = [];
            networkEdges = [];
            const n = 50;
            const m0 = 3;

            // Initial complete graph
            for (let i = 0; i < m0; i++) {
                networkNodes.push(new NetworkNode(
                    Math.random() * networkCanvas.width,
                    Math.random() * networkCanvas.height,
                    i
                ));
                for (let j = 0; j < i; j++) {
                    networkEdges.push([i, j]);
                }
            }

            // Preferential attachment
            for (let i = m0; i < n; i++) {
                networkNodes.push(new NetworkNode(
                    Math.random() * networkCanvas.width,
                    Math.random() * networkCanvas.height,
                    i
                ));

                const degrees = networkNodes.map((_, id) =>
                    networkEdges.filter(e => e[0] === id || e[1] === id).length
                );
                const totalDegree = degrees.reduce((a, b) => a + b, 0);

                for (let j = 0; j < 2; j++) {
                    let r = Math.random() * totalDegree;
                    let target = 0;
                    while (r > 0 && target < i) {
                        r -= degrees[target];
                        target++;
                    }
                    target = Math.max(0, target - 1);
                    networkEdges.push([i, target]);
                }
            }
        }

        function networkCreateSIR() {
            networkCreateSmallWorld();
            networkNodes[0].state = 'I'; // Patient zero
        }

        function networkSIRStep() {
            const beta = 0.3; // Infection rate
            const gamma = 0.1; // Recovery rate

            networkNodes.forEach(node => {
                if (node.state === 'I') {
                    // Try to recover
                    if (Math.random() < gamma) {
                        node.state = 'R';
                    } else {
                        // Try to infect neighbors
                        networkEdges.forEach(edge => {
                            if (edge[0] === node.id || edge[1] === node.id) {
                                const neighbor = networkNodes[edge[0] === node.id ? edge[1] : edge[0]];
                                if (neighbor.state === 'S' && Math.random() < beta) {
                                    neighbor.state = 'I';
                                }
                            }
                        });
                    }
                }
            });
        }

        function networkDraw() {
            networkCtx.fillStyle = '#000';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);

            // Draw edges
            networkCtx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
            networkCtx.lineWidth = 1;
            networkEdges.forEach(edge => {
                const n1 = networkNodes[edge[0]];
                const n2 = networkNodes[edge[1]];
                networkCtx.beginPath();
                networkCtx.moveTo(n1.x, n1.y);
                networkCtx.lineTo(n2.x, n2.y);
                networkCtx.stroke();
            });

            // Draw nodes
            networkNodes.forEach(node => node.draw());
        }

        function networkReset() {
            if (networkType === 'smallworld') {
                networkCreateSmallWorld();
            } else if (networkType === 'scalefree') {
                networkCreateScaleFree();
            } else if (networkType === 'sir') {
                networkCreateSIR();
            }
            networkDraw();
        }

        function networkChangeType() {
            networkType = document.getElementById('network-type').value;
            networkReset();
        }

        function networkAnimate() {
            if (networkType === 'sir') {
                networkSIRStep();
                networkDraw();
            }
            requestAnimationFrame(networkAnimate);
        }

        networkReset();
        networkAnimate();

        // ============================================
        // LANGTON'S ANT
        // ============================================
        const antCanvas = document.getElementById('ant-canvas');
        const antCtx = antCanvas.getContext('2d');
        const antSize = 100;
        const antCellSize = antCanvas.width / antSize;
        let antGrid = Array(antSize).fill().map(() => Array(antSize).fill(0));
        let ant = { x: Math.floor(antSize/2), y: Math.floor(antSize/2), dir: 0 }; // dir: 0=up, 1=right, 2=down, 3=left
        let antSteps = 0;
        let antPlaying = false;
        let antInterval;

        function antReset() {
            antGrid = Array(antSize).fill().map(() => Array(antSize).fill(0));
            ant = { x: Math.floor(antSize/2), y: Math.floor(antSize/2), dir: 0 };
            antSteps = 0;
            antDraw();
        }

        function antStep() {
            const current = antGrid[ant.y][ant.x];

            // Turn
            if (current === 0) {
                ant.dir = (ant.dir + 1) % 4; // Turn right
            } else {
                ant.dir = (ant.dir + 3) % 4; // Turn left
            }

            // Flip color
            antGrid[ant.y][ant.x] = 1 - current;

            // Move forward
            if (ant.dir === 0) ant.y = (ant.y - 1 + antSize) % antSize;
            else if (ant.dir === 1) ant.x = (ant.x + 1) % antSize;
            else if (ant.dir === 2) ant.y = (ant.y + 1) % antSize;
            else if (ant.dir === 3) ant.x = (ant.x - 1 + antSize) % antSize;

            antSteps++;
        }

        function antDraw() {
            antCtx.fillStyle = '#000';
            antCtx.fillRect(0, 0, antCanvas.width, antCanvas.height);

            // Draw grid
            for (let i = 0; i < antSize; i++) {
                for (let j = 0; j < antSize; j++) {
                    if (antGrid[i][j]) {
                        antCtx.fillStyle = '#667eea';
                        antCtx.fillRect(j * antCellSize, i * antCellSize, antCellSize, antCellSize);
                    }
                }
            }

            // Draw ant
            antCtx.fillStyle = '#f97316';
            antCtx.fillRect(ant.x * antCellSize, ant.y * antCellSize, antCellSize, antCellSize);
        }

        function antTogglePlay() {
            antPlaying = !antPlaying;
            if (antPlaying) {
                antInterval = setInterval(() => {
                    antStep();
                    antDraw();
                }, 50);
            } else {
                clearInterval(antInterval);
            }
        }

        function antFast() {
            for (let i = 0; i < 1000; i++) {
                antStep();
            }
            antDraw();
        }

        antReset();

        // ============================================
        // GENETIC ALGORITHM
        // ============================================
        const geneticCanvas = document.getElementById('genetic-canvas');
        const geneticCtx = geneticCanvas.getContext('2d');
        let geneticPopulation = [];
        let geneticGeneration = 0;
        let geneticPlaying = false;
        let geneticInterval;
        const geneticTarget = "HELLO WORLD";
        const geneticPopSize = 100;

        class Individual {
            constructor(genes) {
                if (genes) {
                    this.genes = genes;
                } else {
                    this.genes = '';
                    for (let i = 0; i < geneticTarget.length; i++) {
                        this.genes += String.fromCharCode(Math.floor(Math.random() * 95) + 32);
                    }
                }
                this.fitness = this.calcFitness();
            }

            calcFitness() {
                let score = 0;
                for (let i = 0; i < this.genes.length; i++) {
                    if (this.genes[i] === geneticTarget[i]) score++;
                }
                return score / geneticTarget.length;
            }

            crossover(partner) {
                const child = '';
                const midpoint = Math.floor(Math.random() * this.genes.length);
                let childGenes = '';
                for (let i = 0; i < this.genes.length; i++) {
                    if (i < midpoint) {
                        childGenes += this.genes[i];
                    } else {
                        childGenes += partner.genes[i];
                    }
                }
                return new Individual(childGenes);
            }

            mutate(mutationRate) {
                let genes = '';
                for (let i = 0; i < this.genes.length; i++) {
                    if (Math.random() < mutationRate) {
                        genes += String.fromCharCode(Math.floor(Math.random() * 95) + 32);
                    } else {
                        genes += this.genes[i];
                    }
                }
                this.genes = genes;
                this.fitness = this.calcFitness();
            }
        }

        function geneticReset() {
            geneticPopulation = [];
            for (let i = 0; i < geneticPopSize; i++) {
                geneticPopulation.push(new Individual());
            }
            geneticGeneration = 0;
            geneticDraw();
        }

        function geneticEvolve() {
            // Selection
            geneticPopulation.sort((a, b) => b.fitness - a.fitness);
            const matingPool = geneticPopulation.slice(0, Math.floor(geneticPopSize / 2));

            // Reproduction
            const newPopulation = [...matingPool];
            while (newPopulation.length < geneticPopSize) {
                const parent1 = matingPool[Math.floor(Math.random() * matingPool.length)];
                const parent2 = matingPool[Math.floor(Math.random() * matingPool.length)];
                const child = parent1.crossover(parent2);
                child.mutate(0.01);
                newPopulation.push(child);
            }

            geneticPopulation = newPopulation;
            geneticGeneration++;
            geneticDraw();
        }

        function geneticDraw() {
            geneticCtx.fillStyle = '#000';
            geneticCtx.fillRect(0, 0, geneticCanvas.width, geneticCanvas.height);

            geneticCtx.fillStyle = '#667eea';
            geneticCtx.font = '20px monospace';
            geneticCtx.fillText('Target: ' + geneticTarget, 20, 40);

            geneticPopulation.sort((a, b) => b.fitness - a.fitness);
            const best = geneticPopulation[0];

            geneticCtx.fillStyle = '#f97316';
            geneticCtx.fillText('Best:   ' + best.genes, 20, 70);

            geneticCtx.fillStyle = '#667eea';
            geneticCtx.font = '16px sans-serif';
            geneticCtx.fillText('Generation: ' + geneticGeneration, 20, 100);
            geneticCtx.fillText('Fitness: ' + (best.fitness * 100).toFixed(1) + '%', 20, 120);

            // Draw fitness distribution
            const barWidth = geneticCanvas.width / geneticPopSize;
            geneticPopulation.forEach((ind, i) => {
                const h = ind.fitness * 400;
                geneticCtx.fillStyle = `hsl(${ind.fitness * 240}, 80%, 50%)`;
                geneticCtx.fillRect(i * barWidth, geneticCanvas.height - h, barWidth - 1, h);
            });
        }

        function geneticTogglePlay() {
            geneticPlaying = !geneticPlaying;
            if (geneticPlaying) {
                geneticInterval = setInterval(geneticEvolve, 100);
            } else {
                clearInterval(geneticInterval);
            }
        }

        geneticReset();

        // ============================================
        // TECHNOLOGY TIMELINE
        // ============================================
        const techCanvas = document.getElementById('tech-timeline-canvas');
        const techCtx = techCanvas.getContext('2d');

        function drawTechTimeline() {
            const w = techCanvas.width;
            const h = techCanvas.height;

            techCtx.fillStyle = '#000';
            techCtx.fillRect(0, 0, w, h);

            const technologies = [
                { year: 1963, name: "Sketchpad", cost: "$2M" },
                { year: 1970, name: "Minicomputers", cost: "$100K" },
                { year: 1985, name: "Home PCs", cost: "$2K" },
                { year: 1992, name: "OpenGL", cost: "Free" },
                { year: 2010, name: "Three.js", cost: "Free" },
                { year: 2011, name: "WebGL", cost: "Free" },
                { year: 2017, name: "WebAssembly", cost: "Free" },
                { year: 2025, name: "Browser Access", cost: "$0" }
            ];

            const minYear = 1960;
            const maxYear = 2030;
            const padding = 50;

            // Draw cost reduction curve
            techCtx.strokeStyle = '#667eea';
            techCtx.lineWidth = 3;
            techCtx.beginPath();

            technologies.forEach((tech, i) => {
                const x = padding + ((tech.year - minYear) / (maxYear - minYear)) * (w - 2 * padding);
                const costMap = { "$2M": 500, "$100K": 400, "$2K": 200, "Free": 100, "$0": 50 };
                const y = h - (costMap[tech.cost] || 100);

                if (i === 0) {
                    techCtx.moveTo(x, y);
                } else {
                    techCtx.lineTo(x, y);
                }

                // Draw point
                techCtx.fillStyle = '#f97316';
                techCtx.beginPath();
                techCtx.arc(x, y, 6, 0, Math.PI * 2);
                techCtx.fill();

                // Draw label
                techCtx.fillStyle = '#667eea';
                techCtx.font = 'bold 12px sans-serif';
                techCtx.textAlign = 'center';
                techCtx.fillText(tech.name, x, y - 15);
                techCtx.fillStyle = '#999';
                techCtx.font = '11px sans-serif';
                techCtx.fillText(tech.cost, x, y - 30);
            });

            techCtx.strokeStyle = '#667eea';
            techCtx.stroke();

            // Labels
            techCtx.fillStyle = '#fff';
            techCtx.font = 'bold 16px sans-serif';
            techCtx.textAlign = 'left';
            techCtx.fillText('Cost of Computational Graphics', 20, 30);
            techCtx.fillStyle = '#999';
            techCtx.font = '12px sans-serif';
            techCtx.fillText('10,000× reduction in 60 years', 20, 50);
        }

        techCanvas.width = 600;
        techCanvas.height = 600;
        drawTechTimeline();
    </script>
    <script src="assets/js/enhance.js" defer></script>
</body>
</html>