<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classical Cipher Demo - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #e8e8f0;
        }
        .back-link {
            position: fixed; top: 15px; left: 15px;
            padding: 10px 18px; background: rgba(0,0,0,0.6);
            color: #00ff88; text-decoration: none; border-radius: 8px;
            font-size: 14px; z-index: 1000; border: 1px solid rgba(0,255,136,0.3);
        }
        .container { max-width: 1000px; margin: 0 auto; padding: 70px 20px 40px; }
        h1 { font-size: 1.8rem; color: #00ff88; margin-bottom: 10px; text-align: center; }
        .desc { text-align: center; color: #888; margin-bottom: 30px; line-height: 1.6; }
        .panel {
            background: rgba(0,0,0,0.6); border-radius: 15px; padding: 25px;
            margin-bottom: 20px; border: 1px solid rgba(0,255,136,0.2);
        }
        .control-group { margin-bottom: 20px; }
        .control-group label { display: block; font-size: 0.85rem; color: #00ff88; margin-bottom: 8px; }
        input[type="text"], textarea {
            width: 100%; padding: 12px;
            background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3);
            border-radius: 8px; color: #fff; font-family: 'Courier New', monospace; font-size: 1rem;
        }
        textarea { min-height: 100px; resize: vertical; }
        .output-box {
            background: rgba(0,0,0,0.5); border: 1px solid rgba(0,255,136,0.3);
            border-radius: 8px; padding: 15px; min-height: 80px; font-size: 1rem; word-break: break-all;
        }
        .btn-row { display: flex; gap: 10px; margin-top: 15px; }
        .btn {
            flex: 1; padding: 12px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            border: none; border-radius: 8px; color: #000; font-weight: bold;
            cursor: pointer; font-family: 'Courier New', monospace;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,255,136,0.4); }
        .btn.secondary { background: rgba(0,255,136,0.2); color: #00ff88; }
        .info-box {
            background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.2);
            border-radius: 8px; padding: 15px; margin-top: 20px; font-size: 0.8rem; line-height: 1.6; color: #aaa;
        }
        #canvas { border-radius: 10px; margin: 20px auto; display: block; background: rgba(0,0,0,0.3); }
        .mapping { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; justify-content: center; }
        .map-pair {
            display: flex; flex-direction: column; align-items: center;
            padding: 8px; background: rgba(0,255,136,0.1); border-radius: 6px;
        }
        .map-pair .from { color: #888; font-size: 0.8rem; }
        .map-pair .to { color: #00ff88; font-weight: bold; font-size: 1.1rem; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1 id="title">Classical Cipher</h1>
        <p class="desc" id="description">Interactive cipher visualization</p>

        <div class="panel">
            <div class="control-group" id="keyGroup">
                <label id="keyLabel">Key</label>
                <input type="text" id="keyInput" value="">
            </div>
            <div class="control-group">
                <label>Plaintext</label>
                <textarea id="plaintext">HELLO WORLD</textarea>
            </div>
            <div class="mapping" id="mapping"></div>
            <canvas id="canvas" width="800" height="250"></canvas>
            <div class="control-group">
                <label>Ciphertext</label>
                <div class="output-box" id="ciphertext"></div>
            </div>
            <div class="btn-row">
                <button class="btn" id="encryptBtn">Encrypt</button>
                <button class="btn secondary" id="decryptBtn">Decrypt</button>
            </div>
        </div>

        <div class="info-box" id="infoBox"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        const demos = {
            '11-substitution-cipher': {
                title: 'Substitution Cipher',
                desc: 'Replace each letter with another according to a fixed mapping.',
                keyLabel: 'Substitution Alphabet',
                keyDefault: 'QWERTYUIOPASDFGHJKLZXCVBNM',
                info: 'A monoalphabetic cipher where each letter maps to exactly one other letter. With 26! (about 4×10²⁶) possible keys, brute force is impractical, but frequency analysis breaks it easily.',
                encrypt: encryptSubstitution
            },
            '12-book-cipher': {
                title: 'Book Cipher',
                desc: 'Use a shared book to encode messages as page/line/word references.',
                keyLabel: 'Book Text (each word is numbered)',
                keyDefault: 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',
                info: 'Also called a Beale cipher. Each word in the plaintext is replaced by the position of a word in the key text that starts with the same letter. Very secure if the key text is unknown.',
                encrypt: encryptBook
            },
            '13-steganography': {
                title: 'Steganography',
                desc: 'Hide messages within other content - the art of invisible ink.',
                keyLabel: 'Cover Text',
                keyDefault: 'Sample cover text for hiding messages within normal looking content.',
                info: 'Unlike encryption, steganography hides the existence of the message. Techniques include null ciphers (hidden in first letters), invisible ink, image manipulation, and audio encoding.',
                encrypt: encryptStego
            },
            '14-polybius-square': {
                title: 'Polybius Square',
                desc: 'Encode letters as pairs of coordinates in a 5x5 grid.',
                keyLabel: 'Grid Keyword (I/J combined)',
                keyDefault: 'KEYWORD',
                info: 'Invented by the Greek historian Polybius. Each letter becomes two digits (row, column). Used as a component in more complex ciphers like ADFGX. The 5x5 grid combines I and J.',
                encrypt: encryptPolybius
            },
            '15-scytale-cipher': {
                title: 'Scytale Cipher',
                desc: 'Ancient Spartan military cipher using a wrapped rod.',
                keyLabel: 'Rod Diameter (columns)',
                keyDefault: '4',
                info: 'One of the oldest known encryption devices. A strip of leather was wrapped around a rod, message written across, then unwrapped. Only a rod of matching diameter could read it.',
                encrypt: encryptScytale
            },
            '16-atbash-cipher': {
                title: 'Atbash Cipher',
                desc: 'Ancient Hebrew cipher that reverses the alphabet (A↔Z, B↔Y, etc).',
                keyLabel: '(No key needed)',
                keyDefault: '',
                info: 'One of the oldest ciphers, used in the Hebrew Bible. The name comes from the first two letter pairs: A-T (Aleph-Tav) and B-SH (Beth-Shin). It is self-inverse.',
                encrypt: encryptAtbash
            },
            '17-rot13-cipher': {
                title: 'ROT13 Cipher',
                desc: 'Rotate each letter by 13 positions - a self-inverse cipher.',
                keyLabel: '(Fixed rotation of 13)',
                keyDefault: '',
                info: 'A special case of Caesar cipher with shift 13. Since there are 26 letters, applying ROT13 twice returns the original text. Commonly used to obscure spoilers and puzzle answers online.',
                encrypt: encryptROT13
            },
            '18-keyword-cipher': {
                title: 'Keyword Cipher',
                desc: 'Create a substitution alphabet using a keyword.',
                keyLabel: 'Keyword',
                keyDefault: 'ZEBRA',
                info: 'The keyword (with duplicates removed) starts the cipher alphabet, followed by remaining letters. For ZEBRA: ZEBRWCDFGHIJKLMNOPQSTUVXY. Easier to remember than random substitution.',
                encrypt: encryptKeyword
            },
            '19-morse-code': {
                title: 'Morse Code',
                desc: 'Encode letters as sequences of dots and dashes.',
                keyLabel: '(Standard Morse mapping)',
                keyDefault: '',
                info: 'Developed in the 1830s for telegraphy. Letters are encoded as short (dot) and long (dash) signals. E (.) is shortest as it is most common. Still used in aviation and amateur radio.',
                encrypt: encryptMorse
            },
            '20-pigpen-cipher': {
                title: 'Pigpen Cipher',
                desc: 'Replace letters with symbols from a grid pattern.',
                keyLabel: '(Standard Pigpen grid)',
                keyDefault: '',
                info: 'Also called Freemason cipher. Letters are placed in grids, and the shape of the surrounding lines (with or without a dot) represents each letter. Used by Freemasons and in treasure hunt puzzles.',
                encrypt: encryptPigpen
            }
        };

        const filename = window.location.pathname.split('/').pop().replace('.html', '');
        const demo = demos[filename] || demos['11-substitution-cipher'];

        document.getElementById('title').textContent = demo.title;
        document.getElementById('description').textContent = demo.desc;
        document.getElementById('keyLabel').textContent = demo.keyLabel;
        document.getElementById('keyInput').value = demo.keyDefault;
        document.getElementById('infoBox').innerHTML = '<strong>About:</strong> ' + demo.info;
        document.title = demo.title + ' - CCAB';

        if (!demo.keyDefault) {
            document.getElementById('keyGroup').style.display = 'none';
        }

        function showMapping(from, to) {
            const div = document.getElementById('mapping');
            let html = '';
            for (let i = 0; i < Math.min(from.length, 26); i++) {
                html += `<div class="map-pair"><span class="from">${from[i]}</span><span class="to">${to[i]}</span></div>`;
            }
            div.innerHTML = html;
        }

        function encryptSubstitution() {
            let key = document.getElementById('keyInput').value.toUpperCase().replace(/[^A-Z]/g, '');
            if (key.length !== 26) key = 'QWERTYUIOPASDFGHJKLZXCVBNM';

            let plain = document.getElementById('plaintext').value.toUpperCase();
            let result = '';

            for (let c of plain) {
                const idx = alphabet.indexOf(c);
                result += idx >= 0 ? key[idx] : c;
            }

            showMapping(alphabet.split(''), key.split(''));
            document.getElementById('ciphertext').textContent = result;
            drawSubstitution(key);
        }

        function drawSubstitution(key) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';

            for (let i = 0; i < 26; i++) {
                const x = 30 + (i % 13) * 60;
                const y = 60 + Math.floor(i / 13) * 100;

                ctx.fillStyle = '#666';
                ctx.fillText(alphabet[i], x, y);

                ctx.strokeStyle = '#00ff88';
                ctx.beginPath();
                ctx.moveTo(x, y + 10);
                ctx.lineTo(x, y + 30);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x - 5, y + 25);
                ctx.lineTo(x, y + 30);
                ctx.lineTo(x + 5, y + 25);
                ctx.stroke();

                ctx.fillStyle = '#00ff88';
                ctx.fillText(key[i], x, y + 50);
            }
        }

        function encryptBook() {
            const words = document.getElementById('keyInput').value.toUpperCase().split(/\s+/);
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');
            let result = [];

            for (let c of plain) {
                let found = false;
                for (let i = 0; i < words.length; i++) {
                    if (words[i][0] === c) {
                        result.push(i + 1);
                        found = true;
                        break;
                    }
                }
                if (!found) result.push('?');
            }

            document.getElementById('mapping').innerHTML = words.map((w, i) => `<div class="map-pair"><span class="from">${i+1}</span><span class="to">${w}</span></div>`).join('');
            document.getElementById('ciphertext').textContent = result.join('-');
            drawBook(words);
        }

        function drawBook(words) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';

            let x = 20, y = 30;
            for (let i = 0; i < words.length; i++) {
                ctx.fillStyle = '#888';
                ctx.fillText(i + 1 + ':', x, y);
                ctx.fillStyle = '#00ff88';
                ctx.fillText(words[i], x + 25, y);
                y += 20;
                if (y > canvas.height - 20) { y = 30; x += 150; }
            }
        }

        function encryptStego() {
            let cover = document.getElementById('keyInput').value;
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            // First-letter null cipher
            let words = cover.split(/\s+/);
            let result = [];
            let msgIdx = 0;

            for (let word of words) {
                if (msgIdx < plain.length && word[0].toUpperCase() === plain[msgIdx]) {
                    result.push(word.toUpperCase());
                    msgIdx++;
                } else {
                    result.push(word.toLowerCase());
                }
            }

            document.getElementById('ciphertext').textContent = result.join(' ');
            document.getElementById('mapping').innerHTML = '<div class="map-pair"><span class="from">Hidden message: ' + plain.substring(0, msgIdx) + '</span></div>';
            drawStego(result, plain);
        }

        function drawStego(words, plain) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '14px Courier New';

            let x = 20, y = 40;
            for (let word of words) {
                const isUpper = word[0] === word[0].toUpperCase();
                ctx.fillStyle = isUpper ? '#00ff88' : '#666';
                ctx.fillText(word, x, y);
                x += ctx.measureText(word + ' ').width;
                if (x > canvas.width - 100) { x = 20; y += 25; }
            }

            ctx.fillStyle = '#888';
            ctx.fillText('Uppercase = hidden message letters', 20, canvas.height - 20);
        }

        function encryptPolybius() {
            let key = document.getElementById('keyInput').value.toUpperCase().replace(/[^A-Z]/g, '').replace(/J/g, 'I');
            const used = new Set();
            let grid = [];
            for (let c of key + alphabet.replace('J', '')) {
                if (!used.has(c)) { used.add(c); grid.push(c); }
            }

            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/J/g, 'I').replace(/[^A-Z]/g, '');
            let result = '';

            for (let c of plain) {
                const idx = grid.indexOf(c);
                if (idx >= 0) {
                    result += (Math.floor(idx / 5) + 1) + '' + (idx % 5 + 1) + ' ';
                }
            }

            document.getElementById('ciphertext').textContent = result.trim();
            drawPolybius(grid);
        }

        function drawPolybius(grid) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cellSize = 40;
            const startX = (canvas.width - cellSize * 6) / 2;
            const startY = 40;

            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';

            // Column headers
            for (let i = 1; i <= 5; i++) {
                ctx.fillStyle = '#ffaa00';
                ctx.fillText(i, startX + i * cellSize + cellSize/2, startY);
            }

            // Grid
            for (let r = 0; r < 5; r++) {
                ctx.fillStyle = '#ffaa00';
                ctx.fillText(r + 1, startX + cellSize/2, startY + (r + 1) * cellSize + 5);

                for (let c = 0; c < 5; c++) {
                    const x = startX + (c + 1) * cellSize;
                    const y = startY + (r + 1) * cellSize - cellSize + 10;

                    ctx.fillStyle = 'rgba(0,255,136,0.1)';
                    ctx.fillRect(x, y, cellSize - 2, cellSize - 2);
                    ctx.strokeStyle = 'rgba(0,255,136,0.3)';
                    ctx.strokeRect(x, y, cellSize - 2, cellSize - 2);

                    ctx.fillStyle = '#00ff88';
                    ctx.fillText(grid[r * 5 + c], x + cellSize/2, y + cellSize/2 + 5);
                }
            }
        }

        function encryptScytale() {
            const cols = parseInt(document.getElementById('keyInput').value) || 4;
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            while (plain.length % cols !== 0) plain += 'X';
            const rows = plain.length / cols;

            let result = '';
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows; r++) {
                    result += plain[r * cols + c];
                }
            }

            document.getElementById('ciphertext').textContent = result;
            drawScytale(plain, cols);
        }

        function drawScytale(plain, cols) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const rows = Math.ceil(plain.length / cols);
            const cellW = Math.min(35, (canvas.width - 100) / cols);
            const cellH = 30;
            const startX = (canvas.width - cols * cellW) / 2;

            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const idx = r * cols + c;
                    if (idx >= plain.length) continue;

                    const x = startX + c * cellW;
                    const y = 30 + r * cellH;

                    ctx.fillStyle = `hsl(${c * 40}, 70%, 30%)`;
                    ctx.fillRect(x, y, cellW - 2, cellH - 2);

                    ctx.fillStyle = '#fff';
                    ctx.fillText(plain[idx], x + cellW/2, y + cellH/2 + 5);
                }
            }

            ctx.fillStyle = '#888';
            ctx.fillText('Read by columns to get ciphertext', canvas.width/2, canvas.height - 20);
        }

        function encryptAtbash() {
            let plain = document.getElementById('plaintext').value.toUpperCase();
            let result = '';

            for (let c of plain) {
                const idx = alphabet.indexOf(c);
                result += idx >= 0 ? alphabet[25 - idx] : c;
            }

            showMapping(alphabet.split(''), alphabet.split('').reverse());
            document.getElementById('ciphertext').textContent = result;
            drawAtbash();
        }

        function drawAtbash() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('A ↔ Z    B ↔ Y    C ↔ X    ...    M ↔ N', canvas.width/2, 60);
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#888';
            ctx.fillText('Self-inverse: encrypting twice returns original', canvas.width/2, 120);
        }

        function encryptROT13() {
            let plain = document.getElementById('plaintext').value.toUpperCase();
            let result = '';

            for (let c of plain) {
                const idx = alphabet.indexOf(c);
                result += idx >= 0 ? alphabet[(idx + 13) % 26] : c;
            }

            const rot13Alphabet = alphabet.slice(13) + alphabet.slice(0, 13);
            showMapping(alphabet.split(''), rot13Alphabet.split(''));
            document.getElementById('ciphertext').textContent = result;
            drawROT13();
        }

        function drawROT13() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 18px Courier New';
            ctx.textAlign = 'center';

            const r = 80;
            const cx = canvas.width / 2;
            const cy = 120;

            ctx.strokeStyle = 'rgba(0,255,136,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();

            for (let i = 0; i < 26; i++) {
                const angle = (i / 26) * Math.PI * 2 - Math.PI / 2;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;

                ctx.fillStyle = i < 13 ? '#00ff88' : '#ff6666';
                ctx.fillText(alphabet[i], x, y + 5);

                // Draw connection line
                if (i < 13) {
                    const angle2 = ((i + 13) / 26) * Math.PI * 2 - Math.PI / 2;
                    const x2 = cx + Math.cos(angle2) * r;
                    const y2 = cy + Math.sin(angle2) * r;
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }

        function encryptKeyword() {
            let key = document.getElementById('keyInput').value.toUpperCase().replace(/[^A-Z]/g, '');
            const used = new Set();
            let cipherAlpha = '';
            for (let c of key + alphabet) {
                if (!used.has(c)) { used.add(c); cipherAlpha += c; }
            }

            let plain = document.getElementById('plaintext').value.toUpperCase();
            let result = '';

            for (let c of plain) {
                const idx = alphabet.indexOf(c);
                result += idx >= 0 ? cipherAlpha[idx] : c;
            }

            showMapping(alphabet.split(''), cipherAlpha.split(''));
            document.getElementById('ciphertext').textContent = result;
            drawKeyword(key, cipherAlpha);
        }

        function drawKeyword(key, cipherAlpha) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffaa00';
            ctx.fillText('Keyword: ' + key, canvas.width/2, 40);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Cipher Alphabet: ' + cipherAlpha, canvas.width/2, 80);
        }

        const morseCode = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..', ' ': '/'
        };

        function encryptMorse() {
            let plain = document.getElementById('plaintext').value.toUpperCase();
            let result = [];

            for (let c of plain) {
                result.push(morseCode[c] || c);
            }

            document.getElementById('mapping').innerHTML = Object.entries(morseCode).slice(0, 26).map(([k, v]) =>
                `<div class="map-pair"><span class="from">${k}</span><span class="to">${v}</span></div>`
            ).join('');
            document.getElementById('ciphertext').textContent = result.join(' ');
            drawMorse(result);
        }

        function drawMorse(codes) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const dotR = 8, dashW = 25, dashH = 8, gap = 5;
            let x = 30, y = 60;

            for (let code of codes) {
                if (code === '/') { x += 40; continue; }

                for (let symbol of code) {
                    if (symbol === '.') {
                        ctx.fillStyle = '#00ff88';
                        ctx.beginPath();
                        ctx.arc(x + dotR, y, dotR, 0, Math.PI * 2);
                        ctx.fill();
                        x += dotR * 2 + gap;
                    } else if (symbol === '-') {
                        ctx.fillStyle = '#00ff88';
                        ctx.fillRect(x, y - dashH/2, dashW, dashH);
                        x += dashW + gap;
                    }
                }
                x += 15;

                if (x > canvas.width - 50) { x = 30; y += 40; }
            }
        }

        function encryptPigpen() {
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');
            document.getElementById('ciphertext').textContent = '[See visual representation above]';
            document.getElementById('mapping').innerHTML = '';
            drawPigpen(plain);
        }

        function drawPigpen(plain) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the grid reference
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;

            // First grid (A-I)
            const g1x = 50, g1y = 30, gs = 25;
            ctx.strokeRect(g1x, g1y, gs * 3, gs * 3);
            ctx.beginPath();
            ctx.moveTo(g1x + gs, g1y); ctx.lineTo(g1x + gs, g1y + gs * 3);
            ctx.moveTo(g1x + gs * 2, g1y); ctx.lineTo(g1x + gs * 2, g1y + gs * 3);
            ctx.moveTo(g1x, g1y + gs); ctx.lineTo(g1x + gs * 3, g1y + gs);
            ctx.moveTo(g1x, g1y + gs * 2); ctx.lineTo(g1x + gs * 3, g1y + gs * 2);
            ctx.stroke();

            ctx.font = '10px Courier New';
            ctx.fillStyle = '#888';
            const letters1 = 'ABCDEFGHI';
            for (let i = 0; i < 9; i++) {
                ctx.fillText(letters1[i], g1x + (i % 3) * gs + gs/2 - 3, g1y + Math.floor(i / 3) * gs + gs/2 + 3);
            }

            // Encode message
            const pigpenShapes = {
                'A': (x, y) => { ctx.moveTo(x, y); ctx.lineTo(x, y + 20); ctx.lineTo(x + 20, y + 20); },
                'B': (x, y) => { ctx.moveTo(x, y + 20); ctx.lineTo(x + 10, y + 20); ctx.moveTo(x + 10, y); ctx.lineTo(x + 10, y + 20); },
                'C': (x, y) => { ctx.moveTo(x + 20, y); ctx.lineTo(x + 20, y + 20); ctx.lineTo(x, y + 20); },
                'D': (x, y) => { ctx.moveTo(x, y); ctx.lineTo(x, y + 20); ctx.moveTo(x, y + 10); ctx.lineTo(x + 20, y + 10); },
                'E': (x, y) => { ctx.moveTo(x, y + 10); ctx.lineTo(x + 20, y + 10); },
                'F': (x, y) => { ctx.moveTo(x + 20, y); ctx.lineTo(x + 20, y + 20); ctx.moveTo(x, y + 10); ctx.lineTo(x + 20, y + 10); },
                'G': (x, y) => { ctx.moveTo(x, y); ctx.lineTo(x + 20, y); ctx.lineTo(x + 20, y + 20); },
                'H': (x, y) => { ctx.moveTo(x + 10, y); ctx.lineTo(x + 10, y + 20); ctx.moveTo(x, y); ctx.lineTo(x + 20, y); },
                'I': (x, y) => { ctx.moveTo(x, y); ctx.lineTo(x, y + 20); ctx.lineTo(x + 20, y); }
            };

            // Draw encoded message
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            let px = 200, py = 80;

            for (let c of plain) {
                if (pigpenShapes[c]) {
                    ctx.beginPath();
                    pigpenShapes[c](px, py);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#00ff88';
                    ctx.font = 'bold 16px Courier New';
                    ctx.fillText(c, px + 5, py + 15);
                }

                px += 35;
                if (px > canvas.width - 50) { px = 200; py += 40; }
            }
        }

        document.getElementById('encryptBtn').addEventListener('click', demo.encrypt);
        document.getElementById('decryptBtn').addEventListener('click', demo.encrypt);
        document.getElementById('keyInput').addEventListener('input', demo.encrypt);
        document.getElementById('plaintext').addEventListener('input', demo.encrypt);

        demo.encrypt();

    // Expose for enhance.js keyboard shortcuts
    window.reset = function() { demo.encrypt(); };
    window.init = window.reset;
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
