<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classical Cipher Demo - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #e8e8f0;
        }
        .back-link {
            position: fixed; top: 15px; left: 15px;
            padding: 10px 18px; background: rgba(0,0,0,0.6);
            color: #00ff88; text-decoration: none; border-radius: 8px;
            font-size: 14px; z-index: 1000; border: 1px solid rgba(0,255,136,0.3);
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 70px 20px 40px;
        }
        h1 { font-size: 1.8rem; color: #00ff88; margin-bottom: 10px; text-align: center; }
        .desc { text-align: center; color: #888; margin-bottom: 30px; line-height: 1.6; }
        .panel {
            background: rgba(0,0,0,0.6);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(0,255,136,0.2);
        }
        .control-group { margin-bottom: 20px; }
        .control-group label { display: block; font-size: 0.85rem; color: #00ff88; margin-bottom: 8px; }
        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
        }
        textarea { min-height: 100px; resize: vertical; }
        .output-box {
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: 8px;
            padding: 15px;
            min-height: 80px;
            font-size: 1rem;
            word-break: break-all;
        }
        .grid-display {
            display: grid;
            gap: 2px;
            margin: 20px 0;
            justify-content: center;
        }
        .grid-cell {
            width: 35px; height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            font-weight: bold;
        }
        .grid-cell.highlight {
            background: #00ff88;
            color: #000;
        }
        .btn-row { display: flex; gap: 10px; margin-top: 15px; }
        .btn {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,255,136,0.4); }
        .btn.secondary { background: rgba(0,255,136,0.2); color: #00ff88; }
        .info-box {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.8rem;
            line-height: 1.6;
            color: #aaa;
        }
        #canvas { border-radius: 10px; margin: 20px auto; display: block; }
        .stats { display: flex; gap: 20px; flex-wrap: wrap; margin: 20px 0; }
        .stat { background: rgba(0,255,136,0.1); padding: 10px 15px; border-radius: 8px; }
        .stat-value { font-size: 1.5rem; color: #00ff88; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1 id="title">Classical Cipher</h1>
        <p class="desc" id="description">Interactive cipher visualization</p>

        <div class="panel">
            <div class="control-group">
                <label id="keyLabel">Key</label>
                <input type="text" id="keyInput" value="SECRET">
            </div>
            <div class="control-group">
                <label>Plaintext</label>
                <textarea id="plaintext">HELLO WORLD</textarea>
            </div>
            <canvas id="canvas" width="800" height="300"></canvas>
            <div class="control-group">
                <label>Ciphertext</label>
                <div class="output-box" id="ciphertext"></div>
            </div>
            <div class="btn-row">
                <button class="btn" id="encryptBtn">Encrypt</button>
                <button class="btn secondary" id="decryptBtn">Decrypt</button>
            </div>
        </div>

        <div class="info-box" id="infoBox">
            Cipher information will appear here.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        const demos = {
            '04-playfair-cipher': {
                title: 'Playfair Cipher',
                desc: 'A digraph substitution cipher using a 5x5 key square. Encrypts pairs of letters at a time.',
                keyLabel: 'Keyword (I/J combined)',
                info: 'Invented by Charles Wheatstone in 1854. Uses a 5x5 grid where I and J share a cell. Pairs of letters are encrypted based on their positions in the grid: same row = shift right, same column = shift down, rectangle = swap columns.',
                init: initPlayfair,
                encrypt: encryptPlayfair,
                draw: drawPlayfair
            },
            '05-hill-cipher': {
                title: 'Hill Cipher',
                desc: 'Uses matrix multiplication for encryption. Each block of letters is treated as a vector.',
                keyLabel: 'Key Matrix (2x2, e.g., 3,2,5,7)',
                info: 'Invented by Lester Hill in 1929. The key is a matrix that must be invertible modulo 26. Plaintext is broken into vectors, multiplied by the key matrix, and reduced mod 26.',
                init: initHill,
                encrypt: encryptHill,
                draw: drawHill
            },
            '06-rail-fence': {
                title: 'Rail Fence Cipher',
                desc: 'A transposition cipher that writes the message in a zigzag pattern across multiple rails.',
                keyLabel: 'Number of Rails',
                info: 'One of the simplest transposition ciphers. The plaintext is written diagonally across "rails", then read off row by row. Easy to implement but also easy to break.',
                init: initRailFence,
                encrypt: encryptRailFence,
                draw: drawRailFence
            },
            '07-columnar-transposition': {
                title: 'Columnar Transposition',
                desc: 'Rearranges the plaintext by writing it in rows and reading columns in a key-determined order.',
                keyLabel: 'Keyword',
                info: 'Used extensively in WWI and WWII. The keyword determines the column reading order (alphabetical order of key letters). Double transposition was common for added security.',
                init: initColumnar,
                encrypt: encryptColumnar,
                draw: drawColumnar
            },
            '08-affine-cipher': {
                title: 'Affine Cipher',
                desc: 'Combines multiplicative and additive ciphers: E(x) = (ax + b) mod 26',
                keyLabel: 'a,b (e.g., 5,8 where gcd(a,26)=1)',
                info: 'A monoalphabetic substitution cipher. The value "a" must be coprime with 26 (valid values: 1,3,5,7,9,11,15,17,19,21,23,25). Caesar cipher is a special case with a=1.',
                init: initAffine,
                encrypt: encryptAffine,
                draw: drawAffine
            },
            '09-one-time-pad': {
                title: 'One-Time Pad',
                desc: 'The only provably unbreakable cipher when used correctly with a truly random key.',
                keyLabel: 'Random Key (same length as message)',
                info: 'Invented by Gilbert Vernam in 1917. Requirements: key must be truly random, at least as long as the message, never reused, and kept secret. When done correctly, provides perfect secrecy.',
                init: initOTP,
                encrypt: encryptOTP,
                draw: drawOTP
            },
            '10-frequency-analysis': {
                title: 'Frequency Analysis',
                desc: 'A cryptanalysis technique that exploits the non-uniform distribution of letters in natural language.',
                keyLabel: 'Ciphertext to Analyze',
                info: 'In English, E (12.7%), T (9.1%), A (8.2%), O (7.5%), I (7.0%), N (6.7%) are most common. By matching ciphertext frequencies to expected frequencies, substitution ciphers can be broken.',
                init: initFrequency,
                encrypt: analyzeFrequency,
                draw: drawFrequency
            }
        };

        const filename = window.location.pathname.split('/').pop().replace('.html', '');
        const demo = demos[filename] || demos['04-playfair-cipher'];

        document.getElementById('title').textContent = demo.title;
        document.getElementById('description').textContent = demo.desc;
        document.getElementById('keyLabel').textContent = demo.keyLabel;
        document.getElementById('infoBox').innerHTML = '<strong>About:</strong> ' + demo.info;
        document.title = demo.title + ' - CCAB';

        let state = {};

        // Playfair
        function initPlayfair() {
            document.getElementById('keyInput').value = 'MONARCHY';
            state.grid = [];
        }

        function createPlayfairGrid(key) {
            key = key.toUpperCase().replace(/J/g, 'I').replace(/[^A-Z]/g, '');
            const used = new Set();
            const grid = [];
            for (let c of key + alphabet.replace('J', '')) {
                if (!used.has(c)) { used.add(c); grid.push(c); }
            }
            return grid;
        }

        function encryptPlayfair() {
            const key = document.getElementById('keyInput').value;
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/J/g, 'I').replace(/[^A-Z]/g, '');
            const grid = createPlayfairGrid(key);
            state.grid = grid;

            // Prepare digraphs
            let digraphs = [];
            let i = 0;
            while (i < plain.length) {
                let a = plain[i];
                let b = (i + 1 < plain.length) ? plain[i + 1] : 'X';
                if (a === b) { b = 'X'; i++; } else { i += 2; }
                digraphs.push([a, b]);
            }

            let result = '';
            for (let [a, b] of digraphs) {
                const posA = grid.indexOf(a), posB = grid.indexOf(b);
                const rowA = Math.floor(posA / 5), colA = posA % 5;
                const rowB = Math.floor(posB / 5), colB = posB % 5;

                if (rowA === rowB) {
                    result += grid[rowA * 5 + (colA + 1) % 5] + grid[rowB * 5 + (colB + 1) % 5];
                } else if (colA === colB) {
                    result += grid[((rowA + 1) % 5) * 5 + colA] + grid[((rowB + 1) % 5) * 5 + colB];
                } else {
                    result += grid[rowA * 5 + colB] + grid[rowB * 5 + colA];
                }
            }

            document.getElementById('ciphertext').textContent = result;
            demo.draw();
        }

        function drawPlayfair() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const grid = state.grid;
            if (!grid || grid.length === 0) return;

            const cellSize = 50;
            const startX = (canvas.width - cellSize * 5) / 2;
            const startY = 50;

            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < 25; i++) {
                const x = startX + (i % 5) * cellSize;
                const y = startY + Math.floor(i / 5) * cellSize;

                ctx.fillStyle = 'rgba(0,255,136,0.1)';
                ctx.fillRect(x, y, cellSize - 2, cellSize - 2);
                ctx.strokeStyle = 'rgba(0,255,136,0.3)';
                ctx.strokeRect(x, y, cellSize - 2, cellSize - 2);

                ctx.fillStyle = '#00ff88';
                ctx.fillText(grid[i], x + cellSize/2, y + cellSize/2);
            }
        }

        // Hill Cipher
        function initHill() { document.getElementById('keyInput').value = '3,2,5,7'; }

        function encryptHill() {
            const keyStr = document.getElementById('keyInput').value;
            const keyVals = keyStr.split(',').map(Number);
            if (keyVals.length !== 4) return;

            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');
            if (plain.length % 2 !== 0) plain += 'X';

            state.matrix = [[keyVals[0], keyVals[1]], [keyVals[2], keyVals[3]]];

            let result = '';
            for (let i = 0; i < plain.length; i += 2) {
                const p1 = alphabet.indexOf(plain[i]);
                const p2 = alphabet.indexOf(plain[i + 1]);
                const c1 = (keyVals[0] * p1 + keyVals[1] * p2) % 26;
                const c2 = (keyVals[2] * p1 + keyVals[3] * p2) % 26;
                result += alphabet[c1] + alphabet[c2];
            }

            document.getElementById('ciphertext').textContent = result;
            demo.draw();
        }

        function drawHill() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.matrix) return;

            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Key Matrix:', canvas.width/2, 50);
            ctx.fillText(`[ ${state.matrix[0][0]}  ${state.matrix[0][1]} ]`, canvas.width/2, 100);
            ctx.fillText(`[ ${state.matrix[1][0]}  ${state.matrix[1][1]} ]`, canvas.width/2, 140);

            ctx.font = '16px Courier New';
            ctx.fillStyle = '#888';
            ctx.fillText('C = K × P (mod 26)', canvas.width/2, 200);
        }

        // Rail Fence
        function initRailFence() { document.getElementById('keyInput').value = '3'; }

        function encryptRailFence() {
            const rails = parseInt(document.getElementById('keyInput').value) || 3;
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            const fence = Array(rails).fill().map(() => []);
            let rail = 0, dir = 1;

            for (let char of plain) {
                fence[rail].push(char);
                rail += dir;
                if (rail === 0 || rail === rails - 1) dir = -dir;
            }

            state.fence = fence;
            document.getElementById('ciphertext').textContent = fence.flat().join('');
            demo.draw();
        }

        function drawRailFence() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.fence) return;

            const plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');
            const rails = state.fence.length;
            const cellW = Math.min(30, (canvas.width - 100) / plain.length);
            const cellH = 40;
            const startX = 50;
            const startY = 50;

            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';

            let rail = 0, dir = 1;
            for (let i = 0; i < plain.length; i++) {
                const x = startX + i * cellW;
                const y = startY + rail * cellH;

                ctx.fillStyle = 'rgba(0,255,136,0.2)';
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#00ff88';
                ctx.fillText(plain[i], x, y + 5);

                rail += dir;
                if (rail === 0 || rail === rails - 1) dir = -dir;
            }
        }

        // Columnar
        function initColumnar() { document.getElementById('keyInput').value = 'ZEBRA'; }

        function encryptColumnar() {
            const key = document.getElementById('keyInput').value.toUpperCase();
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            const numCols = key.length;
            while (plain.length % numCols !== 0) plain += 'X';

            const rows = [];
            for (let i = 0; i < plain.length; i += numCols) {
                rows.push(plain.slice(i, i + numCols).split(''));
            }

            const order = [...key].map((c, i) => [c, i]).sort((a, b) => a[0].localeCompare(b[0])).map(x => x[1]);

            let result = '';
            for (let col of order) {
                for (let row of rows) {
                    result += row[col];
                }
            }

            state.rows = rows;
            state.key = key;
            state.order = order;
            document.getElementById('ciphertext').textContent = result;
            demo.draw();
        }

        function drawColumnar() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.rows) return;

            const cellW = 40, cellH = 35;
            const startX = (canvas.width - state.key.length * cellW) / 2;
            const startY = 30;

            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';

            // Key row with numbers
            for (let i = 0; i < state.key.length; i++) {
                ctx.fillStyle = '#ffaa00';
                ctx.fillText(state.key[i], startX + i * cellW + cellW/2, startY);
                ctx.fillStyle = '#888';
                ctx.fillText(state.order.indexOf(i) + 1, startX + i * cellW + cellW/2, startY + 20);
            }

            // Grid
            for (let r = 0; r < state.rows.length; r++) {
                for (let c = 0; c < state.rows[r].length; c++) {
                    const x = startX + c * cellW;
                    const y = startY + 40 + r * cellH;

                    ctx.fillStyle = 'rgba(0,255,136,0.1)';
                    ctx.fillRect(x, y, cellW - 2, cellH - 2);
                    ctx.strokeStyle = 'rgba(0,255,136,0.3)';
                    ctx.strokeRect(x, y, cellW - 2, cellH - 2);

                    ctx.fillStyle = '#00ff88';
                    ctx.fillText(state.rows[r][c], x + cellW/2, y + cellH/2 + 5);
                }
            }
        }

        // Affine
        function initAffine() { document.getElementById('keyInput').value = '5,8'; }

        function encryptAffine() {
            const [a, b] = document.getElementById('keyInput').value.split(',').map(Number);
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            let result = '';
            for (let char of plain) {
                const x = alphabet.indexOf(char);
                const y = (a * x + b) % 26;
                result += alphabet[y];
            }

            state.a = a;
            state.b = b;
            document.getElementById('ciphertext').textContent = result;
            demo.draw();
        }

        function drawAffine() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff88';
            ctx.fillText(`E(x) = (${state.a || 5}x + ${state.b || 8}) mod 26`, canvas.width/2, 80);

            ctx.font = '14px Courier New';
            ctx.fillStyle = '#888';

            for (let i = 0; i < 26; i++) {
                const x = 50 + (i % 13) * 55;
                const y = 130 + Math.floor(i / 13) * 60;
                const enc = ((state.a || 5) * i + (state.b || 8)) % 26;

                ctx.fillStyle = '#666';
                ctx.fillText(alphabet[i], x, y);
                ctx.fillStyle = '#00ff88';
                ctx.fillText('→ ' + alphabet[enc], x, y + 20);
            }
        }

        // One-Time Pad
        function initOTP() {
            const randomKey = Array(11).fill().map(() => alphabet[Math.floor(Math.random() * 26)]).join('');
            document.getElementById('keyInput').value = randomKey;
        }

        function encryptOTP() {
            let key = document.getElementById('keyInput').value.toUpperCase().replace(/[^A-Z]/g, '');
            let plain = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            while (key.length < plain.length) key += alphabet[Math.floor(Math.random() * 26)];
            document.getElementById('keyInput').value = key.slice(0, plain.length);

            let result = '';
            state.steps = [];
            for (let i = 0; i < plain.length; i++) {
                const p = alphabet.indexOf(plain[i]);
                const k = alphabet.indexOf(key[i]);
                const c = (p + k) % 26;
                result += alphabet[c];
                state.steps.push({ p: plain[i], k: key[i], c: alphabet[c] });
            }

            document.getElementById('ciphertext').textContent = result;
            demo.draw();
        }

        function drawOTP() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.steps) return;

            const cellW = Math.min(50, (canvas.width - 100) / state.steps.length);
            const startX = (canvas.width - state.steps.length * cellW) / 2;

            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';

            ctx.fillStyle = '#888';
            ctx.fillText('Plain:', startX - 40, 60);
            ctx.fillText('Key:', startX - 40, 110);
            ctx.fillText('Cipher:', startX - 40, 160);

            for (let i = 0; i < state.steps.length; i++) {
                const x = startX + i * cellW + cellW/2;
                const s = state.steps[i];

                ctx.fillStyle = '#6666ff';
                ctx.fillText(s.p, x, 60);
                ctx.fillStyle = '#ff6666';
                ctx.fillText(s.k, x, 110);
                ctx.fillStyle = '#00ff88';
                ctx.fillText(s.c, x, 160);

                ctx.strokeStyle = '#444';
                ctx.beginPath();
                ctx.moveTo(x, 70);
                ctx.lineTo(x, 145);
                ctx.stroke();
            }
        }

        // Frequency Analysis
        function initFrequency() {
            document.getElementById('keyInput').style.display = 'none';
            document.getElementById('keyLabel').style.display = 'none';
        }

        function analyzeFrequency() {
            let text = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');

            const freq = {};
            for (let c of alphabet) freq[c] = 0;
            for (let c of text) if (freq[c] !== undefined) freq[c]++;

            state.freq = freq;
            state.total = text.length;

            const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]);
            document.getElementById('ciphertext').textContent = sorted.slice(0, 10).map(([c, n]) => `${c}:${(n/text.length*100).toFixed(1)}%`).join(' ');
            demo.draw();
        }

        function drawFrequency() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.freq) return;

            const maxFreq = Math.max(...Object.values(state.freq));
            const barW = (canvas.width - 100) / 26;
            const maxH = 200;

            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';

            // Expected frequencies (English)
            const expected = {A:8.2,B:1.5,C:2.8,D:4.3,E:12.7,F:2.2,G:2.0,H:6.1,I:7.0,J:0.15,K:0.77,L:4.0,M:2.4,N:6.7,O:7.5,P:1.9,Q:0.095,R:6.0,S:6.3,T:9.1,U:2.8,V:0.98,W:2.4,X:0.15,Y:2.0,Z:0.074};

            for (let i = 0; i < 26; i++) {
                const c = alphabet[i];
                const x = 50 + i * barW;
                const actualPct = state.total > 0 ? (state.freq[c] / state.total) * 100 : 0;
                const h = maxFreq > 0 ? (state.freq[c] / maxFreq) * maxH : 0;

                // Actual bar
                ctx.fillStyle = 'rgba(0,255,136,0.7)';
                ctx.fillRect(x, 250 - h, barW - 4, h);

                // Expected line
                const expH = (expected[c] / 13) * maxH;
                ctx.strokeStyle = '#ff6666';
                ctx.beginPath();
                ctx.moveTo(x, 250 - expH);
                ctx.lineTo(x + barW - 4, 250 - expH);
                ctx.stroke();

                // Label
                ctx.fillStyle = '#888';
                ctx.fillText(c, x + (barW-4)/2, 265);
            }

            ctx.fillStyle = '#00ff88';
            ctx.fillText('Green = Actual frequency', 200, 20);
            ctx.fillStyle = '#ff6666';
            ctx.fillText('Red = Expected English frequency', 550, 20);
        }

        // Initialize
        demo.init();
        document.getElementById('encryptBtn').addEventListener('click', demo.encrypt);
        document.getElementById('decryptBtn').addEventListener('click', demo.encrypt);
        document.getElementById('keyInput').addEventListener('input', demo.encrypt);
        document.getElementById('plaintext').addEventListener('input', demo.encrypt);

        demo.encrypt();

    // Expose for enhance.js keyboard shortcuts
    window.reset = function() { demo.encrypt(); };
    window.init = window.reset;
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
