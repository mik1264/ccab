<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Gray-Scott Reaction-Diffusion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .control-group {
            margin: 8px 0;
        }
        label {
            display: inline-block;
            width: 120px;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            margin: 10px 5px 0 0;
            padding: 8px 15px;
            background: #667eea;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #764ba2;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <h3>Gray-Scott Parameters</h3>
        <div class="control-group">
            <label>Feed (F):</label>
            <input type="range" id="feed" min="0" max="0.1" step="0.001" value="0.055">
            <span id="feedVal">0.055</span>
        </div>
        <div class="control-group">
            <label>Kill (k):</label>
            <input type="range" id="kill" min="0" max="0.1" step="0.001" value="0.062">
            <span id="killVal">0.062</span>
        </div>
        <div class="control-group">
            <label>dA:</label>
            <input type="range" id="dA" min="0" max="1" step="0.01" value="1.0">
            <span id="dAVal">1.0</span>
        </div>
        <div class="control-group">
            <label>dB:</label>
            <input type="range" id="dB" min="0" max="1" step="0.01" value="0.5">
            <span id="dBVal">0.5</span>
        </div>
        <button onclick="reset()">Reset</button>
        <button onclick="randomSeed()">Random Seed</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported');
        }

        const width = 512;
        const height = 512;
        canvas.width = width;
        canvas.height = height;

        // Shader sources
        const vertexShaderSource = `#version 300 es
            in vec2 position;
            out vec2 uv;
            void main() {
                uv = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const computeShaderSource = `#version 300 es
            precision highp float;
            uniform sampler2D state;
            uniform vec2 resolution;
            uniform float feed;
            uniform float kill;
            uniform float dA;
            uniform float dB;
            uniform float dt;
            in vec2 uv;
            out vec4 fragColor;

            void main() {
                vec2 pixel = 1.0 / resolution;

                vec2 state_c = texture(state, uv).xy;
                float a = state_c.x;
                float b = state_c.y;

                // Laplacian using 3x3 kernel
                vec2 laplacian = vec2(0.0);
                laplacian += texture(state, uv + vec2(-pixel.x, 0.0)).xy * 0.2;
                laplacian += texture(state, uv + vec2(pixel.x, 0.0)).xy * 0.2;
                laplacian += texture(state, uv + vec2(0.0, -pixel.y)).xy * 0.2;
                laplacian += texture(state, uv + vec2(0.0, pixel.y)).xy * 0.2;
                laplacian += texture(state, uv + vec2(-pixel.x, -pixel.y)).xy * 0.05;
                laplacian += texture(state, uv + vec2(pixel.x, -pixel.y)).xy * 0.05;
                laplacian += texture(state, uv + vec2(-pixel.x, pixel.y)).xy * 0.05;
                laplacian += texture(state, uv + vec2(pixel.x, pixel.y)).xy * 0.05;
                laplacian -= state_c * 1.0;

                // Gray-Scott equations
                float abb = a * b * b;
                float da = dA * laplacian.x - abb + feed * (1.0 - a);
                float db = dB * laplacian.y + abb - (kill + feed) * b;

                a += da * dt;
                b += db * dt;

                fragColor = vec4(a, b, 0.0, 1.0);
            }
        `;

        const displayShaderSource = `#version 300 es
            precision highp float;
            uniform sampler2D state;
            in vec2 uv;
            out vec4 fragColor;

            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.0, 0.33, 0.67);
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                float b = texture(state, uv).y;
                vec3 color = palette(b * 4.0);
                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(vertSource, fragSource) {
            const program = gl.createProgram();
            const vertShader = compileShader(gl.VERTEX_SHADER, vertSource);
            const fragShader = compileShader(gl.FRAGMENT_SHADER, fragSource);
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const computeProgram = createProgram(vertexShaderSource, computeShaderSource);
        const displayProgram = createProgram(vertexShaderSource, displayShaderSource);

        // Quad buffer
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Create textures
        function createTexture() {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, width, height, 0, gl.RG, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return texture;
        }

        const textures = [createTexture(), createTexture()];
        const framebuffers = [gl.createFramebuffer(), gl.createFramebuffer()];

        for (let i = 0; i < 2; i++) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[i], 0);
        }

        // Initialize state
        function initializeState() {
            const data = new Float32Array(width * height * 2);
            for (let i = 0; i < width * height; i++) {
                data[i * 2] = 1.0; // A
                data[i * 2 + 1] = 0.0; // B
            }

            // Add seed in center
            const cx = width / 2, cy = height / 2, radius = 20;
            for (let y = -radius; y < radius; y++) {
                for (let x = -radius; x < radius; x++) {
                    if (x*x + y*y < radius*radius) {
                        const idx = ((cy + y) * width + (cx + x)) * 2;
                        data[idx + 1] = 1.0; // B
                    }
                }
            }

            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, width, height, 0, gl.RG, gl.FLOAT, data);
        }

        function reset() {
            initializeState();
        }

        function randomSeed() {
            const data = new Float32Array(width * height * 2);
            for (let i = 0; i < width * height; i++) {
                data[i * 2] = 1.0;
                data[i * 2 + 1] = Math.random() < 0.05 ? 1.0 : 0.0;
            }
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, width, height, 0, gl.RG, gl.FLOAT, data);
        }

        initializeState();

        // Controls
        const feedSlider = document.getElementById('feed');
        const killSlider = document.getElementById('kill');
        const dASlider = document.getElementById('dA');
        const dBSlider = document.getElementById('dB');

        feedSlider.oninput = () => document.getElementById('feedVal').textContent = feedSlider.value;
        killSlider.oninput = () => document.getElementById('killVal').textContent = killSlider.value;
        dASlider.oninput = () => document.getElementById('dAVal').textContent = dASlider.value;
        dBSlider.oninput = () => document.getElementById('dBVal').textContent = dBSlider.value;

        let currentBuffer = 0;

        function render() {
            // Compute step
            gl.useProgram(computeProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1 - currentBuffer]);
            gl.viewport(0, 0, width, height);

            const posLoc = gl.getAttribLocation(computeProgram, 'position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBuffer]);
            gl.uniform1i(gl.getUniformLocation(computeProgram, 'state'), 0);
            gl.uniform2f(gl.getUniformLocation(computeProgram, 'resolution'), width, height);
            gl.uniform1f(gl.getUniformLocation(computeProgram, 'feed'), parseFloat(feedSlider.value));
            gl.uniform1f(gl.getUniformLocation(computeProgram, 'kill'), parseFloat(killSlider.value));
            gl.uniform1f(gl.getUniformLocation(computeProgram, 'dA'), parseFloat(dASlider.value));
            gl.uniform1f(gl.getUniformLocation(computeProgram, 'dB'), parseFloat(dBSlider.value));
            gl.uniform1f(gl.getUniformLocation(computeProgram, 'dt'), 1.0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            currentBuffer = 1 - currentBuffer;

            // Display
            gl.useProgram(displayProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            const displayPosLoc = gl.getAttribLocation(displayProgram, 'position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(displayPosLoc);
            gl.vertexAttribPointer(displayPosLoc, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBuffer]);
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'state'), 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
