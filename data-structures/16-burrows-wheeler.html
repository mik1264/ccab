<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burrows-Wheeler Transform + FM-Index Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0c1821 0%, #1b2838 50%, #0d1f2d 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #00d4aa, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #8899a6;
            font-size: 1rem;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4ecdc4;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .controls {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.85rem;
            color: #8899a6;
        }

        input[type="text"] {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 10px 14px;
            color: #fff;
            font-size: 1rem;
            font-family: 'Consolas', 'Monaco', monospace;
            width: 200px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #4ecdc4;
        }

        button {
            background: linear-gradient(135deg, #00d4aa, #4ecdc4);
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            color: #0c1821;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 20px;
        }

        .panel h2 {
            font-size: 1.1rem;
            color: #4ecdc4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel h2 .step-badge {
            background: rgba(78, 205, 196, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        /* Rotation Matrix */
        .rotation-matrix {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            overflow-x: auto;
        }

        .rotation-row {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .rotation-row.highlight {
            background: rgba(78, 205, 196, 0.15);
        }

        .rotation-row.current {
            background: rgba(255, 215, 0, 0.2);
            border-left: 3px solid gold;
        }

        .row-index {
            width: 30px;
            color: #666;
            font-size: 0.8rem;
        }

        .rotation-chars {
            display: flex;
        }

        .char {
            width: 24px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .char.first-col {
            background: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            font-weight: bold;
        }

        .char.last-col {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
            font-weight: bold;
        }

        .char.match {
            background: rgba(255, 215, 0, 0.4);
            color: gold;
        }

        /* BWT Result */
        .bwt-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 15px 0;
        }

        .bwt-char {
            width: 32px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.4);
            border-radius: 6px;
            font-family: monospace;
            font-size: 1.1rem;
            color: #ff6b6b;
            transition: all 0.3s;
        }

        .bwt-char.active {
            transform: scale(1.2);
            background: rgba(255, 215, 0, 0.3);
            border-color: gold;
            color: gold;
        }

        /* FM-Index Tables */
        .fm-tables {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 20px;
        }

        .count-table, .occ-table {
            font-family: monospace;
            font-size: 0.85rem;
        }

        .table-title {
            font-size: 0.9rem;
            color: #8899a6;
            margin-bottom: 8px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th, td {
            padding: 6px 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        td {
            background: rgba(0,0,0,0.2);
        }

        td.highlight {
            background: rgba(255, 215, 0, 0.2);
            color: gold;
        }

        /* Search Visualization */
        .search-steps {
            margin-top: 15px;
        }

        .search-step {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 3px solid transparent;
        }

        .search-step.active {
            border-left-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .search-step.found {
            border-left-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .search-step.not-found {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .step-char {
            font-family: monospace;
            font-size: 1.2rem;
            color: gold;
        }

        .step-range {
            font-family: monospace;
            color: #4ecdc4;
        }

        .step-formula {
            font-family: monospace;
            font-size: 0.85rem;
            color: #8899a6;
        }

        /* Info Box */
        .info-box {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .info-box code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Results */
        .results {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
        }

        .results.no-match {
            background: rgba(255, 107, 107, 0.1);
            border-color: rgba(255, 107, 107, 0.3);
        }

        .result-positions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .position-badge {
            background: rgba(0, 255, 136, 0.2);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Original String Display */
        .original-display {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin: 10px 0;
            font-family: monospace;
        }

        .orig-char {
            width: 28px;
            height: 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        .orig-char .idx {
            font-size: 0.65rem;
            color: #666;
        }

        .orig-char .letter {
            font-size: 1rem;
        }

        .orig-char.match-pos {
            background: rgba(0, 255, 136, 0.3);
            border: 1px solid #00ff88;
        }

        /* Loading indicator */
        .loading {
            text-align: center;
            padding: 40px;
            color: #8899a6;
        }

        .suffix-array {
            font-family: monospace;
            font-size: 0.85rem;
            margin-top: 10px;
        }

        .sa-item {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-right: 8px;
            margin-bottom: 4px;
        }

        .sa-index {
            color: #666;
            font-size: 0.75rem;
        }

        .sa-value {
            background: rgba(78, 205, 196, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Burrows-Wheeler Transform + FM-Index</h1>
            <p class="subtitle">Explore rotations, BWT construction, and backward search step-by-step</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Input String</label>
                <input type="text" id="inputString" value="banana" placeholder="Enter text...">
            </div>
            <div class="control-group">
                <label>Search Pattern</label>
                <input type="text" id="searchPattern" value="ana" placeholder="Pattern to find...">
            </div>
            <button id="buildBtn">Build BWT & FM-Index</button>
            <button id="searchBtn" class="btn-secondary" disabled>Backward Search</button>
            <button id="stepBtn" class="btn-secondary" disabled>Step Through</button>
            <button id="resetBtn" class="btn-secondary">Reset</button>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2><span class="step-badge">1</span> Rotation Matrix (Sorted)</h2>
                <p style="font-size: 0.85rem; color: #8899a6; margin-bottom: 10px;">
                    All cyclic rotations of the input string (+ $), sorted lexicographically.
                    <span style="color: #4ecdc4;">First column (F)</span> |
                    <span style="color: #ff6b6b;">Last column (L) = BWT</span>
                </p>
                <div id="rotationMatrix" class="rotation-matrix">
                    <div class="loading">Enter a string and click "Build"</div>
                </div>
            </div>

            <div class="panel">
                <h2><span class="step-badge">2</span> BWT Result & Suffix Array</h2>
                <p style="font-size: 0.85rem; color: #8899a6; margin-bottom: 10px;">
                    The last column forms the BWT string. Suffix Array gives original positions.
                </p>
                <div id="bwtResult">
                    <div class="loading">Build the transform first</div>
                </div>

                <h2 style="margin-top: 25px;"><span class="step-badge">3</span> FM-Index Tables</h2>
                <div id="fmTables">
                    <div class="loading">Build the index first</div>
                </div>
            </div>

            <div class="panel" style="grid-column: 1 / -1;">
                <h2><span class="step-badge">4</span> Backward Search</h2>
                <p style="font-size: 0.85rem; color: #8899a6; margin-bottom: 10px;">
                    FM-Index enables O(m) pattern matching by searching backwards through the pattern.
                </p>
                <div id="searchVisualization">
                    <div class="info-box">
                        <strong>How Backward Search Works:</strong><br>
                        Starting from the last character of the pattern, we maintain a range [sp, ep] in the suffix array.
                        For each character c, we update: <code>sp = C[c] + Occ(c, sp-1)</code> and <code>ep = C[c] + Occ(c, ep) - 1</code><br>
                        When sp ≤ ep, matches exist at positions SA[sp..ep].
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // BWT and FM-Index implementation
        class BWTFMIndex {
            constructor(text) {
                this.originalText = text;
                this.text = text + '$'; // Add end marker
                this.n = this.text.length;
                this.rotations = [];
                this.sortedRotations = [];
                this.bwt = '';
                this.suffixArray = [];
                this.firstColumn = '';
                this.alphabet = [];
                this.C = {}; // Count array: C[c] = number of chars < c
                this.Occ = {}; // Occurrence array: Occ[c][i] = count of c in BWT[0..i-1]

                this.build();
            }

            build() {
                // Generate all rotations
                this.rotations = [];
                for (let i = 0; i < this.n; i++) {
                    this.rotations.push({
                        str: this.text.slice(i) + this.text.slice(0, i),
                        originalIndex: i
                    });
                }

                // Sort rotations lexicographically
                this.sortedRotations = [...this.rotations].sort((a, b) =>
                    a.str.localeCompare(b.str)
                );

                // Extract BWT (last column) and suffix array
                this.bwt = this.sortedRotations.map(r => r.str[this.n - 1]).join('');
                this.suffixArray = this.sortedRotations.map(r => r.originalIndex);
                this.firstColumn = this.sortedRotations.map(r => r.str[0]).join('');

                // Build alphabet
                this.alphabet = [...new Set(this.text)].sort();

                // Build C array
                this.C = {};
                let count = 0;
                for (const c of this.alphabet) {
                    this.C[c] = count;
                    count += this.firstColumn.split(c).length - 1;
                }

                // Build Occ array (occurrence counts)
                this.Occ = {};
                for (const c of this.alphabet) {
                    this.Occ[c] = [0];
                    let cnt = 0;
                    for (let i = 0; i < this.n; i++) {
                        if (this.bwt[i] === c) cnt++;
                        this.Occ[c].push(cnt);
                    }
                }
            }

            // Backward search - returns generator for step-by-step visualization
            *backwardSearch(pattern) {
                let sp = 0;
                let ep = this.n - 1;

                // Process pattern from right to left
                for (let i = pattern.length - 1; i >= 0; i--) {
                    const c = pattern[i];

                    if (!(c in this.C)) {
                        yield {
                            char: c,
                            charIndex: i,
                            sp: sp,
                            ep: ep,
                            newSp: -1,
                            newEp: -1,
                            found: false,
                            message: `Character '${c}' not in alphabet`
                        };
                        return;
                    }

                    const newSp = this.C[c] + this.Occ[c][sp];
                    const newEp = this.C[c] + this.Occ[c][ep + 1] - 1;

                    yield {
                        char: c,
                        charIndex: i,
                        sp: sp,
                        ep: ep,
                        newSp: newSp,
                        newEp: newEp,
                        C_c: this.C[c],
                        Occ_sp: this.Occ[c][sp],
                        Occ_ep: this.Occ[c][ep + 1],
                        found: newSp <= newEp,
                        message: newSp <= newEp
                            ? `Range updated to [${newSp}, ${newEp}]`
                            : `No matches (range became empty)`
                    };

                    if (newSp > newEp) {
                        return;
                    }

                    sp = newSp;
                    ep = newEp;
                }

                // Return positions
                const positions = [];
                for (let i = sp; i <= ep; i++) {
                    positions.push(this.suffixArray[i]);
                }

                yield {
                    complete: true,
                    sp: sp,
                    ep: ep,
                    positions: positions.sort((a, b) => a - b),
                    message: `Found ${positions.length} occurrence(s)`
                };
            }
        }

        // UI State
        let fmIndex = null;
        let searchGenerator = null;
        let searchSteps = [];
        let currentStepIndex = -1;

        // DOM Elements
        const inputString = document.getElementById('inputString');
        const searchPattern = document.getElementById('searchPattern');
        const buildBtn = document.getElementById('buildBtn');
        const searchBtn = document.getElementById('searchBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const rotationMatrix = document.getElementById('rotationMatrix');
        const bwtResult = document.getElementById('bwtResult');
        const fmTables = document.getElementById('fmTables');
        const searchVisualization = document.getElementById('searchVisualization');

        // Render rotation matrix
        function renderRotationMatrix(highlightIndices = []) {
            if (!fmIndex) return;

            let html = '';
            fmIndex.sortedRotations.forEach((rotation, idx) => {
                const isHighlight = highlightIndices.includes(idx);
                html += `<div class="rotation-row ${isHighlight ? 'highlight' : ''}">`;
                html += `<span class="row-index">${idx}</span>`;
                html += '<div class="rotation-chars">';

                for (let i = 0; i < rotation.str.length; i++) {
                    let classes = 'char';
                    if (i === 0) classes += ' first-col';
                    if (i === rotation.str.length - 1) classes += ' last-col';
                    html += `<span class="${classes}">${rotation.str[i]}</span>`;
                }

                html += '</div></div>';
            });

            rotationMatrix.innerHTML = html;
        }

        // Render BWT result and suffix array
        function renderBWTResult() {
            if (!fmIndex) return;

            let html = '<div class="bwt-display">';
            for (let i = 0; i < fmIndex.bwt.length; i++) {
                html += `<div class="bwt-char" data-index="${i}">${fmIndex.bwt[i]}</div>`;
            }
            html += '</div>';

            // Suffix Array
            html += '<div class="table-title" style="margin-top: 15px;">Suffix Array (SA):</div>';
            html += '<div class="suffix-array">';
            fmIndex.suffixArray.forEach((val, idx) => {
                html += `<span class="sa-item"><span class="sa-index">${idx}:</span><span class="sa-value">${val}</span></span>`;
            });
            html += '</div>';

            // Original string display
            html += '<div class="table-title" style="margin-top: 15px;">Original String:</div>';
            html += '<div class="original-display" id="originalDisplay">';
            for (let i = 0; i < fmIndex.originalText.length; i++) {
                html += `<div class="orig-char" data-pos="${i}">
                    <span class="idx">${i}</span>
                    <span class="letter">${fmIndex.originalText[i]}</span>
                </div>`;
            }
            html += '</div>';

            bwtResult.innerHTML = html;
        }

        // Render FM-Index tables
        function renderFMTables() {
            if (!fmIndex) return;

            let html = '<div class="fm-tables">';

            // C array (count of chars less than c)
            html += '<div class="count-table">';
            html += '<div class="table-title">C[c] - Count of chars &lt; c</div>';
            html += '<table><tr><th>Char</th><th>C[c]</th></tr>';
            for (const c of fmIndex.alphabet) {
                html += `<tr><td>${c === '$' ? '$' : c}</td><td>${fmIndex.C[c]}</td></tr>`;
            }
            html += '</table></div>';

            // Occ array (cumulative occurrence)
            html += '<div class="occ-table">';
            html += '<div class="table-title">Occ[c][i] - Occurrences of c in BWT[0..i-1]</div>';
            html += '<table><tr><th>i</th>';
            for (const c of fmIndex.alphabet) {
                html += `<th>${c === '$' ? '$' : c}</th>`;
            }
            html += '</tr>';

            for (let i = 0; i <= fmIndex.n; i++) {
                html += `<tr><td>${i}</td>`;
                for (const c of fmIndex.alphabet) {
                    html += `<td class="occ-cell" data-char="${c}" data-index="${i}">${fmIndex.Occ[c][i]}</td>`;
                }
                html += '</tr>';
            }
            html += '</table></div>';

            html += '</div>';
            fmTables.innerHTML = html;
        }

        // Render search visualization
        function renderSearchVisualization() {
            let html = `
                <div class="info-box">
                    <strong>Backward Search Algorithm:</strong><br>
                    For each character c (right to left):
                    <code>sp = C[c] + Occ[c][sp]</code>,
                    <code>ep = C[c] + Occ[c][ep+1] - 1</code><br>
                    Initial range: [0, n-1]. If sp &gt; ep at any point, pattern not found.
                </div>
            `;

            if (searchSteps.length > 0) {
                html += '<div class="search-steps">';

                searchSteps.forEach((step, idx) => {
                    const isCurrent = idx === currentStepIndex;
                    let stepClass = 'search-step';
                    if (isCurrent) stepClass += ' active';
                    if (step.complete && step.positions.length > 0) stepClass += ' found';
                    if (!step.found && !step.complete) stepClass += ' not-found';

                    html += `<div class="${stepClass}">`;

                    if (step.complete) {
                        html += `<div class="step-header">
                            <span style="color: #00ff88; font-weight: bold;">✓ Search Complete</span>
                            <span class="step-range">Final range: [${step.sp}, ${step.ep}]</span>
                        </div>`;
                        html += `<div class="step-formula">${step.message}</div>`;
                    } else {
                        const patternDisplay = searchPattern.value.split('').map((c, i) =>
                            i === step.charIndex ? `<strong style="color: gold;">${c}</strong>` : c
                        ).join('');

                        html += `<div class="step-header">
                            <span>Step ${searchSteps.length - idx}: Processing '<span class="step-char">${step.char}</span>' from "${patternDisplay}"</span>
                            <span class="step-range">[${step.sp}, ${step.ep}] → [${step.newSp}, ${step.newEp}]</span>
                        </div>`;
                        html += `<div class="step-formula">
                            sp = C['${step.char}'] + Occ['${step.char}'][${step.sp}] = ${step.C_c} + ${step.Occ_sp} = ${step.newSp}<br>
                            ep = C['${step.char}'] + Occ['${step.char}'][${step.ep + 1}] - 1 = ${step.C_c} + ${step.Occ_ep} - 1 = ${step.newEp}
                        </div>`;
                        html += `<div style="margin-top: 5px; color: ${step.found ? '#00ff88' : '#ff6b6b'};">${step.message}</div>`;
                    }

                    html += '</div>';
                });

                // Show results
                const lastStep = searchSteps[searchSteps.length - 1];
                if (lastStep && lastStep.complete && lastStep.positions.length > 0) {
                    html += `<div class="results">
                        <strong>Pattern "${searchPattern.value}" found at positions:</strong>
                        <div class="result-positions">
                            ${lastStep.positions.map(p => `<span class="position-badge">${p}</span>`).join('')}
                        </div>
                    </div>`;

                    // Highlight positions in original string
                    setTimeout(() => {
                        const origChars = document.querySelectorAll('.orig-char');
                        lastStep.positions.forEach(pos => {
                            for (let i = pos; i < pos + searchPattern.value.length && i < fmIndex.originalText.length; i++) {
                                const el = document.querySelector(`.orig-char[data-pos="${i}"]`);
                                if (el) el.classList.add('match-pos');
                            }
                        });
                    }, 0);
                } else if (lastStep && (lastStep.complete || !lastStep.found)) {
                    html += `<div class="results no-match">
                        <strong>Pattern "${searchPattern.value}" not found in the text.</strong>
                    </div>`;
                }

                html += '</div>';
            }

            searchVisualization.innerHTML = html;

            // Highlight relevant rows in rotation matrix
            if (searchSteps.length > 0) {
                const lastStep = searchSteps[currentStepIndex] || searchSteps[searchSteps.length - 1];
                if (lastStep.found || lastStep.complete) {
                    const sp = lastStep.complete ? lastStep.sp : lastStep.newSp;
                    const ep = lastStep.complete ? lastStep.ep : lastStep.newEp;
                    const indices = [];
                    for (let i = sp; i <= ep; i++) indices.push(i);
                    renderRotationMatrix(indices);
                }
            }
        }

        // Build BWT and FM-Index
        function build() {
            const text = inputString.value.trim();
            if (!text) {
                alert('Please enter a string');
                return;
            }

            fmIndex = new BWTFMIndex(text);
            searchSteps = [];
            currentStepIndex = -1;
            searchGenerator = null;

            renderRotationMatrix();
            renderBWTResult();
            renderFMTables();
            renderSearchVisualization();

            searchBtn.disabled = false;
            stepBtn.disabled = false;
        }

        // Run full search
        function runSearch() {
            if (!fmIndex) return;

            const pattern = searchPattern.value;
            if (!pattern) {
                alert('Please enter a search pattern');
                return;
            }

            searchSteps = [];
            currentStepIndex = -1;
            searchGenerator = fmIndex.backwardSearch(pattern);

            // Run all steps
            let result = searchGenerator.next();
            while (!result.done) {
                searchSteps.push(result.value);
                currentStepIndex = searchSteps.length - 1;
                result = searchGenerator.next();
            }

            renderSearchVisualization();
        }

        // Step through search
        function stepSearch() {
            if (!fmIndex) return;

            const pattern = searchPattern.value;
            if (!pattern) {
                alert('Please enter a search pattern');
                return;
            }

            // Initialize generator if needed
            if (!searchGenerator || currentStepIndex === searchSteps.length - 1 && searchSteps.length > 0 && searchSteps[searchSteps.length - 1].complete) {
                searchSteps = [];
                currentStepIndex = -1;
                searchGenerator = fmIndex.backwardSearch(pattern);
            }

            // Get next step
            const result = searchGenerator.next();
            if (!result.done) {
                searchSteps.push(result.value);
                currentStepIndex = searchSteps.length - 1;
                renderSearchVisualization();
            }
        }

        // Reset
        function reset() {
            fmIndex = null;
            searchSteps = [];
            currentStepIndex = -1;
            searchGenerator = null;

            rotationMatrix.innerHTML = '<div class="loading">Enter a string and click "Build"</div>';
            bwtResult.innerHTML = '<div class="loading">Build the transform first</div>';
            fmTables.innerHTML = '<div class="loading">Build the index first</div>';
            searchVisualization.innerHTML = `
                <div class="info-box">
                    <strong>How Backward Search Works:</strong><br>
                    Starting from the last character of the pattern, we maintain a range [sp, ep] in the suffix array.
                    For each character c, we update: <code>sp = C[c] + Occ(c, sp-1)</code> and <code>ep = C[c] + Occ(c, ep) - 1</code><br>
                    When sp ≤ ep, matches exist at positions SA[sp..ep].
                </div>
            `;

            searchBtn.disabled = true;
            stepBtn.disabled = true;
        }

        // Event listeners
        buildBtn.addEventListener('click', build);
        searchBtn.addEventListener('click', runSearch);
        stepBtn.addEventListener('click', stepSearch);
        resetBtn.addEventListener('click', reset);

        inputString.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') build();
        });

        searchPattern.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !searchBtn.disabled) runSearch();
        });

        // Build on load with default values
        build();
    </script>
</body>
</html>
