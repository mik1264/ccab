<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ukkonen's Suffix Tree - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #c9a227, #f4d03f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .subtitle { color: #888; font-size: 1rem; }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-weight: 500;
            transition: transform 0.3s;
        }
        .back-link:hover { transform: translateX(-5px); }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            min-height: 550px;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #0a0a1a;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
        }
        .panel h3 {
            color: #c9a227;
            font-size: 1rem;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(201, 162, 39, 0.3);
            padding-bottom: 5px;
        }
        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #e8e8e8;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
        }
        button {
            padding: 10px 15px;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid rgba(201, 162, 39, 0.5);
            border-radius: 6px;
            color: #c9a227;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(201, 162, 39, 0.3);
            border-color: #c9a227;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .string-display {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-bottom: 10px;
            letter-spacing: 2px;
            word-break: break-all;
        }
        .string-display .processed {
            color: #2ecc71;
        }
        .string-display .current {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.3);
            padding: 0 2px;
        }
        .string-display .remaining {
            color: #666;
        }
        .active-point {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            padding: 10px;
            background: rgba(155, 89, 182, 0.2);
            border: 1px solid rgba(155, 89, 182, 0.5);
            border-radius: 6px;
            margin-top: 10px;
        }
        .active-point .label {
            color: #9b59b6;
            font-weight: bold;
        }
        .log-container {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
        }
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .log-entry.phase { color: #f4d03f; }
        .log-entry.extend { color: #2ecc71; }
        .log-entry.rule { color: #3498db; }
        .log-entry.link { color: #9b59b6; }
        .property-list {
            font-size: 0.85rem;
            color: #ccc;
            list-style: none;
        }
        .property-list li {
            padding: 5px 0;
            padding-left: 15px;
            position: relative;
        }
        .property-list li::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #c9a227;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.2rem;
            color: #c9a227;
            font-weight: bold;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #888;
        }
        .complexity {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #f4d03f;
        }
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }
        .presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .presets button {
            flex: 1;
            min-width: 60px;
            font-size: 0.75rem;
        }
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Ukkonen's Suffix Tree</h1>
            <p class="subtitle">Online Linear-Time Construction with Active Point</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="520"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Internal Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>Leaf Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>Active Point</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12; width: 20px; height: 2px;"></div>
                        <span>Suffix Link</span>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="panel">
                    <h3>Input String</h3>
                    <div class="input-group">
                        <input type="text" id="string-input" placeholder="Enter string..." maxlength="20">
                        <button onclick="buildTree()">Build</button>
                    </div>
                    <div class="presets">
                        <button onclick="setPreset('banana')">banana</button>
                        <button onclick="setPreset('abcabx')">abcabx</button>
                        <button onclick="setPreset('aabaa')">aabaa</button>
                        <button onclick="setPreset('mississippi')">mississippi</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Construction State</h3>
                    <div class="string-display" id="string-display">
                        <span class="remaining">Enter a string above</span>
                    </div>
                    <div class="active-point" id="active-point">
                        <span class="label">Active Point:</span> (root, ε, 0)
                    </div>
                </div>

                <div class="panel">
                    <h3>Controls</h3>
                    <div class="action-buttons">
                        <button onclick="stepForward()" id="step-btn">Step →</button>
                        <button onclick="autoPlay()" id="play-btn">▶ Play</button>
                        <button onclick="resetTree()">Reset</button>
                        <button onclick="finishTree()">Finish</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="phase-count">0</div>
                            <div class="stat-label">Phase</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="node-count">1</div>
                            <div class="stat-label">Nodes</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="extension-count">0</div>
                            <div class="stat-label">Extensions</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="remainder">0</div>
                            <div class="stat-label">Remainder</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Operation Log</h3>
                    <div class="log-container" id="log"></div>
                </div>

                <div class="panel">
                    <h3>About Ukkonen's Algorithm</h3>
                    <ul class="property-list">
                        <li>Online: builds tree incrementally</li>
                        <li><span class="complexity">O(n)</span> time complexity</li>
                        <li>Uses active point (node, edge, length)</li>
                        <li>Suffix links enable fast traversal</li>
                        <li>Implicit end for leaf edges</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let text = '';
        let phase = 0;
        let remainder = 0;
        let activeNode = null;
        let activeEdge = -1;
        let activeLength = 0;
        let root = null;
        let needSuffixLink = null;
        let nodeCount = 0;
        let extensionCount = 0;
        let isPlaying = false;
        let playInterval = null;
        let end = -1;

        class SuffixTreeNode {
            constructor() {
                this.children = {};
                this.suffixLink = null;
                this.start = -1;
                this.end = null; // null means global end (leaf)
                this.suffixIndex = -1;
                this.id = nodeCount++;
            }

            edgeLength() {
                if (this.end === null) return end - this.start + 1;
                return this.end - this.start + 1;
            }
        }

        function init() {
            root = new SuffixTreeNode();
            root.start = -1;
            root.end = -1;
            activeNode = root;
            activeEdge = -1;
            activeLength = 0;
            remainder = 0;
            needSuffixLink = null;
            nodeCount = 1;
            phase = 0;
            extensionCount = 0;
            end = -1;
        }

        function addSuffixLink(node) {
            if (needSuffixLink !== null) {
                needSuffixLink.suffixLink = node;
                log('link', `Added suffix link from node ${needSuffixLink.id} to ${node.id}`);
            }
            needSuffixLink = node;
        }

        function walkDown(node) {
            if (activeLength >= node.edgeLength()) {
                activeEdge += node.edgeLength();
                activeLength -= node.edgeLength();
                activeNode = node;
                return true;
            }
            return false;
        }

        function extendTree(pos) {
            end = pos;
            remainder++;
            needSuffixLink = null;

            log('phase', `Phase ${pos + 1}: Adding '${text[pos]}'`);

            while (remainder > 0) {
                if (activeLength === 0) {
                    activeEdge = pos;
                }

                const edgeChar = text[activeEdge];

                if (!(edgeChar in activeNode.children)) {
                    // Rule 2: Create new leaf
                    const leaf = new SuffixTreeNode();
                    leaf.start = pos;
                    leaf.suffixIndex = pos - remainder + 1;
                    activeNode.children[edgeChar] = leaf;
                    log('extend', `Rule 2: New leaf for '${edgeChar}' at position ${pos}`);

                    addSuffixLink(activeNode);
                } else {
                    const next = activeNode.children[edgeChar];

                    if (walkDown(next)) {
                        continue;
                    }

                    // Rule 3: Character already exists
                    if (text[next.start + activeLength] === text[pos]) {
                        log('rule', `Rule 3: '${text[pos]}' already exists, stop`);
                        addSuffixLink(activeNode);
                        activeLength++;
                        break;
                    }

                    // Rule 2: Split edge
                    const split = new SuffixTreeNode();
                    split.start = next.start;
                    split.end = next.start + activeLength - 1;
                    activeNode.children[edgeChar] = split;

                    const leaf = new SuffixTreeNode();
                    leaf.start = pos;
                    leaf.suffixIndex = pos - remainder + 1;
                    split.children[text[pos]] = leaf;

                    next.start += activeLength;
                    split.children[text[next.start]] = next;

                    log('extend', `Rule 2: Split at '${text.substring(split.start, split.end + 1)}', new leaf for '${text[pos]}'`);

                    addSuffixLink(split);
                }

                remainder--;
                extensionCount++;

                if (activeNode === root && activeLength > 0) {
                    activeLength--;
                    activeEdge = pos - remainder + 1;
                } else if (activeNode !== root) {
                    activeNode = activeNode.suffixLink || root;
                }
            }
        }

        function buildSuffixTree() {
            init();
            for (let i = 0; i < text.length; i++) {
                extendTree(i);
            }
        }

        function stepForward() {
            if (phase >= text.length) {
                log('phase', 'Construction complete!');
                return false;
            }

            extendTree(phase);
            phase++;
            draw();
            updateUI();
            return phase < text.length;
        }

        function autoPlay() {
            if (isPlaying) {
                clearInterval(playInterval);
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
                return;
            }

            isPlaying = true;
            document.getElementById('play-btn').textContent = '⏸ Pause';

            playInterval = setInterval(() => {
                if (!stepForward()) {
                    clearInterval(playInterval);
                    isPlaying = false;
                    document.getElementById('play-btn').textContent = '▶ Play';
                }
            }, 800);
        }

        function resetTree() {
            if (isPlaying) {
                clearInterval(playInterval);
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
            }

            init();
            phase = 0;
            document.getElementById('log').innerHTML = '';
            log('phase', `Ready to build tree for "${text}$"`);
            draw();
            updateUI();
        }

        function finishTree() {
            if (isPlaying) {
                clearInterval(playInterval);
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
            }

            while (phase < text.length) {
                extendTree(phase);
                phase++;
            }
            draw();
            updateUI();
            log('phase', 'Construction complete!');
        }

        function buildTree() {
            const input = document.getElementById('string-input').value.toLowerCase().replace(/[^a-z]/g, '');
            if (!input || input.length < 2) {
                log('phase', 'Please enter at least 2 characters');
                return;
            }

            text = input + '$'; // Add terminal character
            resetTree();
        }

        function setPreset(s) {
            document.getElementById('string-input').value = s;
            buildTree();
        }

        function log(type, message) {
            const logContainer = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logContainer.insertBefore(entry, logContainer.firstChild);

            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function updateUI() {
            document.getElementById('phase-count').textContent = phase;
            document.getElementById('node-count').textContent = nodeCount;
            document.getElementById('extension-count').textContent = extensionCount;
            document.getElementById('remainder').textContent = remainder;

            // Update string display
            const display = document.getElementById('string-display');
            if (text) {
                let html = '';
                for (let i = 0; i < text.length; i++) {
                    if (i < phase) {
                        html += `<span class="processed">${text[i]}</span>`;
                    } else if (i === phase) {
                        html += `<span class="current">${text[i]}</span>`;
                    } else {
                        html += `<span class="remaining">${text[i]}</span>`;
                    }
                }
                display.innerHTML = html;
            }

            // Update active point
            const ap = document.getElementById('active-point');
            const edgeStr = activeEdge >= 0 && activeEdge < text.length ? `'${text[activeEdge]}'` : 'ε';
            const nodeStr = activeNode === root ? 'root' : `node ${activeNode.id}`;
            ap.innerHTML = `<span class="label">Active Point:</span> (${nodeStr}, ${edgeStr}, ${activeLength})`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!root || !text) {
                ctx.fillStyle = '#888';
                ctx.font = '18px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Enter a string to build the suffix tree', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Calculate positions using radial layout
            const positions = new Map();
            const rootX = canvas.width / 2;
            const rootY = 60;
            calculatePositions(root, rootX, rootY, 0, Math.PI * 2, positions, 0);

            // Draw suffix links first (behind edges)
            drawSuffixLinks(root, positions);

            // Draw edges
            drawEdges(root, positions);

            // Draw nodes
            drawNodes(root, positions);
        }

        function calculatePositions(node, x, y, startAngle, angleRange, positions, depth) {
            positions.set(node, { x, y, depth });

            const children = Object.keys(node.children);
            if (children.length === 0) return;

            const radius = Math.max(80, 160 - depth * 30);
            const childAngleRange = angleRange / children.length;

            children.forEach((char, i) => {
                const child = node.children[char];
                const angle = startAngle + childAngleRange * (i + 0.5);
                const childX = x + Math.cos(angle - Math.PI / 2) * radius;
                const childY = y + Math.sin(angle - Math.PI / 2) * radius + 50;

                calculatePositions(child, childX, childY, angle - childAngleRange / 2, childAngleRange, positions, depth + 1);
            });
        }

        function drawSuffixLinks(node, positions) {
            if (!positions.has(node)) return;

            if (node.suffixLink && node.suffixLink !== root && positions.has(node.suffixLink)) {
                const pos = positions.get(node);
                const linkPos = positions.get(node.suffixLink);

                ctx.strokeStyle = 'rgba(243, 156, 18, 0.4)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);

                // Curved line
                const midX = (pos.x + linkPos.x) / 2;
                const midY = (pos.y + linkPos.y) / 2 - 20;
                ctx.quadraticCurveTo(midX, midY, linkPos.x, linkPos.y);
                ctx.stroke();

                ctx.setLineDash([]);
            }

            Object.values(node.children).forEach(child => {
                drawSuffixLinks(child, positions);
            });
        }

        function drawEdges(node, positions) {
            if (!positions.has(node)) return;
            const pos = positions.get(node);

            Object.entries(node.children).forEach(([char, child]) => {
                if (!positions.has(child)) return;
                const childPos = positions.get(child);

                // Draw edge line
                ctx.strokeStyle = child.suffixIndex !== -1 ? '#2ecc71' : '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(childPos.x, childPos.y);
                ctx.stroke();

                // Draw edge label
                const edgeEnd = child.end !== null ? child.end : end;
                const edgeLabel = text.substring(child.start, edgeEnd + 1);

                const midX = (pos.x + childPos.x) / 2;
                const midY = (pos.y + childPos.y) / 2;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const labelWidth = ctx.measureText(edgeLabel).width + 8;
                ctx.fillRect(midX - labelWidth / 2, midY - 10, labelWidth, 18);

                ctx.fillStyle = '#f4d03f';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(edgeLabel, midX, midY);

                drawEdges(child, positions);
            });
        }

        function drawNodes(node, positions) {
            if (!positions.has(node)) return;
            const pos = positions.get(node);

            const isLeaf = node.suffixIndex !== -1;
            const isActive = node === activeNode;
            const radius = isLeaf ? 12 : 16;

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);

            if (isActive) {
                ctx.fillStyle = 'rgba(155, 89, 182, 0.8)';
                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 3;
            } else if (isLeaf) {
                ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
            } else {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.6)';
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
            }

            ctx.fill();
            ctx.stroke();

            // Node label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (node === root) {
                ctx.fillText('R', pos.x, pos.y);
            } else if (isLeaf) {
                ctx.fillText(node.suffixIndex, pos.x, pos.y);
            } else {
                ctx.fillText(node.id, pos.x, pos.y);
            }

            Object.values(node.children).forEach(child => {
                drawNodes(child, positions);
            });
        }

        // Initialize
        init();
        text = 'banana$';
        document.getElementById('string-input').value = 'banana';
        log('phase', `Ready to build tree for "${text}"`);
        draw();
        updateUI();
    </script>
</body>
</html>
