<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Traversal Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            overflow: hidden;
            color: #fff;
        }

        #canvas {
            display: block;
            background: rgba(255, 255, 255, 0.05);
            cursor: crosshair;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .controls h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        .mode-selector {
            margin-bottom: 15px;
        }

        .mode-selector label {
            display: block;
            margin: 5px 0;
            cursor: pointer;
        }

        .mode-selector input[type="radio"] {
            margin-right: 5px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            background: #3498db;
            color: white;
            transition: all 0.3s ease;
            margin: 5px;
            display: inline-block;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-group {
            margin: 10px 0;
        }

        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            z-index: 10;
        }

        .info h3 {
            margin-bottom: 10px;
            color: #3498db;
        }

        .info p {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .complexity {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .complexity-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }

        .legend {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 13px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #fff;
        }

        .status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            text-align: center;
            z-index: 10;
        }

        .traversal-order {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            max-width: 80%;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Graph Traversal</h2>
        <div class="mode-selector">
            <strong>Mode:</strong>
            <label>
                <input type="radio" name="mode" value="addNode" checked>
                Add Nodes (click)
            </label>
            <label>
                <input type="radio" name="mode" value="addEdge">
                Add Edges (drag)
            </label>
            <label>
                <input type="radio" name="mode" value="setStart">
                Set Start Node
            </label>
        </div>
        <div class="btn-group">
            <button class="btn btn-success" onclick="runBFS()">Run BFS</button>
            <button class="btn btn-success" onclick="runDFS()">Run DFS</button>
        </div>
        <div class="btn-group">
            <button class="btn" onclick="generateRandom()">Random Graph</button>
            <button class="btn btn-danger" onclick="clearGraph()">Clear</button>
        </div>
    </div>

    <div class="info">
        <h3>Graph Traversal</h3>
        <p><strong>BFS (Breadth-First Search):</strong> Explores nodes level by level using a queue. Good for finding shortest paths.</p>
        <p><strong>DFS (Depth-First Search):</strong> Explores as far as possible along each branch using a stack. Good for cycle detection.</p>
        <div class="complexity">
            <div class="complexity-item">
                <span>BFS Time:</span>
                <span>O(V + E)</span>
            </div>
            <div class="complexity-item">
                <span>DFS Time:</span>
                <span>O(V + E)</span>
            </div>
            <div class="complexity-item">
                <span>Space:</span>
                <span>O(V)</span>
            </div>
        </div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #3498db;"></div>
                <span>Unvisited</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f39c12;"></div>
                <span>Visiting</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                <span>Visited</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>Start Node</span>
            </div>
        </div>
    </div>

    <div class="status" id="status">Click to add nodes, then switch to edge mode to connect them</div>
    <div class="traversal-order" id="traversalOrder" style="display: none;">
        <strong>Traversal Order:</strong> <span id="orderList"></span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const traversalOrderEl = document.getElementById('traversalOrder');
        const orderListEl = document.getElementById('orderList');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 25;
                this.neighbors = [];
                this.state = 'unvisited'; // unvisited, visiting, visited
                this.distance = Infinity;
            }

            draw() {
                const colors = {
                    unvisited: '#3498db',
                    visiting: '#f39c12',
                    visited: '#27ae60'
                };

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = colors[this.state];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.radius;
            }

            reset() {
                this.state = 'unvisited';
                this.distance = Infinity;
            }
        }

        class Graph {
            constructor() {
                this.nodes = [];
                this.nodeCounter = 0;
                this.startNode = null;
                this.isAnimating = false;
            }

            addNode(x, y) {
                const node = new Node(this.nodeCounter++, x, y);
                this.nodes.push(node);
                if (this.nodes.length === 1) {
                    this.startNode = node;
                }
                return node;
            }

            addEdge(node1, node2) {
                if (!node1.neighbors.includes(node2)) {
                    node1.neighbors.push(node2);
                }
                if (!node2.neighbors.includes(node1)) {
                    node2.neighbors.push(node1);
                }
            }

            getNodeAt(x, y) {
                return this.nodes.find(node => node.contains(x, y));
            }

            reset() {
                this.nodes.forEach(node => node.reset());
                this.isAnimating = false;
            }

            async bfs(startNode) {
                if (!startNode || this.isAnimating) return;

                this.reset();
                this.isAnimating = true;
                const queue = [startNode];
                const order = [];
                startNode.state = 'visiting';
                startNode.distance = 0;

                while (queue.length > 0) {
                    const current = queue.shift();
                    current.state = 'visited';
                    order.push(current.id);

                    await this.sleep(500);

                    for (const neighbor of current.neighbors) {
                        if (neighbor.state === 'unvisited') {
                            neighbor.state = 'visiting';
                            neighbor.distance = current.distance + 1;
                            queue.push(neighbor);
                            await this.sleep(300);
                        }
                    }
                }

                this.isAnimating = false;
                return order;
            }

            async dfs(startNode) {
                if (!startNode || this.isAnimating) return;

                this.reset();
                this.isAnimating = true;
                const order = [];

                await this.dfsRecursive(startNode, order);

                this.isAnimating = false;
                return order;
            }

            async dfsRecursive(node, order) {
                node.state = 'visiting';
                await this.sleep(500);

                node.state = 'visited';
                order.push(node.id);

                for (const neighbor of node.neighbors) {
                    if (neighbor.state === 'unvisited') {
                        await this.dfsRecursive(neighbor, order);
                    }
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            draw() {
                // Draw edges
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;

                this.nodes.forEach(node => {
                    node.neighbors.forEach(neighbor => {
                        // Only draw each edge once
                        if (node.id < neighbor.id) {
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y);
                            ctx.lineTo(neighbor.x, neighbor.y);
                            ctx.stroke();

                            // Draw arrow in the middle
                            const midX = (node.x + neighbor.x) / 2;
                            const midY = (node.y + neighbor.y) / 2;
                            const angle = Math.atan2(neighbor.y - node.y, neighbor.x - node.x);

                            ctx.save();
                            ctx.translate(midX, midY);
                            ctx.rotate(angle);
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(-8, -5);
                            ctx.lineTo(-8, 5);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                    });
                });

                // Draw nodes
                this.nodes.forEach(node => {
                    node.draw();
                });

                // Highlight start node
                if (this.startNode) {
                    ctx.beginPath();
                    ctx.arc(this.startNode.x, this.startNode.y, this.startNode.radius + 5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            clear() {
                this.nodes = [];
                this.nodeCounter = 0;
                this.startNode = null;
                this.isAnimating = false;
            }

            generateRandom() {
                this.clear();

                const numNodes = 8 + Math.floor(Math.random() * 4);
                const margin = 100;

                // Add nodes in a circular layout
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 3;

                for (let i = 0; i < numNodes; i++) {
                    const angle = (i / numNodes) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    this.addNode(x, y);
                }

                // Add random edges (ensuring connected graph)
                // First, create a spanning tree to ensure connectivity
                for (let i = 1; i < this.nodes.length; i++) {
                    const prevNode = this.nodes[Math.floor(Math.random() * i)];
                    this.addEdge(prevNode, this.nodes[i]);
                }

                // Add some additional random edges
                const extraEdges = Math.floor(numNodes * 0.5);
                for (let i = 0; i < extraEdges; i++) {
                    const node1 = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    const node2 = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    if (node1 !== node2) {
                        this.addEdge(node1, node2);
                    }
                }

                this.startNode = this.nodes[0];
            }
        }

        const graph = new Graph();
        let dragStartNode = null;
        let mouseX = 0;
        let mouseY = 0;

        function getMode() {
            return document.querySelector('input[name="mode"]:checked').value;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const mode = getMode();
            const clickedNode = graph.getNodeAt(x, y);

            if (mode === 'addNode' && !clickedNode) {
                graph.addNode(x, y);
                setStatus(`Node ${graph.nodeCounter - 1} added`);
            } else if (mode === 'addEdge' && clickedNode) {
                dragStartNode = clickedNode;
            } else if (mode === 'setStart' && clickedNode) {
                graph.startNode = clickedNode;
                setStatus(`Start node set to ${clickedNode.id}`);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (dragStartNode) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const endNode = graph.getNodeAt(x, y);
                if (endNode && endNode !== dragStartNode) {
                    graph.addEdge(dragStartNode, endNode);
                    setStatus(`Edge added: ${dragStartNode.id} ↔ ${endNode.id}`);
                }
                dragStartNode = null;
            }
        });

        async function runBFS() {
            if (!graph.startNode) {
                setStatus('Please set a start node first');
                return;
            }

            setStatus('Running BFS...');
            const order = await graph.bfs(graph.startNode);
            showTraversalOrder('BFS', order);
            setStatus('BFS completed');
        }

        async function runDFS() {
            if (!graph.startNode) {
                setStatus('Please set a start node first');
                return;
            }

            setStatus('Running DFS...');
            const order = await graph.dfs(graph.startNode);
            showTraversalOrder('DFS', order);
            setStatus('DFS completed');
        }

        function showTraversalOrder(algorithm, order) {
            orderListEl.textContent = `${algorithm}: ${order.join(' → ')}`;
            traversalOrderEl.style.display = 'block';
        }

        function clearGraph() {
            graph.clear();
            traversalOrderEl.style.display = 'none';
            setStatus('Graph cleared');
        }

        function generateRandom() {
            graph.generateRandom();
            traversalOrderEl.style.display = 'none';
            setStatus(`Generated random graph with ${graph.nodes.length} nodes`);
        }

        function setStatus(message) {
            statusEl.textContent = message;
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            graph.draw();

            // Draw edge being dragged
            if (dragStartNode) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(dragStartNode.x, dragStartNode.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            if (graph.nodes.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Click to add nodes, or generate a random graph', canvas.width / 2, canvas.height / 2);
            }

            requestAnimationFrame(animate);
        }

        generateRandom();
        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
