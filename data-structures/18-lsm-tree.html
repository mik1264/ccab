<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSM-Tree Compaction Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #8899a6;
            font-size: 1rem;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f5576c;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .controls {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.85rem;
            color: #8899a6;
        }

        select, input {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 10px 14px;
            color: #fff;
            font-size: 0.95rem;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #f5576c;
        }

        button {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .visualization {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 20px;
        }

        .lsm-tree {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .memtable {
            background: rgba(0, 255, 136, 0.1);
            border: 2px dashed rgba(0, 255, 136, 0.4);
            border-radius: 10px;
            padding: 15px;
        }

        .memtable-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .memtable-title {
            color: #00ff88;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .memtable-size {
            font-size: 0.85rem;
            color: #8899a6;
        }

        .memtable-entries {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 40px;
        }

        .entry {
            display: flex;
            align-items: center;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 4px;
            padding: 4px 8px;
            font-family: monospace;
            font-size: 0.8rem;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .entry-key {
            color: #4ecdc4;
            margin-right: 4px;
        }

        .entry-value {
            color: #f5576c;
        }

        .level {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
        }

        .level-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .level-title {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .level-0 .level-title { color: #ff6b6b; }
        .level-1 .level-title { color: #ffd93d; }
        .level-2 .level-title { color: #6bcb77; }
        .level-3 .level-title { color: #4d96ff; }

        .level-stats {
            font-size: 0.8rem;
            color: #8899a6;
        }

        .sstables {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 50px;
        }

        .sstable {
            background: rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 8px 12px;
            min-width: 80px;
            transition: all 0.3s;
        }

        .sstable.compacting {
            animation: pulse 0.5s infinite alternate;
            border: 2px solid #f5576c;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .sstable-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .sstable-id {
            font-family: monospace;
            font-size: 0.75rem;
            color: #8899a6;
        }

        .sstable-size {
            font-size: 0.75rem;
            color: #f093fb;
        }

        .sstable-range {
            font-family: monospace;
            font-size: 0.8rem;
            color: #e0e0e0;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 15px;
        }

        .panel h3 {
            font-size: 1rem;
            color: #f093fb;
            margin-bottom: 12px;
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
        }

        .metric-label {
            font-size: 0.75rem;
            color: #8899a6;
            margin-top: 4px;
        }

        .metric.highlight .metric-value {
            color: #f5576c;
        }

        .log {
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .log-entry.write { color: #00ff88; }
        .log-entry.flush { color: #ffd93d; }
        .log-entry.compact { color: #f5576c; }
        .log-entry.read { color: #4ecdc4; }

        .strategy-info {
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .strategy-name {
            font-weight: 600;
            color: #f093fb;
            margin-bottom: 5px;
        }

        .strategy-desc {
            color: #8899a6;
        }

        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #4ecdc4);
            transition: width 0.3s;
        }

        .compaction-animation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .compaction-animation.active {
            display: flex;
        }

        .compaction-modal {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
        }

        .compaction-modal h3 {
            color: #f5576c;
            margin-bottom: 15px;
        }

        .compaction-progress {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .compact-dot {
            width: 12px;
            height: 12px;
            background: #f5576c;
            border-radius: 50%;
            animation: bounce 0.6s infinite alternate;
        }

        .compact-dot:nth-child(2) { animation-delay: 0.2s; }
        .compact-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <header>
            <h1>LSM-Tree Compaction Simulator</h1>
            <p class="subtitle">Explore memtables, SSTables, leveled vs tiered compaction, and write amplification</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Compaction Strategy</label>
                <select id="strategySelect">
                    <option value="leveled">Leveled Compaction</option>
                    <option value="tiered">Size-Tiered Compaction</option>
                </select>
            </div>
            <div class="control-group">
                <label>Memtable Size</label>
                <select id="memtableSize">
                    <option value="4">4 entries</option>
                    <option value="8" selected>8 entries</option>
                    <option value="16">16 entries</option>
                </select>
            </div>
            <div class="control-group">
                <label>Level Fanout (T)</label>
                <select id="fanout">
                    <option value="2">2</option>
                    <option value="4" selected>4</option>
                    <option value="10">10</option>
                </select>
            </div>
            <button id="writeBtn">Write Random KV</button>
            <button id="bulkWriteBtn" class="btn-secondary">Bulk Write (10)</button>
            <button id="readBtn" class="btn-secondary">Read Key</button>
            <button id="resetBtn" class="btn-secondary">Reset</button>
        </div>

        <div class="main-content">
            <div class="visualization">
                <div class="lsm-tree">
                    <div class="memtable">
                        <div class="memtable-header">
                            <span class="memtable-title">Memtable (In-Memory)</span>
                            <span class="memtable-size" id="memtableStats">0/8 entries</span>
                        </div>
                        <div class="memtable-entries" id="memtableEntries"></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="memtableProgress" style="width: 0%"></div>
                        </div>
                    </div>

                    <div class="level level-0">
                        <div class="level-header">
                            <span class="level-title">Level 0 (Unsorted)</span>
                            <span class="level-stats" id="level0Stats">0 SSTables</span>
                        </div>
                        <div class="sstables" id="level0"></div>
                    </div>

                    <div class="level level-1">
                        <div class="level-header">
                            <span class="level-title">Level 1</span>
                            <span class="level-stats" id="level1Stats">0 SSTables | 0 entries</span>
                        </div>
                        <div class="sstables" id="level1"></div>
                    </div>

                    <div class="level level-2">
                        <div class="level-header">
                            <span class="level-title">Level 2</span>
                            <span class="level-stats" id="level2Stats">0 SSTables | 0 entries</span>
                        </div>
                        <div class="sstables" id="level2"></div>
                    </div>

                    <div class="level level-3">
                        <div class="level-header">
                            <span class="level-title">Level 3</span>
                            <span class="level-stats" id="level3Stats">0 SSTables | 0 entries</span>
                        </div>
                        <div class="sstables" id="level3"></div>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3>Metrics</h3>
                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-value" id="totalWrites">0</div>
                            <div class="metric-label">Total Writes</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="totalReads">0</div>
                            <div class="metric-label">Total Reads</div>
                        </div>
                        <div class="metric highlight">
                            <div class="metric-value" id="writeAmp">1.0x</div>
                            <div class="metric-label">Write Amp</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="compactions">0</div>
                            <div class="metric-label">Compactions</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="totalEntries">0</div>
                            <div class="metric-label">Total Entries</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="bytesWritten">0</div>
                            <div class="metric-label">Bytes Written</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Strategy Info</h3>
                    <div class="strategy-info" id="strategyInfo">
                        <div class="strategy-name">Leveled Compaction</div>
                        <div class="strategy-desc">
                            Each level has at most one sorted run. When level L fills up,
                            it merges with overlapping SSTables in level L+1.
                            Lower write amplification at higher levels, but more frequent compactions.
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Operation Log</h3>
                    <div class="log" id="log"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="compaction-animation" id="compactionAnimation">
        <div class="compaction-modal">
            <h3>Compacting...</h3>
            <p id="compactionDetails">Merging SSTables</p>
            <div class="compaction-progress">
                <div class="compact-dot"></div>
                <div class="compact-dot"></div>
                <div class="compact-dot"></div>
            </div>
        </div>
    </div>

    <script>
        class LSMTree {
            constructor(config = {}) {
                this.memtableMaxSize = config.memtableMaxSize || 8;
                this.fanout = config.fanout || 4;
                this.strategy = config.strategy || 'leveled';
                this.maxLevels = 4;
                this.memtable = new Map();
                this.levels = [[], [], [], []];
                this.totalWrites = 0;
                this.totalReads = 0;
                this.bytesWritten = 0;
                this.compactionCount = 0;
                this.sstableIdCounter = 0;
                this.updateUI();
            }

            async write(key, value) {
                this.totalWrites++;
                this.bytesWritten += key.length + value.length;
                this.memtable.set(key, value);
                this.log('WRITE: ' + key + '=' + value, 'write');
                this.updateUI();
                if (this.memtable.size >= this.memtableMaxSize) {
                    await this.flushMemtable();
                }
            }

            async flushMemtable() {
                if (this.memtable.size === 0) return;
                const entries = Array.from(this.memtable.entries()).sort((a, b) =>
                    a[0].localeCompare(b[0])
                );
                const sstable = {
                    id: ++this.sstableIdCounter,
                    entries: entries,
                    minKey: entries[0][0],
                    maxKey: entries[entries.length - 1][0],
                    size: entries.length
                };
                this.levels[0].push(sstable);
                this.memtable.clear();
                this.log('FLUSH: Memtable -> L0 (SSTable #' + sstable.id + ')', 'flush');
                this.bytesWritten += entries.length * 10;
                this.updateUI();
                await this.sleep(300);
                await this.maybeCompact();
            }

            async maybeCompact() {
                if (this.strategy === 'leveled') {
                    await this.leveledCompaction();
                } else {
                    await this.tieredCompaction();
                }
            }

            async leveledCompaction() {
                if (this.levels[0].length >= this.fanout) {
                    await this.compactLevel(0);
                }
                for (let level = 1; level < this.maxLevels - 1; level++) {
                    const maxSize = Math.pow(this.fanout, level + 1);
                    const currentSize = this.levels[level].reduce((sum, sst) => sum + sst.size, 0);
                    if (currentSize > maxSize) {
                        await this.compactLevel(level);
                    }
                }
            }

            async tieredCompaction() {
                for (let level = 0; level < this.maxLevels - 1; level++) {
                    if (this.levels[level].length >= this.fanout) {
                        await this.compactLevelTiered(level);
                    }
                }
            }

            async compactLevel(level) {
                if (this.levels[level].length === 0) return;
                this.compactionCount++;
                document.getElementById('compactionAnimation').classList.add('active');
                document.getElementById('compactionDetails').textContent =
                    'Merging L' + level + ' into L' + (level + 1);
                this.levels[level].forEach(sst => sst.compacting = true);
                this.updateUI();
                await this.sleep(500);

                const allEntries = new Map();
                for (const sst of this.levels[level]) {
                    for (const [k, v] of sst.entries) {
                        allEntries.set(k, v);
                    }
                    this.bytesWritten += sst.size * 5;
                }

                const nextLevel = level + 1;
                const minKey = this.levels[level].reduce((min, sst) =>
                    sst.minKey < min ? sst.minKey : min, 'zzz');
                const maxKey = this.levels[level].reduce((max, sst) =>
                    sst.maxKey > max ? sst.maxKey : max, '');

                const overlapping = this.levels[nextLevel].filter(sst =>
                    !(sst.maxKey < minKey || sst.minKey > maxKey)
                );

                for (const sst of overlapping) {
                    sst.compacting = true;
                    for (const [k, v] of sst.entries) {
                        if (!allEntries.has(k)) {
                            allEntries.set(k, v);
                        }
                    }
                    this.bytesWritten += sst.size * 5;
                }
                this.updateUI();
                await this.sleep(500);

                const sortedEntries = Array.from(allEntries.entries()).sort((a, b) =>
                    a[0].localeCompare(b[0])
                );

                this.levels[level] = [];
                this.levels[nextLevel] = this.levels[nextLevel].filter(sst => !overlapping.includes(sst));

                const chunkSize = Math.max(4, Math.floor(sortedEntries.length / 2));
                for (let i = 0; i < sortedEntries.length; i += chunkSize) {
                    const chunk = sortedEntries.slice(i, i + chunkSize);
                    if (chunk.length > 0) {
                        const newSST = {
                            id: ++this.sstableIdCounter,
                            entries: chunk,
                            minKey: chunk[0][0],
                            maxKey: chunk[chunk.length - 1][0],
                            size: chunk.length
                        };
                        this.levels[nextLevel].push(newSST);
                        this.bytesWritten += chunk.length * 10;
                    }
                }

                this.levels[nextLevel].sort((a, b) => a.minKey.localeCompare(b.minKey));
                this.log('COMPACT: L' + level + ' -> L' + nextLevel + ' (' + sortedEntries.length + ' entries)', 'compact');
                document.getElementById('compactionAnimation').classList.remove('active');
                this.updateUI();
            }

            async compactLevelTiered(level) {
                if (this.levels[level].length < this.fanout) return;
                this.compactionCount++;
                document.getElementById('compactionAnimation').classList.add('active');
                document.getElementById('compactionDetails').textContent =
                    'Merging ' + this.levels[level].length + ' SSTables from L' + level;
                this.levels[level].forEach(sst => sst.compacting = true);
                this.updateUI();
                await this.sleep(500);

                const allEntries = new Map();
                for (const sst of this.levels[level]) {
                    for (const [k, v] of sst.entries) {
                        allEntries.set(k, v);
                    }
                    this.bytesWritten += sst.size * 5;
                }

                const sortedEntries = Array.from(allEntries.entries()).sort((a, b) =>
                    a[0].localeCompare(b[0])
                );

                this.levels[level] = [];
                const nextLevel = level + 1;
                const newSST = {
                    id: ++this.sstableIdCounter,
                    entries: sortedEntries,
                    minKey: sortedEntries[0][0],
                    maxKey: sortedEntries[sortedEntries.length - 1][0],
                    size: sortedEntries.length
                };
                this.levels[nextLevel].push(newSST);
                this.bytesWritten += sortedEntries.length * 10;
                this.log('COMPACT: L' + level + ' -> L' + nextLevel + ' (merged ' + sortedEntries.length + ' entries)', 'compact');
                document.getElementById('compactionAnimation').classList.remove('active');
                this.updateUI();
                await this.maybeCompact();
            }

            async read(key) {
                this.totalReads++;
                if (this.memtable.has(key)) {
                    this.log('READ: ' + key + ' found in memtable', 'read');
                    this.updateUI();
                    return this.memtable.get(key);
                }
                for (let level = 0; level < this.maxLevels; level++) {
                    for (let i = this.levels[level].length - 1; i >= 0; i--) {
                        const sst = this.levels[level][i];
                        if (key >= sst.minKey && key <= sst.maxKey) {
                            const entry = sst.entries.find(([k]) => k === key);
                            if (entry) {
                                this.log('READ: ' + key + ' found in L' + level, 'read');
                                this.updateUI();
                                return entry[1];
                            }
                        }
                    }
                }
                this.log('READ: ' + key + ' not found', 'read');
                this.updateUI();
                return null;
            }

            getWriteAmplification() {
                const logicalWrites = this.totalWrites;
                const physicalWrites = this.bytesWritten / 10;
                return logicalWrites > 0 ? (physicalWrites / logicalWrites).toFixed(1) : 1.0;
            }

            getTotalEntries() {
                let total = this.memtable.size;
                for (const level of this.levels) {
                    for (const sst of level) {
                        total += sst.size;
                    }
                }
                return total;
            }

            updateUI() {
                const memtableEntries = document.getElementById('memtableEntries');
                memtableEntries.innerHTML = Array.from(this.memtable.entries())
                    .map(([k, v]) => '<div class="entry"><span class="entry-key">' + k + '</span>:<span class="entry-value">' + v + '</span></div>')
                    .join('');

                document.getElementById('memtableStats').textContent =
                    this.memtable.size + '/' + this.memtableMaxSize + ' entries';
                document.getElementById('memtableProgress').style.width =
                    ((this.memtable.size / this.memtableMaxSize) * 100) + '%';

                for (let level = 0; level < this.maxLevels; level++) {
                    const levelDiv = document.getElementById('level' + level);
                    levelDiv.innerHTML = this.levels[level].map(sst => 
                        '<div class="sstable ' + (sst.compacting ? 'compacting' : '') + '">' +
                            '<div class="sstable-header">' +
                                '<span class="sstable-id">#' + sst.id + '</span>' +
                                '<span class="sstable-size">' + sst.size + ' entries</span>' +
                            '</div>' +
                            '<div class="sstable-range">' + sst.minKey + '..' + sst.maxKey + '</div>' +
                        '</div>'
                    ).join('');

                    const totalSize = this.levels[level].reduce((sum, sst) => sum + sst.size, 0);
                    document.getElementById('level' + level + 'Stats').textContent =
                        this.levels[level].length + ' SSTables | ' + totalSize + ' entries';
                }

                document.getElementById('totalWrites').textContent = this.totalWrites;
                document.getElementById('totalReads').textContent = this.totalReads;
                document.getElementById('writeAmp').textContent = this.getWriteAmplification() + 'x';
                document.getElementById('compactions').textContent = this.compactionCount;
                document.getElementById('totalEntries').textContent = this.getTotalEntries();
                document.getElementById('bytesWritten').textContent = this.formatBytes(this.bytesWritten);
            }

            formatBytes(bytes) {
                if (bytes < 1000) return bytes + 'B';
                if (bytes < 1000000) return (bytes / 1000).toFixed(1) + 'K';
                return (bytes / 1000000).toFixed(1) + 'M';
            }

            log(message, type) {
                const logDiv = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = 'log-entry ' + type;
                entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
                logDiv.insertBefore(entry, logDiv.firstChild);
                while (logDiv.children.length > 50) {
                    logDiv.removeChild(logDiv.lastChild);
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            reset() {
                this.memtable.clear();
                this.levels = [[], [], [], []];
                this.totalWrites = 0;
                this.totalReads = 0;
                this.bytesWritten = 0;
                this.compactionCount = 0;
                this.sstableIdCounter = 0;
                document.getElementById('log').innerHTML = '';
                this.updateUI();
            }
        }

        let lsm = new LSMTree();

        function randomKey() {
            const chars = 'abcdefghijklmnopqrstuvwxyz';
            return Array.from({ length: 3 }, () =>
                chars[Math.floor(Math.random() * chars.length)]
            ).join('');
        }

        function randomValue() {
            return Math.floor(Math.random() * 1000).toString();
        }

        document.getElementById('writeBtn').addEventListener('click', async () => {
            document.getElementById('writeBtn').disabled = true;
            await lsm.write(randomKey(), randomValue());
            document.getElementById('writeBtn').disabled = false;
        });

        document.getElementById('bulkWriteBtn').addEventListener('click', async () => {
            document.getElementById('bulkWriteBtn').disabled = true;
            for (let i = 0; i < 10; i++) {
                await lsm.write(randomKey(), randomValue());
                await lsm.sleep(100);
            }
            document.getElementById('bulkWriteBtn').disabled = false;
        });

        document.getElementById('readBtn').addEventListener('click', async () => {
            const key = prompt('Enter key to read:', randomKey());
            if (key) {
                await lsm.read(key);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            lsm.reset();
        });

        document.getElementById('strategySelect').addEventListener('change', (e) => {
            lsm.strategy = e.target.value;
            updateStrategyInfo();
        });

        document.getElementById('memtableSize').addEventListener('change', (e) => {
            lsm.memtableMaxSize = parseInt(e.target.value);
            lsm.updateUI();
        });

        document.getElementById('fanout').addEventListener('change', (e) => {
            lsm.fanout = parseInt(e.target.value);
        });

        function updateStrategyInfo() {
            const info = document.getElementById('strategyInfo');
            if (lsm.strategy === 'leveled') {
                info.innerHTML = 
                    '<div class="strategy-name">Leveled Compaction</div>' +
                    '<div class="strategy-desc">' +
                        'Each level has at most one sorted run. When level L fills up, ' +
                        'it merges with overlapping SSTables in level L+1. ' +
                        '<br><br>' +
                        '<strong>Pros:</strong> Better read performance, bounded space amplification<br>' +
                        '<strong>Cons:</strong> Higher write amplification' +
                    '</div>';
            } else {
                info.innerHTML = 
                    '<div class="strategy-name">Size-Tiered Compaction</div>' +
                    '<div class="strategy-desc">' +
                        'Multiple SSTables coexist at each level. When T SSTables accumulate, ' +
                        'they merge into one SSTable at the next level. ' +
                        '<br><br>' +
                        '<strong>Pros:</strong> Lower write amplification (~1x)<br>' +
                        '<strong>Cons:</strong> Higher space and read amplification' +
                    '</div>';
            }
        }

        updateStrategyInfo();
    </script>
</body>
</html>
