<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skip List Visualization - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow: hidden;
        }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: #22d3ee;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover { background: rgba(34, 211, 238, 0.2); }

        #canvas {
            display: block;
            width: 100vw;
            height: calc(100vh - 120px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        label { font-size: 13px; color: #888; }
        input[type="number"] {
            width: 70px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: white;
        }
        input[type="range"] { width: 100px; accent-color: #22d3ee; }
        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #22d3ee, #06b6d4);
            border: none;
            border-radius: 6px;
            color: black;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(34, 211, 238, 0.4); }
        button.secondary { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        button.danger { background: linear-gradient(135deg, #ef4444, #dc2626); }

        .info-panel {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            max-width: 280px;
            z-index: 100;
        }
        .info-panel h3 { color: #22d3ee; margin-bottom: 10px; }
        .info-panel p { margin-bottom: 8px; color: #aaa; line-height: 1.5; }

        .stats-panel {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            z-index: 100;
        }
        .stats-panel h3 { color: #22d3ee; margin-bottom: 10px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; color: #aaa; }
        .stat-value { color: white; font-weight: 600; }

        .log-panel {
            position: fixed;
            top: 220px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            max-width: 280px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
            z-index: 100;
        }
        .log-panel h3 { color: #22d3ee; margin-bottom: 10px; }
        .log-entry { padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: #888; }
        .log-entry.search { color: #22d3ee; }
        .log-entry.insert { color: #22c55e; }
        .log-entry.delete { color: #ef4444; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Data Structures</a>

    <canvas id="canvas"></canvas>

    <div class="info-panel">
        <h3>Skip List</h3>
        <p>A probabilistic data structure with O(log n) search, insert, and delete operations.</p>
        <p>Each node has a random "tower height" based on probability p (default 0.5).</p>
        <p>Higher levels act as "express lanes" for faster traversal.</p>
        <p>Expected space: O(n), Expected height: O(log n)</p>
    </div>

    <div class="stats-panel">
        <h3>Statistics</h3>
        <div class="stat-row">
            <span>Elements:</span>
            <span class="stat-value" id="elementCount">0</span>
        </div>
        <div class="stat-row">
            <span>Max Level:</span>
            <span class="stat-value" id="maxLevel">0</span>
        </div>
        <div class="stat-row">
            <span>Avg Height:</span>
            <span class="stat-value" id="avgHeight">0</span>
        </div>
        <div class="stat-row">
            <span>Last Op Steps:</span>
            <span class="stat-value" id="lastSteps">0</span>
        </div>
    </div>

    <div class="log-panel">
        <h3>Operation Log</h3>
        <div id="logEntries"></div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Value:</label>
            <input type="number" id="valueInput" value="50" min="1" max="999">
        </div>
        <button onclick="insertValue()">Insert</button>
        <button class="danger" onclick="deleteValue()">Delete</button>
        <button class="secondary" onclick="searchValue()">Search</button>
        <div class="control-group">
            <label>p:</label>
            <input type="range" id="probability" min="20" max="80" value="50">
            <span id="probValue">0.50</span>
        </div>
        <button onclick="insertRandom()">Random Insert</button>
        <button onclick="clearList()">Clear</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const logEntries = document.getElementById('logEntries');

        let probability = 0.5;
        let maxLevels = 16;
        let searchPath = [];
        let highlightNode = null;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });

        // Skip List Node
        class SkipNode {
            constructor(value, level) {
                this.value = value;
                this.forward = new Array(level + 1).fill(null);
                this.x = 0;
                this.highlight = false;
            }
        }

        // Skip List
        class SkipList {
            constructor() {
                this.maxLevel = 0;
                this.head = new SkipNode(-Infinity, maxLevels);
            }

            randomLevel() {
                let level = 0;
                while (Math.random() < probability && level < maxLevels - 1) {
                    level++;
                }
                return level;
            }

            insert(value) {
                const update = new Array(maxLevels).fill(null);
                let current = this.head;
                let steps = 0;
                searchPath = [{ node: current, level: this.maxLevel }];

                for (let i = this.maxLevel; i >= 0; i--) {
                    while (current.forward[i] && current.forward[i].value < value) {
                        current = current.forward[i];
                        steps++;
                        searchPath.push({ node: current, level: i });
                    }
                    update[i] = current;
                }

                current = current.forward[0];

                if (current === null || current.value !== value) {
                    const level = this.randomLevel();
                    addLog(`Insert ${value} with height ${level + 1}`, 'insert');

                    if (level > this.maxLevel) {
                        for (let i = this.maxLevel + 1; i <= level; i++) {
                            update[i] = this.head;
                        }
                        this.maxLevel = level;
                    }

                    const newNode = new SkipNode(value, level);

                    for (let i = 0; i <= level; i++) {
                        newNode.forward[i] = update[i].forward[i];
                        update[i].forward[i] = newNode;
                    }

                    updateStats(steps);
                    return true;
                }
                return false;
            }

            delete(value) {
                const update = new Array(maxLevels).fill(null);
                let current = this.head;
                let steps = 0;
                searchPath = [{ node: current, level: this.maxLevel }];

                for (let i = this.maxLevel; i >= 0; i--) {
                    while (current.forward[i] && current.forward[i].value < value) {
                        current = current.forward[i];
                        steps++;
                        searchPath.push({ node: current, level: i });
                    }
                    update[i] = current;
                }

                current = current.forward[0];

                if (current && current.value === value) {
                    for (let i = 0; i <= this.maxLevel; i++) {
                        if (update[i].forward[i] !== current) break;
                        update[i].forward[i] = current.forward[i];
                    }

                    while (this.maxLevel > 0 && this.head.forward[this.maxLevel] === null) {
                        this.maxLevel--;
                    }

                    addLog(`Deleted ${value}`, 'delete');
                    updateStats(steps);
                    return true;
                }

                addLog(`${value} not found`, 'delete');
                return false;
            }

            search(value) {
                let current = this.head;
                let steps = 0;
                searchPath = [{ node: current, level: this.maxLevel }];

                for (let i = this.maxLevel; i >= 0; i--) {
                    while (current.forward[i] && current.forward[i].value < value) {
                        current = current.forward[i];
                        steps++;
                        searchPath.push({ node: current, level: i });
                    }
                }

                current = current.forward[0];

                if (current && current.value === value) {
                    current.highlight = true;
                    highlightNode = current;
                    addLog(`Found ${value} in ${steps} steps`, 'search');
                    setTimeout(() => { current.highlight = false; draw(); }, 2000);
                } else {
                    addLog(`${value} not found after ${steps} steps`, 'search');
                }

                updateStats(steps);
                return current && current.value === value ? current : null;
            }

            toArray() {
                const result = [];
                let current = this.head.forward[0];
                while (current) {
                    result.push(current);
                    current = current.forward[0];
                }
                return result;
            }

            getStats() {
                const nodes = this.toArray();
                const heights = nodes.map(n => n.forward.filter(f => f !== null || n.forward.indexOf(f) === 0).length);
                const avgHeight = heights.length ? (heights.reduce((a, b) => a + b, 0) / heights.length).toFixed(2) : 0;
                return {
                    count: nodes.length,
                    maxLevel: this.maxLevel + 1,
                    avgHeight
                };
            }
        }

        let skipList = new SkipList();

        function addLog(message, type) {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logEntries.insertBefore(entry, logEntries.firstChild);
            while (logEntries.children.length > 15) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        function updateStats(steps = 0) {
            const stats = skipList.getStats();
            document.getElementById('elementCount').textContent = stats.count;
            document.getElementById('maxLevel').textContent = stats.maxLevel;
            document.getElementById('avgHeight').textContent = stats.avgHeight;
            document.getElementById('lastSteps').textContent = steps;
        }

        // Drawing
        function draw() {
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            const nodes = skipList.toArray();
            const nodeWidth = 50;
            const nodeHeight = 30;
            const levelHeight = 45;
            const startX = 100;
            const startY = height - 80;

            // Calculate positions
            skipList.head.x = startX - 60;
            nodes.forEach((node, i) => {
                node.x = startX + i * (nodeWidth + 30);
            });

            // Draw level labels
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            for (let level = 0; level <= skipList.maxLevel; level++) {
                ctx.fillText(`L${level}`, 20, startY - level * levelHeight);
            }

            // Draw connections
            for (let level = 0; level <= skipList.maxLevel; level++) {
                let current = skipList.head;

                while (current.forward[level]) {
                    const next = current.forward[level];
                    const y = startY - level * levelHeight;

                    // Check if this edge is in search path
                    const inPath = searchPath.some(p =>
                        p.node === current && p.level === level
                    );

                    ctx.beginPath();
                    ctx.strokeStyle = inPath ? '#22d3ee' : 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = inPath ? 3 : 1;
                    ctx.moveTo(current.x + nodeWidth / 2, y);
                    ctx.lineTo(next.x - nodeWidth / 2 + 10, y);
                    ctx.stroke();

                    // Arrow
                    ctx.beginPath();
                    ctx.fillStyle = ctx.strokeStyle;
                    const ax = next.x - nodeWidth / 2 + 10;
                    ctx.moveTo(ax, y);
                    ctx.lineTo(ax - 8, y - 4);
                    ctx.lineTo(ax - 8, y + 4);
                    ctx.fill();

                    current = next;
                }
            }

            // Draw head node
            ctx.fillStyle = '#475569';
            ctx.fillRect(skipList.head.x - nodeWidth / 2, startY - skipList.maxLevel * levelHeight - 10, nodeWidth, (skipList.maxLevel + 1) * levelHeight + 20);
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.strokeRect(skipList.head.x - nodeWidth / 2, startY - skipList.maxLevel * levelHeight - 10, nodeWidth, (skipList.maxLevel + 1) * levelHeight + 20);
            ctx.fillStyle = '#22d3ee';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HEAD', skipList.head.x, startY + 5);

            // Draw value nodes
            for (const node of nodes) {
                const towerHeight = node.forward.findIndex(f => f === null);
                const actualHeight = towerHeight === -1 ? node.forward.length : towerHeight;

                for (let level = 0; level < actualHeight; level++) {
                    const y = startY - level * levelHeight;

                    // Node box
                    ctx.fillStyle = node.highlight ? 'rgba(34, 211, 238, 0.3)' : 'rgba(71, 85, 105, 0.8)';
                    ctx.fillRect(node.x - nodeWidth / 2, y - nodeHeight / 2, nodeWidth, nodeHeight);

                    ctx.strokeStyle = node.highlight ? '#22d3ee' : '#64748b';
                    ctx.lineWidth = node.highlight ? 3 : 1;
                    ctx.strokeRect(node.x - nodeWidth / 2, y - nodeHeight / 2, nodeWidth, nodeHeight);
                }

                // Value label
                ctx.fillStyle = node.highlight ? '#22d3ee' : '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.value, node.x, startY);

                // Height indicator
                ctx.fillStyle = '#888';
                ctx.font = '10px Arial';
                ctx.fillText(`h:${actualHeight}`, node.x, startY - actualHeight * levelHeight + 35);
            }

            // Draw probability distribution hint
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`p = ${probability.toFixed(2)} | Expected height ≈ ${(1 / (1 - probability)).toFixed(1)}`, width - 200, 30);
        }

        // Control functions
        function insertValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);
            if (!isNaN(value) && value > 0 && value < 1000) {
                skipList.insert(value);
                draw();
                input.value = Math.floor(Math.random() * 100) + 1;
            }
        }

        function deleteValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);
            if (!isNaN(value)) {
                skipList.delete(value);
                draw();
            }
        }

        function searchValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);
            if (!isNaN(value)) {
                skipList.search(value);
                draw();
            }
        }

        function insertRandom() {
            const value = Math.floor(Math.random() * 100) + 1;
            document.getElementById('valueInput').value = value;
            skipList.insert(value);
            draw();
        }

        function clearList() {
            skipList = new SkipList();
            searchPath = [];
            logEntries.innerHTML = '';
            addLog('List cleared', 'delete');
            updateStats();
            draw();
        }

        // Event listeners
        document.getElementById('probability').addEventListener('input', (e) => {
            probability = e.target.value / 100;
            document.getElementById('probValue').textContent = probability.toFixed(2);
        });

        document.getElementById('valueInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') insertValue();
        });

        // Initialize
        [20, 35, 50, 65, 80, 95].forEach(v => skipList.insert(v));
        updateStats();
        draw();
    </script>
</body>
</html>
