<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aho-Corasick Automaton - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #c9a227, #f4d03f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .subtitle { color: #888; font-size: 1rem; }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-weight: 500;
            transition: transform 0.3s;
        }
        .back-link:hover { transform: translateX(-5px); }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            min-height: 550px;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #0a0a1a;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
        }
        .panel h3 {
            color: #c9a227;
            font-size: 1rem;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(201, 162, 39, 0.3);
            padding-bottom: 5px;
        }
        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #e8e8e8;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
        }
        button {
            padding: 10px 15px;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid rgba(201, 162, 39, 0.5);
            border-radius: 6px;
            color: #c9a227;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(201, 162, 39, 0.3);
            border-color: #c9a227;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .patterns-list {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .pattern-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 0;
        }
        .pattern-item .remove {
            color: #e74c3c;
            cursor: pointer;
            padding: 0 5px;
        }
        .text-display {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            line-height: 1.8;
            word-break: break-all;
        }
        .text-display .match {
            background: rgba(46, 204, 113, 0.4);
            border-bottom: 2px solid #2ecc71;
        }
        .text-display .current {
            background: rgba(243, 156, 18, 0.4);
            border-bottom: 2px solid #f39c12;
        }
        .log-container {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
        }
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .log-entry.build { color: #3498db; }
        .log-entry.match { color: #2ecc71; }
        .log-entry.transition { color: #f39c12; }
        .log-entry.failure { color: #9b59b6; }
        .property-list {
            font-size: 0.85rem;
            color: #ccc;
            list-style: none;
        }
        .property-list li {
            padding: 5px 0;
            padding-left: 15px;
            position: relative;
        }
        .property-list li::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #c9a227;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.2rem;
            color: #c9a227;
            font-weight: bold;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #888;
        }
        .complexity {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #f4d03f;
        }
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }
        .presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .presets button {
            flex: 1;
            min-width: 80px;
            font-size: 0.75rem;
        }
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Aho-Corasick Automaton</h1>
            <p class="subtitle">Multi-Pattern String Search with Trie & Failure Links</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="520"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Internal Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>Output Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Current State</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6; width: 20px; height: 2px;"></div>
                        <span>Failure Link</span>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="panel">
                    <h3>Patterns (Dictionary)</h3>
                    <div class="input-group">
                        <input type="text" id="pattern-input" placeholder="Add pattern..." maxlength="10">
                        <button onclick="addPattern()">Add</button>
                    </div>
                    <div class="patterns-list" id="patterns-list">
                        <em style="color: #666;">No patterns added</em>
                    </div>
                    <div class="presets" style="margin-top: 10px;">
                        <button onclick="loadPreset1()">he/she/his/hers</button>
                        <button onclick="loadPreset2()">a/ab/bc/bca</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Search Text</h3>
                    <div class="input-group">
                        <input type="text" id="text-input" placeholder="Text to search..." value="ushers">
                        <button onclick="searchText()">Search</button>
                    </div>
                    <div class="text-display" id="text-display">
                        <span style="color: #666;">Enter patterns and search text</span>
                    </div>
                </div>

                <div class="panel">
                    <h3>Controls</h3>
                    <div class="action-buttons">
                        <button onclick="buildAutomaton()">Build Automaton</button>
                        <button onclick="stepSearch()" id="step-btn" disabled>Step →</button>
                        <button onclick="autoSearch()" id="play-btn" disabled>▶ Play</button>
                        <button onclick="resetSearch()">Reset</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="node-count">1</div>
                            <div class="stat-label">Nodes</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="pattern-count">0</div>
                            <div class="stat-label">Patterns</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="match-count">0</div>
                            <div class="stat-label">Matches</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="text-pos">0</div>
                            <div class="stat-label">Position</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Operation Log</h3>
                    <div class="log-container" id="log"></div>
                </div>

                <div class="panel">
                    <h3>About Aho-Corasick</h3>
                    <ul class="property-list">
                        <li>Multi-pattern string matching</li>
                        <li><span class="complexity">O(n + m + z)</span> time</li>
                        <li>Trie + failure links = automaton</li>
                        <li>Used in antivirus, grep, spam filters</li>
                        <li>Finds all patterns simultaneously</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let patterns = [];
        let root = null;
        let currentState = null;
        let searchText = '';
        let textPosition = 0;
        let matches = [];
        let isPlaying = false;
        let playInterval = null;
        let nodeCount = 0;

        class ACNode {
            constructor() {
                this.children = {};
                this.failure = null;
                this.output = [];
                this.depth = 0;
                this.id = nodeCount++;
            }
        }

        function buildTrie() {
            root = new ACNode();
            nodeCount = 1;

            patterns.forEach(pattern => {
                let node = root;
                for (let i = 0; i < pattern.length; i++) {
                    const char = pattern[i];
                    if (!(char in node.children)) {
                        node.children[char] = new ACNode();
                        node.children[char].depth = node.depth + 1;
                    }
                    node = node.children[char];
                }
                node.output.push(pattern);
            });

            log('build', `Built trie with ${nodeCount} nodes`);
        }

        function buildFailureLinks() {
            const queue = [];

            // Initialize direct children of root
            Object.values(root.children).forEach(child => {
                child.failure = root;
                queue.push(child);
            });

            // BFS to build failure links
            while (queue.length > 0) {
                const current = queue.shift();

                Object.entries(current.children).forEach(([char, child]) => {
                    queue.push(child);

                    // Follow failure links to find longest proper suffix
                    let failureNode = current.failure;
                    while (failureNode !== null && !(char in failureNode.children)) {
                        failureNode = failureNode.failure;
                    }

                    child.failure = failureNode ? failureNode.children[char] : root;

                    // Merge output from failure node
                    child.output = child.output.concat(child.failure.output);
                });
            }

            log('build', 'Built failure links using BFS');
        }

        function buildAutomaton() {
            if (patterns.length === 0) {
                log('build', 'Add some patterns first!');
                return;
            }

            buildTrie();
            buildFailureLinks();
            currentState = root;

            document.getElementById('step-btn').disabled = false;
            document.getElementById('play-btn').disabled = false;

            draw();
            updateStats();
            log('build', 'Automaton ready for search');
        }

        function addPattern() {
            const input = document.getElementById('pattern-input');
            const pattern = input.value.toLowerCase().trim();

            if (!pattern || pattern.length < 1) return;
            if (patterns.includes(pattern)) {
                log('build', `"${pattern}" already exists`);
                return;
            }

            patterns.push(pattern);
            input.value = '';
            updatePatternsList();
            log('build', `Added pattern: "${pattern}"`);
        }

        function removePattern(pattern) {
            patterns = patterns.filter(p => p !== pattern);
            updatePatternsList();
            log('build', `Removed pattern: "${pattern}"`);
        }

        function updatePatternsList() {
            const list = document.getElementById('patterns-list');
            if (patterns.length === 0) {
                list.innerHTML = '<em style="color: #666;">No patterns added</em>';
            } else {
                list.innerHTML = patterns.map(p =>
                    `<div class="pattern-item">
                        <span>"${p}"</span>
                        <span class="remove" onclick="removePattern('${p}')">×</span>
                    </div>`
                ).join('');
            }
            document.getElementById('pattern-count').textContent = patterns.length;
        }

        function loadPreset1() {
            patterns = ['he', 'she', 'his', 'hers'];
            document.getElementById('text-input').value = 'ushers';
            updatePatternsList();
            buildAutomaton();
        }

        function loadPreset2() {
            patterns = ['a', 'ab', 'bc', 'bca', 'c', 'caa'];
            document.getElementById('text-input').value = 'abccab';
            updatePatternsList();
            buildAutomaton();
        }

        function searchText() {
            searchText = document.getElementById('text-input').value.toLowerCase();
            textPosition = 0;
            matches = [];
            currentState = root;

            if (!root) {
                log('build', 'Build the automaton first!');
                return;
            }

            updateTextDisplay();
            draw();
            log('transition', `Starting search in "${searchText}"`);
        }

        function stepSearch() {
            if (!root || textPosition >= searchText.length) {
                log('transition', 'Search complete!');
                return false;
            }

            const char = searchText[textPosition];

            // Follow failure links until we find a match or reach root
            while (currentState !== root && !(char in currentState.children)) {
                log('failure', `Following failure link from node ${currentState.id}`);
                currentState = currentState.failure;
            }

            if (char in currentState.children) {
                currentState = currentState.children[char];
                log('transition', `Transition on '${char}' to node ${currentState.id}`);
            } else {
                log('transition', `No transition for '${char}', stay at root`);
            }

            // Check for matches
            if (currentState.output.length > 0) {
                currentState.output.forEach(pattern => {
                    const startPos = textPosition - pattern.length + 1;
                    matches.push({ pattern, start: startPos, end: textPosition });
                    log('match', `Found "${pattern}" at position ${startPos}`);
                });
            }

            textPosition++;
            updateTextDisplay();
            draw();
            updateStats();

            return textPosition < searchText.length;
        }

        function autoSearch() {
            if (isPlaying) {
                clearInterval(playInterval);
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
                return;
            }

            if (!searchText) {
                searchText = document.getElementById('text-input').value.toLowerCase();
            }

            isPlaying = true;
            document.getElementById('play-btn').textContent = '⏸ Pause';

            playInterval = setInterval(() => {
                if (!stepSearch()) {
                    clearInterval(playInterval);
                    isPlaying = false;
                    document.getElementById('play-btn').textContent = '▶ Play';
                }
            }, 600);
        }

        function resetSearch() {
            if (isPlaying) {
                clearInterval(playInterval);
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
            }

            textPosition = 0;
            matches = [];
            currentState = root;
            document.getElementById('log').innerHTML = '';
            updateTextDisplay();
            draw();
            updateStats();
        }

        function updateTextDisplay() {
            const display = document.getElementById('text-display');
            if (!searchText) {
                display.innerHTML = '<span style="color: #666;">Enter patterns and search text</span>';
                return;
            }

            let html = '';
            for (let i = 0; i < searchText.length; i++) {
                const isMatched = matches.some(m => i >= m.start && i <= m.end);
                const isCurrent = i === textPosition - 1;

                if (isCurrent && isMatched) {
                    html += `<span class="match current">${searchText[i]}</span>`;
                } else if (isCurrent) {
                    html += `<span class="current">${searchText[i]}</span>`;
                } else if (isMatched) {
                    html += `<span class="match">${searchText[i]}</span>`;
                } else {
                    html += searchText[i];
                }
            }
            display.innerHTML = html || '<span style="color: #666;">Empty text</span>';
        }

        function updateStats() {
            document.getElementById('node-count').textContent = nodeCount;
            document.getElementById('match-count').textContent = matches.length;
            document.getElementById('text-pos').textContent = textPosition;
        }

        function log(type, message) {
            const logContainer = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logContainer.insertBefore(entry, logContainer.firstChild);

            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!root) {
                ctx.fillStyle = '#888';
                ctx.font = '18px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Add patterns and build the automaton', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Calculate positions using BFS layered layout
            const positions = new Map();
            const levels = [];
            const queue = [{ node: root, level: 0 }];

            while (queue.length > 0) {
                const { node, level } = queue.shift();

                if (!levels[level]) levels[level] = [];
                levels[level].push(node);

                Object.values(node.children).forEach(child => {
                    queue.push({ node: child, level: level + 1 });
                });
            }

            // Position nodes by level
            levels.forEach((level, depth) => {
                const y = 60 + depth * 90;
                const spacing = canvas.width / (level.length + 1);

                level.forEach((node, i) => {
                    positions.set(node, { x: spacing * (i + 1), y });
                });
            });

            // Draw failure links first (behind everything)
            drawFailureLinks(root, positions);

            // Draw trie edges
            drawEdges(root, positions);

            // Draw nodes
            drawNodes(root, positions);
        }

        function drawFailureLinks(node, positions) {
            if (!positions.has(node)) return;

            if (node.failure && node.failure !== root && positions.has(node.failure)) {
                const pos = positions.get(node);
                const failPos = positions.get(node.failure);

                ctx.strokeStyle = 'rgba(155, 89, 182, 0.4)';
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 1.5;

                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);

                // Curved line
                const midX = (pos.x + failPos.x) / 2;
                const midY = Math.max(pos.y, failPos.y) + 30;
                ctx.quadraticCurveTo(midX, midY, failPos.x, failPos.y);
                ctx.stroke();

                ctx.setLineDash([]);
            }

            Object.values(node.children).forEach(child => {
                drawFailureLinks(child, positions);
            });
        }

        function drawEdges(node, positions) {
            if (!positions.has(node)) return;
            const pos = positions.get(node);

            Object.entries(node.children).forEach(([char, child]) => {
                if (!positions.has(child)) return;
                const childPos = positions.get(child);

                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y + 18);
                ctx.lineTo(childPos.x, childPos.y - 18);
                ctx.stroke();

                // Draw edge label
                const midX = (pos.x + childPos.x) / 2;
                const midY = (pos.y + childPos.y) / 2;

                ctx.fillStyle = '#f4d03f';
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(char, midX + 10, midY);

                drawEdges(child, positions);
            });
        }

        function drawNodes(node, positions) {
            if (!positions.has(node)) return;
            const pos = positions.get(node);

            const hasOutput = node.output.length > 0;
            const isCurrent = node === currentState;
            const radius = 18;

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);

            if (isCurrent) {
                ctx.fillStyle = 'rgba(243, 156, 18, 0.8)';
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 3;
            } else if (hasOutput) {
                ctx.fillStyle = 'rgba(46, 204, 113, 0.7)';
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 3;

                // Double circle for output nodes
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius - 5, 0, Math.PI * 2);
            } else {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.6)';
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
            }

            ctx.fill();
            ctx.stroke();

            // Node label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node === root ? 'R' : node.id, pos.x, pos.y);

            // Output patterns below node
            if (hasOutput) {
                ctx.font = '10px Courier New';
                ctx.fillStyle = '#2ecc71';
                ctx.fillText(node.output.join(','), pos.x, pos.y + radius + 12);
            }

            Object.values(node.children).forEach(child => {
                drawNodes(child, positions);
            });
        }

        // Initialize
        loadPreset1();
    </script>
</body>
</html>
