<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            color: #fff;
        }

        #canvas {
            display: block;
            background: rgba(255, 255, 255, 0.05);
            cursor: default;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .controls h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group input {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            width: 100px;
            margin-right: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            background: #667eea;
            color: white;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        .info h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .info p {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .complexity {
            background: rgba(102, 126, 234, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .complexity-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }

        .status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Binary Search Tree</h2>
        <div class="input-group">
            <input type="number" id="valueInput" placeholder="Value" min="1" max="99">
            <button class="btn btn-success" onclick="insertValue()">Insert</button>
        </div>
        <div class="input-group">
            <button class="btn" onclick="searchValue()">Search</button>
            <button class="btn btn-danger" onclick="deleteValue()">Delete</button>
        </div>
        <div class="input-group">
            <button class="btn" onclick="generateRandom()">Random Tree</button>
            <button class="btn btn-danger" onclick="clearTree()">Clear</button>
        </div>
        <div class="input-group">
            <button class="btn" onclick="traverseInOrder()">In-Order</button>
            <button class="btn" onclick="traversePreOrder()">Pre-Order</button>
            <button class="btn" onclick="traversePostOrder()">Post-Order</button>
        </div>
    </div>

    <div class="info">
        <h3>About BST</h3>
        <p>A Binary Search Tree is a node-based data structure where each node has at most two children. The left subtree contains values less than the node, and the right subtree contains values greater than the node.</p>
        <div class="complexity">
            <div class="complexity-item">
                <span>Search (avg):</span>
                <span>O(log n)</span>
            </div>
            <div class="complexity-item">
                <span>Insert (avg):</span>
                <span>O(log n)</span>
            </div>
            <div class="complexity-item">
                <span>Delete (avg):</span>
                <span>O(log n)</span>
            </div>
            <div class="complexity-item">
                <span>Space:</span>
                <span>O(n)</span>
            </div>
        </div>
    </div>

    <div class="status" id="status">Ready</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.highlight = false;
                this.highlightColor = '#667eea';
            }

            animate() {
                this.x += (this.targetX - this.x) * 0.2;
                this.y += (this.targetY - this.y) * 0.2;
            }
        }

        class BST {
            constructor() {
                this.root = null;
                this.animatingNodes = new Set();
            }

            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                    this.updatePositions();
                    return true;
                }

                let current = this.root;
                while (true) {
                    if (value === current.value) {
                        return false; // Duplicate
                    }
                    if (value < current.value) {
                        if (!current.left) {
                            current.left = newNode;
                            this.updatePositions();
                            this.animateInsertion(newNode);
                            return true;
                        }
                        current = current.left;
                    } else {
                        if (!current.right) {
                            current.right = newNode;
                            this.updatePositions();
                            this.animateInsertion(newNode);
                            return true;
                        }
                        current = current.right;
                    }
                }
            }

            search(value) {
                return this.searchNode(this.root, value);
            }

            searchNode(node, value) {
                if (!node) return null;

                node.highlight = true;
                node.highlightColor = '#f39c12';

                if (value === node.value) {
                    node.highlightColor = '#27ae60';
                    setTimeout(() => { node.highlight = false; }, 2000);
                    return node;
                }

                setTimeout(() => { node.highlight = false; }, 500);

                if (value < node.value) {
                    return this.searchNode(node.left, value);
                } else {
                    return this.searchNode(node.right, value);
                }
            }

            delete(value) {
                this.root = this.deleteNode(this.root, value);
                this.updatePositions();
            }

            deleteNode(node, value) {
                if (!node) return null;

                if (value < node.value) {
                    node.left = this.deleteNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this.deleteNode(node.right, value);
                } else {
                    // Node found
                    if (!node.left && !node.right) {
                        return null;
                    }
                    if (!node.left) {
                        return node.right;
                    }
                    if (!node.right) {
                        return node.left;
                    }

                    // Node has two children
                    const minRight = this.findMin(node.right);
                    node.value = minRight.value;
                    node.right = this.deleteNode(node.right, minRight.value);
                }
                return node;
            }

            findMin(node) {
                while (node.left) {
                    node = node.left;
                }
                return node;
            }

            updatePositions() {
                if (!this.root) return;

                const height = this.getHeight(this.root);
                const width = Math.pow(2, height) * 60;
                this.calculatePositions(this.root, canvas.width / 2, 80, width / 2);
            }

            calculatePositions(node, x, y, offset) {
                if (!node) return;

                node.targetX = x;
                node.targetY = y;

                if (node.x === 0 && node.y === 0) {
                    node.x = x;
                    node.y = y;
                }

                if (node.left) {
                    this.calculatePositions(node.left, x - offset, y + 80, offset / 2);
                }
                if (node.right) {
                    this.calculatePositions(node.right, x + offset, y + 80, offset / 2);
                }
            }

            getHeight(node) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            animateInsertion(node) {
                node.y = 0;
                this.animatingNodes.add(node);
            }

            inOrder(node, result = []) {
                if (!node) return result;
                this.inOrder(node.left, result);
                result.push(node.value);
                this.inOrder(node.right, result);
                return result;
            }

            preOrder(node, result = []) {
                if (!node) return result;
                result.push(node.value);
                this.preOrder(node.left, result);
                this.preOrder(node.right, result);
                return result;
            }

            postOrder(node, result = []) {
                if (!node) return result;
                this.postOrder(node.left, result);
                this.postOrder(node.right, result);
                result.push(node.value);
                return result;
            }

            traverse(node, callback) {
                if (!node) return;
                callback(node);
                this.traverse(node.left, callback);
                this.traverse(node.right, callback);
            }

            draw() {
                this.drawConnections(this.root);
                this.drawNodes(this.root);
            }

            drawConnections(node) {
                if (!node) return;

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;

                if (node.left) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.left.x, node.left.y);
                    ctx.stroke();
                    this.drawConnections(node.left);
                }

                if (node.right) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.right.x, node.right.y);
                    ctx.stroke();
                    this.drawConnections(node.right);
                }
            }

            drawNodes(node) {
                if (!node) return;

                node.animate();

                // Draw circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                ctx.fillStyle = node.highlight ? node.highlightColor : '#667eea';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw value
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.value, node.x, node.y);

                this.drawNodes(node.left);
                this.drawNodes(node.right);
            }
        }

        const bst = new BST();

        function insertValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);

            if (isNaN(value)) {
                setStatus('Please enter a valid number');
                return;
            }

            if (bst.insert(value)) {
                setStatus(`Inserted ${value}`);
                input.value = '';
            } else {
                setStatus(`Value ${value} already exists`);
            }
        }

        function searchValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);

            if (isNaN(value)) {
                setStatus('Please enter a valid number');
                return;
            }

            const found = bst.search(value);
            if (found) {
                setStatus(`Found ${value} in the tree`);
            } else {
                setStatus(`Value ${value} not found`);
            }
        }

        function deleteValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);

            if (isNaN(value)) {
                setStatus('Please enter a valid number');
                return;
            }

            bst.delete(value);
            setStatus(`Deleted ${value}`);
            input.value = '';
        }

        function clearTree() {
            bst.root = null;
            setStatus('Tree cleared');
        }

        function generateRandom() {
            clearTree();
            const count = 10 + Math.floor(Math.random() * 5);
            const values = new Set();

            while (values.size < count) {
                values.add(Math.floor(Math.random() * 90) + 10);
            }

            values.forEach(value => bst.insert(value));
            setStatus(`Generated random tree with ${count} nodes`);
        }

        function traverseInOrder() {
            const result = bst.inOrder(bst.root);
            setStatus(`In-Order: ${result.join(', ')}`);
        }

        function traversePreOrder() {
            const result = bst.preOrder(bst.root);
            setStatus(`Pre-Order: ${result.join(', ')}`);
        }

        function traversePostOrder() {
            const result = bst.postOrder(bst.root);
            setStatus(`Post-Order: ${result.join(', ')}`);
        }

        function setStatus(message) {
            statusEl.textContent = message;
        }

        // Handle Enter key for input
        document.getElementById('valueInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                insertValue();
            }
        });

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (bst.root) {
                bst.draw();
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Insert values to build the tree', canvas.width / 2, canvas.height / 2);
            }

            requestAnimationFrame(animate);
        }

        // Initialize with a sample tree
        generateRandom();
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            bst.updatePositions();
        });
    </script>
</body>
</html>
