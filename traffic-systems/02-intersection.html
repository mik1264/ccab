<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intersection Control | Traffic Systems</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        h1 { color: #60a5fa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #60a5fa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #3b82f6; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #60a5fa; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #60a5fa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #60a5fa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Traffic Systems</a>

    <div class="controls">
        <h1>Intersection Control</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Traffic light optimization</p>

        <div class="control-group">
            <label>Spawn Rate: <span class="value" id="spawnValue">0.03</span></label>
            <input type="range" id="spawnRate" min="0.01" max="0.1" step="0.005" value="0.03">
        </div>

        <div class="control-group">
            <label>Light Duration: <span class="value" id="durationValue">100</span></label>
            <input type="range" id="duration" min="30" max="200" step="10" value="100">
        </div>

        <div class="control-group">
            <label>Control Mode</label>
            <select id="controlMode">
                <option value="fixed">Fixed Timer</option>
                <option value="adaptive">Adaptive (Queue-based)</option>
                <option value="roundrobin">Round Robin</option>
            </select>
        </div>

        <div class="control-group">
            <label>Yellow Light Duration: <span class="value" id="yellowValue">15</span></label>
            <input type="range" id="yellowDuration" min="5" max="30" step="5" value="15">
        </div>

        <button id="runBtn">Start Simulation</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time</span>
                <span class="stat-value" id="timeStep">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Cars Passed</span>
                <span class="stat-value" id="carsPassed">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Wait Time</span>
                <span class="stat-value" id="avgWait">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Queue Length</span>
                <span class="stat-value" id="queueLength">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Fixed:</strong> Regular timing intervals.<br>
            <strong>Adaptive:</strong> Adjusts based on queue length.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let cars = [];
        let spawnRate = 0.03;
        let lightDuration = 100;
        let yellowDuration = 15;
        let controlMode = 'fixed';
        let running = false;
        let timeStep = 0;
        let carsPassed = 0;
        let totalWaitTime = 0;

        // Traffic light states
        let lights = {
            north: 'red', south: 'red',
            east: 'green', west: 'green'
        };
        let lightTimer = 0;
        let currentPhase = 0; // 0: EW green, 1: EW yellow, 2: NS green, 3: NS yellow

        const ROAD_WIDTH = 80;
        const CAR_LENGTH = 30;
        const CAR_WIDTH = 20;

        function initSimulation() {
            cars = [];
            timeStep = 0;
            carsPassed = 0;
            totalWaitTime = 0;
            lightTimer = 0;
            currentPhase = 0;
            updateLights();
        }

        function updateLights() {
            switch (currentPhase) {
                case 0: // EW green
                    lights = { north: 'red', south: 'red', east: 'green', west: 'green' };
                    break;
                case 1: // EW yellow
                    lights = { north: 'red', south: 'red', east: 'yellow', west: 'yellow' };
                    break;
                case 2: // NS green
                    lights = { north: 'green', south: 'green', east: 'red', west: 'red' };
                    break;
                case 3: // NS yellow
                    lights = { north: 'yellow', south: 'yellow', east: 'red', west: 'red' };
                    break;
            }
        }

        function getQueueLength(direction) {
            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;
            return cars.filter(c => c.direction === direction && !c.passed).length;
        }

        function spawnCar() {
            const directions = ['north', 'south', 'east', 'west'];
            const dir = directions[Math.floor(Math.random() * 4)];
            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;

            let x, y, vx, vy;
            switch (dir) {
                case 'north':
                    x = centerX + ROAD_WIDTH / 4;
                    y = canvas.height + CAR_LENGTH;
                    vx = 0; vy = -3;
                    break;
                case 'south':
                    x = centerX - ROAD_WIDTH / 4;
                    y = -CAR_LENGTH;
                    vx = 0; vy = 3;
                    break;
                case 'east':
                    x = -CAR_LENGTH;
                    y = centerY + ROAD_WIDTH / 4;
                    vx = 3; vy = 0;
                    break;
                case 'west':
                    x = canvas.width + CAR_LENGTH;
                    y = centerY - ROAD_WIDTH / 4;
                    vx = -3; vy = 0;
                    break;
            }

            cars.push({
                x, y, vx, vy,
                direction: dir,
                waiting: false,
                waitTime: 0,
                passed: false,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`
            });
        }

        function canProceed(car) {
            const light = lights[car.direction];
            return light === 'green';
        }

        function isAtIntersection(car) {
            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;
            const buffer = ROAD_WIDTH + CAR_LENGTH;

            switch (car.direction) {
                case 'north': return car.y < centerY + buffer && car.y > centerY - buffer;
                case 'south': return car.y > centerY - buffer && car.y < centerY + buffer;
                case 'east': return car.x > centerX - buffer && car.x < centerX + buffer;
                case 'west': return car.x < centerX + buffer && car.x > centerX - buffer;
            }
            return false;
        }

        function isNearStopLine(car) {
            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;
            const stopDist = ROAD_WIDTH / 2 + 10;

            switch (car.direction) {
                case 'north': return car.y > centerY + stopDist && car.y < centerY + stopDist + 50;
                case 'south': return car.y < centerY - stopDist && car.y > centerY - stopDist - 50;
                case 'east': return car.x < centerX - stopDist && car.x > centerX - stopDist - 50;
                case 'west': return car.x > centerX + stopDist && car.x < centerX + stopDist + 50;
            }
            return false;
        }

        function update() {
            if (!running) return;

            timeStep++;
            lightTimer++;

            // Traffic light control
            let phaseDuration = currentPhase % 2 === 1 ? yellowDuration : lightDuration;

            if (controlMode === 'adaptive' && currentPhase % 2 === 0) {
                const ewQueue = getQueueLength('east') + getQueueLength('west');
                const nsQueue = getQueueLength('north') + getQueueLength('south');
                const myQueue = currentPhase === 0 ? ewQueue : nsQueue;
                const otherQueue = currentPhase === 0 ? nsQueue : ewQueue;

                if (myQueue === 0 && otherQueue > 3 && lightTimer > 30) {
                    phaseDuration = 30;
                } else if (myQueue > otherQueue * 2) {
                    phaseDuration = lightDuration * 1.5;
                }
            }

            if (lightTimer >= phaseDuration) {
                lightTimer = 0;
                currentPhase = (currentPhase + 1) % 4;
                updateLights();
            }

            // Spawn cars
            if (Math.random() < spawnRate) {
                spawnCar();
            }

            // Update cars
            for (const car of cars) {
                if (car.passed) continue;

                const nearStop = isNearStopLine(car);
                const atIntersection = isAtIntersection(car);

                // Check if should stop
                let shouldStop = false;
                if (nearStop && !canProceed(car)) {
                    shouldStop = true;
                }

                // Check for car ahead
                for (const other of cars) {
                    if (other === car || other.passed) continue;
                    if (other.direction !== car.direction) continue;

                    const dist = Math.abs(car.x - other.x) + Math.abs(car.y - other.y);
                    if (dist < CAR_LENGTH + 10) {
                        const ahead = (car.direction === 'north' && other.y < car.y) ||
                                      (car.direction === 'south' && other.y > car.y) ||
                                      (car.direction === 'east' && other.x > car.x) ||
                                      (car.direction === 'west' && other.x < car.x);
                        if (ahead) shouldStop = true;
                    }
                }

                if (shouldStop) {
                    car.waiting = true;
                    car.waitTime++;
                } else {
                    car.waiting = false;
                    car.x += car.vx;
                    car.y += car.vy;
                }

                // Check if passed through
                const centerX = canvas.width / 2 - 150;
                const centerY = canvas.height / 2;
                if ((car.direction === 'north' && car.y < centerY - ROAD_WIDTH) ||
                    (car.direction === 'south' && car.y > centerY + ROAD_WIDTH) ||
                    (car.direction === 'east' && car.x > centerX + ROAD_WIDTH) ||
                    (car.direction === 'west' && car.x < centerX - ROAD_WIDTH)) {
                    if (!car.passed && isAtIntersection(car)) {
                        car.passed = true;
                        carsPassed++;
                        totalWaitTime += car.waitTime;
                    }
                }

                // Remove off-screen cars
                if (car.x < -100 || car.x > canvas.width + 100 ||
                    car.y < -100 || car.y > canvas.height + 100) {
                    car.passed = true;
                }
            }

            // Clean up passed cars
            cars = cars.filter(c => !c.passed ||
                (c.x > -50 && c.x < canvas.width + 50 && c.y > -50 && c.y < canvas.height + 50));

            updateStats();
        }

        function updateStats() {
            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('carsPassed').textContent = carsPassed;
            document.getElementById('avgWait').textContent = carsPassed > 0 ?
                (totalWaitTime / carsPassed).toFixed(1) : '0';
            document.getElementById('queueLength').textContent = cars.filter(c => c.waiting).length;
        }

        function drawLight(x, y, color) {
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fillStyle = color === 'red' ? '#ef4444' :
                           (color === 'yellow' ? '#fbbf24' : '#22c55e');
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;

            // Draw roads
            ctx.fillStyle = '#333';
            // Vertical road
            ctx.fillRect(centerX - ROAD_WIDTH / 2, 0, ROAD_WIDTH, canvas.height);
            // Horizontal road
            ctx.fillRect(0, centerY - ROAD_WIDTH / 2, canvas.width - 300, ROAD_WIDTH);

            // Intersection
            ctx.fillStyle = '#444';
            ctx.fillRect(centerX - ROAD_WIDTH / 2, centerY - ROAD_WIDTH / 2, ROAD_WIDTH, ROAD_WIDTH);

            // Lane markings
            ctx.setLineDash([20, 15]);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            // Vertical
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, centerY - ROAD_WIDTH / 2);
            ctx.moveTo(centerX, centerY + ROAD_WIDTH / 2);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            // Horizontal
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(centerX - ROAD_WIDTH / 2, centerY);
            ctx.moveTo(centerX + ROAD_WIDTH / 2, centerY);
            ctx.lineTo(canvas.width - 300, centerY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Stop lines
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            // North approach
            ctx.moveTo(centerX, centerY + ROAD_WIDTH / 2 + 5);
            ctx.lineTo(centerX + ROAD_WIDTH / 2, centerY + ROAD_WIDTH / 2 + 5);
            // South approach
            ctx.moveTo(centerX - ROAD_WIDTH / 2, centerY - ROAD_WIDTH / 2 - 5);
            ctx.lineTo(centerX, centerY - ROAD_WIDTH / 2 - 5);
            // East approach
            ctx.moveTo(centerX - ROAD_WIDTH / 2 - 5, centerY);
            ctx.lineTo(centerX - ROAD_WIDTH / 2 - 5, centerY + ROAD_WIDTH / 2);
            // West approach
            ctx.moveTo(centerX + ROAD_WIDTH / 2 + 5, centerY - ROAD_WIDTH / 2);
            ctx.lineTo(centerX + ROAD_WIDTH / 2 + 5, centerY);
            ctx.stroke();

            // Traffic lights
            drawLight(centerX + ROAD_WIDTH / 2 + 20, centerY + ROAD_WIDTH / 2 + 20, lights.north);
            drawLight(centerX - ROAD_WIDTH / 2 - 20, centerY - ROAD_WIDTH / 2 - 20, lights.south);
            drawLight(centerX - ROAD_WIDTH / 2 - 20, centerY + ROAD_WIDTH / 2 + 20, lights.east);
            drawLight(centerX + ROAD_WIDTH / 2 + 20, centerY - ROAD_WIDTH / 2 - 20, lights.west);

            // Draw cars
            for (const car of cars) {
                ctx.save();
                ctx.translate(car.x, car.y);

                if (car.direction === 'north' || car.direction === 'south') {
                    ctx.rotate(car.direction === 'south' ? Math.PI : 0);
                } else {
                    ctx.rotate(car.direction === 'east' ? Math.PI / 2 : -Math.PI / 2);
                }

                ctx.fillStyle = car.color;
                ctx.fillRect(-CAR_WIDTH / 2, -CAR_LENGTH / 2, CAR_WIDTH, CAR_LENGTH);

                // Headlights
                ctx.fillStyle = '#fef9c3';
                ctx.fillRect(-CAR_WIDTH / 2 + 2, -CAR_LENGTH / 2, 4, 3);
                ctx.fillRect(CAR_WIDTH / 2 - 6, -CAR_LENGTH / 2, 4, 3);

                // Brake lights if waiting
                if (car.waiting) {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(-CAR_WIDTH / 2 + 2, CAR_LENGTH / 2 - 3, 4, 3);
                    ctx.fillRect(CAR_WIDTH / 2 - 6, CAR_LENGTH / 2 - 3, 4, 3);
                }

                ctx.restore();
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Intersection Traffic Control', 50, 30);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('spawnRate').oninput = (e) => {
            spawnRate = parseFloat(e.target.value);
            document.getElementById('spawnValue').textContent = spawnRate.toFixed(3);
        };

        document.getElementById('duration').oninput = (e) => {
            lightDuration = parseInt(e.target.value);
            document.getElementById('durationValue').textContent = lightDuration;
        };

        document.getElementById('controlMode').onchange = (e) => {
            controlMode = e.target.value;
        };

        document.getElementById('yellowDuration').oninput = (e) => {
            yellowDuration = parseInt(e.target.value);
            document.getElementById('yellowValue').textContent = yellowDuration;
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Start Simulation';
        };

        document.getElementById('resetBtn').onclick = initSimulation;

        // Initialize
        initSimulation();
        draw();
    </script>
</body>
</html>
