<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roundabout Dynamics | Traffic Systems</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        h1 { color: #60a5fa; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #60a5fa; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #3b82f6; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #60a5fa; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #60a5fa; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #60a5fa; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Traffic Systems</a>

    <div class="controls">
        <h1>Roundabout Dynamics</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Circular intersection flow</p>

        <div class="control-group">
            <label>Spawn Rate: <span class="value" id="spawnValue">0.02</span></label>
            <input type="range" id="spawnRate" min="0.005" max="0.05" step="0.005" value="0.02">
        </div>

        <div class="control-group">
            <label>Roundabout Size: <span class="value" id="sizeValue">120</span></label>
            <input type="range" id="roundaboutSize" min="80" max="180" step="10" value="120">
        </div>

        <div class="control-group">
            <label>Entry Lanes: <span class="value" id="lanesValue">4</span></label>
            <input type="range" id="entryLanes" min="3" max="6" step="1" value="4">
        </div>

        <div class="control-group">
            <label>Yield Distance: <span class="value" id="yieldValue">60</span></label>
            <input type="range" id="yieldDistance" min="30" max="100" step="10" value="60">
        </div>

        <button id="runBtn">Start Simulation</button>
        <button id="resetBtn" style="background:#444;color:#fff">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time</span>
                <span class="stat-value" id="timeStep">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Cars Completed</span>
                <span class="stat-value" id="carsCompleted">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">In Roundabout</span>
                <span class="stat-value" id="inRoundabout">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Transit Time</span>
                <span class="stat-value" id="avgTransit">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Yield:</strong> Entering cars yield to circulating traffic.<br>
            <strong>Flow:</strong> Continuous flow without signal stops.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let cars = [];
        let spawnRate = 0.02;
        let roundaboutRadius = 120;
        let numLanes = 4;
        let yieldDistance = 60;
        let running = false;
        let timeStep = 0;
        let carsCompleted = 0;
        let totalTransitTime = 0;

        const ROAD_WIDTH = 50;
        const CAR_SIZE = 15;

        function initSimulation() {
            cars = [];
            timeStep = 0;
            carsCompleted = 0;
            totalTransitTime = 0;
        }

        function getEntryAngle(lane) {
            return (lane / numLanes) * Math.PI * 2 - Math.PI / 2;
        }

        function spawnCar() {
            const entryLane = Math.floor(Math.random() * numLanes);
            const exitLane = (entryLane + 1 + Math.floor(Math.random() * (numLanes - 1))) % numLanes;

            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;
            const angle = getEntryAngle(entryLane);
            const dist = roundaboutRadius + ROAD_WIDTH * 3;

            cars.push({
                x: centerX + Math.cos(angle) * dist,
                y: centerY + Math.sin(angle) * dist,
                angle: angle + Math.PI,
                speed: 0,
                maxSpeed: 2 + Math.random(),
                entryLane,
                exitLane,
                state: 'approaching', // approaching, entering, circulating, exiting, done
                circleAngle: angle,
                transitTime: 0,
                yielding: false,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`
            });
        }

        function getCarAtAngle(angle, excludeCar) {
            const tolerance = 0.3;
            for (const car of cars) {
                if (car === excludeCar) continue;
                if (car.state !== 'circulating' && car.state !== 'entering') continue;
                const diff = Math.abs(car.circleAngle - angle);
                if (diff < tolerance || diff > Math.PI * 2 - tolerance) return car;
            }
            return null;
        }

        function update() {
            if (!running) return;

            timeStep++;

            // Spawn cars
            if (Math.random() < spawnRate) {
                spawnCar();
            }

            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;

            for (const car of cars) {
                if (car.state === 'done') continue;

                car.transitTime++;
                const entryAngle = getEntryAngle(car.entryLane);
                const exitAngle = getEntryAngle(car.exitLane);

                switch (car.state) {
                    case 'approaching':
                        // Move toward entry point
                        const targetX = centerX + Math.cos(entryAngle) * (roundaboutRadius + ROAD_WIDTH / 2);
                        const targetY = centerY + Math.sin(entryAngle) * (roundaboutRadius + ROAD_WIDTH / 2);
                        const dx = targetX - car.x;
                        const dy = targetY - car.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Check for cars ahead
                        let blocked = false;
                        for (const other of cars) {
                            if (other === car || other.state === 'done') continue;
                            const odist = Math.sqrt((other.x - car.x) ** 2 + (other.y - car.y) ** 2);
                            if (odist < CAR_SIZE * 2) {
                                const dotProduct = dx * (other.x - car.x) + dy * (other.y - car.y);
                                if (dotProduct > 0) blocked = true;
                            }
                        }

                        // Check for circulating traffic
                        const checkAngle = entryAngle - 0.5;
                        const circulatingCar = getCarAtAngle(checkAngle, car);
                        if (circulatingCar && dist < yieldDistance) {
                            car.yielding = true;
                            blocked = true;
                        } else {
                            car.yielding = false;
                        }

                        if (!blocked) {
                            car.speed = Math.min(car.maxSpeed, car.speed + 0.1);
                        } else {
                            car.speed = Math.max(0, car.speed - 0.2);
                        }

                        if (dist > 5) {
                            car.x += (dx / dist) * car.speed;
                            car.y += (dy / dist) * car.speed;
                            car.angle = Math.atan2(dy, dx);
                        } else if (!blocked) {
                            car.state = 'entering';
                            car.circleAngle = entryAngle;
                        }
                        break;

                    case 'entering':
                    case 'circulating':
                        car.state = 'circulating';

                        // Move around the circle (counterclockwise)
                        car.circleAngle -= 0.02 * car.maxSpeed;
                        if (car.circleAngle < -Math.PI) car.circleAngle += Math.PI * 2;

                        car.x = centerX + Math.cos(car.circleAngle) * roundaboutRadius;
                        car.y = centerY + Math.sin(car.circleAngle) * roundaboutRadius;
                        car.angle = car.circleAngle - Math.PI / 2;

                        // Check if at exit
                        const exitDiff = Math.abs(car.circleAngle - exitAngle);
                        if (exitDiff < 0.2 || exitDiff > Math.PI * 2 - 0.2) {
                            car.state = 'exiting';
                        }
                        break;

                    case 'exiting':
                        // Move away from roundabout
                        const exitX = centerX + Math.cos(exitAngle) * (roundaboutRadius + ROAD_WIDTH * 3);
                        const exitY = centerY + Math.sin(exitAngle) * (roundaboutRadius + ROAD_WIDTH * 3);
                        const edx = exitX - car.x;
                        const edy = exitY - car.y;
                        const edist = Math.sqrt(edx * edx + edy * edy);

                        car.x += (edx / edist) * car.maxSpeed;
                        car.y += (edy / edist) * car.maxSpeed;
                        car.angle = Math.atan2(edy, edx);

                        if (edist < 10) {
                            car.state = 'done';
                            carsCompleted++;
                            totalTransitTime += car.transitTime;
                        }
                        break;
                }
            }

            // Remove completed cars
            cars = cars.filter(c => c.state !== 'done');

            updateStats();
        }

        function updateStats() {
            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('carsCompleted').textContent = carsCompleted;
            document.getElementById('inRoundabout').textContent = cars.filter(c => c.state === 'circulating').length;
            document.getElementById('avgTransit').textContent = carsCompleted > 0 ?
                (totalTransitTime / carsCompleted).toFixed(1) : '0';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            update();

            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2;

            // Draw approach roads
            ctx.fillStyle = '#333';
            for (let i = 0; i < numLanes; i++) {
                const angle = getEntryAngle(i);
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                ctx.fillRect(roundaboutRadius + ROAD_WIDTH / 2, -ROAD_WIDTH / 2, 300, ROAD_WIDTH);
                ctx.restore();
            }

            // Draw roundabout circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, roundaboutRadius + ROAD_WIDTH / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.fill();

            // Inner island
            ctx.beginPath();
            ctx.arc(centerX, centerY, roundaboutRadius - ROAD_WIDTH / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#2d5a2d';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Outer edge
            ctx.beginPath();
            ctx.arc(centerX, centerY, roundaboutRadius + ROAD_WIDTH / 2, 0, Math.PI * 2);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Direction arrows
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * roundaboutRadius;
                const y = centerY + Math.sin(angle) * roundaboutRadius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle - Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(-5, 5);
                ctx.lineTo(0, -5);
                ctx.lineTo(5, 5);
                ctx.stroke();
                ctx.restore();
            }

            // Yield signs
            for (let i = 0; i < numLanes; i++) {
                const angle = getEntryAngle(i);
                const x = centerX + Math.cos(angle) * (roundaboutRadius + ROAD_WIDTH * 1.5);
                const y = centerY + Math.sin(angle) * (roundaboutRadius + ROAD_WIDTH * 1.5);

                ctx.beginPath();
                ctx.moveTo(x, y - 10);
                ctx.lineTo(x - 8, y + 5);
                ctx.lineTo(x + 8, y + 5);
                ctx.closePath();
                ctx.fillStyle = '#ef4444';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw cars
            for (const car of cars) {
                if (car.state === 'done') continue;

                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.rotate(car.angle);

                // Car body
                ctx.fillStyle = car.yielding ? '#fbbf24' : car.color;
                ctx.fillRect(-CAR_SIZE / 2, -CAR_SIZE / 3, CAR_SIZE, CAR_SIZE * 0.66);

                // Direction indicator
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(CAR_SIZE / 2 - 2, 0);
                ctx.lineTo(CAR_SIZE / 2 - 5, -3);
                ctx.lineTo(CAR_SIZE / 2 - 5, 3);
                ctx.fill();

                ctx.restore();
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Roundabout Traffic Flow', 50, 30);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('spawnRate').oninput = (e) => {
            spawnRate = parseFloat(e.target.value);
            document.getElementById('spawnValue').textContent = spawnRate.toFixed(3);
        };

        document.getElementById('roundaboutSize').oninput = (e) => {
            roundaboutRadius = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = roundaboutRadius;
        };

        document.getElementById('entryLanes').oninput = (e) => {
            numLanes = parseInt(e.target.value);
            document.getElementById('lanesValue').textContent = numLanes;
        };

        document.getElementById('yieldDistance').oninput = (e) => {
            yieldDistance = parseInt(e.target.value);
            document.getElementById('yieldValue').textContent = yieldDistance;
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Start Simulation';
        };

        document.getElementById('resetBtn').onclick = initSimulation;

        // Initialize
        initSimulation();
        draw();
    </script>
</body>
</html>
