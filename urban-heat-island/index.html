<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Urban Heat Island Effect</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 18px; font-family: sans-serif; z-index: 999; text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 999; }
.panel { background: rgba(0,0,0,0.75); color: #e0e0e0; padding: 12px 16px; border-radius: 8px; font-size: 13px; min-width: 200px; }
.panel label { display: block; margin: 6px 0 2px; color: #fbbf24; }
.panel input[type=range] { width: 100%; }
.panel button { background: #fbbf24; color: #0a0e1a; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 6px; width: 100%; }
.panel button:hover { background: #f59e0b; }
#stats { color: #aaa; margin-top: 8px; line-height: 1.6; }
.legend-bar { height: 12px; width: 100%; border-radius: 3px; margin: 4px 0; background: linear-gradient(90deg, #2563eb, #06b6d4, #22c55e, #eab308, #f97316, #ef4444, #991b1b); }
.legend-labels { display: flex; justify-content: space-between; font-size: 10px; color: #999; }
.btn-group { display: flex; gap: 4px; margin-top: 6px; }
.btn-group button { flex: 1; }
.btn-active { background: #f59e0b !important; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Urban Heat Island Effect</div>
<div id="ui">
    <div class="panel">
        <label>Vegetation Level: <span id="vegVal">30</span>%</label>
        <input type="range" id="vegetation" min="0" max="100" value="30">
        <label>Urban Density: <span id="densVal">70</span>%</label>
        <input type="range" id="density" min="10" max="100" value="70">
        <label>Wind Speed: <span id="windVal">5</span></label>
        <input type="range" id="wind" min="0" max="20" value="5">
        <div class="btn-group">
            <button id="btnHeat" class="btn-active">Heat Map</button>
            <button id="btnLand">Land Use</button>
        </div>
        <button id="addPark">Add Park (click map)</button>
        <button id="addWater">Add Water (click map)</button>
        <button id="resetBtn">Reset City</button>
        <div style="margin-top: 8px; color: #fbbf24;">Temperature Scale</div>
        <div class="legend-bar"></div>
        <div class="legend-labels"><span>15C</span><span>25C</span><span>35C</span><span>45C</span></div>
        <div id="stats"></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H, gridW, gridH, cellSize;
    let landUse, temperature, newTemp;
    let vegetation = 30;
    let urbanDensity = 70;
    let windSpeed = 5;
    let viewMode = 'heat';
    let placingMode = null;
    let frame = 0;

    // Land types: 0=empty/suburb, 1=building, 2=road, 3=park, 4=water
    const EMPTY = 0, BUILDING = 1, ROAD = 2, PARK = 3, WATER = 4;

    const landColors = ['#2d3436', '#636e72', '#4a4a4a', '#27ae60', '#2980b9'];
    const baseTemp = { [EMPTY]: 28, [BUILDING]: 38, [ROAD]: 36, [PARK]: 20, [WATER]: 18 };

    document.getElementById('vegetation').addEventListener('input', function() {
        vegetation = parseInt(this.value);
        document.getElementById('vegVal').textContent = vegetation;
        generateCity();
    });
    document.getElementById('density').addEventListener('input', function() {
        urbanDensity = parseInt(this.value);
        document.getElementById('densVal').textContent = urbanDensity;
        generateCity();
    });
    document.getElementById('wind').addEventListener('input', function() {
        windSpeed = parseInt(this.value);
        document.getElementById('windVal').textContent = windSpeed;
    });
    document.getElementById('btnHeat').addEventListener('click', function() {
        viewMode = 'heat'; this.classList.add('btn-active'); document.getElementById('btnLand').classList.remove('btn-active');
    });
    document.getElementById('btnLand').addEventListener('click', function() {
        viewMode = 'land'; this.classList.add('btn-active'); document.getElementById('btnHeat').classList.remove('btn-active');
    });
    document.getElementById('addPark').addEventListener('click', function() { placingMode = PARK; });
    document.getElementById('addWater').addEventListener('click', function() { placingMode = WATER; });
    document.getElementById('resetBtn').addEventListener('click', function() { placingMode = null; generateCity(); });

    canvas.addEventListener('click', function(e) {
        if (placingMode !== null) {
            const gx = Math.floor(e.clientX / cellSize);
            const gy = Math.floor(e.clientY / cellSize);
            const radius = 4;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const nx = gx + dx, ny = gy + dy;
                        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                            landUse[ny * gridW + nx] = placingMode;
                        }
                    }
                }
            }
        }
    });

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        cellSize = 5;
        gridW = Math.floor(W / cellSize);
        gridH = Math.floor(H / cellSize);
    }

    function generateCity() {
        landUse = new Uint8Array(gridW * gridH);
        temperature = new Float32Array(gridW * gridH);
        newTemp = new Float32Array(gridW * gridH);
        const cx = gridW / 2, cy = gridH / 2;
        const maxR = Math.min(gridW, gridH) * 0.45;

        for (let y = 0; y < gridH; y++) {
            for (let x = 0; x < gridW; x++) {
                const dx = x - cx, dy = y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const urbanProb = Math.max(0, 1 - dist / maxR) * (urbanDensity / 100);
                const idx = y * gridW + x;

                if (dist < maxR * 0.1) {
                    // Dense core
                    landUse[idx] = Math.random() < 0.8 ? BUILDING : ROAD;
                } else if (dist < maxR * 0.5) {
                    // Urban area
                    if (Math.random() < urbanProb * 0.7) {
                        landUse[idx] = Math.random() < 0.7 ? BUILDING : ROAD;
                    } else if (Math.random() < vegetation / 200) {
                        landUse[idx] = PARK;
                    }
                } else if (dist < maxR * 0.8) {
                    // Suburbs
                    if (Math.random() < urbanProb * 0.3) {
                        landUse[idx] = BUILDING;
                    } else if (Math.random() < vegetation / 100) {
                        landUse[idx] = PARK;
                    }
                } else {
                    // Outskirts
                    if (Math.random() < vegetation / 80) {
                        landUse[idx] = PARK;
                    }
                }

                // Roads: grid pattern
                if ((x % 12 === 0 || y % 12 === 0) && dist < maxR * 0.6 && Math.random() < urbanProb) {
                    landUse[idx] = ROAD;
                }

                // Initialize temperature
                temperature[idx] = baseTemp[landUse[idx]] + (Math.random() - 0.5) * 2;
            }
        }

        // Add some water bodies
        for (let i = 0; i < 3; i++) {
            const wx = Math.floor(cx + (Math.random() - 0.5) * maxR * 1.2);
            const wy = Math.floor(cy + (Math.random() - 0.5) * maxR * 1.2);
            const wr = 5 + Math.random() * 10;
            for (let dy = -wr; dy <= wr; dy++) {
                for (let dx = -wr; dx <= wr; dx++) {
                    if (dx * dx + dy * dy <= wr * wr) {
                        const nx = wx + Math.floor(dx), ny = wy + Math.floor(dy);
                        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                            landUse[ny * gridW + nx] = WATER;
                            temperature[ny * gridW + nx] = baseTemp[WATER];
                        }
                    }
                }
            }
        }
    }

    function simulateHeat() {
        const diffRate = 0.15 + windSpeed * 0.01;
        for (let y = 1; y < gridH - 1; y++) {
            for (let x = 1; x < gridW - 1; x++) {
                const idx = y * gridW + x;
                const land = landUse[idx];
                const target = baseTemp[land];

                // Diffusion with neighbors
                let sum = 0, count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        // Wind bias: favor diffusion from upwind (left)
                        let weight = 1;
                        if (dx === -1) weight += windSpeed * 0.05;
                        sum += temperature[(y + dy) * gridW + (x + dx)] * weight;
                        count += weight;
                    }
                }
                const avgNeighbor = sum / count;

                // Blend between target temp and diffused temp
                newTemp[idx] = temperature[idx] * 0.7 + avgNeighbor * diffRate + target * (0.3 - diffRate);

                // Vegetation cooling effect
                if (land === PARK) newTemp[idx] -= vegetation * 0.02;
                if (land === WATER) newTemp[idx] = Math.min(newTemp[idx], 20);
            }
        }

        const tmp = temperature;
        temperature = newTemp;
        newTemp = tmp;
    }

    function tempToColor(t) {
        // 15-45C range
        const norm = Math.max(0, Math.min(1, (t - 15) / 30));
        let r, g, b;
        if (norm < 0.2) { // Blue to cyan
            const s = norm / 0.2;
            r = 37; g = Math.floor(99 + s * 83); b = Math.floor(235 - s * 37);
        } else if (norm < 0.4) { // Cyan to green
            const s = (norm - 0.2) / 0.2;
            r = Math.floor(6 + s * 28); g = Math.floor(182 + s * 15); b = Math.floor(198 - s * 121);
        } else if (norm < 0.6) { // Green to yellow
            const s = (norm - 0.4) / 0.2;
            r = Math.floor(34 + s * 200); g = Math.floor(197 - s * 28); b = Math.floor(77 - s * 69);
        } else if (norm < 0.8) { // Yellow to orange
            const s = (norm - 0.6) / 0.2;
            r = Math.floor(234 + s * 15); g = Math.floor(169 - s * 52); b = Math.floor(8 + s * 14);
        } else { // Orange to red
            const s = (norm - 0.8) / 0.2;
            r = Math.floor(249 - s * 10); g = Math.floor(117 - s * 89); b = Math.floor(22 - s * 2);
        }
        return `rgb(${r},${g},${b})`;
    }

    function draw() {
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, W, H);

        let minT = Infinity, maxT = -Infinity, sumT = 0, urbanT = 0, urbanC = 0, suburbT = 0, suburbC = 0;
        const cx = gridW / 2, cy = gridH / 2;
        const maxR = Math.min(gridW, gridH) * 0.45;

        for (let y = 0; y < gridH; y++) {
            for (let x = 0; x < gridW; x++) {
                const idx = y * gridW + x;
                const t = temperature[idx];
                sumT += t;
                if (t < minT) minT = t;
                if (t > maxT) maxT = t;

                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                if (dist < maxR * 0.3) { urbanT += t; urbanC++; }
                else if (dist > maxR * 0.6) { suburbT += t; suburbC++; }

                if (viewMode === 'heat') {
                    ctx.fillStyle = tempToColor(t);
                } else {
                    ctx.fillStyle = landColors[landUse[idx]];
                }
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }

        // Wind direction indicator
        ctx.save();
        ctx.translate(80, H - 40);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.lineTo(8, -6);
        ctx.moveTo(15, 0);
        ctx.lineTo(8, 6);
        ctx.stroke();
        ctx.fillStyle = '#fbbf24';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Wind', 0, 18);
        ctx.restore();

        const avgT = sumT / (gridW * gridH);
        const avgUrban = urbanC > 0 ? urbanT / urbanC : 0;
        const avgSuburb = suburbC > 0 ? suburbT / suburbC : 0;

        document.getElementById('stats').innerHTML =
            `Avg Temp: ${avgT.toFixed(1)}C<br>` +
            `Urban Core: ${avgUrban.toFixed(1)}C<br>` +
            `Suburbs: ${avgSuburb.toFixed(1)}C<br>` +
            `Heat Island: +${(avgUrban - avgSuburb).toFixed(1)}C<br>` +
            `Range: ${minT.toFixed(1)} - ${maxT.toFixed(1)}C`;
    }

    window.addEventListener('resize', function() {
        resize();
        generateCity();
    });

    function animate() {
        frame++;
        simulateHeat();
        draw();
        requestAnimationFrame(animate);
    }

    resize();
    generateCity();
    animate();
})();
</script>
</body>
</html>
