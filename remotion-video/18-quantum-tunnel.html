<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Tunneling - Advanced Wave Packet Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050510;
            overflow: hidden;
            font-family: monospace;
        }
        canvas { display: block; }
        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }

        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center,
                transparent 40%,
                rgba(2, 2, 12, 0.4) 70%,
                rgba(2, 2, 12, 0.85) 100%
            );
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, 0.06) 2px,
                rgba(0, 0, 0, 0.06) 4px
            );
        }

        .film-grain {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 7;
            opacity: 0.04;
            mix-blend-mode: overlay;
        }

        .controls {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 10;
            background: rgba(10, 15, 30, 0.75);
            backdrop-filter: blur(10px);
            padding: 0.6rem 1rem;
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.12);
            max-width: 95vw;
        }
        .controls label {
            font-family: monospace;
            font-size: 0.6rem;
            color: rgba(100, 200, 255, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }
        .controls .value {
            color: rgba(100, 200, 255, 0.8);
            font-size: 0.6rem;
            min-width: 2.5em;
            text-align: center;
        }
        input[type="range"] {
            width: 80px;
            accent-color: #64c8ff;
        }
        .controls select, .controls button {
            background: rgba(20, 30, 50, 0.8);
            color: rgba(100, 200, 255, 0.7);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.6rem;
            padding: 0.3rem 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .controls select:hover, .controls button:hover {
            border-color: rgba(100, 200, 255, 0.5);
            color: rgba(100, 200, 255, 1);
        }
        .controls button.active {
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(100, 200, 255, 0.5);
        }

        .info {
            position: fixed;
            top: 1rem;
            right: 1rem;
            font-family: monospace;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.4);
            text-align: right;
            z-index: 10;
            line-height: 1.6;
            background: rgba(10, 15, 30, 0.5);
            backdrop-filter: blur(10px);
            padding: 0.6rem 0.8rem;
            border-radius: 8px;
            border: 1px solid rgba(100, 200, 255, 0.08);
        }

        .title-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: monospace;
            text-align: center;
            z-index: 8;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.5s;
        }
        .title-overlay.visible { opacity: 1; }
        .title-overlay h1 {
            font-size: 1.8rem;
            color: rgba(100, 200, 255, 0.15);
            font-weight: 300;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }
        .title-overlay p {
            font-size: 0.75rem;
            color: rgba(100, 200, 255, 0.1);
            margin-top: 0.5rem;
            letter-spacing: 0.15em;
        }

        .legend {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: monospace;
            font-size: 0.55rem;
            z-index: 10;
            display: flex;
            gap: 1rem;
            background: rgba(10, 15, 30, 0.5);
            backdrop-filter: blur(10px);
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            border: 1px solid rgba(100, 200, 255, 0.08);
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .legend-swatch {
            width: 14px;
            height: 3px;
            border-radius: 1px;
        }
        .legend-label {
            color: rgba(200, 210, 220, 0.4);
        }

        .equation-display {
            position: fixed;
            bottom: 5.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: monospace;
            font-size: 0.6rem;
            color: rgba(100, 200, 255, 0.2);
            z-index: 10;
            letter-spacing: 0.05em;
            text-align: center;
            pointer-events: none;
        }

        .counters {
            position: fixed;
            top: 1rem;
            left: 6rem;
            font-family: monospace;
            font-size: 0.6rem;
            z-index: 10;
            line-height: 1.7;
            background: rgba(10, 15, 30, 0.5);
            backdrop-filter: blur(10px);
            padding: 0.5rem 0.7rem;
            border-radius: 8px;
            border: 1px solid rgba(100, 200, 255, 0.08);
        }
        .counters .t-count { color: rgba(0, 200, 255, 0.6); }
        .counters .r-count { color: rgba(255, 100, 180, 0.6); }
        .counters .runs { color: rgba(200, 210, 220, 0.3); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>
    <div class="vignette"></div>
    <div class="scanlines"></div>
    <canvas id="grainCanvas" class="film-grain"></canvas>
    <canvas id="canvas"></canvas>

    <div class="title-overlay" id="titleOverlay">
        <h1>Quantum Tunneling</h1>
        <p>wave packets &middot; potential barriers &middot; time-dependent schr&ouml;dinger equation</p>
    </div>

    <div class="legend" id="legend"></div>

    <div class="counters" id="counters">
        <div class="t-count">T: 0 transmitted</div>
        <div class="r-count">R: 0 reflected</div>
        <div class="runs">0 runs | ratio --</div>
    </div>

    <div class="info" id="info"></div>

    <div class="equation-display" id="eqDisplay">
        i&#x210F; &part;&psi;/&part;t = [-&#x210F;&sup2;/(2m) &nabla;&sup2; + V(x)] &psi;(x,t)
    </div>

    <div class="controls">
        <label>
            Barrier
            <select id="barrierType">
                <option value="single">Single</option>
                <option value="double">Double (Resonant)</option>
                <option value="step">Step</option>
                <option value="triangle">Triangle</option>
                <option value="well">Quantum Well</option>
            </select>
        </label>
        <label>
            Height
            <input type="range" id="barrierSlider" min="0" max="100" value="50">
            <span class="value" id="barrierVal">50</span>
        </label>
        <label>
            Energy
            <input type="range" id="energySlider" min="5" max="100" value="40">
            <span class="value" id="energyVal">40</span>
        </label>
        <label>
            Packets
            <input type="range" id="packetSlider" min="1" max="5" value="1">
            <span class="value" id="packetVal">1</span>
        </label>
        <label>
            Display
            <select id="displayMode">
                <option value="all">All</option>
                <option value="prob">|&psi;|&sup2;</option>
                <option value="real">Re(&psi;)</option>
                <option value="imag">Im(&psi;)</option>
                <option value="phase">Phase</option>
            </select>
        </label>
        <button id="launchBtn">Launch</button>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const grainCanvas = document.getElementById('grainCanvas');
        const grainCtx = grainCanvas.getContext('2d');
        const titleOverlay = document.getElementById('titleOverlay');
        const infoEl = document.getElementById('info');
        const legendEl = document.getElementById('legend');
        const countersEl = document.getElementById('counters');
        const eqDisplay = document.getElementById('eqDisplay');

        const barrierSlider = document.getElementById('barrierSlider');
        const energySlider = document.getElementById('energySlider');
        const packetSlider = document.getElementById('packetSlider');
        const barrierVal = document.getElementById('barrierVal');
        const energyVal = document.getElementById('energyVal');
        const packetVal = document.getElementById('packetVal');
        const barrierTypeSelect = document.getElementById('barrierType');
        const displayModeSelect = document.getElementById('displayMode');
        const launchBtn = document.getElementById('launchBtn');

        let W, H;
        let animId = null;
        let stepCount = 0;

        // --- Simulation parameters ---
        const N = 1024;
        const dx = 1.0;
        const dt = 0.5;
        const hbar = 1.0;
        const mass = 1.0;

        // Multiple wave packets
        let packets = [];
        const MAX_PACKETS = 5;

        // Potential
        let V = new Float64Array(N);

        // Parameters
        let barrierHeight = 0.5;
        let particleEnergy = 0.4;
        let barrierType = 'single';
        let displayMode = 'all';
        let numPackets = 1;

        // Barrier geometry
        const barrierCenter = Math.floor(N * 0.6);
        const barrierWidth = 30;

        // Counters
        let totalTransmitted = 0;
        let totalReflected = 0;
        let totalRuns = 0;

        // Bound state eigenvalues for well mode
        let eigenEnergies = [];

        // Film grain frame counter
        let grainFrame = 0;

        function createPacket(energyFactor) {
            const pkt = {
                psiRe: new Float64Array(N),
                psiIm: new Float64Array(N),
                probDensity: new Float64Array(N),
                maxProb: 0,
                transmissionProb: 0,
                reflectionProb: 0,
                energy: particleEnergy * energyFactor,
                alive: true,
                age: 0
            };

            const x0 = N * 0.2;
            const sigma = 35;
            const k0 = Math.sqrt(2 * mass * pkt.energy) / hbar;

            let norm = 0;
            for (let i = 0; i < N; i++) {
                const x = i - x0;
                const envelope = Math.exp(-x * x / (2 * sigma * sigma));
                pkt.psiRe[i] = envelope * Math.cos(k0 * i * dx);
                pkt.psiIm[i] = envelope * Math.sin(k0 * i * dx);
                norm += pkt.psiRe[i] * pkt.psiRe[i] + pkt.psiIm[i] * pkt.psiIm[i];
            }

            norm = Math.sqrt(norm * dx);
            if (norm > 0) {
                for (let i = 0; i < N; i++) {
                    pkt.psiRe[i] /= norm;
                    pkt.psiIm[i] /= norm;
                }
            }

            return pkt;
        }

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            grainCanvas.width = W;
            grainCanvas.height = H;
        }

        function setupPotential() {
            for (let i = 0; i < N; i++) V[i] = 0;

            const bLeft = barrierCenter - barrierWidth / 2;
            const bRight = barrierCenter + barrierWidth / 2;

            switch (barrierType) {
                case 'single':
                    for (let i = bLeft; i <= bRight; i++) {
                        if (i >= 0 && i < N) V[i] = barrierHeight;
                    }
                    break;

                case 'double': {
                    const gap = 12;
                    const w = 10;
                    const c1 = barrierCenter - gap;
                    const c2 = barrierCenter + gap;
                    for (let i = c1 - w; i <= c1 + w; i++) {
                        if (i >= 0 && i < N) V[i] = barrierHeight;
                    }
                    for (let i = c2 - w; i <= c2 + w; i++) {
                        if (i >= 0 && i < N) V[i] = barrierHeight;
                    }
                    break;
                }

                case 'step':
                    for (let i = barrierCenter; i < N; i++) {
                        V[i] = barrierHeight * 0.7;
                    }
                    break;

                case 'triangle':
                    for (let i = bLeft; i <= bRight; i++) {
                        if (i >= 0 && i < N) {
                            const t = (i - bLeft) / (bRight - bLeft);
                            V[i] = barrierHeight * (t < 0.5 ? 2 * t : 2 * (1 - t));
                        }
                    }
                    break;

                case 'well':
                    for (let i = 0; i < N; i++) {
                        if (i < bLeft || i > bRight) {
                            V[i] = barrierHeight;
                        }
                    }
                    computeEigenEnergies();
                    break;
            }

            V[0] = 1e6;
            V[N - 1] = 1e6;
        }

        function computeEigenEnergies() {
            eigenEnergies = [];
            const wellWidth = barrierWidth * dx;
            for (let n = 1; n <= 12; n++) {
                const En = (n * n * Math.PI * Math.PI * hbar * hbar) / (2 * mass * wellWidth * wellWidth);
                if (En < barrierHeight) {
                    eigenEnergies.push(En);
                }
            }
        }

        function initPackets() {
            packets = [];
            for (let p = 0; p < numPackets; p++) {
                const eFactor = numPackets === 1 ? 1.0 : 0.6 + (p / (numPackets - 1)) * 0.8;
                packets.push(createPacket(eFactor));
            }
            stepCount = 0;
        }

        function evolvePacket(pkt) {
            if (!pkt.alive) return;
            const coeff = hbar / (2 * mass * dx * dx);
            const re = pkt.psiRe;
            const im = pkt.psiIm;

            for (let i = 1; i < N - 1; i++) {
                const kinetic = -coeff * (im[i + 1] - 2 * im[i] + im[i - 1]);
                const potential = V[i] * im[i] / hbar;
                re[i] += (dt / 2) * (kinetic + potential);
            }

            for (let i = 1; i < N - 1; i++) {
                const kinetic = -coeff * (re[i + 1] - 2 * re[i] + re[i - 1]);
                const potential = V[i] * re[i] / hbar;
                im[i] -= dt * (kinetic + potential);
            }

            for (let i = 1; i < N - 1; i++) {
                const kinetic = -coeff * (im[i + 1] - 2 * im[i] + im[i - 1]);
                const potential = V[i] * im[i] / hbar;
                re[i] += (dt / 2) * (kinetic + potential);
            }

            pkt.age++;
        }

        function computeProbabilityPacket(pkt) {
            pkt.maxProb = 0;
            pkt.transmissionProb = 0;
            pkt.reflectionProb = 0;
            let totalProb = 0;

            for (let i = 0; i < N; i++) {
                pkt.probDensity[i] = pkt.psiRe[i] * pkt.psiRe[i] + pkt.psiIm[i] * pkt.psiIm[i];
                if (pkt.probDensity[i] > pkt.maxProb) pkt.maxProb = pkt.probDensity[i];
                totalProb += pkt.probDensity[i] * dx;

                if (i > barrierCenter + barrierWidth) {
                    pkt.transmissionProb += pkt.probDensity[i] * dx;
                }
                if (i < barrierCenter - barrierWidth * 2) {
                    pkt.reflectionProb += pkt.probDensity[i] * dx;
                }
            }

            if (totalProb > 0) {
                pkt.transmissionProb /= totalProb;
                pkt.reflectionProb /= totalProb;
            }
        }

        function computeExpectationValues(pkt) {
            let expX = 0, expX2 = 0, expP = 0, expP2 = 0, totalProb = 0;

            for (let i = 1; i < N - 1; i++) {
                const prob = pkt.probDensity[i];
                totalProb += prob * dx;
                expX += i * dx * prob * dx;
                expX2 += i * dx * i * dx * prob * dx;

                // Momentum: -i hbar d/dx, using central difference
                const dReIdx = (pkt.psiRe[i + 1] - pkt.psiRe[i - 1]) / (2 * dx);
                const dImIdx = (pkt.psiIm[i + 1] - pkt.psiIm[i - 1]) / (2 * dx);
                // <p> = integral psi* (-i hbar d/dx) psi dx
                // = hbar * integral (psiRe * dImIdx - psiIm * dReIdx) dx (for real expectation)
                const pLocal = hbar * (pkt.psiRe[i] * dImIdx - pkt.psiIm[i] * dReIdx);
                expP += pLocal * dx;

                // <p^2> approximate
                const d2Re = (pkt.psiRe[i + 1] - 2 * pkt.psiRe[i] + pkt.psiRe[i - 1]) / (dx * dx);
                const d2Im = (pkt.psiIm[i + 1] - 2 * pkt.psiIm[i] + pkt.psiIm[i - 1]) / (dx * dx);
                const p2Local = -hbar * hbar * (pkt.psiRe[i] * d2Re + pkt.psiIm[i] * d2Im);
                expP2 += p2Local * dx;
            }

            if (totalProb > 0) {
                expX /= totalProb;
                expX2 /= totalProb;
                expP /= totalProb;
                expP2 /= totalProb;
            }

            const deltaX = Math.sqrt(Math.max(0, expX2 - expX * expX));
            const deltaP = Math.sqrt(Math.max(0, expP2 - expP * expP));

            return { expX, expP, deltaX, deltaP };
        }

        function analyticalTransmission() {
            // T for single rectangular barrier (approximate)
            if (barrierType !== 'single' && barrierType !== 'double') return null;
            const E = particleEnergy;
            const V0 = barrierHeight;
            if (V0 <= 0) return 1;

            if (E >= V0) {
                const k1 = Math.sqrt(2 * mass * E) / hbar;
                const k2 = Math.sqrt(2 * mass * (E - V0)) / hbar;
                const L = barrierWidth * dx;
                const sinTerm = Math.sin(k2 * L);
                const denom = 1 + ((k1 * k1 - k2 * k2) * sinTerm / (2 * k1 * k2)) ** 2;
                return 1 / denom;
            } else {
                const k1 = Math.sqrt(2 * mass * E) / hbar;
                const kappa = Math.sqrt(2 * mass * (V0 - E)) / hbar;
                const L = barrierWidth * dx;
                const sinhTerm = Math.sinh(kappa * L);
                const denom = 1 + ((k1 * k1 + kappa * kappa) * sinhTerm / (2 * k1 * kappa)) ** 2;
                return 1 / denom;
            }
        }

        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, '#060818');
            grad.addColorStop(0.5, '#050510');
            grad.addColorStop(1, '#030308');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            ctx.strokeStyle = 'rgba(100, 200, 255, 0.02)';
            ctx.lineWidth = 0.5;
            const gridSpacing = 50;
            for (let x = 0; x < W; x += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, H);
                ctx.stroke();
            }
            for (let y = 0; y < H; y += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }
        }

        function drawAxis() {
            const baseY = H * 0.65;
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.06)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, baseY);
            ctx.lineTo(W, baseY);
            ctx.stroke();

            ctx.fillStyle = 'rgba(100, 200, 255, 0.1)';
            ctx.font = '9px monospace';
            ctx.fillText('position x', W - 65, baseY + 13);
        }

        function drawPotential() {
            const baseY = H * 0.65;
            const scaleX = W / N;
            const amplitudeScale = H * 0.45;

            // Draw filled potential region
            ctx.beginPath();
            ctx.moveTo(0, baseY);
            for (let i = 0; i < N; i++) {
                if (V[i] > 1e5) continue; // skip hard walls
                const x = i * scaleX;
                const vH = (V[i] / 1.2) * amplitudeScale * 0.5;
                ctx.lineTo(x, baseY - vH);
            }
            ctx.lineTo(W, baseY);
            ctx.closePath();

            const potGrad = ctx.createLinearGradient(0, baseY - amplitudeScale * 0.3, 0, baseY);
            potGrad.addColorStop(0, 'rgba(255, 210, 80, 0.5)');
            potGrad.addColorStop(0.5, 'rgba(255, 180, 40, 0.25)');
            potGrad.addColorStop(1, 'rgba(255, 160, 20, 0.08)');
            ctx.fillStyle = potGrad;
            ctx.fill();

            // Potential outline with glow
            ctx.shadowColor = 'rgba(255, 180, 40, 0.4)';
            ctx.shadowBlur = 15;
            ctx.strokeStyle = 'rgba(255, 200, 60, 0.6)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            let started = false;
            for (let i = 0; i < N; i++) {
                if (V[i] > 1e5) { started = false; continue; }
                const x = i * scaleX;
                const vH = (V[i] / 1.2) * amplitudeScale * 0.5;
                if (!started) { ctx.moveTo(x, baseY - vH); started = true; }
                else ctx.lineTo(x, baseY - vH);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Label
            ctx.fillStyle = 'rgba(255, 200, 60, 0.35)';
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('V(x)', barrierCenter * scaleX, baseY - (barrierHeight / 1.2) * amplitudeScale * 0.5 - 8);
            ctx.textAlign = 'left';

            // Eigenvalue lines for well mode
            if (barrierType === 'well' && eigenEnergies.length > 0) {
                const bLeft = (barrierCenter - barrierWidth / 2) * scaleX;
                const bRight = (barrierCenter + barrierWidth / 2) * scaleX;
                ctx.setLineDash([4, 4]);
                for (let n = 0; n < eigenEnergies.length; n++) {
                    const eH = (eigenEnergies[n] / 1.2) * amplitudeScale * 0.5;
                    const lineY = baseY - eH;
                    const hue = (n * 50 + 180) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.4)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(bLeft, lineY);
                    ctx.lineTo(bRight, lineY);
                    ctx.stroke();

                    ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.4)`;
                    ctx.font = '8px monospace';
                    ctx.textAlign = 'right';
                    ctx.fillText('n=' + (n + 1), bLeft - 4, lineY + 3);
                    ctx.textAlign = 'left';
                }
                ctx.setLineDash([]);
            }
        }

        function drawEnergyDiagram() {
            // Side panel energy level diagram
            const panelX = W - 130;
            const panelY = H * 0.35;
            const panelW = 110;
            const panelH = H * 0.28;

            ctx.fillStyle = 'rgba(10, 15, 30, 0.4)';
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.08)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(panelX, panelY, panelW, panelH, 6);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Energy Diagram', panelX + panelW / 2, panelY + 12);

            const innerX = panelX + 15;
            const innerW = panelW - 30;
            const innerTop = panelY + 22;
            const innerBot = panelY + panelH - 10;
            const innerH = innerBot - innerTop;

            const maxE = Math.max(barrierHeight, particleEnergy) * 1.3;
            if (maxE <= 0) return;

            // Barrier energy level
            const barrierY = innerBot - (barrierHeight / maxE) * innerH;
            ctx.strokeStyle = 'rgba(255, 200, 60, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(innerX, barrierY);
            ctx.lineTo(innerX + innerW, barrierY);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 200, 60, 0.4)';
            ctx.font = '7px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('V\u2080', innerX + innerW + 3, barrierY + 3);

            // Fill below barrier
            const vGrad = ctx.createLinearGradient(0, barrierY, 0, innerBot);
            vGrad.addColorStop(0, 'rgba(255, 200, 60, 0.08)');
            vGrad.addColorStop(1, 'rgba(255, 200, 60, 0.02)');
            ctx.fillStyle = vGrad;
            ctx.fillRect(innerX, barrierY, innerW, innerBot - barrierY);

            // Particle energy levels (one per packet)
            for (let p = 0; p < packets.length; p++) {
                const pE = packets[p].energy;
                const eY = innerBot - (pE / maxE) * innerH;
                const hue = packets.length === 1 ? 200 : (p * 60 + 120);
                ctx.strokeStyle = `hsla(${hue}, 80%, 65%, 0.6)`;
                ctx.setLineDash([3, 3]);
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(innerX, eY);
                ctx.lineTo(innerX + innerW, eY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = `hsla(${hue}, 80%, 65%, 0.5)`;
                ctx.fillText('E' + (packets.length > 1 ? (p + 1) : ''), innerX + innerW + 3, eY + 3);
            }

            // Ground level
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(innerX, innerBot);
            ctx.lineTo(innerX + innerW, innerBot);
            ctx.stroke();
            ctx.fillStyle = 'rgba(100, 200, 255, 0.2)';
            ctx.fillText('0', innerX + innerW + 3, innerBot + 3);

            ctx.textAlign = 'left';
        }

        function drawWavePacket(pkt, index) {
            const baseY = H * 0.65;
            const scaleX = W / N;
            const amplitudeScale = H * 0.45;

            const displayScale = pkt.maxProb > 0 ? amplitudeScale * 0.55 / Math.max(pkt.maxProb, 0.001) : amplitudeScale;
            const waveScale = amplitudeScale * 0.3 / Math.max(Math.sqrt(pkt.maxProb > 0 ? pkt.maxProb : 0.001), 0.03);

            const hueBase = packets.length === 1 ? 200 : (index * 60 + 120);

            // --- Probability density glow fill ---
            if (displayMode === 'all' || displayMode === 'prob') {
                // Glowing gradient fill under |psi|^2
                const probGrad = ctx.createLinearGradient(0, baseY - amplitudeScale * 0.4, 0, baseY);
                probGrad.addColorStop(0, `hsla(${hueBase}, 90%, 60%, 0.0)`);
                probGrad.addColorStop(0.3, `hsla(${hueBase}, 90%, 55%, 0.18)`);
                probGrad.addColorStop(0.7, `hsla(${hueBase}, 80%, 50%, 0.08)`);
                probGrad.addColorStop(1, `hsla(${hueBase}, 80%, 45%, 0.02)`);

                ctx.beginPath();
                ctx.moveTo(0, baseY);
                for (let i = 0; i < N; i++) {
                    ctx.lineTo(i * scaleX, baseY - pkt.probDensity[i] * displayScale);
                }
                ctx.lineTo(W, baseY);
                ctx.closePath();
                ctx.fillStyle = probGrad;
                ctx.fill();

                // Brighter inner glow line
                ctx.shadowColor = `hsla(${hueBase}, 90%, 65%, 0.6)`;
                ctx.shadowBlur = 14;
                ctx.strokeStyle = `hsla(${hueBase}, 85%, 65%, 0.7)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < N; i++) {
                    const x = i * scaleX;
                    const y = baseY - pkt.probDensity[i] * displayScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // --- Real part ---
            if (displayMode === 'all' || displayMode === 'real') {
                ctx.strokeStyle = `hsla(${(hueBase + 20) % 360}, 70%, 70%, 0.45)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i < N; i++) {
                    const x = i * scaleX;
                    const y = baseY - pkt.psiRe[i] * waveScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // --- Imaginary part ---
            if (displayMode === 'all' || displayMode === 'imag') {
                ctx.strokeStyle = `hsla(${(hueBase + 160) % 360}, 70%, 60%, 0.4)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i < N; i++) {
                    const x = i * scaleX;
                    const y = baseY - pkt.psiIm[i] * waveScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // --- Phase-colored rendering ---
            if (displayMode === 'all' || displayMode === 'phase') {
                if (pkt.maxProb > 0.0001) {
                    const step = Math.max(1, Math.floor(N / 400));
                    for (let i = 0; i < N; i += step) {
                        const prob = pkt.probDensity[i];
                        if (prob < pkt.maxProb * 0.015) continue;

                        const phase = Math.atan2(pkt.psiIm[i], pkt.psiRe[i]);
                        const hue = ((phase / Math.PI) * 180 + 360) % 360;
                        const alpha = Math.min(0.7, prob / pkt.maxProb);
                        const x = i * scaleX;
                        const y = baseY - prob * displayScale;
                        const r = displayMode === 'phase' ? 2.5 : 1.5;

                        ctx.fillStyle = `hsla(${hue}, 85%, 60%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();

                        // In phase-only mode, draw a line from baseline colored by phase
                        if (displayMode === 'phase' && prob > pkt.maxProb * 0.05) {
                            ctx.strokeStyle = `hsla(${hue}, 80%, 55%, ${alpha * 0.3})`;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(x, baseY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        }
                    }
                }
            }

            // --- Expectation value markers and uncertainty ---
            if (pkt.maxProb > 0.0001) {
                const ev = computeExpectationValues(pkt);

                // <x> marker
                const expXpx = ev.expX * scaleX;
                if (expXpx > 0 && expXpx < W) {
                    ctx.strokeStyle = `hsla(60, 90%, 70%, 0.5)`;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(expXpx, baseY + 5);
                    ctx.lineTo(expXpx, baseY + 18);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Triangle marker
                    ctx.fillStyle = `hsla(60, 90%, 70%, 0.5)`;
                    ctx.beginPath();
                    ctx.moveTo(expXpx, baseY + 5);
                    ctx.lineTo(expXpx - 4, baseY + 12);
                    ctx.lineTo(expXpx + 4, baseY + 12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.font = '7px monospace';
                    ctx.fillStyle = `hsla(60, 90%, 70%, 0.4)`;
                    ctx.textAlign = 'center';
                    ctx.fillText('<x>', expXpx, baseY + 26);
                    ctx.textAlign = 'left';

                    // Delta x shaded region
                    if (ev.deltaX > 0 && ev.deltaX * scaleX < W) {
                        const dxLeft = (ev.expX - ev.deltaX) * scaleX;
                        const dxRight = (ev.expX + ev.deltaX) * scaleX;
                        ctx.fillStyle = `hsla(60, 80%, 60%, 0.04)`;
                        ctx.fillRect(dxLeft, baseY - amplitudeScale * 0.5, dxRight - dxLeft, amplitudeScale * 0.5);
                        ctx.strokeStyle = `hsla(60, 80%, 60%, 0.15)`;
                        ctx.lineWidth = 0.5;
                        ctx.setLineDash([2, 4]);
                        ctx.beginPath();
                        ctx.moveTo(dxLeft, baseY - amplitudeScale * 0.5);
                        ctx.lineTo(dxLeft, baseY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(dxRight, baseY - amplitudeScale * 0.5);
                        ctx.lineTo(dxRight, baseY);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        ctx.fillStyle = 'rgba(255, 230, 120, 0.2)';
                        ctx.font = '7px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('\u0394x', (dxLeft + dxRight) / 2, baseY - amplitudeScale * 0.5 - 3);
                        ctx.textAlign = 'left';
                    }
                }

                // <p> indicator (small arrow on momentum axis)
                const pIndicatorX = W - 125;
                const pIndicatorY = H * 0.35 + H * 0.28 + 20;
                if (pIndicatorY < H - 80) {
                    const pNorm = ev.expP / (Math.sqrt(2 * mass * particleEnergy) / hbar);
                    const arrowLen = Math.min(40, Math.abs(pNorm) * 40);
                    const dir = pNorm >= 0 ? 1 : -1;

                    ctx.strokeStyle = 'rgba(100, 255, 180, 0.4)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(pIndicatorX, pIndicatorY);
                    ctx.lineTo(pIndicatorX + dir * arrowLen, pIndicatorY);
                    ctx.stroke();

                    if (arrowLen > 5) {
                        ctx.beginPath();
                        ctx.moveTo(pIndicatorX + dir * arrowLen, pIndicatorY);
                        ctx.lineTo(pIndicatorX + dir * (arrowLen - 5), pIndicatorY - 3);
                        ctx.lineTo(pIndicatorX + dir * (arrowLen - 5), pIndicatorY + 3);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(100, 255, 180, 0.4)';
                        ctx.fill();
                    }

                    ctx.fillStyle = 'rgba(100, 255, 180, 0.3)';
                    ctx.font = '7px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('<p>', pIndicatorX, pIndicatorY + 12);

                    // Delta p text
                    ctx.fillStyle = 'rgba(100, 255, 180, 0.2)';
                    ctx.fillText('\u0394p=' + ev.deltaP.toFixed(3), pIndicatorX, pIndicatorY + 22);
                    ctx.textAlign = 'left';
                }
            }
        }

        function drawParticles() {
            const time = performance.now() * 0.001;
            ctx.fillStyle = 'rgba(100, 200, 255, 0.025)';
            for (let i = 0; i < 35; i++) {
                const seed = i * 137.508;
                const x = ((Math.sin(seed + time * 0.1) + 1) / 2) * W;
                const y = ((Math.cos(seed * 1.3 + time * 0.07) + 1) / 2) * H;
                const r = 1 + Math.sin(seed * 0.7 + time * 0.2) * 0.5;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawInfo() {
            let html = '';

            // Transmission coefficient
            const T_analytical = analyticalTransmission();
            if (T_analytical !== null) {
                html += '<span style="color:rgba(0,200,255,0.6)">T(analytical) = ' + T_analytical.toFixed(4) + '</span><br>';
            }

            for (let p = 0; p < packets.length; p++) {
                const pkt = packets[p];
                const label = packets.length > 1 ? ' [' + (p + 1) + ']' : '';
                const T = (pkt.transmissionProb * 100).toFixed(1);
                const R = (pkt.reflectionProb * 100).toFixed(1);
                html += 'T' + label + ' = ' + T + '% | R' + label + ' = ' + R + '%<br>';
            }

            html += 'E = ' + particleEnergy.toFixed(3) + ' | V\u2080 = ' + barrierHeight.toFixed(3) + '<br>';
            html += 'step ' + stepCount + ' | ' + barrierType;

            if (barrierType === 'well' && eigenEnergies.length > 0) {
                html += '<br><span style="color:rgba(180,200,255,0.4)">bound states: ' + eigenEnergies.length + '</span>';
            }

            infoEl.innerHTML = html;
        }

        function drawCounters() {
            const ratio = totalRuns > 0 ? (totalTransmitted / totalRuns * 100).toFixed(1) + '%' : '--';
            countersEl.innerHTML =
                '<div class="t-count">T: ' + totalTransmitted + ' transmitted</div>' +
                '<div class="r-count">R: ' + totalReflected + ' reflected</div>' +
                '<div class="runs">' + totalRuns + ' runs | T-ratio ' + ratio + '</div>';
        }

        function updateLegend() {
            let items = '';
            if (displayMode === 'all' || displayMode === 'prob') {
                items += '<div class="legend-item"><div class="legend-swatch" style="background:rgba(0,180,255,0.8)"></div><span class="legend-label">|&psi;|&sup2;</span></div>';
            }
            if (displayMode === 'all' || displayMode === 'real') {
                items += '<div class="legend-item"><div class="legend-swatch" style="background:rgba(100,220,255,0.6)"></div><span class="legend-label">Re(&psi;)</span></div>';
            }
            if (displayMode === 'all' || displayMode === 'imag') {
                items += '<div class="legend-item"><div class="legend-swatch" style="background:rgba(255,100,180,0.6)"></div><span class="legend-label">Im(&psi;)</span></div>';
            }
            if (displayMode === 'all' || displayMode === 'phase') {
                items += '<div class="legend-item"><div class="legend-swatch" style="background:linear-gradient(90deg,hsl(0,80%,60%),hsl(60,80%,60%),hsl(120,80%,60%),hsl(180,80%,60%),hsl(240,80%,60%),hsl(300,80%,60%),hsl(360,80%,60%))"></div><span class="legend-label">Phase</span></div>';
            }
            items += '<div class="legend-item"><div class="legend-swatch" style="background:rgba(255,200,60,0.6)"></div><span class="legend-label">V(x)</span></div>';
            items += '<div class="legend-item"><div class="legend-swatch" style="background:rgba(255,230,120,0.4)"></div><span class="legend-label">&langle;x&rangle; / &Delta;x</span></div>';
            legendEl.innerHTML = items;
        }

        function updateGrain() {
            grainFrame++;
            if (grainFrame % 3 !== 0) return; // update grain every 3 frames
            const imgData = grainCtx.createImageData(W >> 2, H >> 2);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const v = Math.random() * 255;
                data[i] = v;
                data[i + 1] = v;
                data[i + 2] = v;
                data[i + 3] = 255;
            }
            grainCtx.putImageData(imgData, 0, 0);
            // Scale up
            grainCtx.save();
            grainCtx.imageSmoothingEnabled = false;
            grainCtx.globalCompositeOperation = 'copy';
            grainCtx.drawImage(grainCanvas, 0, 0, W >> 2, H >> 2, 0, 0, W, H);
            grainCtx.restore();
        }

        function shouldResetPacket(pkt) {
            if (pkt.age > 1200) return true;
            let edgeProb = 0;
            for (let i = 0; i < 25; i++) edgeProb += pkt.probDensity[i];
            for (let i = N - 25; i < N; i++) edgeProb += pkt.probDensity[i];
            return pkt.age > 400 && edgeProb > 0.4;
        }

        function recordOutcome(pkt) {
            totalRuns++;
            if (pkt.transmissionProb > pkt.reflectionProb) {
                totalTransmitted++;
            } else {
                totalReflected++;
            }
        }

        let titleShown = false;
        let titleTimer = 0;

        function readSliders() {
            barrierHeight = parseFloat(barrierSlider.value) / 100 * 1.2;
            particleEnergy = parseFloat(energySlider.value) / 100 * 1.0;
            numPackets = parseInt(packetSlider.value);
            barrierType = barrierTypeSelect.value;
            displayMode = displayModeSelect.value;
            barrierVal.textContent = barrierSlider.value;
            energyVal.textContent = energySlider.value;
            packetVal.textContent = packetSlider.value;
        }

        function init() {
            resize();
            readSliders();
            setupPotential();
            initPackets();
            updateLegend();
            totalTransmitted = 0;
            totalReflected = 0;
            totalRuns = 0;

            if (!titleShown) {
                titleOverlay.classList.add('visible');
                titleShown = true;
                titleTimer = setTimeout(function() {
                    titleOverlay.classList.remove('visible');
                }, 4000);
            }
        }

        function onParamChange() {
            readSliders();
            setupPotential();
            initPackets();
            updateLegend();
            totalTransmitted = 0;
            totalReflected = 0;
            totalRuns = 0;
        }

        barrierSlider.addEventListener('input', onParamChange);
        energySlider.addEventListener('input', onParamChange);
        packetSlider.addEventListener('input', onParamChange);
        barrierTypeSelect.addEventListener('change', onParamChange);
        displayModeSelect.addEventListener('change', function() {
            displayMode = displayModeSelect.value;
            updateLegend();
        });

        launchBtn.addEventListener('click', function() {
            // Launch a new packet with random energy variation
            if (packets.length < MAX_PACKETS + 3) {
                const eFactor = 0.5 + Math.random() * 1.0;
                packets.push(createPacket(eFactor));
            }
        });

        function animate() {
            const stepsPerFrame = 4;
            for (let s = 0; s < stepsPerFrame; s++) {
                for (let p = 0; p < packets.length; p++) {
                    evolvePacket(packets[p]);
                }
                stepCount++;
            }

            for (let p = 0; p < packets.length; p++) {
                computeProbabilityPacket(packets[p]);
            }

            drawBackground();
            drawParticles();
            drawAxis();
            drawPotential();

            for (let p = 0; p < packets.length; p++) {
                drawWavePacket(packets[p], p);
            }

            drawEnergyDiagram();
            drawInfo();
            drawCounters();
            updateGrain();

            // Check for resets
            for (let p = packets.length - 1; p >= 0; p--) {
                if (shouldResetPacket(packets[p])) {
                    recordOutcome(packets[p]);
                    if (p < numPackets) {
                        // Primary packets: reinitialize
                        const eFactor = numPackets === 1 ? 1.0 : 0.6 + (p / Math.max(1, numPackets - 1)) * 0.8;
                        packets[p] = createPacket(eFactor);
                    } else {
                        // Extra launched packets: remove
                        packets.splice(p, 1);
                    }
                }
            }

            animId = requestAnimationFrame(animate);
        }

        window.reset = function() {
            if (animId) cancelAnimationFrame(animId);
            clearTimeout(titleTimer);
            init();
            animate();
        };

        window.addEventListener('resize', function() {
            resize();
        });

        init();
        animId = requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
