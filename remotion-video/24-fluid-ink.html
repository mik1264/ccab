<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fluid Dynamics - Ink in Water</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #050510;
    font-family: 'Courier New', monospace;
}
canvas#display {
    display: block;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
}
canvas#fluid, canvas#bloom {
    display: none;
}
.vignette {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 10;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(2,2,12,0.7) 100%);
}
.film-grain {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 11;
    opacity: 0.06;
    mix-blend-mode: overlay;
}
.back-link {
    position: fixed;
    top: 1rem;
    left: 1rem;
    color: rgba(100,200,255,0.6);
    text-decoration: none;
    font-family: monospace;
    font-size: 0.85rem;
    z-index: 20;
    transition: color 0.3s;
}
.back-link:hover { color: rgba(100,200,255,1); }
.title-overlay {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    color: rgba(100,200,255,0.25);
    font-family: monospace;
    font-size: 0.75rem;
    z-index: 20;
    pointer-events: none;
    text-align: right;
    line-height: 1.5;
}
.hint {
    position: fixed;
    bottom: 1.5rem;
    left: 1.5rem;
    color: rgba(100,200,255,0.2);
    font-family: monospace;
    font-size: 0.7rem;
    z-index: 20;
    pointer-events: none;
    transition: opacity 2s;
}

/* --- Controls Panel --- */
.controls-panel {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 25;
    background: rgba(5,5,20,0.85);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(100,200,255,0.15);
    border-radius: 8px;
    padding: 12px 14px;
    color: rgba(200,220,255,0.8);
    font-size: 0.7rem;
    font-family: monospace;
    width: 200px;
    transition: opacity 0.3s, transform 0.3s;
    max-height: calc(100vh - 2rem);
    overflow-y: auto;
}
.controls-panel.hidden {
    opacity: 0;
    pointer-events: none;
    transform: translateX(220px);
}
.controls-panel h3 {
    color: rgba(100,200,255,0.7);
    font-size: 0.75rem;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    border-bottom: 1px solid rgba(100,200,255,0.1);
    padding-bottom: 4px;
}
.control-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}
.control-row label {
    flex-shrink: 0;
    margin-right: 6px;
}
.control-row input[type="range"] {
    width: 90px;
    height: 3px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(100,200,255,0.2);
    border-radius: 2px;
    outline: none;
}
.control-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(100,200,255,0.7);
    cursor: pointer;
}
.color-palette {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    margin-bottom: 8px;
}
.color-swatch {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: border-color 0.2s, transform 0.2s;
}
.color-swatch:hover {
    transform: scale(1.15);
}
.color-swatch.active {
    border-color: rgba(255,255,255,0.9);
    box-shadow: 0 0 8px rgba(255,255,255,0.3);
}
.toggle-btn {
    background: rgba(100,200,255,0.1);
    border: 1px solid rgba(100,200,255,0.2);
    color: rgba(200,220,255,0.7);
    font-family: monospace;
    font-size: 0.65rem;
    padding: 3px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}
.toggle-btn:hover {
    background: rgba(100,200,255,0.2);
}
.toggle-btn.active {
    background: rgba(100,200,255,0.3);
    border-color: rgba(100,200,255,0.5);
    color: #fff;
}
.btn-row {
    display: flex;
    gap: 4px;
    margin-bottom: 6px;
    flex-wrap: wrap;
}
.action-btn {
    background: rgba(100,200,255,0.12);
    border: 1px solid rgba(100,200,255,0.2);
    color: rgba(200,220,255,0.8);
    font-family: monospace;
    font-size: 0.65rem;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    flex: 1;
    text-align: center;
}
.action-btn:hover {
    background: rgba(100,200,255,0.25);
}
.section-label {
    color: rgba(100,200,255,0.4);
    font-size: 0.6rem;
    margin: 8px 0 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.toggle-controls {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 26;
    background: rgba(5,5,20,0.7);
    border: 1px solid rgba(100,200,255,0.2);
    color: rgba(100,200,255,0.6);
    font-family: monospace;
    font-size: 0.75rem;
    padding: 4px 10px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    display: none;
}
.toggle-controls:hover {
    background: rgba(100,200,255,0.15);
    color: rgba(100,200,255,0.9);
}

/* Fullscreen mode hides all UI */
:fullscreen .controls-panel,
:fullscreen .back-link,
:fullscreen .title-overlay,
:fullscreen .hint,
:fullscreen .toggle-controls {
    display: none !important;
}
:-webkit-full-screen .controls-panel,
:-webkit-full-screen .back-link,
:-webkit-full-screen .title-overlay,
:-webkit-full-screen .hint,
:-webkit-full-screen .toggle-controls {
    display: none !important;
}
</style>
</head>
<body>
<canvas id="fluid"></canvas>
<canvas id="bloom"></canvas>
<canvas id="display"></canvas>
<canvas id="grain" class="film-grain"></canvas>
<div class="vignette"></div>
<a href="index.html" class="back-link">&larr; Back to Gallery</a>
<div class="title-overlay">Fluid Dynamics<br>Ink in Water</div>
<div class="hint" id="hint">Click to drop ink &middot; Right-click to place obstacle &middot; Drag to stir &middot; Arrow keys tilt gravity</div>

<button class="toggle-controls" id="toggleBtn">&#9776;</button>

<div class="controls-panel" id="controlsPanel">
    <h3>Ink Studio</h3>

    <div class="section-label">Ink Color</div>
    <div class="color-palette" id="colorPalette"></div>

    <div class="section-label">Physics</div>
    <div class="control-row">
        <label>Viscosity</label>
        <input type="range" id="viscSlider" min="0" max="100" value="0">
    </div>
    <div class="control-row">
        <label>Diffusion</label>
        <input type="range" id="diffSlider" min="0" max="100" value="12">
    </div>

    <div class="section-label">Visualization</div>
    <div class="btn-row">
        <button class="toggle-btn" id="btnPressure">Pressure</button>
        <button class="toggle-btn" id="btnVelocity">Arrows</button>
    </div>
    <div class="btn-row">
        <button class="toggle-btn" id="btnBloom" onclick="this.classList.toggle('active'); bloomEnabled=this.classList.contains('active');">Bloom</button>
        <button class="toggle-btn" id="btnGrain" onclick="this.classList.toggle('active'); grainEnabled=this.classList.contains('active');">Grain</button>
    </div>

    <div class="section-label">Turbulence</div>
    <div class="btn-row">
        <button class="toggle-btn" id="btnTurbulence">Auto Inject</button>
        <button class="toggle-btn" id="btnKH">K-H Instability</button>
    </div>

    <div class="section-label">Actions</div>
    <div class="btn-row">
        <button class="action-btn" id="btnScreenshot">Screenshot</button>
        <button class="action-btn" id="btnClear">Clear</button>
    </div>
</div>

<script>
(function() {
    'use strict';

    // --- Display canvas ---
    var displayCanvas = document.getElementById('display');
    var displayCtx = displayCanvas.getContext('2d');

    // --- Fluid canvas (grid resolution) ---
    var fluidCanvas = document.getElementById('fluid');
    var fluidCtx = fluidCanvas.getContext('2d');

    // --- Bloom canvas ---
    var bloomCanvas = document.getElementById('bloom');
    var bloomCtx = bloomCanvas.getContext('2d');

    // --- Film grain canvas ---
    var grainCanvas = document.getElementById('grain');
    var grainCtx = grainCanvas.getContext('2d');

    // Grid size - higher resolution
    var N = 200;
    var gridW = N + 2;
    var gridH = N + 2;
    var size = gridW * gridH;

    fluidCanvas.width = gridW;
    fluidCanvas.height = gridH;
    bloomCanvas.width = gridW;
    bloomCanvas.height = gridH;

    // Fluid state arrays
    var u = new Float32Array(size);
    var v = new Float32Array(size);
    var u0 = new Float32Array(size);
    var v0 = new Float32Array(size);

    // RGB density channels
    var dr = new Float32Array(size);
    var dg = new Float32Array(size);
    var db = new Float32Array(size);
    var dr0 = new Float32Array(size);
    var dg0 = new Float32Array(size);
    var db0 = new Float32Array(size);

    // Vorticity array
    var vort = new Float32Array(size);

    // Obstacles (circular) - stored as array of {cx, cy, r}
    var obstacles = [];
    var obstacleGrid = new Uint8Array(size); // 1 = blocked

    var dt = 0.08;
    var diffusion = 0.000012;
    var viscosity = 0.0;
    var solverIter = 4;
    var vorticityEpsilon = 3.0;

    var paused = false;
    var time = 0;

    // Gravity
    var gravX = 0, gravY = 0;

    // Toggles
    var showPressure = false;
    var showVelocity = false;
    var bloomEnabled = true;
    var grainEnabled = true;
    var autoInjectEnabled = true;
    var khEnabled = false;

    // Mouse
    var mx = 0, my = 0, pmx = 0, pmy = 0;
    var mouseDown = false;
    var mouseActive = false;
    var rightMouseDown = false;

    // Ink color palette
    var inkColors = [
        { name: 'Cyan',    r: 0.0,  g: 0.85, b: 1.0,  css: '#00d9ff' },
        { name: 'Magenta', r: 1.0,  g: 0.1,  b: 0.6,  css: '#ff1a99' },
        { name: 'Gold',    r: 1.0,  g: 0.78, b: 0.05,  css: '#ffc70d' },
        { name: 'Emerald', r: 0.05, g: 0.9,  b: 0.4,   css: '#0de666' },
        { name: 'Violet',  r: 0.6,  g: 0.15, b: 1.0,   css: '#9926ff' },
        { name: 'White',   r: 0.95, g: 0.95, b: 1.0,   css: '#f2f2ff' },
        { name: 'Crimson', r: 1.0,  g: 0.15, b: 0.15,  css: '#ff2626' },
        { name: 'Coral',   r: 1.0,  g: 0.5,  b: 0.3,   css: '#ff804d' },
    ];
    var activeColorIdx = 0;

    // Build color palette UI
    var paletteEl = document.getElementById('colorPalette');
    inkColors.forEach(function(c, idx) {
        var swatch = document.createElement('div');
        swatch.className = 'color-swatch' + (idx === 0 ? ' active' : '');
        swatch.style.background = c.css;
        swatch.title = c.name;
        swatch.addEventListener('click', function() {
            document.querySelectorAll('.color-swatch').forEach(function(s) { s.classList.remove('active'); });
            swatch.classList.add('active');
            activeColorIdx = idx;
        });
        paletteEl.appendChild(swatch);
    });

    // Slider bindings
    var viscSlider = document.getElementById('viscSlider');
    var diffSlider = document.getElementById('diffSlider');
    viscSlider.addEventListener('input', function() {
        viscosity = Math.pow(this.value / 100, 3) * 0.001;
    });
    diffSlider.addEventListener('input', function() {
        diffusion = Math.pow(this.value / 100, 2) * 0.0005;
    });

    // Toggle buttons
    var btnPressure = document.getElementById('btnPressure');
    var btnVelocity = document.getElementById('btnVelocity');
    var btnTurbulence = document.getElementById('btnTurbulence');
    var btnKH = document.getElementById('btnKH');
    var btnBloom = document.getElementById('btnBloom');
    var btnGrain = document.getElementById('btnGrain');

    btnPressure.addEventListener('click', function() {
        showPressure = !showPressure;
        this.classList.toggle('active', showPressure);
    });
    btnVelocity.addEventListener('click', function() {
        showVelocity = !showVelocity;
        this.classList.toggle('active', showVelocity);
    });
    btnTurbulence.addEventListener('click', function() {
        autoInjectEnabled = !autoInjectEnabled;
        this.classList.toggle('active', autoInjectEnabled);
    });
    btnTurbulence.classList.add('active');
    btnKH.addEventListener('click', function() {
        khEnabled = !khEnabled;
        this.classList.toggle('active', khEnabled);
    });
    btnBloom.classList.add('active');
    btnGrain.classList.add('active');

    // Screenshot
    document.getElementById('btnScreenshot').addEventListener('click', function() {
        var link = document.createElement('a');
        link.download = 'fluid-ink-' + Date.now() + '.png';
        link.href = displayCanvas.toDataURL('image/png');
        link.click();
    });

    // Clear
    document.getElementById('btnClear').addEventListener('click', function() {
        resetFluid();
    });

    // Toggle controls panel
    var panelEl = document.getElementById('controlsPanel');
    var toggleBtn = document.getElementById('toggleBtn');
    toggleBtn.addEventListener('click', function() {
        panelEl.classList.toggle('hidden');
        toggleBtn.style.display = panelEl.classList.contains('hidden') ? 'block' : 'none';
    });
    // Initially show panel, hide toggle button
    toggleBtn.style.display = 'none';

    // Close panel button behavior (click outside)
    document.addEventListener('click', function(e) {
        if (panelEl.contains(e.target) || toggleBtn.contains(e.target)) return;
        if (e.target === displayCanvas && !panelEl.classList.contains('hidden')) {
            // Don't auto-close, user is interacting with fluid
        }
    });

    // Fade hint after 6 seconds
    setTimeout(function() {
        var h = document.getElementById('hint');
        if (h) h.style.opacity = '0';
    }, 6000);

    // --- Helpers ---
    function IX(i, j) { return i + gridW * j; }

    function rebuildObstacleGrid() {
        obstacleGrid.fill(0);
        for (var o = 0; o < obstacles.length; o++) {
            var obs = obstacles[o];
            var r2 = obs.r * obs.r;
            for (var dj = -obs.r; dj <= obs.r; dj++) {
                for (var di = -obs.r; di <= obs.r; di++) {
                    if (di * di + dj * dj > r2) continue;
                    var ni = obs.cx + di;
                    var nj = obs.cy + dj;
                    if (ni >= 0 && ni < gridW && nj >= 0 && nj < gridH) {
                        obstacleGrid[IX(ni, nj)] = 1;
                    }
                }
            }
        }
    }

    function setBnd(b, x) {
        var i, idx;
        for (i = 1; i <= N; i++) {
            x[IX(0,       i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
            x[IX(N + 1,   i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
            x[IX(i,       0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
            x[IX(i,   N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
        }
        x[IX(0,     0    )] = 0.5 * (x[IX(1, 0    )] + x[IX(0,     1)]);
        x[IX(0,     N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0,     N)]);
        x[IX(N + 1, 0    )] = 0.5 * (x[IX(N, 0    )] + x[IX(N + 1, 1)]);
        x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);

        // Enforce obstacle boundaries
        for (i = 0; i < size; i++) {
            if (obstacleGrid[i]) {
                x[i] = 0;
            }
        }
    }

    function linSolve(b, x, x0, a, c) {
        var inv = 1.0 / c;
        var k, j, i, idx;
        for (k = 0; k < solverIter; k++) {
            for (j = 1; j <= N; j++) {
                for (i = 1; i <= N; i++) {
                    idx = IX(i, j);
                    if (obstacleGrid[idx]) { x[idx] = 0; continue; }
                    x[idx] = (x0[idx] + a * (
                        x[IX(i-1, j)] + x[IX(i+1, j)] +
                        x[IX(i, j-1)] + x[IX(i, j+1)]
                    )) * inv;
                }
            }
            setBnd(b, x);
        }
    }

    function diffuse(b, x, x0, diff) {
        var a = dt * diff * N * N;
        linSolve(b, x, x0, a, 1 + 4 * a);
    }

    function advect(b, d, d0, ux, vy) {
        var dt0 = dt * N;
        var i, j, x, y, i0, i1, j0, j1, s0, s1, t0, t1;
        for (j = 1; j <= N; j++) {
            for (i = 1; i <= N; i++) {
                if (obstacleGrid[IX(i, j)]) { d[IX(i, j)] = 0; continue; }
                x = i - dt0 * ux[IX(i, j)];
                y = j - dt0 * vy[IX(i, j)];
                if (x < 0.5) x = 0.5;
                if (x > N + 0.5) x = N + 0.5;
                i0 = x | 0; i1 = i0 + 1;
                s1 = x - i0; s0 = 1 - s1;
                if (y < 0.5) y = 0.5;
                if (y > N + 0.5) y = N + 0.5;
                j0 = y | 0; j1 = j0 + 1;
                t1 = y - j0; t0 = 1 - t1;
                d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                              s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
            }
        }
        setBnd(b, d);
    }

    // Pressure field (stored for visualization)
    var pressureField = new Float32Array(size);
    var divField = new Float32Array(size);

    function project(ux, vy, p, div) {
        var h = 1.0 / N;
        var i, j, idx;
        for (j = 1; j <= N; j++) {
            for (i = 1; i <= N; i++) {
                idx = IX(i, j);
                if (obstacleGrid[idx]) { div[idx] = 0; p[idx] = 0; continue; }
                div[idx] = -0.5 * h * (
                    ux[IX(i+1, j)] - ux[IX(i-1, j)] +
                    vy[IX(i, j+1)] - vy[IX(i, j-1)]
                );
                p[idx] = 0;
            }
        }
        setBnd(0, div);
        setBnd(0, p);
        linSolve(0, p, div, 1, 4);
        for (j = 1; j <= N; j++) {
            for (i = 1; i <= N; i++) {
                idx = IX(i, j);
                if (obstacleGrid[idx]) continue;
                ux[idx] -= 0.5 * N * (p[IX(i+1, j)] - p[IX(i-1, j)]);
                vy[idx] -= 0.5 * N * (p[IX(i, j+1)] - p[IX(i, j-1)]);
            }
        }
        setBnd(1, ux);
        setBnd(2, vy);

        // Store pressure for visualization
        for (i = 0; i < size; i++) pressureField[i] = p[i];
    }

    // --- Vorticity confinement ---
    function vorticityConfinement() {
        var i, j, idx;
        // Compute vorticity (curl of velocity)
        for (j = 1; j <= N; j++) {
            for (i = 1; i <= N; i++) {
                idx = IX(i, j);
                vort[idx] = 0.5 * (
                    (v[IX(i+1, j)] - v[IX(i-1, j)]) -
                    (u[IX(i, j+1)] - u[IX(i, j-1)])
                );
            }
        }

        // Apply confinement force
        var eps = vorticityEpsilon;
        for (j = 2; j < N; j++) {
            for (i = 2; i < N; i++) {
                idx = IX(i, j);
                if (obstacleGrid[idx]) continue;

                var dw_dx = Math.abs(vort[IX(i+1, j)]) - Math.abs(vort[IX(i-1, j)]);
                var dw_dy = Math.abs(vort[IX(i, j+1)]) - Math.abs(vort[IX(i, j-1)]);
                var len = Math.sqrt(dw_dx * dw_dx + dw_dy * dw_dy) + 1e-5;

                dw_dx /= len;
                dw_dy /= len;

                u[idx] += dt * eps * (dw_dy * vort[idx]);
                v[idx] -= dt * eps * (dw_dx * vort[idx]);
            }
        }
    }

    // --- Velocity step ---
    function velStep() {
        var i, tmp;

        // Add gravity
        if (gravX !== 0 || gravY !== 0) {
            for (i = 0; i < size; i++) {
                if (obstacleGrid[i]) continue;
                var totalD = dr[i] + dg[i] + db[i];
                u0[i] += gravX * totalD * 0.5;
                v0[i] += gravY * totalD * 0.5;
            }
        }

        for (i = 0; i < size; i++) {
            u[i] += dt * u0[i];
            v[i] += dt * v0[i];
        }
        tmp = u0; u0 = u; u = tmp;
        diffuse(1, u, u0, viscosity);
        tmp = v0; v0 = v; v = tmp;
        diffuse(2, v, v0, viscosity);
        project(u, v, u0, v0);
        tmp = u0; u0 = u; u = tmp;
        tmp = v0; v0 = v; v = tmp;
        advect(1, u, u0, u0, v0);
        advect(2, v, v0, u0, v0);
        project(u, v, u0, v0);

        // Vorticity confinement
        vorticityConfinement();

        u0.fill(0);
        v0.fill(0);
    }

    // --- Density step for one channel ---
    function densStep(d, d0) {
        var i, tmp;
        for (i = 0; i < size; i++) {
            d[i] += dt * d0[i];
        }
        tmp = d0; d0 = d; d = tmp;
        diffuse(0, d, d0, diffusion);
        tmp = d0; d0 = d; d = tmp;
        advect(0, d, d0, u, v);
        // Subtle decay
        for (i = 0; i < size; i++) {
            d[i] *= 0.9985;
            if (d[i] < 0.001) d[i] = 0;
        }
        return { d: d, d0: d0 };
    }

    // --- Inject ink and velocity ---
    function addInk(gi, gj, r, g, b, radius, amount) {
        var di, dj, ni, nj, dist, f, idx;
        for (dj = -radius; dj <= radius; dj++) {
            for (di = -radius; di <= radius; di++) {
                dist = Math.sqrt(di*di + dj*dj);
                if (dist > radius) continue;
                ni = gi + di; nj = gj + dj;
                if (ni < 1 || ni > N || nj < 1 || nj > N) continue;
                idx = IX(ni, nj);
                if (obstacleGrid[idx]) continue;
                f = amount * (1 - dist / radius);
                f *= f;
                dr0[idx] += r * f;
                dg0[idx] += g * f;
                db0[idx] += b * f;
            }
        }
    }

    function addVel(gi, gj, fx, fy, radius) {
        var di, dj, ni, nj, dist, f, idx;
        for (dj = -radius; dj <= radius; dj++) {
            for (di = -radius; di <= radius; di++) {
                dist = Math.sqrt(di*di + dj*dj);
                if (dist > radius) continue;
                ni = gi + di; nj = gj + dj;
                if (ni < 1 || ni > N || nj < 1 || nj > N) continue;
                idx = IX(ni, nj);
                if (obstacleGrid[idx]) continue;
                f = 1 - dist / radius;
                u0[idx] += fx * f;
                v0[idx] += fy * f;
            }
        }
    }

    // --- Auto-inject rotating ink sources ---
    function autoInject(t) {
        if (!autoInjectEnabled) return;

        var cx = gridW * 0.5;
        var cy = gridH * 0.5;
        var orbit = N * 0.28;

        // Five ink sources orbiting
        var sources = [
            { r: 0.0,  g: 0.85, b: 1.0,  ph: 0 },                        // Cyan
            { r: 1.0,  g: 0.1,  b: 0.6,  ph: Math.PI * 2 / 5 },          // Magenta
            { r: 1.0,  g: 0.78, b: 0.05, ph: Math.PI * 4 / 5 },          // Gold
            { r: 0.05, g: 0.9,  b: 0.4,  ph: Math.PI * 6 / 5 },          // Emerald
            { r: 0.6,  g: 0.15, b: 1.0,  ph: Math.PI * 8 / 5 },          // Violet
        ];

        for (var s = 0; s < sources.length; s++) {
            var src = sources[s];
            var angle = t * 0.2 + src.ph;
            var wobble = orbit + Math.sin(t * 0.5 + s * 1.7) * N * 0.06;
            var gi = Math.round(cx + Math.cos(angle) * wobble);
            var gj = Math.round(cy + Math.sin(angle) * wobble);

            addInk(gi, gj, src.r, src.g, src.b, 3, 50);

            var va = angle + Math.PI * 0.5;
            var spd = 2.0 + Math.sin(t * 0.3 + s) * 0.8;
            addVel(gi, gj,
                Math.cos(va) * spd + Math.sin(t * 0.7 + s * 1.3) * 1.0,
                Math.sin(va) * spd + Math.cos(t * 0.5 + s * 2.1) * 1.0,
                4
            );
        }

        // Inner orbit secondary sources
        var innerOrbit = N * 0.12;
        for (var s2 = 0; s2 < 3; s2++) {
            var src2 = sources[s2];
            var a2 = -t * 0.35 + src2.ph + Math.PI * 0.5;
            var gi2 = Math.round(cx + Math.cos(a2) * innerOrbit);
            var gj2 = Math.round(cy + Math.sin(a2) * innerOrbit);
            addInk(gi2, gj2, src2.r * 0.4, src2.g * 0.4, src2.b * 0.4, 2, 20);
            addVel(gi2, gj2,
                Math.cos(a2 - Math.PI * 0.5) * 1.2,
                Math.sin(a2 - Math.PI * 0.5) * 1.2,
                3
            );
        }

        // Central vortex
        var vcx = Math.round(cx + Math.sin(t * 0.15) * N * 0.04);
        var vcy = Math.round(cy + Math.cos(t * 0.12) * N * 0.04);
        var vs = 1.5 * Math.sin(t * 0.35);
        addVel(vcx, vcy, Math.cos(t * 0.9) * vs, Math.sin(t * 0.7) * vs, 6);
    }

    // --- Kelvin-Helmholtz instability injector ---
    function injectKH(t) {
        if (!khEnabled) return;
        var cy = Math.round(gridH * 0.5);
        var amp = 3;
        for (var i = 1; i <= N; i++) {
            var perturbation = amp * Math.sin(t * 0.4 + i * 0.15) * Math.cos(t * 0.3 + i * 0.08);
            var idx = IX(i, cy);
            u0[idx] += 2.5;
            u0[IX(i, cy + 1)] += 2.0;
            u0[IX(i, cy - 1)] -= 2.0;
            u0[IX(i, cy - 2)] -= 2.5;
            v0[idx] += perturbation * 0.3;

            // Color the shear layer
            if (i % 4 === 0) {
                addInk(i, cy + 1, 1.0, 0.4, 0.1, 1, 15);
                addInk(i, cy - 1, 0.1, 0.4, 1.0, 1, 15);
            }
        }
    }

    // --- Mouse handling ---
    function handleMouse() {
        if (!mouseActive) return;
        var scaleX = gridW / displayCanvas.width;
        var scaleY = gridH / displayCanvas.height;
        var gi = Math.round(mx * scaleX);
        var gj = Math.round(my * scaleY);

        if (gi < 1 || gi > N || gj < 1 || gj > N) return;

        var dx = (mx - pmx) * scaleX;
        var dy = (my - pmy) * scaleY;
        var speed = Math.sqrt(dx * dx + dy * dy);

        if (speed > 0.2) {
            addVel(gi, gj, dx * 5, dy * 5, 5);
        }

        if (mouseDown) {
            var c = inkColors[activeColorIdx];
            addInk(gi, gj, c.r, c.g, c.b, 4, 150);
            addVel(gi, gj,
                Math.sin(time * 3) * 1.5,
                Math.cos(time * 2.7) * 1.5,
                3
            );
        }
    }

    // --- Rendering ---
    var imgData;
    var pix;

    function initFluidImage() {
        imgData = fluidCtx.createImageData(gridW, gridH);
        pix = imgData.data;
    }

    function render() {
        var i, j, idx, pidx, rv, gv, bv, mr, mg, mb;

        if (showPressure) {
            // Pressure visualization mode
            for (j = 0; j < gridH; j++) {
                for (i = 0; i < gridW; i++) {
                    idx = IX(i, j);
                    pidx = (j * gridW + i) * 4;

                    if (obstacleGrid[idx]) {
                        pix[pidx] = 60; pix[pidx+1] = 60; pix[pidx+2] = 80; pix[pidx+3] = 255;
                        continue;
                    }

                    var p = pressureField[idx] * 50;
                    if (p > 0) {
                        pix[pidx]     = Math.min(255, 5 + p * 400);
                        pix[pidx + 1] = Math.min(255, 5 + p * 100);
                        pix[pidx + 2] = 20;
                    } else {
                        pix[pidx]     = 20;
                        pix[pidx + 1] = Math.min(255, 5 - p * 100);
                        pix[pidx + 2] = Math.min(255, 5 - p * 400);
                    }
                    pix[pidx + 3] = 255;
                }
            }
        } else {
            // Normal density rendering
            for (j = 0; j < gridH; j++) {
                for (i = 0; i < gridW; i++) {
                    idx = IX(i, j);
                    pidx = (j * gridW + i) * 4;

                    if (obstacleGrid[idx]) {
                        pix[pidx] = 40; pix[pidx+1] = 40; pix[pidx+2] = 55; pix[pidx+3] = 255;
                        continue;
                    }

                    rv = dr[idx];
                    gv = dg[idx];
                    bv = db[idx];

                    // Subtractive-ish color mixing: darken where multiple inks overlap
                    var totalDensity = rv + gv + bv;
                    var mixDarken = 1.0;
                    if (totalDensity > 1.5) {
                        // Count how many channels are significant
                        var active = 0;
                        if (rv > 0.2) active++;
                        if (gv > 0.2) active++;
                        if (bv > 0.2) active++;
                        if (active >= 2) {
                            mixDarken = 1.0 / (1.0 + (totalDensity - 1.5) * 0.3);
                        }
                    }

                    // Reinhard tonemapping
                    mr = rv / (1 + rv) * mixDarken;
                    mg = gv / (1 + gv) * mixDarken;
                    mb = bv / (1 + bv) * mixDarken;

                    // Glow boost
                    var lum = mr * 0.3 + mg * 0.5 + mb * 0.2;
                    var glow = 1.0 + lum * 0.5;

                    pix[pidx    ] = (5  + mr * glow * 250) & 255;
                    pix[pidx + 1] = (5  + mg * glow * 250) & 255;
                    pix[pidx + 2] = (16 + mb * glow * 239) & 255;
                    pix[pidx + 3] = 255;
                }
            }
        }

        fluidCtx.putImageData(imgData, 0, 0);

        // --- Bloom pass ---
        if (bloomEnabled && !showPressure) {
            bloomCtx.clearRect(0, 0, gridW, gridH);
            // Draw bright areas only
            bloomCtx.globalCompositeOperation = 'source-over';
            bloomCtx.filter = 'brightness(2) blur(3px)';
            bloomCtx.drawImage(fluidCanvas, 0, 0);
            bloomCtx.filter = 'none';
        }

        // Scale up to display
        displayCtx.imageSmoothingEnabled = true;
        displayCtx.imageSmoothingQuality = 'high';
        displayCtx.drawImage(fluidCanvas, 0, 0, displayCanvas.width, displayCanvas.height);

        // Bloom composite
        if (bloomEnabled && !showPressure) {
            displayCtx.globalCompositeOperation = 'screen';
            displayCtx.globalAlpha = 0.4;
            displayCtx.filter = 'blur(8px)';
            displayCtx.drawImage(bloomCanvas, 0, 0, displayCanvas.width, displayCanvas.height);
            displayCtx.filter = 'none';
            displayCtx.globalAlpha = 1.0;
            displayCtx.globalCompositeOperation = 'source-over';
        }

        // --- Draw obstacle outlines on display ---
        if (obstacles.length > 0) {
            var sx = displayCanvas.width / gridW;
            var sy = displayCanvas.height / gridH;
            displayCtx.strokeStyle = 'rgba(100,200,255,0.25)';
            displayCtx.lineWidth = 1.5;
            for (var o = 0; o < obstacles.length; o++) {
                var obs = obstacles[o];
                displayCtx.beginPath();
                displayCtx.arc(obs.cx * sx, obs.cy * sy, obs.r * sx, 0, Math.PI * 2);
                displayCtx.stroke();
            }
        }

        // --- Velocity field arrows ---
        if (showVelocity) {
            var step = 8;
            var arrowLen = 3.0;
            var sx2 = displayCanvas.width / gridW;
            var sy2 = displayCanvas.height / gridH;
            displayCtx.strokeStyle = 'rgba(100,200,255,0.3)';
            displayCtx.lineWidth = 1;
            displayCtx.beginPath();
            for (j = 2; j <= N; j += step) {
                for (i = 2; i <= N; i += step) {
                    idx = IX(i, j);
                    if (obstacleGrid[idx]) continue;
                    var vx = u[idx];
                    var vy = v[idx];
                    var mag = Math.sqrt(vx * vx + vy * vy);
                    if (mag < 0.05) continue;
                    var px = i * sx2;
                    var py = j * sy2;
                    var ax = (vx / mag) * Math.min(mag, 5) * arrowLen * sx2;
                    var ay = (vy / mag) * Math.min(mag, 5) * arrowLen * sy2;
                    displayCtx.moveTo(px, py);
                    displayCtx.lineTo(px + ax, py + ay);
                    // Arrowhead
                    var headLen = 2;
                    var angle = Math.atan2(ay, ax);
                    displayCtx.lineTo(px + ax - headLen * Math.cos(angle - 0.5), py + ay - headLen * Math.sin(angle - 0.5));
                    displayCtx.moveTo(px + ax, py + ay);
                    displayCtx.lineTo(px + ax - headLen * Math.cos(angle + 0.5), py + ay - headLen * Math.sin(angle + 0.5));
                }
            }
            displayCtx.stroke();
        }
    }

    // --- Film grain ---
    var grainImageData;
    function initGrain() {
        grainCanvas.width = window.innerWidth;
        grainCanvas.height = window.innerHeight;
        grainImageData = grainCtx.createImageData(grainCanvas.width, grainCanvas.height);
    }

    var grainFrame = 0;
    function updateGrain() {
        if (!grainEnabled) {
            grainCanvas.style.opacity = '0';
            return;
        }
        grainCanvas.style.opacity = '0.06';
        grainFrame++;
        if (grainFrame % 3 !== 0) return; // Update every 3rd frame for perf
        var data = grainImageData.data;
        var len = data.length;
        for (var i = 0; i < len; i += 4) {
            var v = (Math.random() * 255) | 0;
            data[i] = v; data[i+1] = v; data[i+2] = v; data[i+3] = 40;
        }
        grainCtx.putImageData(grainImageData, 0, 0);
    }

    // --- Resize ---
    function onResize() {
        displayCanvas.width = window.innerWidth;
        displayCanvas.height = window.innerHeight;
        initGrain();
    }

    // --- Main loop ---
    function step() {
        if (!paused) {
            time += dt;

            dr0.fill(0); dg0.fill(0); db0.fill(0);
            u0.fill(0); v0.fill(0);

            autoInject(time);
            injectKH(time);
            handleMouse();
            pmx = mx; pmy = my;
            mouseActive = false;

            velStep();

            var rr = densStep(dr, dr0);
            dr = rr.d; dr0 = rr.d0;
            var rg = densStep(dg, dg0);
            dg = rg.d; dg0 = rg.d0;
            var rb = densStep(db, db0);
            db = rb.d; db0 = rb.d0;

            render();
            updateGrain();
        }
        requestAnimationFrame(step);
    }

    // --- Events ---
    displayCanvas.addEventListener('mousemove', function(e) {
        pmx = mx; pmy = my;
        mx = e.clientX; my = e.clientY;
        mouseActive = true;
    });
    displayCanvas.addEventListener('mousedown', function(e) {
        if (e.button === 2) {
            // Right-click: place obstacle
            e.preventDefault();
            var scaleX = gridW / displayCanvas.width;
            var scaleY = gridH / displayCanvas.height;
            var gi = Math.round(e.clientX * scaleX);
            var gj = Math.round(e.clientY * scaleY);
            obstacles.push({ cx: gi, cy: gj, r: 6 });
            rebuildObstacleGrid();
            return;
        }
        mouseDown = true;
        mx = e.clientX; my = e.clientY;
        mouseActive = true;
    });
    displayCanvas.addEventListener('mouseup', function(e) {
        if (e.button === 0) mouseDown = false;
    });
    displayCanvas.addEventListener('mouseleave', function() {
        mouseDown = false; mouseActive = false;
    });
    displayCanvas.addEventListener('contextmenu', function(e) {
        e.preventDefault();
    });

    displayCanvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        var t = e.touches[0];
        mouseDown = true;
        mx = t.clientX; my = t.clientY;
        pmx = mx; pmy = my;
        mouseActive = true;
    }, { passive: false });
    displayCanvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        var t = e.touches[0];
        pmx = mx; pmy = my;
        mx = t.clientX; my = t.clientY;
        mouseActive = true;
    }, { passive: false });
    displayCanvas.addEventListener('touchend', function() {
        mouseDown = false; mouseActive = false;
    });

    // Arrow keys for gravity tilt
    var gravKeys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false };
    window.addEventListener('keydown', function(e) {
        if (e.key in gravKeys) {
            gravKeys[e.key] = true;
            updateGravity();
            e.preventDefault();
        }
        // Number keys 1-8 select ink color
        var num = parseInt(e.key);
        if (num >= 1 && num <= inkColors.length) {
            activeColorIdx = num - 1;
            document.querySelectorAll('.color-swatch').forEach(function(s, idx) {
                s.classList.toggle('active', idx === activeColorIdx);
            });
        }
        // C key to clear obstacles
        if (e.key === 'c' || e.key === 'C') {
            if (e.shiftKey) {
                obstacles = [];
                rebuildObstacleGrid();
            }
        }
        // Tab to toggle panel
        if (e.key === 'Tab') {
            e.preventDefault();
            panelEl.classList.toggle('hidden');
            toggleBtn.style.display = panelEl.classList.contains('hidden') ? 'block' : 'none';
        }
    });
    window.addEventListener('keyup', function(e) {
        if (e.key in gravKeys) {
            gravKeys[e.key] = false;
            updateGravity();
        }
    });

    function updateGravity() {
        gravX = 0; gravY = 0;
        if (gravKeys.ArrowLeft) gravX -= 3;
        if (gravKeys.ArrowRight) gravX += 3;
        if (gravKeys.ArrowUp) gravY -= 3;
        if (gravKeys.ArrowDown) gravY += 3;
    }

    // Device orientation for gravity tilt on mobile
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', function(e) {
            if (e.gamma !== null && e.beta !== null) {
                gravX = (e.gamma / 90) * 5;
                gravY = ((e.beta - 45) / 90) * 5;
                gravX = Math.max(-5, Math.min(5, gravX));
                gravY = Math.max(-5, Math.min(5, gravY));
            }
        });
    }

    window.addEventListener('resize', onResize);

    // --- Reset ---
    function resetFluid() {
        u.fill(0); v.fill(0); u0.fill(0); v0.fill(0);
        dr.fill(0); dg.fill(0); db.fill(0);
        dr0.fill(0); dg0.fill(0); db0.fill(0);
        vort.fill(0);
        pressureField.fill(0);
        obstacles = [];
        rebuildObstacleGrid();
        gravX = 0; gravY = 0;
        time = 0;
    }
    window.reset = resetFluid;

    // Expose pause for enhance.js
    Object.defineProperty(window, 'paused', {
        get: function() { return paused; },
        set: function(val) { paused = val; }
    });

    // --- Init ---
    onResize();
    initFluidImage();
    step();
})();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
