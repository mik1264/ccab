<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aurora Borealis - Northern Lights</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
        width: 100%; height: 100%;
        overflow: hidden;
        background: #000;
        font-family: 'Courier New', monospace;
    }
    canvas {
        display: block;
        width: 100%; height: 100%;
    }
    .back-link {
        position: fixed; top: 1rem; left: 1rem;
        color: rgba(100, 200, 255, 0.6);
        text-decoration: none;
        font-family: monospace;
        font-size: 0.85rem;
        z-index: 20;
        transition: color 0.3s;
    }
    .back-link:hover { color: rgba(100, 200, 255, 1); }
    .controls {
        position: fixed;
        bottom: 1.5rem;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        display: flex;
        align-items: center;
        gap: 1rem;
        background: rgba(0, 10, 30, 0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 0.6rem 1.2rem;
        border-radius: 2rem;
        border: 1px solid rgba(100, 200, 255, 0.15);
        flex-wrap: wrap;
        justify-content: center;
        max-width: 95vw;
    }
    .control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .controls label {
        color: rgba(100, 200, 255, 0.7);
        font-size: 0.65rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        white-space: nowrap;
    }
    .controls input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 90px;
        height: 4px;
        background: rgba(100, 200, 255, 0.2);
        border-radius: 2px;
        outline: none;
        cursor: pointer;
    }
    .controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px; height: 14px;
        border-radius: 50%;
        background: rgba(100, 220, 180, 0.9);
        border: 2px solid rgba(100, 200, 255, 0.4);
        cursor: pointer;
    }
    .controls input[type="range"]::-moz-range-thumb {
        width: 14px; height: 14px;
        border-radius: 50%;
        background: rgba(100, 220, 180, 0.9);
        border: 2px solid rgba(100, 200, 255, 0.4);
        cursor: pointer;
    }
    .controls button {
        background: rgba(100, 200, 255, 0.15);
        border: 1px solid rgba(100, 200, 255, 0.3);
        color: rgba(100, 200, 255, 0.8);
        padding: 0.3rem 0.6rem;
        border-radius: 1rem;
        font-family: 'Courier New', monospace;
        font-size: 0.6rem;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.3s;
        white-space: nowrap;
    }
    .controls button:hover {
        background: rgba(100, 200, 255, 0.3);
        color: rgba(100, 200, 255, 1);
    }
    .controls button.active {
        background: rgba(100, 220, 180, 0.3);
        border-color: rgba(100, 220, 180, 0.6);
        color: rgba(100, 220, 180, 1);
    }
    .controls select {
        background: rgba(0, 10, 30, 0.8);
        border: 1px solid rgba(100, 200, 255, 0.3);
        color: rgba(100, 200, 255, 0.8);
        padding: 0.25rem 0.4rem;
        border-radius: 0.5rem;
        font-family: 'Courier New', monospace;
        font-size: 0.6rem;
        cursor: pointer;
        outline: none;
    }
    .controls select option {
        background: #0a1020;
        color: rgba(100, 200, 255, 0.9);
    }
    .title-overlay {
        position: fixed;
        top: 1rem;
        right: 1.5rem;
        z-index: 20;
        color: rgba(100, 200, 255, 0.35);
        font-size: 0.7rem;
        letter-spacing: 0.15em;
        text-transform: uppercase;
    }
    .kp-display {
        position: fixed;
        top: 3rem;
        right: 1.5rem;
        z-index: 20;
        color: rgba(100, 200, 255, 0.25);
        font-size: 0.6rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
    }
</style>
</head>
<body>
<a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&larr; Back to Gallery</a>
<span class="title-overlay">Aurora Borealis</span>
<span class="kp-display" id="kpDisplay">KP 5 | Green (557nm O)</span>
<div class="controls">
    <div class="control-group">
        <label for="kpSlider">KP Index</label>
        <input type="range" id="kpSlider" min="1" max="9" value="5" step="1">
    </div>
    <div class="control-group">
        <label for="speedSlider">Speed</label>
        <input type="range" id="speedSlider" min="1" max="10" value="5" step="1">
    </div>
    <div class="control-group">
        <label for="colorMode">Color</label>
        <select id="colorMode">
            <option value="green">Green (557nm O)</option>
            <option value="red">Red (630nm O)</option>
            <option value="purple">Purple (N2)</option>
            <option value="blue">Blue (428nm N+)</option>
            <option value="multi">Multi-color</option>
        </select>
    </div>
    <div class="control-group">
        <button id="moonBtn">Moon</button>
        <button id="soundBtn">Sound</button>
    </div>
</div>
<canvas id="aurora"></canvas>

<script>
(function() {
    'use strict';

    var canvas = document.getElementById('aurora');
    var ctx = canvas.getContext('2d');
    var kpSlider = document.getElementById('kpSlider');
    var speedSlider = document.getElementById('speedSlider');
    var colorModeSelect = document.getElementById('colorMode');
    var moonBtn = document.getElementById('moonBtn');
    var soundBtn = document.getElementById('soundBtn');
    var kpDisplay = document.getElementById('kpDisplay');

    var W, H;
    var animId = null;
    var time = 0;
    var stars = [];
    var mountainPoints = [];
    var treePositions = [];
    var kpIndex = 5;
    var speedMul = 1;
    var colorMode = 'green';
    var moonEnabled = false;
    var soundEnabled = false;

    // Audio context for wind
    var audioCtx = null;
    var windGain = null;
    var windNodes = [];

    // Owl state
    var owl = null;
    var owlTimer = 0;

    // Shooting stars
    var shootingStars = [];

    // Charged particles
    var particles = [];
    var MAX_PARTICLES = 60;

    // --- Perlin-like noise ---
    var PERM = new Uint8Array(512);
    var GRAD = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];

    function initNoise() {
        var p = new Uint8Array(256);
        for (var i = 0; i < 256; i++) p[i] = i;
        for (var i = 255; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var tmp = p[i]; p[i] = p[j]; p[j] = tmp;
        }
        for (var i = 0; i < 512; i++) PERM[i] = p[i & 255];
    }

    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(a, b, t) { return a + t * (b - a); }
    function dot2(g, x, y) { return g[0] * x + g[1] * y; }

    function noise2D(x, y) {
        var xi = Math.floor(x) & 255;
        var yi = Math.floor(y) & 255;
        var xf = x - Math.floor(x);
        var yf = y - Math.floor(y);
        var u = fade(xf);
        var v = fade(yf);
        var aa = PERM[PERM[xi] + yi] & 7;
        var ab = PERM[PERM[xi] + yi + 1] & 7;
        var ba = PERM[PERM[xi + 1] + yi] & 7;
        var bb = PERM[PERM[xi + 1] + yi + 1] & 7;
        return lerp(
            lerp(dot2(GRAD[aa], xf, yf), dot2(GRAD[ba], xf - 1, yf), u),
            lerp(dot2(GRAD[ab], xf, yf - 1), dot2(GRAD[bb], xf - 1, yf - 1), u),
            v
        );
    }

    function fbm(x, y, octaves) {
        var val = 0, amp = 0.5, freq = 1;
        for (var i = 0; i < octaves; i++) {
            val += amp * noise2D(x * freq, y * freq);
            amp *= 0.5;
            freq *= 2.0;
        }
        return val;
    }

    // ==========================================================
    // COLOR PALETTES per mode
    // ==========================================================
    function getAuroraColors() {
        switch (colorMode) {
            case 'green':
                return [
                    [80, 255, 140],
                    [50, 220, 120],
                    [100, 255, 160],
                    [60, 200, 100],
                    [90, 240, 130]
                ];
            case 'red':
                return [
                    [255, 80, 80],
                    [220, 50, 70],
                    [255, 120, 100],
                    [200, 60, 60],
                    [240, 90, 80]
                ];
            case 'purple':
                return [
                    [180, 80, 255],
                    [140, 50, 220],
                    [200, 120, 255],
                    [160, 60, 200],
                    [190, 100, 240]
                ];
            case 'blue':
                return [
                    [80, 140, 255],
                    [50, 120, 220],
                    [100, 160, 255],
                    [60, 100, 200],
                    [90, 150, 240]
                ];
            case 'multi':
            default:
                return [
                    [80, 255, 140],
                    [50, 220, 180],
                    [100, 180, 255],
                    [180, 100, 255],
                    [60, 255, 120]
                ];
        }
    }

    // ==========================================================
    // STARS with CONSTELLATIONS
    // ==========================================================
    var constellations = {
        ursaMajor: {
            name: 'Ursa Major',
            stars: [
                {x: 0.15, y: 0.12}, {x: 0.18, y: 0.10}, {x: 0.21, y: 0.09},
                {x: 0.24, y: 0.10}, {x: 0.25, y: 0.13}, {x: 0.23, y: 0.15},
                {x: 0.20, y: 0.14}
            ],
            lines: [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,3]]
        },
        orion: {
            name: 'Orion',
            stars: [
                {x: 0.55, y: 0.06}, {x: 0.60, y: 0.05},
                {x: 0.565, y: 0.10}, {x: 0.575, y: 0.105}, {x: 0.585, y: 0.10},
                {x: 0.55, y: 0.16}, {x: 0.60, y: 0.15},
                {x: 0.54, y: 0.03}, {x: 0.61, y: 0.18}
            ],
            lines: [[0,2],[1,4],[2,3],[3,4],[0,5],[1,6],[7,0],[6,8]]
        },
        cassiopeia: {
            name: 'Cassiopeia',
            stars: [
                {x: 0.80, y: 0.08}, {x: 0.83, y: 0.05},
                {x: 0.86, y: 0.07}, {x: 0.89, y: 0.04},
                {x: 0.92, y: 0.06}
            ],
            lines: [[0,1],[1,2],[2,3],[3,4]]
        }
    };

    function generateStars() {
        stars = [];
        var count = Math.floor(W * H / 600);
        for (var i = 0; i < count; i++) {
            stars.push({
                x: Math.random() * W,
                y: Math.random() * H * 0.65,
                r: Math.random() * 1.5 + 0.3,
                brightness: Math.random(),
                twinkleSpeed: Math.random() * 2 + 1,
                twinkleOffset: Math.random() * Math.PI * 2
            });
        }
    }

    function drawStars(t) {
        for (var i = 0; i < stars.length; i++) {
            var s = stars[i];
            var twinkle = 0.5 + 0.5 * Math.sin(t * s.twinkleSpeed + s.twinkleOffset);
            var alpha = s.brightness * (0.4 + 0.6 * twinkle);
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, ' + alpha + ')';
            ctx.fill();
        }
    }

    function drawConstellations(t) {
        ctx.save();
        var baseAlpha = 0.25 + 0.1 * Math.sin(t * 0.3);
        ctx.strokeStyle = 'rgba(150, 180, 220, ' + (baseAlpha * 0.4) + ')';
        ctx.lineWidth = 0.6;

        for (var key in constellations) {
            var c = constellations[key];
            // Draw lines
            for (var li = 0; li < c.lines.length; li++) {
                var a = c.stars[c.lines[li][0]];
                var b = c.stars[c.lines[li][1]];
                ctx.beginPath();
                ctx.moveTo(a.x * W, a.y * H);
                ctx.lineTo(b.x * W, b.y * H);
                ctx.stroke();
            }
            // Draw constellation stars (brighter)
            for (var si = 0; si < c.stars.length; si++) {
                var s = c.stars[si];
                var br = 0.7 + 0.3 * Math.sin(t * 1.5 + si);
                ctx.beginPath();
                ctx.arc(s.x * W, s.y * H, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(200, 220, 255, ' + (br * baseAlpha * 2) + ')';
                ctx.fill();
            }
        }
        ctx.restore();
    }

    // ==========================================================
    // MOONLIGHT
    // ==========================================================
    function drawMoon(t) {
        if (!moonEnabled) return;
        var mx = W * 0.88;
        var my = H * 0.12;
        var mr = Math.min(W, H) * 0.035;

        // Moon glow
        ctx.save();
        var moonGlow = ctx.createRadialGradient(mx, my, mr * 0.5, mx, my, mr * 6);
        moonGlow.addColorStop(0, 'rgba(200, 210, 230, 0.08)');
        moonGlow.addColorStop(0.5, 'rgba(180, 200, 220, 0.03)');
        moonGlow.addColorStop(1, 'rgba(180, 200, 220, 0)');
        ctx.fillStyle = moonGlow;
        ctx.fillRect(0, 0, W, H);

        // Crescent moon
        ctx.beginPath();
        ctx.arc(mx, my, mr, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(220, 225, 235, 0.85)';
        ctx.fill();

        // Dark part for crescent shape
        ctx.beginPath();
        ctx.arc(mx + mr * 0.4, my - mr * 0.1, mr * 0.85, 0, Math.PI * 2);
        ctx.fillStyle = '#020510';
        ctx.fill();
        ctx.restore();
    }

    // ==========================================================
    // MAGNETIC FIELD LINES
    // ==========================================================
    function drawMagneticFieldLines(t) {
        ctx.save();
        var intensity = kpIndex / 9;
        ctx.globalAlpha = 0.04 + 0.06 * intensity;
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
        ctx.lineWidth = 0.5;

        var cx = W * 0.5;
        var groundY = H * 0.75;
        var lineCount = 7;

        for (var i = 0; i < lineCount; i++) {
            var spread = (i - lineCount / 2) / lineCount;
            var offsetX = spread * W * 0.8;
            ctx.beginPath();
            for (var s = 0; s <= 40; s++) {
                var frac = s / 40;
                var curveX = cx + offsetX * (1 - frac * frac);
                var curveY = frac * groundY;
                // Add subtle wave
                curveX += Math.sin(frac * 4 + t * 0.2 + i) * 15;
                if (s === 0) ctx.moveTo(curveX, curveY);
                else ctx.lineTo(curveX, curveY);
            }
            ctx.stroke();
        }
        ctx.restore();
    }

    // ==========================================================
    // CHARGED PARTICLES along field lines
    // ==========================================================
    function spawnParticle() {
        if (particles.length >= MAX_PARTICLES) return;
        var spread = (Math.random() - 0.5) * W * 0.6;
        particles.push({
            x: W * 0.5 + spread,
            y: -5,
            vx: spread * -0.002,
            vy: 1.5 + Math.random() * 2,
            life: 1,
            decay: 0.005 + Math.random() * 0.005,
            size: 1 + Math.random() * 1.5,
            color: getAuroraColors()[Math.floor(Math.random() * 5)]
        });
    }

    function updateAndDrawParticles(t) {
        var intensity = kpIndex / 9;
        if (Math.random() < 0.15 * intensity) spawnParticle();

        ctx.save();
        for (var i = particles.length - 1; i >= 0; i--) {
            var p = particles[i];
            // Spiral along field line
            p.x += p.vx + Math.sin(t * 3 + p.y * 0.02) * 0.5;
            p.y += p.vy;
            p.life -= p.decay;

            if (p.life <= 0 || p.y > H * 0.7) {
                particles.splice(i, 1);
                continue;
            }

            var alpha = p.life * 0.6 * intensity;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + p.color[0] + ',' + p.color[1] + ',' + p.color[2] + ',' + alpha + ')';
            ctx.fill();
        }
        ctx.restore();
    }

    // ==========================================================
    // AURORA CURTAINS (multi-layer parallax + corona)
    // ==========================================================
    function drawAurora(t) {
        var curtainCount = 5;
        var colors = getAuroraColors();
        var kpIntensity = kpIndex / 9;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';

        // 5 curtain layers at different depths
        for (var c = 0; c < curtainCount; c++) {
            var phase = c * 1.3;
            var speedFactor = (0.6 + c * 0.18) * speedMul;
            var depthScale = 1 - c * 0.12; // parallax: further curtains move slower
            var baseAlpha = (0.08 + c * 0.025) * kpIntensity;

            var stripWidth = 3;
            var strips = Math.ceil(W / stripWidth);

            for (var i = 0; i <= strips; i++) {
                var x = i * stripWidth;
                var nx = x / W;

                var wave1 = Math.sin(nx * 4 + t * 0.3 * speedFactor * depthScale + phase) * 0.15;
                var wave2 = Math.sin(nx * 8 + t * 0.5 * speedFactor * depthScale + phase * 1.5) * 0.08;
                var wave3 = Math.sin(nx * 16 + t * 0.2 * speedFactor * depthScale + phase * 0.7) * 0.04;

                var n1 = fbm(nx * 2 + t * 0.08 * speedFactor * depthScale + phase, c * 0.5 + t * 0.02 * depthScale, 4);
                var n2 = fbm(nx * 3 - t * 0.05 * speedFactor * depthScale + phase * 2, c * 0.7, 3);

                var presence = Math.max(0, Math.sin(nx * 2.5 + t * 0.1 * speedFactor + phase) * 0.5 + n1 * 0.5 + 0.2);
                if (presence < 0.15) continue;

                // KP affects vertical extent
                var topBase = H * (0.05 - kpIntensity * 0.03);
                var bottomBase = H * (0.4 + kpIntensity * 0.2);
                var waveOffset = (wave1 + wave2 + wave3) * H;
                var noiseOffset = n2 * H * 0.12;

                var topY = topBase + noiseOffset + Math.abs(n1) * H * 0.1;
                var bottomY = bottomBase + waveOffset + noiseOffset + n1 * H * 0.15;
                var curtainHeight = bottomY - topY;
                if (curtainHeight <= 0) continue;

                var grad = ctx.createLinearGradient(x, topY, x, bottomY);
                var col = colors[c % colors.length];
                var colorBase = 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',';

                var peakAlpha = baseAlpha * presence;
                var shimmer = 0.7 + 0.3 * Math.sin(t * 2 + nx * 20 + phase);
                var finalAlpha = peakAlpha * shimmer;

                grad.addColorStop(0, colorBase + (finalAlpha * 0.1) + ')');
                grad.addColorStop(0.15, colorBase + (finalAlpha * 0.5) + ')');
                grad.addColorStop(0.3, colorBase + (finalAlpha * 0.9) + ')');
                grad.addColorStop(0.5, colorBase + finalAlpha + ')');
                grad.addColorStop(0.7, colorBase + (finalAlpha * 0.6) + ')');
                grad.addColorStop(0.85, colorBase + (finalAlpha * 0.2) + ')');
                grad.addColorStop(1, colorBase + '0)');

                ctx.fillStyle = grad;
                ctx.fillRect(x, topY, stripWidth + 1, curtainHeight);
            }
        }

        // Glow bloom layers
        for (var g = 0; g < 4; g++) {
            var glowX = W * (0.15 + 0.23 * g) + Math.sin(t * 0.2 + g) * W * 0.1;
            var glowY = H * 0.2 + Math.sin(t * 0.15 + g * 2) * H * 0.08;
            var glowR = W * (0.12 + 0.12 * kpIntensity);

            var glowGrad = ctx.createRadialGradient(glowX, glowY, 0, glowX, glowY, glowR);
            var gc = colors[g % colors.length];
            var gcStr = 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',';
            glowGrad.addColorStop(0, gcStr + (0.07 * kpIntensity) + ')');
            glowGrad.addColorStop(0.5, gcStr + (0.025 * kpIntensity) + ')');
            glowGrad.addColorStop(1, gcStr + '0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(0, 0, W, H * 0.7);
        }

        ctx.restore();
    }

    // ==========================================================
    // AURORA CORONA (overhead convergence at high KP)
    // ==========================================================
    function drawAuroraCorona(t) {
        if (kpIndex < 6) return;
        var coronaIntensity = (kpIndex - 5) / 4; // 0 at KP5, 1 at KP9
        var colors = getAuroraColors();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = coronaIntensity * 0.4;

        var cx = W * 0.5 + Math.sin(t * 0.15) * W * 0.05;
        var cy = H * 0.02;
        var rayCount = 24;

        for (var i = 0; i < rayCount; i++) {
            var angle = (i / rayCount) * Math.PI * 2 + t * 0.05;
            var rayLen = H * (0.3 + 0.15 * Math.sin(t * 0.8 + i * 1.3));
            var ex = cx + Math.cos(angle) * rayLen * 1.5;
            var ey = cy + Math.sin(angle) * rayLen;

            var col = colors[i % colors.length];
            var colStr = 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',';

            var rayGrad = ctx.createLinearGradient(cx, cy, ex, ey);
            var shimmer = 0.5 + 0.5 * Math.sin(t * 2 + i * 0.8);
            rayGrad.addColorStop(0, colStr + (0.3 * shimmer) + ')');
            rayGrad.addColorStop(0.3, colStr + (0.15 * shimmer) + ')');
            rayGrad.addColorStop(1, colStr + '0)');

            ctx.beginPath();
            ctx.moveTo(cx - Math.sin(angle) * 3, cy + Math.cos(angle) * 3);
            ctx.lineTo(ex, ey);
            ctx.lineTo(cx + Math.sin(angle) * 3, cy - Math.cos(angle) * 3);
            ctx.closePath();
            ctx.fillStyle = rayGrad;
            ctx.fill();
        }

        // Central glow
        var cGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, H * 0.08);
        var mainCol = colors[0];
        cGlow.addColorStop(0, 'rgba(' + mainCol[0] + ',' + mainCol[1] + ',' + mainCol[2] + ',' + (0.2 * coronaIntensity) + ')');
        cGlow.addColorStop(1, 'rgba(' + mainCol[0] + ',' + mainCol[1] + ',' + mainCol[2] + ',0)');
        ctx.fillStyle = cGlow;
        ctx.beginPath();
        ctx.arc(cx, cy, H * 0.08, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ==========================================================
    // MOUNTAIN SILHOUETTE
    // ==========================================================
    function generateMountains() {
        mountainPoints = [];
        var segments = Math.ceil(W / 4) + 1;
        for (var i = 0; i <= segments; i++) {
            var x = (i / segments) * W;
            var nx = x / W;
            var h = 0;
            h += 0.5 * Math.sin(nx * 3.5 + 0.3) * Math.sin(nx * 2.1 + 1.7);
            h += 0.3 * Math.sin(nx * 7.2 + 2.1);
            h += 0.15 * Math.sin(nx * 14.5 + 0.8);
            h += 0.08 * Math.sin(nx * 28 + 3.2);
            h += 0.04 * Math.sin(nx * 55 + 1.1);
            var mountainBase = H * 0.78;
            var mountainHeight = H * 0.18;
            var py = mountainBase - Math.abs(h) * mountainHeight;
            mountainPoints.push({ x: x, y: py });
        }
    }

    function drawMountains() {
        // Distant mountain range (lighter)
        ctx.beginPath();
        ctx.moveTo(0, H);
        for (var i = 0; i < mountainPoints.length; i++) {
            var mp = mountainPoints[i];
            ctx.lineTo(mp.x, mp.y + H * 0.03 + Math.sin(mp.x / W * 5 + 1.2) * H * 0.02);
        }
        ctx.lineTo(W, H);
        ctx.closePath();
        ctx.fillStyle = '#0d0d1a';
        ctx.fill();

        // Near mountain range
        ctx.beginPath();
        ctx.moveTo(0, H);
        for (var i = 0; i < mountainPoints.length; i++) {
            ctx.lineTo(mountainPoints[i].x, mountainPoints[i].y);
        }
        ctx.lineTo(W, H);
        ctx.closePath();
        ctx.fillStyle = '#08080f';
        ctx.fill();

        // Snow caps on highest peaks
        ctx.save();
        ctx.globalAlpha = 0.15;
        for (var i = 1; i < mountainPoints.length - 1; i++) {
            var prev = mountainPoints[i - 1];
            var curr = mountainPoints[i];
            var next = mountainPoints[i + 1];
            if (curr.y < prev.y && curr.y < next.y && curr.y < H * 0.72) {
                ctx.beginPath();
                ctx.moveTo(curr.x - 8, curr.y + 6);
                ctx.lineTo(curr.x, curr.y);
                ctx.lineTo(curr.x + 8, curr.y + 6);
                ctx.fillStyle = 'rgba(200, 210, 230, 0.4)';
                ctx.fill();
            }
        }
        ctx.restore();
    }

    // ==========================================================
    // PINE TREES (snow-covered silhouettes)
    // ==========================================================
    function generateTrees() {
        treePositions = [];
        var treeCount = Math.floor(W / 35);
        for (var i = 0; i < treeCount; i++) {
            var x = (i / treeCount) * W + (Math.random() - 0.5) * 30;
            var baseY = H * (0.79 + Math.random() * 0.04);
            var height = 20 + Math.random() * 40;
            var width = height * (0.25 + Math.random() * 0.15);
            treePositions.push({x: x, y: baseY, h: height, w: width, snow: Math.random() > 0.4});
        }
    }

    function drawTree(tx, ty, th, tw, hasSnow) {
        // Trunk
        ctx.fillStyle = '#050508';
        ctx.fillRect(tx - 2, ty - th * 0.15, 4, th * 0.15);

        // Layered branches
        var layers = 4;
        for (var l = 0; l < layers; l++) {
            var frac = l / layers;
            var layerY = ty - th * (0.1 + frac * 0.9);
            var layerW = tw * (1 - frac * 0.6);
            ctx.beginPath();
            ctx.moveTo(tx, layerY - th * 0.25);
            ctx.lineTo(tx - layerW, layerY + th * 0.05);
            ctx.lineTo(tx + layerW, layerY + th * 0.05);
            ctx.closePath();
            ctx.fillStyle = '#060610';
            ctx.fill();

            // Snow on branches
            if (hasSnow) {
                ctx.beginPath();
                ctx.moveTo(tx, layerY - th * 0.25);
                ctx.lineTo(tx - layerW * 0.6, layerY - th * 0.08);
                ctx.lineTo(tx + layerW * 0.3, layerY - th * 0.1);
                ctx.closePath();
                ctx.fillStyle = 'rgba(180, 190, 210, 0.08)';
                ctx.fill();
            }
        }
    }

    function drawTrees() {
        for (var i = 0; i < treePositions.length; i++) {
            var t = treePositions[i];
            drawTree(t.x, t.y, t.h, t.w, t.snow);
        }
    }

    // ==========================================================
    // FROZEN LAKE with AURORA REFLECTION
    // ==========================================================
    function drawFrozenLake(t) {
        var lakeTop = H * 0.84;
        var lakeBottom = H * 0.92;
        var lakeLeft = W * 0.1;
        var lakeRight = W * 0.9;

        // Ice surface
        var iceGrad = ctx.createLinearGradient(0, lakeTop, 0, lakeBottom);
        iceGrad.addColorStop(0, 'rgba(15, 20, 35, 0.9)');
        iceGrad.addColorStop(0.5, 'rgba(20, 25, 45, 0.85)');
        iceGrad.addColorStop(1, 'rgba(12, 16, 30, 0.95)');

        ctx.beginPath();
        ctx.ellipse((lakeLeft + lakeRight) / 2, (lakeTop + lakeBottom) / 2,
            (lakeRight - lakeLeft) / 2, (lakeBottom - lakeTop) / 2, 0, 0, Math.PI * 2);
        ctx.fillStyle = iceGrad;
        ctx.fill();

        // Aurora reflection in lake
        ctx.save();
        ctx.beginPath();
        ctx.ellipse((lakeLeft + lakeRight) / 2, (lakeTop + lakeBottom) / 2,
            (lakeRight - lakeLeft) / 2, (lakeBottom - lakeTop) / 2, 0, 0, Math.PI * 2);
        ctx.clip();

        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.06 * (kpIndex / 9);

        var colors = getAuroraColors();
        var stripW = 6;
        var strips = Math.ceil((lakeRight - lakeLeft) / stripW);
        for (var i = 0; i < strips; i++) {
            var x = lakeLeft + i * stripW;
            var nx = i / strips;
            var wave = Math.sin(nx * 5 + t * 0.4) * 3;
            var presence = 0.5 + 0.5 * Math.sin(nx * 3 + t * 0.15);
            var col = colors[i % colors.length];

            var reflGrad = ctx.createLinearGradient(x, lakeTop, x, lakeBottom);
            var colStr = 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',';
            reflGrad.addColorStop(0, colStr + (presence * 0.4) + ')');
            reflGrad.addColorStop(0.5, colStr + (presence * 0.2) + ')');
            reflGrad.addColorStop(1, colStr + '0)');
            ctx.fillStyle = reflGrad;
            ctx.fillRect(x + wave, lakeTop, stripW + 1, lakeBottom - lakeTop);
        }

        // Ice cracks/highlights
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 0.04;
        ctx.strokeStyle = 'rgba(150, 180, 220, 0.3)';
        ctx.lineWidth = 0.5;
        for (var c = 0; c < 8; c++) {
            ctx.beginPath();
            var sx = lakeLeft + Math.random() * (lakeRight - lakeLeft);
            var sy = lakeTop + Math.random() * (lakeBottom - lakeTop) * 0.5;
            ctx.moveTo(sx, sy);
            for (var seg = 0; seg < 4; seg++) {
                sx += (Math.random() - 0.5) * 40;
                sy += Math.random() * 15;
                ctx.lineTo(sx, sy);
            }
            ctx.stroke();
        }

        ctx.restore();
    }

    // ==========================================================
    // SNOW GROUND
    // ==========================================================
    function drawSnowGround(t) {
        var snowTop = H * 0.88;
        var grd = ctx.createLinearGradient(0, snowTop, 0, H);
        grd.addColorStop(0, 'rgba(18, 20, 32, 0.9)');
        grd.addColorStop(0.3, 'rgba(25, 30, 45, 0.95)');
        grd.addColorStop(1, 'rgba(12, 15, 25, 1)');
        ctx.fillStyle = grd;
        ctx.fillRect(0, snowTop, W, H - snowTop);

        // Subtle aurora reflection on snow
        ctx.save();
        ctx.globalAlpha = 0.05 * (kpIndex / 9);
        ctx.globalCompositeOperation = 'screen';
        var colors = getAuroraColors();
        for (var i = 0; i < 3; i++) {
            var col = colors[i];
            var gx = W * (0.2 + 0.3 * i);
            var reflGrd = ctx.createRadialGradient(gx, snowTop, 0, gx, snowTop + 30, W * 0.2);
            reflGrd.addColorStop(0, 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',0.3)');
            reflGrd.addColorStop(1, 'transparent');
            ctx.fillStyle = reflGrd;
            ctx.fillRect(0, snowTop, W, H - snowTop);
        }
        ctx.restore();
    }

    // ==========================================================
    // SKY GRADIENT
    // ==========================================================
    function drawSky() {
        var grd = ctx.createLinearGradient(0, 0, 0, H);
        grd.addColorStop(0, '#020510');
        grd.addColorStop(0.3, '#050a1a');
        grd.addColorStop(0.6, '#0a1025');
        grd.addColorStop(0.85, '#0d1530');
        grd.addColorStop(1, '#0a1020');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, W, H);
    }

    // ==========================================================
    // SHOOTING STARS
    // ==========================================================
    function maybeAddShootingStar() {
        if (Math.random() < 0.003 && shootingStars.length < 3) {
            shootingStars.push({
                x: Math.random() * W,
                y: Math.random() * H * 0.35,
                vx: (Math.random() - 0.3) * 10,
                vy: Math.random() * 4 + 2,
                life: 1,
                decay: 0.012 + Math.random() * 0.01,
                len: 35 + Math.random() * 50
            });
        }
    }

    function drawShootingStars() {
        for (var i = shootingStars.length - 1; i >= 0; i--) {
            var ss = shootingStars[i];
            ss.x += ss.vx;
            ss.y += ss.vy;
            ss.life -= ss.decay;
            if (ss.life <= 0) {
                shootingStars.splice(i, 1);
                continue;
            }
            var alpha = ss.life;
            var grad = ctx.createLinearGradient(
                ss.x, ss.y,
                ss.x - ss.vx * ss.len / 8, ss.y - ss.vy * ss.len / 8
            );
            grad.addColorStop(0, 'rgba(255, 255, 255, ' + alpha + ')');
            grad.addColorStop(0.3, 'rgba(200, 220, 255, ' + (alpha * 0.6) + ')');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.moveTo(ss.x, ss.y);
            ctx.lineTo(ss.x - ss.vx * ss.len / 8, ss.y - ss.vy * ss.len / 8);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Bright head
            ctx.beginPath();
            ctx.arc(ss.x, ss.y, 1.5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, ' + (alpha * 0.8) + ')';
            ctx.fill();
        }
    }

    // ==========================================================
    // OWL SILHOUETTE
    // ==========================================================
    function maybeSpawnOwl(t) {
        owlTimer -= 0.016;
        if (owlTimer <= 0 && owl === null && Math.random() < 0.002) {
            var fromLeft = Math.random() > 0.5;
            owl = {
                x: fromLeft ? -30 : W + 30,
                y: H * (0.3 + Math.random() * 0.3),
                vx: fromLeft ? 1.5 + Math.random() : -(1.5 + Math.random()),
                wingPhase: 0,
                scale: 0.7 + Math.random() * 0.5
            };
            owlTimer = 15 + Math.random() * 20;
        }
    }

    function drawOwl(t) {
        if (!owl) return;
        owl.x += owl.vx;
        owl.y += Math.sin(t * 1.5) * 0.3;
        owl.wingPhase += 0.08;

        if (owl.x < -50 || owl.x > W + 50) {
            owl = null;
            return;
        }

        var s = owl.scale;
        var ox = owl.x;
        var oy = owl.y;
        var wingFlap = Math.sin(owl.wingPhase) * 8 * s;

        ctx.save();
        ctx.fillStyle = '#0a0a12';

        // Body
        ctx.beginPath();
        ctx.ellipse(ox, oy, 8 * s, 6 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Head
        ctx.beginPath();
        ctx.arc(ox + (owl.vx > 0 ? 5 : -5) * s, oy - 5 * s, 5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Wings
        ctx.beginPath();
        ctx.moveTo(ox - 5 * s, oy);
        ctx.quadraticCurveTo(ox - 18 * s, oy - 10 * s + wingFlap, ox - 22 * s, oy + wingFlap);
        ctx.lineTo(ox - 5 * s, oy + 3 * s);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(ox + 5 * s, oy);
        ctx.quadraticCurveTo(ox + 18 * s, oy - 10 * s + wingFlap, ox + 22 * s, oy + wingFlap);
        ctx.lineTo(ox + 5 * s, oy + 3 * s);
        ctx.fill();

        // Eyes (tiny glowing dots)
        var eyeX = ox + (owl.vx > 0 ? 7 : -7) * s;
        ctx.fillStyle = 'rgba(255, 220, 80, 0.6)';
        ctx.beginPath();
        ctx.arc(eyeX - 2 * s, oy - 5 * s, 1.2 * s, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX + 2 * s, oy - 5 * s, 1.2 * s, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ==========================================================
    // FILM GRAIN + VIGNETTE
    // ==========================================================
    function drawFilmGrain() {
        var imageData = ctx.getImageData(0, 0, W, H);
        var data = imageData.data;
        // Sparse grain for performance
        var step = 4;
        for (var y = 0; y < H; y += step) {
            for (var x = 0; x < W; x += step) {
                var idx = (y * W + x) * 4;
                var grain = (Math.random() - 0.5) * 12;
                data[idx] += grain;
                data[idx + 1] += grain;
                data[idx + 2] += grain;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }

    function drawVignette() {
        var vignette = ctx.createRadialGradient(W / 2, H / 2, W * 0.25, W / 2, H / 2, W * 0.75);
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(0.7, 'rgba(0,0,0,0.15)');
        vignette.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, W, H);
    }

    // ==========================================================
    // AMBIENT WIND SOUND (Web Audio oscillators)
    // ==========================================================
    function initSound() {
        if (audioCtx) return;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            windGain = audioCtx.createGain();
            windGain.gain.value = 0;
            windGain.connect(audioCtx.destination);

            // Multiple detuned oscillators + filtering for wind-like sound
            for (var i = 0; i < 4; i++) {
                var osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = 60 + i * 15 + Math.random() * 20;

                var filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200 + i * 50;
                filter.Q.value = 0.5;

                var oscGain = audioCtx.createGain();
                oscGain.gain.value = 0.03;

                osc.connect(filter);
                filter.connect(oscGain);
                oscGain.connect(windGain);
                osc.start();

                windNodes.push({osc: osc, filter: filter, gain: oscGain});
            }

            // White noise for wind texture
            var bufferSize = audioCtx.sampleRate * 2;
            var noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var output = noiseBuffer.getChannelData(0);
            for (var s = 0; s < bufferSize; s++) {
                output[s] = (Math.random() * 2 - 1) * 0.5;
            }
            var whiteNoise = audioCtx.createBufferSource();
            whiteNoise.buffer = noiseBuffer;
            whiteNoise.loop = true;

            var noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 300;
            noiseFilter.Q.value = 0.3;

            var noiseGain = audioCtx.createGain();
            noiseGain.gain.value = 0.06;

            whiteNoise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(windGain);
            whiteNoise.start();

            windNodes.push({osc: whiteNoise, filter: noiseFilter, gain: noiseGain});
        } catch (e) {
            audioCtx = null;
        }
    }

    function updateSound(t) {
        if (!audioCtx || !windGain) return;
        var targetVol = soundEnabled ? 0.15 : 0;
        windGain.gain.value += (targetVol - windGain.gain.value) * 0.02;

        // Modulate filter frequencies for wind gusts
        for (var i = 0; i < windNodes.length; i++) {
            var node = windNodes[i];
            if (node.filter) {
                var gustMod = Math.sin(t * 0.3 + i * 1.5) * 80 + Math.sin(t * 0.7 + i) * 40;
                node.filter.frequency.value = 200 + i * 50 + gustMod;
            }
        }
    }

    // ==========================================================
    // RESIZE
    // ==========================================================
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        generateStars();
        generateMountains();
        generateTrees();
    }

    // ==========================================================
    // MAIN RENDER LOOP
    // ==========================================================
    function render() {
        var dt = 0.016 * speedMul;
        time += dt;
        kpIndex = parseInt(kpSlider.value);
        speedMul = parseInt(speedSlider.value) / 5;
        colorMode = colorModeSelect.value;

        // Update KP display
        var colorNames = {green:'Green (557nm O)', red:'Red (630nm O)', purple:'Purple (N2)', blue:'Blue (428nm N+)', multi:'Multi-color'};
        kpDisplay.textContent = 'KP ' + kpIndex + ' | ' + (colorNames[colorMode] || colorMode);

        ctx.clearRect(0, 0, W, H);

        drawSky();
        drawMoon(time);
        drawConstellations(time);
        drawStars(time);
        drawMagneticFieldLines(time);
        updateAndDrawParticles(time);
        drawAurora(time);
        drawAuroraCorona(time);
        maybeAddShootingStar();
        drawShootingStars();
        drawMountains();
        drawTrees();
        drawFrozenLake(time);
        drawSnowGround(time);
        maybeSpawnOwl(time);
        drawOwl(time);
        drawFilmGrain();
        drawVignette();

        updateSound(time);

        animId = requestAnimationFrame(render);
    }

    // ==========================================================
    // INIT
    // ==========================================================
    function init() {
        initNoise();
        resize();
        if (animId) cancelAnimationFrame(animId);
        time = 0;
        shootingStars = [];
        particles = [];
        owl = null;
        owlTimer = 5;
        render();
    }

    // ==========================================================
    // RESET
    // ==========================================================
    window.reset = function() {
        initNoise();
        time = 0;
        shootingStars = [];
        particles = [];
        owl = null;
        owlTimer = 5;
        generateStars();
        generateMountains();
        generateTrees();
        kpSlider.value = 5;
        speedSlider.value = 5;
        colorModeSelect.value = 'green';
        kpIndex = 5;
        speedMul = 1;
        colorMode = 'green';
        moonEnabled = false;
        moonBtn.classList.remove('active');
        soundEnabled = false;
        soundBtn.classList.remove('active');
    };

    // ==========================================================
    // EVENTS
    // ==========================================================
    moonBtn.addEventListener('click', function() {
        moonEnabled = !moonEnabled;
        moonBtn.classList.toggle('active', moonEnabled);
    });

    soundBtn.addEventListener('click', function() {
        if (!audioCtx) initSound();
        soundEnabled = !soundEnabled;
        soundBtn.classList.toggle('active', soundEnabled);
    });

    var resizeTimer;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(resize, 150);
    });

    init();
})();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
