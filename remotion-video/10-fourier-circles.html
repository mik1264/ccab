<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fourier Epicycle Drawing</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    background: #080c1c;
    font-family: 'Courier New', monospace;
    color: #c0d8f0;
  }

  canvas {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
  }

  .vignette {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.6) 100%);
    pointer-events: none;
    z-index: 5;
  }

  .scanlines {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.04) 2px,
      rgba(0,0,0,0.04) 4px
    );
    pointer-events: none;
    z-index: 6;
  }

  .film-grain {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 7;
    opacity: 0.06;
    animation: grainShift 0.5s steps(4) infinite;
  }

  @keyframes grainShift {
    0%   { transform: translate(0, 0); }
    25%  { transform: translate(-2px, 1px); }
    50%  { transform: translate(1px, -1px); }
    75%  { transform: translate(-1px, 2px); }
    100% { transform: translate(2px, -2px); }
  }

  .controls {
    position: fixed;
    bottom: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 20;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.6rem;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    background: rgba(10, 15, 30, 0.7);
    border: 1px solid rgba(100, 200, 255, 0.15);
    border-radius: 12px;
    padding: 0.8rem 1.2rem;
    min-width: 380px;
    max-width: 95vw;
  }

  .shape-buttons {
    display: flex;
    gap: 0.4rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .shape-btn {
    background: rgba(100, 200, 255, 0.1);
    border: 1px solid rgba(100, 200, 255, 0.25);
    color: rgba(100, 200, 255, 0.7);
    padding: 0.3rem 0.6rem;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-size: 0.72rem;
    transition: all 0.3s;
  }

  .shape-btn:hover {
    background: rgba(100, 200, 255, 0.2);
    color: rgba(100, 200, 255, 0.95);
  }

  .shape-btn.active {
    background: rgba(100, 200, 255, 0.25);
    border-color: rgba(100, 200, 255, 0.6);
    color: rgba(100, 200, 255, 1);
    box-shadow: 0 0 12px rgba(100, 200, 255, 0.2);
  }

  .shape-btn.draw-btn {
    background: rgba(255, 180, 100, 0.15);
    border-color: rgba(255, 180, 100, 0.35);
    color: rgba(255, 200, 140, 0.8);
  }

  .shape-btn.draw-btn:hover {
    background: rgba(255, 180, 100, 0.25);
    color: rgba(255, 200, 140, 1);
  }

  .shape-btn.draw-btn.active {
    background: rgba(255, 180, 100, 0.3);
    border-color: rgba(255, 180, 100, 0.7);
    color: rgba(255, 220, 160, 1);
    box-shadow: 0 0 12px rgba(255, 180, 100, 0.3);
  }

  .slider-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    width: 100%;
  }

  .slider-label {
    font-size: 0.7rem;
    color: rgba(100, 200, 255, 0.5);
    white-space: nowrap;
    min-width: 68px;
  }

  .slider-value {
    font-size: 0.7rem;
    color: rgba(100, 200, 255, 0.8);
    min-width: 36px;
    text-align: right;
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    flex: 1;
    height: 4px;
    background: rgba(100, 200, 255, 0.15);
    border-radius: 2px;
    outline: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: rgba(100, 200, 255, 0.7);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(100, 200, 255, 0.4);
  }

  input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: rgba(100, 200, 255, 0.7);
    cursor: pointer;
    border: none;
    box-shadow: 0 0 8px rgba(100, 200, 255, 0.4);
  }

  .title-overlay {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 20;
    text-align: right;
  }

  .title-overlay h1 {
    font-size: 1rem;
    font-weight: 400;
    color: rgba(100, 200, 255, 0.5);
    letter-spacing: 0.1em;
  }

  .title-overlay p {
    font-size: 0.7rem;
    color: rgba(100, 200, 255, 0.3);
    margin-top: 0.2rem;
  }

  .draw-hint {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 15;
    font-size: 1.2rem;
    color: rgba(255, 200, 140, 0.6);
    letter-spacing: 0.15em;
    pointer-events: none;
    transition: opacity 0.5s;
  }

  .spectrum-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 50px;
    z-index: 3;
    pointer-events: none;
  }
</style>
</head>
<body>

<a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&larr; Back to Gallery</a>

<canvas id="canvas"></canvas>
<canvas id="grainCanvas" class="film-grain"></canvas>
<div class="vignette"></div>
<div class="scanlines"></div>

<div class="title-overlay">
  <h1>FOURIER EPICYCLES</h1>
  <p>Discrete Fourier Transform &mdash; Split View</p>
</div>

<div id="drawHint" class="draw-hint" style="opacity:0">Draw a shape with your mouse...</div>

<div class="controls">
  <div class="shape-buttons">
    <button class="shape-btn active" data-shape="star">Star</button>
    <button class="shape-btn" data-shape="heart">Heart</button>
    <button class="shape-btn" data-shape="treble">Treble</button>
    <button class="shape-btn" data-shape="infinity">Infinity</button>
    <button class="shape-btn" data-shape="pi">Pi</button>
    <button class="shape-btn" data-shape="note">Note</button>
    <button class="shape-btn" data-shape="butterfly">Butterfly</button>
    <button class="shape-btn" data-shape="cat">Cat</button>
    <button class="shape-btn draw-btn" data-shape="draw">Draw</button>
  </div>
  <div class="slider-row">
    <span class="slider-label">Epicycles</span>
    <input type="range" id="epicycleSlider" min="1" max="200" value="80">
    <span class="slider-value" id="epicycleValue">80</span>
  </div>
  <div class="slider-row">
    <span class="slider-label">Speed</span>
    <input type="range" id="speedSlider" min="1" max="50" value="10" step="1">
    <span class="slider-value" id="speedValue">1.0x</span>
  </div>
</div>

<script>
(function() {
  'use strict';

  var canvas = document.getElementById('canvas');
  var ctx = canvas.getContext('2d');
  var grainCanvas = document.getElementById('grainCanvas');
  var grainCtx = grainCanvas.getContext('2d');

  var W, H, scaleF;
  var paused = false;
  var time = 0;
  var path = [];
  var fourierX = [];
  var fourierY = [];
  var numEpicycles = 80;
  var speedMult = 1.0;
  var currentShape = 'star';
  var drawMode = false;
  var isDrawing = false;
  var userPoints = [];
  var ghostPoints = [];
  var particles = [];
  var globalTime = 0;

  // --- Film grain ---
  function generateGrain() {
    grainCanvas.width = 256;
    grainCanvas.height = 256;
    var imgData = grainCtx.createImageData(256, 256);
    var d = imgData.data;
    for (var i = 0; i < d.length; i += 4) {
      var v = Math.random() * 255;
      d[i] = v; d[i+1] = v; d[i+2] = v;
      d[i+3] = 255;
    }
    grainCtx.putImageData(imgData, 0, 0);
  }

  // --- DFT ---
  function dft(x) {
    var N = x.length;
    var X = [];
    for (var k = 0; k < N; k++) {
      var re = 0, im = 0;
      for (var n = 0; n < N; n++) {
        var phi = (2 * Math.PI * k * n) / N;
        re += x[n] * Math.cos(phi);
        im -= x[n] * Math.sin(phi);
      }
      re /= N;
      im /= N;
      X.push({
        re: re, im: im, freq: k,
        amp: Math.sqrt(re * re + im * im),
        phase: Math.atan2(im, re)
      });
    }
    X.sort(function(a, b) { return b.amp - a.amp; });
    return X;
  }

  // --- Shape generators ---
  function generateShape(name, numPoints) {
    numPoints = numPoints || 256;
    var points = [];
    var i, t, x, y, r, s, n;

    switch (name) {
      case 'star':
        for (i = 0; i < numPoints; i++) {
          t = (i / numPoints) * 2 * Math.PI;
          var angle5 = 5 * t;
          var sharpness = Math.pow(Math.abs(Math.cos(angle5 * 0.5)), 0.5);
          r = 0.4 + 0.6 * sharpness;
          points.push({ x: r * Math.cos(t - Math.PI / 2), y: r * Math.sin(t - Math.PI / 2) });
        }
        break;

      case 'heart':
        for (i = 0; i < numPoints; i++) {
          t = (i / numPoints) * 2 * Math.PI;
          x = 16 * Math.pow(Math.sin(t), 3);
          y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          points.push({ x: x / 18, y: y / 18 });
        }
        break;

      case 'treble':
        for (i = 0; i < numPoints; i++) {
          t = (i / numPoints) * 2 * Math.PI;
          x = 0.35 * Math.sin(t) + 0.12 * Math.sin(2*t) - 0.08 * Math.cos(3*t)
            + 0.18 * Math.sin(3*t) + 0.06 * Math.cos(5*t) - 0.04 * Math.sin(6*t);
          y = -0.55 * Math.cos(t) + 0.2 * Math.cos(2*t) + 0.12 * Math.sin(3*t)
            - 0.08 * Math.cos(4*t) + 0.06 * Math.sin(5*t) - 0.03 * Math.cos(6*t)
            + 0.04 * Math.sin(7*t);
          var hook = 0.12 * Math.sin(4*t) * Math.exp(-0.4 * Math.abs(t - Math.PI));
          points.push({ x: x + hook * 0.4, y: y + hook * 0.8 });
        }
        break;

      case 'infinity':
        for (i = 0; i < numPoints; i++) {
          t = (i / numPoints) * 2 * Math.PI;
          var denom = 1 + Math.sin(t) * Math.sin(t);
          x = Math.cos(t) / denom;
          y = Math.sin(t) * Math.cos(t) / denom;
          points.push({ x: x * 0.95, y: y * 0.95 });
        }
        break;

      case 'pi':
        n = numPoints;
        for (i = 0; i < n; i++) {
          t = i / n;
          if (t < 0.12) {
            s = t / 0.12;
            x = -0.38; y = 0.55 - s * 0.95;
          } else if (t < 0.18) {
            s = (t - 0.12) / 0.06;
            x = -0.38 + s * 0.08; y = -0.40 - 0.06 * Math.sin(s * Math.PI);
          } else if (t < 0.52) {
            s = (t - 0.18) / 0.34;
            x = -0.30 + s * 0.65; y = -0.46 + 0.04 * Math.sin(s * Math.PI);
          } else if (t < 0.58) {
            s = (t - 0.52) / 0.06;
            x = 0.35 - s * 0.05; y = -0.46 + s * 0.06;
          } else if (t < 0.72) {
            s = (t - 0.58) / 0.14;
            x = 0.30; y = -0.40 + s * 0.95;
          } else if (t < 0.80) {
            s = (t - 0.72) / 0.08;
            x = 0.30 + 0.06 * Math.sin(s * Math.PI); y = 0.55 + 0.04 * Math.sin(s * Math.PI);
          } else {
            s = (t - 0.80) / 0.20;
            x = 0.30 * (1 - s) + (-0.38) * s; y = 0.55 + 0.03 * Math.sin(s * Math.PI);
          }
          points.push({ x: x, y: y });
        }
        break;

      case 'note':
        // Musical eighth note
        n = numPoints;
        for (i = 0; i < n; i++) {
          t = i / n;
          if (t < 0.25) {
            // Note head (oval)
            s = t / 0.25;
            var a = s * 2 * Math.PI;
            x = -0.1 + 0.22 * Math.cos(a);
            y = 0.42 + 0.14 * Math.sin(a);
          } else if (t < 0.55) {
            // Stem going up
            s = (t - 0.25) / 0.30;
            x = 0.12;
            y = 0.42 - s * 1.05;
          } else if (t < 0.75) {
            // Flag curve 1
            s = (t - 0.55) / 0.20;
            x = 0.12 + 0.25 * Math.sin(s * Math.PI * 0.9);
            y = -0.63 + s * 0.40;
          } else if (t < 0.88) {
            // Flag curve 2
            s = (t - 0.75) / 0.13;
            x = 0.12 + 0.18 * Math.sin(s * Math.PI * 0.8);
            y = -0.23 + s * 0.35;
          } else {
            // Return to start
            s = (t - 0.88) / 0.12;
            x = 0.12 * (1 - s) + (-0.1 + 0.22) * s;
            y = 0.12 * (1 - s) + 0.42 * s;
          }
          points.push({ x: x * 0.85, y: y * 0.85 });
        }
        break;

      case 'butterfly':
        for (i = 0; i < numPoints; i++) {
          t = (i / numPoints) * 12 * Math.PI;
          // Butterfly curve (parametric)
          var expTerm = Math.exp(Math.cos(t));
          var cos4 = Math.cos(4 * t);
          var sin5 = Math.pow(Math.sin(t / 12), 5);
          r = expTerm - 2 * Math.cos(4 * t) + sin5;
          x = Math.sin(t) * r;
          y = -Math.cos(t) * r;
          points.push({ x: x * 0.16, y: y * 0.16 });
        }
        break;

      case 'cat':
        // Cat face silhouette
        n = numPoints;
        for (i = 0; i < n; i++) {
          t = i / n;
          if (t < 0.06) {
            // Left ear outer
            s = t / 0.06;
            x = -0.55 + s * 0.18;
            y = 0.0 - s * 0.65;
          } else if (t < 0.12) {
            // Left ear tip to inner
            s = (t - 0.06) / 0.06;
            x = -0.37 + s * 0.15;
            y = -0.65 + s * 0.50;
          } else if (t < 0.22) {
            // Head top curve
            s = (t - 0.12) / 0.10;
            var ta = Math.PI + s * Math.PI;
            x = s * 0.44 - 0.22;
            y = -0.22 + 0.08 * Math.sin(s * Math.PI);
          } else if (t < 0.28) {
            // Right ear inner
            s = (t - 0.22) / 0.06;
            x = 0.22 + s * 0.15;
            y = -0.15 - s * 0.50;
          } else if (t < 0.34) {
            // Right ear tip to outer
            s = (t - 0.28) / 0.06;
            x = 0.37 + s * 0.18;
            y = -0.65 + s * 0.65;
          } else if (t < 0.55) {
            // Right cheek
            s = (t - 0.34) / 0.21;
            var ca = -Math.PI * 0.3 + s * Math.PI * 0.8;
            x = 0.15 + 0.45 * Math.cos(ca);
            y = 0.15 + 0.42 * Math.sin(ca);
          } else if (t < 0.60) {
            // Chin right
            s = (t - 0.55) / 0.05;
            x = 0.25 * (1 - s);
            y = 0.55 + 0.03 * Math.sin(s * Math.PI);
          } else if (t < 0.65) {
            // Chin left
            s = (t - 0.60) / 0.05;
            x = -s * 0.25;
            y = 0.55 + 0.03 * Math.sin(s * Math.PI);
          } else {
            // Left cheek
            s = (t - 0.65) / 0.35;
            var ca2 = Math.PI * 0.5 + s * Math.PI * 0.8;
            x = -0.15 - 0.45 * Math.cos(ca2);
            y = 0.15 + 0.42 * Math.sin(ca2);
          }
          points.push({ x: x * 0.8, y: y * 0.8 });
        }
        break;
    }

    return points;
  }

  // --- Compute separate X and Y Fourier coefficients for split view ---
  function computeEpicycles(shapeName) {
    var points;
    if (shapeName === 'draw' && userPoints.length > 10) {
      points = resamplePoints(userPoints, 256);
    } else if (shapeName === 'draw') {
      return;
    } else {
      points = generateShape(shapeName, 256);
    }

    // Store ghost overlay points
    ghostPoints = [];
    for (var i = 0; i < points.length; i++) {
      ghostPoints.push({ x: points[i].x, y: points[i].y });
    }

    // Separate X and Y channels
    var xVals = [];
    var yVals = [];
    for (var j = 0; j < points.length; j++) {
      xVals.push(points[j].x);
      yVals.push(points[j].y);
    }

    fourierX = dft(xVals);
    fourierY = dft(yVals);

    time = 0;
    path = [];
    particles = [];
  }

  // --- Resample arbitrary user-drawn points to fixed count ---
  function resamplePoints(pts, count) {
    if (pts.length < 2) return pts;

    // Compute total arc length
    var lengths = [0];
    for (var i = 1; i < pts.length; i++) {
      var dx = pts[i].x - pts[i-1].x;
      var dy = pts[i].y - pts[i-1].y;
      lengths.push(lengths[i-1] + Math.sqrt(dx*dx + dy*dy));
    }
    var totalLen = lengths[pts.length - 1];
    if (totalLen < 1e-6) return pts;

    var resampled = [];
    for (var k = 0; k < count; k++) {
      var targetDist = (k / count) * totalLen;
      // Find segment
      var seg = 0;
      for (var m = 1; m < lengths.length; m++) {
        if (lengths[m] >= targetDist) { seg = m - 1; break; }
      }
      var segLen = lengths[seg+1] - lengths[seg];
      var frac = segLen > 0 ? (targetDist - lengths[seg]) / segLen : 0;
      resampled.push({
        x: pts[seg].x + frac * (pts[seg+1].x - pts[seg].x),
        y: pts[seg].y + frac * (pts[seg+1].y - pts[seg].y)
      });
    }
    return resampled;
  }

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    scaleF = Math.min(W, H) * 0.22;
  }

  // --- Epicycle chain drawing, returns tip position ---
  function drawEpicycleChain(fourier, cx, cy, rotation, count, drawCircles) {
    var x = cx;
    var y = cy;
    var N = fourier.length;
    var c = Math.min(count, N);
    var dt = (2 * Math.PI) / N;

    for (var i = 0; i < c; i++) {
      var prevX = x;
      var prevY = y;
      var freq = fourier[i].freq;
      var radius = fourier[i].amp * scaleF;
      var phase = fourier[i].phase;
      var angle = freq * time + phase + rotation;

      x += radius * Math.cos(angle);
      y += radius * Math.sin(angle);

      if (radius < 0.3) continue;

      if (drawCircles) {
        // Circle with transparency based on index
        var alphaC = Math.max(0.02, 0.22 - i * 0.004);

        // Phase-based hue coloring
        var phaseHue = ((phase + Math.PI) / (2 * Math.PI)) * 360;
        ctx.beginPath();
        ctx.arc(prevX, prevY, radius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'hsla(' + phaseHue + ', 70%, 60%, ' + alphaC + ')';
        ctx.lineWidth = 0.7;
        ctx.stroke();

        // Glow for large circles
        if (i < 5 && radius > 4) {
          ctx.beginPath();
          ctx.arc(prevX, prevY, radius, 0, 2 * Math.PI);
          ctx.strokeStyle = 'hsla(' + phaseHue + ', 70%, 60%, ' + (alphaC * 0.2) + ')';
          ctx.lineWidth = 4;
          ctx.stroke();
        }

        // Glowing connection line
        var alphaR = Math.max(0.03, 0.35 - i * 0.006);
        ctx.beginPath();
        ctx.moveTo(prevX, prevY);
        ctx.lineTo(x, y);
        // Main line
        ctx.strokeStyle = 'rgba(140, 200, 255, ' + alphaR + ')';
        ctx.lineWidth = 0.6;
        ctx.stroke();
        // Glow pass
        ctx.beginPath();
        ctx.moveTo(prevX, prevY);
        ctx.lineTo(x, y);
        ctx.strokeStyle = 'rgba(100, 180, 255, ' + (alphaR * 0.25) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Joint dot
        if (i < 15) {
          ctx.beginPath();
          ctx.arc(x, y, 1.2, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(140, 210, 255, ' + Math.max(0.1, 0.4 - i * 0.025) + ')';
          ctx.fill();
        }
      }
    }
    return { x: x, y: y };
  }

  // --- Particle system ---
  function spawnParticles(px, py) {
    for (var p = 0; p < 2; p++) {
      var angle = Math.random() * 2 * Math.PI;
      var speed = 0.3 + Math.random() * 1.2;
      particles.push({
        x: px, y: py,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1.0,
        decay: 0.008 + Math.random() * 0.015,
        size: 1 + Math.random() * 2,
        hue: (globalTime * 50 + Math.random() * 60) % 360
      });
    }
  }

  function updateAndDrawParticles() {
    for (var i = particles.length - 1; i >= 0; i--) {
      var p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.02; // slight gravity
      p.life -= p.decay;
      if (p.life <= 0) {
        particles.splice(i, 1);
        continue;
      }
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, 2 * Math.PI);
      ctx.fillStyle = 'hsla(' + p.hue + ', 80%, 70%, ' + (p.life * 0.6) + ')';
      ctx.fill();
    }
    // Cap particle count
    if (particles.length > 500) {
      particles.splice(0, particles.length - 500);
    }
  }

  // --- Draw frequency spectrum ---
  function drawSpectrum() {
    var specH = 45;
    var specY = H - specH - 5;
    var combined = fourierX.concat(fourierY);
    combined.sort(function(a, b) { return a.freq - b.freq; });

    // Deduplicate by freq, take max amplitude
    var freqMap = {};
    for (var i = 0; i < combined.length; i++) {
      var f = combined[i].freq;
      if (!freqMap[f] || combined[i].amp > freqMap[f]) {
        freqMap[f] = combined[i].amp;
      }
    }
    var freqs = Object.keys(freqMap).sort(function(a,b) { return +a - +b; });
    var maxAmp = 0;
    for (var j = 0; j < freqs.length; j++) {
      if (freqMap[freqs[j]] > maxAmp) maxAmp = freqMap[freqs[j]];
    }
    if (maxAmp < 1e-6) return;

    var barCount = Math.min(freqs.length, Math.floor(W * 0.6));
    var totalBarW = W * 0.6;
    var barW = totalBarW / barCount;
    var startX = W * 0.2;

    ctx.globalAlpha = 0.5;
    for (var k = 0; k < barCount; k++) {
      var amp = freqMap[freqs[k]] || 0;
      var barH = (amp / maxAmp) * specH;
      var hue = (k / barCount) * 270;
      ctx.fillStyle = 'hsla(' + hue + ', 80%, 55%, 0.7)';
      ctx.fillRect(startX + k * barW, specY + specH - barH, Math.max(barW - 1, 1), barH);
    }
    ctx.globalAlpha = 1.0;

    // Label
    ctx.font = '9px Courier New';
    ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.fillText('FREQUENCY SPECTRUM', startX, specY - 3);
  }

  // --- Ghost overlay of target shape ---
  function drawGhost(cx, cy) {
    if (ghostPoints.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(cx + ghostPoints[0].x * scaleF, cy + ghostPoints[0].y * scaleF);
    for (var i = 1; i < ghostPoints.length; i++) {
      ctx.lineTo(cx + ghostPoints[i].x * scaleF, cy + ghostPoints[i].y * scaleF);
    }
    ctx.closePath();
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.07)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // --- Rainbow HSL from time ---
  function rainbowHue(t) {
    return (t * 120) % 360;
  }

  // --- Main drawing ---
  function drawFrame() {
    globalTime += 0.016;

    // Dark background
    ctx.fillStyle = 'rgba(8, 12, 28, 1)';
    ctx.fillRect(0, 0, W, H);

    // Subtle grid
    ctx.strokeStyle = 'rgba(60, 100, 140, 0.03)';
    ctx.lineWidth = 0.5;
    var gridSize = 40;
    for (var gx = 0; gx < W; gx += gridSize) {
      ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, H); ctx.stroke();
    }
    for (var gy = 0; gy < H; gy += gridSize) {
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(W, gy); ctx.stroke();
    }

    if (drawMode && fourierX.length === 0) {
      // Draw user input points
      if (userPoints.length > 1) {
        ctx.beginPath();
        ctx.moveTo(userPoints[0].sx, userPoints[0].sy);
        for (var u = 1; u < userPoints.length; u++) {
          ctx.lineTo(userPoints[u].sx, userPoints[u].sy);
        }
        ctx.strokeStyle = 'rgba(255, 200, 140, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      return;
    }

    if (fourierX.length === 0 || fourierY.length === 0) return;

    var N = fourierX.length;
    var count = Math.min(numEpicycles, N);

    // Layout for split view:
    // X epicycles run horizontally at top, feeding Y coord
    // Y epicycles run vertically on left, feeding X coord
    // Drawing area is bottom-right
    var margin = 60;
    var drawCX = W * 0.55;
    var drawCY = H * 0.55;
    var xChainCX = drawCX;
    var xChainCY = margin + 30;
    var yChainCX = margin + 30;
    var yChainCY = drawCY;

    // Draw ghost overlay of target shape
    drawGhost(drawCX, drawCY);

    // Draw X-component epicycle chain (horizontal, at top)
    var tipX = drawEpicycleChain(fourierX, xChainCX, xChainCY, 0, count, true);

    // Draw Y-component epicycle chain (vertical, on left) - rotated by PI/2
    var tipY = drawEpicycleChain(fourierY, yChainCX, yChainCY, Math.PI / 2, count, true);

    // The drawing point is (tipX.x, tipY.y)
    var drawX = tipX.x;
    var drawY = tipY.y;

    // Draw dashed guide lines from tips to drawing point
    ctx.setLineDash([4, 6]);
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.12)';
    ctx.lineWidth = 0.8;

    ctx.beginPath();
    ctx.moveTo(tipX.x, tipX.y);
    ctx.lineTo(drawX, drawY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(tipY.x, tipY.y);
    ctx.lineTo(drawX, drawY);
    ctx.stroke();

    ctx.setLineDash([]);

    // Add current point to path
    path.unshift({ x: drawX, y: drawY, t: globalTime });

    // Limit path length
    var maxLen = N + 10;
    if (path.length > maxLen) path.length = maxLen;

    // Draw rainbow trail
    if (path.length > 1) {
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      for (var j = 0; j < path.length - 1; j++) {
        var alpha = Math.max(0, 1 - j / path.length);
        // Rainbow based on time at point
        var hue = rainbowHue(path[j].t);
        var lightness = 68 - (j / path.length) * 15;
        ctx.beginPath();
        ctx.moveTo(path[j].x, path[j].y);
        ctx.lineTo(path[j+1].x, path[j+1].y);
        ctx.strokeStyle = 'hsla(' + hue + ', 90%, ' + lightness + '%, ' + (alpha * 0.9) + ')';
        ctx.lineWidth = 2.5 * alpha + 0.4;
        ctx.stroke();
      }

      // Bloom/glow pass
      var glowLen = Math.min(60, path.length - 1);
      for (var g = 0; g < glowLen; g++) {
        var ga = 1 - g / glowLen;
        var glowHue = rainbowHue(path[g].t);
        ctx.beginPath();
        ctx.moveTo(path[g].x, path[g].y);
        ctx.lineTo(path[g+1].x, path[g+1].y);
        ctx.strokeStyle = 'hsla(' + glowHue + ', 80%, 65%, ' + (ga * 0.1) + ')';
        ctx.lineWidth = 8 * ga;
        ctx.stroke();
      }
    }

    // Drawing tip glow
    ctx.beginPath();
    ctx.arc(drawX, drawY, 4, 0, 2 * Math.PI);
    ctx.fillStyle = 'rgba(220, 250, 255, 0.95)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(drawX, drawY, 14, 0, 2 * Math.PI);
    var tipGrad = ctx.createRadialGradient(drawX, drawY, 2, drawX, drawY, 14);
    tipGrad.addColorStop(0, 'rgba(120, 220, 255, 0.35)');
    tipGrad.addColorStop(1, 'rgba(120, 220, 255, 0)');
    ctx.fillStyle = tipGrad;
    ctx.fill();

    // Spawn and draw particles
    spawnParticles(drawX, drawY);
    updateAndDrawParticles();

    // Draw frequency spectrum
    drawSpectrum();

    // Advance time
    var dt = (2 * Math.PI) / N;
    time += dt * speedMult;

    // Loop after one full cycle
    if (time >= 2 * Math.PI) {
      time -= 2 * Math.PI;
      path = [];
    }
  }

  function animate() {
    if (!paused) {
      drawFrame();
    }
    requestAnimationFrame(animate);
  }

  // --- Controls ---
  var epicycleSlider = document.getElementById('epicycleSlider');
  var epicycleValue = document.getElementById('epicycleValue');
  var speedSlider = document.getElementById('speedSlider');
  var speedValue = document.getElementById('speedValue');
  var drawHint = document.getElementById('drawHint');

  epicycleSlider.addEventListener('input', function() {
    numEpicycles = parseInt(this.value);
    epicycleValue.textContent = numEpicycles;
  });

  speedSlider.addEventListener('input', function() {
    var v = parseInt(this.value);
    speedMult = v / 10;
    speedValue.textContent = speedMult.toFixed(1) + 'x';
  });

  // Shape buttons
  var shapeButtons = document.querySelectorAll('.shape-btn');
  for (var b = 0; b < shapeButtons.length; b++) {
    shapeButtons[b].addEventListener('click', function() {
      for (var bb = 0; bb < shapeButtons.length; bb++) {
        shapeButtons[bb].classList.remove('active');
      }
      this.classList.add('active');
      currentShape = this.dataset.shape;

      if (currentShape === 'draw') {
        drawMode = true;
        userPoints = [];
        fourierX = [];
        fourierY = [];
        path = [];
        particles = [];
        ghostPoints = [];
        drawHint.style.opacity = '1';
      } else {
        drawMode = false;
        drawHint.style.opacity = '0';
        computeEpicycles(currentShape);
        epicycleSlider.max = fourierX.length;
        if (numEpicycles > fourierX.length) {
          numEpicycles = fourierX.length;
          epicycleSlider.value = numEpicycles;
          epicycleValue.textContent = numEpicycles;
        }
      }
    });
  }

  // --- Drawing mode mouse/touch handlers ---
  function screenToNorm(sx, sy) {
    var drawCX = W * 0.55;
    var drawCY = H * 0.55;
    return {
      x: (sx - drawCX) / scaleF,
      y: (sy - drawCY) / scaleF,
      sx: sx,
      sy: sy
    };
  }

  canvas.addEventListener('mousedown', function(e) {
    if (!drawMode) return;
    isDrawing = true;
    userPoints = [];
    fourierX = [];
    fourierY = [];
    path = [];
    particles = [];
    ghostPoints = [];
    drawHint.style.opacity = '0';
    var pt = screenToNorm(e.clientX, e.clientY);
    userPoints.push(pt);
  });

  canvas.addEventListener('mousemove', function(e) {
    if (!drawMode || !isDrawing) return;
    var pt = screenToNorm(e.clientX, e.clientY);
    userPoints.push(pt);
  });

  canvas.addEventListener('mouseup', function() {
    if (!drawMode || !isDrawing) return;
    isDrawing = false;
    if (userPoints.length > 10) {
      computeEpicycles('draw');
      epicycleSlider.max = fourierX.length;
      if (numEpicycles > fourierX.length) {
        numEpicycles = fourierX.length;
        epicycleSlider.value = numEpicycles;
        epicycleValue.textContent = numEpicycles;
      }
    }
  });

  // Touch support for drawing
  canvas.addEventListener('touchstart', function(e) {
    if (!drawMode) return;
    e.preventDefault();
    isDrawing = true;
    userPoints = [];
    fourierX = [];
    fourierY = [];
    path = [];
    particles = [];
    ghostPoints = [];
    drawHint.style.opacity = '0';
    var touch = e.touches[0];
    var pt = screenToNorm(touch.clientX, touch.clientY);
    userPoints.push(pt);
  }, { passive: false });

  canvas.addEventListener('touchmove', function(e) {
    if (!drawMode || !isDrawing) return;
    e.preventDefault();
    var touch = e.touches[0];
    var pt = screenToNorm(touch.clientX, touch.clientY);
    userPoints.push(pt);
  }, { passive: false });

  canvas.addEventListener('touchend', function() {
    if (!drawMode || !isDrawing) return;
    isDrawing = false;
    if (userPoints.length > 10) {
      computeEpicycles('draw');
      epicycleSlider.max = fourierX.length;
      if (numEpicycles > fourierX.length) {
        numEpicycles = fourierX.length;
        epicycleSlider.value = numEpicycles;
        epicycleValue.textContent = numEpicycles;
      }
    }
  });

  // Pause/resume
  window.addEventListener('keydown', function(e) {
    if (e.code === 'Space') {
      e.preventDefault();
      paused = !paused;
    }
  });

  // Expose reset
  window.reset = function() {
    time = 0;
    path = [];
    paused = false;
    numEpicycles = 80;
    speedMult = 1.0;
    drawMode = false;
    userPoints = [];
    particles = [];
    epicycleSlider.value = 80;
    epicycleValue.textContent = '80';
    speedSlider.value = 10;
    speedValue.textContent = '1.0x';
    drawHint.style.opacity = '0';
    currentShape = 'star';
    for (var bb = 0; bb < shapeButtons.length; bb++) {
      shapeButtons[bb].classList.remove('active');
    }
    shapeButtons[0].classList.add('active');
    computeEpicycles(currentShape);
  };

  // Resize handler
  var resizeTimer;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() {
      resize();
      time = 0;
      path = [];
      particles = [];
    }, 150);
  });

  // Initialize
  resize();
  generateGrain();
  computeEpicycles(currentShape);
  epicycleSlider.max = fourierX.length;
  animate();

})();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
