<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molecular Dance - Chemical Bond Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #060a14;
            overflow: hidden;
            font-family: monospace;
        }
        canvas { display: block; }
        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }

        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            z-index: 5;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 6;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.04) 2px,
                rgba(0,0,0,0.04) 4px
            );
        }

        .film-grain {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 7;
            opacity: 0.06;
            mix-blend-mode: overlay;
        }

        .controls {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 10;
            background: rgba(10, 15, 30, 0.7);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.15);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        .controls label {
            font-family: monospace;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }
        .controls .val {
            color: rgba(100, 200, 255, 0.8);
            font-size: 0.6rem;
        }
        .controls button {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
            color: rgba(100, 200, 255, 0.7);
            font-family: monospace;
            font-size: 0.6rem;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .controls button:hover {
            background: rgba(100, 200, 255, 0.2);
            color: rgba(100, 200, 255, 1);
        }
        .controls button.active {
            background: rgba(100, 200, 255, 0.25);
            border-color: rgba(100, 200, 255, 0.5);
            color: rgba(100, 200, 255, 1);
        }
        input[type="range"] {
            width: 80px;
            accent-color: #64c8ff;
        }

        .info {
            position: fixed;
            top: 1rem;
            right: 1rem;
            font-family: monospace;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.4);
            z-index: 20;
            text-align: right;
            line-height: 1.6;
        }

        .title-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 1.4rem;
            color: rgba(100, 200, 255, 0.06);
            letter-spacing: 0.5em;
            text-transform: uppercase;
            z-index: 1;
            pointer-events: none;
            white-space: nowrap;
        }

        .energy-graph {
            position: fixed;
            bottom: 5.5rem;
            right: 1rem;
            width: 200px;
            height: 100px;
            z-index: 10;
            pointer-events: none;
        }

        .hover-formula {
            position: fixed;
            pointer-events: none;
            font-family: monospace;
            font-size: 0.8rem;
            color: rgba(200, 230, 255, 0.9);
            background: rgba(10, 15, 30, 0.8);
            backdrop-filter: blur(8px);
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            border: 1px solid rgba(100, 200, 255, 0.25);
            z-index: 25;
            display: none;
            white-space: nowrap;
        }

        .preset-panel {
            position: fixed;
            top: 3.5rem;
            left: 1rem;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        .preset-panel button {
            background: rgba(10, 15, 30, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.15);
            color: rgba(100, 200, 255, 0.6);
            font-family: monospace;
            font-size: 0.6rem;
            padding: 0.3rem 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }
        .preset-panel button:hover {
            background: rgba(100, 200, 255, 0.15);
            color: rgba(100, 200, 255, 1);
        }

        .reaction-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 1rem;
            color: rgba(255, 200, 100, 0.9);
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 10px rgba(255, 200, 100, 0.5);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>
    <div class="vignette"></div>
    <div class="scanlines"></div>
    <canvas id="grain" class="film-grain"></canvas>
    <div class="title-overlay">Molecular Dynamics</div>
    <canvas id="canvas"></canvas>
    <canvas id="energyCanvas" class="energy-graph"></canvas>
    <div id="hoverFormula" class="hover-formula"></div>
    <div id="reactionFlash" class="reaction-flash"></div>

    <div class="preset-panel" id="presetPanel">
        <button onclick="spawnPreset('water')">H2O Water</button>
        <button onclick="spawnPreset('methane')">CH4 Methane</button>
        <button onclick="spawnPreset('benzene')">C6H6 Benzene</button>
        <button onclick="spawnPreset('ethanol')">C2H5OH Ethanol</button>
        <button onclick="spawnPreset('caffeine')">Caffeine</button>
    </div>

    <div class="controls">
        <label>Temperature
            <input type="range" id="tempSlider" min="0" max="100" value="40">
            <span class="val" id="tempVal">300 K</span>
        </label>
        <label>Pressure
            <input type="range" id="pressureSlider" min="20" max="100" value="100">
            <span class="val" id="pressureVal">1.0 atm</span>
        </label>
        <label style="gap:0.3rem">
            <button id="gravityBtn" onclick="toggleGravity()">Gravity: OFF</button>
        </label>
        <label style="gap:0.3rem">
            <button id="vdwBtn" onclick="toggleVDW()">VdW Radii: OFF</button>
        </label>
        <label style="gap:0.3rem">
            <button id="heatmapBtn" onclick="toggleHeatmap()">Heatmap: OFF</button>
        </label>
        <label style="gap:0.3rem">
            <button id="electronsBtn" onclick="toggleElectrons()">Orbitals: OFF</button>
        </label>
    </div>

    <div class="info">
        <div id="atomCount">Atoms: 0</div>
        <div id="bondCount">Bonds: 0</div>
        <div id="moleculeCount">Molecules: 0</div>
        <div id="elementBreakdown" style="margin-top:0.2rem;font-size:0.55rem;color:rgba(100,200,255,0.3)"></div>
        <div id="phaseState" style="margin-top:0.2rem;font-size:0.6rem;color:rgba(100,200,255,0.5)">Phase: Gas</div>
        <div style="margin-top:0.3rem; font-size:0.55rem; color:rgba(100,200,255,0.2);">Click to add atoms</div>
    </div>

    <script>
    (function() {
        'use strict';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const energyCanvas = document.getElementById('energyCanvas');
        const ectx = energyCanvas.getContext('2d');
        const grainCanvas = document.getElementById('grain');
        const gctx = grainCanvas.getContext('2d');
        const tempSlider = document.getElementById('tempSlider');
        const pressureSlider = document.getElementById('pressureSlider');
        const tempValEl = document.getElementById('tempVal');
        const pressureValEl = document.getElementById('pressureVal');
        const atomCountEl = document.getElementById('atomCount');
        const bondCountEl = document.getElementById('bondCount');
        const moleculeCountEl = document.getElementById('moleculeCount');
        const elementBreakdownEl = document.getElementById('elementBreakdown');
        const phaseStateEl = document.getElementById('phaseState');
        const hoverFormula = document.getElementById('hoverFormula');
        const reactionFlash = document.getElementById('reactionFlash');

        let W, H;
        let atoms = [];
        let brownianParticles = [];
        let paused = false;
        let animId = null;
        let showGravity = false;
        let showVDW = false;
        let showHeatmap = false;
        let showElectrons = false;
        let frameCount = 0;
        let mouseX = -1, mouseY = -1;
        let hoveredMolecule = null;

        // Energy history for graph
        const energyHistory = { kinetic: [], potential: [], length: 150 };

        // Element definitions: name, color, radius, mass, maxBonds, vdwRadius
        const ELEMENTS = [
            { name: 'O',  color: [220, 60, 60],   radius: 14, mass: 16, maxBonds: 2, vdwRadius: 28 },
            { name: 'N',  color: [60, 100, 220],  radius: 13, mass: 14, maxBonds: 3, vdwRadius: 27 },
            { name: 'C',  color: [140, 140, 140], radius: 13, mass: 12, maxBonds: 4, vdwRadius: 30 },
            { name: 'H',  color: [230, 230, 240], radius: 8,  mass: 1,  maxBonds: 1, vdwRadius: 22 },
            { name: 'S',  color: [220, 200, 50],  radius: 15, mass: 32, maxBonds: 2, vdwRadius: 32 },
            { name: 'P',  color: [180, 100, 220], radius: 14, mass: 31, maxBonds: 3, vdwRadius: 30 },
        ];
        const EL_IDX = { O: 0, N: 1, C: 2, H: 3, S: 4, P: 5 };

        // Weights for random selection
        const ELEMENT_WEIGHTS = [3, 3, 4, 6, 1, 1];
        const TOTAL_WEIGHT = ELEMENT_WEIGHTS.reduce((a, b) => a + b, 0);

        function pickElement() {
            let r = Math.random() * TOTAL_WEIGHT;
            for (let i = 0; i < ELEMENTS.length; i++) {
                r -= ELEMENT_WEIGHTS[i];
                if (r <= 0) return i;
            }
            return 0;
        }

        // Bond type: 1=single, 2=double, 3=triple
        // Bond lookup for determining type between two elements
        function getBondType(a, b) {
            const nameA = ELEMENTS[a.elIdx].name;
            const nameB = ELEMENTS[b.elIdx].name;
            const pair = [nameA, nameB].sort().join('');
            // Some default double/triple bonds
            if (pair === 'OO') return 2;
            if (pair === 'CC' && a.bonds.length <= 2 && b.bonds.length <= 2) return Math.random() < 0.3 ? 2 : 1;
            if (pair === 'CO' && a.bonds.length <= 1 && b.bonds.length <= 1) return 2;
            if (pair === 'NN') return Math.random() < 0.2 ? 3 : (Math.random() < 0.5 ? 2 : 1);
            return 1;
        }

        // Lennard-Jones parameters
        const LJ_EPSILON = 1.2;
        const BOND_THRESHOLD = 45;
        const BOND_BREAK = 65;
        const DAMPING = 0.997;
        const DT = 0.4;
        const GRAVITY_STRENGTH = 0.02;

        function getTemperature() {
            return 100 + (tempSlider.value / 100) * 900;
        }

        function getThermalVelocity() {
            return 0.3 + (tempSlider.value / 100) * 2.5;
        }

        function getPressureFactor() {
            return pressureSlider.value / 100;
        }

        function getBounds() {
            const pf = getPressureFactor();
            const marginX = W * (1 - pf) * 0.4;
            const marginY = H * (1 - pf) * 0.4;
            return { x: marginX, y: marginY, w: W - marginX * 2, h: H - marginY * 2 };
        }

        function createAtom(x, y, elIdx) {
            if (elIdx === undefined) elIdx = pickElement();
            const el = ELEMENTS[elIdx];
            const tv = getThermalVelocity();
            const angle = Math.random() * Math.PI * 2;
            const speed = (tv / Math.sqrt(el.mass)) * (0.5 + Math.random());
            return {
                x: x, y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                ax: 0, ay: 0,
                elIdx: elIdx,
                radius: el.radius,
                mass: el.mass,
                color: el.color,
                bonds: [],
                bondTypes: [], // parallel array: bond type for each bond
                vibPhase: Math.random() * Math.PI * 2,
                glow: 0,
                trail: [],
                moleculeId: -1,
                electronPhase: Math.random() * Math.PI * 2
            };
        }

        // Brownian background particles (tiny water molecules)
        function createBrownianParticle() {
            return {
                x: Math.random() * W,
                y: Math.random() * H,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: 1 + Math.random() * 1.5,
                alpha: 0.05 + Math.random() * 0.1
            };
        }

        function initBrownian(count) {
            brownianParticles = [];
            for (let i = 0; i < count; i++) {
                brownianParticles.push(createBrownianParticle());
            }
        }

        function initAtoms(count) {
            atoms = [];
            const bounds = getBounds();
            for (let i = 0; i < count; i++) {
                const x = bounds.x + 40 + Math.random() * (bounds.w - 80);
                const y = bounds.y + 40 + Math.random() * (bounds.h - 80);
                atoms.push(createAtom(x, y));
            }
        }

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            grainCanvas.width = W;
            grainCanvas.height = H;
            energyCanvas.width = 200;
            energyCanvas.height = 100;
        }

        // Lennard-Jones force
        function ljForce(r, sigma) {
            if (r < 5) r = 5;
            const sr = sigma / r;
            const sr6 = sr * sr * sr * sr * sr * sr;
            const sr12 = sr6 * sr6;
            return 24 * LJ_EPSILON * (2 * sr12 - sr6) / r;
        }

        function hasBond(a, b) {
            return a.bonds.indexOf(b) !== -1;
        }

        function addBond(a, b) {
            if (!hasBond(a, b)) {
                const btype = getBondType(a, b);
                a.bonds.push(b);
                a.bondTypes.push(btype);
                b.bonds.push(a);
                b.bondTypes.push(btype);
            }
        }

        function removeBond(a, b) {
            let idx = a.bonds.indexOf(b);
            if (idx !== -1) { a.bonds.splice(idx, 1); a.bondTypes.splice(idx, 1); }
            idx = b.bonds.indexOf(a);
            if (idx !== -1) { b.bonds.splice(idx, 1); b.bondTypes.splice(idx, 1); }
        }

        // Find connected molecules using flood fill
        function findMolecules() {
            const visited = new Set();
            const molecules = [];
            for (let i = 0; i < atoms.length; i++) {
                if (visited.has(i)) continue;
                const mol = [];
                const stack = [i];
                while (stack.length > 0) {
                    const idx = stack.pop();
                    if (visited.has(idx)) continue;
                    visited.add(idx);
                    mol.push(idx);
                    const a = atoms[idx];
                    for (let j = 0; j < a.bonds.length; j++) {
                        const bidx = atoms.indexOf(a.bonds[j]);
                        if (bidx !== -1 && !visited.has(bidx)) stack.push(bidx);
                    }
                }
                const molId = molecules.length;
                for (let j = 0; j < mol.length; j++) {
                    atoms[mol[j]].moleculeId = molId;
                }
                molecules.push(mol);
            }
            return molecules;
        }

        // Get chemical formula for a molecule (sorted by Hill system)
        function getFormula(molIndices) {
            const counts = {};
            for (let i = 0; i < molIndices.length; i++) {
                const name = ELEMENTS[atoms[molIndices[i]].elIdx].name;
                counts[name] = (counts[name] || 0) + 1;
            }
            // Hill system: C first, H second, then alphabetical
            const keys = Object.keys(counts);
            keys.sort((a, b) => {
                if (a === 'C') return -1;
                if (b === 'C') return 1;
                if (a === 'H') return -1;
                if (b === 'H') return 1;
                return a.localeCompare(b);
            });
            let formula = '';
            for (let i = 0; i < keys.length; i++) {
                formula += keys[i];
                if (counts[keys[i]] > 1) formula += counts[keys[i]];
            }

            // Common name lookup
            const known = {
                'H2O': 'Water', 'CH4': 'Methane', 'C2H6O': 'Ethanol',
                'CO2': 'Carbon Dioxide', 'C6H6': 'Benzene', 'NH3': 'Ammonia',
                'C8H10N4O2': 'Caffeine', 'H2': 'Hydrogen', 'O2': 'Oxygen',
                'N2': 'Nitrogen', 'H2S': 'Hydrogen Sulfide', 'NO': 'Nitric Oxide',
                'CH2O': 'Formaldehyde', 'C2H4': 'Ethylene', 'C2H2': 'Acetylene'
            };
            const common = known[formula];
            return common ? formula + ' (' + common + ')' : formula;
        }

        // Molecule presets
        const PRESETS = {
            water: function(cx, cy) {
                // H-O-H with 104.5 degree angle
                const o = createAtom(cx, cy, EL_IDX.O);
                const h1 = createAtom(cx - 20, cy - 15, EL_IDX.H);
                const h2 = createAtom(cx + 20, cy - 15, EL_IDX.H);
                atoms.push(o, h1, h2);
                addBond(o, h1);
                addBond(o, h2);
            },
            methane: function(cx, cy) {
                // CH4 tetrahedral
                const c = createAtom(cx, cy, EL_IDX.C);
                const h1 = createAtom(cx - 18, cy - 18, EL_IDX.H);
                const h2 = createAtom(cx + 18, cy - 18, EL_IDX.H);
                const h3 = createAtom(cx - 18, cy + 18, EL_IDX.H);
                const h4 = createAtom(cx + 18, cy + 18, EL_IDX.H);
                atoms.push(c, h1, h2, h3, h4);
                addBond(c, h1); addBond(c, h2); addBond(c, h3); addBond(c, h4);
            },
            benzene: function(cx, cy) {
                // C6H6 ring
                const carbons = [];
                const r = 30;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const c = createAtom(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r, EL_IDX.C);
                    carbons.push(c);
                    atoms.push(c);
                }
                for (let i = 0; i < 6; i++) {
                    const next = (i + 1) % 6;
                    addBond(carbons[i], carbons[next]);
                    // Alternating double bonds
                    if (i % 2 === 0) {
                        const bidx = carbons[i].bonds.indexOf(carbons[next]);
                        if (bidx !== -1) { carbons[i].bondTypes[bidx] = 2; }
                        const bidx2 = carbons[next].bonds.indexOf(carbons[i]);
                        if (bidx2 !== -1) { carbons[next].bondTypes[bidx2] = 2; }
                    }
                }
                // H atoms
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const h = createAtom(cx + Math.cos(angle) * (r + 18), cy + Math.sin(angle) * (r + 18), EL_IDX.H);
                    atoms.push(h);
                    addBond(carbons[i], h);
                }
            },
            ethanol: function(cx, cy) {
                // C2H5OH
                const c1 = createAtom(cx - 15, cy, EL_IDX.C);
                const c2 = createAtom(cx + 15, cy, EL_IDX.C);
                const o = createAtom(cx + 35, cy - 10, EL_IDX.O);
                const h_o = createAtom(cx + 48, cy - 20, EL_IDX.H);
                const h1 = createAtom(cx - 30, cy - 14, EL_IDX.H);
                const h2 = createAtom(cx - 30, cy + 14, EL_IDX.H);
                const h3 = createAtom(cx - 10, cy - 20, EL_IDX.H);
                const h4 = createAtom(cx + 10, cy + 18, EL_IDX.H);
                const h5 = createAtom(cx + 22, cy + 18, EL_IDX.H);
                atoms.push(c1, c2, o, h_o, h1, h2, h3, h4, h5);
                addBond(c1, c2); addBond(c2, o); addBond(o, h_o);
                addBond(c1, h1); addBond(c1, h2); addBond(c1, h3);
                addBond(c2, h4); addBond(c2, h5);
            },
            caffeine: function(cx, cy) {
                // Simplified caffeine C8H10N4O2 - fused ring structure
                const n1 = createAtom(cx - 25, cy - 15, EL_IDX.N);
                const c2 = createAtom(cx - 10, cy - 25, EL_IDX.C);
                const n3 = createAtom(cx + 10, cy - 20, EL_IDX.N);
                const c4 = createAtom(cx + 15, cy - 5, EL_IDX.C);
                const c5 = createAtom(cx, cy + 5, EL_IDX.C);
                const c6 = createAtom(cx - 20, cy, EL_IDX.C);
                const n7 = createAtom(cx + 25, cy + 10, EL_IDX.N);
                const c8 = createAtom(cx + 15, cy + 20, EL_IDX.C);
                const n9 = createAtom(cx, cy + 18, EL_IDX.N);
                const o1 = createAtom(cx - 35, cy + 8, EL_IDX.O);
                const o2 = createAtom(cx - 10, cy - 40, EL_IDX.O);
                atoms.push(n1, c2, n3, c4, c5, c6, n7, c8, n9, o1, o2);
                addBond(n1, c2); addBond(c2, n3); addBond(n3, c4);
                addBond(c4, c5); addBond(c5, c6); addBond(c6, n1);
                addBond(c4, n7); addBond(n7, c8); addBond(c8, n9); addBond(n9, c5);
                addBond(c6, o1); addBond(c2, o2);
                // Set some double bonds
                const setDouble = function(a, b) {
                    let i1 = a.bonds.indexOf(b);
                    let i2 = b.bonds.indexOf(a);
                    if (i1 !== -1) a.bondTypes[i1] = 2;
                    if (i2 !== -1) b.bondTypes[i2] = 2;
                };
                setDouble(c6, o1); setDouble(c2, o2); setDouble(c4, c5);
                // Methyl groups (simplified - a few H)
                const methylPositions = [
                    [n1, -35, -25], [n3, 20, -30], [n7, 40, 15]
                ];
                for (let i = 0; i < methylPositions.length; i++) {
                    const mp = methylPositions[i];
                    for (let j = 0; j < 3; j++) {
                        const angle = (j / 3) * Math.PI * 2;
                        const h = createAtom(cx + mp[1] + Math.cos(angle) * 10, cy + mp[2] + Math.sin(angle) * 10, EL_IDX.H);
                        atoms.push(h);
                        // Only add bond if under max
                        if (mp[0].bonds.length < ELEMENTS[mp[0].elIdx].maxBonds + 2) {
                            addBond(mp[0], h);
                        }
                    }
                }
                // One more H on c8
                const hc8 = createAtom(cx + 20, cy + 32, EL_IDX.H);
                atoms.push(hc8);
                addBond(c8, hc8);
            }
        };

        window.spawnPreset = function(name) {
            const bounds = getBounds();
            const cx = bounds.x + 80 + Math.random() * (bounds.w - 160);
            const cy = bounds.y + 80 + Math.random() * (bounds.h - 160);
            if (PRESETS[name]) PRESETS[name](cx, cy);
        };

        // Toggle functions
        window.toggleGravity = function() {
            showGravity = !showGravity;
            document.getElementById('gravityBtn').textContent = 'Gravity: ' + (showGravity ? 'ON' : 'OFF');
            document.getElementById('gravityBtn').classList.toggle('active', showGravity);
        };
        window.toggleVDW = function() {
            showVDW = !showVDW;
            document.getElementById('vdwBtn').textContent = 'VdW Radii: ' + (showVDW ? 'ON' : 'OFF');
            document.getElementById('vdwBtn').classList.toggle('active', showVDW);
        };
        window.toggleHeatmap = function() {
            showHeatmap = !showHeatmap;
            document.getElementById('heatmapBtn').textContent = 'Heatmap: ' + (showHeatmap ? 'ON' : 'OFF');
            document.getElementById('heatmapBtn').classList.toggle('active', showHeatmap);
        };
        window.toggleElectrons = function() {
            showElectrons = !showElectrons;
            document.getElementById('electronsBtn').textContent = 'Orbitals: ' + (showElectrons ? 'ON' : 'OFF');
            document.getElementById('electronsBtn').classList.toggle('active', showElectrons);
        };

        // Reaction events
        let reactionCooldown = 0;
        function tryReaction() {
            if (reactionCooldown > 0 || atoms.length < 4) { reactionCooldown--; return; }
            const temp = getTemperature();
            // Higher temp = more reactions
            if (Math.random() > 0.001 * (temp / 300)) return;

            // Find two bonded molecules close together
            const molecules = findMolecules();
            if (molecules.length < 2) return;

            // Pick two molecules that are close
            for (let tries = 0; tries < 5; tries++) {
                const mi = Math.floor(Math.random() * molecules.length);
                const mj = Math.floor(Math.random() * molecules.length);
                if (mi === mj) continue;

                const molA = molecules[mi];
                const molB = molecules[mj];
                if (molA.length < 2 || molB.length < 2) continue;

                // Check proximity
                let closest = Infinity;
                let aiClose = -1, bjClose = -1;
                for (let ai = 0; ai < molA.length; ai++) {
                    for (let bj = 0; bj < molB.length; bj++) {
                        const dx = atoms[molA[ai]].x - atoms[molB[bj]].x;
                        const dy = atoms[molA[ai]].y - atoms[molB[bj]].y;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d < closest) {
                            closest = d;
                            aiClose = molA[ai];
                            bjClose = molB[bj];
                        }
                    }
                }

                if (closest < 50) {
                    // Reaction: swap one bond from each
                    const a = atoms[aiClose];
                    const b = atoms[bjClose];
                    if (a.bonds.length > 0 && b.bonds.length > 0) {
                        // Remove a random bond from each, form new bond between them
                        const ab = a.bonds[Math.floor(Math.random() * a.bonds.length)];
                        removeBond(a, ab);
                        const bb = b.bonds[Math.floor(Math.random() * b.bonds.length)];
                        removeBond(b, bb);

                        // Form new bonds
                        if (a.bonds.length < ELEMENTS[a.elIdx].maxBonds &&
                            b.bonds.length < ELEMENTS[b.elIdx].maxBonds) {
                            addBond(a, b);
                        }
                        if (ab.bonds.length < ELEMENTS[ab.elIdx].maxBonds &&
                            bb.bonds.length < ELEMENTS[bb.elIdx].maxBonds) {
                            addBond(ab, bb);
                        }

                        // Flash effect
                        a.glow = 1.5; b.glow = 1.5; ab.glow = 1.2; bb.glow = 1.2;
                        showReactionFlash('Bond Rearrangement!');
                        reactionCooldown = 120;
                        return;
                    }
                }
            }
        }

        function showReactionFlash(text) {
            reactionFlash.textContent = text;
            reactionFlash.style.opacity = '1';
            setTimeout(function() { reactionFlash.style.opacity = '0'; }, 1500);
        }

        // Phase detection
        function detectPhase() {
            const temp = getTemperature();
            const pressure = getPressureFactor();
            // Simplified phase diagram
            if (temp > 600) return 'Gas';
            if (temp < 200 && pressure > 0.6) return 'Solid';
            if (temp < 400 && pressure > 0.5) return 'Liquid';
            return 'Gas';
        }

        function update() {
            const temp = getTemperature();
            const thermalKick = getThermalVelocity() * 0.008;
            const bounds = getBounds();
            const phase = detectPhase();
            let bondTotal = 0;
            let totalKE = 0;
            let totalPE = 0;

            // Phase-dependent damping
            let phaseDamping = DAMPING;
            if (phase === 'Liquid') phaseDamping = 0.990;
            if (phase === 'Solid') phaseDamping = 0.970;

            // Reset accelerations
            for (let i = 0; i < atoms.length; i++) {
                atoms[i].ax = 0;
                atoms[i].ay = 0;
            }

            // Pairwise interactions
            for (let i = 0; i < atoms.length; i++) {
                const a = atoms[i];
                for (let j = i + 1; j < atoms.length; j++) {
                    const b = atoms[j];
                    let dx = b.x - a.x;
                    let dy = b.y - a.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 1) continue;

                    const nx = dx / dist;
                    const ny = dy / dist;
                    const sigma = (a.radius + b.radius) * 1.1;

                    // Lennard-Jones
                    if (dist < sigma * 3) {
                        const sr = sigma / (dist < 5 ? 5 : dist);
                        const sr6 = sr * sr * sr * sr * sr * sr;
                        const sr12 = sr6 * sr6;
                        const force = 24 * LJ_EPSILON * (2 * sr12 - sr6) / (dist < 5 ? 5 : dist);
                        const fx = force * nx;
                        const fy = force * ny;
                        a.ax += fx / a.mass;
                        a.ay += fy / a.mass;
                        b.ax -= fx / b.mass;
                        b.ay -= fy / b.mass;

                        // Potential energy
                        totalPE += 4 * LJ_EPSILON * (sr12 - sr6);
                    }

                    // Solid phase: extra attraction to form lattice
                    if (phase === 'Solid' && dist < sigma * 2.5 && dist > sigma) {
                        const latticeForce = 0.005;
                        a.ax += latticeForce * nx / a.mass;
                        a.ay += latticeForce * ny / a.mass;
                        b.ax -= latticeForce * nx / b.mass;
                        b.ay -= latticeForce * ny / b.mass;
                    }

                    // Bond formation / breaking
                    const bonded = hasBond(a, b);
                    if (bonded) {
                        if (dist > BOND_BREAK) {
                            removeBond(a, b);
                            a.glow = 1.0;
                            b.glow = 1.0;
                        } else {
                            const restLen = (a.radius + b.radius) * 1.3;
                            const stretch = dist - restLen;
                            const springK = 0.03;
                            const sf = springK * stretch;
                            a.ax += sf * nx / a.mass;
                            a.ay += sf * ny / a.mass;
                            b.ax -= sf * nx / b.mass;
                            b.ay -= sf * ny / b.mass;
                            totalPE += 0.5 * springK * stretch * stretch;
                        }
                    } else {
                        const maxBondsA = ELEMENTS[a.elIdx].maxBonds;
                        const maxBondsB = ELEMENTS[b.elIdx].maxBonds;
                        if (dist < BOND_THRESHOLD &&
                            a.bonds.length < maxBondsA &&
                            b.bonds.length < maxBondsB) {
                            const bondProb = 0.02 * (1 - tempSlider.value / 150);
                            if (Math.random() < bondProb) {
                                addBond(a, b);
                                a.glow = 1.0;
                                b.glow = 1.0;
                            }
                        }
                    }
                }
            }

            // Integrate velocities and positions
            const elementCounts = {};
            for (let i = 0; i < atoms.length; i++) {
                const a = atoms[i];

                // Gravity
                if (showGravity) {
                    a.ay += GRAVITY_STRENGTH * a.mass;
                }

                // Thermal noise
                a.vx += a.ax * DT + (Math.random() - 0.5) * thermalKick;
                a.vy += a.ay * DT + (Math.random() - 0.5) * thermalKick;

                // Damping
                a.vx *= phaseDamping;
                a.vy *= phaseDamping;

                // Speed limit
                const speed = Math.sqrt(a.vx * a.vx + a.vy * a.vy);
                const maxSpeed = 4 + (tempSlider.value / 100) * 6;
                if (speed > maxSpeed) {
                    a.vx = (a.vx / speed) * maxSpeed;
                    a.vy = (a.vy / speed) * maxSpeed;
                }

                a.x += a.vx * DT;
                a.y += a.vy * DT;

                // Boundary (pressure-dependent)
                const pad = a.radius + 5;
                const bx0 = bounds.x + pad;
                const bx1 = bounds.x + bounds.w - pad;
                const by0 = bounds.y + pad;
                const by1 = bounds.y + bounds.h - pad;
                if (a.x < bx0) { a.x = bx0; a.vx = Math.abs(a.vx) * 0.8; }
                if (a.x > bx1) { a.x = bx1; a.vx = -Math.abs(a.vx) * 0.8; }
                if (a.y < by0) { a.y = by0; a.vy = Math.abs(a.vy) * 0.8; }
                if (a.y > by1) { a.y = by1; a.vy = -Math.abs(a.vy) * 0.8; }

                a.vibPhase += 0.05 + (temp / 1000) * 0.1;
                a.electronPhase += 0.03 + Math.random() * 0.02;
                a.glow *= 0.95;

                a.trail.push({ x: a.x, y: a.y });
                if (a.trail.length > 6) a.trail.shift();

                bondTotal += a.bonds.length;
                totalKE += 0.5 * a.mass * (a.vx * a.vx + a.vy * a.vy);

                const ename = ELEMENTS[a.elIdx].name;
                elementCounts[ename] = (elementCounts[ename] || 0) + 1;
            }

            // Brownian particles
            for (let i = 0; i < brownianParticles.length; i++) {
                const p = brownianParticles[i];
                p.vx += (Math.random() - 0.5) * 0.3;
                p.vy += (Math.random() - 0.5) * 0.3;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.x += p.vx;
                p.y += p.vy;
                if (p.x < 0) p.x = W;
                if (p.x > W) p.x = 0;
                if (p.y < 0) p.y = H;
                if (p.y > H) p.y = 0;
            }

            // Try reactions
            tryReaction();

            // Find molecules
            const molecules = findMolecules();

            // Energy history
            energyHistory.kinetic.push(totalKE);
            energyHistory.potential.push(totalPE);
            if (energyHistory.kinetic.length > energyHistory.length) {
                energyHistory.kinetic.shift();
                energyHistory.potential.shift();
            }

            // Update UI
            atomCountEl.textContent = 'Atoms: ' + atoms.length;
            bondCountEl.textContent = 'Bonds: ' + Math.floor(bondTotal / 2);
            moleculeCountEl.textContent = 'Molecules: ' + molecules.filter(function(m) { return m.length > 1; }).length;

            let breakdown = '';
            const sortedElements = Object.keys(elementCounts).sort();
            for (let i = 0; i < sortedElements.length; i++) {
                if (i > 0) breakdown += ' ';
                breakdown += sortedElements[i] + ':' + elementCounts[sortedElements[i]];
            }
            elementBreakdownEl.textContent = breakdown;

            phaseStateEl.textContent = 'Phase: ' + phase;
            phaseStateEl.style.color = phase === 'Gas' ? 'rgba(255,150,80,0.6)' :
                                       phase === 'Liquid' ? 'rgba(80,150,255,0.6)' :
                                       'rgba(180,220,255,0.6)';

            const tempK = Math.round(getTemperature());
            tempValEl.textContent = tempK + ' K';
            const pf = getPressureFactor();
            pressureValEl.textContent = pf.toFixed(1) + ' atm';

            // Hover detection
            hoveredMolecule = null;
            if (mouseX >= 0 && mouseY >= 0) {
                for (let i = 0; i < atoms.length; i++) {
                    const dx = atoms[i].x - mouseX;
                    const dy = atoms[i].y - mouseY;
                    if (Math.sqrt(dx * dx + dy * dy) < atoms[i].radius + 10) {
                        // Find this atom's molecule
                        const molId = atoms[i].moleculeId;
                        const molIndices = [];
                        for (let j = 0; j < atoms.length; j++) {
                            if (atoms[j].moleculeId === molId) molIndices.push(j);
                        }
                        if (molIndices.length > 1) {
                            hoveredMolecule = molIndices;
                        }
                        break;
                    }
                }
            }

            if (hoveredMolecule) {
                hoverFormula.style.display = 'block';
                hoverFormula.style.left = (mouseX + 15) + 'px';
                hoverFormula.style.top = (mouseY - 25) + 'px';
                hoverFormula.textContent = getFormula(hoveredMolecule);
            } else {
                hoverFormula.style.display = 'none';
            }
        }

        function drawBond(a, b, bondType) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1) return;

            const normalizedDist = (dist - (a.radius + b.radius)) / (BOND_BREAK - (a.radius + b.radius));
            const energy = Math.max(0, 1 - normalizedDist);
            const intensity = 0.3 + energy * 0.7;

            const cr = (a.color[0] + b.color[0]) / 2;
            const cg = (a.color[1] + b.color[1]) / 2;
            const cb = (a.color[2] + b.color[2]) / 2;

            const vib = Math.sin(a.vibPhase * 3) * 1.5 * (1 - energy);
            const nx = -dy / dist;
            const ny = dx / dist;
            const mx = (a.x + b.x) / 2 + nx * vib;
            const my = (a.y + b.y) / 2 + ny * vib;

            ctx.save();

            if (bondType === 1) {
                // Single bond
                // Glow
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.quadraticCurveTo(mx, my, b.x, b.y);
                ctx.strokeStyle = 'rgba(' + Math.round(cr) + ',' + Math.round(cg) + ',' + Math.round(cb) + ',' + (intensity * 0.15) + ')';
                ctx.lineWidth = 8 + energy * 6;
                ctx.stroke();

                // Core
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.quadraticCurveTo(mx, my, b.x, b.y);
                ctx.strokeStyle = 'rgba(' + Math.round(cr) + ',' + Math.round(cg) + ',' + Math.round(cb) + ',' + (intensity * 0.7) + ')';
                ctx.lineWidth = 2 + energy * 2;
                ctx.stroke();

                // Bright center
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.quadraticCurveTo(mx, my, b.x, b.y);
                ctx.strokeStyle = 'rgba(255, 255, 255,' + (intensity * 0.3) + ')';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else if (bondType === 2) {
                // Double bond: two parallel lines
                var offset = 3;
                for (var s = -1; s <= 1; s += 2) {
                    var ox = nx * offset * s;
                    var oy = ny * offset * s;

                    ctx.beginPath();
                    ctx.moveTo(a.x + ox, a.y + oy);
                    ctx.quadraticCurveTo(mx + ox, my + oy, b.x + ox, b.y + oy);
                    ctx.strokeStyle = 'rgba(' + Math.round(cr) + ',' + Math.round(cg) + ',' + Math.round(cb) + ',' + (intensity * 0.6) + ')';
                    ctx.lineWidth = 1.5 + energy * 1.5;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(a.x + ox, a.y + oy);
                    ctx.quadraticCurveTo(mx + ox, my + oy, b.x + ox, b.y + oy);
                    ctx.strokeStyle = 'rgba(255, 255, 255,' + (intensity * 0.2) + ')';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
                // Glow
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.quadraticCurveTo(mx, my, b.x, b.y);
                ctx.strokeStyle = 'rgba(' + Math.round(cr) + ',' + Math.round(cg) + ',' + Math.round(cb) + ',' + (intensity * 0.1) + ')';
                ctx.lineWidth = 12 + energy * 6;
                ctx.stroke();
            } else if (bondType === 3) {
                // Triple bond: three parallel lines
                var offset3 = 4;
                for (var s3 = -1; s3 <= 1; s3++) {
                    var ox3 = nx * offset3 * s3;
                    var oy3 = ny * offset3 * s3;

                    ctx.beginPath();
                    ctx.moveTo(a.x + ox3, a.y + oy3);
                    ctx.quadraticCurveTo(mx + ox3, my + oy3, b.x + ox3, b.y + oy3);
                    ctx.strokeStyle = 'rgba(' + Math.round(cr) + ',' + Math.round(cg) + ',' + Math.round(cb) + ',' + (intensity * 0.5) + ')';
                    ctx.lineWidth = 1.2 + energy;
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.quadraticCurveTo(mx, my, b.x, b.y);
                ctx.strokeStyle = 'rgba(' + Math.round(cr) + ',' + Math.round(cg) + ',' + Math.round(cb) + ',' + (intensity * 0.08) + ')';
                ctx.lineWidth = 16 + energy * 6;
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawElectronCloud(a) {
            const el = ELEMENTS[a.elIdx];
            const orbitalR = el.vdwRadius * 0.8;
            const phase = a.electronPhase;

            ctx.save();
            ctx.globalAlpha = 0.15;

            // Draw fuzzy orbital lobes
            const lobes = el.maxBonds > 2 ? 4 : (el.maxBonds > 1 ? 2 : 1);
            for (let l = 0; l < lobes; l++) {
                const angle = phase + (l / lobes) * Math.PI * 2;
                const lx = a.x + Math.cos(angle) * orbitalR * 0.4;
                const ly = a.y + Math.sin(angle) * orbitalR * 0.4;

                const grad = ctx.createRadialGradient(lx, ly, 0, lx, ly, orbitalR * 0.6);
                const col = a.color;
                grad.addColorStop(0, 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',0.2)');
                grad.addColorStop(0.5, 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',0.08)');
                grad.addColorStop(1, 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',0)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                // Elliptical lobe
                ctx.ellipse(lx, ly, orbitalR * 0.5, orbitalR * 0.3, angle, 0, Math.PI * 2);
                ctx.fill();
            }

            // Central s-orbital cloud
            const sGrad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, orbitalR * 0.5);
            sGrad.addColorStop(0, 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0.12)');
            sGrad.addColorStop(1, 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0)');
            ctx.fillStyle = sGrad;
            ctx.beginPath();
            ctx.arc(a.x, a.y, orbitalR * 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawAtom(a) {
            const el = ELEMENTS[a.elIdx];
            const r = a.radius;
            const speed = Math.sqrt(a.vx * a.vx + a.vy * a.vy);
            const speedNorm = Math.min(speed / 5, 1);

            // Electron clouds
            if (showElectrons) {
                drawElectronCloud(a);
            }

            // VdW radius
            if (showVDW) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(a.x, a.y, el.vdwRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0.03)';
                ctx.fill();
                ctx.restore();
            }

            // Trail
            if (a.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(a.trail[0].x, a.trail[0].y);
                for (let t = 1; t < a.trail.length; t++) {
                    ctx.lineTo(a.trail[t].x, a.trail[t].y);
                }
                ctx.strokeStyle = 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0.06)';
                ctx.lineWidth = r * 0.5;
                ctx.stroke();
            }

            // Outer glow
            const glowRadius = r * (2.0 + a.glow * 2.5 + speedNorm * 0.5);
            const grad = ctx.createRadialGradient(a.x, a.y, r * 0.3, a.x, a.y, glowRadius);
            const glowAlpha = 0.15 + a.glow * 0.4 + speedNorm * 0.05;
            grad.addColorStop(0, 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',' + glowAlpha + ')');
            grad.addColorStop(0.5, 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',' + (glowAlpha * 0.3) + ')');
            grad.addColorStop(1, 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(a.x, a.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Atom sphere with 3D shading
            const sphereGrad = ctx.createRadialGradient(
                a.x - r * 0.3, a.y - r * 0.3, r * 0.1,
                a.x, a.y, r
            );
            const brightR = Math.min(255, a.color[0] + 80);
            const brightG = Math.min(255, a.color[1] + 80);
            const brightB = Math.min(255, a.color[2] + 80);
            sphereGrad.addColorStop(0, 'rgba(' + brightR + ',' + brightG + ',' + brightB + ',0.95)');
            sphereGrad.addColorStop(0.6, 'rgba(' + a.color[0] + ',' + a.color[1] + ',' + a.color[2] + ',0.9)');
            sphereGrad.addColorStop(1, 'rgba(' + Math.round(a.color[0] * 0.4) + ',' + Math.round(a.color[1] * 0.4) + ',' + Math.round(a.color[2] * 0.4) + ',0.85)');

            ctx.fillStyle = sphereGrad;
            ctx.beginPath();
            ctx.arc(a.x, a.y, r, 0, Math.PI * 2);
            ctx.fill();

            // Specular highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(a.x - r * 0.25, a.y - r * 0.25, r * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Highlight if hovered molecule
            if (hoveredMolecule) {
                for (let hi = 0; hi < hoveredMolecule.length; hi++) {
                    if (atoms[hoveredMolecule[hi]] === a) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(a.x, a.y, r + 3, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        ctx.restore();
                        break;
                    }
                }
            }

            // Element label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = (r < 10 ? '7' : '9') + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(el.name, a.x, a.y + 1);
        }

        function drawHeatmap() {
            const cellSize = 40;
            const cols = Math.ceil(W / cellSize);
            const rows = Math.ceil(H / cellSize);
            const grid = [];

            for (let i = 0; i < cols * rows; i++) grid[i] = 0;

            for (let i = 0; i < atoms.length; i++) {
                const a = atoms[i];
                const speed = Math.sqrt(a.vx * a.vx + a.vy * a.vy);
                const ke = 0.5 * a.mass * speed * speed;
                const col = Math.floor(a.x / cellSize);
                const row = Math.floor(a.y / cellSize);
                if (col >= 0 && col < cols && row >= 0 && row < rows) {
                    grid[row * cols + col] += ke;
                }
                // Spread to neighbors
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = row + dr;
                        const nc = col + dc;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                            grid[nr * cols + nc] += ke * 0.25;
                        }
                    }
                }
            }

            // Find max for normalization
            let maxVal = 1;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] > maxVal) maxVal = grid[i];
            }

            ctx.save();
            ctx.globalAlpha = 0.15;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const val = grid[row * cols + col] / maxVal;
                    if (val < 0.05) continue;
                    // Blue -> Cyan -> Yellow -> Red
                    let r, g, b;
                    if (val < 0.33) {
                        const t = val / 0.33;
                        r = 0; g = Math.round(t * 200); b = Math.round(200 - t * 100);
                    } else if (val < 0.66) {
                        const t = (val - 0.33) / 0.33;
                        r = Math.round(t * 255); g = 200; b = Math.round(100 - t * 100);
                    } else {
                        const t = (val - 0.66) / 0.34;
                        r = 255; g = Math.round(200 - t * 150); b = 0;
                    }
                    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }
            }
            ctx.restore();
        }

        function drawContainerBounds() {
            const bounds = getBounds();
            const pf = getPressureFactor();
            if (pf >= 1) return;

            ctx.save();
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.12)';
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 4]);
            ctx.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);
            ctx.setLineDash([]);
            ctx.restore();
        }

        function drawEnergyGraph() {
            ectx.fillStyle = 'rgba(10, 15, 30, 0.85)';
            ectx.fillRect(0, 0, 200, 100);

            // Border
            ectx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
            ectx.lineWidth = 1;
            ectx.strokeRect(0, 0, 200, 100);

            const ke = energyHistory.kinetic;
            const pe = energyHistory.potential;
            if (ke.length < 2) return;

            // Find range
            let maxE = 1;
            for (let i = 0; i < ke.length; i++) {
                if (Math.abs(ke[i]) > maxE) maxE = Math.abs(ke[i]);
                if (Math.abs(pe[i]) > maxE) maxE = Math.abs(pe[i]);
            }

            // Draw kinetic (orange)
            ectx.beginPath();
            for (let i = 0; i < ke.length; i++) {
                const x = (i / energyHistory.length) * 200;
                const y = 50 - (ke[i] / maxE) * 40;
                if (i === 0) ectx.moveTo(x, y);
                else ectx.lineTo(x, y);
            }
            ectx.strokeStyle = 'rgba(255, 150, 50, 0.6)';
            ectx.lineWidth = 1;
            ectx.stroke();

            // Draw potential (cyan)
            ectx.beginPath();
            for (let i = 0; i < pe.length; i++) {
                const x = (i / energyHistory.length) * 200;
                const y = 50 - (pe[i] / maxE) * 40;
                if (i === 0) ectx.moveTo(x, y);
                else ectx.lineTo(x, y);
            }
            ectx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            ectx.lineWidth = 1;
            ectx.stroke();

            // Labels
            ectx.fillStyle = 'rgba(255, 150, 50, 0.5)';
            ectx.font = '8px monospace';
            ectx.fillText('KE', 5, 10);
            ectx.fillStyle = 'rgba(100, 200, 255, 0.5)';
            ectx.fillText('PE', 25, 10);
            ectx.fillStyle = 'rgba(100, 200, 255, 0.25)';
            ectx.fillText('Energy', 155, 95);
        }

        function drawBrownian() {
            ctx.save();
            for (let i = 0; i < brownianParticles.length; i++) {
                const p = brownianParticles[i];
                ctx.fillStyle = 'rgba(100, 160, 220, ' + p.alpha + ')';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawFilmGrain() {
            if (frameCount % 3 !== 0) return; // Update every 3 frames for performance
            const imageData = gctx.createImageData(W, H);
            const data = imageData.data;
            // Sparse grain for performance
            const step = 4;
            for (let y = 0; y < H; y += step) {
                for (let x = 0; x < W; x += step) {
                    const val = Math.random() * 255;
                    for (let dy = 0; dy < step && y + dy < H; dy++) {
                        for (let dx = 0; dx < step && x + dx < W; dx++) {
                            const idx = ((y + dy) * W + (x + dx)) * 4;
                            data[idx] = val;
                            data[idx + 1] = val;
                            data[idx + 2] = val;
                            data[idx + 3] = 255;
                        }
                    }
                }
            }
            gctx.putImageData(imageData, 0, 0);
        }

        function draw() {
            // Clear with fade
            ctx.fillStyle = 'rgba(6, 10, 20, 0.85)';
            ctx.fillRect(0, 0, W, H);

            // Heatmap overlay
            if (showHeatmap) {
                drawHeatmap();
            }

            // Brownian background
            drawBrownian();

            // Subtle background grid
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.015)';
            ctx.lineWidth = 0.5;
            const gridSize = 60;
            for (let x = gridSize; x < W; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, H);
                ctx.stroke();
            }
            for (let y = gridSize; y < H; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }

            // Container bounds
            drawContainerBounds();

            // Draw bonds
            const drawnBonds = new Set();
            for (let i = 0; i < atoms.length; i++) {
                const a = atoms[i];
                for (let j = 0; j < a.bonds.length; j++) {
                    const b = a.bonds[j];
                    const ai = atoms.indexOf(a);
                    const bi = atoms.indexOf(b);
                    const bondKey = Math.min(ai, bi) + '-' + Math.max(ai, bi);
                    if (!drawnBonds.has(bondKey)) {
                        drawnBonds.add(bondKey);
                        drawBond(a, b, a.bondTypes[j] || 1);
                    }
                }
            }

            // Draw atoms
            for (let i = 0; i < atoms.length; i++) {
                drawAtom(atoms[i]);
            }

            // Energy graph
            drawEnergyGraph();

            // Film grain
            drawFilmGrain();
        }

        function animate() {
            frameCount++;
            if (!paused) {
                update();
            }
            draw();
            animId = requestAnimationFrame(animate);
        }

        // Mouse tracking for hover
        canvas.addEventListener('mousemove', function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        canvas.addEventListener('mouseleave', function() {
            mouseX = -1;
            mouseY = -1;
        });

        // Click to add atoms
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const count = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < count; i++) {
                const ox = (Math.random() - 0.5) * 30;
                const oy = (Math.random() - 0.5) * 30;
                atoms.push(createAtom(x + ox, y + oy));
            }
        });

        // Reset function
        function reset() {
            atoms = [];
            brownianParticles = [];
            energyHistory.kinetic = [];
            energyHistory.potential = [];
            initBrownian(80);
            initAtoms(40);
        }
        window.reset = reset;

        // Pause/unpause
        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                paused = !paused;
            }
        });

        // Handle resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                resize();
            }, 150);
        });

        // Init
        resize();
        initBrownian(80);
        initAtoms(40);
        animate();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
