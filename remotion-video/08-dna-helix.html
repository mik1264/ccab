<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DNA Double Helix</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%; overflow: hidden;
    background: linear-gradient(135deg, hsl(240, 35%, 8%) 0%, hsl(220, 45%, 13%) 50%, hsl(200, 30%, 10%) 100%);
    font-family: 'Courier New', monospace;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  .vignette {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
    pointer-events: none; z-index: 5;
  }
  /* Film grain + scanlines overlay */
  .film-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 6;
    mix-blend-mode: overlay;
    opacity: 0.08;
  }
  .scanlines {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 7;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.15) 2px,
      rgba(0,0,0,0.15) 4px
    );
    opacity: 0.3;
  }
  .title-overlay {
    position: fixed; bottom: 2rem; left: 50%;
    transform: translateX(-50%);
    color: rgba(140, 200, 255, 0.5);
    font-size: 0.75rem; letter-spacing: 0.3em; text-transform: uppercase;
    pointer-events: none; z-index: 10;
    text-shadow: 0 0 20px rgba(100, 180, 255, 0.3);
  }
  .info-panel {
    position: fixed; top: 1rem; right: 1rem;
    color: rgba(140, 200, 255, 0.5);
    font-size: 0.7rem; line-height: 1.6;
    text-align: right;
    pointer-events: none; z-index: 10;
    backdrop-filter: blur(10px);
    background: rgba(0,0,0,0.2);
    padding: 0.6rem 0.8rem;
    border-radius: 6px;
    border: 1px solid rgba(100,180,255,0.1);
  }
  .legend {
    position: fixed; bottom: 2rem; right: 1.5rem;
    z-index: 10; pointer-events: none;
    backdrop-filter: blur(10px);
    background: rgba(0,0,0,0.25);
    padding: 0.6rem 0.8rem;
    border-radius: 6px;
    border: 1px solid rgba(100,180,255,0.1);
  }
  .legend-title {
    color: rgba(180, 210, 240, 0.7);
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    margin-bottom: 0.4rem;
  }
  .legend-item {
    display: flex; align-items: center; gap: 0.5rem;
    margin-bottom: 0.35rem;
    color: rgba(180, 210, 240, 0.55);
    font-size: 0.65rem; font-family: 'Courier New', monospace;
  }
  .legend-dot {
    width: 8px; height: 8px; border-radius: 50%;
    box-shadow: 0 0 6px currentColor;
  }
  .legend-pair {
    color: rgba(180, 210, 240, 0.35);
    font-size: 0.55rem;
  }
  /* Controls panel */
  .controls-panel {
    position: fixed; bottom: 5rem; left: 1.5rem;
    z-index: 15;
    backdrop-filter: blur(10px);
    background: rgba(0,0,0,0.35);
    padding: 0.8rem 1rem;
    border-radius: 8px;
    border: 1px solid rgba(100,180,255,0.15);
    display: flex; flex-direction: column; gap: 0.6rem;
    min-width: 180px;
  }
  .controls-panel label {
    color: rgba(160, 200, 240, 0.6);
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    display: flex; flex-direction: column; gap: 0.25rem;
  }
  .controls-panel input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 3px;
    background: rgba(100,180,255,0.2);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .controls-panel input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: rgba(100,180,255,0.7);
    border: 1px solid rgba(100,180,255,0.4);
    cursor: pointer;
  }
  .toggle-btn {
    background: rgba(100,180,255,0.15);
    border: 1px solid rgba(100,180,255,0.25);
    color: rgba(160, 200, 240, 0.7);
    font-size: 0.6rem;
    font-family: 'Courier New', monospace;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    padding: 0.35rem 0.6rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .toggle-btn:hover {
    background: rgba(100,180,255,0.25);
  }
  .toggle-btn.active {
    background: rgba(100,180,255,0.3);
    border-color: rgba(100,180,255,0.5);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<canvas id="grain" class="film-overlay"></canvas>
<div class="scanlines"></div>
<div class="vignette"></div>
<a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&larr; Back to Gallery</a>
<div class="title-overlay">DNA Double Helix &mdash; B-Form</div>
<div class="info-panel">
  <div>Pitch: 3.4 nm</div>
  <div>Base pairs/turn: 10</div>
  <div>Diameter: 2.0 nm</div>
  <div>Rise/bp: 0.34 nm</div>
</div>
<div class="legend">
  <div class="legend-title">Base Pair Colors</div>
  <div class="legend-item"><span class="legend-dot" style="background: #ff6b4a; color: #ff6b4a;"></span> Adenine (A) <span class="legend-pair">-- 2 H-bonds</span></div>
  <div class="legend-item"><span class="legend-dot" style="background: #ffa726; color: #ffa726;"></span> Thymine (T) <span class="legend-pair">-- 2 H-bonds</span></div>
  <div class="legend-item"><span class="legend-dot" style="background: #42a5f5; color: #42a5f5;"></span> Guanine (G) <span class="legend-pair">-- 3 H-bonds</span></div>
  <div class="legend-item"><span class="legend-dot" style="background: #66cccc; color: #66cccc;"></span> Cytosine (C) <span class="legend-pair">-- 3 H-bonds</span></div>
  <div class="legend-item" style="margin-top:0.3rem; border-top: 1px solid rgba(100,180,255,0.1); padding-top: 0.3rem;">
    <span class="legend-dot" style="background: #b388ff; color: #b388ff;"></span> RNA Polymerase
  </div>
</div>

<!-- Controls -->
<div class="controls-panel">
  <label>
    Zoom
    <input type="range" id="zoomSlider" min="400" max="1600" value="800" step="10">
  </label>
  <label>
    Rotation Speed
    <input type="range" id="speedSlider" min="0" max="20" value="4" step="1">
  </label>
  <button class="toggle-btn active" id="labelToggle">Labels: ON</button>
</div>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W, H;
  let animId;
  let paused = false;

  // --- Film grain canvas ---
  const grainCanvas = document.getElementById('grain');
  const grainCtx = grainCanvas.getContext('2d');
  let grainFrame = 0;

  // --- DNA structural constants ---
  const BP_PER_TURN = 10;
  const TOTAL_BP = 60;
  const RISE_PER_BP = 18;
  const HELIX_RADIUS = 120;
  const TURN_ANGLE = (2 * Math.PI) / BP_PER_TURN;

  // Nucleotide colors
  const COLORS = {
    A: { r: 255, g: 107, b: 74 },
    T: { r: 255, g: 167, b: 38 },
    G: { r: 66,  g: 165, b: 245 },
    C: { r: 102, g: 204, b: 204 }
  };

  // H-bond counts: A-T = 2, G-C = 3
  const HBOND_COUNT = { A: 2, T: 2, G: 3, C: 3 };

  const BASES = ['A', 'T', 'G', 'C'];
  const COMPLEMENT = { A: 'T', T: 'A', G: 'C', C: 'G' };
  let sequence = [];

  function generateSequence() {
    sequence = [];
    for (let i = 0; i < TOTAL_BP; i++) {
      const base = BASES[Math.floor(Math.random() * 4)];
      sequence.push({ left: base, right: COMPLEMENT[base] });
    }
  }
  generateSequence();

  // --- Camera / 3D projection ---
  let rotY = 0;
  let rotX = -0.15;
  let autoRotSpeed = 0.004;
  let fov = 600;
  let cameraZ = -800;

  // Mouse drag state
  let isDragging = false;
  let lastMX = 0, lastMY = 0;
  let dragRotY = 0, dragRotX = 0;

  // --- Time ---
  let time = 0;

  // --- Controls state ---
  let showLabels = true;

  // --- Control bindings ---
  const zoomSlider = document.getElementById('zoomSlider');
  const speedSlider = document.getElementById('speedSlider');
  const labelToggle = document.getElementById('labelToggle');

  zoomSlider.addEventListener('input', function() {
    cameraZ = -parseInt(this.value);
  });

  speedSlider.addEventListener('input', function() {
    autoRotSpeed = parseInt(this.value) * 0.001;
  });

  labelToggle.addEventListener('click', function() {
    showLabels = !showLabels;
    this.textContent = 'Labels: ' + (showLabels ? 'ON' : 'OFF');
    this.classList.toggle('active', showLabels);
  });

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    grainCanvas.width = W;
    grainCanvas.height = H;
  }
  resize();
  window.addEventListener('resize', resize);

  // --- 3D Math ---
  function rotateYm(x, y, z, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return { x: x * c + z * s, y: y, z: -x * s + z * c };
  }

  function rotateXm(x, y, z, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return { x: x, y: y * c - z * s, z: y * s + z * c };
  }

  function project(x, y, z) {
    const dz = z - cameraZ;
    if (dz <= 0) return null;
    const scale = fov / dz;
    return {
      x: W / 2 + x * scale,
      y: H / 2 + y * scale,
      scale: scale,
      z: dz
    };
  }

  // --- Glow helpers ---
  function glowCircle(cx, cy, radius, color, alpha, glowRadius) {
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius + glowRadius);
    grad.addColorStop(0, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + alpha + ')');
    grad.addColorStop(0.4, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + (alpha * 0.6) + ')');
    grad.addColorStop(1, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',0)');
    ctx.beginPath();
    ctx.arc(cx, cy, radius + glowRadius, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  function glowLine(x1, y1, x2, y2, color, alpha, width) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',1)';
    ctx.lineWidth = width;
    ctx.shadowColor = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',0.8)';
    ctx.shadowBlur = width * 4;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  // --- Backbone colors ---
  const BACKBONE_COLOR_1 = { r: 100, g: 180, b: 255 };
  const BACKBONE_COLOR_2 = { r: 180, g: 100, b: 255 };
  const HBOND_COLOR = { r: 200, g: 220, b: 255 };
  const RNAP_COLOR = { r: 179, g: 136, b: 255 };

  // --- RNA Polymerase state ---
  let rnapPosition = 0; // which base pair the RNAP is at (fractional)
  const RNAP_SPEED = 0.015;
  const RNAP_UNZIP_RADIUS = 4; // how many bp around it are unzipped

  // --- Floating nucleotides (free bases in background) ---
  const floatingNucs = [];
  const NUM_FLOATING = 40;

  function initFloatingNucs() {
    floatingNucs.length = 0;
    for (let i = 0; i < NUM_FLOATING; i++) {
      floatingNucs.push({
        x: Math.random() * 2400 - 1200,
        y: Math.random() * 2400 - 1200,
        z: Math.random() * 600 + 300,
        vx: (Math.random() - 0.5) * 0.6,
        vy: (Math.random() - 0.5) * 0.6,
        vz: (Math.random() - 0.5) * 0.15,
        base: BASES[Math.floor(Math.random() * 4)],
        rot: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.02,
        size: Math.random() * 0.6 + 0.4
      });
    }
  }
  initFloatingNucs();

  function updateFloatingNucs() {
    for (const n of floatingNucs) {
      n.x += n.vx;
      n.y += n.vy;
      n.z += n.vz;
      n.rot += n.rotSpeed;
      if (n.x < -1200) n.x = 1200;
      if (n.x > 1200) n.x = -1200;
      if (n.y < -1200) n.y = 1200;
      if (n.y > 1200) n.y = -1200;
      if (n.z < 300) n.z = 600;
      if (n.z > 600) n.z = 300;
    }
  }

  function drawFloatingNucs() {
    for (const n of floatingNucs) {
      const dz = n.z - cameraZ;
      if (dz <= 0) continue;
      const scale = fov / dz;
      const sx = W / 2 + n.x * scale;
      const sy = H / 2 + n.y * scale;
      const col = COLORS[n.base];
      const depthAlpha = Math.max(0.05, Math.min(0.25, 0.4 - dz / 2000));
      const fontSize = Math.max(6, 14 * scale * n.size);

      ctx.save();
      ctx.globalAlpha = depthAlpha;
      ctx.font = fontSize + 'px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.8)';
      ctx.shadowColor = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.5)';
      ctx.shadowBlur = 8;

      // Subtle rotation wobble
      ctx.translate(sx, sy);
      ctx.rotate(Math.sin(n.rot) * 0.15);
      ctx.fillText(n.base, 0, 0);
      ctx.restore();
    }
  }

  // --- Floating particles (ambient molecules) ---
  const particles = [];
  const NUM_PARTICLES = 120;
  function initParticles() {
    particles.length = 0;
    for (let i = 0; i < NUM_PARTICLES; i++) {
      particles.push({
        x: Math.random() * 2000 - 1000,
        y: Math.random() * 2000 - 1000,
        z: Math.random() * 800 + 200,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        vz: (Math.random() - 0.5) * 0.1,
        size: Math.random() * 1.5 + 0.3,
        alpha: Math.random() * 0.3 + 0.05,
        hue: Math.random() < 0.3 ? 200 : (Math.random() < 0.5 ? 260 : 180)
      });
    }
  }
  initParticles();

  function updateParticles() {
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.z += p.vz;
      if (p.x < -1000) p.x = 1000;
      if (p.x > 1000) p.x = -1000;
      if (p.y < -1000) p.y = 1000;
      if (p.y > 1000) p.y = -1000;
      if (p.z < 200) p.z = 800;
      if (p.z > 800) p.z = 200;
    }
  }

  function drawParticles() {
    for (const p of particles) {
      const dz = p.z - cameraZ;
      if (dz <= 0) continue;
      const scale = fov / dz;
      const sx = W / 2 + p.x * scale;
      const sy = H / 2 + p.y * scale;
      const sr = p.size * scale;
      const flicker = 0.7 + 0.3 * Math.sin(time * 2 + p.x * 0.01);
      ctx.beginPath();
      ctx.arc(sx, sy, Math.max(0.3, sr), 0, Math.PI * 2);
      ctx.fillStyle = 'hsla(' + p.hue + ', 60%, 70%, ' + (p.alpha * flicker) + ')';
      ctx.fill();
    }
  }

  // --- Ambient glow (volumetric light behind helix) ---
  function drawAmbientGlow() {
    const grad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.5);
    grad.addColorStop(0, 'rgba(60, 100, 180, 0.12)');
    grad.addColorStop(0.3, 'rgba(40, 70, 160, 0.06)');
    grad.addColorStop(0.6, 'rgba(30, 50, 120, 0.03)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Pulsing volumetric rays
    const pulse = 0.5 + 0.5 * Math.sin(time * 0.5);
    const grad2 = ctx.createRadialGradient(W / 2, H / 2 + 50, 0, W / 2, H / 2 + 50, Math.max(W, H) * 0.35);
    grad2.addColorStop(0, 'rgba(80, 140, 255, ' + (0.06 * pulse) + ')');
    grad2.addColorStop(0.5, 'rgba(60, 100, 200, ' + (0.03 * pulse) + ')');
    grad2.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad2;
    ctx.fillRect(0, 0, W, H);
  }

  // --- Film grain ---
  function renderGrain() {
    grainFrame++;
    if (grainFrame % 3 !== 0) return; // update every 3rd frame for performance
    const imageData = grainCtx.createImageData(W, H);
    const data = imageData.data;
    // Sparse grain - only set ~10% of pixels for performance
    const totalPixels = W * H;
    const numGrains = (totalPixels * 0.1) | 0;
    for (let i = 0; i < numGrains; i++) {
      const idx = (Math.random() * totalPixels) | 0;
      const v = (Math.random() * 255) | 0;
      const off = idx * 4;
      data[off] = v;
      data[off + 1] = v;
      data[off + 2] = v;
      data[off + 3] = 40;
    }
    grainCtx.putImageData(imageData, 0, 0);
  }

  // --- Draw hydrogen bonds with correct count ---
  function drawHBonds(s1x, s1y, s2x, s2y, count, avgAlpha, avgScale) {
    ctx.save();
    ctx.globalAlpha = avgAlpha * 0.5;

    const dx = s2x - s1x;
    const dy = s2y - s1y;
    const len = Math.sqrt(dx * dx + dy * dy);
    // Perpendicular offset for spacing bonds
    const px = -dy / len;
    const py = dx / len;

    const bondSpacing = Math.max(2, 5 * avgScale);
    const dashLen = Math.max(2, 4 * avgScale);
    const gapLen = Math.max(1.5, 3 * avgScale);
    const lineW = Math.max(0.5, 1.5 * avgScale);

    // Offset to center the group of bonds
    const totalSpan = (count - 1) * bondSpacing;
    const startOffset = -totalSpan / 2;

    for (let b = 0; b < count; b++) {
      const off = startOffset + b * bondSpacing;
      const ox = px * off;
      const oy = py * off;

      ctx.beginPath();
      ctx.setLineDash([dashLen, gapLen]);
      ctx.strokeStyle = 'rgba(200, 230, 255, 0.7)';
      ctx.lineWidth = lineW;
      ctx.shadowColor = 'rgba(200, 230, 255, 0.4)';
      ctx.shadowBlur = 6;
      ctx.moveTo(s1x + ox, s1y + oy);
      ctx.lineTo(s2x + ox, s2y + oy);
      ctx.stroke();
    }

    ctx.setLineDash([]);
    ctx.restore();
  }

  // --- RNA Polymerase rendering ---
  function drawRNAPolymerase(items, centerY, verticalScroll) {
    // RNAP travels along the helix
    const rnapBP = rnapPosition % TOTAL_BP;
    const rnapAngle = rnapBP * TURN_ANGLE;
    const rnapY3d = centerY + rnapBP * RISE_PER_BP + (verticalScroll % (RISE_PER_BP * BP_PER_TURN));

    // Position RNAP slightly outside the helix
    const rnapRadius = HELIX_RADIUS * 1.4;
    const rnapX = rnapRadius * Math.cos(rnapAngle + Math.PI * 0.5);
    const rnapZ = rnapRadius * Math.sin(rnapAngle + Math.PI * 0.5);

    let p = rotateYm(rnapX, rnapY3d, rnapZ, rotY + dragRotY);
    p = rotateXm(p.x, p.y, p.z, rotX + dragRotX);
    const sp = project(p.x, p.y, p.z);

    if (!sp) return;

    const rnapSize = Math.max(8, 25 * sp.scale);
    const depthAlpha = Math.max(0.15, Math.min(1, 1.2 - sp.z / 1200));

    items.push({
      z: sp.z - 0.5,
      draw: function() {
        // Outer glow
        const grad = ctx.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, rnapSize * 3);
        grad.addColorStop(0, 'rgba(' + RNAP_COLOR.r + ',' + RNAP_COLOR.g + ',' + RNAP_COLOR.b + ',' + (depthAlpha * 0.3) + ')');
        grad.addColorStop(0.5, 'rgba(' + RNAP_COLOR.r + ',' + RNAP_COLOR.g + ',' + RNAP_COLOR.b + ',' + (depthAlpha * 0.1) + ')');
        grad.addColorStop(1, 'rgba(' + RNAP_COLOR.r + ',' + RNAP_COLOR.g + ',' + RNAP_COLOR.b + ',0)');
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, rnapSize * 3, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Main body - slightly oval enzyme complex
        ctx.save();
        ctx.globalAlpha = depthAlpha;
        ctx.translate(sp.x, sp.y);

        // Pulsing effect
        const pulse = 1 + 0.08 * Math.sin(time * 4);

        // Body shape (rounded rectangle-ish)
        const bw = rnapSize * 1.8 * pulse;
        const bh = rnapSize * 1.2 * pulse;
        ctx.beginPath();
        ctx.ellipse(0, 0, bw, bh, rnapAngle * 0.3, 0, Math.PI * 2);

        const bodyGrad = ctx.createRadialGradient(-bw * 0.2, -bh * 0.2, 0, 0, 0, bw);
        bodyGrad.addColorStop(0, 'rgba(220, 200, 255, ' + depthAlpha + ')');
        bodyGrad.addColorStop(0.5, 'rgba(' + RNAP_COLOR.r + ',' + RNAP_COLOR.g + ',' + RNAP_COLOR.b + ',' + depthAlpha + ')');
        bodyGrad.addColorStop(1, 'rgba(100, 70, 160, ' + (depthAlpha * 0.7) + ')');
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // Edge glow
        ctx.strokeStyle = 'rgba(200, 180, 255, ' + (depthAlpha * 0.5) + ')';
        ctx.lineWidth = Math.max(0.5, 1.5 * sp.scale);
        ctx.shadowColor = 'rgba(179, 136, 255, 0.6)';
        ctx.shadowBlur = 10;
        ctx.stroke();

        // "RNAP" label
        if (showLabels && rnapSize > 12) {
          ctx.shadowBlur = 0;
          ctx.font = Math.max(6, rnapSize * 0.45) + 'px "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = 'rgba(255, 255, 255, ' + (depthAlpha * 0.8) + ')';
          ctx.fillText('RNAP', 0, 0);
        }

        ctx.restore();

        // Transcription bubble lines (unzipping visual)
        ctx.save();
        ctx.globalAlpha = depthAlpha * 0.3;
        ctx.strokeStyle = 'rgba(179, 136, 255, 0.5)';
        ctx.lineWidth = Math.max(0.5, 1 * sp.scale);
        ctx.setLineDash([3, 4]);
        // Draw two arcs suggesting the opening
        for (let side = -1; side <= 1; side += 2) {
          ctx.beginPath();
          ctx.arc(sp.x, sp.y, rnapSize * 2.2, rnapAngle + side * 0.5, rnapAngle + side * 1.2);
          ctx.stroke();
        }
        ctx.setLineDash([]);
        ctx.restore();
      }
    });
  }

  // --- Major/minor groove visual distinction ---
  function drawGrooveIndicators(items, centerY, verticalScroll) {
    // Draw groove width indicators along the helix
    for (let turn = 0; turn < TOTAL_BP / BP_PER_TURN; turn++) {
      const baseBP = turn * BP_PER_TURN;
      const y3d = centerY + baseBP * RISE_PER_BP + (verticalScroll % (RISE_PER_BP * BP_PER_TURN));

      // Major groove marker (wider, ~22 angstrom)
      const majorAngle = baseBP * TURN_ANGLE + Math.PI * 0.25;
      const majorR = HELIX_RADIUS * 1.15;
      const mx = majorR * Math.cos(majorAngle);
      const mz = majorR * Math.sin(majorAngle);

      let mp = rotateYm(mx, y3d - 20, mz, rotY + dragRotY);
      mp = rotateXm(mp.x, mp.y, mp.z, rotX + dragRotX);
      const msp = project(mp.x, mp.y, mp.z);

      // Minor groove marker (narrower, ~12 angstrom)
      const minorAngle = majorAngle + Math.PI;
      const minorR = HELIX_RADIUS * 1.08;
      const mnx = minorR * Math.cos(minorAngle);
      const mnz = minorR * Math.sin(minorAngle);

      let mnp = rotateYm(mnx, y3d + 20, mnz, rotY + dragRotY);
      mnp = rotateXm(mnp.x, mnp.y, mnp.z, rotX + dragRotX);
      const mnsp = project(mnp.x, mnp.y, mnp.z);

      if (msp) {
        const da = Math.max(0.05, Math.min(0.2, 0.35 - msp.z / 1200));
        // Only show when roughly facing camera
        const facing = Math.cos(majorAngle + rotY + dragRotY);
        if (facing > 0.4) {
          items.push({
            z: msp.z + 1,
            draw: function() {
              ctx.save();
              ctx.globalAlpha = da * facing;
              // Wide bracket shape for major groove
              const sz = Math.max(3, 12 * msp.scale);
              ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
              ctx.lineWidth = Math.max(0.5, 1 * msp.scale);
              ctx.beginPath();
              ctx.arc(msp.x, msp.y, sz, -0.5, 0.5);
              ctx.stroke();

              if (showLabels && sz > 6) {
                ctx.font = Math.max(5, 7 * msp.scale) + 'px "Courier New"';
                ctx.fillStyle = 'rgba(140, 200, 255, ' + (da * facing * 0.8) + ')';
                ctx.textAlign = 'center';
                ctx.fillText('major', msp.x, msp.y - sz - 3);
              }
              ctx.restore();
            }
          });
        }
      }

      if (mnsp) {
        const da = Math.max(0.05, Math.min(0.15, 0.3 - mnsp.z / 1200));
        const facing = Math.cos(minorAngle + rotY + dragRotY);
        if (facing > 0.4) {
          items.push({
            z: mnsp.z + 1,
            draw: function() {
              ctx.save();
              ctx.globalAlpha = da * facing;
              const sz = Math.max(2, 7 * mnsp.scale);
              ctx.strokeStyle = 'rgba(180, 100, 255, 0.25)';
              ctx.lineWidth = Math.max(0.5, 1 * mnsp.scale);
              ctx.beginPath();
              ctx.arc(mnsp.x, mnsp.y, sz, -0.3, 0.3);
              ctx.stroke();

              if (showLabels && sz > 5) {
                ctx.font = Math.max(5, 6 * mnsp.scale) + 'px "Courier New"';
                ctx.fillStyle = 'rgba(180, 140, 255, ' + (da * facing * 0.7) + ')';
                ctx.textAlign = 'center';
                ctx.fillText('minor', mnsp.x, mnsp.y - sz - 2);
              }
              ctx.restore();
            }
          });
        }
      }
    }
  }

  // --- Build geometry for one frame ---
  function buildGeometry() {
    const items = [];

    const centerY = -(TOTAL_BP * RISE_PER_BP) / 2;
    const verticalScroll = time * 12;

    const rnapBP = rnapPosition % TOTAL_BP;

    for (let i = 0; i < TOTAL_BP; i++) {
      const angle1 = i * TURN_ANGLE;
      const angle2 = angle1 + Math.PI;

      const y3d = centerY + i * RISE_PER_BP + (verticalScroll % (RISE_PER_BP * BP_PER_TURN));

      // Calculate unzip effect from RNA polymerase
      const distToRNAP = Math.abs(i - rnapBP);
      const unzipFactor = Math.max(0, 1 - distToRNAP / RNAP_UNZIP_RADIUS);
      const unzipSpread = unzipFactor * 0.4; // how much the strands separate

      // Strand 1 backbone position (spread when unzipped)
      const r1 = HELIX_RADIUS * (1 + unzipSpread);
      const x1 = r1 * Math.cos(angle1);
      const z1 = r1 * Math.sin(angle1);

      // Strand 2 backbone position
      const r2 = HELIX_RADIUS * (1 + unzipSpread);
      const x2 = r2 * Math.cos(angle2);
      const z2 = r2 * Math.sin(angle2);

      // Rotate and project
      let p1 = rotateYm(x1, y3d, z1, rotY + dragRotY);
      p1 = rotateXm(p1.x, p1.y, p1.z, rotX + dragRotX);
      const s1 = project(p1.x, p1.y, p1.z);

      let p2 = rotateYm(x2, y3d, z2, rotY + dragRotY);
      p2 = rotateXm(p2.x, p2.y, p2.z, rotX + dragRotX);
      const s2 = project(p2.x, p2.y, p2.z);

      if (!s1 || !s2) continue;

      const bp = sequence[i % sequence.length];
      const col1 = COLORS[bp.left];
      const col2 = COLORS[bp.right];
      const hbondCount = HBOND_COUNT[bp.left];

      // Depth-based alpha (depth of field effect)
      const depthAlpha1 = Math.max(0.1, Math.min(1, 1.2 - s1.z / 1200));
      const depthAlpha2 = Math.max(0.1, Math.min(1, 1.2 - s2.z / 1200));

      // Depth of field blur simulation via size scaling
      const dofScale1 = 1 + Math.max(0, (s1.z - 600) / 800) * 0.5;
      const dofScale2 = 1 + Math.max(0, (s2.z - 600) / 800) * 0.5;

      const sphereRadius1 = Math.max(2, 7 * s1.scale * dofScale1);
      const sphereRadius2 = Math.max(2, 7 * s2.scale * dofScale2);

      // --- Hydrogen bonds ---
      const avgZ = (s1.z + s2.z) / 2;
      const avgAlpha = (depthAlpha1 + depthAlpha2) / 2;
      const avgScale = (s1.scale + s2.scale) / 2;

      // Only draw H-bonds if not fully unzipped
      if (unzipFactor < 0.8) {
        items.push({
          z: avgZ + 0.1,
          draw: function() {
            const bondAlpha = avgAlpha * (1 - unzipFactor);
            drawHBonds(s1.x, s1.y, s2.x, s2.y, hbondCount, bondAlpha, avgScale);
          }
        });
      }

      // --- Nucleotide sphere on strand 1 ---
      items.push({
        z: s1.z,
        draw: function() {
          // Outer glow (bigger for DOF effect on far objects)
          glowCircle(s1.x, s1.y, sphereRadius1, col1, depthAlpha1 * 0.4, sphereRadius1 * (2.5 + dofScale1));
          // Inner bright sphere
          const grad = ctx.createRadialGradient(
            s1.x - sphereRadius1 * 0.3, s1.y - sphereRadius1 * 0.3, 0,
            s1.x, s1.y, sphereRadius1
          );
          grad.addColorStop(0, 'rgba(' + Math.min(255, col1.r + 80) + ',' + Math.min(255, col1.g + 80) + ',' + Math.min(255, col1.b + 80) + ',' + depthAlpha1 + ')');
          grad.addColorStop(0.7, 'rgba(' + col1.r + ',' + col1.g + ',' + col1.b + ',' + depthAlpha1 + ')');
          grad.addColorStop(1, 'rgba(' + (col1.r * 0.5 | 0) + ',' + (col1.g * 0.5 | 0) + ',' + (col1.b * 0.5 | 0) + ',' + depthAlpha1 + ')');
          ctx.beginPath();
          ctx.arc(s1.x, s1.y, sphereRadius1, 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.fill();

          // Label
          if (showLabels && sphereRadius1 > 5) {
            ctx.save();
            ctx.font = 'bold ' + Math.max(6, sphereRadius1 * 1.1) + 'px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(255,255,255,' + (depthAlpha1 * 0.9) + ')';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(bp.left, s1.x, s1.y);
            ctx.restore();
          }
        }
      });

      // --- Nucleotide sphere on strand 2 ---
      items.push({
        z: s2.z,
        draw: function() {
          glowCircle(s2.x, s2.y, sphereRadius2, col2, depthAlpha2 * 0.4, sphereRadius2 * (2.5 + dofScale2));
          const grad = ctx.createRadialGradient(
            s2.x - sphereRadius2 * 0.3, s2.y - sphereRadius2 * 0.3, 0,
            s2.x, s2.y, sphereRadius2
          );
          grad.addColorStop(0, 'rgba(' + Math.min(255, col2.r + 80) + ',' + Math.min(255, col2.g + 80) + ',' + Math.min(255, col2.b + 80) + ',' + depthAlpha2 + ')');
          grad.addColorStop(0.7, 'rgba(' + col2.r + ',' + col2.g + ',' + col2.b + ',' + depthAlpha2 + ')');
          grad.addColorStop(1, 'rgba(' + (col2.r * 0.5 | 0) + ',' + (col2.g * 0.5 | 0) + ',' + (col2.b * 0.5 | 0) + ',' + depthAlpha2 + ')');
          ctx.beginPath();
          ctx.arc(s2.x, s2.y, sphereRadius2, 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.fill();

          // Label
          if (showLabels && sphereRadius2 > 5) {
            ctx.save();
            ctx.font = 'bold ' + Math.max(6, sphereRadius2 * 1.1) + 'px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(255,255,255,' + (depthAlpha2 * 0.9) + ')';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(bp.right, s2.x, s2.y);
            ctx.restore();
          }
        }
      });

      // --- Backbone segments ---
      if (i > 0) {
        const prevAngle1 = (i - 1) * TURN_ANGLE;
        const prevAngle2 = prevAngle1 + Math.PI;
        const prevY = centerY + (i - 1) * RISE_PER_BP + (verticalScroll % (RISE_PER_BP * BP_PER_TURN));

        const prevDistToRNAP = Math.abs((i - 1) - rnapBP);
        const prevUnzip = Math.max(0, 1 - prevDistToRNAP / RNAP_UNZIP_RADIUS);
        const prevSpread = prevUnzip * 0.4;
        const pr1 = HELIX_RADIUS * (1 + prevSpread);
        const pr2 = HELIX_RADIUS * (1 + prevSpread);

        // Previous strand 1
        const px1 = pr1 * Math.cos(prevAngle1);
        const pz1 = pr1 * Math.sin(prevAngle1);
        let pp1 = rotateYm(px1, prevY, pz1, rotY + dragRotY);
        pp1 = rotateXm(pp1.x, pp1.y, pp1.z, rotX + dragRotX);
        const sp1 = project(pp1.x, pp1.y, pp1.z);

        // Previous strand 2
        const px2 = pr2 * Math.cos(prevAngle2);
        const pz2 = pr2 * Math.sin(prevAngle2);
        let pp2 = rotateYm(px2, prevY, pz2, rotY + dragRotY);
        pp2 = rotateXm(pp2.x, pp2.y, pp2.z, rotX + dragRotX);
        const sp2 = project(pp2.x, pp2.y, pp2.z);

        if (sp1) {
          const segZ = (s1.z + sp1.z) / 2;
          const segAlpha = Math.max(0.1, Math.min(0.9, 1.1 - segZ / 1200));
          const segWidth = Math.max(1, 3.5 * ((s1.scale + sp1.scale) / 2));
          items.push({
            z: segZ + 0.2,
            draw: function() {
              glowLine(sp1.x, sp1.y, s1.x, s1.y, BACKBONE_COLOR_1, segAlpha * 0.7, segWidth);
              ctx.save();
              ctx.globalAlpha = segAlpha;
              ctx.strokeStyle = 'rgba(' + (BACKBONE_COLOR_1.r + 40) + ',' + (BACKBONE_COLOR_1.g + 40) + ',' + (BACKBONE_COLOR_1.b + 20) + ',0.9)';
              ctx.lineWidth = Math.max(0.5, segWidth * 0.4);
              ctx.beginPath();
              ctx.moveTo(sp1.x, sp1.y);
              ctx.lineTo(s1.x, s1.y);
              ctx.stroke();
              ctx.restore();
            }
          });
        }

        if (sp2) {
          const segZ = (s2.z + sp2.z) / 2;
          const segAlpha = Math.max(0.1, Math.min(0.9, 1.1 - segZ / 1200));
          const segWidth = Math.max(1, 3.5 * ((s2.scale + sp2.scale) / 2));
          items.push({
            z: segZ + 0.2,
            draw: function() {
              glowLine(sp2.x, sp2.y, s2.x, s2.y, BACKBONE_COLOR_2, segAlpha * 0.7, segWidth);
              ctx.save();
              ctx.globalAlpha = segAlpha;
              ctx.strokeStyle = 'rgba(' + (BACKBONE_COLOR_2.r + 20) + ',' + (BACKBONE_COLOR_2.g + 40) + ',' + (BACKBONE_COLOR_2.b + 20) + ',0.9)';
              ctx.lineWidth = Math.max(0.5, segWidth * 0.4);
              ctx.beginPath();
              ctx.moveTo(sp2.x, sp2.y);
              ctx.lineTo(s2.x, s2.y);
              ctx.stroke();
              ctx.restore();
            }
          });
        }
      }
    }

    // RNA Polymerase
    drawRNAPolymerase(items, centerY, verticalScroll);

    // Major/minor groove indicators
    drawGrooveIndicators(items, centerY, verticalScroll);

    // Depth-sort: far to near
    items.sort(function(a, b) { return b.z - a.z; });
    return items;
  }

  // --- Main render loop ---
  function render() {
    animId = requestAnimationFrame(render);
    if (paused) return;

    time += 0.016;
    rotY += autoRotSpeed;
    rnapPosition += RNAP_SPEED;

    ctx.clearRect(0, 0, W, H);

    // Ambient glow behind everything
    drawAmbientGlow();

    // Ambient particles
    updateParticles();
    drawParticles();

    // Floating nucleotides
    updateFloatingNucs();
    drawFloatingNucs();

    // Build and render depth-sorted DNA geometry
    const items = buildGeometry();
    for (const item of items) {
      item.draw();
    }

    // Film grain
    renderGrain();
  }

  // --- Mouse interaction ---
  canvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    lastMX = e.clientX;
    lastMY = e.clientY;
  });

  window.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    const dx = e.clientX - lastMX;
    const dy = e.clientY - lastMY;
    dragRotY += dx * 0.005;
    dragRotX += dy * 0.003;
    dragRotX = Math.max(-1.2, Math.min(1.2, dragRotX));
    lastMX = e.clientX;
    lastMY = e.clientY;
  });

  window.addEventListener('mouseup', function() {
    isDragging = false;
  });

  // Scroll to zoom
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    cameraZ += e.deltaY * 0.5;
    cameraZ = Math.max(-1600, Math.min(-400, cameraZ));
    // Sync slider
    zoomSlider.value = -cameraZ;
  }, { passive: false });

  // Touch support
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      isDragging = true;
      lastMX = e.touches[0].clientX;
      lastMY = e.touches[0].clientY;
    }
  }, { passive: true });

  window.addEventListener('touchmove', function(e) {
    if (!isDragging || e.touches.length !== 1) return;
    const dx = e.touches[0].clientX - lastMX;
    const dy = e.touches[0].clientY - lastMY;
    dragRotY += dx * 0.005;
    dragRotX += dy * 0.003;
    dragRotX = Math.max(-1.2, Math.min(1.2, dragRotX));
    lastMX = e.touches[0].clientX;
    lastMY = e.touches[0].clientY;
  }, { passive: true });

  window.addEventListener('touchend', function() {
    isDragging = false;
  });

  // Pinch to zoom on touch
  let lastPinchDist = 0;
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      lastPinchDist = Math.sqrt(dx * dx + dy * dy);
    }
  }, { passive: true });

  canvas.addEventListener('touchmove', function(e) {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const delta = lastPinchDist - dist;
      cameraZ += delta * 2;
      cameraZ = Math.max(-1600, Math.min(-400, cameraZ));
      zoomSlider.value = -cameraZ;
      lastPinchDist = dist;
    }
  }, { passive: true });

  // --- Pause toggle ---
  window.togglePause = function() {
    paused = !paused;
  };

  // --- Reset ---
  window.reset = function() {
    time = 0;
    rotY = 0;
    rotX = -0.15;
    dragRotY = 0;
    dragRotX = 0;
    rnapPosition = 0;
    autoRotSpeed = 0.004;
    cameraZ = -800;
    zoomSlider.value = 800;
    speedSlider.value = 4;
    generateSequence();
    initParticles();
    initFloatingNucs();
  };

  // Start
  render();
})();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
