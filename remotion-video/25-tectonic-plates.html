<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tectonic Plate Boundaries - Cross-Section View</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, hsl(220, 40%, 6%) 0%, hsl(210, 35%, 10%) 50%, hsl(200, 30%, 8%) 100%);
            overflow: hidden;
            font-family: monospace;
        }
        canvas { display: block; }

        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.6) 100%);
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.06) 2px,
                rgba(0,0,0,0.06) 4px
            );
        }

        .film-grain {
            position: fixed;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            pointer-events: none;
            z-index: 7;
            opacity: 0.035;
            animation: grain 0.5s steps(6) infinite;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        }
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            30% { transform: translate(3%, -15%); }
            50% { transform: translate(12%, 9%); }
            70% { transform: translate(9%, 4%); }
            90% { transform: translate(-1%, 7%); }
        }

        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }

        .title-overlay {
            position: fixed;
            top: 1rem;
            right: 1.5rem;
            text-align: right;
            z-index: 20;
            pointer-events: none;
        }
        .title-overlay h1 {
            font-family: monospace;
            font-size: 1rem;
            font-weight: 400;
            color: rgba(100, 200, 255, 0.4);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        .title-overlay .subtitle {
            font-family: monospace;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.25);
            margin-top: 0.2rem;
        }

        .hint {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: monospace;
            font-size: 0.7rem;
            color: rgba(100, 200, 255, 0.25);
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* Timeline slider */
        .timeline-container {
            position: fixed;
            bottom: 3.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            padding: 0.4rem 1rem;
            border-radius: 20px;
            border: 1px solid rgba(100,200,255,0.1);
        }
        .timeline-container label {
            font-family: monospace;
            font-size: 0.6rem;
            color: rgba(100,200,255,0.4);
            white-space: nowrap;
        }
        .timeline-container input[type="range"] {
            width: 180px;
            accent-color: rgba(100,200,255,0.5);
            height: 4px;
            cursor: pointer;
        }
        .timeline-container .era-label {
            font-family: monospace;
            font-size: 0.55rem;
            color: rgba(100,200,255,0.5);
            min-width: 80px;
            text-align: right;
        }

        /* Seismograph panel */
        .seismograph-panel {
            position: fixed;
            bottom: 6rem;
            right: 1rem;
            z-index: 20;
            width: 200px;
            height: 80px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            border: 1px solid rgba(100,200,255,0.1);
            overflow: hidden;
        }
        .seismograph-panel .seismo-title {
            font-family: monospace;
            font-size: 0.5rem;
            color: rgba(100,200,255,0.4);
            padding: 3px 6px;
            letter-spacing: 0.1em;
        }
        .seismograph-panel canvas {
            display: block;
        }

        /* Richter display */
        .richter-display {
            position: fixed;
            bottom: 6rem;
            right: 220px;
            z-index: 20;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            border: 1px solid rgba(100,200,255,0.1);
            padding: 6px 12px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .richter-display .richter-label {
            font-family: monospace;
            font-size: 0.45rem;
            color: rgba(100,200,255,0.3);
            letter-spacing: 0.1em;
        }
        .richter-display .richter-value {
            font-family: monospace;
            font-size: 1.4rem;
            font-weight: bold;
            color: rgba(255,200,80,0.9);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="vignette"></div>
    <div class="scanlines"></div>
    <div class="film-grain"></div>
    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>
    <div class="title-overlay">
        <h1>Tectonic Plates</h1>
        <div class="subtitle">Divergent / Convergent / Transform Boundaries</div>
    </div>
    <div class="hint" id="hint">Click anywhere to trigger an earthquake -- Drag timeline to shift continental drift</div>

    <div class="timeline-container">
        <label>CONTINENTAL DRIFT</label>
        <input type="range" id="timeline" min="0" max="100" value="100">
        <div class="era-label" id="eraLabel">Present Day</div>
    </div>

    <div class="seismograph-panel">
        <div class="seismo-title">SEISMOGRAPH</div>
        <canvas id="seismoCanvas" width="200" height="65"></canvas>
    </div>

    <div class="richter-display" id="richterDisplay">
        <div class="richter-label">RICHTER MAGNITUDE</div>
        <div class="richter-value" id="richterValue">0.0</div>
    </div>

    <script>
    (function() {
        'use strict';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const seismoCanvas = document.getElementById('seismoCanvas');
        const seismoCtx = seismoCanvas.getContext('2d');
        let W, H;
        let time = 0;
        let paused = false;
        let earthquakes = [];
        let magmaParticles = [];
        let convectionParticles = [];
        let subductionParticles = [];
        let transformParticles = [];
        let eruptionParticles = [];
        let ashParticles = [];
        let lavaFlows = [];
        let tsunamiWaves = [];
        let hotspotPlumes = [];
        let islandChain = [];
        let seismicWaves = [];
        let fossilPairs = [];
        let mineralDeposits = [];

        // Seismograph data
        let seismoData = new Float32Array(200);
        let seismoIndex = 0;
        let currentMagnitude = 0;
        let richterTimer = 0;

        // Timeline
        let driftProgress = 1.0; // 0 = Pangaea, 1 = present
        const timelineSlider = document.getElementById('timeline');
        const eraLabel = document.getElementById('eraLabel');

        const eras = [
            { t: 0, label: '335 Mya - Pangaea' },
            { t: 15, label: '300 Mya - Late Carboniferous' },
            { t: 30, label: '250 Mya - Permian' },
            { t: 45, label: '200 Mya - Early Jurassic' },
            { t: 60, label: '150 Mya - Late Jurassic' },
            { t: 75, label: '100 Mya - Cretaceous' },
            { t: 85, label: '65 Mya - End Cretaceous' },
            { t: 95, label: '30 Mya - Oligocene' },
            { t: 100, label: 'Present Day' }
        ];

        timelineSlider.addEventListener('input', function() {
            driftProgress = this.value / 100;
            // Find matching era label
            let best = eras[0];
            for (const era of eras) {
                if (this.value >= era.t) best = era;
            }
            eraLabel.textContent = best.label;
        });

        // Layout zones
        let zones = {};

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;

            const thirdW = W / 3;
            const surfaceY = H * 0.32;
            const crustBottom = H * 0.42;
            const mantleBottom = H * 0.82;

            zones = {
                surfaceY: surfaceY,
                crustBottom: crustBottom,
                mantleBottom: mantleBottom,
                coreY: H * 0.95,
                divergent: { cx: thirdW * 0.5, left: 0, right: thirdW },
                convergent: { cx: thirdW * 1.5, left: thirdW, right: thirdW * 2 },
                transform: { cx: thirdW * 2.5, left: thirdW * 2, right: W }
            };

            initParticles();
            initFossils();
            initMinerals();
            initIslandChain();
        }

        // --- Fossil pairs across divergent boundary ---
        function initFossils() {
            fossilPairs = [];
            const cx = zones.divergent.cx;
            const sy = zones.surfaceY;
            const fossils = [
                { symbol: 'M', name: 'Mesosaurus', color: 'rgba(180,220,140,' },
                { symbol: 'G', name: 'Glossopteris', color: 'rgba(140,200,180,' },
                { symbol: 'L', name: 'Lystrosaurus', color: 'rgba(200,180,140,' },
                { symbol: 'C', name: 'Cynognathus', color: 'rgba(180,160,200,' }
            ];
            for (let i = 0; i < fossils.length; i++) {
                const yOff = -25 - i * 14;
                fossilPairs.push({
                    leftX: cx - 60 - i * 10,
                    rightX: cx + 60 + i * 10,
                    y: sy + yOff,
                    symbol: fossils[i].symbol,
                    name: fossils[i].name,
                    color: fossils[i].color
                });
            }
        }

        // --- Mineral deposits ---
        function initMinerals() {
            mineralDeposits = [];
            // At divergent: copper, zinc (hydrothermal)
            const dcx = zones.divergent.cx;
            const sy = zones.surfaceY;
            const cb = zones.crustBottom;
            for (let i = 0; i < 5; i++) {
                mineralDeposits.push({
                    x: dcx + (Math.random() - 0.5) * 40,
                    y: sy + Math.random() * (cb - sy) * 0.7,
                    type: 'Cu/Zn',
                    color: 'rgba(200,160,60,',
                    size: 2 + Math.random() * 2
                });
            }
            // At convergent: gold, tin (subduction related)
            const ccx = zones.convergent.cx;
            for (let i = 0; i < 5; i++) {
                mineralDeposits.push({
                    x: ccx - 40 + Math.random() * 30,
                    y: sy - 20 + Math.random() * 30,
                    type: 'Au/Sn',
                    color: 'rgba(255,215,0,',
                    size: 2 + Math.random() * 2
                });
            }
            // At transform: asbestos, serpentinite
            const tcx = zones.transform.cx;
            for (let i = 0; i < 4; i++) {
                mineralDeposits.push({
                    x: tcx + (Math.random() - 0.5) * 20,
                    y: sy + Math.random() * (cb - sy) * 0.5,
                    type: 'Serp',
                    color: 'rgba(100,180,120,',
                    size: 2 + Math.random() * 1.5
                });
            }
        }

        // --- Island chain for hotspot ---
        function initIslandChain() {
            islandChain = [];
            const tcx = zones.transform.cx;
            const sy = zones.surfaceY;
            // Chain of islands trailing from hotspot
            for (let i = 0; i < 8; i++) {
                islandChain.push({
                    x: tcx - 60 + i * 18,
                    y: sy,
                    age: i,
                    size: Math.max(2, 10 - i * 1.2),
                    height: Math.max(3, 18 - i * 2)
                });
            }
        }

        // --- Convection cell particles ---
        function initParticles() {
            convectionParticles = [];
            magmaParticles = [];
            subductionParticles = [];
            transformParticles = [];
            eruptionParticles = [];
            ashParticles = [];
            lavaFlows = [];
            hotspotPlumes = [];

            const thirdW = W / 3;

            // Convection cells
            for (let z = 0; z < 3; z++) {
                const zoneLeft = z * thirdW;
                for (let cell = 0; cell < 2; cell++) {
                    const cellCx = cell === 0 ? zoneLeft + thirdW * 0.25 : zoneLeft + thirdW * 0.75;
                    const cellDir = cell === 0 ? 1 : -1;
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 * i) / 12 + Math.random() * 0.3;
                        const rx = thirdW * 0.18;
                        const ry = (zones.mantleBottom - zones.crustBottom) * 0.35;
                        convectionParticles.push({
                            angle: angle,
                            cx: cellCx,
                            cy: (zones.crustBottom + zones.mantleBottom) / 2,
                            rx: rx,
                            ry: ry,
                            speed: (0.003 + Math.random() * 0.002) * cellDir,
                            size: 1.5 + Math.random() * 1.5
                        });
                    }
                }
            }

            // Magma particles at divergent boundary
            for (let i = 0; i < 40; i++) {
                magmaParticles.push(createMagmaParticle());
            }

            // Subduction particles
            for (let i = 0; i < 25; i++) {
                subductionParticles.push(createSubductionParticle());
            }

            // Transform fault particles
            for (let i = 0; i < 15; i++) {
                transformParticles.push(createTransformParticle());
            }

            // Hotspot plume particles
            for (let i = 0; i < 30; i++) {
                hotspotPlumes.push(createHotspotPlume());
            }
        }

        function createMagmaParticle() {
            const cx = zones.divergent.cx;
            return {
                x: cx + (Math.random() - 0.5) * 20,
                y: zones.mantleBottom - Math.random() * (zones.mantleBottom - zones.crustBottom),
                vy: -(0.3 + Math.random() * 0.8),
                vx: (Math.random() - 0.5) * 0.3,
                size: 1 + Math.random() * 3,
                life: 1,
                maxLife: 120 + Math.random() * 180
            };
        }

        function createSubductionParticle() {
            const cx = zones.convergent.cx;
            return {
                x: cx + 30 + Math.random() * 80,
                y: zones.surfaceY + Math.random() * 10,
                t: Math.random(),
                speed: 0.001 + Math.random() * 0.001,
                size: 1.5 + Math.random() * 2
            };
        }

        function createTransformParticle() {
            const cx = zones.transform.cx;
            return {
                x: cx + (Math.random() - 0.5) * 6,
                y: zones.surfaceY - 5 + Math.random() * (zones.crustBottom - zones.surfaceY + 10),
                baseX: cx,
                vy: 0,
                vx: (Math.random() > 0.5 ? 1 : -1) * (0.1 + Math.random() * 0.2),
                size: 1 + Math.random() * 1.5,
                life: Math.random()
            };
        }

        function createHotspotPlume() {
            const cx = zones.transform.cx - 60;
            return {
                x: cx + (Math.random() - 0.5) * 16,
                y: zones.mantleBottom + Math.random() * (H - zones.mantleBottom),
                vy: -(0.4 + Math.random() * 0.6),
                vx: (Math.random() - 0.5) * 0.2,
                size: 1.5 + Math.random() * 3,
                life: 1,
                maxLife: 200 + Math.random() * 200
            };
        }

        function createEruptionParticle(volcX, volcY) {
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
            const speed = 2 + Math.random() * 5;
            return {
                x: volcX + (Math.random() - 0.5) * 6,
                y: volcY,
                vx: Math.cos(angle) * speed + (Math.random() - 0.5) * 1.5,
                vy: Math.sin(angle) * speed,
                size: 2 + Math.random() * 4,
                life: 1,
                decay: 0.005 + Math.random() * 0.008,
                type: Math.random() > 0.3 ? 'lava' : 'rock',
                gravity: 0.04 + Math.random() * 0.02
            };
        }

        function createAshParticle(volcX, volcY) {
            return {
                x: volcX + (Math.random() - 0.5) * 30,
                y: volcY - 20 - Math.random() * 60,
                vx: (Math.random() - 0.5) * 0.8 + 0.3,
                vy: -(0.1 + Math.random() * 0.3),
                size: 15 + Math.random() * 30,
                life: 1,
                decay: 0.002 + Math.random() * 0.003
            };
        }

        // --- Earthquake effects ---
        function triggerEarthquake(x, y) {
            const magnitude = 3.0 + Math.random() * 6.0;
            currentMagnitude = magnitude;
            richterTimer = 180; // ~3 seconds display

            // Show richter display
            const rd = document.getElementById('richterDisplay');
            rd.style.opacity = '1';
            document.getElementById('richterValue').textContent = magnitude.toFixed(1);

            // Color richter based on magnitude
            const rv = document.getElementById('richterValue');
            if (magnitude < 4) rv.style.color = 'rgba(100,255,100,0.9)';
            else if (magnitude < 6) rv.style.color = 'rgba(255,200,80,0.9)';
            else if (magnitude < 8) rv.style.color = 'rgba(255,120,50,0.9)';
            else rv.style.color = 'rgba(255,60,60,0.9)';

            earthquakes.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 150 + magnitude * 30,
                life: 1,
                rings: 3 + Math.floor(magnitude / 2),
                magnitude: magnitude
            });

            // Spawn seismic P-waves and S-waves
            seismicWaves.push({
                x: x, y: y,
                pRadius: 0, sRadius: 0,
                pSpeed: 6, sSpeed: 3.5, // P-waves faster than S-waves
                life: 1,
                magnitude: magnitude
            });

            // Add seismograph disturbance
            const amp = magnitude * 4;
            for (let i = 0; i < 60; i++) {
                const idx = (seismoIndex + i) % seismoData.length;
                seismoData[idx] += amp * Math.sin(i * 0.5) * Math.exp(-i * 0.04);
            }

            // If quake is underwater near convergent zone, trigger tsunami
            if (y > zones.surfaceY - 10 && y < zones.surfaceY + 40 && magnitude > 5) {
                tsunamiWaves.push({
                    originX: x,
                    originY: zones.surfaceY,
                    leftX: x,
                    rightX: x,
                    speed: 1.5 + magnitude * 0.3,
                    amplitude: 3 + magnitude * 1.5,
                    life: 1,
                    decay: 0.003
                });
            }
        }

        // --- Drawing functions ---

        function drawSky() {
            const grad = ctx.createLinearGradient(0, 0, 0, zones.surfaceY);
            grad.addColorStop(0, 'hsl(220, 40%, 8%)');
            grad.addColorStop(0.5, 'hsl(215, 35%, 12%)');
            grad.addColorStop(1, 'hsl(210, 30%, 18%)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, zones.surfaceY);
        }

        function drawTemperatureGradient() {
            // Temperature increases with depth - subtle color overlay
            ctx.save();
            ctx.globalAlpha = 0.12;
            const steps = 20;
            const topY = zones.surfaceY;
            const botY = H;
            const stepH = (botY - topY) / steps;
            for (let i = 0; i < steps; i++) {
                const t = i / steps;
                const y = topY + i * stepH;
                // Cool blue at surface -> warm orange/red at depth
                const r = Math.floor(30 + t * 225);
                const g = Math.floor(60 + t * 40 - t * t * 80);
                const b = Math.floor(120 - t * 100);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(0, y, W, stepH + 1);
            }
            ctx.restore();
        }

        function drawEarthLayers() {
            // Crust layer
            const crustGrad = ctx.createLinearGradient(0, zones.surfaceY, 0, zones.crustBottom);
            crustGrad.addColorStop(0, 'hsl(25, 40%, 28%)');
            crustGrad.addColorStop(0.5, 'hsl(20, 35%, 22%)');
            crustGrad.addColorStop(1, 'hsl(15, 30%, 18%)');
            ctx.fillStyle = crustGrad;
            ctx.fillRect(0, zones.surfaceY, W, zones.crustBottom - zones.surfaceY);

            // Upper mantle
            const mantleGrad = ctx.createLinearGradient(0, zones.crustBottom, 0, zones.mantleBottom);
            mantleGrad.addColorStop(0, 'hsl(10, 45%, 16%)');
            mantleGrad.addColorStop(0.3, 'hsl(8, 50%, 20%)');
            mantleGrad.addColorStop(0.6, 'hsl(5, 55%, 24%)');
            mantleGrad.addColorStop(1, 'hsl(0, 60%, 28%)');
            ctx.fillStyle = mantleGrad;
            ctx.fillRect(0, zones.crustBottom, W, zones.mantleBottom - zones.crustBottom);

            // Lower mantle / core glow
            const coreGrad = ctx.createLinearGradient(0, zones.mantleBottom, 0, H);
            coreGrad.addColorStop(0, 'hsl(0, 60%, 28%)');
            coreGrad.addColorStop(0.4, 'hsl(15, 70%, 30%)');
            coreGrad.addColorStop(1, 'hsl(30, 80%, 35%)');
            ctx.fillStyle = coreGrad;
            ctx.fillRect(0, zones.mantleBottom, W, H - zones.mantleBottom);

            // Core glow from bottom
            const glowGrad = ctx.createRadialGradient(W / 2, H + 100, 0, W / 2, H + 100, H * 0.6);
            glowGrad.addColorStop(0, 'rgba(255, 120, 30, 0.15)');
            glowGrad.addColorStop(0.5, 'rgba(255, 80, 20, 0.06)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 10, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(0, zones.mantleBottom, W, H - zones.mantleBottom);

            // Mantle heat shimmer
            ctx.save();
            ctx.globalAlpha = 0.04;
            for (let i = 0; i < 8; i++) {
                const y = zones.crustBottom + (zones.mantleBottom - zones.crustBottom) * (i / 8);
                const wave = Math.sin(time * 0.5 + i * 0.7) * 15;
                ctx.fillStyle = 'hsl(' + (10 + i * 3) + ', 70%, ' + (25 + i * 3) + '%)';
                ctx.fillRect(0, y + wave, W, (zones.mantleBottom - zones.crustBottom) / 8);
            }
            ctx.restore();
        }

        function drawAgeColoredSeafloor() {
            // Oceanic crust colored by age: red at ridge (young), blue far away (old)
            const cx = zones.divergent.cx;
            const sy = zones.surfaceY;
            const cb = zones.crustBottom;
            const halfW = zones.divergent.right - zones.divergent.left;

            ctx.save();
            ctx.globalAlpha = 0.18;
            const strips = 30;
            for (let i = 0; i < strips; i++) {
                const dist = (i / strips) * halfW * 0.5;
                const age = i / strips;
                // Young = red/orange, Old = blue/purple
                const r = Math.floor(255 - age * 200);
                const g = Math.floor(80 - age * 40);
                const b = Math.floor(20 + age * 180);
                ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                const stripW = halfW * 0.5 / strips;
                // Left side of ridge
                ctx.fillRect(cx - dist - stripW, sy, stripW, (cb - sy) * 0.4);
                // Right side of ridge
                ctx.fillRect(cx + dist, sy, stripW, (cb - sy) * 0.4);
            }
            ctx.restore();

            // Label
            ctx.save();
            ctx.font = '0.45rem monospace';
            ctx.fillStyle = 'rgba(255,120,80,0.3)';
            ctx.textAlign = 'center';
            ctx.fillText('YOUNG', cx, sy + 12);
            const oldLabelX1 = cx - halfW * 0.4;
            const oldLabelX2 = cx + halfW * 0.4;
            ctx.fillStyle = 'rgba(80,120,255,0.3)';
            ctx.fillText('OLD', oldLabelX1, sy + 12);
            ctx.fillText('OLD', oldLabelX2, sy + 12);
            ctx.restore();
        }

        function drawSurface() {
            const sy = zones.surfaceY;

            // Surface line with terrain
            ctx.beginPath();
            ctx.moveTo(0, sy);
            for (let x = 0; x <= W; x += 3) {
                const noise = Math.sin(x * 0.02 + time * 0.2) * 2 + Math.sin(x * 0.005) * 5;
                ctx.lineTo(x, sy + noise);
            }
            ctx.strokeStyle = 'rgba(120, 180, 100, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Ocean water with tsunami waves
            ctx.beginPath();
            ctx.moveTo(0, sy - 1);
            for (let x = 0; x <= W; x += 4) {
                let wave = Math.sin(x * 0.03 + time * 1.5) * 1.5 + Math.sin(x * 0.01 + time) * 2;
                // Add tsunami wave contributions
                for (const tw of tsunamiWaves) {
                    const distL = Math.abs(x - tw.leftX);
                    const distR = Math.abs(x - tw.rightX);
                    const dist = Math.min(distL, distR);
                    if (dist < 60) {
                        wave += tw.amplitude * tw.life * Math.cos(dist * 0.1) * Math.exp(-dist * 0.02);
                    }
                }
                ctx.lineTo(x, sy + wave - 3);
            }
            ctx.strokeStyle = 'rgba(60, 140, 220, 0.25)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawDeepOceanTrench() {
            const cx = zones.convergent.cx;
            const sy = zones.surfaceY;

            // Deep trench - more pronounced
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(cx + 35, sy);
            ctx.quadraticCurveTo(cx + 55, sy + 28, cx + 65, sy + 35);
            ctx.quadraticCurveTo(cx + 75, sy + 28, cx + 95, sy + 10);
            ctx.quadraticCurveTo(cx + 110, sy + 2, cx + 130, sy);

            // Fill trench with dark blue
            ctx.lineTo(cx + 130, sy);
            ctx.lineTo(cx + 35, sy);
            ctx.closePath();
            const trenchGrad = ctx.createLinearGradient(0, sy, 0, sy + 35);
            trenchGrad.addColorStop(0, 'rgba(10, 30, 80, 0.4)');
            trenchGrad.addColorStop(1, 'rgba(5, 15, 50, 0.7)');
            ctx.fillStyle = trenchGrad;
            ctx.fill();

            // Trench edge glow
            ctx.beginPath();
            ctx.moveTo(cx + 35, sy);
            ctx.quadraticCurveTo(cx + 55, sy + 28, cx + 65, sy + 35);
            ctx.quadraticCurveTo(cx + 75, sy + 28, cx + 95, sy + 10);
            ctx.quadraticCurveTo(cx + 110, sy + 2, cx + 130, sy);
            ctx.strokeStyle = 'rgba(30, 80, 160, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Depth markers
            ctx.font = '0.4rem monospace';
            ctx.fillStyle = 'rgba(60,120,200,0.3)';
            ctx.textAlign = 'center';
            ctx.fillText('~11km', cx + 65, sy + 32);
            ctx.fillText('TRENCH', cx + 65, sy + 25);
            ctx.restore();
        }

        function drawDivergentBoundary() {
            const cx = zones.divergent.cx;
            const sy = zones.surfaceY;
            const cb = zones.crustBottom;

            // Rift valley gap
            const spreadFactor = driftProgress;
            const riftWidth = (20 + spreadFactor * 15) + Math.sin(time * 0.3) * 3;

            ctx.save();

            // Rift gap glow (magma visible through gap)
            const riftGlow = ctx.createLinearGradient(cx - riftWidth, sy, cx + riftWidth, sy);
            riftGlow.addColorStop(0, 'rgba(255, 80, 20, 0)');
            riftGlow.addColorStop(0.3, 'rgba(255, 120, 30, 0.4)');
            riftGlow.addColorStop(0.5, 'rgba(255, 160, 50, 0.6)');
            riftGlow.addColorStop(0.7, 'rgba(255, 120, 30, 0.4)');
            riftGlow.addColorStop(1, 'rgba(255, 80, 20, 0)');
            ctx.fillStyle = riftGlow;
            ctx.fillRect(cx - riftWidth, sy - 10, riftWidth * 2, cb - sy + 20);

            // Magma column beneath
            const magmaGlow = ctx.createRadialGradient(cx, (sy + zones.mantleBottom) / 2, 5, cx, (sy + zones.mantleBottom) / 2, 100);
            magmaGlow.addColorStop(0, 'rgba(255, 100, 20, 0.25)');
            magmaGlow.addColorStop(0.5, 'rgba(255, 60, 10, 0.1)');
            magmaGlow.addColorStop(1, 'rgba(255, 40, 5, 0)');
            ctx.fillStyle = magmaGlow;
            ctx.fillRect(cx - 60, sy, 120, zones.mantleBottom - sy);

            // Spreading ridge arrows on surface
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(time * 2) * 0.1;
            drawArrow(cx - 50, sy - 15, cx - 90, sy - 15, 'rgba(255, 150, 80, 0.6)');
            drawArrow(cx + 50, sy - 15, cx + 90, sy - 15, 'rgba(255, 150, 80, 0.6)');
            ctx.restore();

            // Magma rising particles
            for (const p of magmaParticles) {
                const alpha = p.life * (1 - Math.max(0, (zones.surfaceY - p.y) / 30));
                if (alpha <= 0) continue;
                const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
                glow.addColorStop(0, 'rgba(255, ' + (160 + (time * 40 | 0) % 40) + ', ' + (50 + (time * 30 | 0) % 30) + ', ' + (alpha * 0.8) + ')');
                glow.addColorStop(0.5, 'rgba(255, ' + (100 + (time * 30 | 0) % 30) + ', 20, ' + (alpha * 0.3) + ')');
                glow.addColorStop(1, 'rgba(255, 50, 10, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // New crust formation - solidifying magma at edges
            ctx.save();
            ctx.globalAlpha = 0.15;
            for (let i = 0; i < 6; i++) {
                const age = i / 6;
                const dist = 15 + age * 40;
                const h = (cb - sy) * (0.3 + age * 0.7);
                ctx.fillStyle = 'hsl(' + (20 - age * 10) + ', ' + (50 - age * 20) + '%, ' + (20 + age * 5) + '%)';
                ctx.fillRect(cx - dist - 8, sy, 6, h);
                ctx.fillRect(cx + dist + 2, sy, 6, h);
            }
            ctx.restore();
        }

        function drawFossilMatching() {
            if (driftProgress > 0.8) return; // Only visible when plates are closer together
            ctx.save();
            const fadeFactor = 1 - (driftProgress / 0.8);
            ctx.globalAlpha = fadeFactor * 0.7;

            for (const fp of fossilPairs) {
                // Move fossils based on drift
                const spread = driftProgress * 50;
                const lx = fp.leftX - spread;
                const rx = fp.rightX + spread;

                // Draw fossil markers
                ctx.font = 'bold 0.6rem monospace';
                ctx.textAlign = 'center';

                // Left fossil
                ctx.fillStyle = fp.color + '0.8)';
                ctx.beginPath();
                ctx.arc(lx, fp.y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillText(fp.symbol, lx, fp.y + 3);

                // Right fossil (matching)
                ctx.fillStyle = fp.color + '0.8)';
                ctx.beginPath();
                ctx.arc(rx, fp.y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillText(fp.symbol, rx, fp.y + 3);

                // Dashed connection line
                ctx.beginPath();
                ctx.setLineDash([3, 4]);
                ctx.moveTo(lx + 8, fp.y);
                ctx.lineTo(rx - 8, fp.y);
                ctx.strokeStyle = fp.color + '0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Label
            ctx.font = '0.45rem monospace';
            ctx.fillStyle = 'rgba(180,220,140,' + (fadeFactor * 0.5) + ')';
            ctx.textAlign = 'center';
            ctx.fillText('MATCHING FOSSILS (Pangaea Evidence)', zones.divergent.cx, zones.surfaceY - 70);
            ctx.restore();
        }

        function drawConvergentBoundary() {
            const cx = zones.convergent.cx;
            const sy = zones.surfaceY;
            const cb = zones.crustBottom;
            const mb = zones.mantleBottom;

            ctx.save();

            // Subduction slab curve
            ctx.beginPath();
            ctx.moveTo(cx + 80, sy);
            ctx.quadraticCurveTo(cx + 20, sy + 30, cx - 20, cb + 60);
            ctx.quadraticCurveTo(cx - 40, cb + 120, cx - 30, mb - 30);
            ctx.lineWidth = 12;
            ctx.strokeStyle = 'rgba(60, 50, 40, 0.5)';
            ctx.stroke();

            // Inner slab
            ctx.beginPath();
            ctx.moveTo(cx + 80, sy);
            ctx.quadraticCurveTo(cx + 20, sy + 30, cx - 20, cb + 60);
            ctx.quadraticCurveTo(cx - 40, cb + 120, cx - 30, mb - 30);
            ctx.lineWidth = 6;
            ctx.strokeStyle = 'rgba(100, 85, 65, 0.4)';
            ctx.stroke();

            // Mountain building above
            ctx.beginPath();
            ctx.moveTo(cx - 100, sy);
            ctx.lineTo(cx - 70, sy - 25);
            ctx.lineTo(cx - 45, sy - 40 - Math.sin(time * 0.5) * 2);
            ctx.lineTo(cx - 20, sy - 55 - Math.sin(time * 0.3 + 1) * 3);
            ctx.lineTo(cx + 5, sy - 35);
            ctx.lineTo(cx + 30, sy - 15);
            ctx.lineTo(cx + 50, sy);
            ctx.closePath();

            const mtGrad = ctx.createLinearGradient(cx - 50, sy - 55, cx - 50, sy);
            mtGrad.addColorStop(0, 'rgba(140, 130, 110, 0.6)');
            mtGrad.addColorStop(0.3, 'rgba(100, 90, 70, 0.5)');
            mtGrad.addColorStop(1, 'rgba(80, 70, 55, 0.3)');
            ctx.fillStyle = mtGrad;
            ctx.fill();

            // Snow caps
            ctx.beginPath();
            ctx.moveTo(cx - 50, sy - 37);
            ctx.lineTo(cx - 45, sy - 40 - Math.sin(time * 0.5) * 2);
            ctx.lineTo(cx - 38, sy - 34);
            ctx.closePath();
            ctx.fillStyle = 'rgba(220, 230, 240, 0.3)';
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cx - 27, sy - 50);
            ctx.lineTo(cx - 20, sy - 55 - Math.sin(time * 0.3 + 1) * 3);
            ctx.lineTo(cx - 13, sy - 48);
            ctx.closePath();
            ctx.fillStyle = 'rgba(220, 230, 240, 0.35)';
            ctx.fill();

            // Subduction zone particles
            for (const p of subductionParticles) {
                const t = p.t;
                const startX = cx + 80;
                const startY = sy;
                const px = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * (cx + 20) + t * t * (cx - 20);
                const py = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * (sy + 30) + t * t * (cb + 60);

                const alpha = (1 - t) * 0.6;
                const glow = ctx.createRadialGradient(px, py, 0, px, py, p.size * 2);
                glow.addColorStop(0, 'rgba(100, 140, 200, ' + alpha + ')');
                glow.addColorStop(1, 'rgba(60, 100, 160, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(px, py, p.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Convergent arrows
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(time * 2) * 0.1;
            drawArrow(cx + 100, sy - 15, cx + 60, sy - 15, 'rgba(100, 180, 255, 0.6)');
            drawArrow(cx - 80, sy - 15, cx - 40, sy - 15, 'rgba(100, 180, 255, 0.6)');
            ctx.restore();

            ctx.restore();
        }

        // --- VOLCANIC ERUPTION (full animation) ---
        function drawVolcanicEruption() {
            const cx = zones.convergent.cx;
            const sy = zones.surfaceY;
            const volcX = cx - 20;
            const volcY = sy - 55 - Math.sin(time * 0.3 + 1) * 3;

            // Eruption cycle: erupt every ~8 seconds for ~3 seconds
            const cycle = time % 8;
            const isErupting = cycle < 3;

            if (isErupting) {
                // Spawn eruption particles
                if (Math.random() < 0.5) {
                    eruptionParticles.push(createEruptionParticle(volcX, volcY));
                }
                // Spawn ash clouds
                if (Math.random() < 0.15) {
                    ashParticles.push(createAshParticle(volcX, volcY));
                }
                // Spawn lava flow
                if (Math.random() < 0.08) {
                    lavaFlows.push({
                        x: volcX + (Math.random() - 0.5) * 10,
                        y: volcY + 5,
                        vx: (Math.random() - 0.5) * 0.8,
                        vy: 0.3 + Math.random() * 0.3,
                        life: 1,
                        decay: 0.003,
                        size: 2 + Math.random() * 2
                    });
                }

                // Eruption column glow
                ctx.save();
                const colGlow = ctx.createRadialGradient(volcX, volcY - 30, 0, volcX, volcY - 30, 50);
                colGlow.addColorStop(0, 'rgba(255, 150, 50, ' + (0.3 * (1 - cycle / 3)) + ')');
                colGlow.addColorStop(0.5, 'rgba(255, 80, 20, ' + (0.15 * (1 - cycle / 3)) + ')');
                colGlow.addColorStop(1, 'rgba(255, 40, 10, 0)');
                ctx.fillStyle = colGlow;
                ctx.beginPath();
                ctx.arc(volcX, volcY - 30, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw ash cloud (pyroclastic)
            for (const a of ashParticles) {
                if (a.life <= 0) continue;
                ctx.save();
                ctx.globalAlpha = a.life * 0.3;
                const ashGrad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.size);
                ashGrad.addColorStop(0, 'rgba(80, 70, 60, 0.5)');
                ashGrad.addColorStop(0.5, 'rgba(60, 55, 50, 0.3)');
                ashGrad.addColorStop(1, 'rgba(40, 35, 30, 0)');
                ctx.fillStyle = ashGrad;
                ctx.beginPath();
                ctx.arc(a.x, a.y, a.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw eruption particles
            for (const ep of eruptionParticles) {
                if (ep.life <= 0) continue;
                ctx.save();
                if (ep.type === 'lava') {
                    const glow = ctx.createRadialGradient(ep.x, ep.y, 0, ep.x, ep.y, ep.size * 2);
                    glow.addColorStop(0, 'rgba(255, ' + (150 + Math.floor(ep.life * 80)) + ', 30, ' + (ep.life * 0.9) + ')');
                    glow.addColorStop(1, 'rgba(255, 60, 10, 0)');
                    ctx.fillStyle = glow;
                } else {
                    ctx.fillStyle = 'rgba(100, 80, 60, ' + (ep.life * 0.7) + ')';
                }
                ctx.beginPath();
                ctx.arc(ep.x, ep.y, ep.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw lava flows down mountain
            for (const lf of lavaFlows) {
                if (lf.life <= 0) continue;
                ctx.save();
                const glow = ctx.createRadialGradient(lf.x, lf.y, 0, lf.x, lf.y, lf.size * 3);
                glow.addColorStop(0, 'rgba(255, 120, 20, ' + (lf.life * 0.7) + ')');
                glow.addColorStop(0.6, 'rgba(200, 50, 10, ' + (lf.life * 0.3) + ')');
                glow.addColorStop(1, 'rgba(100, 20, 5, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(lf.x, lf.y, lf.size * 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Volcano crater glow (always present, stronger when erupting)
            const craterGlow = isErupting ? 0.5 : 0.15;
            ctx.save();
            const cGlow = ctx.createRadialGradient(volcX, volcY, 0, volcX, volcY, 12);
            cGlow.addColorStop(0, 'rgba(255, 140, 40, ' + craterGlow + ')');
            cGlow.addColorStop(1, 'rgba(255, 60, 10, 0)');
            ctx.fillStyle = cGlow;
            ctx.beginPath();
            ctx.arc(volcX, volcY, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // --- HOT SPOT ---
        function drawHotspot() {
            const hx = zones.transform.cx - 60;
            const sy = zones.surfaceY;
            const mb = zones.mantleBottom;

            // Plume column from deep mantle
            ctx.save();
            const plumeGrad = ctx.createRadialGradient(hx, (mb + H) / 2, 5, hx, (mb + H) / 2, 60);
            plumeGrad.addColorStop(0, 'rgba(255, 100, 20, 0.2)');
            plumeGrad.addColorStop(0.5, 'rgba(255, 60, 10, 0.08)');
            plumeGrad.addColorStop(1, 'rgba(255, 40, 5, 0)');
            ctx.fillStyle = plumeGrad;
            ctx.fillRect(hx - 40, sy, 80, H - sy);

            // Mushroom head of plume at base of lithosphere
            const headY = zones.crustBottom + 20;
            const headGlow = ctx.createRadialGradient(hx, headY, 0, hx, headY, 50);
            headGlow.addColorStop(0, 'rgba(255, 120, 30, 0.25)');
            headGlow.addColorStop(0.6, 'rgba(255, 80, 20, 0.08)');
            headGlow.addColorStop(1, 'rgba(255, 40, 5, 0)');
            ctx.fillStyle = headGlow;
            ctx.beginPath();
            ctx.ellipse(hx, headY, 50, 30, 0, 0, Math.PI * 2);
            ctx.fill();

            // Plume particles rising
            for (const p of hotspotPlumes) {
                if (p.life <= 0) continue;
                const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
                glow.addColorStop(0, 'rgba(255, ' + (100 + Math.floor(p.life * 60)) + ', 20, ' + (p.life * 0.5) + ')');
                glow.addColorStop(1, 'rgba(255, 50, 10, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // Draw island chain
            drawIslandChain();
        }

        function drawIslandChain() {
            const sy = zones.surfaceY;
            ctx.save();

            for (const island of islandChain) {
                const ageFade = 1 - island.age * 0.1;
                // Island shape
                ctx.beginPath();
                ctx.moveTo(island.x - island.size, sy);
                ctx.quadraticCurveTo(island.x - island.size * 0.5, sy - island.height, island.x, sy - island.height - Math.sin(time * 0.5 + island.age) * 1);
                ctx.quadraticCurveTo(island.x + island.size * 0.5, sy - island.height, island.x + island.size, sy);
                ctx.closePath();

                const isGrad = ctx.createLinearGradient(0, sy - island.height, 0, sy);
                isGrad.addColorStop(0, 'rgba(' + (120 + island.age * 10) + ',' + (140 - island.age * 5) + ',' + (90 + island.age * 5) + ',' + (ageFade * 0.6) + ')');
                isGrad.addColorStop(1, 'rgba(80, 70, 55, ' + (ageFade * 0.3) + ')');
                ctx.fillStyle = isGrad;
                ctx.fill();

                // Active volcano on youngest island
                if (island.age === 0) {
                    const vGlow = ctx.createRadialGradient(island.x, sy - island.height, 0, island.x, sy - island.height, 6);
                    vGlow.addColorStop(0, 'rgba(255, 120, 30, ' + (0.4 + Math.sin(time * 3) * 0.2) + ')');
                    vGlow.addColorStop(1, 'rgba(255, 60, 10, 0)');
                    ctx.fillStyle = vGlow;
                    ctx.beginPath();
                    ctx.arc(island.x, sy - island.height, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Label
            ctx.font = '0.45rem monospace';
            ctx.fillStyle = 'rgba(255,150,80,0.3)';
            ctx.textAlign = 'center';
            ctx.fillText('HOTSPOT ISLAND CHAIN', zones.transform.cx - 60, sy - 30);

            // Direction arrow
            ctx.globalAlpha = 0.25;
            drawArrow(zones.transform.cx - 20, sy - 22, zones.transform.cx - 100, sy - 22, 'rgba(255,150,80,0.5)');
            ctx.font = '0.4rem monospace';
            ctx.fillStyle = 'rgba(255,150,80,0.25)';
            ctx.fillText('Plate Motion', zones.transform.cx - 60, sy - 26);

            ctx.restore();
        }

        function drawTransformBoundary() {
            const cx = zones.transform.cx;
            const sy = zones.surfaceY;
            const cb = zones.crustBottom;

            ctx.save();

            // Fault line - jagged
            ctx.beginPath();
            ctx.moveTo(cx, sy - 5);
            for (let y = sy; y <= cb + 10; y += 6) {
                const jag = Math.sin(y * 0.3 + time) * 3 + (Math.random() - 0.5) * 2;
                ctx.lineTo(cx + jag, y);
            }
            ctx.strokeStyle = 'rgba(200, 180, 100, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Fault glow
            const faultGlow = ctx.createRadialGradient(cx, (sy + cb) / 2, 0, cx, (sy + cb) / 2, 40);
            faultGlow.addColorStop(0, 'rgba(200, 180, 100, 0.08)');
            faultGlow.addColorStop(1, 'rgba(200, 180, 100, 0)');
            ctx.fillStyle = faultGlow;
            ctx.fillRect(cx - 40, sy, 80, cb - sy);

            // Opposing plate arrows
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(time * 2) * 0.1;
            drawArrow(cx - 40, sy - 15, cx - 80, sy - 15, 'rgba(200, 180, 100, 0.6)');
            drawArrow(cx + 40, sy - 15, cx + 80, sy - 15, 'rgba(200, 180, 100, 0.6)');
            ctx.restore();

            // Stress buildup visualization
            const stressPhase = Math.sin(time * 0.8);
            if (stressPhase > 0.85) {
                const flashAlpha = (stressPhase - 0.85) / 0.15 * 0.3;
                ctx.fillStyle = 'rgba(255, 255, 200, ' + flashAlpha + ')';
                ctx.beginPath();
                ctx.arc(cx, sy + (cb - sy) * 0.3, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            // Transform particles
            for (const p of transformParticles) {
                const alpha = 0.3 + Math.sin(p.life * Math.PI * 2) * 0.2;
                ctx.fillStyle = 'rgba(200, 180, 100, ' + alpha + ')';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawConvectionCells() {
            for (const p of convectionParticles) {
                const x = p.cx + Math.cos(p.angle) * p.rx;
                const y = p.cy + Math.sin(p.angle) * p.ry;

                const depthRatio = (y - zones.crustBottom) / (zones.mantleBottom - zones.crustBottom);
                const r = 180 + depthRatio * 75;
                const g = 60 + (1 - depthRatio) * 40;
                const b = 20;
                const alpha = 0.25 + Math.sin(p.angle * 2 + time) * 0.1;

                const trailAngle = p.angle - p.speed * 15;
                const tx = p.cx + Math.cos(trailAngle) * p.rx;
                const ty = p.cy + Math.sin(trailAngle) * p.ry;

                ctx.beginPath();
                ctx.moveTo(tx, ty);
                ctx.lineTo(x, y);
                ctx.strokeStyle = 'rgba(' + Math.floor(r) + ', ' + Math.floor(g) + ', ' + b + ', ' + (alpha * 0.4) + ')';
                ctx.lineWidth = p.size * 0.8;
                ctx.stroke();

                const glow = ctx.createRadialGradient(x, y, 0, x, y, p.size * 2.5);
                glow.addColorStop(0, 'rgba(' + Math.floor(r) + ', ' + Math.floor(g) + ', ' + b + ', ' + alpha + ')');
                glow.addColorStop(1, 'rgba(' + Math.floor(r) + ', ' + Math.floor(g) + ', ' + b + ', 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(x, y, p.size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSeismicWaves() {
            for (const sw of seismicWaves) {
                if (sw.life <= 0) continue;
                ctx.save();

                // P-wave (faster, compression wave) - circular, subtle
                if (sw.pRadius > 0) {
                    ctx.beginPath();
                    ctx.arc(sw.x, sw.y, sw.pRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(100, 200, 255, ' + (sw.life * 0.25) + ')';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // P-wave label
                    if (sw.pRadius > 30 && sw.pRadius < 200) {
                        ctx.font = '0.45rem monospace';
                        ctx.fillStyle = 'rgba(100,200,255,' + (sw.life * 0.4) + ')';
                        ctx.fillText('P-wave', sw.x + sw.pRadius * 0.7, sw.y - sw.pRadius * 0.7);
                    }
                }

                // S-wave (slower, shear wave) - circular, different color
                if (sw.sRadius > 0) {
                    ctx.beginPath();
                    ctx.arc(sw.x, sw.y, sw.sRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 150, 100, ' + (sw.life * 0.3) + ')';
                    ctx.lineWidth = 2.5;
                    // Wavy line for S-wave
                    ctx.stroke();

                    // S-wave label
                    if (sw.sRadius > 20 && sw.sRadius < 150) {
                        ctx.font = '0.45rem monospace';
                        ctx.fillStyle = 'rgba(255,150,100,' + (sw.life * 0.4) + ')';
                        ctx.fillText('S-wave', sw.x + sw.sRadius * 0.5, sw.y + sw.sRadius * 0.5);
                    }
                }

                ctx.restore();
            }
        }

        function drawTsunamiWaves() {
            for (const tw of tsunamiWaves) {
                if (tw.life <= 0) continue;
                ctx.save();
                ctx.globalAlpha = tw.life * 0.5;

                // Left-propagating wave crest
                ctx.beginPath();
                ctx.arc(tw.leftX, tw.originY - 3, tw.amplitude * tw.life * 2, 0, Math.PI, true);
                ctx.strokeStyle = 'rgba(60, 180, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Right-propagating wave crest
                ctx.beginPath();
                ctx.arc(tw.rightX, tw.originY - 3, tw.amplitude * tw.life * 2, 0, Math.PI, true);
                ctx.strokeStyle = 'rgba(60, 180, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Tsunami label
                if (tw.life > 0.5) {
                    ctx.font = 'bold 0.5rem monospace';
                    ctx.fillStyle = 'rgba(60,180,255,' + (tw.life * 0.5) + ')';
                    ctx.textAlign = 'center';
                    ctx.fillText('TSUNAMI', (tw.leftX + tw.rightX) / 2, tw.originY - 20);
                }

                ctx.restore();
            }
        }

        function drawMineralDeposits() {
            ctx.save();
            for (const m of mineralDeposits) {
                const pulse = 0.6 + Math.sin(time * 2 + m.x * 0.1) * 0.3;
                // Diamond shape
                ctx.beginPath();
                ctx.moveTo(m.x, m.y - m.size);
                ctx.lineTo(m.x + m.size, m.y);
                ctx.lineTo(m.x, m.y + m.size);
                ctx.lineTo(m.x - m.size, m.y);
                ctx.closePath();
                ctx.fillStyle = m.color + (pulse * 0.6) + ')';
                ctx.fill();

                // Glow
                const glow = ctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, m.size * 3);
                glow.addColorStop(0, m.color + (pulse * 0.15) + ')');
                glow.addColorStop(1, m.color + '0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.size * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawBoundaryDividers() {
            const thirdW = W / 3;
            ctx.save();
            ctx.setLineDash([4, 8]);
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.08)';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(thirdW, 0);
            ctx.lineTo(thirdW, H);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(thirdW * 2, 0);
            ctx.lineTo(thirdW * 2, H);
            ctx.stroke();

            ctx.restore();
        }

        function drawLabels() {
            ctx.save();
            ctx.textAlign = 'center';

            const labelY = zones.surfaceY - 50;

            // Divergent
            ctx.font = '600 0.75rem monospace';
            ctx.fillStyle = 'rgba(255, 150, 80, 0.5)';
            ctx.fillText('DIVERGENT', zones.divergent.cx, labelY);
            ctx.font = '0.55rem monospace';
            ctx.fillStyle = 'rgba(255, 150, 80, 0.3)';
            ctx.fillText('Mid-Ocean Ridge', zones.divergent.cx, labelY + 14);

            // Convergent
            ctx.font = '600 0.75rem monospace';
            ctx.fillStyle = 'rgba(100, 180, 255, 0.5)';
            ctx.fillText('CONVERGENT', zones.convergent.cx, labelY);
            ctx.font = '0.55rem monospace';
            ctx.fillStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.fillText('Subduction Zone', zones.convergent.cx, labelY + 14);

            // Transform
            ctx.font = '600 0.75rem monospace';
            ctx.fillStyle = 'rgba(200, 180, 100, 0.5)';
            ctx.fillText('TRANSFORM', zones.transform.cx, labelY);
            ctx.font = '0.55rem monospace';
            ctx.fillStyle = 'rgba(200, 180, 100, 0.3)';
            ctx.fillText('Strike-Slip Fault', zones.transform.cx, labelY + 14);

            // Layer labels
            ctx.textAlign = 'left';
            ctx.font = '0.6rem monospace';

            const layerX = 12;
            ctx.fillStyle = 'rgba(120, 180, 100, 0.3)';
            ctx.fillText('CRUST', layerX, zones.surfaceY + 18);

            ctx.fillStyle = 'rgba(200, 100, 50, 0.25)';
            ctx.fillText('UPPER MANTLE', layerX, zones.crustBottom + 20);

            ctx.fillStyle = 'rgba(220, 120, 40, 0.2)';
            ctx.fillText('LOWER MANTLE', layerX, zones.mantleBottom + 18);

            // Temperature scale on far right
            ctx.textAlign = 'right';
            ctx.font = '0.45rem monospace';
            const tempX = W - 12;
            ctx.fillStyle = 'rgba(100,150,200,0.3)';
            ctx.fillText('~20\u00B0C', tempX, zones.surfaceY + 15);
            ctx.fillStyle = 'rgba(200,120,60,0.25)';
            ctx.fillText('~1000\u00B0C', tempX, zones.crustBottom + 15);
            ctx.fillStyle = 'rgba(220,100,40,0.2)';
            ctx.fillText('~3700\u00B0C', tempX, zones.mantleBottom + 15);
            ctx.fillStyle = 'rgba(255,130,40,0.2)';
            ctx.fillText('~5500\u00B0C', tempX, H - 10);

            // Feature labels
            ctx.textAlign = 'center';
            ctx.font = '0.5rem monospace';

            ctx.fillStyle = 'rgba(255, 150, 80, 0.25)';
            ctx.fillText('Magma Rising', zones.divergent.cx, zones.crustBottom + 40);

            ctx.fillStyle = 'rgba(100, 180, 255, 0.25)';
            ctx.fillText('Oceanic Plate', zones.convergent.cx + 70, zones.surfaceY + 45);
            ctx.fillText('Subducting', zones.convergent.cx + 70, zones.surfaceY + 57);

            ctx.fillStyle = 'rgba(140, 130, 110, 0.35)';
            ctx.fillText('Mountains', zones.convergent.cx - 20, zones.surfaceY - 65);

            ctx.fillStyle = 'rgba(200, 80, 30, 0.15)';
            ctx.fillText('Convection Cells', W / 2, (zones.crustBottom + zones.mantleBottom) / 2 + 50);

            // Mineral deposit labels
            ctx.font = '0.4rem monospace';
            ctx.fillStyle = 'rgba(200,160,60,0.3)';
            ctx.fillText('Cu/Zn deposits', zones.divergent.cx, zones.surfaceY + 60);
            ctx.fillStyle = 'rgba(255,215,0,0.3)';
            ctx.fillText('Au/Sn ore', zones.convergent.cx - 40, zones.surfaceY - 20);
            ctx.fillStyle = 'rgba(100,180,120,0.25)';
            ctx.fillText('Serpentinite', zones.transform.cx, zones.surfaceY + 50);

            ctx.restore();
        }

        function drawEarthquakes() {
            for (const eq of earthquakes) {
                for (let r = 0; r < eq.rings; r++) {
                    const ringRadius = eq.radius - r * 25;
                    if (ringRadius <= 0) continue;
                    const alpha = eq.life * 0.4 * (1 - r / eq.rings);
                    ctx.beginPath();
                    ctx.arc(eq.x, eq.y, ringRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 220, 100, ' + alpha + ')';
                    ctx.lineWidth = 2 - r * 0.4;
                    ctx.stroke();
                }

                // Central flash
                if (eq.life > 0.8) {
                    const flashAlpha = (eq.life - 0.8) / 0.2 * 0.5;
                    const glow = ctx.createRadialGradient(eq.x, eq.y, 0, eq.x, eq.y, 20);
                    glow.addColorStop(0, 'rgba(255, 255, 200, ' + flashAlpha + ')');
                    glow.addColorStop(1, 'rgba(255, 220, 100, 0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(eq.x, eq.y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawSeismograph() {
            // Clear seismograph canvas
            seismoCtx.fillStyle = 'rgba(0,10,20,0.9)';
            seismoCtx.fillRect(0, 0, 200, 65);

            // Grid lines
            seismoCtx.strokeStyle = 'rgba(100,200,255,0.08)';
            seismoCtx.lineWidth = 0.5;
            for (let y = 10; y < 65; y += 15) {
                seismoCtx.beginPath();
                seismoCtx.moveTo(0, y);
                seismoCtx.lineTo(200, y);
                seismoCtx.stroke();
            }

            // Draw seismograph trace
            seismoCtx.beginPath();
            const midY = 32;
            for (let i = 0; i < 200; i++) {
                const idx = (seismoIndex - 200 + i + seismoData.length) % seismoData.length;
                const val = seismoData[idx];
                const y = midY + Math.max(-28, Math.min(28, val));
                if (i === 0) seismoCtx.moveTo(i, y);
                else seismoCtx.lineTo(i, y);
            }
            seismoCtx.strokeStyle = 'rgba(100,255,100,0.7)';
            seismoCtx.lineWidth = 1.2;
            seismoCtx.stroke();

            // Needle position indicator
            seismoCtx.fillStyle = 'rgba(255,100,100,0.8)';
            seismoCtx.fillRect(199, 0, 1, 65);
        }

        function drawArrow(x1, y1, x2, y2, color) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const headLen = 8;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - 0.4), y2 - headLen * Math.sin(angle - 0.4));
            ctx.lineTo(x2 - headLen * Math.cos(angle + 0.4), y2 - headLen * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        function drawCrustTexture() {
            ctx.save();
            ctx.globalAlpha = 0.04;
            for (let x = 0; x < W; x += 40) {
                for (let y = zones.surfaceY; y < zones.crustBottom; y += 15) {
                    const noise = Math.sin(x * 0.05 + y * 0.03) * 0.5 + 0.5;
                    ctx.fillStyle = noise > 0.5 ? 'rgba(180, 160, 120, 1)' : 'rgba(80, 70, 55, 1)';
                    ctx.fillRect(x + Math.sin(y * 0.1) * 5, y, 35, 12);
                }
            }
            ctx.restore();
        }

        // Continental drift visualization at top
        function drawContinentalDrift() {
            if (driftProgress >= 0.95) return; // Hide when at present day
            ctx.save();

            const cy = 20;
            const spread = driftProgress * 80;
            const alpha = (1 - driftProgress) * 0.4 + 0.1;

            // Simplified Pangaea -> drifting continents at top of screen
            ctx.globalAlpha = alpha;
            ctx.font = '0.4rem monospace';
            ctx.textAlign = 'center';

            // Left mass (Americas)
            const leftX = W * 0.35 - spread;
            ctx.fillStyle = 'rgba(120,160,90,0.5)';
            ctx.beginPath();
            ctx.ellipse(leftX, cy + 8, 30 - driftProgress * 5, 12, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(120,160,90,0.3)';
            ctx.fillText('Americas', leftX, cy + 25);

            // Right mass (Afro-Eurasia)
            const rightX = W * 0.55 + spread;
            ctx.fillStyle = 'rgba(160,140,90,0.5)';
            ctx.beginPath();
            ctx.ellipse(rightX, cy + 6, 40 - driftProgress * 8, 14, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(160,140,90,0.3)';
            ctx.fillText('Afro-Eurasia', rightX, cy + 25);

            // Gondwana remnants below
            const bottomX = W * 0.5 + spread * 0.3;
            ctx.fillStyle = 'rgba(140,120,80,0.4)';
            ctx.beginPath();
            ctx.ellipse(bottomX, cy + 15, 20, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // --- Update functions ---

        function updateParticles() {
            // Convection
            for (const p of convectionParticles) {
                p.angle += p.speed;
            }

            // Magma particles
            for (let i = 0; i < magmaParticles.length; i++) {
                const p = magmaParticles[i];
                p.y += p.vy;
                p.x += p.vx + Math.sin(time * 2 + p.y * 0.05) * 0.2;
                p.life -= 1 / p.maxLife;

                if (p.life <= 0 || p.y < zones.surfaceY - 30) {
                    magmaParticles[i] = createMagmaParticle();
                }
            }

            // Subduction particles
            for (let i = 0; i < subductionParticles.length; i++) {
                const p = subductionParticles[i];
                p.t += p.speed;
                if (p.t >= 1) {
                    subductionParticles[i] = createSubductionParticle();
                    subductionParticles[i].t = 0;
                }
            }

            // Transform particles
            for (let i = 0; i < transformParticles.length; i++) {
                const p = transformParticles[i];
                p.x += p.vx;
                p.life += 0.01;
                if (Math.abs(p.x - p.baseX) > 30 || p.life > 1) {
                    transformParticles[i] = createTransformParticle();
                }
            }

            // Hotspot plumes
            for (let i = 0; i < hotspotPlumes.length; i++) {
                const p = hotspotPlumes[i];
                p.y += p.vy;
                p.x += p.vx + Math.sin(time * 1.5 + p.y * 0.03) * 0.15;
                p.life -= 1 / p.maxLife;
                if (p.life <= 0 || p.y < zones.crustBottom) {
                    hotspotPlumes[i] = createHotspotPlume();
                }
            }

            // Eruption particles
            for (let i = eruptionParticles.length - 1; i >= 0; i--) {
                const p = eruptionParticles[i];
                p.vy += p.gravity;
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                if (p.life <= 0 || p.y > zones.surfaceY + 20) {
                    eruptionParticles.splice(i, 1);
                }
            }
            // Cap eruption particles
            if (eruptionParticles.length > 80) {
                eruptionParticles.splice(0, eruptionParticles.length - 80);
            }

            // Ash particles
            for (let i = ashParticles.length - 1; i >= 0; i--) {
                const a = ashParticles[i];
                a.x += a.vx;
                a.y += a.vy;
                a.size += 0.15;
                a.life -= a.decay;
                if (a.life <= 0) {
                    ashParticles.splice(i, 1);
                }
            }
            if (ashParticles.length > 20) {
                ashParticles.splice(0, ashParticles.length - 20);
            }

            // Lava flows
            for (let i = lavaFlows.length - 1; i >= 0; i--) {
                const lf = lavaFlows[i];
                lf.x += lf.vx;
                lf.y += lf.vy;
                lf.life -= lf.decay;
                // Slow down as it cools
                lf.vy *= 0.998;
                if (lf.life <= 0 || lf.y > zones.surfaceY + 5) {
                    lavaFlows.splice(i, 1);
                }
            }
            if (lavaFlows.length > 40) {
                lavaFlows.splice(0, lavaFlows.length - 40);
            }

            // Earthquakes
            for (let i = earthquakes.length - 1; i >= 0; i--) {
                const eq = earthquakes[i];
                eq.radius += 3;
                eq.life -= 0.012;
                if (eq.life <= 0) {
                    earthquakes.splice(i, 1);
                }
            }

            // Seismic waves
            for (let i = seismicWaves.length - 1; i >= 0; i--) {
                const sw = seismicWaves[i];
                sw.pRadius += sw.pSpeed;
                sw.sRadius += sw.sSpeed;
                sw.life -= 0.005;
                if (sw.life <= 0) {
                    seismicWaves.splice(i, 1);
                }
            }

            // Tsunami waves
            for (let i = tsunamiWaves.length - 1; i >= 0; i--) {
                const tw = tsunamiWaves[i];
                tw.leftX -= tw.speed;
                tw.rightX += tw.speed;
                tw.life -= tw.decay;
                if (tw.life <= 0) {
                    tsunamiWaves.splice(i, 1);
                }
            }

            // Seismograph update
            seismoData[seismoIndex] = seismoData[seismoIndex] * 0.92 + (Math.random() - 0.5) * 0.5;
            seismoIndex = (seismoIndex + 1) % seismoData.length;

            // Richter display fade
            if (richterTimer > 0) {
                richterTimer--;
                if (richterTimer <= 0) {
                    document.getElementById('richterDisplay').style.opacity = '0';
                }
            }

            // Periodically auto-trigger small quakes at boundaries
            if (Math.random() < 0.003) {
                const zone = Math.floor(Math.random() * 3);
                let qx, qy;
                if (zone === 0) {
                    qx = zones.divergent.cx + (Math.random() - 0.5) * 40;
                    qy = zones.surfaceY + Math.random() * (zones.crustBottom - zones.surfaceY);
                } else if (zone === 1) {
                    qx = zones.convergent.cx + (Math.random() - 0.5) * 60;
                    qy = zones.surfaceY + Math.random() * (zones.crustBottom - zones.surfaceY);
                } else {
                    qx = zones.transform.cx + (Math.random() - 0.5) * 20;
                    qy = zones.surfaceY + Math.random() * (zones.crustBottom - zones.surfaceY);
                }
                // Small auto quakes
                const mag = 2 + Math.random() * 3;
                earthquakes.push({
                    x: qx, y: qy, radius: 0,
                    maxRadius: 60 + mag * 15, life: 1,
                    rings: 2, magnitude: mag
                });
                seismicWaves.push({
                    x: qx, y: qy, pRadius: 0, sRadius: 0,
                    pSpeed: 4, sSpeed: 2.3, life: 0.6, magnitude: mag
                });
                // Small seismograph disturbance
                const amp = mag * 2;
                for (let i = 0; i < 30; i++) {
                    const idx = (seismoIndex + i) % seismoData.length;
                    seismoData[idx] += amp * Math.sin(i * 0.7) * Math.exp(-i * 0.06);
                }
            }
        }

        // --- Main loop ---

        function draw() {
            ctx.clearRect(0, 0, W, H);

            drawSky();
            drawEarthLayers();
            drawTemperatureGradient();
            drawCrustTexture();
            drawAgeColoredSeafloor();
            drawConvectionCells();
            drawSurface();
            drawBoundaryDividers();
            drawDivergentBoundary();
            drawFossilMatching();
            drawDeepOceanTrench();
            drawConvergentBoundary();
            drawVolcanicEruption();
            drawHotspot();
            drawTransformBoundary();
            drawMineralDeposits();
            drawSeismicWaves();
            drawEarthquakes();
            drawTsunamiWaves();
            drawLabels();
            drawContinentalDrift();
            drawSeismograph();
        }

        function animate() {
            if (!paused) {
                time += 0.016;
                updateParticles();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // --- Events ---

        canvas.addEventListener('click', function(e) {
            triggerEarthquake(e.clientX, e.clientY);
            var hint = document.getElementById('hint');
            if (hint) hint.style.opacity = '0';
        });

        window.addEventListener('resize', function() {
            resize();
        });

        // Expose reset and pause for enhance.js
        window.reset = function() {
            time = 0;
            earthquakes = [];
            seismicWaves = [];
            tsunamiWaves = [];
            eruptionParticles = [];
            ashParticles = [];
            lavaFlows = [];
            currentMagnitude = 0;
            richterTimer = 0;
            seismoData = new Float32Array(200);
            seismoIndex = 0;
            driftProgress = 1.0;
            timelineSlider.value = 100;
            eraLabel.textContent = 'Present Day';
            document.getElementById('richterDisplay').style.opacity = '0';
            initParticles();
            initFossils();
            initMinerals();
            initIslandChain();
        };

        window.togglePause = function() {
            paused = !paused;
        };

        // --- Init ---
        resize();
        animate();

        // Fade hint after a few seconds
        setTimeout(function() {
            var hint = document.getElementById('hint');
            if (hint) hint.style.opacity = '0';
        }, 8000);

    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
