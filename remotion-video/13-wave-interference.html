<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Interference Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: rgba(100, 200, 255, 0.8);
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #canvas3d {
            z-index: 1;
            display: none;
        }

        #canvas2d {
            z-index: 1;
        }

        /* Vignette + scanlines + grain overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .vignette {
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.6) 100%);
        }

        .scanlines {
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.06) 2px,
                rgba(0,0,0,0.06) 4px
            );
            z-index: 6;
        }

        .grain {
            z-index: 7;
            opacity: 0.04;
            animation: grainAnim 0.5s steps(6) infinite;
        }

        @keyframes grainAnim {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            30% { transform: translate(3%, -15%); }
            50% { transform: translate(12%, 9%); }
            70% { transform: translate(9%, 4%); }
            90% { transform: translate(-1%, 7%); }
        }

        /* Controls panel */
        .controls {
            position: fixed;
            bottom: 1.2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            display: flex;
            gap: 1rem;
            align-items: center;
            padding: 0.6rem 1.2rem;
            background: rgba(0, 10, 20, 0.75);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.15);
            border-radius: 12px;
            font-size: 0.7rem;
            user-select: none;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 96vw;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            align-items: center;
        }

        .control-group label {
            color: rgba(100, 200, 255, 0.5);
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 3px;
            background: rgba(100, 200, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(100, 200, 255, 0.8);
            cursor: pointer;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(100, 200, 255, 0.8);
            border: none;
            cursor: pointer;
        }

        .control-value {
            color: rgba(100, 200, 255, 0.7);
            font-size: 0.65rem;
            min-width: 2rem;
            text-align: center;
        }

        /* Toolbar (mode buttons) */
        .toolbar {
            position: fixed;
            top: 3.5rem;
            right: 1rem;
            z-index: 15;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .toolbar button, .presets button {
            background: rgba(0, 10, 20, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.2);
            color: rgba(100, 200, 255, 0.7);
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }

        .toolbar button:hover, .presets button:hover {
            border-color: rgba(100, 200, 255, 0.5);
            color: rgba(100, 200, 255, 1);
        }

        .toolbar button.active {
            background: rgba(50, 120, 180, 0.4);
            border-color: rgba(100, 200, 255, 0.6);
            color: rgba(200, 240, 255, 1);
        }

        /* Presets */
        .presets {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }

        .presets button.active {
            background: rgba(50, 120, 180, 0.4);
            border-color: rgba(100, 200, 255, 0.6);
        }

        /* Info overlay */
        .info {
            position: fixed;
            top: 3.5rem;
            left: 1rem;
            z-index: 15;
            text-align: left;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.4);
            line-height: 1.6;
            pointer-events: none;
            max-width: 260px;
        }

        .info .source-count {
            font-size: 1rem;
            color: rgba(100, 200, 255, 0.7);
            font-weight: bold;
        }

        .equation {
            font-size: 0.6rem;
            color: rgba(100, 200, 255, 0.35);
            margin-top: 0.3rem;
            font-style: italic;
            line-height: 1.4;
        }

        /* Intensity detector graph */
        .intensity-graph {
            position: fixed;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 14;
            pointer-events: none;
            display: none;
        }

        .intensity-graph.visible {
            display: block;
        }

        /* Hint text */
        .hint {
            position: fixed;
            bottom: 5.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.3);
            text-align: center;
            pointer-events: none;
            transition: opacity 1.5s ease;
        }

        .hint.hidden { opacity: 0; }

        @media (max-width: 700px) {
            .controls { gap: 0.5rem; padding: 0.4rem 0.7rem; }
            .control-group input[type="range"] { width: 55px; }
            .toolbar { top: auto; bottom: 5rem; right: 0.5rem; flex-direction: row; flex-wrap: wrap; max-width: 50vw; justify-content: flex-end; }
            .presets { top: 0.5rem; }
            .info { font-size: 0.55rem; max-width: 180px; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>

    <canvas id="canvas2d"></canvas>
    <canvas id="canvas3d"></canvas>
    <div class="overlay vignette"></div>
    <div class="overlay scanlines"></div>
    <canvas id="grainCanvas" class="overlay grain"></canvas>

    <!-- Presets -->
    <div class="presets">
        <button id="presetDefault" class="active" title="Default two-source interference">Two Sources</button>
        <button id="presetDoubleSlit" title="Double-slit diffraction experiment">Double Slit</button>
        <button id="presetDoppler" title="Moving source with Doppler effect">Doppler</button>
        <button id="presetMultiFreq" title="Sources with different frequencies">Multi-Freq</button>
        <button id="presetReflection" title="Wave reflection off walls">Reflection</button>
        <button id="presetStanding" title="Standing wave pattern">Standing Wave</button>
    </div>

    <!-- Info panel -->
    <div class="info">
        <div>Sources: <span class="source-count" id="sourceCount">2</span></div>
        <div id="modeInfo">Mode: Circular waves</div>
        <div id="toolInfo">Tool: Add source</div>
        <div class="equation" id="equation">&psi; = &Sigma; A/&radic;r &middot; sin(kr - &omega;t + &phi;)</div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button id="btnWaveCircle" class="active" title="Circular waves">Circular</button>
        <button id="btnWavePlane" title="Plane waves">Plane</button>
        <button id="btnWaveCylinder" title="Cylindrical waves">Cylinder</button>
        <button id="btnPhaseColor" title="Show phase as hue (rainbow)">Phase Color</button>
        <button id="btnTimeAvg" title="Time-averaged standing pattern">Time Avg</button>
        <button id="btn3DView" title="3D perspective height field">3D View</button>
        <button id="btnDetector" title="Show intensity detector line">Detector</button>
        <button id="btnToolSource" class="active" title="Click to add sources">+ Source</button>
        <button id="btnToolObstacle" title="Click to place obstacles">+ Obstacle</button>
        <button id="btnToolWall" title="Click to place reflecting walls">+ Wall</button>
        <button id="btnAbsorb" title="Absorbing boundary conditions">Absorb BC</button>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="control-group">
            <label>Wavelength</label>
            <input type="range" id="wavelengthSlider" min="8" max="80" value="30">
            <div class="control-value" id="wavelengthValue">30</div>
        </div>
        <div class="control-group">
            <label>Speed</label>
            <input type="range" id="speedSlider" min="20" max="300" value="120">
            <div class="control-value" id="speedValue">120</div>
        </div>
        <div class="control-group">
            <label>Damping</label>
            <input type="range" id="dampingSlider" min="0" max="100" value="30">
            <div class="control-value" id="dampingValue">0.30</div>
        </div>
        <div class="control-group">
            <label>Amplitude</label>
            <input type="range" id="amplitudeSlider" min="10" max="200" value="100">
            <div class="control-value" id="amplitudeValue">1.0</div>
        </div>
    </div>

    <div class="hint" id="hint">Click to place wave sources | Right-click to remove</div>

    <!-- Intensity detector canvas -->
    <canvas id="detectorCanvas" class="intensity-graph" width="600" height="120"></canvas>

    <script>
    (function() {
        'use strict';

        // --- Canvas Setup ---
        var canvas2d = document.getElementById('canvas2d');
        var ctx = canvas2d.getContext('2d');
        var canvas3d = document.getElementById('canvas3d');
        var ctx3d = canvas3d.getContext('2d');
        var detectorCanvas = document.getElementById('detectorCanvas');
        var ctxDet = detectorCanvas.getContext('2d');
        var grainCanvas = document.getElementById('grainCanvas');
        var ctxGrain = grainCanvas.getContext('2d');

        var W, H;
        var dpr = Math.min(window.devicePixelRatio || 1, 2);
        var imageData, pixels;
        var SCALE = 2;

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas2d.width = Math.ceil(W * dpr / SCALE) * SCALE;
            canvas2d.height = Math.ceil(H * dpr / SCALE) * SCALE;
            canvas2d.style.width = W + 'px';
            canvas2d.style.height = H + 'px';
            canvas3d.width = W * dpr;
            canvas3d.height = H * dpr;
            canvas3d.style.width = W + 'px';
            canvas3d.style.height = H + 'px';
            ctx3d.setTransform(dpr, 0, 0, dpr, 0, 0);
            imageData = ctx.createImageData(canvas2d.width, canvas2d.height);
            pixels = imageData.data;
            // Grain canvas
            grainCanvas.width = 256;
            grainCanvas.height = 256;
            generateGrain();
            // Time avg buffer
            timeAvgBuffer = null;
            timeAvgCount = 0;
        }

        resize();
        var resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resize, 150);
        });

        // --- Film grain generation ---
        function generateGrain() {
            var gd = ctxGrain.createImageData(256, 256);
            var gp = gd.data;
            for (var i = 0; i < gp.length; i += 4) {
                var v = Math.random() * 255;
                gp[i] = v; gp[i+1] = v; gp[i+2] = v; gp[i+3] = 255;
            }
            ctxGrain.putImageData(gd, 0, 0);
        }

        // --- State ---
        var wavelength = 30;
        var speed = 120;
        var damping = 0.003;
        var globalAmplitude = 1.0;
        var time = 0;
        var paused = false;

        // Wave types: 'circular', 'plane', 'cylinder'
        var waveType = 'circular';

        // Sources: {x, y, phase, freq (multiplier), vx, vy (for doppler)}
        var sources = [
            { x: 0.3, y: 0.4, phase: 0, freq: 1.0, vx: 0, vy: 0, color: [100, 200, 255] },
            { x: 0.7, y: 0.6, phase: 0, freq: 1.0, vx: 0, vy: 0, color: [100, 200, 255] }
        ];

        // Obstacles: {x, y, w, h, type: 'circle'|'rect', radius}
        var obstacles = [];

        // Reflecting walls: {x1, y1, x2, y2}
        var walls = [];

        // Barrier (for double-slit): {y, slits: [{x, width}], thickness}
        var barrier = null;

        // Modes
        var phaseColorMode = false;
        var timeAvgMode = false;
        var view3D = false;
        var showDetector = false;
        var absorbingBC = false;
        var currentTool = 'source'; // 'source', 'obstacle', 'wall'

        // Time average buffer
        var timeAvgBuffer = null;
        var timeAvgCount = 0;

        // Detector line position (normalized y)
        var detectorY = 0.5;

        // Wall placement state
        var wallStart = null;

        // Per-source frequency colors
        var freqColors = [
            [100, 200, 255], // 1.0x - cyan
            [255, 100, 100], // other - red
            [100, 255, 100], // green
            [255, 200, 50],  // gold
            [200, 100, 255], // purple
            [255, 150, 50],  // orange
            [50, 255, 200],  // teal
            [255, 80, 200],  // pink
        ];

        function getFreqColor(freq) {
            if (freq === 1.0) return freqColors[0];
            var idx = Math.round(freq * 3) % freqColors.length;
            return freqColors[idx < 0 ? 0 : idx];
        }

        // --- Controls ---
        var wavelengthSlider = document.getElementById('wavelengthSlider');
        var speedSlider = document.getElementById('speedSlider');
        var dampingSlider = document.getElementById('dampingSlider');
        var amplitudeSlider = document.getElementById('amplitudeSlider');
        var wavelengthValueEl = document.getElementById('wavelengthValue');
        var speedValueEl = document.getElementById('speedValue');
        var dampingValueEl = document.getElementById('dampingValue');
        var amplitudeValueEl = document.getElementById('amplitudeValue');
        var sourceCountEl = document.getElementById('sourceCount');
        var hintEl = document.getElementById('hint');
        var modeInfoEl = document.getElementById('modeInfo');
        var toolInfoEl = document.getElementById('toolInfo');
        var equationEl = document.getElementById('equation');

        wavelengthSlider.addEventListener('input', function() {
            wavelength = parseFloat(this.value);
            wavelengthValueEl.textContent = wavelength;
        });
        speedSlider.addEventListener('input', function() {
            speed = parseFloat(this.value);
            speedValueEl.textContent = speed;
        });
        dampingSlider.addEventListener('input', function() {
            damping = parseFloat(this.value) / 10000;
            dampingValueEl.textContent = (damping * 10000 / 100).toFixed(2);
        });
        amplitudeSlider.addEventListener('input', function() {
            globalAmplitude = parseFloat(this.value) / 100;
            amplitudeValueEl.textContent = globalAmplitude.toFixed(1);
        });

        // --- Toolbar buttons ---
        function setActive(btn, group) {
            group.forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
        }

        var btnCircle = document.getElementById('btnWaveCircle');
        var btnPlane = document.getElementById('btnWavePlane');
        var btnCylinder = document.getElementById('btnWaveCylinder');
        var waveTypeBtns = [btnCircle, btnPlane, btnCylinder];

        btnCircle.addEventListener('click', function() {
            waveType = 'circular'; setActive(this, waveTypeBtns);
            modeInfoEl.textContent = 'Mode: Circular waves';
            equationEl.innerHTML = '&psi; = &Sigma; A/&radic;r &middot; sin(kr - &omega;t + &phi;)';
        });
        btnPlane.addEventListener('click', function() {
            waveType = 'plane'; setActive(this, waveTypeBtns);
            modeInfoEl.textContent = 'Mode: Plane waves';
            equationEl.innerHTML = '&psi; = &Sigma; A &middot; sin(k&middot;x - &omega;t + &phi;)';
        });
        btnCylinder.addEventListener('click', function() {
            waveType = 'cylinder'; setActive(this, waveTypeBtns);
            modeInfoEl.textContent = 'Mode: Cylindrical waves';
            equationEl.innerHTML = '&psi; = &Sigma; A/r&frac14; &middot; sin(kr - &omega;t + &phi;)';
        });

        var btnPhase = document.getElementById('btnPhaseColor');
        btnPhase.addEventListener('click', function() {
            phaseColorMode = !phaseColorMode;
            this.classList.toggle('active');
        });

        var btnTimeAvg = document.getElementById('btnTimeAvg');
        btnTimeAvg.addEventListener('click', function() {
            timeAvgMode = !timeAvgMode;
            this.classList.toggle('active');
            if (timeAvgMode) { timeAvgBuffer = null; timeAvgCount = 0; }
        });

        var btn3D = document.getElementById('btn3DView');
        btn3D.addEventListener('click', function() {
            view3D = !view3D;
            this.classList.toggle('active');
            canvas3d.style.display = view3D ? 'block' : 'none';
            canvas2d.style.display = view3D ? 'none' : 'block';
        });

        var btnDet = document.getElementById('btnDetector');
        btnDet.addEventListener('click', function() {
            showDetector = !showDetector;
            this.classList.toggle('active');
            detectorCanvas.classList.toggle('visible', showDetector);
        });

        var btnAbsorb = document.getElementById('btnAbsorb');
        btnAbsorb.addEventListener('click', function() {
            absorbingBC = !absorbingBC;
            this.classList.toggle('active');
        });

        var btnToolSource = document.getElementById('btnToolSource');
        var btnToolObstacle = document.getElementById('btnToolObstacle');
        var btnToolWall = document.getElementById('btnToolWall');
        var toolBtns = [btnToolSource, btnToolObstacle, btnToolWall];

        btnToolSource.addEventListener('click', function() {
            currentTool = 'source'; setActive(this, toolBtns);
            toolInfoEl.textContent = 'Tool: Add source';
            hintEl.textContent = 'Click to place wave sources | Right-click to remove';
            hintEl.classList.remove('hidden');
        });
        btnToolObstacle.addEventListener('click', function() {
            currentTool = 'obstacle'; setActive(this, toolBtns);
            toolInfoEl.textContent = 'Tool: Place obstacle';
            hintEl.textContent = 'Click to place circular obstacles | Right-click to remove';
            hintEl.classList.remove('hidden');
        });
        btnToolWall.addEventListener('click', function() {
            currentTool = 'wall'; setActive(this, toolBtns);
            toolInfoEl.textContent = 'Tool: Place wall';
            hintEl.textContent = 'Click start + end to place reflecting wall | Right-click to remove';
            hintEl.classList.remove('hidden');
        });

        // --- Presets ---
        function clearPresets() {
            document.querySelectorAll('.presets button').forEach(function(b) { b.classList.remove('active'); });
        }

        document.getElementById('presetDefault').addEventListener('click', function() {
            clearPresets(); this.classList.add('active');
            sources = [
                { x: 0.3, y: 0.4, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] },
                { x: 0.7, y: 0.6, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] }
            ];
            obstacles = []; walls = []; barrier = null;
            wavelength = 30; speed = 120; damping = 0.003;
            wavelengthSlider.value = 30; speedSlider.value = 120; dampingSlider.value = 30;
            wavelengthValueEl.textContent = '30'; speedValueEl.textContent = '120'; dampingValueEl.textContent = '0.30';
            sourceCountEl.textContent = '2';
            waveType = 'circular'; setActive(btnCircle, waveTypeBtns);
            timeAvgBuffer = null; timeAvgCount = 0; time = 0;
        });

        document.getElementById('presetDoubleSlit').addEventListener('click', function() {
            clearPresets(); this.classList.add('active');
            sources = [
                { x: 0.1, y: 0.5, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] }
            ];
            obstacles = [];
            walls = [];
            // Barrier as a set of obstacles with slits
            var slitWidth = 0.03;
            var slitSep = 0.12;
            var barrierX = 0.35;
            barrier = { x: barrierX, slitY1: 0.5 - slitSep / 2, slitY2: 0.5 + slitSep / 2, slitWidth: slitWidth, thickness: 0.008 };
            wavelength = 20; speed = 100; damping = 0.001;
            wavelengthSlider.value = 20; speedSlider.value = 100; dampingSlider.value = 10;
            wavelengthValueEl.textContent = '20'; speedValueEl.textContent = '100'; dampingValueEl.textContent = '0.10';
            sourceCountEl.textContent = '1';
            waveType = 'circular'; setActive(btnCircle, waveTypeBtns);
            timeAvgBuffer = null; timeAvgCount = 0; time = 0;
        });

        document.getElementById('presetDoppler').addEventListener('click', function() {
            clearPresets(); this.classList.add('active');
            sources = [
                { x: 0.2, y: 0.5, phase: 0, freq: 1.0, vx: 0.08, vy: 0.02, color: freqColors[0] }
            ];
            obstacles = []; walls = []; barrier = null;
            wavelength = 25; speed = 150; damping = 0.002;
            wavelengthSlider.value = 25; speedSlider.value = 150; dampingSlider.value = 20;
            wavelengthValueEl.textContent = '25'; speedValueEl.textContent = '150'; dampingValueEl.textContent = '0.20';
            sourceCountEl.textContent = '1';
            waveType = 'circular'; setActive(btnCircle, waveTypeBtns);
            timeAvgBuffer = null; timeAvgCount = 0; time = 0;
        });

        document.getElementById('presetMultiFreq').addEventListener('click', function() {
            clearPresets(); this.classList.add('active');
            sources = [
                { x: 0.25, y: 0.3, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] },
                { x: 0.75, y: 0.3, phase: 0, freq: 1.5, vx: 0, vy: 0, color: getFreqColor(1.5) },
                { x: 0.5, y: 0.75, phase: 0, freq: 0.7, vx: 0, vy: 0, color: getFreqColor(0.7) }
            ];
            obstacles = []; walls = []; barrier = null;
            wavelength = 30; speed = 120; damping = 0.002;
            wavelengthSlider.value = 30; speedSlider.value = 120; dampingSlider.value = 20;
            wavelengthValueEl.textContent = '30'; speedValueEl.textContent = '120'; dampingValueEl.textContent = '0.20';
            sourceCountEl.textContent = '3';
            waveType = 'circular'; setActive(btnCircle, waveTypeBtns);
            timeAvgBuffer = null; timeAvgCount = 0; time = 0;
        });

        document.getElementById('presetReflection').addEventListener('click', function() {
            clearPresets(); this.classList.add('active');
            sources = [
                { x: 0.5, y: 0.5, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] }
            ];
            obstacles = [];
            barrier = null;
            // Add reflecting walls
            walls = [
                { x1: 0.1, y1: 0.1, x2: 0.9, y2: 0.1 },
                { x1: 0.9, y1: 0.1, x2: 0.9, y2: 0.9 },
                { x1: 0.1, y1: 0.9, x2: 0.9, y2: 0.9 },
                { x1: 0.1, y1: 0.1, x2: 0.1, y2: 0.9 }
            ];
            wavelength = 35; speed = 120; damping = 0.001;
            wavelengthSlider.value = 35; speedSlider.value = 120; dampingSlider.value = 10;
            wavelengthValueEl.textContent = '35'; speedValueEl.textContent = '120'; dampingValueEl.textContent = '0.10';
            sourceCountEl.textContent = '1';
            waveType = 'circular'; setActive(btnCircle, waveTypeBtns);
            timeAvgBuffer = null; timeAvgCount = 0; time = 0;
        });

        document.getElementById('presetStanding').addEventListener('click', function() {
            clearPresets(); this.classList.add('active');
            sources = [
                { x: 0.2, y: 0.5, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] },
                { x: 0.8, y: 0.5, phase: Math.PI, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] }
            ];
            obstacles = []; walls = []; barrier = null;
            wavelength = 40; speed = 100; damping = 0.0005;
            wavelengthSlider.value = 40; speedSlider.value = 100; dampingSlider.value = 5;
            wavelengthValueEl.textContent = '40'; speedValueEl.textContent = '100'; dampingValueEl.textContent = '0.05';
            sourceCountEl.textContent = '2';
            waveType = 'plane'; setActive(btnPlane, waveTypeBtns);
            timeAvgMode = true; btnTimeAvg.classList.add('active');
            timeAvgBuffer = null; timeAvgCount = 0; time = 0;
        });

        // --- Click / Interaction ---
        function getEventPos(e) {
            var rect = canvas2d.getBoundingClientRect();
            return { x: (e.clientX - rect.left) / W, y: (e.clientY - rect.top) / H };
        }

        function findNearest(arr, pos, threshold) {
            var best = -1, bestD = threshold * threshold;
            for (var i = 0; i < arr.length; i++) {
                var dx = (arr[i].x !== undefined ? arr[i].x : (arr[i].x1 + arr[i].x2) / 2) - pos.x;
                var dy = (arr[i].y !== undefined ? arr[i].y : (arr[i].y1 + arr[i].y2) / 2) - pos.y;
                var d = dx * dx + dy * dy;
                if (d < bestD) { bestD = d; best = i; }
            }
            return best;
        }

        // Track cycling of freq for multi-freq sources
        var nextFreqIdx = 0;
        var freqOptions = [1.0, 0.5, 0.7, 1.3, 1.5, 2.0];

        canvas2d.addEventListener('click', function(e) {
            if (e.target !== canvas2d) return;
            var pos = getEventPos(e);

            if (currentTool === 'source') {
                var freq = freqOptions[nextFreqIdx % freqOptions.length];
                if (sources.length < 2) freq = 1.0; // first two are default
                else nextFreqIdx++;
                sources.push({
                    x: pos.x, y: pos.y,
                    phase: time * speed * (Math.PI * 2 / wavelength),
                    freq: freq, vx: 0, vy: 0,
                    color: getFreqColor(freq)
                });
                sourceCountEl.textContent = sources.length;
            } else if (currentTool === 'obstacle') {
                obstacles.push({ x: pos.x, y: pos.y, radius: 0.03, type: 'circle' });
            } else if (currentTool === 'wall') {
                if (!wallStart) {
                    wallStart = { x: pos.x, y: pos.y };
                    hintEl.textContent = 'Click end point for wall';
                    hintEl.classList.remove('hidden');
                } else {
                    walls.push({ x1: wallStart.x, y1: wallStart.y, x2: pos.x, y2: pos.y });
                    wallStart = null;
                    hintEl.textContent = 'Wall placed | Click start + end for another';
                }
            }

            if (!hintEl.classList.contains('hidden')) {
                clearTimeout(hintTimeout);
                hintTimeout = setTimeout(function() { hintEl.classList.add('hidden'); }, 3000);
            }
        });

        // Right-click to remove nearest
        canvas2d.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            var pos = getEventPos(e);
            if (currentTool === 'source') {
                var idx = findNearest(sources, pos, 0.05);
                if (idx >= 0) { sources.splice(idx, 1); sourceCountEl.textContent = sources.length; }
            } else if (currentTool === 'obstacle') {
                var idx = findNearest(obstacles, pos, 0.06);
                if (idx >= 0) obstacles.splice(idx, 1);
            } else if (currentTool === 'wall') {
                var idx = findNearest(walls, pos, 0.08);
                if (idx >= 0) walls.splice(idx, 1);
            }
        });

        var hintTimeout = setTimeout(function() { hintEl.classList.add('hidden'); }, 5000);

        // --- Color LUT ---
        var COLOR_LUT_SIZE = 512;
        var colorLutR = new Uint8Array(COLOR_LUT_SIZE);
        var colorLutG = new Uint8Array(COLOR_LUT_SIZE);
        var colorLutB = new Uint8Array(COLOR_LUT_SIZE);

        function buildColorLUT() {
            for (var i = 0; i < COLOR_LUT_SIZE; i++) {
                var amp = (i / (COLOR_LUT_SIZE - 1)) * 2 - 1;
                var r, g, b;
                if (amp > 0) {
                    var t = amp, t2 = t * t, t3 = t2 * t;
                    r = Math.floor(10 + 60 * t2 + 185 * t3);
                    g = Math.floor(15 + 160 * t + 80 * t3);
                    b = Math.floor(30 + 200 * t + 25 * t2);
                } else {
                    var t = -amp, t2 = t * t;
                    r = Math.floor(5 + 25 * t2);
                    g = Math.floor(5 + 10 * t);
                    b = Math.floor(15 + 60 * t - 20 * t2);
                }
                colorLutR[i] = Math.min(255, Math.max(0, r));
                colorLutG[i] = Math.min(255, Math.max(0, g));
                colorLutB[i] = Math.min(255, Math.max(0, b));
            }
        }
        buildColorLUT();

        // Phase-to-HSL color
        function phaseToRGB(phase, intensity) {
            // phase: 0..2PI -> hue 0..360
            var hue = ((phase % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            hue = hue / (Math.PI * 2) * 360;
            var s = 0.9;
            var l = 0.15 + intensity * 0.45;
            // HSL to RGB
            var c = (1 - Math.abs(2 * l - 1)) * s;
            var x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            var m = l - c / 2;
            var r, g, b;
            if (hue < 60) { r = c; g = x; b = 0; }
            else if (hue < 120) { r = x; g = c; b = 0; }
            else if (hue < 180) { r = 0; g = c; b = x; }
            else if (hue < 240) { r = 0; g = x; b = c; }
            else if (hue < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return [
                Math.floor((r + m) * 255),
                Math.floor((g + m) * 255),
                Math.floor((b + m) * 255)
            ];
        }

        // --- Obstacle/wall/barrier check ---
        function isInsideObstacle(px, py, cw, ch) {
            for (var i = 0; i < obstacles.length; i++) {
                var ox = obstacles[i].x * cw, oy = obstacles[i].y * ch;
                var or2 = obstacles[i].radius * Math.max(cw, ch);
                or2 = or2 * or2;
                var dx = px - ox, dy = py - oy;
                if (dx * dx + dy * dy < or2) return true;
            }
            return false;
        }

        function isInsideBarrier(px, py, cw, ch) {
            if (!barrier) return false;
            var bx = barrier.x * cw;
            var bt = barrier.thickness * cw;
            if (px < bx - bt / 2 || px > bx + bt / 2) return false;
            // Check if in slit
            var sy1 = barrier.slitY1 * ch;
            var sy2 = barrier.slitY2 * ch;
            var sw = barrier.slitWidth * ch;
            if (Math.abs(py - sy1) < sw / 2) return false;
            if (Math.abs(py - sy2) < sw / 2) return false;
            return true;
        }

        function distToWallSegment(px, py, w, cw, ch) {
            var x1 = w.x1 * cw, y1 = w.y1 * ch, x2 = w.x2 * cw, y2 = w.y2 * ch;
            var dx = x2 - x1, dy = y2 - y1;
            var len2 = dx * dx + dy * dy;
            if (len2 < 1) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            var t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / len2));
            var projX = x1 + t * dx, projY = y1 + t * dy;
            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }

        function nearWall(px, py, cw, ch) {
            var wallThickness = 3 * dpr;
            for (var i = 0; i < walls.length; i++) {
                if (distToWallSegment(px, py, walls[i], cw, ch) < wallThickness) return true;
            }
            return false;
        }

        // Reflect contribution: for each wall, compute mirror source
        function getMirrorSources(src, cw, ch) {
            var mirrors = [];
            for (var wi = 0; wi < walls.length; wi++) {
                var w = walls[wi];
                var x1 = w.x1 * cw, y1 = w.y1 * ch, x2 = w.x2 * cw, y2 = w.y2 * ch;
                var dx = x2 - x1, dy = y2 - y1;
                var len2 = dx * dx + dy * dy;
                if (len2 < 1) continue;
                var sx = src.x * cw, sy = src.y * ch;
                // Project source onto wall line
                var t = ((sx - x1) * dx + (sy - y1) * dy) / len2;
                var projX = x1 + t * dx, projY = y1 + t * dy;
                // Mirror
                var mx = 2 * projX - sx, my = 2 * projY - sy;
                mirrors.push({ x: mx / cw, y: my / ch, phase: src.phase, freq: src.freq });
            }
            return mirrors;
        }

        // --- Compute amplitude at a point ---
        function computeAmplitude(px, py, cw, ch, t, srcs) {
            var totalAmp = 0;
            var totalPhaseX = 0, totalPhaseY = 0;
            var numSources = srcs.length;
            var TWO_PI = Math.PI * 2;

            for (var s = 0; s < numSources; s++) {
                var src = srcs[s];
                var srcX = src.x * cw, srcY = src.y * ch;
                var wl = wavelength * dpr * (1 / (src.freq || 1));
                var k = TWO_PI / wl;
                var omega = speed * dpr * k;
                var dampFactor = damping * dpr;

                var dx = px - srcX, dy = py - srcY;
                var dist, envelope, phase;

                if (waveType === 'circular') {
                    dist = Math.sqrt(dx * dx + dy * dy);
                    envelope = 1 / (1 + Math.sqrt(dist) * 0.08);
                    phase = k * dist - omega * t + (src.phase || 0);
                } else if (waveType === 'plane') {
                    // Plane wave propagates in x direction from source
                    dist = Math.abs(dx);
                    envelope = 1.0;
                    phase = k * dx - omega * t + (src.phase || 0);
                } else { // cylinder
                    dist = Math.sqrt(dx * dx + dy * dy);
                    envelope = 1 / (1 + Math.pow(dist, 0.25) * 0.15);
                    phase = k * dist - omega * t + (src.phase || 0);
                }

                var dampEnv = Math.exp(-dampFactor * Math.abs(dist));
                var amp = envelope * dampEnv * Math.sin(phase) * globalAmplitude;
                totalAmp += amp;

                // For phase mode, accumulate phasors
                totalPhaseX += envelope * dampEnv * Math.cos(phase);
                totalPhaseY += envelope * dampEnv * Math.sin(phase);
            }

            return {
                amplitude: totalAmp,
                phase: Math.atan2(totalPhaseY, totalPhaseX),
                intensity: Math.sqrt(totalPhaseX * totalPhaseX + totalPhaseY * totalPhaseY) / Math.max(1, Math.sqrt(numSources))
            };
        }

        // --- Absorbing boundary factor ---
        function absorbFactor(px, py, cw, ch) {
            if (!absorbingBC) return 1;
            var margin = 40 * dpr;
            var fx = 1, fy = 1;
            if (px < margin) fx = px / margin;
            if (px > cw - margin) fx = (cw - px) / margin;
            if (py < margin) fy = py / margin;
            if (py > ch - margin) fy = (ch - py) / margin;
            var f = Math.min(fx, fy);
            return f < 0 ? 0 : f * f; // quadratic taper
        }

        // --- Rendering ---
        var prevTimestamp = 0;

        function render(timestamp) {
            if (!paused) {
                var dt = Math.min((timestamp - prevTimestamp) / 1000, 0.05);
                prevTimestamp = timestamp;
                time += dt;

                // Move doppler sources
                for (var s = 0; s < sources.length; s++) {
                    if (sources[s].vx || sources[s].vy) {
                        sources[s].x += sources[s].vx * dt;
                        sources[s].y += sources[s].vy * dt;
                        // Bounce off edges
                        if (sources[s].x < 0.05 || sources[s].x > 0.95) sources[s].vx *= -1;
                        if (sources[s].y < 0.05 || sources[s].y > 0.95) sources[s].vy *= -1;
                        sources[s].x = Math.max(0.02, Math.min(0.98, sources[s].x));
                        sources[s].y = Math.max(0.02, Math.min(0.98, sources[s].y));
                    }
                }

                if (view3D) {
                    render3D();
                } else {
                    render2D();
                }

                // Render detector
                if (showDetector) {
                    renderDetector();
                }
            } else {
                prevTimestamp = timestamp;
            }

            rafId = requestAnimationFrame(render);
        }

        function render2D() {
            var cw = canvas2d.width;
            var ch = canvas2d.height;
            var numSources = sources.length;
            var TWO_PI = Math.PI * 2;
            var lutMax = COLOR_LUT_SIZE - 1;
            var halfLut = lutMax / 2;

            // Build list of all effective sources (real + mirror)
            var allSrcs = sources.slice();
            for (var s = 0; s < sources.length; s++) {
                var mirrors = getMirrorSources(sources[s], cw, ch);
                for (var m = 0; m < mirrors.length; m++) {
                    allSrcs.push(mirrors[m]);
                }
            }

            // Precompute source data
            var nSrcs = allSrcs.length;
            var srcX = new Float64Array(nSrcs);
            var srcY = new Float64Array(nSrcs);
            var srcPhase = new Float64Array(nSrcs);
            var srcK = new Float64Array(nSrcs);
            var srcOmega = new Float64Array(nSrcs);
            var dampFactor = damping * dpr;

            for (var s = 0; s < nSrcs; s++) {
                srcX[s] = allSrcs[s].x * cw;
                srcY[s] = allSrcs[s].y * ch;
                srcPhase[s] = allSrcs[s].phase || 0;
                var wl = wavelength * dpr * (1 / (allSrcs[s].freq || 1));
                srcK[s] = TWO_PI / wl;
                srcOmega[s] = speed * dpr * srcK[s];
            }

            var t = time;

            // Time avg setup
            var doTimeAvg = timeAvgMode;
            var rw = Math.ceil(cw / SCALE);
            var rh = Math.ceil(ch / SCALE);
            if (doTimeAvg && !timeAvgBuffer) {
                timeAvgBuffer = new Float64Array(rw * rh);
            }

            var avgIdx = 0;

            for (var py = 0; py < ch; py += SCALE) {
                for (var px = 0; px < cw; px += SCALE) {
                    // Check obstacles and barrier
                    if (isInsideObstacle(px, py, cw, ch) || isInsideBarrier(px, py, cw, ch)) {
                        // Draw obstacle/barrier as dark
                        for (var sy2 = 0; sy2 < SCALE && (py + sy2) < ch; sy2++) {
                            for (var sx2 = 0; sx2 < SCALE && (px + sx2) < cw; sx2++) {
                                var idx = ((py + sy2) * cw + (px + sx2)) * 4;
                                pixels[idx] = 15; pixels[idx+1] = 20; pixels[idx+2] = 30; pixels[idx+3] = 255;
                            }
                        }
                        avgIdx++;
                        continue;
                    }

                    // Near wall = reflector surface
                    if (nearWall(px, py, cw, ch)) {
                        for (var sy2 = 0; sy2 < SCALE && (py + sy2) < ch; sy2++) {
                            for (var sx2 = 0; sx2 < SCALE && (px + sx2) < cw; sx2++) {
                                var idx = ((py + sy2) * cw + (px + sx2)) * 4;
                                pixels[idx] = 60; pixels[idx+1] = 80; pixels[idx+2] = 100; pixels[idx+3] = 255;
                            }
                        }
                        avgIdx++;
                        continue;
                    }

                    var totalAmp = 0;
                    var phaseX = 0, phaseY = 0;

                    for (var s = 0; s < nSrcs; s++) {
                        var dx = px - srcX[s];
                        var dy = py - srcY[s];
                        var dist, envelope, phase;

                        if (waveType === 'circular') {
                            dist = Math.sqrt(dx * dx + dy * dy);
                            envelope = 1 / (1 + Math.sqrt(dist) * 0.08);
                            phase = srcK[s] * dist - srcOmega[s] * t + srcPhase[s];
                        } else if (waveType === 'plane') {
                            dist = dx;
                            envelope = 1.0;
                            phase = srcK[s] * dx - srcOmega[s] * t + srcPhase[s];
                        } else {
                            dist = Math.sqrt(dx * dx + dy * dy);
                            envelope = 1 / (1 + Math.pow(dist + 1, 0.25) * 0.15);
                            phase = srcK[s] * dist - srcOmega[s] * t + srcPhase[s];
                        }

                        var dampEnv = Math.exp(-dampFactor * Math.abs(dist));
                        var af = absorbFactor(px, py, cw, ch);
                        var contrib = envelope * dampEnv * af * globalAmplitude;
                        totalAmp += contrib * Math.sin(phase);
                        phaseX += contrib * Math.cos(phase);
                        phaseY += contrib * Math.sin(phase);
                    }

                    // Normalize
                    var norm = totalAmp / Math.sqrt(Math.max(1, nSrcs));
                    norm = norm / (1 + Math.abs(norm) * 0.3);
                    norm = Math.max(-1, Math.min(1, norm * 1.5));

                    var r, g, b;

                    if (phaseColorMode) {
                        var phs = Math.atan2(phaseY, phaseX);
                        var intensity = Math.sqrt(phaseX * phaseX + phaseY * phaseY) / Math.max(1, Math.sqrt(nSrcs));
                        intensity = Math.min(1, intensity * 1.5);
                        var rgb = phaseToRGB(phs, intensity);
                        r = rgb[0]; g = rgb[1]; b = rgb[2];
                    } else {
                        var lutIdx = Math.floor((norm + 1) * halfLut);
                        if (lutIdx < 0) lutIdx = 0;
                        if (lutIdx > lutMax) lutIdx = lutMax;
                        r = colorLutR[lutIdx]; g = colorLutG[lutIdx]; b = colorLutB[lutIdx];
                    }

                    // Time average accumulation
                    if (doTimeAvg && timeAvgBuffer) {
                        var ampSq = norm * norm;
                        timeAvgBuffer[avgIdx] = (timeAvgBuffer[avgIdx] * timeAvgCount + ampSq) / (timeAvgCount + 1);
                        // Override color with time-averaged intensity
                        var avgI = Math.sqrt(timeAvgBuffer[avgIdx]);
                        r = Math.floor(10 + 245 * avgI * avgI);
                        g = Math.floor(15 + 200 * avgI);
                        b = Math.floor(30 + 180 * avgI * 0.5);
                        r = Math.min(255, r); g = Math.min(255, g); b = Math.min(255, b);
                    }

                    for (var sy2 = 0; sy2 < SCALE && (py + sy2) < ch; sy2++) {
                        for (var sx2 = 0; sx2 < SCALE && (px + sx2) < cw; sx2++) {
                            var idx = ((py + sy2) * cw + (px + sx2)) * 4;
                            pixels[idx] = r; pixels[idx+1] = g; pixels[idx+2] = b; pixels[idx+3] = 255;
                        }
                    }
                    avgIdx++;
                }
            }

            if (doTimeAvg) timeAvgCount++;

            ctx.putImageData(imageData, 0, 0);

            // Draw source dots, obstacles, walls over the image
            ctx.save();
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // Draw walls
            ctx.strokeStyle = 'rgba(100, 150, 200, 0.6)';
            ctx.lineWidth = 3;
            for (var i = 0; i < walls.length; i++) {
                ctx.beginPath();
                ctx.moveTo(walls[i].x1 * W, walls[i].y1 * H);
                ctx.lineTo(walls[i].x2 * W, walls[i].y2 * H);
                ctx.stroke();
            }

            // Draw barrier
            if (barrier) {
                ctx.fillStyle = 'rgba(40, 55, 75, 0.9)';
                var bx = barrier.x * W;
                var bt = barrier.thickness * W;
                var sw = barrier.slitWidth * H;
                // Top section
                ctx.fillRect(bx - bt/2, 0, bt, barrier.slitY1 * H - sw/2);
                // Middle section
                ctx.fillRect(bx - bt/2, barrier.slitY1 * H + sw/2, bt, (barrier.slitY2 - barrier.slitY1) * H - sw);
                // Bottom section
                ctx.fillRect(bx - bt/2, barrier.slitY2 * H + sw/2, bt, H - barrier.slitY2 * H - sw/2);
            }

            // Draw obstacles
            for (var i = 0; i < obstacles.length; i++) {
                var ox = obstacles[i].x * W, oy = obstacles[i].y * H;
                var or2 = obstacles[i].radius * Math.max(W, H);
                ctx.fillStyle = 'rgba(30, 45, 65, 0.9)';
                ctx.strokeStyle = 'rgba(80, 120, 160, 0.5)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(ox, oy, or2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Draw sources
            for (var s = 0; s < sources.length; s++) {
                var srcXp = sources[s].x * W;
                var srcYp = sources[s].y * H;
                var sc = sources[s].color || [100, 200, 255];

                // Glow
                var grd = ctx.createRadialGradient(srcXp, srcYp, 0, srcXp, srcYp, 22);
                grd.addColorStop(0, 'rgba(' + sc[0] + ',' + sc[1] + ',' + sc[2] + ',0.8)');
                grd.addColorStop(0.3, 'rgba(' + sc[0] + ',' + sc[1] + ',' + sc[2] + ',0.3)');
                grd.addColorStop(1, 'rgba(' + sc[0] + ',' + sc[1] + ',' + sc[2] + ',0)');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(srcXp, srcYp, 22, 0, Math.PI * 2);
                ctx.fill();

                // Dot
                ctx.fillStyle = 'rgba(220, 245, 255, 0.95)';
                ctx.beginPath();
                ctx.arc(srcXp, srcYp, 3, 0, Math.PI * 2);
                ctx.fill();

                // Freq label
                if (sources[s].freq !== 1.0) {
                    ctx.fillStyle = 'rgba(' + sc[0] + ',' + sc[1] + ',' + sc[2] + ',0.7)';
                    ctx.font = '9px Courier New';
                    ctx.fillText(sources[s].freq.toFixed(1) + 'x', srcXp + 8, srcYp - 8);
                }

                // Velocity arrow for doppler
                if (sources[s].vx || sources[s].vy) {
                    var arrowLen = 30;
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(srcXp, srcYp);
                    var vlen = Math.sqrt(sources[s].vx * sources[s].vx + sources[s].vy * sources[s].vy);
                    if (vlen > 0) {
                        ctx.lineTo(srcXp + sources[s].vx / vlen * arrowLen, srcYp + sources[s].vy / vlen * arrowLen);
                    }
                    ctx.stroke();
                }
            }

            // Draw wall placement preview
            if (wallStart && currentTool === 'wall') {
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(wallStart.x * W, wallStart.y * H, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Detector line
            if (showDetector) {
                ctx.strokeStyle = 'rgba(255, 200, 50, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(0, detectorY * H);
                ctx.lineTo(W, detectorY * H);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        // --- 3D Perspective Rendering ---
        function render3D() {
            var cw = canvas3d.width / dpr;
            var ch = canvas3d.height / dpr;
            ctx3d.clearRect(0, 0, cw, ch);
            ctx3d.fillStyle = '#000';
            ctx3d.fillRect(0, 0, cw, ch);

            // Compute wave field at lower resolution
            var gridW = 120, gridH = 80;
            var field = new Float64Array(gridW * gridH);

            var allSrcs = sources.slice();
            for (var s = 0; s < sources.length; s++) {
                var mirrors = getMirrorSources(sources[s], cw, ch);
                for (var m = 0; m < mirrors.length; m++) allSrcs.push(mirrors[m]);
            }

            var nSrcs = allSrcs.length;
            var TWO_PI = Math.PI * 2;
            var t = time;

            for (var gy = 0; gy < gridH; gy++) {
                for (var gx = 0; gx < gridW; gx++) {
                    var px = (gx / gridW) * cw;
                    var py = (gy / gridH) * ch;
                    var totalAmp = 0;

                    for (var s = 0; s < nSrcs; s++) {
                        var src = allSrcs[s];
                        var sx = src.x * cw, sy = src.y * ch;
                        var wl = wavelength * (1 / (src.freq || 1));
                        var k = TWO_PI / wl;
                        var omega = speed * k;
                        var dx = px - sx, dy = py - sy;
                        var dist = Math.sqrt(dx * dx + dy * dy);
                        var envelope = 1 / (1 + Math.sqrt(dist) * 0.08);
                        var dampEnv = Math.exp(-damping * dist);
                        totalAmp += envelope * dampEnv * Math.sin(k * dist - omega * t + (src.phase || 0)) * globalAmplitude;
                    }

                    var norm = totalAmp / Math.sqrt(Math.max(1, nSrcs));
                    norm = norm / (1 + Math.abs(norm) * 0.3);
                    field[gy * gridW + gx] = Math.max(-1, Math.min(1, norm * 1.5));
                }
            }

            // Project 3D perspective
            var camDist = 3.5;
            var tiltAngle = 0.75; // radians tilt
            var rotAngle = time * 0.05; // slow rotation
            var cosT = Math.cos(tiltAngle), sinT = Math.sin(tiltAngle);
            var cosR = Math.cos(rotAngle), sinR = Math.sin(rotAngle);
            var fov = 1.2;
            var heightScale = 60;
            var cx = cw / 2, cy = ch / 2;

            // Draw from back to front (painter's algorithm)
            var startY = 0, endY = gridH, startX = 0, endX = gridW;

            for (var gy = startY; gy < endY - 1; gy++) {
                for (var gx = startX; gx < endX - 1; gx++) {
                    // Get 4 corners of quad
                    var corners = [];
                    for (var dy = 0; dy < 2; dy++) {
                        for (var dx2 = 0; dx2 < 2; dx2++) {
                            var ix = gx + dx2, iy = gy + dy;
                            var val = field[iy * gridW + ix];
                            // 3D position centered at origin
                            var x3 = (ix / gridW - 0.5) * 2;
                            var z3 = (iy / gridH - 0.5) * 2;
                            var y3 = val * (heightScale / cw);

                            // Rotate around Y
                            var rx = x3 * cosR - z3 * sinR;
                            var rz = x3 * sinR + z3 * cosR;

                            // Tilt
                            var ry = y3 * cosT - rz * sinT;
                            var rz2 = y3 * sinT + rz * cosT + camDist;

                            // Project
                            if (rz2 < 0.1) rz2 = 0.1;
                            var sx2 = cx + rx / rz2 * cw * fov;
                            var sy2 = cy - ry / rz2 * ch * fov;

                            corners.push({ x: sx2, y: sy2, val: val, depth: rz2 });
                        }
                    }

                    // Average value for color
                    var avgVal = (corners[0].val + corners[1].val + corners[2].val + corners[3].val) / 4;
                    var lutIdx = Math.floor((avgVal + 1) * ((COLOR_LUT_SIZE - 1) / 2));
                    lutIdx = Math.max(0, Math.min(COLOR_LUT_SIZE - 1, lutIdx));

                    var r = colorLutR[lutIdx], g = colorLutG[lutIdx], b = colorLutB[lutIdx];

                    // Depth shading
                    var avgDepth = (corners[0].depth + corners[1].depth + corners[2].depth + corners[3].depth) / 4;
                    var depthFade = Math.max(0.2, Math.min(1, 2.5 / avgDepth));
                    r = Math.floor(r * depthFade);
                    g = Math.floor(g * depthFade);
                    b = Math.floor(b * depthFade);

                    ctx3d.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx3d.beginPath();
                    ctx3d.moveTo(corners[0].x, corners[0].y);
                    ctx3d.lineTo(corners[1].x, corners[1].y);
                    ctx3d.lineTo(corners[3].x, corners[3].y);
                    ctx3d.lineTo(corners[2].x, corners[2].y);
                    ctx3d.closePath();
                    ctx3d.fill();

                    // Wireframe edges
                    ctx3d.strokeStyle = 'rgba(' + Math.min(255, r + 30) + ',' + Math.min(255, g + 30) + ',' + Math.min(255, b + 30) + ',0.15)';
                    ctx3d.lineWidth = 0.5;
                    ctx3d.stroke();
                }
            }
        }

        // --- Intensity detector ---
        function renderDetector() {
            var dw = detectorCanvas.width;
            var dh = detectorCanvas.height;
            ctxDet.clearRect(0, 0, dw, dh);

            // Background
            ctxDet.fillStyle = 'rgba(0, 10, 20, 0.7)';
            ctxDet.fillRect(0, 0, dw, dh);
            ctxDet.strokeStyle = 'rgba(100, 200, 255, 0.2)';
            ctxDet.lineWidth = 1;
            ctxDet.strokeRect(0, 0, dw, dh);

            // Sample intensity along detector line
            var cw = canvas2d.width;
            var ch = canvas2d.height;
            var allSrcs = sources.slice();
            for (var s = 0; s < sources.length; s++) {
                var mirrors = getMirrorSources(sources[s], cw, ch);
                for (var m = 0; m < mirrors.length; m++) allSrcs.push(mirrors[m]);
            }

            var samples = dw;
            var py = detectorY * ch;
            var maxI = 0.001;
            var intensities = new Float64Array(samples);

            for (var i = 0; i < samples; i++) {
                var px = (i / samples) * cw;
                var result = computeAmplitude(px, py, cw, ch, time, allSrcs);
                var intensity = result.amplitude * result.amplitude;
                intensities[i] = intensity;
                if (intensity > maxI) maxI = intensity;
            }

            // Draw intensity graph
            ctxDet.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            ctxDet.lineWidth = 1.5;
            ctxDet.beginPath();
            for (var i = 0; i < samples; i++) {
                var x = i;
                var y = dh - 5 - (intensities[i] / maxI) * (dh - 10);
                if (i === 0) ctxDet.moveTo(x, y);
                else ctxDet.lineTo(x, y);
            }
            ctxDet.stroke();

            // Fill under curve
            ctxDet.lineTo(dw, dh);
            ctxDet.lineTo(0, dh);
            ctxDet.closePath();
            ctxDet.fillStyle = 'rgba(50, 120, 200, 0.15)';
            ctxDet.fill();

            // Label
            ctxDet.fillStyle = 'rgba(100, 200, 255, 0.5)';
            ctxDet.font = '9px Courier New';
            ctxDet.fillText('Intensity at y=' + detectorY.toFixed(2), 5, 12);
        }

        var rafId = requestAnimationFrame(render);

        // --- Reset ---
        function resetSimulation() {
            sources = [
                { x: 0.3, y: 0.4, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] },
                { x: 0.7, y: 0.6, phase: 0, freq: 1.0, vx: 0, vy: 0, color: freqColors[0] }
            ];
            obstacles = [];
            walls = [];
            barrier = null;
            time = 0;
            wavelength = 30; speed = 120; damping = 0.003; globalAmplitude = 1.0;
            wavelengthSlider.value = 30; speedSlider.value = 120; dampingSlider.value = 30; amplitudeSlider.value = 100;
            wavelengthValueEl.textContent = '30'; speedValueEl.textContent = '120';
            dampingValueEl.textContent = '0.30'; amplitudeValueEl.textContent = '1.0';
            sourceCountEl.textContent = '2';
            waveType = 'circular'; setActive(btnCircle, waveTypeBtns);
            phaseColorMode = false; btnPhase.classList.remove('active');
            timeAvgMode = false; btnTimeAvg.classList.remove('active');
            view3D = false; btn3D.classList.remove('active');
            canvas3d.style.display = 'none'; canvas2d.style.display = 'block';
            showDetector = false; btnDet.classList.remove('active');
            detectorCanvas.classList.remove('visible');
            absorbingBC = false; btnAbsorb.classList.remove('active');
            currentTool = 'source'; setActive(btnToolSource, toolBtns);
            toolInfoEl.textContent = 'Tool: Add source';
            wallStart = null;
            timeAvgBuffer = null; timeAvgCount = 0;
            nextFreqIdx = 0;
            clearPresets();
            document.getElementById('presetDefault').classList.add('active');
        }

        window.reset = resetSimulation;

        // --- Keyboard: detector Y movement ---
        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && e.target === document.body) {
                e.preventDefault();
                paused = !paused;
            }
            if (e.code === 'ArrowUp' && showDetector) {
                detectorY = Math.max(0.05, detectorY - 0.02);
            }
            if (e.code === 'ArrowDown' && showDetector) {
                detectorY = Math.min(0.95, detectorY + 0.02);
            }
        });

    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
