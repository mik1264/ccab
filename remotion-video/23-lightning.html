<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightning Bolt Formation - Remotion Video Effects</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050508;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }
        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.8) 100%);
            z-index: 5;
        }
        .film-grain {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            opacity: 0.06;
            mix-blend-mode: overlay;
        }
        .info {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: monospace;
            font-size: 0.7rem;
            color: rgba(180, 160, 220, 0.35);
            z-index: 10;
            text-align: center;
            letter-spacing: 0.05em;
        }
        #ui-panel {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            font-family: 'Courier New', monospace;
            color: rgba(180, 200, 255, 0.7);
            font-size: 0.72rem;
            background: rgba(10, 10, 30, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 130, 255, 0.15);
            border-radius: 8px;
            padding: 12px 16px;
            min-width: 200px;
            user-select: none;
        }
        #ui-panel .panel-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: rgba(140, 160, 255, 0.5);
            margin-bottom: 8px;
        }
        #ui-panel .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        #ui-panel .stat-label {
            color: rgba(160, 170, 200, 0.5);
        }
        #ui-panel .stat-value {
            color: rgba(200, 210, 255, 0.85);
        }
        .slider-row {
            margin-top: 8px;
        }
        .slider-row label {
            display: block;
            font-size: 0.65rem;
            color: rgba(140, 160, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 3px;
        }
        .slider-row input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(100, 130, 255, 0.15);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(140, 170, 255, 0.6);
            border: 1px solid rgba(180, 200, 255, 0.3);
        }
        #histogram-canvas {
            display: block;
            margin-top: 6px;
            border: 1px solid rgba(100, 130, 255, 0.1);
            border-radius: 3px;
        }
        #thunder-text {
            position: fixed;
            bottom: 3.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: rgba(180, 170, 220, 0.6);
            z-index: 10;
            text-align: center;
            letter-spacing: 0.08em;
            transition: opacity 0.3s;
        }
        #charge-canvas {
            position: fixed;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 3;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>
    <canvas id="canvas"></canvas>
    <canvas id="charge-canvas"></canvas>
    <canvas id="grain-canvas" class="film-grain"></canvas>
    <div class="vignette"></div>
    <div id="thunder-text"></div>
    <div id="ui-panel">
        <div class="panel-title">Storm Monitor</div>
        <div class="stat-row"><span class="stat-label">Bolts</span><span class="stat-value" id="bolt-count">0</span></div>
        <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value" id="bolt-type">--</span></div>
        <div class="stat-row"><span class="stat-label">Ball Lightning</span><span class="stat-value" id="ball-status">None</span></div>
        <div class="stat-row"><span class="stat-label">Wind</span><span class="stat-value" id="wind-display">0 m/s</span></div>
        <canvas id="histogram-canvas" width="180" height="40"></canvas>
        <div class="slider-row">
            <label>Storm Intensity</label>
            <input type="range" id="intensity-slider" min="0" max="100" value="40">
        </div>
    </div>
    <div class="info">Click anywhere to summon lightning</div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const chargeCanvas = document.getElementById('charge-canvas');
    const chargeCtx = chargeCanvas.getContext('2d');
    const grainCanvas = document.getElementById('grain-canvas');
    const grainCtx = grainCanvas.getContext('2d');
    const histCanvas = document.getElementById('histogram-canvas');
    const histCtx = histCanvas.getContext('2d');

    let W, H;
    let bolts = [];
    let flashes = [];
    let clouds = [];
    let rain = [];
    let ballLightnings = [];
    let powerLines = [];
    let buildings = [];
    let chargeRegions = [];
    let thunderQueue = [];
    let time = 0;
    let autoTimer = 0;
    let autoInterval = 2.5;
    let totalBoltCount = 0;
    let intensityHistogram = new Array(10).fill(0);
    let paused = false;
    let lastTime = 0;

    // Storm intensity (0-100)
    let stormIntensity = 40;
    const intensitySlider = document.getElementById('intensity-slider');
    intensitySlider.addEventListener('input', e => {
        stormIntensity = parseInt(e.target.value);
    });

    // Wind simulation
    let wind = { speed: 0, target: 0, gustTimer: 0 };

    // Flash inversion effect
    let invertFlash = { active: false, timer: 0, duration: 0.06 };

    // Web Audio for thunder
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) { /* no audio */ }
        }
    }

    function playThunder(distance, intensity) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const delay = distance * 0.003; // ~3ms per "unit" distance
        const duration = 1.5 + intensity * 2;
        const volume = Math.max(0.02, 0.4 * intensity / (1 + distance * 0.005));

        // Low rumble using filtered noise
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            const env = Math.exp(-i / (bufferSize * 0.3)) * (1 + 0.5 * Math.sin(i / (bufferSize * 0.05)));
            data[i] = (Math.random() * 2 - 1) * env;
        }

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;

        const lowpass = audioCtx.createBiquadFilter();
        lowpass.type = 'lowpass';
        lowpass.frequency.value = 80 + intensity * 60;
        lowpass.Q.value = 0.7;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0, now + delay);
        gain.gain.linearRampToValueAtTime(volume, now + delay + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, now + delay + duration);

        source.connect(lowpass);
        lowpass.connect(gain);
        gain.connect(audioCtx.destination);
        source.start(now + delay);
        source.stop(now + delay + duration);
    }

    // --- Resize ---
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        chargeCanvas.width = W;
        chargeCanvas.height = H;
        grainCanvas.width = W;
        grainCanvas.height = H;
        generateClouds();
        generateRain();
        generateBuildings();
        generatePowerLines();
    }

    // --- Cloud generation (volumetric multi-layer) ---
    function generateClouds() {
        clouds = [];
        const cloudCount = Math.max(10, Math.floor(W / 90));
        for (let i = 0; i < cloudCount; i++) {
            const cx = (W / cloudCount) * i + Math.random() * (W / cloudCount);
            const cy = H * 0.03 + Math.random() * H * 0.12;
            const layerCount = 2 + Math.floor(Math.random() * 3);
            const layers = [];
            for (let layer = 0; layer < layerCount; layer++) {
                const blobCount = 4 + Math.floor(Math.random() * 6);
                const blobs = [];
                const layerDepth = layer / layerCount;
                for (let j = 0; j < blobCount; j++) {
                    blobs.push({
                        ox: (Math.random() - 0.5) * (160 + layer * 30),
                        oy: (Math.random() - 0.5) * (45 + layer * 15),
                        rx: 50 + Math.random() * 90 + layer * 15,
                        ry: 28 + Math.random() * 40,
                        baseAlpha: (0.08 + Math.random() * 0.12) * (1 - layerDepth * 0.3),
                        depth: layerDepth
                    });
                }
                layers.push({ blobs, depth: layerDepth });
            }
            clouds.push({
                cx, cy, layers,
                drift: (Math.random() - 0.5) * 10,
                glowIntensity: 0,
                charge: Math.random() < 0.5 ? 'positive' : 'negative'
            });
        }
    }

    // --- Rain ---
    function generateRain() {
        rain = [];
        const baseDensity = stormIntensity / 40;
        const count = Math.floor(W * H / 3000 * baseDensity);
        for (let i = 0; i < count; i++) {
            rain.push({
                x: Math.random() * W * 1.4 - W * 0.2,
                y: Math.random() * H,
                speed: 6 + Math.random() * 12,
                len: 10 + Math.random() * 22,
                alpha: 0.03 + Math.random() * 0.08,
                thickness: 0.3 + Math.random() * 0.7
            });
        }
    }

    // --- City silhouette ---
    function generateBuildings() {
        buildings = [];
        const horizonY = H * 0.88;
        let x = 0;
        while (x < W) {
            const w = 15 + Math.random() * 50;
            const h = 15 + Math.random() * 80;
            const hasAntenna = Math.random() < 0.2;
            const windows = [];
            const wCols = Math.floor(w / 8);
            const wRows = Math.floor(h / 10);
            for (let r = 0; r < wRows; r++) {
                for (let c = 0; c < wCols; c++) {
                    if (Math.random() < 0.4) {
                        windows.push({
                            rx: 3 + c * 8 + Math.random() * 2,
                            ry: 4 + r * 10 + Math.random() * 2,
                            lit: Math.random() < 0.15,
                            w: 3 + Math.random() * 2,
                            h: 3 + Math.random() * 4
                        });
                    }
                }
            }
            buildings.push({
                x, y: horizonY - h, w, h,
                hasAntenna,
                antennaH: hasAntenna ? 10 + Math.random() * 25 : 0,
                windows,
                color: `hsl(230, ${10 + Math.random() * 10}%, ${3 + Math.random() * 4}%)`
            });
            x += w + Math.random() * 8;
        }
    }

    // --- Power lines ---
    function generatePowerLines() {
        powerLines = [];
        const horizonY = H * 0.88;
        const poleCount = Math.floor(W / 200);
        for (let i = 0; i < poleCount; i++) {
            const px = 100 + i * (W / poleCount) + (Math.random() - 0.5) * 40;
            const poleH = 50 + Math.random() * 30;
            powerLines.push({
                x: px,
                y: horizonY - poleH,
                baseY: horizonY,
                poleH,
                sparking: false,
                sparkTimer: 0
            });
        }
    }

    // --- Lightning bolt generation using stepped leader algorithm ---
    function generateBolt(startX, startY, endY, isMain, jitterScale) {
        const segments = [];
        let x = startX;
        let y = startY;
        const totalDist = endY - startY;
        const stepCount = 30 + Math.random() * 25;
        const stepSize = totalDist / stepCount;
        const jitter = (isMain ? 65 : 30) * (jitterScale || 1);

        while (y < endY) {
            const newY = Math.min(y + stepSize + Math.random() * stepSize * 0.5, endY);
            const newX = x + (Math.random() - 0.5) * jitter;
            segments.push({ x1: x, y1: y, x2: newX, y2: newY });
            x = newX;
            y = newY;
        }
        return segments;
    }

    function createBranch(parentSeg, depth, maxDepth) {
        if (depth >= maxDepth) return [];
        const branches = [];
        const branchLen = (H * 0.3) / (depth + 1);
        const dir = Math.random() < 0.5 ? -1 : 1;
        let bx = parentSeg.x2;
        let by = parentSeg.y2;
        const steps = 5 + Math.floor(Math.random() * 8);
        const stepY = branchLen / steps;
        const jitter = 25 / (depth + 1);

        const segs = [];
        for (let i = 0; i < steps; i++) {
            const newX = bx + dir * (5 + Math.random() * jitter) + (Math.random() - 0.5) * jitter * 0.5;
            const newY = by + stepY + Math.random() * stepY * 0.3;
            segs.push({ x1: bx, y1: by, x2: newX, y2: newY });
            bx = newX;
            by = newY;
        }
        branches.push(...segs);

        if (depth < maxDepth - 1 && segs.length > 2) {
            const subIdx = Math.floor(Math.random() * (segs.length - 1)) + 1;
            if (Math.random() < 0.5) {
                branches.push(...createBranch(segs[subIdx], depth + 1, maxDepth));
            }
        }
        return branches;
    }

    // Lightning types: fork, sheet, ribbon, bead
    const LIGHTNING_TYPES = ['fork', 'sheet', 'ribbon', 'bead'];

    function chooseLightningType() {
        const r = Math.random();
        if (r < 0.5) return 'fork';
        if (r < 0.75) return 'sheet';
        if (r < 0.92) return 'ribbon';
        return 'bead';
    }

    // --- Spawn cloud-to-ground bolt ---
    function spawnBolt(targetX, forceType) {
        initAudio();
        const lightningType = forceType || chooseLightningType();
        let cloudX = targetX + (Math.random() - 0.5) * 80;
        let cloudY = H * 0.06 + Math.random() * H * 0.08;

        const mainSegments = generateBolt(cloudX, cloudY, H * (0.86 + Math.random() * 0.06), true,
            lightningType === 'ribbon' ? 1.6 : 1);

        const branchSegments = [];
        const branchCount = lightningType === 'fork' ? (4 + Math.floor(Math.random() * 6)) :
                            lightningType === 'sheet' ? (8 + Math.floor(Math.random() * 8)) :
                            (2 + Math.floor(Math.random() * 3));

        const branchableIndices = [];
        for (let i = Math.floor(mainSegments.length * 0.1); i < Math.floor(mainSegments.length * 0.7); i++) {
            branchableIndices.push(i);
        }

        for (let b = 0; b < branchCount && branchableIndices.length > 0; b++) {
            const pickIdx = Math.floor(Math.random() * branchableIndices.length);
            const segIdx = branchableIndices.splice(pickIdx, 1)[0];
            const parentSeg = mainSegments[segIdx];
            const maxDepth = 1 + Math.floor(Math.random() * 2);
            branchSegments.push(...createBranch(parentSeg, 0, maxDepth));
        }

        const intensity = 0.5 + (stormIntensity / 100) * 0.5 + Math.random() * 0.2;
        const bolt = {
            mainSegments,
            branchSegments,
            phase: 'leader',
            leaderProgress: 0,
            strokeTime: 0,
            strokeDuration: 0.08 + Math.random() * 0.04,
            fadeTime: 0,
            fadeDuration: 0.3 + Math.random() * 0.3,
            flickerCount: 1 + Math.floor(Math.random() * 3),
            flickerPhase: 0,
            alive: true,
            intensity,
            hue: 200 + Math.random() * 60,
            type: lightningType,
            direction: 'down',
            ribbonOffset: lightningType === 'ribbon' ? (3 + Math.random() * 5) : 0,
            beadGaps: [],
            originX: cloudX,
            originY: cloudY,
            groundX: mainSegments.length > 0 ? mainSegments[mainSegments.length - 1].x2 : targetX,
            groundY: mainSegments.length > 0 ? mainSegments[mainSegments.length - 1].y2 : H * 0.9
        };

        // Bead gaps
        if (lightningType === 'bead') {
            for (let i = 0; i < mainSegments.length; i++) {
                if (Math.random() < 0.3) {
                    bolt.beadGaps.push(i);
                }
            }
        }

        bolts.push(bolt);
        totalBoltCount++;

        // Record histogram
        const histBin = Math.min(9, Math.floor(intensity * 10));
        intensityHistogram[histBin]++;

        // Update UI
        document.getElementById('bolt-count').textContent = totalBoltCount;
        document.getElementById('bolt-type').textContent = lightningType;

        // Schedule flash
        setTimeout(() => {
            const flashIntensity = intensity * (lightningType === 'sheet' ? 1.3 : 1);
            flashes.push({ intensity: flashIntensity, time: 0, duration: 0.15 + Math.random() * 0.05 });
            // Flash photography inversion on bright strikes
            if (intensity > 0.85) {
                invertFlash.active = true;
                invertFlash.timer = 0;
            }
        }, 200);

        // Thunder timing
        const dist = Math.abs(targetX - W / 2) + Math.random() * 200;
        const thunderDelaySec = dist / 340; // speed of sound ~340 m/s
        const thunderDelayDisplay = Math.max(1, Math.round(thunderDelaySec * 3));
        thunderQueue.push({
            text: `thunder in ~${thunderDelayDisplay}s`,
            displayTime: 2.5,
            timer: 0,
            audioDelay: thunderDelaySec * 0.5,
            audioPlayed: false,
            intensity,
            distance: dist
        });

        // Check power line strikes
        for (const pl of powerLines) {
            if (Math.abs(pl.x - bolt.groundX) < 40) {
                pl.sparking = true;
                pl.sparkTimer = 0.8 + Math.random() * 0.5;
            }
        }

        // Ball lightning (rare)
        if (Math.random() < 0.08 && stormIntensity > 30) {
            spawnBallLightning(bolt.groundX, bolt.groundY);
        }
    }

    // --- Cloud-to-cloud lightning ---
    function spawnCloudToCloud() {
        initAudio();
        if (clouds.length < 2) return;
        const c1Idx = Math.floor(Math.random() * clouds.length);
        let c2Idx = (c1Idx + 1 + Math.floor(Math.random() * (clouds.length - 1))) % clouds.length;
        const c1 = clouds[c1Idx];
        const c2 = clouds[c2Idx];

        const startX = c1.cx;
        const startY = c1.cy + 10 + Math.random() * 20;
        const endX = c2.cx;
        const endY = c2.cy + 10 + Math.random() * 20;

        const segments = [];
        const steps = 20 + Math.floor(Math.random() * 20);
        let x = startX, y = startY;
        for (let i = 0; i < steps; i++) {
            const t = (i + 1) / steps;
            const nx = startX + (endX - startX) * t + (Math.random() - 0.5) * 50;
            const ny = startY + (endY - startY) * t + (Math.random() - 0.5) * 30;
            segments.push({ x1: x, y1: y, x2: nx, y2: ny });
            x = nx;
            y = ny;
        }

        const intensity = 0.4 + Math.random() * 0.4;
        bolts.push({
            mainSegments: segments,
            branchSegments: [],
            phase: 'stroke',
            leaderProgress: 1,
            strokeTime: 0,
            strokeDuration: 0.1 + Math.random() * 0.06,
            fadeTime: 0,
            fadeDuration: 0.2 + Math.random() * 0.2,
            flickerCount: 1 + Math.floor(Math.random() * 2),
            flickerPhase: 0,
            alive: true,
            intensity,
            hue: 210 + Math.random() * 50,
            type: 'cloud-to-cloud',
            direction: 'horizontal',
            ribbonOffset: 0,
            beadGaps: [],
            originX: startX,
            originY: startY,
            groundX: endX,
            groundY: endY
        });

        totalBoltCount++;
        document.getElementById('bolt-count').textContent = totalBoltCount;
        document.getElementById('bolt-type').textContent = 'cloud-to-cloud';

        c1.glowIntensity = Math.max(c1.glowIntensity, intensity);
        c2.glowIntensity = Math.max(c2.glowIntensity, intensity);
        flashes.push({ intensity: intensity * 0.5, time: 0, duration: 0.1 });
    }

    // --- Upward lightning (ground-to-cloud) ---
    function spawnUpwardLightning() {
        initAudio();
        const groundX = W * 0.1 + Math.random() * W * 0.8;
        const groundY = H * 0.88;
        const cloudY = H * 0.05 + Math.random() * H * 0.08;

        const segments = [];
        let x = groundX, y = groundY;
        const steps = 25 + Math.floor(Math.random() * 20);
        const stepY = (groundY - cloudY) / steps;

        for (let i = 0; i < steps; i++) {
            const newY = Math.max(y - stepY - Math.random() * stepY * 0.3, cloudY);
            const newX = x + (Math.random() - 0.5) * 55;
            segments.push({ x1: x, y1: y, x2: newX, y2: newY });
            x = newX;
            y = newY;
        }

        // Upward branches
        const branchSegments = [];
        for (let b = 0; b < 2 + Math.floor(Math.random() * 3); b++) {
            const segIdx = Math.floor(Math.random() * segments.length * 0.6) + Math.floor(segments.length * 0.2);
            if (segIdx < segments.length) {
                const parentSeg = segments[segIdx];
                const dir = Math.random() < 0.5 ? -1 : 1;
                let bx = parentSeg.x2, by = parentSeg.y2;
                for (let s = 0; s < 5 + Math.floor(Math.random() * 5); s++) {
                    const nx = bx + dir * (5 + Math.random() * 15) + (Math.random() - 0.5) * 10;
                    const ny = by - 10 - Math.random() * 15;
                    branchSegments.push({ x1: bx, y1: by, x2: nx, y2: ny });
                    bx = nx;
                    by = ny;
                }
            }
        }

        const intensity = 0.6 + Math.random() * 0.3;
        bolts.push({
            mainSegments: segments,
            branchSegments,
            phase: 'leader',
            leaderProgress: 0,
            strokeTime: 0,
            strokeDuration: 0.1 + Math.random() * 0.05,
            fadeTime: 0,
            fadeDuration: 0.4 + Math.random() * 0.3,
            flickerCount: 2 + Math.floor(Math.random() * 2),
            flickerPhase: 0,
            alive: true,
            intensity,
            hue: 220 + Math.random() * 40,
            type: 'upward',
            direction: 'up',
            ribbonOffset: 0,
            beadGaps: [],
            originX: groundX,
            originY: groundY,
            groundX,
            groundY
        });

        totalBoltCount++;
        document.getElementById('bolt-count').textContent = totalBoltCount;
        document.getElementById('bolt-type').textContent = 'upward';
        flashes.push({ intensity: intensity * 0.6, time: 0, duration: 0.12 });
    }

    // --- Ball lightning ---
    function spawnBallLightning(x, y) {
        ballLightnings.push({
            x, y,
            vx: (Math.random() - 0.5) * 30,
            vy: -10 - Math.random() * 20,
            radius: 8 + Math.random() * 15,
            life: 3 + Math.random() * 5,
            maxLife: 0,
            hue: 200 + Math.random() * 80,
            pulsePhase: Math.random() * Math.PI * 2
        });
        ballLightnings[ballLightnings.length - 1].maxLife = ballLightnings[ballLightnings.length - 1].life;
        document.getElementById('ball-status').textContent = 'Active!';
        document.getElementById('ball-status').style.color = 'rgba(180, 255, 200, 0.9)';
    }

    // --- Charge buildup ---
    function updateCharges(dt) {
        // Build up charge regions before bolts
        if (Math.random() < dt * stormIntensity * 0.02) {
            chargeRegions.push({
                x: Math.random() * W,
                y: H * 0.03 + Math.random() * H * 0.12,
                type: Math.random() < 0.5 ? '+' : '-',
                alpha: 0,
                maxAlpha: 0.15 + Math.random() * 0.2,
                radius: 20 + Math.random() * 40,
                life: 2 + Math.random() * 3,
                timer: 0
            });
        }
        for (let i = chargeRegions.length - 1; i >= 0; i--) {
            const c = chargeRegions[i];
            c.timer += dt;
            if (c.timer < 0.5) {
                c.alpha = (c.timer / 0.5) * c.maxAlpha;
            } else if (c.timer > c.life - 0.5) {
                c.alpha = ((c.life - c.timer) / 0.5) * c.maxAlpha;
            }
            if (c.timer >= c.life) {
                chargeRegions.splice(i, 1);
            }
        }
    }

    // --- Update ---
    function update(dt) {
        time += dt;
        autoTimer += dt;

        // Wind gusts
        wind.gustTimer -= dt;
        if (wind.gustTimer <= 0) {
            wind.target = (Math.random() - 0.3) * stormIntensity * 0.5;
            wind.gustTimer = 1 + Math.random() * 4;
        }
        wind.speed += (wind.target - wind.speed) * dt * 2;
        document.getElementById('wind-display').textContent = Math.abs(wind.speed).toFixed(1) + ' m/s';

        // Auto-generate lightning based on storm intensity
        const baseInterval = 5 - stormIntensity * 0.045; // 5s at 0 to 0.5s at 100
        if (autoTimer >= Math.max(0.3, baseInterval + Math.random() * baseInterval * 0.5)) {
            autoTimer = 0;
            const r = Math.random();
            if (r < 0.12 && stormIntensity > 20) {
                spawnCloudToCloud();
            } else if (r < 0.16 && stormIntensity > 50) {
                spawnUpwardLightning();
            } else {
                spawnBolt(Math.random() * W);
            }
        }

        // Update bolts
        for (let i = bolts.length - 1; i >= 0; i--) {
            const b = bolts[i];
            if (b.phase === 'leader') {
                b.leaderProgress += dt * 4.0;
                if (b.leaderProgress >= 1) {
                    b.phase = 'stroke';
                    b.strokeTime = 0;
                }
            } else if (b.phase === 'stroke') {
                b.strokeTime += dt;
                b.flickerPhase += dt * 60;
                if (b.strokeTime >= b.strokeDuration * b.flickerCount) {
                    b.phase = 'fade';
                    b.fadeTime = 0;
                }
                // Illuminate nearby clouds
                for (const cloud of clouds) {
                    const dx = cloud.cx - b.originX;
                    const dy = cloud.cy - b.originY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 300) {
                        cloud.glowIntensity = Math.max(cloud.glowIntensity, b.intensity * (1 - dist / 300));
                    }
                }
            } else if (b.phase === 'fade') {
                b.fadeTime += dt;
                if (b.fadeTime >= b.fadeDuration) {
                    b.alive = false;
                }
            }
            if (!b.alive) bolts.splice(i, 1);
        }

        // Update flashes
        for (let i = flashes.length - 1; i >= 0; i--) {
            flashes[i].time += dt;
            if (flashes[i].time >= flashes[i].duration) flashes.splice(i, 1);
        }

        // Update rain (wind-blown)
        const rainAngle = wind.speed * 0.04;
        for (const drop of rain) {
            drop.y += drop.speed * (1 + stormIntensity * 0.01);
            drop.x += wind.speed * 0.3 + 1.2;
            if (drop.y > H + drop.len) {
                drop.y = -drop.len;
                drop.x = Math.random() * W * 1.4 - W * 0.2;
            }
            if (drop.x > W + 50) drop.x -= W + 100;
            if (drop.x < -50) drop.x += W + 100;
        }

        // Drift clouds
        for (const c of clouds) {
            c.cx += (c.drift + wind.speed * 0.1) * dt;
            c.glowIntensity *= Math.pow(0.05, dt); // decay glow
            if (c.cx > W + 250) c.cx = -250;
            if (c.cx < -250) c.cx = W + 250;
        }

        // Update ball lightnings
        for (let i = ballLightnings.length - 1; i >= 0; i--) {
            const bl = ballLightnings[i];
            bl.x += bl.vx * dt;
            bl.y += bl.vy * dt;
            bl.vy *= 0.99;
            bl.vx += (Math.random() - 0.5) * 5 * dt;
            bl.life -= dt;
            bl.pulsePhase += dt * 4;
            if (bl.life <= 0) {
                ballLightnings.splice(i, 1);
                if (ballLightnings.length === 0) {
                    document.getElementById('ball-status').textContent = 'None';
                    document.getElementById('ball-status').style.color = '';
                }
            }
        }

        // Power line sparks
        for (const pl of powerLines) {
            if (pl.sparking) {
                pl.sparkTimer -= dt;
                if (pl.sparkTimer <= 0) pl.sparking = false;
            }
        }

        // Thunder queue
        for (let i = thunderQueue.length - 1; i >= 0; i--) {
            const tq = thunderQueue[i];
            tq.timer += dt;
            if (!tq.audioPlayed && tq.timer >= tq.audioDelay) {
                tq.audioPlayed = true;
                playThunder(tq.distance, tq.intensity);
            }
            if (tq.timer >= tq.displayTime) {
                thunderQueue.splice(i, 1);
            }
        }
        // Show latest thunder text
        const thunderEl = document.getElementById('thunder-text');
        if (thunderQueue.length > 0) {
            thunderEl.textContent = thunderQueue[thunderQueue.length - 1].text;
            thunderEl.style.opacity = '1';
        } else {
            thunderEl.style.opacity = '0';
        }

        // Flash inversion
        if (invertFlash.active) {
            invertFlash.timer += dt;
            if (invertFlash.timer >= invertFlash.duration) {
                invertFlash.active = false;
                invertFlash.timer = 0;
            }
        }

        // Charge regions
        updateCharges(dt);
    }

    // --- Draw ---
    function drawSkyGradient() {
        const intensity01 = stormIntensity / 100;
        const baseBright = 5 + intensity01 * 3;
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, `hsl(250, 25%, ${baseBright}%)`);
        grad.addColorStop(0.2, `hsl(255, 30%, ${baseBright + 5}%)`);
        grad.addColorStop(0.5, `hsl(245, 35%, ${baseBright + 8}%)`);
        grad.addColorStop(0.8, `hsl(235, 25%, ${baseBright + 3}%)`);
        grad.addColorStop(1, `hsl(220, 20%, ${baseBright - 1}%)`);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    }

    function drawClouds(illumination) {
        for (const cloud of clouds) {
            const glow = Math.max(illumination, cloud.glowIntensity);
            for (const layer of cloud.layers) {
                for (const blob of layer.blobs) {
                    const litBoost = glow * (1 - layer.depth * 0.5);
                    const alpha = blob.baseAlpha + litBoost * 0.5;
                    const gray = Math.floor(60 + litBoost * 180);
                    const blueBoost = Math.min(255, gray + 30 + litBoost * 30);

                    // Internal glow during lightning
                    if (glow > 0.2) {
                        const glowGrad = ctx.createRadialGradient(
                            cloud.cx + blob.ox, cloud.cy + blob.oy, 0,
                            cloud.cx + blob.ox, cloud.cy + blob.oy, blob.rx
                        );
                        glowGrad.addColorStop(0, `rgba(${Math.min(255, gray + 60)}, ${Math.min(255, gray + 40)}, ${Math.min(255, blueBoost + 20)}, ${alpha * glow * 0.6})`);
                        glowGrad.addColorStop(1, `rgba(${gray}, ${gray}, ${blueBoost}, ${alpha * 0.1})`);
                        ctx.fillStyle = glowGrad;
                    } else {
                        ctx.fillStyle = `rgba(${gray}, ${gray}, ${blueBoost}, ${alpha})`;
                    }
                    ctx.beginPath();
                    ctx.ellipse(
                        cloud.cx + blob.ox,
                        cloud.cy + blob.oy,
                        blob.rx, blob.ry,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }
    }

    function drawRain(illumination) {
        const windAngle = wind.speed * 0.03;
        for (const drop of rain) {
            const a = drop.alpha + illumination * 0.1;
            const bright = Math.floor(150 + illumination * 100);
            ctx.strokeStyle = `rgba(${bright}, ${bright}, ${Math.min(255, bright + 30)}, ${a})`;
            ctx.lineWidth = drop.thickness;
            ctx.beginPath();
            const dx = Math.sin(windAngle) * drop.len;
            const dy = Math.cos(windAngle) * drop.len;
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x + dx, drop.y + dy);
            ctx.stroke();
        }
    }

    function drawBoltSegments(segments, color, width, alpha, progress, beadGaps) {
        if (segments.length === 0) return;
        const visibleCount = Math.floor(segments.length * progress);
        for (let i = 0; i < visibleCount; i++) {
            if (beadGaps && beadGaps.includes(i)) continue;
            const seg = segments[i];
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(seg.x1, seg.y1);
            ctx.lineTo(seg.x2, seg.y2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    function drawBolt(bolt) {
        const h = bolt.hue;
        const isRibbon = bolt.type === 'ribbon';
        const ribbonOff = bolt.ribbonOffset;
        const beadGaps = bolt.type === 'bead' ? bolt.beadGaps : null;

        if (bolt.phase === 'leader') {
            const prog = bolt.leaderProgress;
            drawBoltSegments(bolt.mainSegments, `hsla(${h}, 70%, 60%, 0.15)`, 8, 0.3, prog, beadGaps);
            drawBoltSegments(bolt.mainSegments, `hsla(${h}, 50%, 70%, 0.6)`, 1.5, 0.5, prog, beadGaps);
        } else if (bolt.phase === 'stroke') {
            const flicker = Math.sin(bolt.flickerPhase) > -0.3 ? 1 : 0.15;
            const intensity = bolt.intensity * flicker;

            // Sheet lightning: wider, more diffuse glow
            const sheetMul = bolt.type === 'sheet' ? 2.5 : 1;

            // Ribbon: draw offset copies
            const offsets = isRibbon ? [-ribbonOff, 0, ribbonOff] : [0];

            for (const off of offsets) {
                ctx.save();
                ctx.translate(off, 0);
                drawBoltSegments(bolt.mainSegments, `hsla(${h}, 60%, 80%, ${0.06 * intensity * sheetMul})`, 40 * sheetMul, 1, 1, beadGaps);
                drawBoltSegments(bolt.mainSegments, `hsla(${h}, 70%, 85%, ${0.12 * intensity})`, 20, 1, 1, beadGaps);
                drawBoltSegments(bolt.mainSegments, `hsla(${h}, 80%, 90%, ${0.25 * intensity})`, 8, 1, 1, beadGaps);
                drawBoltSegments(bolt.mainSegments, `hsla(0, 0%, 100%, ${(isRibbon ? 0.6 : 0.9) * intensity})`, isRibbon ? 1.5 : 2.5, 1, 1, beadGaps);
                ctx.restore();
            }

            // Branches
            drawBoltSegments(bolt.branchSegments, `hsla(${h}, 60%, 75%, ${0.1 * intensity})`, 12, 1, 1);
            drawBoltSegments(bolt.branchSegments, `hsla(${h}, 70%, 85%, ${0.25 * intensity})`, 4, 1, 1);
            drawBoltSegments(bolt.branchSegments, `hsla(0, 0%, 100%, ${0.7 * intensity})`, 1.2, 1, 1);

            // Ground/endpoint glow
            if (bolt.direction !== 'horizontal') {
                const lastSeg = bolt.mainSegments[bolt.mainSegments.length - 1];
                if (lastSeg) {
                    const grad = ctx.createRadialGradient(lastSeg.x2, lastSeg.y2, 0, lastSeg.x2, lastSeg.y2, 120 * intensity);
                    grad.addColorStop(0, `hsla(${h}, 80%, 90%, ${0.4 * intensity})`);
                    grad.addColorStop(0.3, `hsla(${h}, 70%, 70%, ${0.15 * intensity})`);
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.fillRect(lastSeg.x2 - 150, lastSeg.y2 - 150, 300, 300);
                }
            }

            // Cloud illumination at origin
            const firstSeg = bolt.mainSegments[0];
            if (firstSeg) {
                const cGrad = ctx.createRadialGradient(firstSeg.x1, firstSeg.y1, 0, firstSeg.x1, firstSeg.y1, 250 * intensity);
                cGrad.addColorStop(0, `hsla(${h}, 50%, 85%, ${0.35 * intensity})`);
                cGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = cGrad;
                ctx.fillRect(firstSeg.x1 - 300, firstSeg.y1 - 300, 600, 600);
            }

            // Bead lightning: bright dots at segment joints
            if (bolt.type === 'bead') {
                for (let i = 0; i < bolt.mainSegments.length; i++) {
                    if (!beadGaps.includes(i)) {
                        const seg = bolt.mainSegments[i];
                        ctx.beginPath();
                        ctx.arc(seg.x2, seg.y2, 3 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(0, 0%, 100%, ${0.8 * intensity})`;
                        ctx.fill();
                    }
                }
            }
        } else if (bolt.phase === 'fade') {
            const fadeAlpha = 1 - (bolt.fadeTime / bolt.fadeDuration);
            const ea = fadeAlpha * fadeAlpha;

            drawBoltSegments(bolt.mainSegments, `hsla(${h}, 60%, 75%, ${0.08 * ea})`, 14, 1, 1, beadGaps);
            drawBoltSegments(bolt.mainSegments, `hsla(${h}, 70%, 85%, ${0.2 * ea})`, 5, 1, 1, beadGaps);
            drawBoltSegments(bolt.mainSegments, `hsla(0, 0%, 100%, ${0.6 * ea})`, 1.5, 1, 1, beadGaps);

            drawBoltSegments(bolt.branchSegments, `hsla(${h}, 60%, 75%, ${0.1 * ea})`, 6, 1, 1);
            drawBoltSegments(bolt.branchSegments, `hsla(0, 0%, 100%, ${0.4 * ea})`, 0.8, 1, 1);
        }
    }

    function drawFlash() {
        let totalIntensity = 0;
        for (const f of flashes) {
            const progress = f.time / f.duration;
            let alpha;
            if (progress < 0.15) {
                alpha = progress / 0.15;
            } else {
                alpha = 1 - ((progress - 0.15) / 0.85);
            }
            totalIntensity += f.intensity * alpha * alpha;
        }
        totalIntensity = Math.min(totalIntensity, 1);

        if (totalIntensity > 0.01) {
            ctx.fillStyle = `rgba(200, 190, 255, ${totalIntensity * 0.35})`;
            ctx.fillRect(0, 0, W, H);
        }
        return totalIntensity;
    }

    function drawBuildings(illumination) {
        const horizonY = H * 0.88;
        for (const b of buildings) {
            // Building body
            const litAmount = illumination * 0.6;
            const r = 8 + litAmount * 60;
            const g = 8 + litAmount * 55;
            const bl = 15 + litAmount * 70;
            ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(bl)})`;
            ctx.fillRect(b.x, b.y, b.w, b.h);

            // Antenna
            if (b.hasAntenna) {
                ctx.strokeStyle = `rgb(${Math.floor(r + 10)}, ${Math.floor(g + 8)}, ${Math.floor(bl + 12)})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                const antX = b.x + b.w / 2;
                ctx.moveTo(antX, b.y);
                ctx.lineTo(antX, b.y - b.antennaH);
                ctx.stroke();
                // Blinking red light
                if (Math.sin(time * 2) > 0.3) {
                    ctx.beginPath();
                    ctx.arc(antX, b.y - b.antennaH, 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 40, 40, 0.8)';
                    ctx.fill();
                }
            }

            // Windows
            for (const win of b.windows) {
                const winLit = win.lit || illumination > 0.3;
                if (winLit) {
                    const wa = win.lit ? 0.4 + Math.random() * 0.1 : illumination * 0.7;
                    ctx.fillStyle = `rgba(255, 240, 180, ${wa})`;
                    ctx.fillRect(b.x + win.rx, b.y + win.ry, win.w, win.h);
                }
            }
        }
    }

    function drawPowerLines(illumination) {
        ctx.strokeStyle = `rgba(${40 + illumination * 80}, ${35 + illumination * 70}, ${50 + illumination * 90}, 0.6)`;
        ctx.lineWidth = 1;

        for (let i = 0; i < powerLines.length; i++) {
            const pl = powerLines[i];
            // Pole
            ctx.beginPath();
            ctx.moveTo(pl.x, pl.baseY);
            ctx.lineTo(pl.x, pl.y);
            ctx.stroke();

            // Cross arm
            ctx.beginPath();
            ctx.moveTo(pl.x - 15, pl.y + 5);
            ctx.lineTo(pl.x + 15, pl.y + 5);
            ctx.stroke();

            // Wire to next pole
            if (i < powerLines.length - 1) {
                const next = powerLines[i + 1];
                ctx.beginPath();
                ctx.moveTo(pl.x + 15, pl.y + 5);
                const midX = (pl.x + next.x) / 2;
                const sag = 15 + Math.abs(next.x - pl.x) * 0.02;
                ctx.quadraticCurveTo(midX, pl.y + 5 + sag, next.x - 15, next.y + 5);
                ctx.stroke();
                // Second wire
                ctx.beginPath();
                ctx.moveTo(pl.x - 15, pl.y + 5);
                ctx.quadraticCurveTo(midX, pl.y + 8 + sag, next.x + 15, next.y + 5);
                ctx.stroke();
            }

            // Sparks
            if (pl.sparking) {
                for (let s = 0; s < 5; s++) {
                    const sx = pl.x + (Math.random() - 0.5) * 20;
                    const sy = pl.y + Math.random() * 10;
                    const sparkLen = 3 + Math.random() * 8;
                    const angle = Math.random() * Math.PI * 2;
                    ctx.strokeStyle = `rgba(255, 240, 150, ${0.5 + Math.random() * 0.5})`;
                    ctx.lineWidth = 0.5 + Math.random();
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + Math.cos(angle) * sparkLen, sy + Math.sin(angle) * sparkLen);
                    ctx.stroke();
                }
                // Spark glow
                const sparkGrad = ctx.createRadialGradient(pl.x, pl.y, 0, pl.x, pl.y, 25);
                sparkGrad.addColorStop(0, `rgba(255, 230, 120, ${0.3 * pl.sparkTimer})`);
                sparkGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = sparkGrad;
                ctx.fillRect(pl.x - 30, pl.y - 30, 60, 60);
            }
        }
    }

    function drawGround(illumination) {
        const horizonY = H * 0.88;
        const grad = ctx.createLinearGradient(0, horizonY, 0, H);
        const litR = 5 + illumination * 30;
        const litG = 5 + illumination * 25;
        const litB = 8 + illumination * 40;
        grad.addColorStop(0, 'transparent');
        grad.addColorStop(0.15, `rgba(${Math.floor(litR)}, ${Math.floor(litG)}, ${Math.floor(litB)}, 0.5)`);
        grad.addColorStop(1, `rgba(${Math.floor(litR * 0.6)}, ${Math.floor(litG * 0.6)}, ${Math.floor(litB * 0.7)}, 0.95)`);
        ctx.fillStyle = grad;
        ctx.fillRect(0, horizonY, W, H - horizonY);
    }

    function drawBallLightnings() {
        for (const bl of ballLightnings) {
            const lifeRatio = bl.life / bl.maxLife;
            const pulse = 0.7 + 0.3 * Math.sin(bl.pulsePhase);
            const r = bl.radius * pulse;

            // Outer glow
            const grad = ctx.createRadialGradient(bl.x, bl.y, 0, bl.x, bl.y, r * 4);
            grad.addColorStop(0, `hsla(${bl.hue}, 80%, 85%, ${0.3 * lifeRatio})`);
            grad.addColorStop(0.3, `hsla(${bl.hue}, 70%, 60%, ${0.1 * lifeRatio})`);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(bl.x - r * 4, bl.y - r * 4, r * 8, r * 8);

            // Core
            const coreGrad = ctx.createRadialGradient(bl.x, bl.y, 0, bl.x, bl.y, r);
            coreGrad.addColorStop(0, `hsla(0, 0%, 100%, ${0.9 * lifeRatio * pulse})`);
            coreGrad.addColorStop(0.4, `hsla(${bl.hue}, 70%, 80%, ${0.7 * lifeRatio})`);
            coreGrad.addColorStop(1, `hsla(${bl.hue}, 80%, 50%, ${0.2 * lifeRatio})`);
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(bl.x, bl.y, r, 0, Math.PI * 2);
            ctx.fill();

            // Tiny arcs around ball
            for (let a = 0; a < 3; a++) {
                const angle = time * 3 + a * Math.PI * 2 / 3;
                const arcR = r * 1.5 + Math.random() * r;
                const ax = bl.x + Math.cos(angle) * arcR;
                const ay = bl.y + Math.sin(angle) * arcR;
                ctx.strokeStyle = `hsla(${bl.hue}, 80%, 85%, ${0.3 * lifeRatio * Math.random()})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(bl.x + Math.cos(angle) * r, bl.y + Math.sin(angle) * r);
                ctx.quadraticCurveTo(
                    bl.x + Math.cos(angle + 0.3) * arcR * 0.7,
                    bl.y + Math.sin(angle + 0.3) * arcR * 0.7,
                    ax, ay
                );
                ctx.stroke();
            }
        }
    }

    function drawChargeRegions() {
        chargeCtx.clearRect(0, 0, W, H);
        for (const c of chargeRegions) {
            if (c.alpha < 0.01) continue;
            chargeCtx.font = `${c.radius * 0.6}px monospace`;
            chargeCtx.textAlign = 'center';
            chargeCtx.textBaseline = 'middle';
            chargeCtx.fillStyle = c.type === '+' ?
                `rgba(255, 120, 120, ${c.alpha})` :
                `rgba(120, 120, 255, ${c.alpha})`;
            // Draw cluster of charges
            for (let p = 0; p < 5; p++) {
                const px = c.x + (Math.random() - 0.5) * c.radius * 2;
                const py = c.y + (Math.random() - 0.5) * c.radius;
                chargeCtx.globalAlpha = c.alpha * (0.3 + Math.random() * 0.7);
                chargeCtx.fillText(c.type, px, py);
            }
        }
        chargeCtx.globalAlpha = 1;
    }

    function drawFilmGrain() {
        const imageData = grainCtx.createImageData(W, H);
        const data = imageData.data;
        // Sparse grain for performance
        const step = 4;
        for (let y = 0; y < H; y += step) {
            for (let x = 0; x < W; x += step) {
                const val = Math.random() * 255;
                const idx = (y * W + x) * 4;
                for (let dy = 0; dy < step && y + dy < H; dy++) {
                    for (let dx = 0; dx < step && x + dx < W; dx++) {
                        const i = ((y + dy) * W + (x + dx)) * 4;
                        data[i] = val;
                        data[i + 1] = val;
                        data[i + 2] = val;
                        data[i + 3] = 255;
                    }
                }
            }
        }
        grainCtx.putImageData(imageData, 0, 0);
    }

    function drawHistogram() {
        const hW = histCanvas.width;
        const hH = histCanvas.height;
        histCtx.clearRect(0, 0, hW, hH);
        histCtx.fillStyle = 'rgba(10, 10, 30, 0.5)';
        histCtx.fillRect(0, 0, hW, hH);

        const maxVal = Math.max(1, ...intensityHistogram);
        const barW = hW / intensityHistogram.length;
        for (let i = 0; i < intensityHistogram.length; i++) {
            const barH = (intensityHistogram[i] / maxVal) * (hH - 4);
            const hue = 200 + i * 8;
            histCtx.fillStyle = `hsla(${hue}, 70%, 60%, 0.7)`;
            histCtx.fillRect(i * barW + 1, hH - barH - 2, barW - 2, barH);
        }
    }

    // --- Film grain timer ---
    let grainTimer = 0;

    // --- Main loop ---
    function draw(timestamp) {
        const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;

        if (!paused) {
            update(dt);
        }

        // Calculate illumination
        let illumination = 0;
        for (const b of bolts) {
            if (b.phase === 'stroke') {
                const flicker = Math.sin(b.flickerPhase) > -0.3 ? 1 : 0.15;
                illumination += b.intensity * flicker * 0.5;
            } else if (b.phase === 'fade') {
                const fadeAlpha = 1 - (b.fadeTime / b.fadeDuration);
                illumination += fadeAlpha * fadeAlpha * 0.2;
            }
        }
        for (const f of flashes) {
            const progress = f.time / f.duration;
            let alpha = progress < 0.15 ? progress / 0.15 : 1 - ((progress - 0.15) / 0.85);
            illumination += f.intensity * alpha * 0.3;
        }
        illumination = Math.min(illumination, 1);

        // Draw scene layers
        drawSkyGradient();
        drawGround(illumination);
        drawBuildings(illumination);
        drawPowerLines(illumination);
        drawRain(illumination);
        drawClouds(illumination);

        for (const bolt of bolts) {
            drawBolt(bolt);
        }

        drawBallLightnings();
        drawFlash();

        // Flash photography inversion effect
        if (invertFlash.active) {
            ctx.globalCompositeOperation = 'difference';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillRect(0, 0, W, H);
            ctx.globalCompositeOperation = 'source-over';
        }

        // Charge buildup visualization
        drawChargeRegions();

        // Film grain (update every few frames for performance)
        grainTimer += dt;
        if (grainTimer > 0.08) {
            grainTimer = 0;
            drawFilmGrain();
        }

        // Histogram update
        drawHistogram();

        requestAnimationFrame(draw);
    }

    // --- Interaction ---
    canvas.addEventListener('click', function(e) {
        initAudio();
        spawnBolt(e.clientX);
    });

    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        initAudio();
        const touch = e.touches[0];
        spawnBolt(touch.clientX);
    }, { passive: false });

    // --- Reset ---
    function resetScene() {
        bolts = [];
        flashes = [];
        ballLightnings = [];
        chargeRegions = [];
        thunderQueue = [];
        autoTimer = 0;
        time = 0;
        totalBoltCount = 0;
        intensityHistogram = new Array(10).fill(0);
        wind = { speed: 0, target: 0, gustTimer: 0 };
        invertFlash = { active: false, timer: 0, duration: 0.06 };
        document.getElementById('bolt-count').textContent = '0';
        document.getElementById('bolt-type').textContent = '--';
        document.getElementById('ball-status').textContent = 'None';
        document.getElementById('ball-status').style.color = '';
        generateClouds();
        generateRain();
        generateBuildings();
        generatePowerLines();
    }

    window.reset = resetScene;

    // Pause toggle
    window.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            paused = !paused;
        }
    });

    // --- Init ---
    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(draw);
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
