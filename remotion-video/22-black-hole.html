<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Black Hole Gravitational Lensing</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
canvas { display: block; }
.back-link {
    position: fixed; top: 1rem; left: 1rem;
    color: rgba(100, 200, 255, 0.6);
    text-decoration: none; font-family: monospace;
    font-size: 0.85rem; z-index: 20;
    transition: color 0.3s;
}
.back-link:hover { color: rgba(100, 200, 255, 1); }
.info-panel {
    position: fixed; bottom: 1rem; left: 1rem;
    color: rgba(100, 200, 255, 0.7);
    font-family: monospace; font-size: 0.72rem;
    z-index: 20; line-height: 1.6;
    pointer-events: none;
    backdrop-filter: blur(10px);
    background: rgba(0, 0, 0, 0.5);
    padding: 0.6rem 0.85rem;
    border-radius: 4px;
    border: 1px solid rgba(100, 200, 255, 0.1);
    min-width: 220px;
}
.info-panel .label { color: rgba(100, 200, 255, 0.45); }
.info-panel .value { color: rgba(180, 220, 255, 0.85); }
.title-overlay {
    position: fixed; top: 1rem; right: 1rem;
    color: rgba(100, 200, 255, 0.4);
    font-family: monospace; font-size: 0.75rem;
    z-index: 20; text-align: right;
    pointer-events: none;
}
.controls-panel {
    position: fixed; top: 4rem; right: 1rem;
    z-index: 20; display: flex; flex-direction: column; gap: 0.5rem;
    backdrop-filter: blur(10px);
    background: rgba(0, 0, 0, 0.5);
    padding: 0.7rem 0.85rem;
    border-radius: 4px;
    border: 1px solid rgba(100, 200, 255, 0.1);
    min-width: 180px;
}
.controls-panel label {
    color: rgba(100, 200, 255, 0.6);
    font-family: monospace; font-size: 0.7rem;
    display: flex; flex-direction: column; gap: 0.2rem;
}
.controls-panel input[type="range"] {
    width: 100%;
    -webkit-appearance: none; appearance: none;
    height: 3px; background: rgba(100, 200, 255, 0.2);
    border-radius: 2px; outline: none;
    cursor: pointer;
}
.controls-panel input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 10px; height: 10px; border-radius: 50%;
    background: rgba(100, 200, 255, 0.7);
    cursor: pointer;
}
.controls-panel .toggle-row {
    display: flex; align-items: center; gap: 0.4rem;
    cursor: pointer; user-select: none;
}
.controls-panel .toggle-row input[type="checkbox"] {
    accent-color: rgba(100, 200, 255, 0.7);
    cursor: pointer;
}
.time-dilation-clock {
    position: fixed; bottom: 1rem; right: 1rem;
    z-index: 20; pointer-events: none;
    backdrop-filter: blur(10px);
    background: rgba(0, 0, 0, 0.5);
    padding: 0.5rem 0.7rem;
    border-radius: 4px;
    border: 1px solid rgba(100, 200, 255, 0.1);
    color: rgba(100, 200, 255, 0.7);
    font-family: monospace; font-size: 0.7rem;
    text-align: center;
}
.clock-face {
    width: 60px; height: 60px;
    border: 1.5px solid rgba(100, 200, 255, 0.3);
    border-radius: 50%; margin: 0.3rem auto;
    position: relative;
}
.clock-hand {
    position: absolute; bottom: 50%; left: 50%;
    width: 1.5px; height: 22px;
    background: rgba(100, 200, 255, 0.7);
    transform-origin: bottom center;
    border-radius: 1px;
}
.clock-center {
    position: absolute; top: 50%; left: 50%;
    width: 4px; height: 4px;
    background: rgba(100, 200, 255, 0.8);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}
/* Film grain overlay */
.film-grain {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 15; pointer-events: none; opacity: 0.04;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    background-size: 256px 256px;
}
/* Scanlines */
.scanlines {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 16; pointer-events: none; opacity: 0.03;
    background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 1px,
        rgba(0, 0, 0, 0.3) 1px,
        rgba(0, 0, 0, 0.3) 2px
    );
}
/* Vignette */
.vignette {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 14; pointer-events: none;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.6) 100%);
}
</style>
</head>
<body>
<a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&larr; Back to Gallery</a>
<div class="title-overlay">
    Black Hole<br>Gravitational Lensing
</div>
<div class="info-panel" id="info"></div>

<div class="controls-panel" id="controls">
    <label>
        <span>Mass: <span id="massVal">10</span> M&#x2609;</span>
        <input type="range" id="massSlider" min="1" max="100" value="10" step="1">
    </label>
    <label>
        <span>Spin: <span id="spinVal">0.0</span></span>
        <input type="range" id="spinSlider" min="0" max="95" value="0" step="1">
    </label>
    <label class="toggle-row">
        <input type="checkbox" id="companionToggle">
        <span>Companion Star</span>
    </label>
    <label class="toggle-row">
        <input type="checkbox" id="spaghettiToggle">
        <span>Spaghettification</span>
    </label>
</div>

<div class="time-dilation-clock" id="clockPanel">
    <div>Time Dilation</div>
    <div class="clock-face" id="clockFace">
        <div class="clock-hand" id="clockHand"></div>
        <div class="clock-center"></div>
    </div>
    <div id="dilationFactor">1.000x</div>
</div>

<canvas id="canvas"></canvas>

<div class="film-grain" id="filmGrain"></div>
<div class="scanlines"></div>
<div class="vignette"></div>

<script>
(function() {
    'use strict';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // --- Configuration ---
    const CONFIG = {
        starCount: 900,
        diskParticleCount: 2500,
        orbitingParticleCount: 70,
        infallParticleCount: 18,
        jetParticleCount: 120,
        hawkingPairCount: 16,
        bhRadius: 80,
        diskInner: 1.8,
        diskOuter: 5.5,
        lensStrength: 2.5,
        diskThickness: 0.12,
        rotationSpeed: 0.0003,
        hawkingGlow: 0.15
    };

    // --- State ---
    let W, H, cx, cy;
    let mouseX = 0.5, mouseY = 0.5;
    let rawMouseX = 0.5, rawMouseY = 0.5;
    let viewTiltX = 0, viewTiltY = 0.3;
    let zoom = 1.0;
    let time = 0;
    let paused = false;
    let stars = [];
    let diskParticles = [];
    let orbitingParticles = [];
    let infallParticles = [];
    let jetParticlesUp = [];
    let jetParticlesDown = [];
    let hawkingPairs = [];
    let spaghettiObj = null;

    // Sliders
    let bhMass = 10; // solar masses
    let bhSpin = 0.0; // 0 to 0.95
    let showCompanion = false;
    let showSpaghetti = false;

    // Derived
    let schwarzschildR = CONFIG.bhRadius;
    let iscoR, photonSphereR;

    function updateDerived() {
        // Schwarzschild radius scales linearly with mass
        schwarzschildR = CONFIG.bhRadius * (bhMass / 10);
        // Kerr ISCO: for a=0, ISCO=6M (3 Rs), for a->1, ISCO->M (0.5 Rs) prograde
        const a = bhSpin;
        const z1 = 1 + Math.pow(1 - a * a, 1/3) * (Math.pow(1 + a, 1/3) + Math.pow(1 - a, 1/3));
        const z2 = Math.sqrt(3 * a * a + z1 * z1);
        const iscoFactor = 3 + z2 - Math.sqrt((3 - z1) * (3 + z1 + 2 * z2));
        iscoR = iscoFactor; // in units of Rs/2 (gravitational radius)
        // Photon sphere: 1.5 Rs for Schwarzschild
        photonSphereR = 1.5 * (1 - bhSpin * 0.33);
    }

    // --- Companion Star ---
    const companion = {
        angle: 0,
        orbitR: 8,
        starR: 0.6,
        streamParticles: []
    };

    function initCompanionStream() {
        companion.streamParticles = [];
        for (let i = 0; i < 80; i++) {
            companion.streamParticles.push({
                t: Math.random(),
                offset: (Math.random() - 0.5) * 0.3,
                size: Math.random() * 2 + 0.5,
                brightness: Math.random() * 0.5 + 0.5
            });
        }
    }

    // --- Resize ---
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        cx = W / 2;
        cy = H / 2;
    }

    // --- Star Field ---
    function initStars() {
        stars = [];
        for (let i = 0; i < CONFIG.starCount; i++) {
            stars.push({
                x: Math.random() * 2 - 1,
                y: Math.random() * 2 - 1,
                z: Math.random() * 0.8 + 0.2,
                brightness: Math.random() * 0.7 + 0.3,
                size: Math.random() * 1.5 + 0.5,
                twinkleSpeed: Math.random() * 0.02 + 0.005,
                twinkleOffset: Math.random() * Math.PI * 2
            });
        }
    }

    function drawStars() {
        const bhR = schwarzschildR * zoom;
        for (let i = 0; i < stars.length; i++) {
            const s = stars[i];
            let sx = cx + s.x * W * 0.6;
            let sy = cy + s.y * H * 0.6;

            const dx = sx - cx;
            const dy = sy - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < bhR * 1.05) continue;

            // Gravitational lensing with distortion / duplication
            let duplicated = false;
            let sx2, sy2;
            if (dist < bhR * 6) {
                const lensAmount = CONFIG.lensStrength * bhR * bhR / (dist * dist);
                const angle = Math.atan2(dy, dx);
                const deflection = lensAmount * bhR / dist;
                sx += Math.cos(angle + Math.PI / 2) * deflection * 0.5;
                sy += Math.sin(angle + Math.PI / 2) * deflection * 0.5;
                const pushFactor = 1 + (bhR * bhR) / (dist * dist) * 0.8;
                sx = cx + (sx - cx) * pushFactor;
                sy = cy + (sy - cy) * pushFactor;

                // Create secondary image for close stars (gravitational lensing duplicate)
                if (dist < bhR * 2.5 && dist > bhR * 1.2) {
                    duplicated = true;
                    const mirrorAngle = angle + Math.PI;
                    const mirrorDist = bhR * bhR / dist * 1.1;
                    sx2 = cx + Math.cos(mirrorAngle) * mirrorDist;
                    sy2 = cy + Math.sin(mirrorAngle) * mirrorDist;
                }
            }

            const twinkle = 0.5 + 0.5 * Math.sin(time * s.twinkleSpeed + s.twinkleOffset);
            const alpha = s.brightness * twinkle;
            const temp = s.z;
            const r = Math.floor(200 + 55 * temp);
            const g = Math.floor(200 + 55 * temp * 0.8);
            const b = Math.floor(220 + 35 * temp);

            ctx.beginPath();
            ctx.arc(sx, sy, s.size * zoom * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
            ctx.fill();

            // Draw duplicated lensed image
            if (duplicated) {
                const d2 = Math.sqrt((sx2 - cx) ** 2 + (sy2 - cy) ** 2);
                if (d2 > bhR * 1.05) {
                    ctx.beginPath();
                    ctx.arc(sx2, sy2, s.size * zoom * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha * 0.4})`;
                    ctx.fill();
                }
            }
        }
    }

    // --- Einstein Ring ---
    function drawEinsteinRing() {
        const bhR = schwarzschildR * zoom;
        const ringRadius = bhR * 1.6;
        const gradient = ctx.createRadialGradient(cx, cy, ringRadius - 6, cx, cy, ringRadius + 12);
        gradient.addColorStop(0, 'rgba(100, 180, 255, 0)');
        gradient.addColorStop(0.2, 'rgba(120, 200, 255, 0.02)');
        gradient.addColorStop(0.4, 'rgba(180, 230, 255, 0.07)');
        gradient.addColorStop(0.5, 'rgba(200, 240, 255, 0.10)');
        gradient.addColorStop(0.6, 'rgba(180, 230, 255, 0.07)');
        gradient.addColorStop(0.8, 'rgba(120, 200, 255, 0.02)');
        gradient.addColorStop(1, 'rgba(100, 180, 255, 0)');
        ctx.beginPath();
        ctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Bright Einstein ring arc
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(200, 230, 255, 0.05)';
        ctx.lineWidth = 2 * zoom;
        ctx.stroke();
        ctx.restore();
    }

    // --- Accretion Disk Particles ---
    function initDiskParticles() {
        diskParticles = [];
        for (let i = 0; i < CONFIG.diskParticleCount; i++) {
            const r = CONFIG.diskInner + Math.random() * (CONFIG.diskOuter - CONFIG.diskInner);
            const angle = Math.random() * Math.PI * 2;
            const yOff = (Math.random() - 0.5) * CONFIG.diskThickness * r;
            diskParticles.push({
                r: r,
                angle: angle,
                yOffset: yOff,
                speed: 1.0 / Math.pow(r, 1.5),
                brightness: Math.random() * 0.6 + 0.4,
                size: Math.random() * 2.5 + 0.5,
                hueShift: (Math.random() - 0.5) * 20
            });
        }
    }

    function initOrbitingParticles() {
        orbitingParticles = [];
        for (let i = 0; i < CONFIG.orbitingParticleCount; i++) {
            const r = CONFIG.diskInner * 0.8 + Math.random() * (CONFIG.diskOuter - CONFIG.diskInner) * 1.2;
            orbitingParticles.push({
                r: r,
                angle: Math.random() * Math.PI * 2,
                yOffset: (Math.random() - 0.5) * CONFIG.diskThickness * r * 0.5,
                speed: 1.0 / Math.pow(r, 1.5),
                brightness: Math.random() * 0.5 + 0.5,
                size: Math.random() * 3 + 1,
                trail: [],
                trailMax: Math.floor(Math.random() * 12 + 6)
            });
        }
    }

    function initInfallParticles() {
        infallParticles = [];
        for (let i = 0; i < CONFIG.infallParticleCount; i++) {
            spawnInfallParticle(i);
        }
    }

    function spawnInfallParticle(index) {
        const r = CONFIG.diskInner + Math.random() * (CONFIG.diskOuter - CONFIG.diskInner) * 0.3;
        infallParticles[index] = {
            r: r,
            angle: Math.random() * Math.PI * 2,
            yOffset: (Math.random() - 0.5) * CONFIG.diskThickness * r * 0.3,
            speed: 1.0 / Math.pow(r, 1.5),
            infallRate: 0.001 + Math.random() * 0.003,
            brightness: 0.8 + Math.random() * 0.2,
            size: Math.random() * 2 + 1,
            trail: [],
            trailMax: 20,
            alive: true
        };
    }

    // --- Jet Particles ---
    function initJetParticles() {
        jetParticlesUp = [];
        jetParticlesDown = [];
        for (let i = 0; i < CONFIG.jetParticleCount; i++) {
            jetParticlesUp.push(spawnJetParticle());
            jetParticlesDown.push(spawnJetParticle());
        }
    }

    function spawnJetParticle() {
        return {
            t: Math.random(),
            offset: (Math.random() - 0.5) * 0.15,
            speed: 0.003 + Math.random() * 0.005,
            size: Math.random() * 2.5 + 0.5,
            brightness: Math.random() * 0.6 + 0.4,
            wobble: Math.random() * Math.PI * 2
        };
    }

    // --- Hawking Radiation Pairs ---
    function initHawkingPairs() {
        hawkingPairs = [];
        for (let i = 0; i < CONFIG.hawkingPairCount; i++) {
            hawkingPairs.push(spawnHawkingPair());
        }
    }

    function spawnHawkingPair() {
        const angle = Math.random() * Math.PI * 2;
        return {
            angle: angle,
            t: Math.random(),
            escaping: { r: 1.0, speed: 0.005 + Math.random() * 0.008, size: 1.5, alive: true },
            infalling: { r: 1.0, speed: 0.003 + Math.random() * 0.005, size: 1.2, alive: true },
            maxLife: 60 + Math.random() * 120,
            life: 0
        };
    }

    // --- Spaghettification Object ---
    function initSpaghettiObj() {
        spaghettiObj = {
            r: CONFIG.diskOuter * 1.2,
            angle: Math.random() * Math.PI * 2,
            yOffset: 0,
            segments: 8,
            baseWidth: 6,
            baseHeight: 12,
            speed: 0.0005,
            infallRate: 0.002,
            active: false
        };
    }

    // --- 3D Projection with Lensing ---
    function project3D(r, angle, yOffset, applyLensing) {
        const bhR = schwarzschildR * zoom;
        const x3d = r * bhR * Math.cos(angle);
        const z3d = r * bhR * Math.sin(angle);
        const y3d = yOffset * bhR;

        const cosT = Math.cos(viewTiltY);
        const sinT = Math.sin(viewTiltY);
        const rotY = y3d * cosT - z3d * sinT;
        const rotZ = y3d * sinT + z3d * cosT;

        const cosP = Math.cos(viewTiltX);
        const sinP = Math.sin(viewTiltX);
        const rotX = x3d * cosP - rotZ * sinP;
        const rotZ2 = x3d * sinP + rotZ * cosP;

        let sx = cx + rotX;
        let sy = cy + rotY;

        if (applyLensing) {
            const dx = sx - cx;
            const dy = sy - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0 && dist < bhR * 5) {
                const lensAmount = CONFIG.lensStrength * bhR / (dist + bhR * 0.5);
                const bendAngle = Math.atan2(dy, dx);
                const vertBend = lensAmount * bhR * 0.3 / (dist + bhR);
                sy += Math.sign(rotY || 0.001) * vertBend * Math.abs(Math.sin(bendAngle));
                const pushFactor = 1 + lensAmount * 0.15;
                sx = cx + dx * pushFactor;
                sy = cy + (sy - cy) * pushFactor;
            }
        }

        return { x: sx, y: sy, z: rotZ2, behindBH: false };
    }

    // --- Doppler + Temperature Color ---
    function getDiskColor(angle, r, brightness) {
        const dopplerAngle = angle + viewTiltX;
        const doppler = Math.cos(dopplerAngle);

        // Temperature gradient: inner = white-hot, outer = red
        const tempNorm = 1.0 - Math.min(1, (r - CONFIG.diskInner) / (CONFIG.diskOuter - CONFIG.diskInner));
        const tempFactor = 0.3 + tempNorm * 0.7;

        // Doppler beaming: approaching side much brighter
        const dopplerBoost = 1.0 + doppler * 0.7;

        let red, green, blue;
        // Temperature-based coloring: white -> yellow -> orange -> red
        if (tempNorm > 0.8) {
            // Inner: white-hot
            red = 255; green = 240 + (tempNorm - 0.8) * 75; blue = 200 + (tempNorm - 0.8) * 275;
        } else if (tempNorm > 0.5) {
            // Mid-inner: yellow-white
            red = 255; green = 180 + (tempNorm - 0.5) * 200; blue = 100 + (tempNorm - 0.5) * 333;
        } else if (tempNorm > 0.2) {
            // Mid: orange
            red = 255; green = 120 + (tempNorm - 0.2) * 200; blue = 40 + (tempNorm - 0.2) * 200;
        } else {
            // Outer: deep red
            red = 200 + tempNorm * 275; green = 60 + tempNorm * 300; blue = 20 + tempNorm * 100;
        }

        // Apply Doppler shift
        if (doppler > 0) {
            blue = Math.min(255, blue + doppler * 60);
            green = Math.min(255, green + doppler * 20);
        } else {
            blue = Math.max(0, blue + doppler * 60);
            green = Math.max(0, green + doppler * 30);
            red = Math.min(255, red - doppler * 20);
        }

        red = Math.min(255, Math.max(0, Math.floor(red)));
        green = Math.min(255, Math.max(0, Math.floor(green)));
        blue = Math.min(255, Math.max(0, Math.floor(blue)));

        const alpha = Math.min(1, brightness * tempFactor * dopplerBoost * 0.8);
        return `rgba(${red},${green},${blue},${alpha})`;
    }

    // --- Draw Accretion Disk ---
    function drawAccretionDisk() {
        const bhR = schwarzschildR * zoom;
        const projected = [];

        for (let i = 0; i < diskParticles.length; i++) {
            const p = diskParticles[i];
            const pos = project3D(p.r, p.angle, p.yOffset, true);
            const dx = pos.x - cx;
            const dy = pos.y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < bhR * 0.95) continue;

            projected.push({
                x: pos.x, y: pos.y, z: pos.z,
                angle: p.angle, r: p.r,
                brightness: p.brightness,
                size: p.size, dist: dist
            });
        }

        projected.sort((a, b) => b.z - a.z);

        drawDiskGlow(bhR);

        for (let i = 0; i < projected.length; i++) {
            const p = projected[i];
            const color = getDiskColor(p.angle, p.r, p.brightness);
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * zoom * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
    }

    function drawDiskGlow(bhR) {
        const tiltCos = Math.cos(viewTiltY);
        const segments = 360;

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        for (let layer = 0; layer < 3; layer++) {
            const layerAlpha = [0.08, 0.04, 0.02][layer];
            const layerWidth = [25, 50, 80][layer];

            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const r = (CONFIG.diskInner + (CONFIG.diskOuter - CONFIG.diskInner) * 0.5) * bhR;
                const x = cx + r * Math.cos(angle) * Math.cos(viewTiltX);
                const y = cy + r * Math.sin(angle) * tiltCos;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = `rgba(255, 180, 100, ${layerAlpha})`;
            ctx.lineWidth = layerWidth * zoom;
            ctx.stroke();
        }

        ctx.restore();
    }

    // --- Lensed Disk ---
    function drawLensedDisk() {
        const bhR = schwarzschildR * zoom;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        const segments = 200;
        for (let pass = 0; pass < 2; pass++) {
            const ySign = pass === 0 ? -1 : 1;

            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const angle = t * Math.PI;
                const lensR = bhR * (1.15 + 0.3 * Math.sin(t * Math.PI));

                const x = cx + lensR * Math.cos(angle);
                const y = cy + ySign * (bhR * 1.05 + Math.sin(t * Math.PI) * bhR * 0.4);

                const dx = x - cx;
                const dy = y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < bhR * 1.0) continue;

                const doppler = Math.cos(angle + viewTiltX + time * CONFIG.rotationSpeed * 50);
                let r, g, b;
                if (doppler > 0) {
                    r = 200; g = 170; b = Math.floor(180 + doppler * 75);
                } else {
                    r = Math.floor(255 + doppler * 0); g = Math.floor(170 + doppler * 60); b = 120;
                }

                const alpha = 0.06 * (1 - Math.abs(t - 0.5) * 2) * Math.abs(Math.sin(viewTiltY));
                if (alpha < 0.005) continue;

                ctx.beginPath();
                ctx.arc(x, y, 2 * zoom, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.fill();
            }
        }

        // Lensing arcs
        for (let pass = 0; pass < 2; pass++) {
            const ySign = pass === 0 ? -1 : 1;
            const tiltFactor = Math.abs(Math.sin(viewTiltY));
            if (tiltFactor < 0.05) continue;

            ctx.beginPath();
            for (let i = 0; i <= 180; i++) {
                const angle = (i / 180) * Math.PI;
                const arcR = bhR * 1.12;
                const x = cx + arcR * Math.cos(angle);
                const bulge = Math.sin(angle) * bhR * 0.35 * tiltFactor;
                const y = cy + ySign * (bhR * 1.0 + bulge);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            const grad = ctx.createLinearGradient(cx - bhR * 1.5, cy, cx + bhR * 1.5, cy);
            const phaseShift = time * CONFIG.rotationSpeed * 50 + viewTiltX;
            const leftDoppler = Math.cos(Math.PI + phaseShift);
            const rightDoppler = Math.cos(phaseShift);

            grad.addColorStop(0, leftDoppler > 0 ?
                `rgba(180, 200, 255, ${0.15 * tiltFactor})` :
                `rgba(255, 160, 100, ${0.15 * tiltFactor})`);
            grad.addColorStop(0.5, `rgba(255, 220, 180, ${0.1 * tiltFactor})`);
            grad.addColorStop(1, rightDoppler > 0 ?
                `rgba(180, 200, 255, ${0.15 * tiltFactor})` :
                `rgba(255, 160, 100, ${0.15 * tiltFactor})`);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 6 * zoom * tiltFactor;
            ctx.stroke();
        }

        ctx.restore();
    }

    // --- Orbiting Particles ---
    function drawOrbitingParticles() {
        const bhR = schwarzschildR * zoom;

        for (let i = 0; i < orbitingParticles.length; i++) {
            const p = orbitingParticles[i];
            const pos = project3D(p.r, p.angle, p.yOffset, true);
            const dx = pos.x - cx;
            const dy = pos.y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < bhR * 0.95) continue;

            p.trail.push({ x: pos.x, y: pos.y });
            if (p.trail.length > p.trailMax) p.trail.shift();

            if (p.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(p.trail[0].x, p.trail[0].y);
                for (let j = 1; j < p.trail.length; j++) {
                    ctx.lineTo(p.trail[j].x, p.trail[j].y);
                }
                const color = getDiskColor(p.angle, p.r, p.brightness * 0.3);
                ctx.strokeStyle = color;
                ctx.lineWidth = p.size * zoom * 0.4;
                ctx.stroke();
            }

            const color = getDiskColor(p.angle, p.r, p.brightness);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, p.size * zoom * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
    }

    // --- Infall Particles ---
    function drawInfallParticles() {
        const bhR = schwarzschildR * zoom;

        for (let i = 0; i < infallParticles.length; i++) {
            const p = infallParticles[i];
            if (!p.alive) continue;

            const pos = project3D(p.r, p.angle, p.yOffset, true);
            const dx = pos.x - cx;
            const dy = pos.y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);

            p.trail.push({ x: pos.x, y: pos.y, brightness: p.brightness });
            if (p.trail.length > p.trailMax) p.trail.shift();

            if (dist < bhR * 0.6 || p.r < 0.8) {
                p.alive = false;
                spawnInfallParticle(i);
                continue;
            }

            if (p.trail.length > 1) {
                for (let j = 1; j < p.trail.length; j++) {
                    const alpha = (j / p.trail.length) * p.brightness * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(p.trail[j - 1].x, p.trail[j - 1].y);
                    ctx.lineTo(p.trail[j].x, p.trail[j].y);
                    ctx.strokeStyle = `rgba(255, 200, 100, ${alpha})`;
                    ctx.lineWidth = p.size * zoom * 0.5 * (j / p.trail.length);
                    ctx.stroke();
                }
            }

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, p.size * zoom * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 220, 150, ${p.brightness})`;
            ctx.fill();
        }
    }

    // --- Relativistic Jets ---
    function drawJets() {
        const bhR = schwarzschildR * zoom;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        const jetLength = bhR * 8;
        const jetBaseWidth = bhR * 0.15;

        for (let sign = -1; sign <= 1; sign += 2) {
            // Jet cone glow
            const jetGrad = ctx.createLinearGradient(cx, cy, cx, cy + sign * jetLength);
            jetGrad.addColorStop(0, 'rgba(80, 140, 255, 0.12)');
            jetGrad.addColorStop(0.15, 'rgba(100, 160, 255, 0.08)');
            jetGrad.addColorStop(0.4, 'rgba(60, 120, 255, 0.04)');
            jetGrad.addColorStop(0.7, 'rgba(40, 80, 200, 0.015)');
            jetGrad.addColorStop(1, 'rgba(30, 60, 180, 0)');

            ctx.beginPath();
            ctx.moveTo(cx - jetBaseWidth, cy);
            ctx.lineTo(cx - jetBaseWidth * 2.5, cy + sign * jetLength);
            ctx.lineTo(cx + jetBaseWidth * 2.5, cy + sign * jetLength);
            ctx.lineTo(cx + jetBaseWidth, cy);
            ctx.closePath();
            ctx.fillStyle = jetGrad;
            ctx.fill();

            // Core of jet (narrow, brighter)
            const coreGrad = ctx.createLinearGradient(cx, cy, cx, cy + sign * jetLength * 0.6);
            coreGrad.addColorStop(0, 'rgba(150, 200, 255, 0.15)');
            coreGrad.addColorStop(0.3, 'rgba(120, 170, 255, 0.08)');
            coreGrad.addColorStop(1, 'rgba(80, 130, 255, 0)');
            ctx.beginPath();
            ctx.moveTo(cx - jetBaseWidth * 0.3, cy);
            ctx.lineTo(cx - jetBaseWidth * 0.8, cy + sign * jetLength * 0.6);
            ctx.lineTo(cx + jetBaseWidth * 0.8, cy + sign * jetLength * 0.6);
            ctx.lineTo(cx + jetBaseWidth * 0.3, cy);
            ctx.closePath();
            ctx.fillStyle = coreGrad;
            ctx.fill();

            // Jet particles
            const particles = sign > 0 ? jetParticlesDown : jetParticlesUp;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const dist = p.t * jetLength;
                const spread = jetBaseWidth * (0.3 + p.t * 2.2);
                const wobbleX = Math.sin(p.wobble + time * 0.02 + p.t * 8) * spread * 0.3;
                const px = cx + p.offset * spread + wobbleX;
                const py = cy + sign * dist;

                const alpha = p.brightness * (1 - p.t) * 0.35;
                if (alpha < 0.01) continue;

                // Blue-white particles
                const r = Math.floor(150 + (1 - p.t) * 105);
                const g = Math.floor(180 + (1 - p.t) * 75);
                const b = 255;

                ctx.beginPath();
                ctx.arc(px, py, p.size * zoom * (0.5 + (1 - p.t) * 0.5), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.fill();
            }
        }

        ctx.restore();
    }

    // --- Hawking Radiation Particle Pairs ---
    function drawHawkingPairs() {
        const bhR = schwarzschildR * zoom;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        for (let i = 0; i < hawkingPairs.length; i++) {
            const pair = hawkingPairs[i];
            const a = pair.angle;
            const lifeRatio = pair.life / pair.maxLife;

            // Escaping particle (moves outward)
            const escR = bhR * (1.0 + pair.escaping.r * 0.5);
            const escX = cx + Math.cos(a) * escR;
            const escY = cy + Math.sin(a) * escR;
            const escAlpha = 0.3 * (1 - lifeRatio) * pair.escaping.size / 1.5;

            if (escAlpha > 0.01) {
                ctx.beginPath();
                ctx.arc(escX, escY, pair.escaping.size * zoom, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(100, 200, 255, ${escAlpha})`;
                ctx.fill();

                // Small glow
                ctx.beginPath();
                ctx.arc(escX, escY, pair.escaping.size * zoom * 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(80, 160, 255, ${escAlpha * 0.15})`;
                ctx.fill();
            }

            // Infalling particle (moves inward, red-shifted)
            const infR = bhR * (1.0 - pair.infalling.r * 0.15);
            if (infR > bhR * 0.3) {
                const infX = cx + Math.cos(a + Math.PI) * infR;
                const infY = cy + Math.sin(a + Math.PI) * infR;
                const infAlpha = 0.25 * (1 - lifeRatio) * (infR / bhR);

                if (infAlpha > 0.01) {
                    ctx.beginPath();
                    ctx.arc(infX, infY, pair.infalling.size * zoom, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 120, 80, ${infAlpha})`;
                    ctx.fill();
                }
            }

            // Connection line (virtual pair)
            if (lifeRatio < 0.3) {
                const lineAlpha = 0.05 * (1 - lifeRatio / 0.3);
                ctx.beginPath();
                ctx.moveTo(escX, escY);
                const midX = cx + Math.cos(a) * bhR;
                const midY = cy + Math.sin(a) * bhR;
                ctx.lineTo(midX, midY);
                ctx.strokeStyle = `rgba(150, 180, 220, ${lineAlpha})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        }

        ctx.restore();
    }

    // --- Black Hole & Event Horizon ---
    function drawBlackHole() {
        const bhR = schwarzschildR * zoom;

        // Photon sphere glow
        const photonGrad = ctx.createRadialGradient(cx, cy, bhR * 0.9, cx, cy, bhR * 2.0);
        photonGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
        photonGrad.addColorStop(0.3, 'rgba(40, 60, 80, 0.05)');
        photonGrad.addColorStop(0.6, 'rgba(60, 100, 140, 0.03)');
        photonGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.beginPath();
        ctx.arc(cx, cy, bhR * 2.0, 0, Math.PI * 2);
        ctx.fillStyle = photonGrad;
        ctx.fill();

        // Event horizon
        ctx.beginPath();
        ctx.arc(cx, cy, bhR, 0, Math.PI * 2);
        ctx.fillStyle = '#000000';
        ctx.fill();

        // Hawking radiation glow
        const hawkingFlicker = 0.7 + 0.3 * Math.sin(time * 0.01) * Math.sin(time * 0.017);
        const hawkingGrad = ctx.createRadialGradient(cx, cy, bhR * 0.97, cx, cy, bhR * 1.08);
        hawkingGrad.addColorStop(0, `rgba(80, 120, 200, ${CONFIG.hawkingGlow * hawkingFlicker * 0.3})`);
        hawkingGrad.addColorStop(0.5, `rgba(100, 150, 255, ${CONFIG.hawkingGlow * hawkingFlicker * 0.15})`);
        hawkingGrad.addColorStop(1, 'rgba(60, 100, 200, 0)');
        ctx.beginPath();
        ctx.arc(cx, cy, bhR * 1.08, 0, Math.PI * 2);
        ctx.fillStyle = hawkingGrad;
        ctx.fill();
    }

    // --- Photon Sphere (1.5 Rs) ---
    function drawPhotonSphere() {
        const bhR = schwarzschildR * zoom;
        const ringR = bhR * photonSphereR;

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        // Bright photon sphere ring
        const grad = ctx.createRadialGradient(cx, cy, ringR - 3 * zoom, cx, cy, ringR + 5 * zoom);
        grad.addColorStop(0, 'rgba(255, 200, 150, 0)');
        grad.addColorStop(0.3, 'rgba(255, 220, 180, 0.06)');
        grad.addColorStop(0.5, 'rgba(255, 230, 200, 0.10)');
        grad.addColorStop(0.7, 'rgba(255, 220, 180, 0.06)');
        grad.addColorStop(1, 'rgba(255, 200, 150, 0)');
        ctx.beginPath();
        ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Sharp ring stroke
        ctx.beginPath();
        ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 220, 170, 0.08)';
        ctx.lineWidth = 2 * zoom;
        ctx.stroke();

        // Label
        ctx.font = `${9 * zoom}px monospace`;
        ctx.fillStyle = 'rgba(255, 220, 170, 0.2)';
        ctx.fillText('photon sphere', cx + ringR + 6, cy - 3);

        ctx.restore();
    }

    // --- ISCO Ring (innermost stable circular orbit) ---
    function drawISCO() {
        const bhR = schwarzschildR * zoom;
        const iscoPixelR = bhR * iscoR;

        ctx.save();

        // Dashed ring at ISCO
        ctx.setLineDash([4 * zoom, 6 * zoom]);
        ctx.beginPath();
        ctx.arc(cx, cy, iscoPixelR, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 180, 80, 0.12)';
        ctx.lineWidth = 1.5 * zoom;
        ctx.stroke();
        ctx.setLineDash([]);

        // Label
        ctx.font = `${9 * zoom}px monospace`;
        ctx.fillStyle = 'rgba(255, 180, 80, 0.2)';
        ctx.fillText('ISCO', cx + iscoPixelR + 6, cy + 12);

        ctx.restore();
    }

    // --- Companion Star ---
    function drawCompanionStar() {
        if (!showCompanion) return;

        const bhR = schwarzschildR * zoom;
        const starOrbitR = companion.orbitR * bhR;
        const sx = cx + Math.cos(companion.angle) * starOrbitR;
        const sy = cy + Math.sin(companion.angle) * starOrbitR * 0.4; // perspective squash
        const starSize = companion.starR * bhR;

        // Star body
        const starGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, starSize);
        starGrad.addColorStop(0, 'rgba(255, 240, 200, 0.9)');
        starGrad.addColorStop(0.3, 'rgba(255, 200, 140, 0.7)');
        starGrad.addColorStop(0.6, 'rgba(255, 150, 80, 0.4)');
        starGrad.addColorStop(1, 'rgba(255, 100, 40, 0)');
        ctx.beginPath();
        ctx.arc(sx, sy, starSize, 0, Math.PI * 2);
        ctx.fillStyle = starGrad;
        ctx.fill();

        // Outer glow
        const glowGrad = ctx.createRadialGradient(sx, sy, starSize * 0.5, sx, sy, starSize * 3);
        glowGrad.addColorStop(0, 'rgba(255, 180, 100, 0.1)');
        glowGrad.addColorStop(1, 'rgba(255, 100, 40, 0)');
        ctx.beginPath();
        ctx.arc(sx, sy, starSize * 3, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();

        // Mass stream from companion to black hole
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < companion.streamParticles.length; i++) {
            const p = companion.streamParticles[i];
            const t = p.t;
            // Bezier curve from star to BH with a bow
            const cpx = (sx + cx) / 2 + (sy - cy) * 0.5;
            const cpy = (sy + cy) / 2 - (sx - cx) * 0.2;
            const px = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * cpx + t * t * cx;
            const py = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * cpy + t * t * cy;
            const offsetAngle = Math.atan2(py - cy, px - cx) + Math.PI / 2;
            const finalX = px + Math.cos(offsetAngle) * p.offset * bhR;
            const finalY = py + Math.sin(offsetAngle) * p.offset * bhR;

            const alpha = p.brightness * 0.3 * Math.sin(t * Math.PI);
            if (alpha < 0.01) continue;

            // Color transitions from star-yellow to disk-orange
            const r = 255;
            const g = Math.floor(200 - t * 80);
            const b = Math.floor(140 - t * 80);

            ctx.beginPath();
            ctx.arc(finalX, finalY, p.size * zoom, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
            ctx.fill();
        }
        ctx.restore();

        // Roche lobe distortion hint - teardrop shape on the star toward BH
        const tearAngle = Math.atan2(cy - sy, cx - sx);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.ellipse(
            sx + Math.cos(tearAngle) * starSize * 0.7,
            sy + Math.sin(tearAngle) * starSize * 0.7,
            starSize * 0.6, starSize * 0.3,
            tearAngle, 0, Math.PI * 2
        );
        ctx.fillStyle = 'rgba(255, 200, 140, 0.15)';
        ctx.fill();
        ctx.restore();
    }

    // --- Spaghettification Demo ---
    function drawSpaghettification() {
        if (!showSpaghetti || !spaghettiObj) return;

        const bhR = schwarzschildR * zoom;
        const pos = project3D(spaghettiObj.r, spaghettiObj.angle, spaghettiObj.yOffset, false);

        // Tidal stretching factor increases as object approaches
        const rNorm = Math.max(0.3, spaghettiObj.r / CONFIG.diskOuter);
        const stretchFactor = 1.0 / (rNorm * rNorm);
        const compressionFactor = Math.sqrt(rNorm);

        const radialAngle = Math.atan2(pos.y - cy, pos.x - cx);

        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(radialAngle);

        const segH = spaghettiObj.baseHeight * zoom * stretchFactor / spaghettiObj.segments;
        const segW = spaghettiObj.baseWidth * zoom * compressionFactor;

        // Draw stretched object segments
        for (let s = 0; s < spaghettiObj.segments; s++) {
            const t = s / spaghettiObj.segments;
            const y = -spaghettiObj.baseHeight * zoom * stretchFactor / 2 + s * segH;
            const width = segW * (1 - 0.3 * Math.sin(t * Math.PI));

            // Color shifts red and brightens closer to BH
            const heat = Math.min(1, stretchFactor * 0.3);
            const r = Math.floor(180 + heat * 75);
            const g = Math.floor(160 - heat * 60);
            const b = Math.floor(200 - heat * 100);
            const alpha = 0.6 + heat * 0.3;

            ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
            ctx.fillRect(-width / 2, y, width, segH + 1);
        }

        // Head and feet markers
        const headY = -spaghettiObj.baseHeight * zoom * stretchFactor / 2;
        const feetY = spaghettiObj.baseHeight * zoom * stretchFactor / 2;

        ctx.beginPath();
        ctx.arc(0, headY, segW * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(200, 180, 220, 0.7)';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(0, feetY, segW * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(200, 180, 220, 0.5)';
        ctx.fill();

        ctx.restore();

        // Label
        if (stretchFactor > 2) {
            ctx.save();
            ctx.font = `${9 * zoom}px monospace`;
            ctx.fillStyle = 'rgba(200, 180, 220, 0.4)';
            ctx.fillText(`stretch: ${stretchFactor.toFixed(1)}x`, pos.x + 20, pos.y);
            ctx.restore();
        }
    }

    // --- Frame Dragging Indicator ---
    function drawFrameDragging() {
        if (bhSpin < 0.05) return;

        const bhR = schwarzschildR * zoom;
        const ergoR = bhR * (2.0 - bhSpin * 0.5); // ergosphere

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        // Ergosphere boundary
        ctx.setLineDash([3 * zoom, 8 * zoom]);
        ctx.beginPath();
        ctx.arc(cx, cy, ergoR, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(150, 100, 255, ${0.06 + bhSpin * 0.06})`;
        ctx.lineWidth = 1 * zoom;
        ctx.stroke();
        ctx.setLineDash([]);

        // Frame-dragging swirl indicators
        const swirlCount = 6;
        for (let i = 0; i < swirlCount; i++) {
            const baseAngle = (i / swirlCount) * Math.PI * 2 + time * 0.001 * bhSpin;
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const r = bhR * (1.1 + t * 1.0);
                const dragAngle = baseAngle + t * bhSpin * 1.5;
                const x = cx + Math.cos(dragAngle) * r;
                const y = cy + Math.sin(dragAngle) * r;
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            const alpha = 0.04 + bhSpin * 0.04;
            ctx.strokeStyle = `rgba(130, 100, 255, ${alpha})`;
            ctx.lineWidth = 1.5 * zoom;
            ctx.stroke();
        }

        // Label ergosphere
        ctx.font = `${9 * zoom}px monospace`;
        ctx.fillStyle = `rgba(150, 100, 255, ${0.15 + bhSpin * 0.1})`;
        ctx.fillText('ergosphere', cx + ergoR + 6, cy + 24);

        ctx.restore();
    }

    // --- Nebula Background ---
    function drawNebulaBackground() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        const nebulaGrad = ctx.createRadialGradient(
            cx * 0.7, cy * 0.6, 0,
            cx * 0.7, cy * 0.6, W * 0.5
        );
        nebulaGrad.addColorStop(0, 'rgba(30, 10, 40, 0.03)');
        nebulaGrad.addColorStop(0.5, 'rgba(20, 5, 30, 0.02)');
        nebulaGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = nebulaGrad;
        ctx.fillRect(0, 0, W, H);

        const nebulaGrad2 = ctx.createRadialGradient(
            cx * 1.4, cy * 1.3, 0,
            cx * 1.4, cy * 1.3, W * 0.4
        );
        nebulaGrad2.addColorStop(0, 'rgba(10, 15, 40, 0.03)');
        nebulaGrad2.addColorStop(0.5, 'rgba(5, 10, 30, 0.02)');
        nebulaGrad2.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = nebulaGrad2;
        ctx.fillRect(0, 0, W, H);

        ctx.restore();
    }

    function drawBloomEffect() {
        const bhR = schwarzschildR * zoom;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        const bloomGrad = ctx.createRadialGradient(cx, cy, bhR * 1.5, cx, cy, bhR * 4);
        bloomGrad.addColorStop(0, 'rgba(255, 180, 100, 0.02)');
        bloomGrad.addColorStop(0.5, 'rgba(255, 150, 80, 0.01)');
        bloomGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = bloomGrad;
        ctx.fillRect(0, 0, W, H);

        ctx.restore();
    }

    // --- Film Grain Animation ---
    let grainPhase = 0;
    function animateGrain() {
        grainPhase += 0.5;
        const grain = document.getElementById('filmGrain');
        if (grain) {
            grain.style.transform = `translate(${Math.sin(grainPhase) * 2}px, ${Math.cos(grainPhase * 0.7) * 2}px)`;
        }
    }

    // --- Time Dilation Clock ---
    function updateTimeDilationClock() {
        const bhR = schwarzschildR * zoom;
        // Distance of mouse from center (proxy for observer distance from BH)
        const mdx = rawMouseX * W - cx;
        const mdy = rawMouseY * H - cy;
        const mouseDist = Math.sqrt(mdx * mdx + mdy * mdy);

        // Time dilation factor: sqrt(1 - Rs/r)
        // Map mouse distance to a physical distance
        const physicalR = Math.max(bhR * 1.01, mouseDist);
        const ratio = bhR / physicalR;
        const dilationFactor = Math.sqrt(Math.max(0.01, 1 - ratio));

        // Update clock hand rotation
        const clockHand = document.getElementById('clockHand');
        const clockAngle = (time * dilationFactor * 0.5) % 360;
        if (clockHand) {
            clockHand.style.transform = `rotate(${clockAngle}deg)`;
        }

        // Update label
        const dilationLabel = document.getElementById('dilationFactor');
        if (dilationLabel) {
            dilationLabel.textContent = dilationFactor.toFixed(3) + 'x';
            // Color: green when normal, red when slow
            const hue = dilationFactor * 120; // 120=green, 0=red
            dilationLabel.style.color = `hsla(${hue}, 70%, 60%, 0.8)`;
        }
    }

    // --- Info Panel ---
    function updateInfoPanel() {
        const info = document.getElementById('info');
        if (!info) return;

        const G = 6.674e-11;
        const c = 3e8;
        const Msun = 1.989e30;
        const M = bhMass * Msun;

        // Schwarzschild radius in km
        const Rs_m = (2 * G * M) / (c * c);
        const Rs_km = Rs_m / 1000;

        // Hawking temperature: T = hbar*c^3 / (8*pi*G*M*k_B)
        const hbar = 1.0546e-34;
        const kB = 1.381e-23;
        const T_hawking = (hbar * c * c * c) / (8 * Math.PI * G * M * kB);

        // Luminosity (Eddington)
        const sigmaT = 6.652e-29;
        const mp = 1.673e-27;
        const L_edd = (4 * Math.PI * G * M * mp * c) / sigmaT;
        const L_sun = 3.828e26;
        const L_ratio = L_edd / L_sun;

        const iscoKm = Rs_km * iscoR / 2;

        info.innerHTML = `
            <span class="label">Mass:</span> <span class="value">${bhMass} M&#x2609;</span><br>
            <span class="label">Spin (a):</span> <span class="value">${bhSpin.toFixed(2)}</span><br>
            <span class="label">R<sub>s</sub>:</span> <span class="value">${Rs_km < 1 ? Rs_m.toFixed(0) + ' m' : Rs_km.toFixed(1) + ' km'}</span><br>
            <span class="label">ISCO:</span> <span class="value">${iscoKm.toFixed(1)} km</span><br>
            <span class="label">T<sub>Hawking</sub>:</span> <span class="value">${T_hawking.toExponential(1)} K</span><br>
            <span class="label">L<sub>Edd</sub>:</span> <span class="value">${L_ratio.toExponential(1)} L&#x2609;</span><br>
            <span class="label" style="font-size:0.6rem;opacity:0.5;">Mouse=tilt &middot; Scroll=zoom</span>
        `;
    }

    // --- Update Physics ---
    function update() {
        if (paused) return;
        time++;

        const targetTiltX = (mouseX - 0.5) * 0.8;
        const targetTiltY = (mouseY - 0.5) * 0.8 + 0.3;
        viewTiltX += (targetTiltX - viewTiltX) * 0.03;
        viewTiltY += (targetTiltY - viewTiltY) * 0.03;

        // Frame-dragging effect on disk rotation speed
        const frameDragBoost = 1 + bhSpin * 0.3;

        for (let i = 0; i < diskParticles.length; i++) {
            const p = diskParticles[i];
            p.angle += CONFIG.rotationSpeed * p.speed * 60 * frameDragBoost;
        }

        for (let i = 0; i < orbitingParticles.length; i++) {
            const p = orbitingParticles[i];
            p.angle += CONFIG.rotationSpeed * p.speed * 60 * frameDragBoost;
        }

        for (let i = 0; i < infallParticles.length; i++) {
            const p = infallParticles[i];
            if (!p.alive) continue;
            p.angle += CONFIG.rotationSpeed * p.speed * 80 * frameDragBoost;
            p.r -= p.infallRate;
            p.speed = 1.0 / Math.pow(Math.max(p.r, 0.5), 1.5);
            p.brightness = Math.min(1, p.brightness + 0.002);
        }

        // Jet particles
        for (let arr of [jetParticlesUp, jetParticlesDown]) {
            for (let i = 0; i < arr.length; i++) {
                arr[i].t += arr[i].speed;
                if (arr[i].t > 1) {
                    arr[i] = spawnJetParticle();
                    arr[i].t = 0;
                }
            }
        }

        // Hawking pairs
        for (let i = 0; i < hawkingPairs.length; i++) {
            const pair = hawkingPairs[i];
            pair.life++;
            pair.escaping.r += pair.escaping.speed;
            pair.infalling.r += pair.infalling.speed;
            if (pair.life > pair.maxLife) {
                hawkingPairs[i] = spawnHawkingPair();
            }
        }

        // Companion star orbit
        if (showCompanion) {
            companion.angle += 0.0005;
            for (let i = 0; i < companion.streamParticles.length; i++) {
                companion.streamParticles[i].t += 0.004 + companion.streamParticles[i].t * 0.002;
                if (companion.streamParticles[i].t > 1) {
                    companion.streamParticles[i].t = 0;
                }
            }
        }

        // Spaghettification
        if (showSpaghetti && spaghettiObj) {
            if (!spaghettiObj.active && spaghettiObj.r <= 0.5) {
                // Reset
                spaghettiObj.r = CONFIG.diskOuter * 1.2;
                spaghettiObj.angle = Math.random() * Math.PI * 2;
            }
            spaghettiObj.active = true;
            spaghettiObj.angle += spaghettiObj.speed * frameDragBoost;
            spaghettiObj.r -= spaghettiObj.infallRate;
            spaghettiObj.speed = 0.0005 + (CONFIG.diskOuter / Math.max(0.5, spaghettiObj.r)) * 0.001;
            if (spaghettiObj.r < 0.5) {
                spaghettiObj.r = CONFIG.diskOuter * 1.2;
                spaghettiObj.angle = Math.random() * Math.PI * 2;
            }
        }

        animateGrain();
    }

    // --- Main Render ---
    function render() {
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, W, H);

        drawNebulaBackground();
        drawStars();
        drawJets();
        drawEinsteinRing();
        drawCompanionStar();

        drawAccretionDisk();
        drawLensedDisk();

        drawFrameDragging();
        drawISCO();

        drawBlackHole();
        drawPhotonSphere();
        drawHawkingPairs();

        drawOrbitingParticles();
        drawInfallParticles();

        drawSpaghettification();

        drawBloomEffect();

        updateTimeDilationClock();
        if (time % 30 === 0) updateInfoPanel();
    }

    // --- Animation Loop ---
    let animId;
    function loop() {
        update();
        render();
        animId = requestAnimationFrame(loop);
    }

    // --- Init ---
    function init() {
        resize();
        updateDerived();
        initStars();
        initDiskParticles();
        initOrbitingParticles();
        initInfallParticles();
        initJetParticles();
        initHawkingPairs();
        initCompanionStream();
        initSpaghettiObj();
        time = 0;
        viewTiltX = 0;
        viewTiltY = 0.3;
        zoom = 1.0;
        updateInfoPanel();
    }

    // --- Reset ---
    window.reset = function() {
        cancelAnimationFrame(animId);
        paused = false;
        init();
        loop();
    };

    // --- Events ---
    window.addEventListener('resize', resize);

    canvas.addEventListener('mousemove', function(e) {
        mouseX = e.clientX / W;
        mouseY = e.clientY / H;
        rawMouseX = e.clientX / W;
        rawMouseY = e.clientY / H;
    });

    canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        zoom *= e.deltaY > 0 ? 0.95 : 1.05;
        zoom = Math.max(0.3, Math.min(3.0, zoom));
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            mouseX = e.touches[0].clientX / W;
            mouseY = e.touches[0].clientY / H;
            rawMouseX = mouseX;
            rawMouseY = mouseY;
        }
    }, { passive: false });

    document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            paused = !paused;
            if (!paused) loop();
        }
    });

    // --- Slider Events ---
    const massSlider = document.getElementById('massSlider');
    const spinSlider = document.getElementById('spinSlider');
    const companionToggle = document.getElementById('companionToggle');
    const spaghettiToggle = document.getElementById('spaghettiToggle');

    massSlider.addEventListener('input', function() {
        bhMass = parseFloat(this.value);
        document.getElementById('massVal').textContent = bhMass;
        updateDerived();
        updateInfoPanel();
    });

    spinSlider.addEventListener('input', function() {
        bhSpin = parseFloat(this.value) / 100;
        document.getElementById('spinVal').textContent = bhSpin.toFixed(2);
        updateDerived();
        updateInfoPanel();
    });

    companionToggle.addEventListener('change', function() {
        showCompanion = this.checked;
        if (showCompanion) initCompanionStream();
    });

    spaghettiToggle.addEventListener('change', function() {
        showSpaghetti = this.checked;
        if (showSpaghetti) {
            initSpaghettiObj();
            spaghettiObj.active = true;
        }
    });

    // Prevent slider interaction from affecting canvas
    document.getElementById('controls').addEventListener('wheel', function(e) {
        e.stopPropagation();
    });

    // Start
    init();
    loop();
})();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
