<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Protein Folding - Hydrophobic Collapse & Secondary Structure</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #050510; font-family: 'Courier New', monospace; }
  canvas#main { display: block; position: absolute; top: 0; left: 0; }

  .vignette {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 10;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(2,2,12,0.7) 100%);
  }
  .scanlines {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 11;
    background: repeating-linear-gradient(
      0deg, transparent, transparent 2px,
      rgba(0,0,0,0.06) 2px, rgba(0,0,0,0.06) 4px
    );
  }
  .film-grain {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 12; opacity: 0.04;
    mix-blend-mode: overlay;
  }

  .back-link {
    position: fixed; top: 1rem; left: 1rem;
    color: rgba(100,200,255,0.6); text-decoration: none;
    font-family: monospace; font-size: 0.85rem;
    z-index: 20; transition: color 0.3s;
  }
  .back-link:hover { color: rgba(100,200,255,1); }

  .info-panel {
    position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%);
    color: rgba(180,200,220,0.7); font-family: 'Courier New', monospace;
    font-size: 0.8rem; z-index: 20; text-align: center;
    pointer-events: none; line-height: 1.6;
  }
  .info-panel .title {
    font-size: 1.1rem; color: rgba(200,220,240,0.85);
    letter-spacing: 0.15em; margin-bottom: 0.3rem;
  }

  .legend {
    position: fixed; top: 1rem; right: 1rem; z-index: 20;
    font-family: 'Courier New', monospace; font-size: 0.72rem;
    color: rgba(180,200,220,0.55); line-height: 1.7;
  }
  .legend-item { display: flex; align-items: center; gap: 0.4rem; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

  .stage-label {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-family: 'Courier New', monospace; font-size: 1.4rem;
    color: rgba(200,220,255,0); z-index: 15; pointer-events: none;
    letter-spacing: 0.2em; text-transform: uppercase;
    transition: color 1.5s ease;
    text-shadow: 0 0 30px rgba(100,150,255,0.3);
  }
  .stage-label.visible { color: rgba(200,220,255,0.6); }
  .stage-label.fade { color: rgba(200,220,255,0); }

  /* Controls panel */
  .controls-panel {
    position: fixed; top: 1rem; left: 50%; transform: translateX(-50%);
    z-index: 25; display: flex; gap: 0.5rem; align-items: center;
    pointer-events: auto;
  }
  .ctrl-btn {
    background: rgba(30,35,60,0.7); border: 1px solid rgba(100,150,255,0.25);
    color: rgba(180,200,230,0.8); padding: 0.3rem 0.65rem; font-size: 0.68rem;
    font-family: 'Courier New', monospace; cursor: pointer; border-radius: 3px;
    transition: all 0.25s; backdrop-filter: blur(10px);
  }
  .ctrl-btn:hover { background: rgba(50,60,100,0.8); border-color: rgba(100,150,255,0.5); }
  .ctrl-btn.active { background: rgba(60,80,160,0.6); border-color: rgba(100,150,255,0.6); }

  .ctrl-select {
    background: rgba(30,35,60,0.7); border: 1px solid rgba(100,150,255,0.25);
    color: rgba(180,200,230,0.8); padding: 0.3rem 0.4rem; font-size: 0.68rem;
    font-family: 'Courier New', monospace; cursor: pointer; border-radius: 3px;
    backdrop-filter: blur(10px);
  }
  .ctrl-select option { background: #1a1e3a; color: #b0c4e0; }

  .ctrl-slider {
    -webkit-appearance: none; width: 80px; height: 4px;
    background: rgba(100,150,255,0.2); border-radius: 2px; outline: none;
  }
  .ctrl-slider::-webkit-slider-thumb {
    -webkit-appearance: none; width: 12px; height: 12px;
    background: rgba(100,160,255,0.7); border-radius: 50%; cursor: pointer;
  }
  .ctrl-label {
    color: rgba(160,180,210,0.6); font-size: 0.6rem; white-space: nowrap;
  }

  /* Sequence bar */
  .sequence-bar {
    position: fixed; bottom: 4.5rem; left: 50%; transform: translateX(-50%);
    z-index: 20; pointer-events: none; display: flex; gap: 1px;
    max-width: 90vw; overflow: hidden;
  }
  .seq-residue {
    width: 6px; height: 18px; border-radius: 1px; opacity: 0.5;
    transition: opacity 0.3s, transform 0.3s;
  }
  .seq-residue.active { opacity: 1; transform: scaleY(1.4); }

  /* Side panels */
  .energy-panel {
    position: fixed; right: 1rem; bottom: 6rem; z-index: 20;
    pointer-events: none;
  }
  .energy-panel canvas { border: 1px solid rgba(100,150,255,0.15); border-radius: 3px; }
  .panel-label {
    color: rgba(160,180,210,0.5); font-size: 0.58rem; text-align: center;
    margin-bottom: 2px; letter-spacing: 0.1em;
  }

  .rama-panel {
    position: fixed; left: 1rem; bottom: 6rem; z-index: 20;
    pointer-events: none;
  }
  .rama-panel canvas { border: 1px solid rgba(100,150,255,0.15); border-radius: 3px; }
</style>
</head>
<body>

<div class="vignette"></div>
<div class="scanlines"></div>
<div class="film-grain" id="filmGrain"></div>
<a href="index.html" class="back-link">&larr; Back to Gallery</a>

<div class="legend" id="legendBox">
  <div class="legend-item"><span class="legend-dot" style="background:#ff8844"></span> Hydrophobic</div>
  <div class="legend-item"><span class="legend-dot" style="background:#4499ff"></span> Hydrophilic</div>
  <div class="legend-item"><span class="legend-dot" style="background:#ff4488"></span> Charged (&minus;)</div>
  <div class="legend-item"><span class="legend-dot" style="background:#44ddaa"></span> Charged (+)</div>
  <div class="legend-item"><span class="legend-dot" style="background:#cccc55"></span> Cysteine</div>
  <div class="legend-item"><span class="legend-dot" style="background:rgba(160,120,220,0.7)"></span> Alpha Helix</div>
  <div class="legend-item"><span class="legend-dot" style="background:rgba(220,200,100,0.7)"></span> Beta Sheet</div>
  <div class="legend-item" style="margin-top:2px"><span class="legend-dot" style="background:rgba(80,180,255,0.4);border:1px dashed rgba(80,180,255,0.6)"></span> H-Bond</div>
  <div class="legend-item"><span class="legend-dot" style="background:#ddcc33;border:1px solid #aa9900"></span> S-S Bridge</div>
</div>

<div class="controls-panel" id="controls">
  <select class="ctrl-select" id="proteinSelect" title="Protein preset">
    <option value="random">Random</option>
    <option value="insulin">Insulin</option>
    <option value="hemoglobin">Hemoglobin &alpha;</option>
    <option value="gfp">GFP</option>
  </select>
  <select class="ctrl-select" id="renderMode" title="Render mode">
    <option value="ball-stick">Ball & Stick</option>
    <option value="spacefill">Space Filling</option>
    <option value="ribbon">Ribbon</option>
    <option value="backbone">Backbone</option>
  </select>
  <span class="ctrl-label">Temp</span>
  <input type="range" class="ctrl-slider" id="tempSlider" min="0" max="100" value="50" title="Temperature">
  <button class="ctrl-btn" id="btnChaperone" title="Toggle chaperone">Chaperone</button>
  <button class="ctrl-btn" id="btnWater" title="Toggle water">Water</button>
</div>

<div class="stage-label" id="stageLabel"></div>

<div class="sequence-bar" id="seqBar"></div>

<div class="energy-panel">
  <div class="panel-label">ENERGY LANDSCAPE</div>
  <canvas id="energyCanvas" width="140" height="100"></canvas>
</div>

<div class="rama-panel">
  <div class="panel-label">RAMACHANDRAN</div>
  <canvas id="ramaCanvas" width="120" height="120"></canvas>
</div>

<div class="info-panel">
  <div class="title">PROTEIN FOLDING</div>
  <div id="statusLine">Initializing sequence...</div>
</div>

<canvas id="main"></canvas>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('main');
  const ctx = canvas.getContext('2d');
  const stageLabel = document.getElementById('stageLabel');
  const statusLine = document.getElementById('statusLine');
  const seqBar = document.getElementById('seqBar');
  const energyCanvas = document.getElementById('energyCanvas');
  const ectx = energyCanvas.getContext('2d');
  const ramaCanvas = document.getElementById('ramaCanvas');
  const rctx = ramaCanvas.getContext('2d');
  const filmGrain = document.getElementById('filmGrain');

  // Controls
  const proteinSelect = document.getElementById('proteinSelect');
  const renderModeSelect = document.getElementById('renderMode');
  const tempSlider = document.getElementById('tempSlider');
  const btnChaperone = document.getElementById('btnChaperone');
  const btnWater = document.getElementById('btnWater');

  // Amino acid types
  const AA_HYDROPHOBIC = 0;
  const AA_HYDROPHILIC = 1;
  const AA_NEG_CHARGED = 2;
  const AA_POS_CHARGED = 3;
  const AA_CYSTEINE    = 4;

  const AA_COLORS = {
    [AA_HYDROPHOBIC]: [255, 136, 68],
    [AA_HYDROPHILIC]: [68, 153, 255],
    [AA_NEG_CHARGED]: [255, 68, 136],
    [AA_POS_CHARGED]: [68, 221, 170],
    [AA_CYSTEINE]:    [204, 204, 85],
  };

  const AA_LETTERS = { [AA_HYDROPHOBIC]: 'A', [AA_HYDROPHILIC]: 'S', [AA_NEG_CHARGED]: 'D', [AA_POS_CHARGED]: 'K', [AA_CYSTEINE]: 'C' };

  // Config
  let NUM_RESIDUES = 60;
  const BOND_REST = 3.8;
  const BOND_K = 0.6;
  const ANGLE_K = 0.08;
  const HYDROPHOBIC_ATTRACT = 0.012;
  const HYDROPHOBIC_RANGE = 12.0;
  const CHARGE_REPEL = 0.02;
  const CHARGE_ATTRACT = 0.015;
  const EXCLUDED_VOLUME = 3.2;
  const EXCLUSION_K = 0.5;
  const BASE_DAMPING = 0.96;
  const DT = 0.4;
  const BEAD_RADIUS = 1.6;

  // Stages
  const STAGE_EXTEND   = 0;
  const STAGE_COLLAPSE = 1;
  const STAGE_HELIX    = 2;
  const STAGE_SETTLE   = 3;
  const STAGE_MISFOLD  = 4;

  let W, H;
  let residues = [];
  let stage = STAGE_EXTEND;
  let frame = 0;
  let foldingProgress = 0;
  let renderMode = 'ball-stick';
  let temperature = 0.5;
  let showChaperone = false;
  let showWater = true;
  let waterMolecules = [];
  let disulfideBonds = [];
  let hBonds = [];
  let chaperonePhase = 0;
  let misfoldTimer = 0;
  let misfoldActive = false;
  let misfoldShake = 0;
  let energyHistory = [];
  let currentProtein = 'random';

  // Camera
  let camRotX = 0.3;
  let camRotY = 0;
  let autoRotate = true;
  let dragging = false;
  let lastMX = 0, lastMY = 0;
  let camDist = 120;

  // Stars
  let stars = [];

  // Film grain canvas
  let grainCanvas = document.createElement('canvas');
  let grainCtx = grainCanvas.getContext('2d');

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    grainCanvas.width = W;
    grainCanvas.height = H;
  }
  window.addEventListener('resize', resize);
  resize();

  function generateStars() {
    stars = [];
    for (let i = 0; i < 200; i++) {
      stars.push({
        x: Math.random() * 2 - 1, y: Math.random() * 2 - 1,
        z: Math.random() * 0.5 + 0.5, brightness: Math.random() * 0.3 + 0.05
      });
    }
  }
  generateStars();

  // --- Protein presets ---
  // Simplified amino acid sequences inspired by real proteins
  const PRESETS = {
    random: null,
    insulin: {
      name: 'Insulin B-Chain',
      // F-V-N-Q-H-L-C-G-S-H-L-V-E-A-L-Y-L-V-C-G-E-R-G-F-F-Y-T-P-K-T (30 residues)
      sequence: [0,0,1,1,3,0,4,1,1,3,0,0,2,0,0,1,0,0,4,1,2,3,1,0,0,1,1,1,3,1],
      length: 30
    },
    hemoglobin: {
      name: 'Hemoglobin \u03B1 (fragment)',
      // V-L-S-P-A-D-K-T-N-V-K-A-A-W-G-K-V-G-A-H-A-G-E-Y-G-A-E-A-L-E-R-M-F-L-S-F-P-T-T-K (40)
      sequence: [0,0,1,1,0,2,3,1,1,0,3,0,0,0,1,3,0,1,0,3,0,1,2,1,1,0,2,0,0,2,3,0,0,0,1,0,1,1,1,3],
      length: 40
    },
    gfp: {
      name: 'GFP (fragment)',
      // S-K-G-E-E-L-F-T-G-V-V-P-I-L-V-E-L-D-G-D-V-N-G-H-K-F-S-V-S-G-E-G-E-G-D-A-T-Y-G-K-L-T-L-K-F-I-C-T-T-G (50)
      sequence: [1,3,1,2,2,0,0,1,1,0,0,1,0,0,0,2,0,2,1,2,0,1,1,3,3,0,1,0,1,1,2,1,2,1,2,0,1,1,1,3,0,1,1,3,0,0,4,1,1,1],
      length: 50
    }
  };

  // --- Generate sequence ---
  function generateSequence() {
    const preset = PRESETS[currentProtein];
    if (preset) {
      NUM_RESIDUES = preset.length;
      return preset.sequence.slice();
    }
    NUM_RESIDUES = 60;
    const seq = [];
    for (let i = 0; i < NUM_RESIDUES; i++) {
      const r = Math.random();
      if (r < 0.35) seq.push(AA_HYDROPHOBIC);
      else if (r < 0.65) seq.push(AA_HYDROPHILIC);
      else if (r < 0.80) seq.push(AA_NEG_CHARGED);
      else if (r < 0.95) seq.push(AA_POS_CHARGED);
      else seq.push(AA_CYSTEINE);
    }
    // Insert helix-prone region
    const helixStart = 8 + Math.floor(Math.random() * 5);
    const helixLen = 10 + Math.floor(Math.random() * 4);
    for (let i = helixStart; i < helixStart + helixLen && i < NUM_RESIDUES; i++) {
      seq[i] = (i - helixStart) % 3 === 0 ? AA_HYDROPHOBIC : AA_HYDROPHILIC;
    }
    // Insert sheet-prone region
    const sheetStart = 30 + Math.floor(Math.random() * 5);
    const sheetLen = 8 + Math.floor(Math.random() * 3);
    for (let i = sheetStart; i < sheetStart + sheetLen && i < NUM_RESIDUES; i++) {
      seq[i] = i % 2 === 0 ? AA_HYDROPHOBIC : AA_HYDROPHILIC;
    }
    // Ensure some cysteines for disulfide bridges
    const cysPositions = [];
    for (let i = 0; i < seq.length; i++) if (seq[i] === AA_CYSTEINE) cysPositions.push(i);
    while (cysPositions.length < 4) {
      const pos = 5 + Math.floor(Math.random() * (NUM_RESIDUES - 10));
      if (seq[pos] !== AA_CYSTEINE) { seq[pos] = AA_CYSTEINE; cysPositions.push(pos); }
    }
    return seq;
  }

  // Assign secondary structure
  function assignSS(sequence) {
    const ss = [];
    for (let i = 0; i < sequence.length; i++) ss.push('C');
    for (let i = 2; i < sequence.length - 2; i++) {
      if (sequence[i] !== AA_CYSTEINE && sequence[i-1] !== AA_CYSTEINE && sequence[i+1] !== AA_CYSTEINE) {
        const localH = [sequence[i-2], sequence[i-1], sequence[i], sequence[i+1], sequence[i+2]]
          .filter(a => a === AA_HYDROPHOBIC).length;
        if (localH >= 1 && localH <= 2) ss[i] = 'H';
      }
    }
    for (let i = 1; i < sequence.length - 1; i++) {
      if (sequence[i] === AA_HYDROPHOBIC && sequence[i-1] !== AA_HYDROPHOBIC && sequence[i+1] !== AA_HYDROPHOBIC) {
        if (ss[i] !== 'H') ss[i] = 'E';
      }
    }
    return ss;
  }

  // Detect secondary structure regions for ribbon rendering
  function detectSSRegions() {
    const regions = [];
    let cur = residues[0] ? residues[0].ss : 'C';
    let start = 0;
    for (let i = 1; i <= residues.length; i++) {
      const s = i < residues.length ? residues[i].ss : 'X';
      if (s !== cur) {
        if (cur !== 'C' && i - start >= 3) {
          regions.push({ type: cur, start, end: i - 1 });
        }
        cur = s;
        start = i;
      }
    }
    return regions;
  }

  // --- Water molecules ---
  function generateWater() {
    waterMolecules = [];
    const count = 80;
    for (let i = 0; i < count; i++) {
      waterMolecules.push({
        x: (Math.random() - 0.5) * 100,
        y: (Math.random() - 0.5) * 100,
        z: (Math.random() - 0.5) * 100,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        vz: (Math.random() - 0.5) * 0.3,
        phase: Math.random() * Math.PI * 2,
      });
    }
  }

  function updateWater() {
    if (!showWater) return;
    for (const w of waterMolecules) {
      w.phase += 0.02;
      // Brownian motion
      w.vx += (Math.random() - 0.5) * 0.1 * temperature;
      w.vy += (Math.random() - 0.5) * 0.1 * temperature;
      w.vz += (Math.random() - 0.5) * 0.1 * temperature;
      w.vx *= 0.92; w.vy *= 0.92; w.vz *= 0.92;
      w.x += w.vx; w.y += w.vy; w.z += w.vz;

      // Attract towards hydrophilic surface residues
      for (const r of residues) {
        if (r.type === AA_HYDROPHILIC || r.type === AA_NEG_CHARGED || r.type === AA_POS_CHARGED) {
          const dx = r.x - w.x, dy = r.y - w.y, dz = r.z - w.z;
          const d2 = dx*dx + dy*dy + dz*dz;
          if (d2 < 400 && d2 > 25) {
            const d = Math.sqrt(d2);
            const f = 0.003 / d;
            w.vx += dx * f; w.vy += dy * f; w.vz += dz * f;
          }
          // Repel if too close
          if (d2 < 25 && d2 > 0.1) {
            const d = Math.sqrt(d2);
            const f = -0.05 / d;
            w.vx += dx * f; w.vy += dy * f; w.vz += dz * f;
          }
        }
      }

      // Contain within bounding sphere
      const dist = Math.sqrt(w.x*w.x + w.y*w.y + w.z*w.z);
      if (dist > 60) {
        const f = -0.01 * (dist - 60);
        w.x += w.x / dist * f; w.y += w.y / dist * f; w.z += w.z / dist * f;
      }
    }
  }

  // --- Disulfide bonds ---
  function findDisulfideBonds() {
    disulfideBonds = [];
    const cysteines = residues.filter(r => r.type === AA_CYSTEINE);
    for (let i = 0; i < cysteines.length; i++) {
      for (let j = i + 1; j < cysteines.length; j++) {
        if (Math.abs(cysteines[i].index - cysteines[j].index) < 4) continue;
        const dx = cysteines[i].x - cysteines[j].x;
        const dy = cysteines[i].y - cysteines[j].y;
        const dz = cysteines[i].z - cysteines[j].z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        if (dist < 8) {
          disulfideBonds.push({ a: cysteines[i].index, b: cysteines[j].index, dist });
        }
      }
    }
  }

  // --- Hydrogen bonds ---
  function findHBonds() {
    hBonds = [];
    if (foldingProgress < 0.3) return;
    // i to i+4 for helices, i to i+2 for beta turns
    for (let i = 0; i < residues.length - 4; i++) {
      if (residues[i].ss === 'H' && residues[i+4].ss === 'H') {
        const a = residues[i], b = residues[i+4];
        const dx = a.x-b.x, dy = a.y-b.y, dz = a.z-b.z;
        const dist = Math.sqrt(dx*dx+dy*dy+dz*dz);
        if (dist < 12) hBonds.push({ a: i, b: i+4, dist, type: 'helix' });
      }
    }
    // Anti-parallel beta sheet hydrogen bonds
    for (let i = 0; i < residues.length - 2; i++) {
      if (residues[i].ss !== 'E') continue;
      for (let j = i + 5; j < residues.length; j++) {
        if (residues[j].ss !== 'E') continue;
        const a = residues[i], b = residues[j];
        const dx = a.x-b.x, dy = a.y-b.y, dz = a.z-b.z;
        const d2 = dx*dx+dy*dy+dz*dz;
        if (d2 < 64) {
          hBonds.push({ a: i, b: j, dist: Math.sqrt(d2), type: 'sheet' });
        }
      }
    }
  }

  // --- Init chain ---
  function initChain() {
    const sequence = generateSequence();
    const ss = assignSS(sequence);
    residues = [];

    for (let i = 0; i < NUM_RESIDUES; i++) {
      residues.push({
        x: (i - NUM_RESIDUES / 2) * BOND_REST,
        y: (Math.random() - 0.5) * 0.5,
        z: (Math.random() - 0.5) * 0.5,
        vx: 0, vy: 0, vz: 0,
        type: sequence[i], ss: ss[i], index: i,
        phi: 0, psi: 0,
      });
    }

    stage = STAGE_EXTEND;
    frame = 0;
    foldingProgress = 0;
    misfoldActive = false;
    misfoldTimer = 300 + Math.random() * 400;
    misfoldShake = 0;
    energyHistory = [];
    disulfideBonds = [];
    hBonds = [];
    chaperonePhase = 0;
    generateWater();
    buildSequenceBar();
    showStageLabel('Extended Chain');
  }

  function buildSequenceBar() {
    seqBar.innerHTML = '';
    for (let i = 0; i < residues.length; i++) {
      const el = document.createElement('div');
      el.className = 'seq-residue';
      const col = AA_COLORS[residues[i].type];
      el.style.background = `rgb(${col[0]},${col[1]},${col[2]})`;
      el.title = `${AA_LETTERS[residues[i].type]}${i+1} (${residues[i].ss})`;
      seqBar.appendChild(el);
    }
  }

  function updateSequenceBar() {
    const children = seqBar.children;
    // Highlight folding region
    const foldCenter = Math.floor(foldingProgress * NUM_RESIDUES);
    const foldRadius = 8;
    for (let i = 0; i < children.length; i++) {
      const dist = Math.abs(i - foldCenter);
      children[i].className = dist < foldRadius ? 'seq-residue active' : 'seq-residue';
    }
  }

  function showStageLabel(text) {
    stageLabel.textContent = text;
    stageLabel.className = 'stage-label visible';
    setTimeout(() => { stageLabel.className = 'stage-label fade'; }, 2500);
  }

  // --- Physics ---
  function applyBondForces() {
    for (let i = 0; i < residues.length - 1; i++) {
      const a = residues[i], b = residues[i + 1];
      const dx = b.x - a.x, dy = b.y - a.y, dz = b.z - a.z;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.001;
      const force = BOND_K * (dist - BOND_REST) / dist;
      const fx = force * dx, fy = force * dy, fz = force * dz;
      a.vx += fx; a.vy += fy; a.vz += fz;
      b.vx -= fx; b.vy -= fy; b.vz -= fz;
    }
    // Disulfide bond forces
    if (foldingProgress > 0.6) {
      for (const ss of disulfideBonds) {
        const a = residues[ss.a], b = residues[ss.b];
        const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z;
        const dist = Math.sqrt(dx*dx+dy*dy+dz*dz) || 0.001;
        const target = 3.0;
        const force = 0.3 * (dist - target) / dist;
        a.vx += force*dx; a.vy += force*dy; a.vz += force*dz;
        b.vx -= force*dx; b.vy -= force*dy; b.vz -= force*dz;
      }
    }
  }

  function applyAngleForces() {
    for (let i = 1; i < residues.length - 1; i++) {
      const a = residues[i-1], b = residues[i], c = residues[i+1];
      const bax = a.x-b.x, bay = a.y-b.y, baz = a.z-b.z;
      const bcx = c.x-b.x, bcy = c.y-b.y, bcz = c.z-b.z;
      const lenBA = Math.sqrt(bax*bax+bay*bay+baz*baz) || 0.001;
      const lenBC = Math.sqrt(bcx*bcx+bcy*bcy+bcz*bcz) || 0.001;
      const dot = (bax*bcx+bay*bcy+baz*bcz) / (lenBA*lenBC);
      const clampedDot = Math.max(-0.999, Math.min(0.999, dot));
      const angle = Math.acos(clampedDot);

      let targetAngle = Math.PI * 0.85;
      if (b.ss === 'H' && foldingProgress > 0.3) targetAngle = Math.PI * 0.55;
      else if (b.ss === 'E' && foldingProgress > 0.5) targetAngle = Math.PI * 0.9;

      // Misfold: perturb target angles
      let misfoldPerturbation = 0;
      if (misfoldActive && misfoldShake > 0) {
        misfoldPerturbation = Math.sin(i * 2 + frame * 0.1) * 0.4 * (misfoldShake / 60);
      }

      const angleDiff = (angle - targetAngle + misfoldPerturbation) * ANGLE_K * Math.min(1, foldingProgress * 2);
      const nax = bax/lenBA, nay = bay/lenBA, naz = baz/lenBA;
      const ncx = bcx/lenBC, ncy = bcy/lenBC, ncz = bcz/lenBC;
      const perpAx = nax - clampedDot*ncx, perpAy = nay - clampedDot*ncy, perpAz = naz - clampedDot*ncz;
      const perpCx = ncx - clampedDot*nax, perpCy = ncy - clampedDot*nay, perpCz = ncz - clampedDot*naz;
      a.vx -= angleDiff*perpAx; a.vy -= angleDiff*perpAy; a.vz -= angleDiff*perpAz;
      c.vx -= angleDiff*perpCx; c.vy -= angleDiff*perpCy; c.vz -= angleDiff*perpCz;

      // Compute phi/psi for Ramachandran
      if (i > 0 && i < residues.length - 1) {
        b.phi = angle - Math.PI;
        b.psi = (clampedDot > 0 ? 1 : -1) * angle * 0.8;
      }
    }
  }

  function applyHydrophobicCollapse() {
    const strength = HYDROPHOBIC_ATTRACT * Math.min(1, foldingProgress * 1.5);
    if (strength < 0.0001) return;
    for (let i = 0; i < residues.length; i++) {
      if (residues[i].type !== AA_HYDROPHOBIC) continue;
      for (let j = i + 3; j < residues.length; j++) {
        if (residues[j].type !== AA_HYDROPHOBIC) continue;
        const a = residues[i], b = residues[j];
        const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z;
        const dist2 = dx*dx+dy*dy+dz*dz;
        if (dist2 > HYDROPHOBIC_RANGE*HYDROPHOBIC_RANGE) continue;
        const dist = Math.sqrt(dist2) || 0.001;
        if (dist < EXCLUDED_VOLUME) continue;
        const force = strength * (1 - dist / HYDROPHOBIC_RANGE) / dist;
        a.vx += force*dx; a.vy += force*dy; a.vz += force*dz;
        b.vx -= force*dx; b.vy -= force*dy; b.vz -= force*dz;
      }
    }
  }

  function applyChargeInteractions() {
    const strength = Math.min(1, foldingProgress * 1.2);
    if (strength < 0.01) return;
    for (let i = 0; i < residues.length; i++) {
      const ti = residues[i].type;
      if (ti !== AA_NEG_CHARGED && ti !== AA_POS_CHARGED) continue;
      for (let j = i + 3; j < residues.length; j++) {
        const tj = residues[j].type;
        if (tj !== AA_NEG_CHARGED && tj !== AA_POS_CHARGED) continue;
        const a = residues[i], b = residues[j];
        const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z;
        const dist2 = dx*dx+dy*dy+dz*dz;
        if (dist2 > 225) continue;
        const dist = Math.sqrt(dist2) || 0.001;
        if (dist < EXCLUDED_VOLUME) continue;
        const k = (ti === tj) ? -CHARGE_REPEL : CHARGE_ATTRACT;
        const force = k * strength / (dist*dist);
        a.vx += force*dx; a.vy += force*dy; a.vz += force*dz;
        b.vx -= force*dx; b.vy -= force*dy; b.vz -= force*dz;
      }
    }
  }

  function applyExcludedVolume() {
    for (let i = 0; i < residues.length; i++) {
      for (let j = i + 2; j < residues.length; j++) {
        const a = residues[i], b = residues[j];
        const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z;
        const dist2 = dx*dx+dy*dy+dz*dz;
        if (dist2 >= EXCLUDED_VOLUME*EXCLUDED_VOLUME) continue;
        const dist = Math.sqrt(dist2) || 0.001;
        const overlap = EXCLUDED_VOLUME - dist;
        const force = EXCLUSION_K * overlap / dist;
        a.vx -= force*dx; a.vy -= force*dy; a.vz -= force*dz;
        b.vx += force*dx; b.vy += force*dy; b.vz += force*dz;
      }
    }
  }

  function applyThermalNoise() {
    const noise = temperature * 0.15;
    for (const r of residues) {
      r.vx += (Math.random() - 0.5) * noise;
      r.vy += (Math.random() - 0.5) * noise;
      r.vz += (Math.random() - 0.5) * noise;
    }
  }

  function applyChaperoneForce() {
    if (!showChaperone) return;
    chaperonePhase += 0.008;
    // Chaperone gently compresses the protein when it's too extended
    const rg = radiusOfGyration();
    if (rg > 15) {
      const strength = 0.002 * (rg - 15);
      for (const r of residues) {
        const dist = Math.sqrt(r.x*r.x + r.y*r.y + r.z*r.z) || 0.001;
        if (dist > 15) {
          r.vx -= r.x / dist * strength;
          r.vy -= r.y / dist * strength;
          r.vz -= r.z / dist * strength;
        }
      }
    }
  }

  function centerMass() {
    let cx = 0, cy = 0, cz = 0;
    for (const r of residues) { cx += r.x; cy += r.y; cz += r.z; }
    cx /= residues.length; cy /= residues.length; cz /= residues.length;
    for (const r of residues) { r.x -= cx; r.y -= cy; r.z -= cz; }
  }

  function computeEnergy() {
    let E = 0;
    // Bond energy
    for (let i = 0; i < residues.length - 1; i++) {
      const a = residues[i], b = residues[i+1];
      const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z;
      const dist = Math.sqrt(dx*dx+dy*dy+dz*dz);
      E += 0.5 * BOND_K * (dist - BOND_REST) * (dist - BOND_REST);
    }
    // Hydrophobic contacts (negative)
    for (let i = 0; i < residues.length; i++) {
      if (residues[i].type !== AA_HYDROPHOBIC) continue;
      for (let j = i + 3; j < residues.length; j++) {
        if (residues[j].type !== AA_HYDROPHOBIC) continue;
        const dx = residues[i].x-residues[j].x, dy = residues[i].y-residues[j].y, dz = residues[i].z-residues[j].z;
        const dist = Math.sqrt(dx*dx+dy*dy+dz*dz);
        if (dist < HYDROPHOBIC_RANGE) E -= 0.5 * (1 - dist / HYDROPHOBIC_RANGE);
      }
    }
    return E;
  }

  function simulate() {
    const damping = BASE_DAMPING - temperature * 0.1;

    // Stage transitions
    if (stage === STAGE_EXTEND) {
      if (frame > 80) { stage = STAGE_COLLAPSE; showStageLabel('Hydrophobic Collapse'); }
    } else if (stage === STAGE_COLLAPSE) {
      foldingProgress = Math.min(1, foldingProgress + 0.003 * (1 + temperature * 0.5));
      if (foldingProgress >= 0.5) { stage = STAGE_HELIX; showStageLabel('Secondary Structure Formation'); }
    } else if (stage === STAGE_HELIX) {
      foldingProgress = Math.min(1, foldingProgress + 0.002);

      // Misfolding events
      misfoldTimer--;
      if (misfoldTimer <= 0 && !misfoldActive && foldingProgress < 0.9) {
        misfoldActive = true;
        misfoldShake = 60;
        showStageLabel('Misfolding Detected!');
        foldingProgress = Math.max(0.35, foldingProgress - 0.15);
        stage = STAGE_MISFOLD;
      }

      if (foldingProgress >= 1) { stage = STAGE_SETTLE; showStageLabel('Native State'); }
    } else if (stage === STAGE_MISFOLD) {
      misfoldShake--;
      if (misfoldShake <= 0) {
        misfoldActive = false;
        misfoldTimer = 500 + Math.random() * 300;
        stage = STAGE_HELIX;
        showStageLabel('Refolding...');
      }
    }

    applyBondForces();
    if (foldingProgress > 0.1) applyAngleForces();
    applyHydrophobicCollapse();
    applyChargeInteractions();
    applyExcludedVolume();
    applyThermalNoise();
    applyChaperoneForce();

    for (const r of residues) {
      r.vx *= damping; r.vy *= damping; r.vz *= damping;
      r.x += r.vx * DT; r.y += r.vy * DT; r.z += r.vz * DT;
    }
    centerMass();

    // Update disulfide bonds and H-bonds periodically
    if (frame % 20 === 0) {
      findDisulfideBonds();
      findHBonds();
    }

    // Energy history
    if (frame % 5 === 0) {
      const E = computeEnergy();
      energyHistory.push(E);
      if (energyHistory.length > 120) energyHistory.shift();
    }
  }

  // --- 3D Projection ---
  function rotateX(p, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return { x: p.x, y: p.y*c - p.z*s, z: p.y*s + p.z*c };
  }
  function rotateY(p, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return { x: p.x*c + p.z*s, y: p.y, z: -p.x*s + p.z*c };
  }

  function project(x, y, z) {
    let p = {x, y, z};
    p = rotateX(p, camRotX);
    p = rotateY(p, camRotY);
    p.z += camDist;
    const fov = 400;
    const scale = fov / (p.z + fov);
    return { sx: W/2 + p.x*scale, sy: H/2 + p.y*scale, z: p.z, scale };
  }

  // --- Rendering ---
  function drawStars() {
    for (const s of stars) {
      const sx = (s.x*0.5+0.5)*W, sy = (s.y*0.5+0.5)*H;
      const alpha = s.brightness * (0.7 + 0.3*Math.sin(frame*0.01+s.x*100));
      ctx.fillStyle = `rgba(180,200,255,${alpha})`;
      ctx.beginPath();
      ctx.arc(sx, sy, s.z*1.2, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawBackground() {
    const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.7);
    grad.addColorStop(0, '#0a0a20');
    grad.addColorStop(0.5, '#060614');
    grad.addColorStop(1, '#020208');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    drawStars();
  }

  function drawWater() {
    if (!showWater) return;
    for (const w of waterMolecules) {
      const p = project(w.x, w.y, w.z);
      if (p.z < -350) continue;
      const r = Math.max(1.2, 2.5 * p.scale);
      const alpha = Math.min(0.35, 0.15 * p.scale) * (0.7 + 0.3 * Math.sin(w.phase));
      // Oxygen (red center)
      ctx.fillStyle = `rgba(60,140,220,${alpha})`;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
      ctx.fill();
      // Two hydrogens
      const hOff = r * 1.5;
      const a1 = w.phase * 0.3;
      ctx.fillStyle = `rgba(180,210,255,${alpha * 0.7})`;
      ctx.beginPath();
      ctx.arc(p.sx + Math.cos(a1)*hOff, p.sy + Math.sin(a1)*hOff, r*0.5, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.sx + Math.cos(a1+1.9)*hOff, p.sy + Math.sin(a1+1.9)*hOff, r*0.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawChaperone() {
    if (!showChaperone) return;
    // Draw as a translucent shell around the protein
    const rg = radiusOfGyration();
    const shellRadius = rg * 1.8 + 5;
    const p = project(0, 0, 0);
    const screenR = shellRadius * p.scale * 12;

    // Breathing animation
    const breathe = 1 + Math.sin(chaperonePhase * 3) * 0.05;
    const finalR = screenR * breathe;

    // Outer shell
    const grad = ctx.createRadialGradient(p.sx, p.sy, finalR*0.7, p.sx, p.sy, finalR);
    grad.addColorStop(0, 'rgba(100,200,180,0)');
    grad.addColorStop(0.6, 'rgba(100,200,180,0.02)');
    grad.addColorStop(0.85, 'rgba(80,180,160,0.06)');
    grad.addColorStop(1, 'rgba(60,160,140,0.1)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(p.sx, p.sy, finalR, 0, Math.PI*2);
    ctx.fill();

    // Dotted rim
    ctx.setLineDash([4, 6]);
    ctx.strokeStyle = `rgba(80,200,170,${0.15 + 0.05*Math.sin(chaperonePhase*2)})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(p.sx, p.sy, finalR, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Label
    ctx.fillStyle = 'rgba(80,200,170,0.3)';
    ctx.font = '9px monospace';
    ctx.fillText('GroEL/ES Chaperonin', p.sx - 55, p.sy - finalR - 6);
  }

  function drawDisulfideBonds(projected) {
    if (foldingProgress < 0.5) return;
    for (const ss of disulfideBonds) {
      const a = projected[ss.a], b = projected[ss.b];
      const alpha = Math.min(0.7, foldingProgress) * ((a.scale+b.scale)*0.5);
      ctx.strokeStyle = `rgba(220,200,50,${alpha})`;
      ctx.lineWidth = 2.5;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(a.sx, a.sy);
      // Draw with a slight curve
      const mx = (a.sx+b.sx)/2 + (a.sy-b.sy)*0.15;
      const my = (a.sy+b.sy)/2 + (b.sx-a.sx)*0.15;
      ctx.quadraticCurveTo(mx, my, b.sx, b.sy);
      ctx.stroke();

      // S-S label
      ctx.fillStyle = `rgba(220,200,50,${alpha*0.6})`;
      ctx.font = '8px monospace';
      ctx.fillText('S-S', mx-8, my-4);
    }
  }

  function drawHBonds(projected) {
    if (hBonds.length === 0) return;
    ctx.setLineDash([3, 4]);
    ctx.lineWidth = 0.8;
    for (const hb of hBonds) {
      const a = projected[hb.a], b = projected[hb.b];
      const alpha = Math.min(0.3, foldingProgress*0.35) * ((a.scale+b.scale)*0.5);
      if (hb.type === 'helix') {
        ctx.strokeStyle = `rgba(140,120,240,${alpha})`;
      } else {
        ctx.strokeStyle = `rgba(80,180,255,${alpha})`;
      }
      ctx.beginPath();
      ctx.moveTo(a.sx, a.sy);
      ctx.lineTo(b.sx, b.sy);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  function drawRibbon(projected) {
    const regions = detectSSRegions();
    ctx.lineWidth = 1;

    for (const reg of regions) {
      if (reg.end - reg.start < 2) continue;

      if (reg.type === 'H') {
        // Alpha helix: draw as a thick ribbon with helical twist
        ctx.lineWidth = 4;
        const helixColor = `rgba(160,120,220,${0.5 * foldingProgress})`;
        ctx.strokeStyle = helixColor;
        ctx.beginPath();
        for (let i = reg.start; i <= reg.end; i++) {
          const p = projected[i];
          const twist = Math.sin(i * 1.0 + frame * 0.02) * 4 * p.scale;
          if (i === reg.start) ctx.moveTo(p.sx + twist, p.sy);
          else ctx.lineTo(p.sx + twist, p.sy);
        }
        ctx.stroke();

        // Second strand for ribbon effect
        ctx.strokeStyle = `rgba(130,90,200,${0.3 * foldingProgress})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let i = reg.start; i <= reg.end; i++) {
          const p = projected[i];
          const twist = Math.sin(i * 1.0 + frame * 0.02 + Math.PI) * 4 * p.scale;
          if (i === reg.start) ctx.moveTo(p.sx + twist, p.sy);
          else ctx.lineTo(p.sx + twist, p.sy);
        }
        ctx.stroke();
      } else if (reg.type === 'E') {
        // Beta sheet: flat arrows
        const last = reg.end;
        ctx.fillStyle = `rgba(220,200,100,${0.4 * foldingProgress})`;
        ctx.strokeStyle = `rgba(220,200,100,${0.6 * foldingProgress})`;
        ctx.lineWidth = 1;

        // Draw flat band
        ctx.beginPath();
        for (let i = reg.start; i <= reg.end; i++) {
          const p = projected[i];
          const norm = 3 * p.scale;
          if (i === reg.start) ctx.moveTo(p.sx, p.sy - norm);
          else ctx.lineTo(p.sx, p.sy - norm);
        }
        for (let i = reg.end; i >= reg.start; i--) {
          const p = projected[i];
          const norm = 3 * p.scale;
          ctx.lineTo(p.sx, p.sy + norm);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Arrowhead at end
        const pe = projected[last];
        const arrowSize = 6 * pe.scale;
        ctx.beginPath();
        ctx.moveTo(pe.sx + arrowSize*2, pe.sy);
        ctx.lineTo(pe.sx, pe.sy - arrowSize);
        ctx.lineTo(pe.sx, pe.sy + arrowSize);
        ctx.closePath();
        ctx.fill();
      }
    }
  }

  function drawProtein() {
    const projected = residues.map(r => {
      const p = project(r.x, r.y, r.z);
      return { ...p, type: r.type, ss: r.ss, index: r.index };
    });

    const sorted = projected.slice().sort((a, b) => b.z - a.z);
    const mode = renderMode;

    // Draw ribbon/backbone overlays first if in those modes
    if (mode === 'ribbon') {
      drawRibbon(projected);
    }

    // Draw H-bonds
    drawHBonds(projected);

    // Draw disulfide bonds
    drawDisulfideBonds(projected);

    // Backbone bonds
    if (mode !== 'spacefill') {
      const boneWidth = mode === 'backbone' ? 2.5 : 1.5;
      ctx.lineWidth = boneWidth;
      for (let i = 0; i < projected.length - 1; i++) {
        const a = projected[i], b = projected[i+1];
        const alpha = Math.min(0.7, (a.scale+b.scale)*0.4);
        let bondColor;
        const ss = residues[i].ss;
        if (ss === 'H' && foldingProgress > 0.3) bondColor = `rgba(160,120,220,${alpha})`;
        else if (ss === 'E' && foldingProgress > 0.5) bondColor = `rgba(220,200,100,${alpha})`;
        else bondColor = `rgba(100,120,160,${alpha})`;
        ctx.strokeStyle = bondColor;
        ctx.beginPath();
        ctx.moveTo(a.sx, a.sy);
        ctx.lineTo(b.sx, b.sy);
        ctx.stroke();
      }
    }

    if (mode === 'backbone') {
      // Just draw small dots at each position
      for (const p of sorted) {
        const col = AA_COLORS[p.type];
        const r = Math.max(1.5, BEAD_RADIUS * p.scale * 5);
        ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},0.6)`;
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
        ctx.fill();
      }
      return;
    }

    if (mode === 'ribbon') {
      // Minimal beads on ribbon
      for (const p of sorted) {
        const col = AA_COLORS[p.type];
        const r = Math.max(1.5, BEAD_RADIUS * p.scale * 6);
        ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},0.4)`;
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
        ctx.fill();
      }
      return;
    }

    // Ball-and-stick or Space-filling
    const sizeMul = mode === 'spacefill' ? 22 : 12;

    for (const p of sorted) {
      const col = AA_COLORS[p.type];
      const baseR = BEAD_RADIUS * p.scale * sizeMul;
      const r = Math.max(2, baseR);

      // Glow
      const glowR = r * (mode === 'spacefill' ? 1.6 : 2.5);
      const glow = ctx.createRadialGradient(p.sx, p.sy, r*0.3, p.sx, p.sy, glowR);
      const glowAlpha = (mode === 'spacefill' ? 0.08 : 0.15) * p.scale;
      glow.addColorStop(0, `rgba(${col[0]},${col[1]},${col[2]},${glowAlpha})`);
      glow.addColorStop(1, `rgba(${col[0]},${col[1]},${col[2]},0)`);
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, glowR, 0, Math.PI*2);
      ctx.fill();

      // 3D shaded sphere
      const grad = ctx.createRadialGradient(p.sx-r*0.3, p.sy-r*0.3, r*0.1, p.sx, p.sy, r);
      const br = (c, f) => Math.min(255, Math.floor(c*f));
      grad.addColorStop(0, `rgba(${br(col[0],1.5)},${br(col[1],1.5)},${br(col[2],1.5)},0.95)`);
      grad.addColorStop(0.5, `rgba(${col[0]},${col[1]},${col[2]},0.9)`);
      grad.addColorStop(1, `rgba(${Math.floor(col[0]*0.4)},${Math.floor(col[1]*0.4)},${Math.floor(col[2]*0.4)},0.85)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
      ctx.fill();

      // Secondary structure ring
      if (foldingProgress > 0.3 && mode !== 'spacefill') {
        let ringColor = null;
        if (p.ss === 'H') ringColor = `rgba(160,120,220,${0.4*foldingProgress})`;
        else if (p.ss === 'E') ringColor = `rgba(220,200,100,${0.3*foldingProgress})`;
        if (ringColor) {
          ctx.strokeStyle = ringColor;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(p.sx, p.sy, r+2, 0, Math.PI*2);
          ctx.stroke();
        }
      }
    }
  }

  // --- Energy landscape panel ---
  function drawEnergyLandscape() {
    const w = energyCanvas.width, h = energyCanvas.height;
    ectx.clearRect(0, 0, w, h);
    ectx.fillStyle = 'rgba(8,10,25,0.9)';
    ectx.fillRect(0, 0, w, h);

    if (energyHistory.length < 2) return;

    // Draw 2D energy landscape contours (funnel shape)
    const cx = w * 0.5, cy = h * 0.4;
    for (let ring = 5; ring > 0; ring--) {
      const r = ring * 12;
      const alpha = 0.08 + ring * 0.02;
      ectx.strokeStyle = `rgba(60,120,200,${alpha})`;
      ectx.lineWidth = 0.5;
      ectx.beginPath();
      ectx.ellipse(cx, cy + ring * 4, r, r * 0.5, 0, 0, Math.PI * 2);
      ectx.stroke();
    }

    // Current state as a ball on the funnel
    const progress = foldingProgress;
    const ballX = cx + Math.sin(frame * 0.03) * (1 - progress) * 30;
    const ballY = cy + progress * 40 + Math.cos(frame * 0.05) * (1 - progress) * 10;

    // Trail
    const trailAlpha = 0.3;
    ectx.fillStyle = `rgba(100,180,255,${trailAlpha})`;
    for (let t = 0; t < 5; t++) {
      const tp = Math.max(0, progress - t * 0.05);
      const tx = cx + Math.sin((frame - t*10) * 0.03) * (1-tp) * 30;
      const ty = cy + tp * 40 + Math.cos((frame - t*10) * 0.05) * (1-tp) * 10;
      ectx.beginPath();
      ectx.arc(tx, ty, 1.5 - t*0.2, 0, Math.PI*2);
      ectx.fill();
    }

    // Current ball
    const ballGrad = ectx.createRadialGradient(ballX, ballY, 0, ballX, ballY, 4);
    ballGrad.addColorStop(0, 'rgba(150,220,255,0.9)');
    ballGrad.addColorStop(1, 'rgba(80,140,255,0)');
    ectx.fillStyle = ballGrad;
    ectx.beginPath();
    ectx.arc(ballX, ballY, 4, 0, Math.PI*2);
    ectx.fill();

    // Energy trace at bottom
    const maxE = Math.max(...energyHistory) || 1;
    const minE = Math.min(...energyHistory) || 0;
    const range = maxE - minE || 1;
    ectx.strokeStyle = 'rgba(100,200,150,0.4)';
    ectx.lineWidth = 1;
    ectx.beginPath();
    for (let i = 0; i < energyHistory.length; i++) {
      const x = (i / energyHistory.length) * w;
      const y = h - 5 - ((energyHistory[i] - minE) / range) * 15;
      if (i === 0) ectx.moveTo(x, y); else ectx.lineTo(x, y);
    }
    ectx.stroke();

    // Labels
    ectx.fillStyle = 'rgba(160,180,210,0.4)';
    ectx.font = '7px monospace';
    ectx.fillText('Unfolded', 3, 12);
    ectx.fillText('Native', cx - 12, h - 2);
  }

  // --- Ramachandran plot ---
  function drawRamachandran() {
    const w = ramaCanvas.width, h = ramaCanvas.height;
    rctx.clearRect(0, 0, w, h);
    rctx.fillStyle = 'rgba(8,10,25,0.9)';
    rctx.fillRect(0, 0, w, h);

    // Axes
    rctx.strokeStyle = 'rgba(100,120,160,0.3)';
    rctx.lineWidth = 0.5;
    // Horizontal axis (phi)
    rctx.beginPath();
    rctx.moveTo(0, h/2); rctx.lineTo(w, h/2);
    rctx.stroke();
    // Vertical axis (psi)
    rctx.beginPath();
    rctx.moveTo(w/2, 0); rctx.lineTo(w/2, h);
    rctx.stroke();

    // Allowed regions (simplified)
    // Alpha helix region
    rctx.fillStyle = 'rgba(160,120,220,0.08)';
    rctx.fillRect(w*0.15, h*0.15, w*0.25, h*0.25);
    // Beta sheet region
    rctx.fillStyle = 'rgba(220,200,100,0.08)';
    rctx.fillRect(w*0.55, h*0.1, w*0.3, h*0.25);

    // Labels
    rctx.fillStyle = 'rgba(160,180,210,0.35)';
    rctx.font = '7px monospace';
    rctx.fillText('\u03C6', w/2 + 2, h - 2);
    rctx.fillText('\u03C8', 2, h/2 - 3);
    rctx.fillText('\u03B1', w*0.22, h*0.28);
    rctx.fillText('\u03B2', w*0.65, h*0.25);

    // Plot points
    for (let i = 1; i < residues.length - 1; i++) {
      const r = residues[i];
      const phi = r.phi || 0;
      const psi = r.psi || 0;
      const px = w/2 + (phi / Math.PI) * w/2;
      const py = h/2 - (psi / Math.PI) * h/2;

      const col = AA_COLORS[r.type];
      let alpha = 0.5;
      if (r.ss === 'H') alpha = 0.8;
      else if (r.ss === 'E') alpha = 0.7;

      rctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},${alpha * foldingProgress})`;
      rctx.beginPath();
      rctx.arc(px, py, 2, 0, Math.PI*2);
      rctx.fill();
    }
  }

  // --- Film grain ---
  function updateFilmGrain() {
    if (frame % 3 !== 0) return;
    const imgData = grainCtx.createImageData(W, H);
    const d = imgData.data;
    // Only do a sparse grain for performance
    for (let i = 0; i < d.length; i += 16) {
      const v = Math.random() * 255;
      d[i] = d[i+1] = d[i+2] = v;
      d[i+3] = 255;
    }
    grainCtx.putImageData(imgData, 0, 0);
    filmGrain.style.backgroundImage = `url(${grainCanvas.toDataURL()})`;
    filmGrain.style.backgroundSize = '100% 100%';
  }

  function radiusOfGyration() {
    let cx = 0, cy = 0, cz = 0;
    for (const r of residues) { cx += r.x; cy += r.y; cz += r.z; }
    cx /= residues.length; cy /= residues.length; cz /= residues.length;
    let rg2 = 0;
    for (const r of residues) {
      const dx = r.x-cx, dy = r.y-cy, dz = r.z-cz;
      rg2 += dx*dx + dy*dy + dz*dz;
    }
    return Math.sqrt(rg2 / residues.length);
  }

  function updateStatus() {
    const rg = radiusOfGyration().toFixed(1);
    const stageNames = ['Extended Chain', 'Hydrophobic Collapse', 'Secondary Structure', 'Native State', 'Misfolding!'];
    const helixCount = residues.filter(r => r.ss === 'H').length;
    const sheetCount = residues.filter(r => r.ss === 'E').length;
    const preset = PRESETS[currentProtein];
    const name = preset ? preset.name : 'Random';
    const tempLabel = temperature < 0.3 ? 'Cold' : temperature < 0.7 ? 'Ambient' : 'Hot';
    statusLine.textContent =
      `${name}  |  ${stageNames[stage]}  |  Rg: ${rg}\u00C5  |  ` +
      `H: ${helixCount}  E: ${sheetCount}  |  SS: ${disulfideBonds.length}  |  ` +
      `T: ${tempLabel}  |  n=${NUM_RESIDUES}`;
  }

  // --- Mouse / Touch ---
  canvas.addEventListener('mousedown', (e) => {
    dragging = true; lastMX = e.clientX; lastMY = e.clientY; autoRotate = false;
  });
  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    camRotY += (e.clientX - lastMX) * 0.005;
    camRotX += (e.clientY - lastMY) * 0.005;
    camRotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, camRotX));
    lastMX = e.clientX; lastMY = e.clientY;
  });
  window.addEventListener('mouseup', () => {
    dragging = false;
    setTimeout(() => { if (!dragging) autoRotate = true; }, 3000);
  });
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; autoRotate = false;
    }
  }, { passive: true });
  canvas.addEventListener('touchmove', (e) => {
    if (!dragging || e.touches.length !== 1) return;
    camRotY += (e.touches[0].clientX - lastMX) * 0.005;
    camRotX += (e.touches[0].clientY - lastMY) * 0.005;
    camRotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, camRotX));
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  }, { passive: true });
  canvas.addEventListener('touchend', () => {
    dragging = false;
    setTimeout(() => { if (!dragging) autoRotate = true; }, 3000);
  }, { passive: true });
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    camDist = Math.max(40, Math.min(300, camDist + e.deltaY * 0.1));
  }, { passive: false });

  // --- Controls ---
  proteinSelect.addEventListener('change', () => {
    currentProtein = proteinSelect.value;
    reset();
  });
  renderModeSelect.addEventListener('change', () => {
    renderMode = renderModeSelect.value;
  });
  tempSlider.addEventListener('input', () => {
    temperature = tempSlider.value / 100;
  });
  btnChaperone.addEventListener('click', () => {
    showChaperone = !showChaperone;
    btnChaperone.classList.toggle('active', showChaperone);
  });
  btnWater.addEventListener('click', () => {
    showWater = !showWater;
    btnWater.classList.toggle('active', showWater);
  });
  // Init button states
  btnWater.classList.add('active');

  // --- Main loop ---
  let paused = false;

  function animate() {
    requestAnimationFrame(animate);
    if (paused) return;
    frame++;

    if (autoRotate) camRotY += 0.004;

    // Physics substeps
    for (let s = 0; s < 3; s++) simulate();
    updateWater();

    drawBackground();
    drawWater();
    drawChaperone();
    drawProtein();

    if (frame % 10 === 0) updateSequenceBar();
    if (frame % 15 === 0) drawEnergyLandscape();
    if (frame % 20 === 0) drawRamachandran();
    if (frame % 30 === 0) updateStatus();
    if (frame % 6 === 0) updateFilmGrain();
  }

  // Pause/Resume
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); paused = !paused; }
  });

  // Reset
  function reset() {
    initChain();
    paused = false;
    autoRotate = true;
    camRotX = 0.3;
    camRotY = 0;
    camDist = 120;
  }
  window.reset = reset;

  // Start
  initChain();
  animate();

})();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
