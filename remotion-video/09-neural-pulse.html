<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Signal Propagation - Remotion Video Effects</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, hsl(240, 35%, 8%) 0%, hsl(220, 45%, 13%) 50%, hsl(200, 30%, 10%) 100%);
            overflow: hidden;
            font-family: monospace;
        }
        canvas { display: block; }
        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }
        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            z-index: 5;
        }
        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.06) 2px,
                rgba(0,0,0,0.06) 4px
            );
        }
        .film-grain {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 7;
            opacity: 0.04;
            mix-blend-mode: overlay;
        }
        .info {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: monospace;
            font-size: 0.7rem;
            color: rgba(100, 200, 255, 0.35);
            z-index: 10;
            text-align: center;
            letter-spacing: 0.05em;
        }
        .controls {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
        }
        .ctrl-btn {
            background: rgba(20, 35, 70, 0.7);
            border: 1px solid rgba(100, 200, 255, 0.2);
            color: rgba(100, 200, 255, 0.7);
            font-family: monospace;
            font-size: 0.65rem;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .ctrl-btn:hover { border-color: rgba(100, 200, 255, 0.5); color: rgba(100, 200, 255, 1); background: rgba(20, 35, 70, 0.9); }
        .ctrl-btn.active { border-color: rgba(100, 200, 255, 0.6); background: rgba(40, 80, 160, 0.5); color: #fff; }
        .hud {
            position: fixed;
            top: 3.5rem;
            left: 1rem;
            z-index: 20;
            font-family: monospace;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.5);
            line-height: 1.6;
            pointer-events: none;
        }
        .hud .val { color: rgba(100, 220, 255, 0.85); }
        .hud .loss-val { color: rgba(255, 140, 80, 0.85); }
        .hud .acc-val { color: rgba(80, 255, 180, 0.85); }
        .mini-graph {
            position: fixed;
            bottom: 3.5rem;
            right: 1rem;
            z-index: 20;
            pointer-events: none;
        }
        .mini-graph canvas {
            border: 1px solid rgba(100, 200, 255, 0.15);
            border-radius: 3px;
            background: rgba(8, 12, 24, 0.6);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&#8592; Back to Gallery</a>
    <canvas id="canvas"></canvas>
    <div class="vignette"></div>
    <div class="scanlines"></div>
    <canvas id="grainCanvas" class="film-grain" width="256" height="256"></canvas>

    <div class="controls">
        <button class="ctrl-btn active" id="btnFeedforward" onclick="setArch('feedforward')">Feedforward</button>
        <button class="ctrl-btn" id="btnCNN" onclick="setArch('cnn')">CNN</button>
        <button class="ctrl-btn" id="btnRNN" onclick="setArch('rnn')">RNN</button>
        <button class="ctrl-btn" id="btnTransformer" onclick="setArch('transformer')">Transformer</button>
        <hr style="border-color: rgba(100,200,255,0.1); width: 100%; margin: 2px 0;">
        <button class="ctrl-btn" id="btnDropout" onclick="toggleDropout()">Dropout: OFF</button>
        <button class="ctrl-btn" id="btnBackprop" onclick="toggleBackprop()">Backprop: OFF</button>
    </div>

    <div class="hud" id="hud">
        Epoch: <span class="val" id="hudEpoch">0</span><br>
        Loss: <span class="loss-val" id="hudLoss">2.3026</span><br>
        Accuracy: <span class="acc-val" id="hudAcc">10.0%</span><br>
        Architecture: <span class="val" id="hudArch">Feedforward</span><br>
        Activation: <span class="val" id="hudAct">ReLU</span>
    </div>

    <div class="mini-graph">
        <canvas id="lossGraph" width="160" height="80"></canvas>
    </div>

    <div class="info">Click nodes to trigger signals | Toggle architecture & features above</div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const grainCanvas = document.getElementById('grainCanvas');
    const grainCtx = grainCanvas.getContext('2d');
    const lossCanvas = document.getElementById('lossGraph');
    const lossCtx = lossCanvas.getContext('2d');

    let W, H;
    let nodes = [];
    let connections = [];
    let recurrentConnections = [];
    let signals = [];
    let backSignals = [];
    let particles = [];
    let sparks = [];
    let time = 0;
    let animId;
    let epoch = 0;
    let trainLoss = 2.3026;
    let trainAcc = 10.0;
    let lossHistory = [];
    let dropoutEnabled = false;
    let backpropEnabled = false;
    let currentArch = 'feedforward';
    let batchNormTimer = 0;
    let batchNormLayer = -1;
    let batchNormAlpha = 0;

    // Architecture definitions
    const ARCHS = {
        feedforward: { layers: [4, 7, 10, 12, 10, 7, 4], labels: ['Input', 'Hidden 1', 'Hidden 2', 'Hidden 3', 'Hidden 4', 'Hidden 5', 'Output'], activations: ['none', 'relu', 'relu', 'relu', 'relu', 'relu', 'sigmoid'], recurrent: false, attention: -1 },
        cnn: { layers: [6, 8, 8, 12, 8, 6, 3], labels: ['Input', 'Conv 1', 'Pool 1', 'Conv 2', 'Pool 2', 'FC', 'Output'], activations: ['none', 'relu', 'none', 'relu', 'none', 'relu', 'sigmoid'], recurrent: false, attention: -1 },
        rnn: { layers: [4, 8, 8, 8, 8, 6, 3], labels: ['Input', 'LSTM 1', 'LSTM 2', 'LSTM 3', 'LSTM 4', 'Dense', 'Output'], activations: ['none', 'relu', 'relu', 'relu', 'relu', 'relu', 'sigmoid'], recurrent: true, attention: -1 },
        transformer: { layers: [4, 8, 10, 10, 8, 6, 3], labels: ['Input', 'Embed', 'Attn Q/K/V', 'Attn Out', 'FFN', 'Norm', 'Output'], activations: ['none', 'none', 'relu', 'relu', 'relu', 'relu', 'sigmoid'], recurrent: false, attention: 2 }
    };

    const NODE_RADIUS = 6;
    const SIGNAL_SPEED = 2.5;

    const COLORS = {
        nodeIdle: { r: 40, g: 80, b: 140 },
        nodeActive: { r: 80, g: 200, b: 255 },
        nodeGlow: { r: 100, g: 220, b: 255 },
        nodeDropout: { r: 60, g: 60, b: 80 },
        connectionIdle: { r: 30, g: 60, b: 120 },
        signalHead: { r: 120, g: 220, b: 255 },
        signalTrail: { r: 60, g: 140, b: 220 },
        backpropHead: { r: 220, g: 60, b: 60 },
        backpropTrail: { r: 160, g: 40, b: 40 },
        attentionLine: { r: 255, g: 200, b: 60 },
        batchNorm: { r: 60, g: 255, b: 180 },
        particleColors: [
            { r: 80, g: 200, b: 255 },
            { r: 140, g: 100, b: 255 },
            { r: 60, g: 255, b: 200 },
            { r: 255, g: 180, b: 80 }
        ]
    };

    // Film grain generation
    function generateGrain() {
        const imgData = grainCtx.createImageData(256, 256);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            const v = Math.random() * 255;
            data[i] = v; data[i+1] = v; data[i+2] = v; data[i+3] = 255;
        }
        grainCtx.putImageData(imgData, 0, 0);
    }

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        buildNetwork();
    }

    function buildNetwork() {
        nodes = [];
        connections = [];
        recurrentConnections = [];
        signals = [];
        backSignals = [];
        particles = [];
        sparks = [];

        const arch = ARCHS[currentArch];
        const LAYER_COUNTS = arch.layers;
        const numLayers = LAYER_COUNTS.length;
        const layerSpacing = W / (numLayers + 1);
        const verticalPadding = H * 0.14;

        for (let l = 0; l < numLayers; l++) {
            const count = LAYER_COUNTS[l];
            const x = layerSpacing * (l + 1);
            const availHeight = H - verticalPadding * 2;
            const nodeSpacing = availHeight / (count + 1);

            for (let n = 0; n < count; n++) {
                const y = verticalPadding + nodeSpacing * (n + 1);
                const activation_fn = arch.activations[l];
                nodes.push({
                    x, y,
                    layer: l,
                    index: n,
                    activation: 0,
                    pulsePhase: Math.random() * Math.PI * 2,
                    radius: NODE_RADIUS + (l === 0 || l === numLayers - 1 ? 2 : 0),
                    activationFn: activation_fn,
                    droppedOut: false,
                    dropoutFlicker: 0
                });
            }
        }

        // Forward connections
        for (let i = 0; i < nodes.length; i++) {
            for (let j = 0; j < nodes.length; j++) {
                if (nodes[j].layer === nodes[i].layer + 1) {
                    const layerSize = Math.max(LAYER_COUNTS[nodes[i].layer], LAYER_COUNTS[nodes[j].layer]);
                    const connectProb = layerSize <= 7 ? 0.7 : 0.4;
                    if (Math.random() < connectProb) {
                        const weight = 0.1 + Math.random() * 0.9;
                        connections.push({
                            from: i, to: j,
                            weight, activity: 0
                        });
                    }
                }
            }
        }

        // Ensure connectivity
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.layer < numLayers - 1) {
                const outgoing = connections.filter(c => c.from === i);
                if (outgoing.length === 0) {
                    const nextLayerNodes = nodes.filter(n => n.layer === node.layer + 1);
                    const target = nextLayerNodes[Math.floor(Math.random() * nextLayerNodes.length)];
                    connections.push({ from: i, to: nodes.indexOf(target), weight: 0.3 + Math.random() * 0.7, activity: 0 });
                }
            }
            if (node.layer > 0) {
                const incoming = connections.filter(c => c.to === i);
                if (incoming.length === 0) {
                    const prevLayerNodes = nodes.filter(n => n.layer === node.layer - 1);
                    const source = prevLayerNodes[Math.floor(Math.random() * prevLayerNodes.length)];
                    connections.push({ from: nodes.indexOf(source), to: i, weight: 0.3 + Math.random() * 0.7, activity: 0 });
                }
            }
        }

        // Recurrent connections (for RNN)
        if (arch.recurrent) {
            for (let l = 1; l < numLayers - 1; l++) {
                const layerNodes = nodes.filter(n => n.layer === l);
                const nextLayerNodes = nodes.filter(n => n.layer === l + 1);
                if (nextLayerNodes.length > 0) {
                    // backward connections from layer l+1 back to layer l
                    for (let k = 0; k < 2 && k < nextLayerNodes.length; k++) {
                        const fromIdx = nodes.indexOf(nextLayerNodes[Math.floor(Math.random() * nextLayerNodes.length)]);
                        const toIdx = nodes.indexOf(layerNodes[Math.floor(Math.random() * layerNodes.length)]);
                        recurrentConnections.push({
                            from: fromIdx, to: toIdx,
                            weight: 0.3 + Math.random() * 0.5,
                            activity: 0,
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
        }

        // Attention weight connections (for Transformer)
        if (arch.attention >= 0) {
            const attnLayerNodes = nodes.filter(n => n.layer === arch.attention);
            for (let i = 0; i < attnLayerNodes.length; i++) {
                for (let j = i + 1; j < attnLayerNodes.length; j++) {
                    if (Math.random() < 0.6) {
                        const ni = nodes.indexOf(attnLayerNodes[i]);
                        const nj = nodes.indexOf(attnLayerNodes[j]);
                        recurrentConnections.push({
                            from: ni, to: nj,
                            weight: Math.random(),
                            activity: 0,
                            phase: Math.random() * Math.PI * 2,
                            isAttention: true
                        });
                    }
                }
            }
        }
    }

    function setArch(name) {
        currentArch = name;
        document.querySelectorAll('.ctrl-btn').forEach(b => {
            if (['btnFeedforward','btnCNN','btnRNN','btnTransformer'].includes(b.id)) b.classList.remove('active');
        });
        document.getElementById('btn' + name.charAt(0).toUpperCase() + name.slice(1)).classList.add('active');
        document.getElementById('hudArch').textContent = name.charAt(0).toUpperCase() + name.slice(1);
        resize();
        ctx.fillStyle = 'rgba(8, 12, 24, 1)';
        ctx.fillRect(0, 0, W, H);
        setTimeout(launchSignalFromInput, 100);
        setTimeout(launchSignalFromInput, 500);
    }

    function toggleDropout() {
        dropoutEnabled = !dropoutEnabled;
        const btn = document.getElementById('btnDropout');
        btn.textContent = 'Dropout: ' + (dropoutEnabled ? 'ON' : 'OFF');
        btn.classList.toggle('active', dropoutEnabled);
        if (dropoutEnabled) applyDropout();
        else clearDropout();
    }

    function toggleBackprop() {
        backpropEnabled = !backpropEnabled;
        const btn = document.getElementById('btnBackprop');
        btn.textContent = 'Backprop: ' + (backpropEnabled ? 'ON' : 'OFF');
        btn.classList.toggle('active', backpropEnabled);
    }

    function applyDropout() {
        for (const node of nodes) {
            if (node.layer > 0 && node.layer < ARCHS[currentArch].layers.length - 1) {
                node.droppedOut = Math.random() < 0.25;
                node.dropoutFlicker = node.droppedOut ? 1.0 : 0;
            }
        }
    }

    function clearDropout() {
        for (const node of nodes) {
            node.droppedOut = false;
            node.dropoutFlicker = 0;
        }
    }

    function launchSignalFromInput() {
        const inputNodes = nodes.filter(n => n.layer === 0);
        if (inputNodes.length === 0) return;
        const startNode = inputNodes[Math.floor(Math.random() * inputNodes.length)];
        activateNode(nodes.indexOf(startNode));
    }

    function activateNode(nodeIdx) {
        const node = nodes[nodeIdx];
        if (node.droppedOut && dropoutEnabled) return;
        node.activation = 1.0;

        spawnBurst(node.x, node.y, 6);

        const outgoing = connections.filter(c => c.from === nodeIdx);
        for (const conn of outgoing) {
            const toNode = nodes[conn.to];
            if (toNode.droppedOut && dropoutEnabled) continue;
            const fromNode = nodes[conn.from];
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const delay = Math.random() * 8;

            signals.push({
                connIdx: connections.indexOf(conn),
                fromX: fromNode.x, fromY: fromNode.y,
                toX: toNode.x, toY: toNode.y,
                progress: 0,
                speed: SIGNAL_SPEED / dist,
                targetNode: conn.to,
                delay, active: false,
                trail: [],
                color: COLORS.particleColors[node.layer % COLORS.particleColors.length]
            });
        }

        // Recurrent signals
        const recOut = recurrentConnections.filter(c => c.from === nodeIdx && !c.isAttention);
        for (const conn of recOut) {
            const toNode = nodes[conn.to];
            const fromNode = nodes[conn.from];
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            signals.push({
                connIdx: -1,
                fromX: fromNode.x, fromY: fromNode.y,
                toX: toNode.x, toY: toNode.y,
                progress: 0,
                speed: SIGNAL_SPEED * 0.7 / dist,
                targetNode: conn.to,
                delay: 5 + Math.random() * 10,
                active: false, trail: [],
                color: { r: 255, g: 140, b: 60 },
                isRecurrent: true
            });
        }
    }

    function launchBackpropSignal() {
        if (!backpropEnabled) return;
        const arch = ARCHS[currentArch];
        const outputNodes = nodes.filter(n => n.layer === arch.layers.length - 1);
        if (outputNodes.length === 0) return;
        const startNode = outputNodes[Math.floor(Math.random() * outputNodes.length)];
        const startIdx = nodes.indexOf(startNode);

        // backward through connections
        const incoming = connections.filter(c => c.to === startIdx);
        for (const conn of incoming) {
            const fromNode = nodes[conn.to]; // signal goes backward: to -> from
            const toNode = nodes[conn.from];
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            backSignals.push({
                fromX: fromNode.x, fromY: fromNode.y,
                toX: toNode.x, toY: toNode.y,
                progress: 0,
                speed: SIGNAL_SPEED * 0.6 / dist,
                targetNode: conn.from,
                delay: Math.random() * 5,
                active: false, trail: []
            });
        }
    }

    function spawnBurst(x, y, count) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
            const speed = 0.5 + Math.random() * 1.5;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                decay: 0.015 + Math.random() * 0.02,
                size: 1 + Math.random() * 2.5,
                color: COLORS.particleColors[Math.floor(Math.random() * COLORS.particleColors.length)]
            });
        }
    }

    function spawnSparks(x, y) {
        const count = 8 + Math.floor(Math.random() * 6);
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 3;
            sparks.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                decay: 0.03 + Math.random() * 0.04,
                size: 0.5 + Math.random() * 1.5,
                color: { r: 255, g: 200 + Math.floor(Math.random() * 55), b: 80 + Math.floor(Math.random() * 120) }
            });
        }
    }

    function updateTraining() {
        // Simulated training progress
        epoch += 0.016;
        const ep = Math.floor(epoch);
        const progress = 1 - Math.exp(-epoch * 0.03);
        trainLoss = 2.3026 * (1 - progress) + 0.01 * progress + Math.sin(epoch * 0.7) * 0.02 * (1 - progress * 0.8);
        trainAcc = 10 + 89.5 * progress + Math.sin(epoch * 0.5) * 1.5 * (1 - progress * 0.5);
        trainLoss = Math.max(0.005, trainLoss);
        trainAcc = Math.min(99.8, trainAcc);

        if (Math.floor(epoch * 60) % 3 === 0) {
            lossHistory.push(trainLoss);
            if (lossHistory.length > 160) lossHistory.shift();
        }

        document.getElementById('hudEpoch').textContent = ep;
        document.getElementById('hudLoss').textContent = trainLoss.toFixed(4);
        document.getElementById('hudAcc').textContent = trainAcc.toFixed(1) + '%';

        const actFn = ARCHS[currentArch].activations[1];
        document.getElementById('hudAct').textContent = actFn === 'relu' ? 'ReLU' : actFn === 'sigmoid' ? 'Sigmoid' : 'None';
    }

    function drawLossGraph() {
        const w = lossCanvas.width;
        const h = lossCanvas.height;
        lossCtx.clearRect(0, 0, w, h);

        if (lossHistory.length < 2) return;

        // Background
        lossCtx.fillStyle = 'rgba(8, 12, 24, 0.4)';
        lossCtx.fillRect(0, 0, w, h);

        // Label
        lossCtx.font = '8px monospace';
        lossCtx.fillStyle = 'rgba(100, 200, 255, 0.4)';
        lossCtx.fillText('Loss', 4, 10);

        // Draw loss curve
        const maxLoss = 2.4;
        lossCtx.beginPath();
        for (let i = 0; i < lossHistory.length; i++) {
            const x = (i / (lossHistory.length - 1)) * w;
            const y = h - (lossHistory[i] / maxLoss) * (h - 14) - 2;
            if (i === 0) lossCtx.moveTo(x, y);
            else lossCtx.lineTo(x, y);
        }
        lossCtx.strokeStyle = 'rgba(255, 140, 80, 0.7)';
        lossCtx.lineWidth = 1.2;
        lossCtx.stroke();

        // Glow
        lossCtx.strokeStyle = 'rgba(255, 140, 80, 0.15)';
        lossCtx.lineWidth = 4;
        lossCtx.stroke();
    }

    function update() {
        time += 0.016;
        updateTraining();

        // Batch normalization periodic sweep
        batchNormTimer += 0.016;
        if (batchNormTimer > 4.0) {
            batchNormTimer = 0;
            batchNormLayer = 1 + Math.floor(Math.random() * (ARCHS[currentArch].layers.length - 2));
            batchNormAlpha = 1.0;
        }
        if (batchNormAlpha > 0) batchNormAlpha -= 0.015;

        // Dropout re-roll periodically
        if (dropoutEnabled && Math.floor(time * 60) % 180 === 0) {
            applyDropout();
        }

        // Decay node activations
        for (const node of nodes) {
            node.activation *= 0.96;
            if (node.dropoutFlicker > 0) node.dropoutFlicker *= 0.98;
        }

        // Decay connection activity
        for (const conn of connections) {
            conn.activity *= 0.95;
        }
        for (const conn of recurrentConnections) {
            conn.activity *= 0.95;
        }

        // Update forward signals
        for (let i = signals.length - 1; i >= 0; i--) {
            const sig = signals[i];
            if (sig.delay > 0) { sig.delay -= 1; continue; }
            sig.active = true;
            sig.progress += sig.speed;

            const cx = sig.fromX + (sig.toX - sig.fromX) * sig.progress;
            const cy = sig.fromY + (sig.toY - sig.fromY) * sig.progress;
            sig.trail.push({ x: cx, y: cy, alpha: 1.0 });

            for (let t = sig.trail.length - 1; t >= 0; t--) {
                sig.trail[t].alpha -= 0.06;
                if (sig.trail[t].alpha <= 0) sig.trail.splice(t, 1);
            }

            if (sig.connIdx >= 0) {
                const conn = connections[sig.connIdx];
                if (conn) conn.activity = Math.max(conn.activity, 0.8);
            }

            if (Math.random() < 0.3) {
                particles.push({
                    x: cx + (Math.random() - 0.5) * 4,
                    y: cy + (Math.random() - 0.5) * 4,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    life: 0.6 + Math.random() * 0.4,
                    decay: 0.03 + Math.random() * 0.02,
                    size: 0.5 + Math.random() * 1.0,
                    color: sig.color
                });
            }

            if (sig.progress >= 1.0) {
                // Spark collision effect
                const tNode = nodes[sig.targetNode];
                if (tNode && tNode.activation > 0.3) {
                    spawnSparks(tNode.x, tNode.y);
                }
                activateNode(sig.targetNode);
                signals.splice(i, 1);
            }
        }

        // Update backprop signals
        for (let i = backSignals.length - 1; i >= 0; i--) {
            const sig = backSignals[i];
            if (sig.delay > 0) { sig.delay -= 1; continue; }
            sig.active = true;
            sig.progress += sig.speed;

            const cx = sig.fromX + (sig.toX - sig.fromX) * sig.progress;
            const cy = sig.fromY + (sig.toY - sig.fromY) * sig.progress;
            sig.trail.push({ x: cx, y: cy, alpha: 0.8 });

            for (let t = sig.trail.length - 1; t >= 0; t--) {
                sig.trail[t].alpha -= 0.05;
                if (sig.trail[t].alpha <= 0) sig.trail.splice(t, 1);
            }

            if (sig.progress >= 1.0) {
                // Continue backprop backward
                const node = nodes[sig.targetNode];
                if (node && node.layer > 0) {
                    const inc = connections.filter(c => c.to === sig.targetNode);
                    for (const conn of inc) {
                        if (Math.random() < 0.5) {
                            const fn = nodes[conn.to];
                            const tn = nodes[conn.from];
                            const dx = tn.x - fn.x;
                            const dy = tn.y - fn.y;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            backSignals.push({
                                fromX: fn.x, fromY: fn.y,
                                toX: tn.x, toY: tn.y,
                                progress: 0,
                                speed: SIGNAL_SPEED * 0.5 / dist,
                                targetNode: conn.from,
                                delay: Math.random() * 3,
                                active: false, trail: []
                            });
                        }
                    }
                }
                backSignals.splice(i, 1);
            }
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx; p.y += p.vy;
            p.vx *= 0.98; p.vy *= 0.98;
            p.life -= p.decay;
            if (p.life <= 0) particles.splice(i, 1);
        }

        // Update sparks
        for (let i = sparks.length - 1; i >= 0; i--) {
            const s = sparks[i];
            s.x += s.vx; s.y += s.vy;
            s.vy += 0.05; // gravity
            s.vx *= 0.97; s.vy *= 0.97;
            s.life -= s.decay;
            if (s.life <= 0) sparks.splice(i, 1);
        }

        // Auto-launch signals
        if (signals.length < 5 && Math.random() < 0.02) {
            launchSignalFromInput();
        }

        // Auto-launch backprop
        if (backpropEnabled && backSignals.length < 3 && Math.random() < 0.01) {
            launchBackpropSignal();
        }

        // Film grain refresh
        if (Math.floor(time * 60) % 4 === 0) {
            generateGrain();
        }
    }

    function drawConnection(conn) {
        const fromNode = nodes[conn.from];
        const toNode = nodes[conn.to];

        // Weight heatmap: thickness and brightness by weight magnitude
        const baseAlpha = 0.04 + conn.weight * 0.08;
        const activeAlpha = conn.activity * 0.6;
        const alpha = baseAlpha + activeAlpha;

        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        const midX = (fromNode.x + toNode.x) / 2;
        const midY = (fromNode.y + toNode.y) / 2;
        const offset = (fromNode.index - toNode.index) * 3;
        ctx.quadraticCurveTo(midX + offset, midY + offset * 0.5, toNode.x, toNode.y);

        // Weight heatmap coloring
        const weightHeat = conn.weight;
        const cr = Math.round(30 + weightHeat * 60);
        const cg = Math.round(60 + weightHeat * 40);
        const cb = Math.round(120 + weightHeat * 60);
        const lineWidth = 0.3 + conn.weight * 1.5 + conn.activity * 2;
        ctx.strokeStyle = `rgba(${cr}, ${cg}, ${cb}, ${alpha})`;
        ctx.lineWidth = lineWidth;
        ctx.stroke();

        if (conn.activity > 0.1) {
            ctx.strokeStyle = `rgba(${COLORS.signalTrail.r}, ${COLORS.signalTrail.g}, ${COLORS.signalTrail.b}, ${conn.activity * 0.15})`;
            ctx.lineWidth = lineWidth + 4;
            ctx.stroke();
        }
    }

    function drawRecurrentConnection(conn) {
        const fromNode = nodes[conn.from];
        const toNode = nodes[conn.to];

        if (conn.isAttention) {
            // Attention mechanism - varying thickness lines within same layer
            const pulse = Math.sin(time * 2 + conn.phase) * 0.3 + 0.7;
            const alpha = 0.08 + conn.weight * 0.2 * pulse + conn.activity * 0.4;
            const thickness = 0.5 + conn.weight * 3;

            ctx.beginPath();
            const midX = (fromNode.x + toNode.x) / 2;
            const midY = (fromNode.y + toNode.y) / 2;
            const offsetX = 0;
            const offsetY = -20 - Math.abs(fromNode.index - toNode.index) * 8;
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.quadraticCurveTo(midX + offsetX, midY + offsetY, toNode.x, toNode.y);
            ctx.strokeStyle = `rgba(${COLORS.attentionLine.r}, ${COLORS.attentionLine.g}, ${COLORS.attentionLine.b}, ${alpha})`;
            ctx.lineWidth = thickness;
            ctx.stroke();

            // Glow
            ctx.strokeStyle = `rgba(${COLORS.attentionLine.r}, ${COLORS.attentionLine.g}, ${COLORS.attentionLine.b}, ${alpha * 0.2})`;
            ctx.lineWidth = thickness + 4;
            ctx.stroke();
        } else {
            // Recurrent backward loop
            const pulse = Math.sin(time * 1.5 + conn.phase) * 0.2 + 0.8;
            const alpha = 0.06 * pulse + conn.activity * 0.3;

            ctx.beginPath();
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const cpx = (fromNode.x + toNode.x) / 2 + dy * 0.5;
            const cpy = (fromNode.y + toNode.y) / 2 - Math.abs(dx) * 0.3 - 30;
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.quadraticCurveTo(cpx, cpy, toNode.x, toNode.y);
            ctx.strokeStyle = `rgba(255, 140, 60, ${alpha})`;
            ctx.lineWidth = 0.8 + conn.weight * 1;
            ctx.setLineDash([4, 4]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Arrowhead
            const t = 0.85;
            const ax = (1-t)*(1-t)*fromNode.x + 2*(1-t)*t*cpx + t*t*toNode.x;
            const ay = (1-t)*(1-t)*fromNode.y + 2*(1-t)*t*cpy + t*t*toNode.y;
            const bx = (1-t-0.05)*(1-t-0.05)*fromNode.x + 2*(1-t-0.05)*(t+0.05)*cpx + (t+0.05)*(t+0.05)*toNode.x;
            const by = (1-t-0.05)*(1-t-0.05)*fromNode.y + 2*(1-t-0.05)*(t+0.05)*cpy + (t+0.05)*(t+0.05)*toNode.y;
            const ang = Math.atan2(by - ay, bx - ax);
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(ax - 6 * Math.cos(ang - 0.4), ay - 6 * Math.sin(ang - 0.4));
            ctx.moveTo(ax, ay);
            ctx.lineTo(ax - 6 * Math.cos(ang + 0.4), ay - 6 * Math.sin(ang + 0.4));
            ctx.strokeStyle = `rgba(255, 140, 60, ${alpha + 0.1})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    function drawNode(node, idx) {
        const x = node.x;
        const y = node.y;
        const baseR = node.radius;
        const pulse = Math.sin(time * 1.5 + node.pulsePhase) * 0.15 + 0.85;
        const r = baseR * pulse;
        const a = node.activation;

        // Dropout state
        if (node.droppedOut && dropoutEnabled) {
            // Dimmed dropped-out node
            const dimAlpha = 0.15 + Math.sin(time * 3) * 0.05;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${COLORS.nodeDropout.r}, ${COLORS.nodeDropout.g}, ${COLORS.nodeDropout.b}, ${dimAlpha})`;
            ctx.fill();
            // Cross mark
            ctx.beginPath();
            ctx.moveTo(x - r * 0.6, y - r * 0.6);
            ctx.lineTo(x + r * 0.6, y + r * 0.6);
            ctx.moveTo(x + r * 0.6, y - r * 0.6);
            ctx.lineTo(x - r * 0.6, y + r * 0.6);
            ctx.strokeStyle = `rgba(255, 80, 80, ${dimAlpha + 0.15})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            return;
        }

        // Batch norm glow sweep
        if (batchNormAlpha > 0 && node.layer === batchNormLayer) {
            const bnGlow = ctx.createRadialGradient(x, y, r, x, y, r + 25 * batchNormAlpha);
            bnGlow.addColorStop(0, `rgba(${COLORS.batchNorm.r}, ${COLORS.batchNorm.g}, ${COLORS.batchNorm.b}, ${batchNormAlpha * 0.4})`);
            bnGlow.addColorStop(1, `rgba(${COLORS.batchNorm.r}, ${COLORS.batchNorm.g}, ${COLORS.batchNorm.b}, 0)`);
            ctx.beginPath();
            ctx.arc(x, y, r + 25 * batchNormAlpha, 0, Math.PI * 2);
            ctx.fillStyle = bnGlow;
            ctx.fill();
        }

        // Outer glow
        const glowRadius = r + 12 + a * 20;
        const glowAlpha = 0.04 + a * 0.25;
        const glow = ctx.createRadialGradient(x, y, r, x, y, glowRadius);
        glow.addColorStop(0, `rgba(${COLORS.nodeGlow.r}, ${COLORS.nodeGlow.g}, ${COLORS.nodeGlow.b}, ${glowAlpha})`);
        glow.addColorStop(1, `rgba(${COLORS.nodeGlow.r}, ${COLORS.nodeGlow.g}, ${COLORS.nodeGlow.b}, 0)`);
        ctx.beginPath();
        ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
        ctx.fillStyle = glow;
        ctx.fill();

        // Activation function shape indicator
        const actFn = node.activationFn;
        const idleC = COLORS.nodeIdle;
        const actC = COLORS.nodeActive;
        const nr = Math.round(idleC.r + (actC.r - idleC.r) * a);
        const ng = Math.round(idleC.g + (actC.g - idleC.g) * a);
        const nb = Math.round(idleC.b + (actC.b - idleC.b) * a);

        ctx.beginPath();
        if (actFn === 'relu') {
            // Hexagonal shape for ReLU
            for (let i = 0; i < 6; i++) {
                const ang = (Math.PI * 2 * i) / 6 - Math.PI / 6;
                const px = x + r * Math.cos(ang);
                const py = y + r * Math.sin(ang);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        } else if (actFn === 'sigmoid') {
            // Diamond shape for sigmoid
            ctx.moveTo(x, y - r * 1.1);
            ctx.lineTo(x + r * 1.1, y);
            ctx.lineTo(x, y + r * 1.1);
            ctx.lineTo(x - r * 1.1, y);
            ctx.closePath();
        } else {
            // Circle for none/default
            ctx.arc(x, y, r, 0, Math.PI * 2);
        }

        const bodyGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
        bodyGrad.addColorStop(0, `rgba(${Math.min(255, nr + 60)}, ${Math.min(255, ng + 60)}, ${Math.min(255, nb + 60)}, ${0.8 + a * 0.2})`);
        bodyGrad.addColorStop(1, `rgba(${nr}, ${ng}, ${nb}, ${0.6 + a * 0.4})`);
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // Bright core on activation
        if (a > 0.1) {
            ctx.beginPath();
            ctx.arc(x, y, r * 0.4 * a, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${a * 0.8})`;
            ctx.fill();
        }

        // Ring matching activation shape
        ctx.beginPath();
        if (actFn === 'relu') {
            for (let i = 0; i < 6; i++) {
                const ang = (Math.PI * 2 * i) / 6 - Math.PI / 6;
                const px = x + (r + 1) * Math.cos(ang);
                const py = y + (r + 1) * Math.sin(ang);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        } else if (actFn === 'sigmoid') {
            ctx.moveTo(x, y - (r + 1) * 1.1);
            ctx.lineTo(x + (r + 1) * 1.1, y);
            ctx.lineTo(x, y + (r + 1) * 1.1);
            ctx.lineTo(x - (r + 1) * 1.1, y);
            ctx.closePath();
        } else {
            ctx.arc(x, y, r + 1, 0, Math.PI * 2);
        }
        ctx.strokeStyle = `rgba(${COLORS.nodeGlow.r}, ${COLORS.nodeGlow.g}, ${COLORS.nodeGlow.b}, ${0.15 + a * 0.5})`;
        ctx.lineWidth = 0.8 + a * 1.2;
        ctx.stroke();
    }

    function drawSignal(sig) {
        if (!sig.active) return;

        for (let i = 0; i < sig.trail.length; i++) {
            const t = sig.trail[i];
            const sz = 2.5 * t.alpha;
            ctx.beginPath();
            ctx.arc(t.x, t.y, sz, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${sig.color.r}, ${sig.color.g}, ${sig.color.b}, ${t.alpha * 0.5})`;
            ctx.fill();
        }

        const cx = sig.fromX + (sig.toX - sig.fromX) * sig.progress;
        const cy = sig.fromY + (sig.toY - sig.fromY) * sig.progress;

        const headGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 14);
        headGlow.addColorStop(0, `rgba(${COLORS.signalHead.r}, ${COLORS.signalHead.g}, ${COLORS.signalHead.b}, 0.7)`);
        headGlow.addColorStop(0.5, `rgba(${sig.color.r}, ${sig.color.g}, ${sig.color.b}, 0.2)`);
        headGlow.addColorStop(1, `rgba(${sig.color.r}, ${sig.color.g}, ${sig.color.b}, 0)`);
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.fillStyle = headGlow;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(cx, cy, 3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fill();
    }

    function drawBackSignal(sig) {
        if (!sig.active) return;

        for (let i = 0; i < sig.trail.length; i++) {
            const t = sig.trail[i];
            const sz = 2 * t.alpha;
            ctx.beginPath();
            ctx.arc(t.x, t.y, sz, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${COLORS.backpropTrail.r}, ${COLORS.backpropTrail.g}, ${COLORS.backpropTrail.b}, ${t.alpha * 0.4})`;
            ctx.fill();
        }

        const cx = sig.fromX + (sig.toX - sig.fromX) * sig.progress;
        const cy = sig.fromY + (sig.toY - sig.fromY) * sig.progress;

        const headGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 10);
        headGlow.addColorStop(0, `rgba(${COLORS.backpropHead.r}, ${COLORS.backpropHead.g}, ${COLORS.backpropHead.b}, 0.5)`);
        headGlow.addColorStop(1, `rgba(${COLORS.backpropHead.r}, ${COLORS.backpropHead.g}, ${COLORS.backpropHead.b}, 0)`);
        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, Math.PI * 2);
        ctx.fillStyle = headGlow;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(cx, cy, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
        ctx.fill();
    }

    function drawParticle(p) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.life * 0.6})`;
        ctx.fill();
    }

    function drawSpark(s) {
        // Sparks are brighter streaks
        const len = Math.sqrt(s.vx * s.vx + s.vy * s.vy) * 3;
        const ang = Math.atan2(s.vy, s.vx);
        ctx.beginPath();
        ctx.moveTo(s.x - Math.cos(ang) * len, s.y - Math.sin(ang) * len);
        ctx.lineTo(s.x, s.y);
        ctx.strokeStyle = `rgba(${s.color.r}, ${s.color.g}, ${s.color.b}, ${s.life * 0.9})`;
        ctx.lineWidth = s.size * s.life;
        ctx.stroke();

        // Bright tip
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size * s.life * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 240, ${s.life * 0.7})`;
        ctx.fill();
    }

    function drawLayerLabels() {
        const arch = ARCHS[currentArch];
        const labels = arch.labels;
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';

        const numLayers = arch.layers.length;
        const layerSpacing = W / (numLayers + 1);

        for (let l = 0; l < numLayers; l++) {
            const x = layerSpacing * (l + 1);
            const layerNodes = nodes.filter(n => n.layer === l);
            if (layerNodes.length === 0) continue;
            const topY = Math.min(...layerNodes.map(n => n.y));

            ctx.fillStyle = 'rgba(100, 200, 255, 0.2)';
            ctx.fillText(labels[l], x, topY - 25);

            // Show activation function below label
            const actLabel = arch.activations[l] === 'relu' ? 'ReLU' : arch.activations[l] === 'sigmoid' ? 'Sig' : '';
            if (actLabel) {
                ctx.fillStyle = 'rgba(100, 200, 255, 0.12)';
                ctx.font = '8px monospace';
                ctx.fillText(actLabel, x, topY - 14);
                ctx.font = '10px monospace';
            }
        }
    }

    function drawBackgroundGrid() {
        ctx.strokeStyle = 'rgba(40, 80, 140, 0.03)';
        ctx.lineWidth = 0.5;
        const spacing = 40;

        for (let x = 0; x < W; x += spacing) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, H);
            ctx.stroke();
        }
        for (let y = 0; y < H; y += spacing) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
    }

    function draw() {
        ctx.fillStyle = 'rgba(8, 12, 24, 0.25)';
        ctx.fillRect(0, 0, W, H);

        drawBackgroundGrid();

        // Draw forward connections
        for (const conn of connections) {
            drawConnection(conn);
        }

        // Draw recurrent / attention connections
        for (const conn of recurrentConnections) {
            drawRecurrentConnection(conn);
        }

        // Draw backprop signals
        for (const sig of backSignals) {
            drawBackSignal(sig);
        }

        // Draw forward signals
        for (const sig of signals) {
            drawSignal(sig);
        }

        // Draw particles
        for (const p of particles) {
            drawParticle(p);
        }

        // Draw sparks
        for (const s of sparks) {
            drawSpark(s);
        }

        // Draw nodes on top
        for (let i = 0; i < nodes.length; i++) {
            drawNode(nodes[i], i);
        }

        drawLayerLabels();

        // Batch norm label flash
        if (batchNormAlpha > 0.2 && batchNormLayer >= 0) {
            const arch = ARCHS[currentArch];
            const numLayers = arch.layers.length;
            const layerSpacing = W / (numLayers + 1);
            const x = layerSpacing * (batchNormLayer + 1);
            const layerNodes = nodes.filter(n => n.layer === batchNormLayer);
            if (layerNodes.length > 0) {
                const botY = Math.max(...layerNodes.map(n => n.y));
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(${COLORS.batchNorm.r}, ${COLORS.batchNorm.g}, ${COLORS.batchNorm.b}, ${batchNormAlpha * 0.6})`;
                ctx.fillText('BatchNorm', x, botY + 22);
            }
        }

        // Draw mini loss graph
        drawLossGraph();
    }

    function animate() {
        update();
        draw();
        animId = requestAnimationFrame(animate);
    }

    // Click to send pulse from specific nodes
    canvas.addEventListener('click', function(e) {
        // Find closest node (any layer)
        let closest = null;
        let minDist = Infinity;

        for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];
            const dx = e.clientX - n.x;
            const dy = e.clientY - n.y;
            const d = dx * dx + dy * dy;
            if (d < minDist) {
                minDist = d;
                closest = i;
            }
        }

        if (closest !== null && minDist < 2500) {
            // Clicked near a node - activate it directly
            activateNode(closest);
            spawnSparks(nodes[closest].x, nodes[closest].y);
        } else {
            // Clicked far from nodes - send from random input
            launchSignalFromInput();
        }

        spawnBurst(e.clientX, e.clientY, 10);
    });

    // Resize handler
    let resizeTimer;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(resize, 150);
    });

    // Expose reset for enhance.js
    window.reset = function() {
        cancelAnimationFrame(animId);
        time = 0;
        epoch = 0;
        trainLoss = 2.3026;
        trainAcc = 10.0;
        lossHistory = [];
        batchNormTimer = 0;
        batchNormLayer = -1;
        batchNormAlpha = 0;
        resize();
        ctx.fillStyle = 'rgba(8, 12, 24, 1)';
        ctx.fillRect(0, 0, W, H);
        setTimeout(function() {
            launchSignalFromInput();
            setTimeout(launchSignalFromInput, 400);
            setTimeout(launchSignalFromInput, 900);
        }, 100);
        animate();
    };

    // Initialize
    generateGrain();
    resize();
    ctx.fillStyle = 'rgba(8, 12, 24, 1)';
    ctx.fillRect(0, 0, W, H);
    launchSignalFromInput();
    setTimeout(launchSignalFromInput, 500);
    setTimeout(launchSignalFromInput, 1200);
    animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
