<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strange Attractors - Chaos in Multiple Dimensions</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #060810;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }

        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center, transparent 35%, rgba(0,0,0,0.7) 100%);
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.04) 2px,
                rgba(0,0,0,0.04) 4px
            );
        }

        .film-grain {
            position: fixed;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            pointer-events: none;
            z-index: 7;
            opacity: 0.035;
            animation: grainShift 0.5s steps(6) infinite;
        }
        @keyframes grainShift {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2%, -3%); }
            30% { transform: translate(3%, 2%); }
            50% { transform: translate(-1%, 4%); }
            70% { transform: translate(2%, -2%); }
            90% { transform: translate(-3%, 1%); }
        }

        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }

        .title-overlay {
            position: fixed;
            top: 1rem;
            right: 1.5rem;
            text-align: right;
            z-index: 20;
            pointer-events: none;
        }
        .title-overlay h1 {
            font-family: monospace;
            font-size: 1rem;
            font-weight: 400;
            color: rgba(100, 200, 255, 0.4);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        .title-overlay .subtitle {
            font-family: monospace;
            font-size: 0.65rem;
            color: rgba(100, 200, 255, 0.25);
            margin-top: 0.2rem;
        }

        .equations {
            position: fixed;
            top: 3.5rem;
            right: 1.5rem;
            font-family: monospace;
            font-size: 0.55rem;
            color: rgba(100, 200, 255, 0.2);
            z-index: 20;
            pointer-events: none;
            line-height: 1.6;
            text-align: right;
            transition: opacity 0.3s;
        }

        /* Attractor selector */
        .attractor-selector {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.3rem;
            z-index: 20;
        }
        .attractor-btn {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 200, 255, 0.15);
            color: rgba(100, 200, 255, 0.5);
            font-family: monospace;
            font-size: 0.6rem;
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .attractor-btn:hover {
            border-color: rgba(100, 200, 255, 0.4);
            color: rgba(100, 200, 255, 0.8);
        }
        .attractor-btn.active {
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(100, 200, 255, 0.5);
            color: rgba(100, 200, 255, 0.9);
        }

        /* Camera mode buttons */
        .camera-modes {
            position: fixed;
            top: 3rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.3rem;
            z-index: 20;
        }
        .cam-btn {
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(100, 200, 255, 0.1);
            color: rgba(100, 200, 255, 0.4);
            font-family: monospace;
            font-size: 0.55rem;
            padding: 0.25rem 0.5rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .cam-btn:hover {
            border-color: rgba(100, 200, 255, 0.3);
            color: rgba(100, 200, 255, 0.7);
        }
        .cam-btn.active {
            background: rgba(100, 200, 255, 0.1);
            border-color: rgba(100, 200, 255, 0.4);
            color: rgba(100, 200, 255, 0.8);
        }

        /* Parameter presets */
        .preset-row {
            position: fixed;
            top: 4.8rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.3rem;
            z-index: 20;
        }
        .preset-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 200, 100, 0.12);
            color: rgba(255, 200, 100, 0.4);
            font-family: monospace;
            font-size: 0.5rem;
            padding: 0.2rem 0.45rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .preset-btn:hover {
            border-color: rgba(255, 200, 100, 0.4);
            color: rgba(255, 200, 100, 0.8);
        }

        /* Stats panel */
        .stats-panel {
            position: fixed;
            bottom: 6rem;
            left: 1rem;
            z-index: 20;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 0.6rem 0.8rem;
            border-radius: 8px;
            border: 1px solid rgba(100, 200, 255, 0.08);
            font-family: monospace;
            font-size: 0.55rem;
            color: rgba(100, 200, 255, 0.45);
            line-height: 1.6;
            min-width: 160px;
        }
        .stats-panel .stat-label {
            color: rgba(100, 200, 255, 0.25);
        }
        .stats-panel .stat-val {
            color: rgba(100, 200, 255, 0.6);
        }

        /* Toggles row */
        .toggle-row {
            position: fixed;
            bottom: 4.2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.6rem;
            z-index: 20;
        }
        .toggle-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.1);
            color: rgba(100, 200, 255, 0.4);
            font-family: monospace;
            font-size: 0.55rem;
            padding: 0.25rem 0.5rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .toggle-btn:hover {
            border-color: rgba(100, 200, 255, 0.3);
        }
        .toggle-btn.on {
            background: rgba(100, 200, 255, 0.1);
            border-color: rgba(100, 200, 255, 0.35);
            color: rgba(100, 200, 255, 0.8);
        }

        /* Bottom controls */
        .controls {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.2rem;
            z-index: 20;
            background: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            padding: 0.7rem 1.2rem;
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.1);
        }
        .controls label {
            font-family: monospace;
            font-size: 0.6rem;
            color: rgba(100, 200, 255, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        .controls .param-value {
            color: rgba(100, 200, 255, 0.7);
            font-size: 0.65rem;
            min-width: 2.5em;
            text-align: center;
        }
        input[type="range"] {
            width: 80px;
            accent-color: #64c8ff;
            height: 3px;
        }

        .info {
            position: fixed;
            bottom: 0.4rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: monospace;
            font-size: 0.5rem;
            color: rgba(100, 200, 255, 0.2);
            z-index: 20;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Gallery</a>

    <div class="title-overlay">
        <h1 id="attractorTitle">Lorenz Attractor</h1>
        <div class="subtitle" id="attractorSubtitle">deterministic chaos &middot; sensitivity to initial conditions</div>
    </div>

    <div class="equations" id="equationsDiv">
        dx/dt = &sigma;(y - x)<br>
        dy/dt = x(&rho; - z) - y<br>
        dz/dt = xy - &beta;z
    </div>

    <canvas id="canvas"></canvas>
    <div class="vignette"></div>
    <div class="scanlines"></div>
    <div class="film-grain" id="filmGrain"></div>

    <!-- Attractor type selector -->
    <div class="attractor-selector" id="attractorSelector">
        <button class="attractor-btn active" data-type="lorenz">Lorenz</button>
        <button class="attractor-btn" data-type="rossler">R&ouml;ssler</button>
        <button class="attractor-btn" data-type="chen">Chen</button>
        <button class="attractor-btn" data-type="halvorsen">Halvorsen</button>
        <button class="attractor-btn" data-type="aizawa">Aizawa</button>
    </div>

    <!-- Camera modes -->
    <div class="camera-modes" id="cameraModes">
        <button class="cam-btn active" data-mode="orbit">Auto-Orbit</button>
        <button class="cam-btn" data-mode="follow">Follow Head</button>
        <button class="cam-btn" data-mode="free">Free Look</button>
        <button class="cam-btn" data-mode="stereo">Stereo 3D</button>
    </div>

    <!-- Parameter presets -->
    <div class="preset-row" id="presetRow"></div>

    <!-- Statistics panel -->
    <div class="stats-panel" id="statsPanel">
        <div><span class="stat-label">x:</span> <span class="stat-val" id="statX">0.000</span></div>
        <div><span class="stat-label">y:</span> <span class="stat-val" id="statY">0.000</span></div>
        <div><span class="stat-label">z:</span> <span class="stat-val" id="statZ">0.000</span></div>
        <div><span class="stat-label">speed:</span> <span class="stat-val" id="statSpeed">0.000</span></div>
        <div><span class="stat-label">&lambda; (Lyapunov):</span> <span class="stat-val" id="statLyap">---</span></div>
        <div><span class="stat-label">trajectories:</span> <span class="stat-val" id="statTrajs">12</span></div>
    </div>

    <!-- Toggle row -->
    <div class="toggle-row">
        <button class="toggle-btn on" id="toggleGrid" onclick="toggleGrid()">Grid</button>
        <button class="toggle-btn on" id="toggleGlow" onclick="toggleGlow()">Glow</button>
        <button class="toggle-btn" id="toggleParticles" onclick="toggleParticles()">Particles</button>
    </div>

    <!-- Param sliders -->
    <div class="controls" id="controlsPanel">
        <label id="paramALabel">P1
            <input type="range" id="paramASlider" min="0" max="50" step="0.1" value="10">
            <span class="param-value" id="paramAVal">10.0</span>
        </label>
        <label id="paramBLabel">P2
            <input type="range" id="paramBSlider" min="0" max="80" step="0.1" value="28">
            <span class="param-value" id="paramBVal">28.0</span>
        </label>
        <label id="paramCLabel">P3
            <input type="range" id="paramCSlider" min="0" max="15" step="0.01" value="2.67">
            <span class="param-value" id="paramCVal">2.67</span>
        </label>
    </div>

    <div class="info">drag to rotate &middot; scroll to zoom &middot; Space pause &middot; R reset &middot; 1-5 attractors</div>

    <script>
    (function() {
        'use strict';

        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');

        // --- Film grain noise ---
        (function initGrain() {
            var gc = document.createElement('canvas');
            gc.width = 256; gc.height = 256;
            var gctx = gc.getContext('2d');
            var img = gctx.createImageData(256, 256);
            for (var i = 0; i < img.data.length; i += 4) {
                var v = Math.random() * 255;
                img.data[i] = v; img.data[i+1] = v; img.data[i+2] = v; img.data[i+3] = 255;
            }
            gctx.putImageData(img, 0, 0);
            document.getElementById('filmGrain').style.backgroundImage = 'url(' + gc.toDataURL() + ')';
        })();

        // ========================================
        // ATTRACTOR DEFINITIONS
        // ========================================
        var ATTRACTORS = {
            lorenz: {
                name: 'Lorenz Attractor',
                subtitle: 'deterministic chaos \u00b7 sensitivity to initial conditions',
                equations: 'dx/dt = \u03c3(y - x)<br>dy/dt = x(\u03c1 - z) - y<br>dz/dt = xy - \u03b2z',
                defaults: { a: 10, b: 28, c: 8/3 },
                labels: ['\u03c3 (Prandtl)', '\u03c1 (Rayleigh)', '\u03b2 (Geometry)'],
                ranges: [[1,50,0.1], [0.1,80,0.1], [0.1,15,0.01]],
                center: function(p) { return [0, 0, p.b - 1]; },
                scale: 1.0,
                camDist: 80,
                deriv: function(x, y, z, p) {
                    return { dx: p.a*(y-x), dy: x*(p.b-z)-y, dz: x*y - p.c*z };
                },
                presets: [
                    { name: 'Classic', a: 10, b: 28, c: 8/3 },
                    { name: 'Chaotic', a: 14, b: 45, c: 2.5 },
                    { name: 'Periodic', a: 10, b: 13, c: 8/3 },
                    { name: 'Transient', a: 10, b: 24.74, c: 8/3 }
                ]
            },
            rossler: {
                name: 'R\u00f6ssler Attractor',
                subtitle: 'spiral chaos \u00b7 period-doubling route',
                equations: 'dx/dt = -(y + z)<br>dy/dt = x + ay<br>dz/dt = b + z(x - c)',
                defaults: { a: 0.2, b: 0.2, c: 5.7 },
                labels: ['a', 'b', 'c'],
                ranges: [[0.01,1,0.01], [0.01,1,0.01], [1,20,0.1]],
                center: function() { return [0, 0, 2]; },
                scale: 2.5,
                camDist: 60,
                deriv: function(x, y, z, p) {
                    return { dx: -(y+z), dy: x + p.a*y, dz: p.b + z*(x - p.c) };
                },
                presets: [
                    { name: 'Classic', a: 0.2, b: 0.2, c: 5.7 },
                    { name: 'Funnel', a: 0.2, b: 0.2, c: 9.0 },
                    { name: 'Screw', a: 0.38, b: 0.3, c: 4.82 },
                    { name: 'Spiral', a: 0.1, b: 0.1, c: 14 }
                ]
            },
            chen: {
                name: 'Chen Attractor',
                subtitle: 'dual-scroll \u00b7 anti-control of chaos',
                equations: 'dx/dt = a(y - x)<br>dy/dt = (c - a)x - xz + cy<br>dz/dt = xy - bz',
                defaults: { a: 35, b: 3, c: 28 },
                labels: ['a', 'b', 'c'],
                ranges: [[20,50,0.5], [0.5,10,0.1], [15,40,0.5]],
                center: function() { return [0, 0, 30]; },
                scale: 0.7,
                camDist: 80,
                deriv: function(x, y, z, p) {
                    return { dx: p.a*(y-x), dy: (p.c-p.a)*x - x*z + p.c*y, dz: x*y - p.b*z };
                },
                presets: [
                    { name: 'Classic', a: 35, b: 3, c: 28 },
                    { name: 'Tight', a: 40, b: 5, c: 25 },
                    { name: 'Wide', a: 30, b: 2, c: 32 }
                ]
            },
            halvorsen: {
                name: 'Halvorsen Attractor',
                subtitle: 'three-fold symmetry \u00b7 cyclic attractor',
                equations: 'dx/dt = -ax - 4y - 4z - y\u00b2<br>dy/dt = -ay - 4z - 4x - z\u00b2<br>dz/dt = -az - 4x - 4y - x\u00b2',
                defaults: { a: 1.89, b: 0, c: 0 },
                labels: ['a', '--', '--'],
                ranges: [[1,3,0.01], [0,1,0.1], [0,1,0.1]],
                center: function() { return [0, 0, 0]; },
                scale: 2.5,
                camDist: 50,
                deriv: function(x, y, z, p) {
                    return {
                        dx: -p.a*x - 4*y - 4*z - y*y,
                        dy: -p.a*y - 4*z - 4*x - z*z,
                        dz: -p.a*z - 4*x - 4*y - x*x
                    };
                },
                presets: [
                    { name: 'Classic', a: 1.89, b: 0, c: 0 },
                    { name: 'Tight', a: 1.4, b: 0, c: 0 },
                    { name: 'Loose', a: 2.2, b: 0, c: 0 }
                ]
            },
            aizawa: {
                name: 'Aizawa Attractor',
                subtitle: 'toroidal chaos \u00b7 mushroom-like structure',
                equations: 'dx/dt = (z-b)x - dy<br>dy/dt = dx + (z-b)y<br>dz/dt = c + az - z\u00b3/3 - (x\u00b2+y\u00b2)(1+ez) + fzx\u00b3',
                defaults: { a: 0.95, b: 0.7, c: 0.6 },
                labels: ['a', 'b', 'c'],
                ranges: [[0.1,2,0.01], [0.1,2,0.01], [0.1,2,0.01]],
                center: function() { return [0, 0, 0]; },
                scale: 12,
                camDist: 35,
                deriv: function(x, y, z, p) {
                    var d = 3.5, e = 0.25, f = 0.1;
                    return {
                        dx: (z - p.b)*x - d*y,
                        dy: d*x + (z - p.b)*y,
                        dz: p.c + p.a*z - z*z*z/3 - (x*x + y*y)*(1 + e*z) + f*z*x*x*x
                    };
                },
                presets: [
                    { name: 'Classic', a: 0.95, b: 0.7, c: 0.6 },
                    { name: 'Wide', a: 0.95, b: 0.5, c: 0.65 },
                    { name: 'Tight', a: 0.81, b: 0.89, c: 0.5 }
                ]
            }
        };

        // ========================================
        // STATE
        // ========================================
        var currentType = 'lorenz';
        var params = { a: 10, b: 28, c: 8/3 };

        var NUM_TRAJECTORIES = 12;
        var MAX_TRAIL = 2500;
        var DT = 0.005;
        var STEPS_PER_FRAME = 5;

        var trajectories = [];
        var particles = [];
        var paused = false;
        var time = 0;
        var frameCount = 0;

        // Camera
        var camRotX = -0.35;
        var camRotY = 0.0;
        var camDist = 80;
        var cameraMode = 'orbit'; // orbit, follow, free, stereo
        var isDragging = false;
        var lastMX = 0, lastMY = 0;

        // Toggles
        var showGrid = true;
        var showGlow = true;
        var showParticles = false;

        // Lyapunov estimation
        var lyapSum = 0;
        var lyapCount = 0;
        var lyapRef = null;

        // ========================================
        // CANVAS SETUP
        // ========================================
        var W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // ========================================
        // UI WIRING
        // ========================================
        var paramASlider = document.getElementById('paramASlider');
        var paramBSlider = document.getElementById('paramBSlider');
        var paramCSlider = document.getElementById('paramCSlider');
        var paramAVal = document.getElementById('paramAVal');
        var paramBVal = document.getElementById('paramBVal');
        var paramCVal = document.getElementById('paramCVal');

        paramASlider.addEventListener('input', function() {
            params.a = parseFloat(this.value);
            paramAVal.textContent = params.a.toFixed(2);
        });
        paramBSlider.addEventListener('input', function() {
            params.b = parseFloat(this.value);
            paramBVal.textContent = params.b.toFixed(2);
        });
        paramCSlider.addEventListener('input', function() {
            params.c = parseFloat(this.value);
            paramCVal.textContent = params.c.toFixed(2);
        });

        // Attractor selector buttons
        var attractorBtns = document.querySelectorAll('.attractor-btn');
        for (var i = 0; i < attractorBtns.length; i++) {
            attractorBtns[i].addEventListener('click', function() {
                switchAttractor(this.getAttribute('data-type'));
            });
        }

        // Camera mode buttons
        var camBtns = document.querySelectorAll('.cam-btn');
        for (var i = 0; i < camBtns.length; i++) {
            camBtns[i].addEventListener('click', function() {
                var mode = this.getAttribute('data-mode');
                if (mode === 'stereo') {
                    stereoEnabled = !stereoEnabled;
                    this.classList.toggle('active', stereoEnabled);
                } else {
                    cameraMode = mode;
                    for (var j = 0; j < camBtns.length; j++) {
                        if (camBtns[j].getAttribute('data-mode') !== 'stereo') {
                            camBtns[j].classList.remove('active');
                        }
                    }
                    this.classList.add('active');
                }
            });
        }

        var stereoEnabled = false;

        // ========================================
        // TOGGLE FUNCTIONS (global scope for onclick)
        // ========================================
        window.toggleGrid = function() {
            showGrid = !showGrid;
            document.getElementById('toggleGrid').classList.toggle('on', showGrid);
        };
        window.toggleGlow = function() {
            showGlow = !showGlow;
            document.getElementById('toggleGlow').classList.toggle('on', showGlow);
        };
        window.toggleParticles = function() {
            showParticles = !showParticles;
            document.getElementById('toggleParticles').classList.toggle('on', showParticles);
        };

        // ========================================
        // SWITCH ATTRACTOR
        // ========================================
        function switchAttractor(type) {
            currentType = type;
            var def = ATTRACTORS[type];

            // Update UI
            document.getElementById('attractorTitle').textContent = def.name;
            document.getElementById('attractorSubtitle').innerHTML = def.subtitle;
            document.getElementById('equationsDiv').innerHTML = def.equations;

            // Update selector buttons
            for (var i = 0; i < attractorBtns.length; i++) {
                attractorBtns[i].classList.toggle('active', attractorBtns[i].getAttribute('data-type') === type);
            }

            // Set params
            params.a = def.defaults.a;
            params.b = def.defaults.b;
            params.c = def.defaults.c;

            // Update sliders
            var ranges = def.ranges;
            paramASlider.min = ranges[0][0]; paramASlider.max = ranges[0][1]; paramASlider.step = ranges[0][2];
            paramBSlider.min = ranges[1][0]; paramBSlider.max = ranges[1][1]; paramBSlider.step = ranges[1][2];
            paramCSlider.min = ranges[2][0]; paramCSlider.max = ranges[2][1]; paramCSlider.step = ranges[2][2];

            paramASlider.value = params.a;
            paramBSlider.value = params.b;
            paramCSlider.value = params.c;

            paramAVal.textContent = params.a.toFixed(2);
            paramBVal.textContent = params.b.toFixed(2);
            paramCVal.textContent = params.c.toFixed(2);

            document.getElementById('paramALabel').childNodes[0].textContent = def.labels[0] + ' ';
            document.getElementById('paramBLabel').childNodes[0].textContent = def.labels[1] + ' ';
            document.getElementById('paramCLabel').childNodes[0].textContent = def.labels[2] + ' ';

            // Update presets
            buildPresets(def.presets);

            camDist = def.camDist;

            // Reset trajectories
            initTrajectories();
            lyapSum = 0; lyapCount = 0; lyapRef = null;
            ctx.clearRect(0, 0, W, H);
        }

        function buildPresets(presets) {
            var row = document.getElementById('presetRow');
            row.innerHTML = '';
            for (var i = 0; i < presets.length; i++) {
                var btn = document.createElement('button');
                btn.className = 'preset-btn';
                btn.textContent = presets[i].name;
                btn.setAttribute('data-idx', i);
                btn.addEventListener('click', (function(p) {
                    return function() {
                        params.a = p.a; params.b = p.b; params.c = p.c;
                        paramASlider.value = p.a; paramBSlider.value = p.b; paramCSlider.value = p.c;
                        paramAVal.textContent = p.a.toFixed(2);
                        paramBVal.textContent = p.b.toFixed(2);
                        paramCVal.textContent = p.c.toFixed(2);
                        initTrajectories();
                        lyapSum = 0; lyapCount = 0; lyapRef = null;
                        ctx.clearRect(0, 0, W, H);
                    };
                })(presets[i]));
                row.appendChild(btn);
            }
        }

        // ========================================
        // MOUSE / TOUCH INTERACTION
        // ========================================
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMX = e.clientX;
            lastMY = e.clientY;
        });
        window.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            if (cameraMode === 'orbit') cameraMode = 'free';
            camRotY += (e.clientX - lastMX) * 0.005;
            camRotX += (e.clientY - lastMY) * 0.005;
            camRotX = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, camRotX));
            lastMX = e.clientX;
            lastMY = e.clientY;
        });
        window.addEventListener('mouseup', function() { isDragging = false; });

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            camDist += e.deltaY * 0.05;
            camDist = Math.max(10, Math.min(300, camDist));
        }, { passive: false });

        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMX = e.touches[0].clientX;
                lastMY = e.touches[0].clientY;
            }
        }, { passive: true });
        canvas.addEventListener('touchmove', function(e) {
            if (!isDragging || e.touches.length !== 1) return;
            if (cameraMode === 'orbit') cameraMode = 'free';
            camRotY += (e.touches[0].clientX - lastMX) * 0.005;
            camRotX += (e.touches[0].clientY - lastMY) * 0.005;
            camRotX = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, camRotX));
            lastMX = e.touches[0].clientX;
            lastMY = e.touches[0].clientY;
        }, { passive: true });
        canvas.addEventListener('touchend', function() { isDragging = false; }, { passive: true });

        // ========================================
        // 3D PROJECTION
        // ========================================
        function project(x, y, z, eyeOffset) {
            var def = ATTRACTORS[currentType];
            var cen = def.center(params);
            var sc = def.scale;

            var cx = (x - cen[0]) * sc;
            var cy = (y - cen[1]) * sc;
            var cz = (z - cen[2]) * sc;

            // Rotate Y
            var cosY = Math.cos(camRotY), sinY = Math.sin(camRotY);
            var tx = cx * cosY - cz * sinY;
            var tz = cx * sinY + cz * cosY;
            cx = tx; cz = tz;

            // Rotate X
            var cosX = Math.cos(camRotX), sinX = Math.sin(camRotX);
            var ty = cy * cosX - cz * sinX;
            tz = cy * sinX + cz * cosX;
            cy = ty; cz = tz;

            // Stereo eye offset
            if (eyeOffset) cx += eyeOffset;

            // Perspective
            var fov = 600;
            var depth = cz + camDist;
            if (depth < 1) depth = 1;
            var scale = fov / depth;

            return {
                x: W/2 + cx * scale,
                y: H/2 - cy * scale,
                scale: scale,
                depth: depth
            };
        }

        // ========================================
        // RK4 INTEGRATION
        // ========================================
        function rk4Step(x, y, z, dt) {
            var deriv = ATTRACTORS[currentType].deriv;
            var k1 = deriv(x, y, z, params);
            var k2 = deriv(x + k1.dx*dt*0.5, y + k1.dy*dt*0.5, z + k1.dz*dt*0.5, params);
            var k3 = deriv(x + k2.dx*dt*0.5, y + k2.dy*dt*0.5, z + k2.dz*dt*0.5, params);
            var k4 = deriv(x + k3.dx*dt, y + k3.dy*dt, z + k3.dz*dt, params);
            return {
                x: x + (k1.dx + 2*k2.dx + 2*k3.dx + k4.dx) * dt / 6,
                y: y + (k1.dy + 2*k2.dy + 2*k3.dy + k4.dy) * dt / 6,
                z: z + (k1.dz + 2*k2.dz + 2*k3.dz + k4.dz) * dt / 6
            };
        }

        // ========================================
        // TRAJECTORIES
        // ========================================
        function initTrajectories() {
            trajectories = [];
            for (var i = 0; i < NUM_TRAJECTORIES; i++) {
                var offset = (i - NUM_TRAJECTORIES/2) * 0.005;
                var def = ATTRACTORS[currentType];
                var cx = def.center(params);
                trajectories.push({
                    x: cx[0] + 1 + offset,
                    y: cx[1] + 1 + offset * 0.7,
                    z: cx[2] + 1 + offset * 0.3,
                    trail: [],
                    hueBase: (i / NUM_TRAJECTORIES) * 360
                });
            }
            // Lyapunov reference trajectory
            if (trajectories.length > 0) {
                var t0 = trajectories[0];
                lyapRef = { x: t0.x + 1e-8, y: t0.y, z: t0.z };
            }
            particles = [];
        }
        initTrajectories();

        // ========================================
        // VELOCITY COLOR MAPPING
        // ========================================
        function velocityColor(speed, maxSpeed, alpha) {
            // blue=slow -> cyan -> green -> yellow -> red=fast
            var t = Math.min(speed / maxSpeed, 1);
            var hue = 240 - t * 240; // 240 (blue) -> 0 (red)
            var sat = 85 + t * 15;
            var lit = 40 + t * 25;
            return 'hsla(' + hue + ',' + sat + '%,' + lit + '%,' + alpha + ')';
        }

        // ========================================
        // PARTICLES
        // ========================================
        function spawnParticles(x, y, z, speed) {
            if (!showParticles) return;
            // Spawn in certain regions (near origin or high curvature)
            var distFromCenter = Math.sqrt(x*x + y*y);
            if (distFromCenter < 3 || speed > 30) {
                for (var i = 0; i < 2; i++) {
                    particles.push({
                        x: x, y: y, z: z,
                        vx: (Math.random()-0.5)*2,
                        vy: (Math.random()-0.5)*2,
                        vz: (Math.random()-0.5)*2,
                        life: 1.0,
                        decay: 0.015 + Math.random()*0.02,
                        speed: speed
                    });
                }
            }
        }

        function updateParticles() {
            for (var i = particles.length - 1; i >= 0; i--) {
                var p = particles[i];
                p.x += p.vx * 0.3;
                p.y += p.vy * 0.3;
                p.z += p.vz * 0.3;
                p.life -= p.decay;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            // Cap particles
            if (particles.length > 500) {
                particles = particles.slice(particles.length - 500);
            }
        }

        // ========================================
        // 3D GRID
        // ========================================
        function drawGrid(eyeOffset) {
            if (!showGrid) return;
            var def = ATTRACTORS[currentType];
            var sc = def.scale;
            var gridSize = 30 / sc;
            var gridStep = 10 / sc;

            ctx.lineWidth = 0.5;

            // Draw grid lines in XZ plane at y=center
            var cen = def.center(params);
            for (var i = -gridSize; i <= gridSize; i += gridStep) {
                // Lines along X
                var p0 = project(cen[0] + i, cen[1] - 15/sc, cen[2] - gridSize, eyeOffset);
                var p1 = project(cen[0] + i, cen[1] - 15/sc, cen[2] + gridSize, eyeOffset);
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.04)';
                ctx.stroke();

                // Lines along Z
                p0 = project(cen[0] - gridSize, cen[1] - 15/sc, cen[2] + i, eyeOffset);
                p1 = project(cen[0] + gridSize, cen[1] - 15/sc, cen[2] + i, eyeOffset);
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.04)';
                ctx.stroke();
            }

            // Axis lines
            var axisLen = 15 / sc;
            var origin = project(cen[0], cen[1], cen[2], eyeOffset);
            var axes = [
                { end: project(cen[0] + axisLen, cen[1], cen[2], eyeOffset), color: 'rgba(255,100,100,0.12)' },
                { end: project(cen[0], cen[1] + axisLen, cen[2], eyeOffset), color: 'rgba(100,255,100,0.12)' },
                { end: project(cen[0], cen[1], cen[2] + axisLen, eyeOffset), color: 'rgba(100,100,255,0.12)' }
            ];
            for (var j = 0; j < axes.length; j++) {
                ctx.beginPath();
                ctx.moveTo(origin.x, origin.y);
                ctx.lineTo(axes[j].end.x, axes[j].end.y);
                ctx.strokeStyle = axes[j].color;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // ========================================
        // RENDER SCENE
        // ========================================
        function renderScene(eyeOffset, tintColor) {
            // Draw grid behind
            drawGrid(eyeOffset);

            // Compute max speed for color normalization
            var maxSpeed = 1;
            for (var t = 0; t < NUM_TRAJECTORIES; t++) {
                var trail = trajectories[t].trail;
                if (trail.length > 1) {
                    var last = trail[trail.length - 1];
                    var prev = trail[trail.length - 2];
                    var spd = Math.sqrt(
                        (last.x-prev.x)*(last.x-prev.x) +
                        (last.y-prev.y)*(last.y-prev.y) +
                        (last.z-prev.z)*(last.z-prev.z)
                    ) / DT;
                    if (spd > maxSpeed) maxSpeed = spd;
                }
            }

            // Draw trails
            for (var t = 0; t < NUM_TRAJECTORIES; t++) {
                var traj = trajectories[t];
                var trail = traj.trail;
                if (trail.length < 2) continue;

                var len = trail.length;
                // Draw every Nth segment for performance
                var step = len > 1500 ? 2 : 1;

                for (var i = step; i < len; i += step) {
                    var progress = i / len;
                    var alpha = progress * progress * 0.7;
                    if (alpha < 0.01) continue;

                    var p0 = project(trail[i-step].x, trail[i-step].y, trail[i-step].z, eyeOffset);
                    var p1 = project(trail[i].x, trail[i].y, trail[i].z, eyeOffset);

                    // Depth-based line width: thicker when closer
                    var depthFactor = Math.min(p1.scale / 8, 3);
                    var lineWidth = Math.max(0.2, progress * 2.0 * depthFactor);

                    // Speed for this segment
                    var segSpeed = Math.sqrt(
                        (trail[i].x - trail[i-step].x)*(trail[i].x - trail[i-step].x) +
                        (trail[i].y - trail[i-step].y)*(trail[i].y - trail[i-step].y) +
                        (trail[i].z - trail[i-step].z)*(trail[i].z - trail[i-step].z)
                    ) / (DT * step);

                    ctx.beginPath();
                    ctx.moveTo(p0.x, p0.y);
                    ctx.lineTo(p1.x, p1.y);

                    if (tintColor) {
                        // Stereo: use tint color with alpha
                        ctx.strokeStyle = tintColor.replace('ALPHA', alpha.toFixed(3));
                    } else {
                        ctx.strokeStyle = velocityColor(segSpeed, maxSpeed * 0.8, alpha);
                    }
                    ctx.lineWidth = lineWidth;
                    ctx.stroke();
                }

                // Draw glowing head
                if (trail.length > 0 && showGlow) {
                    var head = trail[trail.length - 1];
                    var ph = project(head.x, head.y, head.z, eyeOffset);
                    var headRadius = Math.max(2, Math.min(ph.scale / 5, 7));

                    var headSpeed = 0;
                    if (trail.length > 1) {
                        var prev = trail[trail.length - 2];
                        headSpeed = Math.sqrt(
                            (head.x-prev.x)*(head.x-prev.x) +
                            (head.y-prev.y)*(head.y-prev.y) +
                            (head.z-prev.z)*(head.z-prev.z)
                        ) / DT;
                    }

                    var headCol = tintColor ? tintColor.replace('ALPHA', '0.8') : velocityColor(headSpeed, maxSpeed * 0.8, 1);

                    // Outer glow
                    var grd = ctx.createRadialGradient(ph.x, ph.y, 0, ph.x, ph.y, headRadius * 5);
                    grd.addColorStop(0, tintColor ? tintColor.replace('ALPHA', '0.5') : velocityColor(headSpeed, maxSpeed * 0.8, 0.5));
                    grd.addColorStop(0.3, tintColor ? tintColor.replace('ALPHA', '0.15') : velocityColor(headSpeed, maxSpeed * 0.8, 0.15));
                    grd.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.beginPath();
                    ctx.arc(ph.x, ph.y, headRadius * 5, 0, Math.PI * 2);
                    ctx.fillStyle = grd;
                    ctx.fill();

                    // Core
                    ctx.beginPath();
                    ctx.arc(ph.x, ph.y, headRadius, 0, Math.PI * 2);
                    ctx.fillStyle = headCol;
                    ctx.fill();

                    // White center
                    ctx.beginPath();
                    ctx.arc(ph.x, ph.y, headRadius * 0.35, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.fill();
                }
            }

            // Draw particles
            if (showParticles) {
                for (var i = 0; i < particles.length; i++) {
                    var part = particles[i];
                    var pp = project(part.x, part.y, part.z, eyeOffset);
                    var pr = Math.max(0.5, Math.min(pp.scale / 15, 2.5));
                    var pa = part.life * 0.6;

                    ctx.beginPath();
                    ctx.arc(pp.x, pp.y, pr, 0, Math.PI * 2);
                    if (tintColor) {
                        ctx.fillStyle = tintColor.replace('ALPHA', pa.toFixed(3));
                    } else {
                        ctx.fillStyle = velocityColor(part.speed, maxSpeed * 0.8, pa);
                    }
                    ctx.fill();
                }
            }
        }

        // ========================================
        // LYAPUNOV ESTIMATION
        // ========================================
        function updateLyapunov() {
            if (!lyapRef || trajectories.length === 0) return;

            var t0 = trajectories[0];
            var newRef = rk4Step(lyapRef.x, lyapRef.y, lyapRef.z, DT);

            var dx = t0.x - newRef.x;
            var dy = t0.y - newRef.y;
            var dz = t0.z - newRef.z;
            var dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist > 0 && dist < 100) {
                lyapSum += Math.log(dist / 1e-8);
                lyapCount++;

                // Renormalize
                var scale = 1e-8 / dist;
                lyapRef.x = t0.x - dx * scale;
                lyapRef.y = t0.y - dy * scale;
                lyapRef.z = t0.z - dz * scale;
            } else {
                lyapRef.x = t0.x + 1e-8;
                lyapRef.y = t0.y;
                lyapRef.z = t0.z;
            }
        }

        // ========================================
        // STATS UPDATE
        // ========================================
        function updateStats() {
            if (trajectories.length === 0 || trajectories[0].trail.length === 0) return;

            var t0 = trajectories[0];
            var head = t0.trail[t0.trail.length - 1];

            document.getElementById('statX').textContent = head.x.toFixed(3);
            document.getElementById('statY').textContent = head.y.toFixed(3);
            document.getElementById('statZ').textContent = head.z.toFixed(3);

            if (t0.trail.length > 1) {
                var prev = t0.trail[t0.trail.length - 2];
                var speed = Math.sqrt(
                    (head.x-prev.x)*(head.x-prev.x) +
                    (head.y-prev.y)*(head.y-prev.y) +
                    (head.z-prev.z)*(head.z-prev.z)
                ) / DT;
                document.getElementById('statSpeed').textContent = speed.toFixed(1);
            }

            if (lyapCount > 100) {
                var lyap = lyapSum / (lyapCount * DT);
                document.getElementById('statLyap').textContent = lyap.toFixed(3);
            }

            document.getElementById('statTrajs').textContent = NUM_TRAJECTORIES;
        }

        // ========================================
        // MAIN ANIMATION LOOP
        // ========================================
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            frameCount++;

            // Camera modes
            if (cameraMode === 'orbit') {
                camRotY += 0.003;
            } else if (cameraMode === 'follow' && trajectories.length > 0 && trajectories[0].trail.length > 0) {
                var head = trajectories[0].trail[trajectories[0].trail.length - 1];
                var def = ATTRACTORS[currentType];
                var cen = def.center(params);
                var targetY = Math.atan2(head.x - cen[0], head.z - cen[2]);
                camRotY += (targetY - camRotY) * 0.02;
            }

            // Step simulation
            if (!paused) {
                for (var t = 0; t < NUM_TRAJECTORIES; t++) {
                    var traj = trajectories[t];
                    for (var s = 0; s < STEPS_PER_FRAME; s++) {
                        var next = rk4Step(traj.x, traj.y, traj.z, DT);

                        if (isNaN(next.x) || isNaN(next.y) || isNaN(next.z) ||
                            Math.abs(next.x) > 1000 || Math.abs(next.y) > 1000 || Math.abs(next.z) > 1000) {
                            var def = ATTRACTORS[currentType];
                            var cen = def.center(params);
                            traj.x = cen[0] + 1 + t * 0.005;
                            traj.y = cen[1] + 1;
                            traj.z = cen[2] + 1;
                            traj.trail = [];
                            break;
                        }

                        var speed = Math.sqrt(
                            (next.x-traj.x)*(next.x-traj.x) +
                            (next.y-traj.y)*(next.y-traj.y) +
                            (next.z-traj.z)*(next.z-traj.z)
                        ) / DT;

                        traj.x = next.x;
                        traj.y = next.y;
                        traj.z = next.z;
                        traj.trail.push({ x: next.x, y: next.y, z: next.z, speed: speed });

                        // Particle bursts
                        if (t === 0 && s === 0) {
                            spawnParticles(next.x, next.y, next.z, speed);
                        }
                    }

                    if (traj.trail.length > MAX_TRAIL) {
                        traj.trail = traj.trail.slice(traj.trail.length - MAX_TRAIL);
                    }
                }

                // Update Lyapunov
                updateLyapunov();

                // Update particles
                updateParticles();
            }

            // --- DRAW ---
            if (stereoEnabled) {
                // Anaglyph stereoscopic rendering
                ctx.fillStyle = 'rgba(6, 8, 16, 0.15)';
                ctx.fillRect(0, 0, W, H);

                var eyeSep = 1.5;

                // Left eye (red channel)
                ctx.globalCompositeOperation = 'lighter';
                renderScene(-eyeSep, 'rgba(255,0,0,ALPHA)');

                // Right eye (cyan channel)
                renderScene(eyeSep, 'rgba(0,255,255,ALPHA)');

                ctx.globalCompositeOperation = 'source-over';
            } else {
                // Normal rendering with trail fade
                ctx.fillStyle = 'rgba(6, 8, 16, 0.12)';
                ctx.fillRect(0, 0, W, H);

                renderScene(0, null);
            }

            // Update stats periodically
            if (frameCount % 10 === 0) {
                updateStats();
            }
        }

        animate();

        // ========================================
        // RESET
        // ========================================
        function reset() {
            paused = false;
            cameraMode = 'orbit';
            stereoEnabled = false;
            camRotX = -0.35;
            camRotY = 0.0;
            switchAttractor('lorenz');

            // Reset camera button states
            for (var j = 0; j < camBtns.length; j++) {
                camBtns[j].classList.remove('active');
                if (camBtns[j].getAttribute('data-mode') === 'orbit') {
                    camBtns[j].classList.add('active');
                }
            }

            ctx.clearRect(0, 0, W, H);
        }
        window.reset = reset;

        // ========================================
        // KEYBOARD
        // ========================================
        window.addEventListener('keydown', function(e) {
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                paused = !paused;
            }
            if (e.key === 'r' || e.key === 'R') {
                reset();
            }
            if (e.key === 'a' || e.key === 'A') {
                cameraMode = cameraMode === 'orbit' ? 'free' : 'orbit';
            }
            if (e.key === 'g' || e.key === 'G') {
                window.toggleGrid();
            }
            // Number keys 1-5 switch attractors
            var types = ['lorenz', 'rossler', 'chen', 'halvorsen', 'aizawa'];
            var num = parseInt(e.key);
            if (num >= 1 && num <= 5) {
                switchAttractor(types[num - 1]);
            }
        });

        // Initialize presets for lorenz
        buildPresets(ATTRACTORS.lorenz.presets);

    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
