<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Tree Growth - Seasonal Cycle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e0a;
            overflow: hidden;
            font-family: 'Georgia', serif;
        }
        canvas { display: block; }
        a.back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: rgba(100, 200, 255, 0.6);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.85rem;
            z-index: 20;
            transition: color 0.3s;
        }
        a.back-link:hover { color: rgba(100, 200, 255, 1); }
        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
        }
        .film-grain {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 11;
            opacity: 0.06;
            mix-blend-mode: overlay;
        }
        .title-overlay {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            font-family: 'Georgia', serif;
            font-size: 0.8rem;
            color: rgba(150, 200, 130, 0.35);
            z-index: 15;
            pointer-events: none;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        .controls {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(100,200,130,0.15);
        }
        .controls label {
            color: rgba(180, 210, 160, 0.7);
            font-family: monospace;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .controls select, .controls input[type="range"] {
            background: rgba(30,40,30,0.8);
            color: rgba(180, 210, 160, 0.9);
            border: 1px solid rgba(100,200,130,0.2);
            border-radius: 4px;
            padding: 2px 4px;
            font-family: monospace;
            font-size: 0.7rem;
            outline: none;
        }
        .controls input[type="range"] {
            width: 80px;
            cursor: pointer;
        }
        .season-indicator {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            font-family: 'Georgia', serif;
            font-size: 0.75rem;
            color: rgba(180, 210, 160, 0.5);
            z-index: 15;
            pointer-events: none;
            letter-spacing: 0.08em;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>
    <div class="vignette"></div>
    <canvas id="grain" class="film-grain"></canvas>
    <div class="title-overlay">Generative Tree Growth</div>
    <div class="season-indicator" id="seasonLabel">Spring</div>

    <div class="controls">
        <label>Tree
            <select id="treeType">
                <option value="oak">Oak</option>
                <option value="pine">Pine</option>
                <option value="cherry">Cherry Blossom</option>
                <option value="willow">Willow</option>
            </select>
        </label>
        <label>Speed
            <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
        </label>
    </div>

    <canvas id="canvas"></canvas>

    <script>
    (function() {
        'use strict';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const grainCanvas = document.getElementById('grain');
        const grainCtx = grainCanvas.getContext('2d');
        let W, H;
        let tree = null;
        let roots = [];
        let fireflies = [];
        let fallingLeaves = [];
        let birds = [];
        let raindrops = [];
        let puddles = [];
        let snowflakes = [];
        let snowPiles = [];
        let grassBlades = [];
        let flowers = [];
        let bgTrees = [];
        let bushes = [];
        let time = 0;
        let seasonTime = 0;
        let animId = null;
        let paused = false;
        let growthSpeed = 1;
        let currentTreeType = 'oak';

        const SEASON_DURATION = 30; // seconds per season
        const SEASONS = ['spring', 'summer', 'autumn', 'winter'];

        const speedSlider = document.getElementById('speedSlider');
        const treeTypeSelect = document.getElementById('treeType');
        const seasonLabel = document.getElementById('seasonLabel');

        speedSlider.addEventListener('input', function() {
            growthSpeed = parseFloat(this.value);
        });

        treeTypeSelect.addEventListener('change', function() {
            currentTreeType = this.value;
            rebuildTree();
        });

        // --- Perlin Noise (simplified) ---
        const perlinPerm = new Uint8Array(512);
        (function initPerlin() {
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++) p[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
            }
            for (let i = 0; i < 512; i++) perlinPerm[i] = p[i & 255];
        })();

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function grad(hash, x) {
            return (hash & 1) === 0 ? x : -x;
        }
        function noise1D(x) {
            const xi = Math.floor(x) & 255;
            const xf = x - Math.floor(x);
            const u = fade(xf);
            return lerp(grad(perlinPerm[xi], xf), grad(perlinPerm[xi + 1], xf - 1), u);
        }
        function noise2D(x, y) {
            const xi = Math.floor(x) & 255;
            const yi = Math.floor(y) & 255;
            const xf = x - Math.floor(x);
            const yf = y - Math.floor(y);
            const u = fade(xf);
            const v = fade(yf);
            const aa = perlinPerm[perlinPerm[xi] + yi];
            const ab = perlinPerm[perlinPerm[xi] + yi + 1];
            const ba = perlinPerm[perlinPerm[xi + 1] + yi];
            const bb = perlinPerm[perlinPerm[xi + 1] + yi + 1];
            const x1 = lerp(grad(aa, xf) + grad(aa, yf), grad(ba, xf - 1) + grad(ba, yf), u);
            const x2 = lerp(grad(ab, xf) + grad(ab, yf - 1), grad(bb, xf - 1) + grad(bb, yf - 1), u);
            return lerp(x1, x2, v);
        }

        // --- Resize ---
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            grainCanvas.width = W;
            grainCanvas.height = H;
            initGrass();
            initBgTrees();
            initBushes();
        }
        window.addEventListener('resize', resize);

        // --- Utility ---
        function rand(min, max) { return min + Math.random() * (max - min); }
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
        function easeInOut(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; }

        // --- Season helpers ---
        function getCurrentSeason() {
            const cycle = seasonTime % (SEASON_DURATION * 4);
            const idx = Math.floor(cycle / SEASON_DURATION);
            return SEASONS[idx];
        }

        function getSeasonProgress() {
            const cycle = seasonTime % (SEASON_DURATION * 4);
            return (cycle % SEASON_DURATION) / SEASON_DURATION;
        }

        function getSeasonBlend() {
            const progress = getSeasonProgress();
            // Returns 0 at start of season, 1 at end (for blending to next)
            if (progress > 0.8) return (progress - 0.8) / 0.2;
            return 0;
        }

        function getDayNightCycle() {
            // Full day/night cycle every 2 seasons
            const cycle = (seasonTime % (SEASON_DURATION * 2)) / (SEASON_DURATION * 2);
            // 0 = dawn, 0.25 = noon, 0.5 = dusk, 0.75 = midnight
            return cycle;
        }

        function isNight() {
            const c = getDayNightCycle();
            return c > 0.4 && c < 0.9;
        }

        function getSunMoonPos() {
            const c = getDayNightCycle();
            // Sun: visible 0 to 0.5
            const sunAngle = c * Math.PI;
            const sunX = W * 0.1 + (W * 0.8) * (c / 0.5);
            const sunY = H * 0.15 + H * 0.35 * Math.sin(sunAngle);
            const sunVisible = c < 0.45 ? 1 : c < 0.55 ? 1 - (c - 0.45) / 0.1 : 0;
            // Moon: visible 0.5 to 1.0
            const moonC = (c - 0.5 + 1) % 1;
            const moonAngle = moonC * Math.PI;
            const moonX = W * 0.1 + (W * 0.8) * (moonC / 0.5);
            const moonY = H * 0.12 + H * 0.3 * Math.sin(moonAngle);
            const moonVisible = c > 0.45 && c < 0.95 ? (c < 0.55 ? (c - 0.45) / 0.1 : c > 0.85 ? 1 - (c - 0.85) / 0.1 : 1) : 0;
            return { sunX, sunY: H - sunY, sunVisible, moonX, moonY: H - moonY, moonVisible };
        }

        // --- Tree type configs ---
        function getTreeConfig(type) {
            switch(type) {
                case 'oak': return {
                    maxDepth: 8, trunkLenFactor: [0.14, 0.18], trunkThick: [10, 15],
                    spreadAngle: [0.35, 0.65], lengthFactor: [0.62, 0.78], thickFactor: [0.55, 0.72],
                    childrenMin: 2, childrenMax: 3, leafHue: [70, 140], leafSize: [3, 7],
                    autumnHue: [10, 45], branchColor: [90, 55, 30], tipColor: [60, 100, 40]
                };
                case 'pine': return {
                    maxDepth: 10, trunkLenFactor: [0.18, 0.24], trunkThick: [8, 12],
                    spreadAngle: [0.5, 0.9], lengthFactor: [0.5, 0.65], thickFactor: [0.5, 0.65],
                    childrenMin: 2, childrenMax: 4, leafHue: [120, 160], leafSize: [2, 4],
                    autumnHue: [120, 160], branchColor: [70, 45, 25], tipColor: [40, 80, 35],
                    evergreen: true
                };
                case 'cherry': return {
                    maxDepth: 7, trunkLenFactor: [0.12, 0.16], trunkThick: [8, 12],
                    spreadAngle: [0.4, 0.7], lengthFactor: [0.65, 0.8], thickFactor: [0.55, 0.7],
                    childrenMin: 2, childrenMax: 3, leafHue: [320, 350], leafSize: [3, 6],
                    autumnHue: [15, 40], branchColor: [80, 50, 35], tipColor: [65, 75, 45],
                    blossoms: true
                };
                case 'willow': return {
                    maxDepth: 8, trunkLenFactor: [0.12, 0.16], trunkThick: [9, 13],
                    spreadAngle: [0.3, 0.5], lengthFactor: [0.7, 0.85], thickFactor: [0.5, 0.65],
                    childrenMin: 2, childrenMax: 4, leafHue: [80, 130], leafSize: [2, 5],
                    autumnHue: [40, 70], branchColor: [75, 60, 35], tipColor: [55, 90, 40],
                    drooping: true
                };
                default: return getTreeConfig('oak');
            }
        }

        // --- Wind ---
        function getWind(x, y, t) {
            const wx = noise2D(x * 0.003 + t * 0.5, y * 0.005) * 0.03;
            const gustStrength = Math.max(0, noise1D(t * 0.15)) * 0.02;
            return wx + gustStrength;
        }

        // --- Ground line ---
        const GROUND_Y_RATIO = 0.82;
        function groundY() { return H * GROUND_Y_RATIO; }

        // --- Branch class ---
        class Branch {
            constructor(x, y, angle, length, thickness, depth, maxDepth, growDelay, config) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.length = length;
                this.thickness = thickness;
                this.depth = depth;
                this.maxDepth = maxDepth;
                this.growDelay = growDelay;
                this.config = config;
                this.growProgress = 0;
                this.children = [];
                this.hasLeaf = depth >= maxDepth - 2;
                this.leafSize = 0;
                this.leafMaxSize = rand(config.leafSize[0], config.leafSize[1]);
                this.leafColor = null;
                this.spawned = false;
                this.sway = rand(-0.01, 0.01);
                this.swayPhase = rand(0, Math.PI * 2);
                this.leafDetached = false;
                this.snowAmount = 0;

                if (this.hasLeaf) {
                    this.leafColor = {
                        h: rand(config.leafHue[0], config.leafHue[1]),
                        s: rand(50, 90),
                        l: rand(40, 65)
                    };
                    this.autumnColor = {
                        h: rand(config.autumnHue[0], config.autumnHue[1]),
                        s: rand(70, 100),
                        l: rand(45, 60)
                    };
                }
            }

            get endX() {
                const wind = getWind(this.x, this.y, time);
                const sway = this.sway + wind;
                const currentAngle = this.angle + Math.sin(time * 0.5 + this.swayPhase) * sway;
                return this.x + Math.cos(currentAngle) * this.length * this.growProgress;
            }

            get endY() {
                const wind = getWind(this.x, this.y, time);
                const sway = this.sway + wind;
                const currentAngle = this.angle + Math.sin(time * 0.5 + this.swayPhase) * sway;
                return this.y + Math.sin(currentAngle) * this.length * this.growProgress;
            }

            update(dt) {
                if (this.growDelay > 0) {
                    this.growDelay -= dt;
                    return;
                }

                if (this.growProgress < 1) {
                    this.growProgress = clamp(this.growProgress + dt * 0.8 * growthSpeed, 0, 1);
                }

                if (this.growProgress > 0.9 && !this.spawned && this.depth < this.maxDepth) {
                    this.spawned = true;
                    this.spawnChildren();
                }

                const season = getCurrentSeason();
                const progress = getSeasonProgress();
                const cfg = this.config;

                // Leaf growth / shedding based on season
                if (this.hasLeaf && this.growProgress >= 1) {
                    if (season === 'spring') {
                        this.leafSize = clamp(this.leafSize + dt * 2.5 * growthSpeed, 0, this.leafMaxSize);
                        this.leafDetached = false;
                    } else if (season === 'summer') {
                        this.leafSize = clamp(this.leafSize + dt * 1.0, 0, this.leafMaxSize);
                    } else if (season === 'autumn' && !cfg.evergreen) {
                        // Leaves fall off gradually
                        if (!this.leafDetached && Math.random() < 0.0008 * progress) {
                            this.leafDetached = true;
                            const ex = this.endX;
                            const ey = this.endY;
                            fallingLeaves.push({
                                x: ex, y: ey,
                                vx: rand(-0.8, 0.8), vy: rand(0.1, 0.4),
                                size: this.leafSize * 0.8,
                                color: this.autumnColor,
                                rot: rand(0, Math.PI * 2),
                                rotSpeed: rand(-0.03, 0.03),
                                life: 1,
                                flutter: rand(1, 3)
                            });
                        }
                        if (this.leafDetached) {
                            this.leafSize = clamp(this.leafSize - dt * 0.5, 0, this.leafMaxSize);
                        }
                    } else if (season === 'winter' && !cfg.evergreen) {
                        this.leafSize = clamp(this.leafSize - dt * 2, 0, this.leafMaxSize);
                        this.leafDetached = true;
                    }

                    // Snow accumulation in winter
                    if (season === 'winter') {
                        this.snowAmount = clamp(this.snowAmount + dt * 0.3 * progress, 0, this.thickness * 2 + 3);
                    } else {
                        this.snowAmount = clamp(this.snowAmount - dt * 2, 0, 10);
                    }
                }

                for (let i = 0; i < this.children.length; i++) {
                    this.children[i].update(dt);
                }
            }

            spawnChildren() {
                const ex = this.endX;
                const ey = this.endY;
                const cfg = this.config;
                const numChildren = this.depth < 3 ? randInt(cfg.childrenMin, cfg.childrenMax) : randInt(1, cfg.childrenMax);
                const spreadAngle = rand(cfg.spreadAngle[0], cfg.spreadAngle[1]);
                const lengthFactor = rand(cfg.lengthFactor[0], cfg.lengthFactor[1]);
                const thickFactor = rand(cfg.thickFactor[0], cfg.thickFactor[1]);

                for (let i = 0; i < numChildren; i++) {
                    let angleOffset = (i - (numChildren - 1) / 2) * spreadAngle + rand(-0.15, 0.15);
                    let childAngle = this.angle + angleOffset;

                    // Willow: droop outer branches
                    if (cfg.drooping && this.depth > 2) {
                        childAngle += 0.3 + rand(0, 0.3);
                    }

                    const childLength = this.length * lengthFactor * rand(0.85, 1.15);
                    const childThick = this.thickness * thickFactor;
                    const delay = rand(0.05, 0.3);

                    if (childLength > 4 && childThick > 0.25) {
                        this.children.push(new Branch(
                            ex, ey, childAngle, childLength, childThick,
                            this.depth + 1, this.maxDepth, delay, cfg
                        ));
                    }
                }
            }

            draw() {
                if (this.growProgress <= 0) return;

                const wind = getWind(this.x, this.y, time);
                const sway = this.sway + wind;
                const currentAngle = this.angle + Math.sin(time * 0.5 + this.swayPhase) * sway;
                const ex = this.x + Math.cos(currentAngle) * this.length * this.growProgress;
                const ey = this.y + Math.sin(currentAngle) * this.length * this.growProgress;
                const currentThick = this.thickness * (1 - this.growProgress * 0.15);
                const cfg = this.config;

                const depthRatio = this.depth / this.maxDepth;
                const r = Math.floor(lerp(cfg.branchColor[0], cfg.tipColor[0], depthRatio));
                const g = Math.floor(lerp(cfg.branchColor[1], cfg.tipColor[1], depthRatio));
                const b = Math.floor(lerp(cfg.branchColor[2], cfg.tipColor[2], depthRatio));

                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(ex, ey);
                ctx.strokeStyle = `rgb(${r},${g},${b})`;
                ctx.lineWidth = currentThick * this.growProgress;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Snow on branches
                if (this.snowAmount > 0.5 && this.depth < this.maxDepth - 1) {
                    const mx = (this.x + ex) / 2;
                    const my = (this.y + ey) / 2;
                    ctx.beginPath();
                    ctx.ellipse(mx, my - currentThick * 0.5, this.length * this.growProgress * 0.3, this.snowAmount * 0.5, currentAngle, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(230, 240, 255, ${0.4 * clamp(this.snowAmount / 3, 0, 1)})`;
                    ctx.fill();
                }

                // Draw leaf at tip
                if (this.hasLeaf && this.leafSize > 0.5 && !this.leafDetached) {
                    const season = getCurrentSeason();
                    const progress = getSeasonProgress();
                    let lc = this.leafColor;

                    // Transition leaf color in autumn
                    if (season === 'autumn' && !cfg.evergreen) {
                        const t = easeInOut(clamp(progress * 1.5, 0, 1));
                        lc = {
                            h: lerp(this.leafColor.h, this.autumnColor.h, t),
                            s: lerp(this.leafColor.s, this.autumnColor.s, t),
                            l: lerp(this.leafColor.l, this.autumnColor.l, t)
                        };
                    }

                    // Cherry blossoms: pink petals
                    if (cfg.blossoms && (season === 'spring' || season === 'summer')) {
                        const glow = 0.5 + 0.3 * Math.sin(time * 1.5 + this.swayPhase);
                        ctx.beginPath();
                        ctx.arc(ex, ey, this.leafSize * 2, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(340, 80%, 80%, ${0.1 * glow})`;
                        ctx.fill();
                        for (let p = 0; p < 5; p++) {
                            const pa = (p / 5) * Math.PI * 2 + time * 0.2;
                            const px = ex + Math.cos(pa) * this.leafSize * 1.2;
                            const py = ey + Math.sin(pa) * this.leafSize * 1.2;
                            ctx.beginPath();
                            ctx.ellipse(px, py, this.leafSize * 0.6, this.leafSize * 0.3, pa, 0, Math.PI * 2);
                            ctx.fillStyle = `hsla(${rand(330, 350)}, 80%, 80%, ${0.6 * glow})`;
                            ctx.fill();
                        }
                    } else {
                        const glow = 0.5 + 0.3 * Math.sin(time * 1.5 + this.swayPhase);
                        ctx.beginPath();
                        ctx.arc(ex, ey, this.leafSize * 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${lc.h}, ${lc.s}%, ${lc.l}%, ${0.08 * glow})`;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(ex, ey, this.leafSize, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${lc.h}, ${lc.s}%, ${lc.l}%, ${0.7 + 0.3 * glow})`;
                        ctx.fill();
                    }
                }

                for (let i = 0; i < this.children.length; i++) {
                    this.children[i].draw();
                }
            }

            // Collect branch endpoints for birds to land on
            collectPerchPoints(points) {
                if (this.growProgress >= 1 && this.depth >= 2 && this.depth <= this.maxDepth - 2) {
                    points.push({ x: this.endX, y: this.endY, angle: this.angle });
                }
                for (let c of this.children) c.collectPerchPoints(points);
            }
        }

        // --- Root system ---
        class Root {
            constructor(x, y, angle, length, thickness, depth, maxDepth, delay) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.length = length;
                this.thickness = thickness;
                this.depth = depth;
                this.maxDepth = maxDepth;
                this.growDelay = delay;
                this.growProgress = 0;
                this.children = [];
                this.spawned = false;
            }

            get endX() { return this.x + Math.cos(this.angle) * this.length * this.growProgress; }
            get endY() { return this.y + Math.sin(this.angle) * this.length * this.growProgress; }

            update(dt) {
                if (this.growDelay > 0) { this.growDelay -= dt; return; }
                if (this.growProgress < 1) {
                    this.growProgress = clamp(this.growProgress + dt * 0.4 * growthSpeed, 0, 1);
                }
                if (this.growProgress > 0.8 && !this.spawned && this.depth < this.maxDepth) {
                    this.spawned = true;
                    const ex = this.endX, ey = this.endY;
                    const numC = randInt(1, 3);
                    for (let i = 0; i < numC; i++) {
                        const a = this.angle + rand(-0.6, 0.6);
                        const l = this.length * rand(0.5, 0.75);
                        const t = this.thickness * rand(0.5, 0.7);
                        if (l > 3 && t > 0.2) {
                            this.children.push(new Root(ex, ey, a, l, t, this.depth + 1, this.maxDepth, rand(0.1, 0.5)));
                        }
                    }
                }
                for (let c of this.children) c.update(dt);
            }

            draw() {
                if (this.growProgress <= 0) return;
                const ex = this.endX, ey = this.endY;
                const depthRatio = this.depth / this.maxDepth;
                const r = Math.floor(lerp(80, 50, depthRatio));
                const g = Math.floor(lerp(50, 35, depthRatio));
                const b = Math.floor(lerp(25, 15, depthRatio));
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(ex, ey);
                ctx.strokeStyle = `rgb(${r},${g},${b})`;
                ctx.lineWidth = this.thickness * this.growProgress;
                ctx.lineCap = 'round';
                ctx.stroke();
                for (let c of this.children) c.draw();
            }
        }

        // --- Create tree ---
        function createTree() {
            const cfg = getTreeConfig(currentTreeType);
            const gy = groundY();
            const trunkLength = H * rand(cfg.trunkLenFactor[0], cfg.trunkLenFactor[1]);
            const trunkThickness = rand(cfg.trunkThick[0], cfg.trunkThick[1]);
            const maxDepth = cfg.maxDepth;
            const baseX = W / 2 + rand(-30, 30);
            tree = new Branch(
                baseX, gy,
                -Math.PI / 2 + rand(-0.06, 0.06),
                trunkLength, trunkThickness,
                0, maxDepth, 0, cfg
            );

            // Create roots
            roots = [];
            const numRoots = randInt(3, 6);
            for (let i = 0; i < numRoots; i++) {
                const a = Math.PI / 2 + rand(-0.8, 0.8);
                const l = trunkLength * rand(0.3, 0.5);
                const t = trunkThickness * rand(0.3, 0.6);
                roots.push(new Root(baseX + rand(-5, 5), gy, a, l, t, 0, 5, rand(0.5, 2)));
            }
        }

        function rebuildTree() {
            fallingLeaves = [];
            snowflakes = [];
            snowPiles = [];
            createTree();
        }

        // --- Background depth layers ---
        function initBgTrees() {
            bgTrees = [];
            const gy = groundY();
            for (let i = 0; i < 15; i++) {
                bgTrees.push({
                    x: rand(-50, W + 50),
                    baseY: gy + rand(-20, 0),
                    height: rand(80, 200),
                    width: rand(30, 70),
                    alpha: rand(0.04, 0.12),
                    type: Math.random() > 0.5 ? 'round' : 'triangle'
                });
            }
        }

        function drawBgTrees() {
            const season = getCurrentSeason();
            const nightFactor = isNight() ? 0.5 : 1;
            for (const t of bgTrees) {
                let hue = 130, sat = 20, light = 25;
                if (season === 'autumn') { hue = 30; sat = 30; light = 30; }
                if (season === 'winter') { hue = 200; sat = 10; light = 35; }
                ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${t.alpha * nightFactor})`;
                if (t.type === 'round') {
                    ctx.beginPath();
                    ctx.ellipse(t.x, t.baseY - t.height * 0.5, t.width * 0.5, t.height * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(t.x, t.baseY);
                    ctx.lineTo(t.x - t.width * 0.5, t.baseY);
                    ctx.lineTo(t.x, t.baseY - t.height);
                    ctx.lineTo(t.x + t.width * 0.5, t.baseY);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            // Mist layer
            const mistAlpha = isNight() ? 0.03 : 0.06;
            const mistGrad = ctx.createLinearGradient(0, groundY() - 200, 0, groundY());
            mistGrad.addColorStop(0, `rgba(180, 200, 210, 0)`);
            mistGrad.addColorStop(0.5, `rgba(180, 200, 210, ${mistAlpha})`);
            mistGrad.addColorStop(1, `rgba(180, 200, 210, 0)`);
            ctx.fillStyle = mistGrad;
            ctx.fillRect(0, groundY() - 200, W, 200);
        }

        function initBushes() {
            bushes = [];
            const gy = groundY();
            for (let i = 0; i < 8; i++) {
                bushes.push({
                    x: rand(0, W),
                    y: gy + rand(-5, 5),
                    w: rand(30, 60),
                    h: rand(15, 30),
                    phase: rand(0, Math.PI * 2)
                });
            }
        }

        function drawBushes() {
            const season = getCurrentSeason();
            for (const b of bushes) {
                let hue = 120, sat = 40, light = 25;
                if (season === 'autumn') { hue = 35; sat = 50; light = 30; }
                if (season === 'winter') { hue = 30; sat = 15; light = 20; }
                const sway = Math.sin(time * 0.6 + b.phase) * 2;
                ctx.beginPath();
                ctx.ellipse(b.x + sway, b.y, b.w * 0.5, b.h, 0, Math.PI, 0);
                ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.4)`;
                ctx.fill();
            }
        }

        // --- Grass ---
        function initGrass() {
            grassBlades = [];
            const gy = groundY();
            for (let i = 0; i < 200; i++) {
                grassBlades.push({
                    x: rand(0, W),
                    y: gy + rand(-2, 4),
                    height: rand(8, 25),
                    phase: rand(0, Math.PI * 2),
                    hue: rand(80, 140),
                    width: rand(0.5, 1.5)
                });
            }
        }

        function drawGrass() {
            const season = getCurrentSeason();
            const progress = getSeasonProgress();
            for (const g of grassBlades) {
                let hue = g.hue;
                let sat = 50, light = 35;
                let h = g.height;
                if (season === 'autumn') {
                    hue = lerp(g.hue, 40, progress * 0.7);
                    sat = lerp(50, 35, progress);
                } else if (season === 'winter') {
                    hue = 40; sat = 15; light = 25;
                    h = g.height * 0.4;
                } else if (season === 'spring') {
                    light = lerp(25, 40, progress);
                }
                const wind = getWind(g.x, g.y, time);
                const sway = Math.sin(time * 1.2 + g.phase) * 4 + wind * 80;
                ctx.beginPath();
                ctx.moveTo(g.x, g.y);
                ctx.quadraticCurveTo(g.x + sway * 0.6, g.y - h * 0.5, g.x + sway, g.y - h);
                ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.5)`;
                ctx.lineWidth = g.width;
                ctx.stroke();
            }
        }

        // --- Flowers ---
        function updateFlowers() {
            const season = getCurrentSeason();
            const gy = groundY();
            if (season === 'spring' && flowers.length < 20 && Math.random() < 0.02) {
                flowers.push({
                    x: rand(50, W - 50),
                    y: gy + rand(-5, 0),
                    size: 0,
                    maxSize: rand(3, 6),
                    hue: rand(0, 360),
                    petals: randInt(4, 7),
                    phase: rand(0, Math.PI * 2),
                    stemH: rand(10, 20)
                });
            }
            for (let i = flowers.length - 1; i >= 0; i--) {
                const f = flowers[i];
                if (season === 'spring' || season === 'summer') {
                    f.size = clamp(f.size + 0.02, 0, f.maxSize);
                } else {
                    f.size = clamp(f.size - 0.05, 0, f.maxSize);
                    if (f.size <= 0) { flowers.splice(i, 1); }
                }
            }
        }

        function drawFlowers() {
            for (const f of flowers) {
                if (f.size < 0.5) continue;
                const sway = Math.sin(time * 0.8 + f.phase) * 2;
                // Stem
                ctx.beginPath();
                ctx.moveTo(f.x, f.y);
                ctx.quadraticCurveTo(f.x + sway * 0.5, f.y - f.stemH * 0.5, f.x + sway, f.y - f.stemH);
                ctx.strokeStyle = `hsla(120, 40%, 30%, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();
                // Petals
                const fx = f.x + sway;
                const fy = f.y - f.stemH;
                for (let p = 0; p < f.petals; p++) {
                    const a = (p / f.petals) * Math.PI * 2;
                    const px = fx + Math.cos(a) * f.size * 1.5;
                    const py = fy + Math.sin(a) * f.size * 1.5;
                    ctx.beginPath();
                    ctx.arc(px, py, f.size * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${f.hue}, 70%, 70%, 0.7)`;
                    ctx.fill();
                }
                // Center
                ctx.beginPath();
                ctx.arc(fx, fy, f.size * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(50, 80%, 60%, 0.8)`;
                ctx.fill();
            }
        }

        // --- Birds ---
        function updateBirds(dt) {
            // Spawn birds occasionally
            if (birds.length < 5 && Math.random() < 0.002) {
                const perchPoints = [];
                if (tree) tree.collectPerchPoints(perchPoints);
                const fromLeft = Math.random() > 0.5;
                birds.push({
                    x: fromLeft ? -30 : W + 30,
                    y: rand(H * 0.1, groundY() - 50),
                    vx: fromLeft ? rand(1, 2.5) : rand(-2.5, -1),
                    vy: 0,
                    state: 'flying', // flying, landing, perched, takeoff
                    wingPhase: rand(0, Math.PI * 2),
                    wingSpeed: rand(6, 10),
                    size: rand(4, 7),
                    perchTarget: perchPoints.length > 0 ? perchPoints[randInt(0, perchPoints.length - 1)] : null,
                    perchTimer: 0,
                    color: `hsl(${rand(0, 40)}, ${rand(20, 50)}%, ${rand(20, 40)}%)`
                });
            }

            for (let i = birds.length - 1; i >= 0; i--) {
                const b = birds[i];
                if (b.state === 'flying') {
                    b.x += b.vx;
                    b.y += b.vy + Math.sin(time * 2 + b.wingPhase) * 0.3;
                    b.vy *= 0.98;

                    // Check if near perch target
                    if (b.perchTarget && Math.random() < 0.01) {
                        const dx = b.perchTarget.x - b.x;
                        const dy = b.perchTarget.y - b.y;
                        if (Math.abs(dx) < 100 && Math.abs(dy) < 80) {
                            b.state = 'landing';
                            b.vx = dx * 0.02;
                            b.vy = dy * 0.02;
                        }
                    }

                    // Remove if offscreen
                    if (b.x < -60 || b.x > W + 60) {
                        birds.splice(i, 1);
                        continue;
                    }
                } else if (b.state === 'landing') {
                    if (b.perchTarget) {
                        b.x = lerp(b.x, b.perchTarget.x, 0.05);
                        b.y = lerp(b.y, b.perchTarget.y, 0.05);
                        if (Math.abs(b.x - b.perchTarget.x) < 3 && Math.abs(b.y - b.perchTarget.y) < 3) {
                            b.state = 'perched';
                            b.perchTimer = rand(3, 10);
                        }
                    }
                } else if (b.state === 'perched') {
                    if (b.perchTarget) {
                        b.x = b.perchTarget.x;
                        b.y = b.perchTarget.y;
                    }
                    b.perchTimer -= dt;
                    if (b.perchTimer <= 0) {
                        b.state = 'flying';
                        b.vx = (Math.random() > 0.5 ? 1 : -1) * rand(1.5, 3);
                        b.vy = rand(-1, -0.5);
                        b.perchTarget = null;
                    }
                }
            }
        }

        function drawBirds() {
            for (const b of birds) {
                ctx.save();
                ctx.translate(b.x, b.y);
                const flap = b.state === 'perched' ? 0 : Math.sin(time * b.wingSpeed + b.wingPhase) * 0.6;
                ctx.fillStyle = b.color;
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, b.size, b.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                // Wings
                const dir = b.vx >= 0 ? 1 : -1;
                ctx.beginPath();
                ctx.moveTo(-b.size * 0.3, 0);
                ctx.quadraticCurveTo(-b.size, -b.size * flap * 1.5, -b.size * 1.5, -b.size * flap);
                ctx.quadraticCurveTo(-b.size * 0.5, -b.size * flap * 0.3, -b.size * 0.3, 0);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(b.size * 0.3, 0);
                ctx.quadraticCurveTo(b.size, -b.size * flap * 1.5, b.size * 1.5, -b.size * flap);
                ctx.quadraticCurveTo(b.size * 0.5, -b.size * flap * 0.3, b.size * 0.3, 0);
                ctx.fill();
                // Beak
                ctx.beginPath();
                ctx.moveTo(b.size * dir, 0);
                ctx.lineTo(b.size * 1.4 * dir, -1);
                ctx.lineTo(b.size * 1.4 * dir, 1);
                ctx.closePath();
                ctx.fillStyle = '#d4a030';
                ctx.fill();
                ctx.restore();
            }
        }

        // --- Fireflies (only at night) ---
        function initFireflies(count) {
            fireflies = [];
            for (let i = 0; i < count; i++) {
                fireflies.push({
                    x: rand(0, W),
                    y: rand(H * 0.1, groundY()),
                    vx: rand(-0.3, 0.3),
                    vy: rand(-0.2, 0.2),
                    size: rand(1.5, 3),
                    phase: rand(0, Math.PI * 2),
                    speed: rand(0.5, 2),
                    hue: rand(40, 70)
                });
            }
        }

        function updateFireflies(dt) {
            if (!isNight()) return;
            for (const f of fireflies) {
                f.x += f.vx + Math.sin(time * 0.3 + f.phase) * 0.15;
                f.y += f.vy + Math.cos(time * 0.4 + f.phase) * 0.1;
                f.vx += rand(-0.01, 0.01);
                f.vy += rand(-0.01, 0.01);
                f.vx *= 0.99;
                f.vy *= 0.99;
                if (f.x < -20) f.x = W + 20;
                if (f.x > W + 20) f.x = -20;
                if (f.y < -20) f.y = groundY();
                if (f.y > groundY()) f.y = H * 0.1;
            }
        }

        function drawFireflies() {
            if (!isNight()) return;
            const nightIntensity = isNight() ? 1 : 0;
            for (const f of fireflies) {
                const brightness = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(time * f.speed + f.phase));
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size * 5, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${f.hue}, 80%, 70%, ${0.04 * brightness * nightIntensity})`;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size * 2.5, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${f.hue}, 80%, 70%, ${0.12 * brightness * nightIntensity})`;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${f.hue}, 90%, 80%, ${0.8 * brightness * nightIntensity})`;
                ctx.fill();
            }
        }

        // --- Falling leaves ---
        function updateFallingLeaves(dt) {
            for (let i = fallingLeaves.length - 1; i >= 0; i--) {
                const l = fallingLeaves[i];
                const wind = getWind(l.x, l.y, time);
                l.x += l.vx + Math.sin(time * l.flutter + l.rot) * 0.5 + wind * 30;
                l.y += l.vy;
                l.vy += 0.006;
                l.vy = Math.min(l.vy, 1.5);
                l.rot += l.rotSpeed;
                l.life -= 0.002;

                if (l.life <= 0 || l.y > groundY() + 10) {
                    fallingLeaves.splice(i, 1);
                }
            }
        }

        function drawFallingLeaves() {
            for (const l of fallingLeaves) {
                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rot);
                ctx.beginPath();
                // Leaf shape
                ctx.moveTo(0, -l.size);
                ctx.bezierCurveTo(l.size, -l.size * 0.5, l.size, l.size * 0.5, 0, l.size);
                ctx.bezierCurveTo(-l.size, l.size * 0.5, -l.size, -l.size * 0.5, 0, -l.size);
                ctx.fillStyle = `hsla(${l.color.h}, ${l.color.s}%, ${l.color.l}%, ${l.life * 0.7})`;
                ctx.fill();
                ctx.restore();
            }
        }

        // --- Rain ---
        function updateRain(dt) {
            const season = getCurrentSeason();
            // Rain mostly in spring/autumn, not winter
            const shouldRain = (season === 'spring' || season === 'autumn') && noise1D(time * 0.05) > 0.3;
            const gy = groundY();

            if (shouldRain && raindrops.length < 300) {
                for (let i = 0; i < 5; i++) {
                    raindrops.push({
                        x: rand(-50, W + 50),
                        y: rand(-50, -10),
                        speed: rand(6, 12),
                        length: rand(8, 20),
                        alpha: rand(0.1, 0.3)
                    });
                }
            }

            for (let i = raindrops.length - 1; i >= 0; i--) {
                const r = raindrops[i];
                r.y += r.speed;
                r.x -= r.speed * 0.1; // slight wind angle

                if (r.y > gy) {
                    // Create puddle ripple
                    if (puddles.length < 30 && Math.random() < 0.3) {
                        puddles.push({
                            x: r.x,
                            y: gy + rand(0, 10),
                            radius: 0,
                            maxRadius: rand(5, 15),
                            alpha: 0.3,
                            speed: rand(0.3, 0.6)
                        });
                    }
                    raindrops.splice(i, 1);
                }
            }

            // Update puddle ripples
            for (let i = puddles.length - 1; i >= 0; i--) {
                const p = puddles[i];
                p.radius += p.speed;
                p.alpha -= 0.005;
                if (p.alpha <= 0 || p.radius > p.maxRadius) {
                    puddles.splice(i, 1);
                }
            }
        }

        function drawRain() {
            const nightFactor = isNight() ? 0.5 : 1;
            ctx.strokeStyle = `rgba(150, 180, 220, 0.15)`;
            ctx.lineWidth = 1;
            for (const r of raindrops) {
                ctx.beginPath();
                ctx.moveTo(r.x, r.y);
                ctx.lineTo(r.x - r.length * 0.1, r.y + r.length);
                ctx.strokeStyle = `rgba(150, 180, 220, ${r.alpha * nightFactor})`;
                ctx.stroke();
            }
            // Puddle ripples
            for (const p of puddles) {
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, p.radius, p.radius * 0.3, 0, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(150, 180, 220, ${p.alpha * 0.5 * nightFactor})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        }

        // --- Snow ---
        function updateSnow(dt) {
            const season = getCurrentSeason();
            const gy = groundY();

            if (season === 'winter' && snowflakes.length < 250) {
                for (let i = 0; i < 2; i++) {
                    snowflakes.push({
                        x: rand(-20, W + 20),
                        y: rand(-30, -5),
                        speed: rand(0.5, 2),
                        size: rand(1, 3.5),
                        wobble: rand(0.5, 2),
                        wobblePhase: rand(0, Math.PI * 2),
                        alpha: rand(0.3, 0.8)
                    });
                }
            }

            for (let i = snowflakes.length - 1; i >= 0; i--) {
                const s = snowflakes[i];
                s.y += s.speed;
                s.x += Math.sin(time * s.wobble + s.wobblePhase) * 0.5;

                if (s.y > gy + 5) {
                    snowflakes.splice(i, 1);
                }
            }

            // Manage snow accumulation on ground
            if (season === 'winter') {
                if (snowPiles.length === 0) {
                    for (let i = 0; i < 40; i++) {
                        snowPiles.push({
                            x: (i / 40) * W,
                            height: 0,
                            maxHeight: rand(5, 20)
                        });
                    }
                }
                for (const p of snowPiles) {
                    p.height = clamp(p.height + dt * 0.5 * getSeasonProgress(), 0, p.maxHeight);
                }
            } else {
                for (const p of snowPiles) {
                    p.height = clamp(p.height - dt * 2, 0, p.maxHeight);
                }
                if (season !== 'autumn' && snowPiles.length > 0 && snowPiles.every(p => p.height <= 0)) {
                    snowPiles = [];
                }
            }
        }

        function drawSnow() {
            for (const s of snowflakes) {
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(230, 240, 255, ${s.alpha})`;
                ctx.fill();
            }
        }

        function drawSnowGround() {
            if (snowPiles.length === 0) return;
            const gy = groundY();
            ctx.beginPath();
            ctx.moveTo(0, gy + 20);
            for (let i = 0; i < snowPiles.length; i++) {
                const p = snowPiles[i];
                const nextP = snowPiles[(i + 1) % snowPiles.length];
                const cx = (p.x + (nextP ? nextP.x : W)) / 2;
                ctx.quadraticCurveTo(p.x, gy - p.height, cx, gy - (p.height + (nextP ? nextP.height : 0)) / 2);
            }
            ctx.lineTo(W, gy + 20);
            ctx.closePath();
            ctx.fillStyle = `rgba(220, 235, 250, 0.4)`;
            ctx.fill();
        }

        // --- Stars ---
        let stars = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < 120; i++) {
                stars.push({
                    x: rand(0, W),
                    y: rand(0, H * 0.6),
                    size: rand(0.3, 1.8),
                    phase: rand(0, Math.PI * 2),
                    speed: rand(0.3, 1.2)
                });
            }
        }

        function drawStars() {
            if (!isNight()) return;
            const c = getDayNightCycle();
            const nightStrength = c > 0.5 && c < 0.85 ? 1 : c >= 0.85 ? 1 - (c - 0.85) / 0.15 : c > 0.4 ? (c - 0.4) / 0.1 : 0;
            for (const s of stars) {
                const twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(time * s.speed + s.phase));
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 220, 255, ${0.5 * twinkle * nightStrength})`;
                ctx.fill();
            }
        }

        // --- Sky ---
        function drawSky() {
            const season = getCurrentSeason();
            const c = getDayNightCycle();
            const gy = groundY();

            let topColor, midColor, botColor;

            if (isNight()) {
                topColor = [5, 10, 22];
                midColor = [10, 18, 28];
                botColor = [12, 22, 18];
            } else {
                // Daytime sky varies by season
                if (season === 'spring') {
                    topColor = [70, 130, 200];
                    midColor = [120, 170, 220];
                    botColor = [160, 200, 220];
                } else if (season === 'summer') {
                    topColor = [50, 110, 200];
                    midColor = [100, 160, 220];
                    botColor = [150, 190, 210];
                } else if (season === 'autumn') {
                    topColor = [60, 80, 120];
                    midColor = [100, 100, 120];
                    botColor = [130, 110, 100];
                } else {
                    topColor = [80, 100, 130];
                    midColor = [120, 130, 150];
                    botColor = [150, 155, 165];
                }
            }

            // Transition factor for dawn/dusk
            let transitionFactor = 0;
            if (c > 0.35 && c < 0.55) {
                transitionFactor = c < 0.45 ? (c - 0.35) / 0.1 : 1 - (c - 0.45) / 0.1;
            }
            if (c > 0.85 || c < 0.1) {
                const dc = c > 0.85 ? c - 0.85 : c + 0.15;
                transitionFactor = dc < 0.15 ? dc / 0.15 : 1 - (dc - 0.15) / 0.1;
                transitionFactor = clamp(transitionFactor, 0, 1);
            }

            // Dawn/dusk tint
            const dawnR = [200, 120, 60];
            const dawnG = [100, 80, 60];
            const dawnB = [60, 80, 100];

            const blendedTop = topColor.map((c, i) => Math.floor(lerp(c, dawnR[i], transitionFactor * 0.3)));
            const blendedMid = midColor.map((c, i) => Math.floor(lerp(c, dawnG[i], transitionFactor * 0.5)));
            const blendedBot = botColor.map((c, i) => Math.floor(lerp(c, dawnB[i], transitionFactor * 0.3)));

            const skyGrad = ctx.createLinearGradient(0, 0, 0, gy);
            skyGrad.addColorStop(0, `rgb(${blendedTop.join(',')})`);
            skyGrad.addColorStop(0.5, `rgb(${blendedMid.join(',')})`);
            skyGrad.addColorStop(1, `rgb(${blendedBot.join(',')})`);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, W, gy);
        }

        // --- Sun / Moon ---
        function drawSunMoon() {
            const pos = getSunMoonPos();

            // Sun
            if (pos.sunVisible > 0.05) {
                const sx = pos.sunX, sy = pos.sunY;
                const alpha = pos.sunVisible;
                // Glow
                const sunGlow = ctx.createRadialGradient(sx, sy, 10, sx, sy, 120);
                sunGlow.addColorStop(0, `rgba(255, 220, 100, ${0.2 * alpha})`);
                sunGlow.addColorStop(0.3, `rgba(255, 180, 60, ${0.06 * alpha})`);
                sunGlow.addColorStop(1, `rgba(255, 150, 50, 0)`);
                ctx.fillStyle = sunGlow;
                ctx.fillRect(sx - 150, sy - 150, 300, 300);
                // Body
                ctx.beginPath();
                ctx.arc(sx, sy, 25, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 230, 120, ${0.9 * alpha})`;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(sx, sy, 22, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 245, 180, ${0.6 * alpha})`;
                ctx.fill();
            }

            // Moon
            if (pos.moonVisible > 0.05) {
                const mx = pos.moonX, my = pos.moonY;
                const alpha = pos.moonVisible;
                const moonGlow = ctx.createRadialGradient(mx, my, 15, mx, my, 100);
                moonGlow.addColorStop(0, `rgba(200, 220, 240, ${0.08 * alpha})`);
                moonGlow.addColorStop(0.5, `rgba(180, 200, 220, ${0.02 * alpha})`);
                moonGlow.addColorStop(1, `rgba(180, 200, 220, 0)`);
                ctx.fillStyle = moonGlow;
                ctx.fillRect(mx - 120, my - 120, 240, 240);
                ctx.beginPath();
                ctx.arc(mx, my, 20, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(220, 230, 240, ${0.15 * alpha})`;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(mx, my, 17, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(230, 240, 250, ${0.1 * alpha})`;
                ctx.fill();
                // Crescent shadow
                ctx.beginPath();
                ctx.arc(mx + 6, my - 3, 15, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(10, 15, 30, ${0.12 * alpha})`;
                ctx.fill();
            }
        }

        // --- Ground ---
        function drawGround() {
            const gy = groundY();
            const season = getCurrentSeason();

            // Underground section (below ground line)
            const underGrad = ctx.createLinearGradient(0, gy, 0, H);
            if (season === 'winter') {
                underGrad.addColorStop(0, 'rgba(80, 70, 60, 0.9)');
                underGrad.addColorStop(0.2, 'rgba(60, 50, 40, 0.95)');
                underGrad.addColorStop(1, 'rgba(30, 25, 18, 1)');
            } else {
                underGrad.addColorStop(0, 'rgba(50, 40, 25, 0.9)');
                underGrad.addColorStop(0.2, 'rgba(40, 30, 18, 0.95)');
                underGrad.addColorStop(1, 'rgba(20, 15, 8, 1)');
            }
            ctx.fillStyle = underGrad;
            ctx.fillRect(0, gy, W, H - gy);

            // Ground line
            ctx.beginPath();
            ctx.moveTo(0, gy);
            for (let x = 0; x <= W; x += 10) {
                ctx.lineTo(x, gy + Math.sin(x * 0.03 + time * 0.1) * 2);
            }
            ctx.lineTo(W, gy + 5);
            ctx.lineTo(0, gy + 5);
            ctx.closePath();
            let groundColor = season === 'winter' ? 'rgba(120, 115, 100, 0.6)' :
                              season === 'autumn' ? 'rgba(90, 70, 40, 0.6)' :
                              'rgba(50, 80, 35, 0.6)';
            ctx.fillStyle = groundColor;
            ctx.fill();

            // Soil layers
            const soilY1 = gy + (H - gy) * 0.3;
            const soilY2 = gy + (H - gy) * 0.6;
            ctx.strokeStyle = 'rgba(80, 60, 35, 0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([10, 8]);
            ctx.beginPath();
            ctx.moveTo(0, soilY1);
            for (let x = 0; x <= W; x += 20) {
                ctx.lineTo(x, soilY1 + Math.sin(x * 0.02) * 3);
            }
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, soilY2);
            for (let x = 0; x <= W; x += 20) {
                ctx.lineTo(x, soilY2 + Math.sin(x * 0.015 + 1) * 4);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Small rocks underground
            ctx.fillStyle = 'rgba(100, 90, 70, 0.2)';
            for (let i = 0; i < 12; i++) {
                const rx = (i * 97 + 30) % W;
                const ry = gy + 30 + ((i * 73) % Math.floor(H - gy - 40));
                const rs = 2 + (i % 4);
                ctx.beginPath();
                ctx.ellipse(rx, ry, rs, rs * 0.7, (i * 0.5), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Film grain ---
        function updateGrain() {
            const imageData = grainCtx.createImageData(W, H);
            const data = imageData.data;
            // Sparse grain for performance
            for (let i = 0; i < data.length; i += 16) {
                const v = Math.random() * 255;
                data[i] = data[i + 1] = data[i + 2] = v;
                data[i + 3] = 255;
            }
            grainCtx.putImageData(imageData, 0, 0);
        }

        // --- Season label ---
        function updateSeasonLabel() {
            const season = getCurrentSeason();
            const names = { spring: 'Spring', summer: 'Summer', autumn: 'Autumn', winter: 'Winter' };
            seasonLabel.textContent = names[season] || '';
        }

        // --- Main loop ---
        let lastTime = 0;
        let grainTimer = 0;

        function animate(timestamp) {
            animId = requestAnimationFrame(animate);
            if (paused) return;

            const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;
            time += dt * growthSpeed;
            seasonTime += dt * growthSpeed;

            // Draw sky
            drawSky();

            // Sun / Moon
            drawSunMoon();

            // Stars
            drawStars();

            // Background forest
            drawBgTrees();

            // Midground bushes
            drawBushes();

            // Rain
            updateRain(dt * growthSpeed);
            drawRain();

            // Snow
            updateSnow(dt * growthSpeed);
            drawSnow();

            // Tree (above ground)
            if (tree) {
                tree.update(dt);
                tree.draw();
            }

            // Birds
            updateBirds(dt * growthSpeed);
            drawBirds();

            // Falling leaves
            updateFallingLeaves(dt * growthSpeed);
            drawFallingLeaves();

            // Ground (includes underground)
            drawGround();

            // Roots (underground)
            for (const r of roots) {
                r.update(dt);
                r.draw();
            }

            // Snow on ground
            drawSnowGround();

            // Grass and flowers
            drawGrass();
            updateFlowers();
            drawFlowers();

            // Fireflies
            updateFireflies(dt * growthSpeed);
            drawFireflies();

            // Update season label
            updateSeasonLabel();

            // Film grain (update every few frames for performance)
            grainTimer += dt;
            if (grainTimer > 0.1) {
                grainTimer = 0;
                updateGrain();
            }
        }

        // --- Init ---
        function init() {
            resize();
            time = 0;
            seasonTime = 0;
            fallingLeaves = [];
            raindrops = [];
            puddles = [];
            snowflakes = [];
            snowPiles = [];
            flowers = [];
            birds = [];
            createTree();
            initFireflies(40);
            initStars();
            initGrass();
            initBgTrees();
            initBushes();
            lastTime = performance.now();
            if (animId) cancelAnimationFrame(animId);
            animId = requestAnimationFrame(animate);
        }

        // --- Expose reset ---
        window.reset = function() {
            init();
        };

        // --- Pause toggle ---
        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                paused = !paused;
                if (!paused) lastTime = performance.now();
            }
        });

        init();
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
