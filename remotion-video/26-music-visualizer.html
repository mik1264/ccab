<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio-Reactive Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: pointer;
        }
        canvas { display: block; }

        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
        }

        .film-grain {
            position: fixed;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            pointer-events: none;
            z-index: 11;
            opacity: 0.06;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="200" height="200" filter="url(%23n)" opacity="1"/></svg>');
            animation: grainShift 0.5s steps(4) infinite;
        }
        @keyframes grainShift {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-5%, -5%); }
            50% { transform: translate(5%, -3%); }
            75% { transform: translate(-3%, 5%); }
            100% { transform: translate(0, 0); }
        }

        .start-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            background: rgba(0, 0, 0, 0.85);
            transition: opacity 0.8s ease;
        }
        .start-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .start-overlay h1 {
            color: rgba(100, 200, 255, 0.9);
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }
        .start-overlay p {
            color: rgba(100, 200, 255, 0.5);
            font-size: 1rem;
            letter-spacing: 0.15em;
        }
        .pulse-ring {
            width: 120px; height: 120px;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 50%;
            margin: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulseRing 2s ease-in-out infinite;
        }
        .pulse-ring::after {
            content: '\25B6';
            color: rgba(100, 200, 255, 0.7);
            font-size: 2.5rem;
            padding-left: 0.3rem;
        }
        @keyframes pulseRing {
            0%, 100% { transform: scale(1); border-color: rgba(100, 200, 255, 0.2); }
            50% { transform: scale(1.1); border-color: rgba(100, 200, 255, 0.6); }
        }

        .hud {
            position: fixed;
            z-index: 15;
            color: rgba(200, 220, 255, 0.6);
            font-size: 0.7rem;
            pointer-events: none;
            letter-spacing: 0.05em;
        }
        .hud-top-right {
            top: 1rem; right: 1rem;
            text-align: right;
        }
        .hud-top-center {
            top: 1rem; left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.85rem;
        }
        .hud-bottom-left {
            bottom: 1rem; left: 1rem;
        }

        .info-panel {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(100, 200, 255, 0.4);
            font-size: 0.7rem;
            z-index: 15;
            text-align: center;
            letter-spacing: 0.1em;
            pointer-events: none;
            transition: opacity 0.5s;
            line-height: 1.6;
            max-width: 600px;
        }

        .controls-bar {
            position: fixed;
            bottom: 4rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.4rem;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        body:hover .controls-bar { opacity: 1; pointer-events: auto; }
        .ctrl-btn {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(200,220,255,0.7);
            font-family: 'Courier New', monospace;
            font-size: 0.65rem;
            padding: 0.35rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        .ctrl-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
        .ctrl-btn.active { background: rgba(100,200,255,0.25); border-color: rgba(100,200,255,0.5); color: #fff; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="vignette"></div>
    <div class="film-grain"></div>

    <div class="start-overlay" id="startOverlay">
        <h1>Visualizer</h1>
        <div class="pulse-ring"></div>
        <p>Click anywhere to start audio</p>
    </div>

    <a href="index.html" class="back-link" style="position:fixed;top:1rem;left:1rem;color:rgba(100,200,255,0.6);text-decoration:none;font-family:monospace;font-size:0.85rem;z-index:20;transition:color 0.3s">&#8592; Back to Gallery</a>

    <div class="hud hud-top-right" id="hudRight"></div>
    <div class="hud hud-top-center" id="hudCenter"></div>
    <div class="hud hud-bottom-left" id="hudLeft"></div>

    <div class="controls-bar" id="controlsBar">
        <button class="ctrl-btn" id="btnMic" title="Microphone input">MIC</button>
        <button class="ctrl-btn" id="btnReverb" title="Toggle reverb">RVB</button>
        <button class="ctrl-btn" id="btnDelay" title="Toggle delay">DLY</button>
        <button class="ctrl-btn" id="btnDistort" title="Toggle distortion">DST</button>
        <button class="ctrl-btn" id="btnKaleid" title="Kaleidoscope">KALEID</button>
        <button class="ctrl-btn" id="btnRecord" title="Record clip">REC</button>
    </div>

    <div class="info-panel" id="infoPanel">
        1-6 modes &middot; C theme &middot; K kaleidoscope &middot; M mic &middot; SPACE pause &middot; R reset &middot; ? help
    </div>

    <script>
    (function() {
        'use strict';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('startOverlay');
        const hudRight = document.getElementById('hudRight');
        const hudCenter = document.getElementById('hudCenter');
        const hudLeft = document.getElementById('hudLeft');

        let W, H, cx, cy;
        let audioCtx, analyser, analyserL, analyserR, freqData, timeData, freqDataL, freqDataR;
        let splitter;
        let running = false;
        let paused = false;
        let animId = null;
        let particles = [];
        let hueBase = 200;
        let lastBassHit = 0;
        let bassFlash = 0;
        let time = 0;
        let cameraShake = { x: 0, y: 0 };
        let bgShapes = [];

        // Oscillator state
        let oscillators = [];
        let gainNodes = [];
        let masterGain, effectsChain;

        // Effects nodes
        let reverbNode, delayNode, distortionNode;
        let reverbActive = false, delayActive = false, distortionActive = false;

        // Microphone
        let micStream = null;
        let micSource = null;
        let usingMic = false;

        // Visualization modes
        const MODE_NAMES = ['Circular Spectrum', 'Linear Bars', 'Radial Web', 'Waveform Tunnel', 'Particle Fountain', '3D Tunnel'];
        let vizMode = 0;
        let kaleidoscope = false;

        // Color themes
        const THEMES = {
            synthwave: { name: 'Synthwave', hues: [300, 180], sat: 90, bg: [10, 0, 30] },
            matrix:    { name: 'Matrix',    hues: [120, 140], sat: 80, bg: [0, 8, 0] },
            fire:      { name: 'Fire',      hues: [0, 40],    sat: 95, bg: [15, 2, 0] },
            ice:       { name: 'Ice',       hues: [190, 220], sat: 70, bg: [0, 5, 20] },
            rainbow:   { name: 'Rainbow',   hues: [0, 360],   sat: 85, bg: [5, 0, 10] },
            default:   { name: 'Cinematic', hues: [200, 280], sat: 75, bg: [0, 0, 0] }
        };
        const THEME_KEYS = Object.keys(THEMES);
        let currentThemeIdx = 5; // default
        let theme = THEMES.default;

        // Peak hold data
        let peakHold = [];
        let peakDecay = [];
        const PEAK_BARS = 128;
        for (let i = 0; i < PEAK_BARS; i++) { peakHold[i] = 0; peakDecay[i] = 0; }

        // Beat detection
        let beatHistory = [];
        let beatTimes = [];
        let bpm = 0;
        let lastBeatTime = 0;
        let beatEnergy = 0;
        let beatThreshold = 1.3;

        // Recording
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;

        // Musical scales and chord progressions
        const NOTE_FREQ = (n) => 440 * Math.pow(2, (n - 69) / 12);
        // Cm: C Eb G, Fm: F Ab C, Gm: G Bb D, Ab: Ab C Eb
        const CHORDS = [
            [60, 63, 67],       // Cm
            [65, 68, 72],       // Fm
            [67, 70, 74],       // Gm
            [68, 72, 75],       // Ab
        ];
        const BASS_NOTES = [36, 41, 43, 44]; // C2, F2, G2, Ab2
        const ARPEGGIO_PATTERNS = [
            [0, 1, 2, 1],
            [0, 2, 1, 2],
            [2, 1, 0, 1],
            [0, 1, 2, 0, 1, 2]
        ];
        let currentChord = 0;
        let beatCount = 0;
        let schedulerTimer = null;
        let nextBeatTime = 0;
        const TEMPO = 120; // BPM for generated music
        const BEAT_DURATION = 60 / TEMPO;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            initBgShapes();
        }
        resize();
        window.addEventListener('resize', resize);

        function initBgShapes() {
            bgShapes = [];
            const count = 8 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                bgShapes.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    sides: 3 + Math.floor(Math.random() * 4), // tri, quad, pent, hex
                    size: 30 + Math.random() * 80,
                    baseSize: 30 + Math.random() * 80,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.005,
                    freqBand: Math.floor(Math.random() * 4), // 0=sub, 1=bass, 2=mid, 3=treble
                    alpha: 0,
                    drift: { x: (Math.random() - 0.5) * 0.3, y: (Math.random() - 0.5) * 0.3 }
                });
            }
        }

        // --- Audio Effects ---
        function createReverb() {
            const convolver = audioCtx.createConvolver();
            const rate = audioCtx.sampleRate;
            const length = rate * 2.5;
            const impulse = audioCtx.createBuffer(2, length, rate);
            for (let ch = 0; ch < 2; ch++) {
                const data = impulse.getChannelData(ch);
                for (let i = 0; i < length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                }
            }
            convolver.buffer = impulse;
            return convolver;
        }

        function createDelay() {
            const delay = audioCtx.createDelay(1.0);
            delay.delayTime.value = 0.35;
            const feedback = audioCtx.createGain();
            feedback.gain.value = 0.3;
            const wet = audioCtx.createGain();
            wet.gain.value = 0.4;
            delay.connect(feedback);
            feedback.connect(delay);
            delay.connect(wet);
            return { input: delay, output: wet };
        }

        function createDistortion() {
            const ws = audioCtx.createWaveShaper();
            const samples = 44100;
            const curve = new Float32Array(samples);
            const amount = 20;
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount) * x * 20 * (Math.PI / 180)) / (Math.PI + amount * Math.abs(x));
            }
            ws.curve = curve;
            ws.oversample = '4x';
            return ws;
        }

        function rebuildEffectsChain() {
            if (!audioCtx || !masterGain) return;
            // Disconnect everything from masterGain onward
            masterGain.disconnect();
            if (reverbNode) { try { reverbNode.disconnect(); } catch(e){} }
            if (delayNode) { try { delayNode.input.disconnect(); delayNode.output.disconnect(); } catch(e){} }
            if (distortionNode) { try { distortionNode.disconnect(); } catch(e){} }

            let chain = masterGain;

            if (distortionActive && distortionNode) {
                chain.connect(distortionNode);
                chain = distortionNode;
            }
            if (delayActive && delayNode) {
                chain.connect(delayNode.input);
                delayNode.output.connect(splitter ? analyser : analyser);
                // Also pass dry signal
            }
            if (reverbActive && reverbNode) {
                const reverbGain = audioCtx.createGain();
                reverbGain.gain.value = 0.4;
                chain.connect(reverbNode);
                reverbNode.connect(reverbGain);
                reverbGain.connect(analyser);
            }

            chain.connect(analyser);
            analyser.connect(audioCtx.destination);

            if (splitter) {
                analyser.connect(splitter);
            }
        }

        // --- Procedural Audio Engine ---
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 4096;
            analyser.smoothingTimeConstant = 0.8;
            freqData = new Uint8Array(analyser.frequencyBinCount);
            timeData = new Uint8Array(analyser.frequencyBinCount);

            // Stereo split
            splitter = audioCtx.createChannelSplitter(2);
            analyserL = audioCtx.createAnalyser();
            analyserR = audioCtx.createAnalyser();
            analyserL.fftSize = 2048;
            analyserR.fftSize = 2048;
            freqDataL = new Uint8Array(analyserL.frequencyBinCount);
            freqDataR = new Uint8Array(analyserR.frequencyBinCount);

            analyser.connect(splitter);
            splitter.connect(analyserL, 0);
            splitter.connect(analyserR, 1);

            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.25;

            // Create effects
            reverbNode = createReverb();
            delayNode = createDelay();
            distortionNode = createDistortion();

            masterGain.connect(analyser);
            analyser.connect(audioCtx.destination);
            analyser.connect(splitter);

            startProceduralMusic();
        }

        // --- Richer Procedural Music ---
        function startProceduralMusic() {
            // Low drone pad
            createDrone(NOTE_FREQ(36), 'sine', 0.1);     // C2
            createDrone(NOTE_FREQ(43), 'sine', 0.06);     // G2
            createDrone(NOTE_FREQ(48), 'triangle', 0.04); // C3

            nextBeatTime = audioCtx.currentTime + 0.1;
            scheduleBeat();
        }

        function createDrone(freq, type, vol) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.frequency.value = 0.08 + Math.random() * 0.2;
            lfoGain.gain.value = freq * 0.008;
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            lfo.start();
            gain.gain.value = vol;
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            oscillators.push(osc, lfo);
            gainNodes.push(gain);
        }

        function playNote(freq, duration, startTime, vol, type) {
            if (!audioCtx || audioCtx.state === 'closed') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = type || 'sine';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = 1500 + Math.random() * 2500;
            filter.Q.value = 2;

            const v = vol || 0.06;
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(v, startTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            osc.start(startTime);
            osc.stop(startTime + duration + 0.05);
        }

        function playKick(startTime) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, startTime);
            osc.frequency.exponentialRampToValueAtTime(30, startTime + 0.15);
            gain.gain.setValueAtTime(0.4, startTime);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(startTime);
            osc.stop(startTime + 0.35);
        }

        function playHihat(startTime, open) {
            const bufSize = audioCtx.sampleRate * (open ? 0.15 : 0.05);
            const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, open ? 2 : 8);
            }
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            const hp = audioCtx.createBiquadFilter();
            hp.type = 'highpass';
            hp.frequency.value = 7000;
            const gain = audioCtx.createGain();
            gain.gain.value = open ? 0.08 : 0.06;
            src.connect(hp);
            hp.connect(gain);
            gain.connect(masterGain);
            src.start(startTime);
        }

        function scheduleBeat() {
            if (!running) return;
            while (nextBeatTime < audioCtx.currentTime + 0.2) {
                const beatInBar = beatCount % 16;
                const chordIdx = Math.floor((beatCount % 64) / 16);
                currentChord = chordIdx % CHORDS.length;
                const chord = CHORDS[currentChord];
                const bass = BASS_NOTES[currentChord];

                // Kick on beats 0, 4, 8, 12
                if (beatInBar % 4 === 0) {
                    playKick(nextBeatTime);
                }

                // Hi-hat on 8th notes
                if (beatInBar % 2 === 0) {
                    playHihat(nextBeatTime, beatInBar % 8 === 4);
                }

                // Bass note on beat 0 of each chord
                if (beatInBar === 0) {
                    playNote(NOTE_FREQ(bass), BEAT_DURATION * 3, nextBeatTime, 0.12, 'sawtooth');
                }

                // Arpeggio pattern
                const arpPattern = ARPEGGIO_PATTERNS[currentChord % ARPEGGIO_PATTERNS.length];
                const arpIdx = arpPattern[beatInBar % arpPattern.length];
                const arpNote = chord[arpIdx];
                if (beatInBar % 2 === 0) {
                    playNote(NOTE_FREQ(arpNote), BEAT_DURATION * 0.8, nextBeatTime, 0.04, 'sine');
                }
                // High octave arp
                if (beatInBar % 4 === 2) {
                    playNote(NOTE_FREQ(arpNote + 12), BEAT_DURATION * 0.5, nextBeatTime, 0.025, 'triangle');
                }

                // Melody â€” longer notes on some beats
                if (beatInBar === 0 && Math.random() > 0.3) {
                    const melodyNote = chord[Math.floor(Math.random() * 3)] + 12;
                    playNote(NOTE_FREQ(melodyNote), BEAT_DURATION * 4, nextBeatTime + BEAT_DURATION * 0.5, 0.05, 'sine');
                }
                if (beatInBar === 8 && Math.random() > 0.5) {
                    const melodyNote = chord[Math.floor(Math.random() * 3)] + 12;
                    playNote(NOTE_FREQ(melodyNote), BEAT_DURATION * 2, nextBeatTime, 0.04, 'triangle');
                }

                nextBeatTime += BEAT_DURATION / 4; // 16th note grid
                beatCount++;
            }
            schedulerTimer = setTimeout(scheduleBeat, 50);
        }

        // --- Microphone Input ---
        async function toggleMic() {
            if (usingMic) {
                // Switch back to generated
                if (micStream) {
                    micStream.getTracks().forEach(t => t.stop());
                    micStream = null;
                }
                if (micSource) {
                    micSource.disconnect();
                    micSource = null;
                }
                usingMic = false;
                document.getElementById('btnMic').classList.remove('active');
                // Restart music
                startProceduralMusic();
                return;
            }
            try {
                micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Stop generated music
                oscillators.forEach(o => { try { o.stop(); } catch(e) {} });
                oscillators = [];
                gainNodes = [];
                if (schedulerTimer) clearTimeout(schedulerTimer);

                micSource = audioCtx.createMediaStreamSource(micStream);
                micSource.connect(analyser);
                usingMic = true;
                document.getElementById('btnMic').classList.add('active');
            } catch (e) {
                console.warn('Microphone access denied:', e);
            }
        }

        // --- Particle System ---
        class Particle {
            constructor(x, y, vx, vy, life, hue, size, type) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.life = life; this.maxLife = life;
                this.hue = hue; this.size = size;
                this.type = type || 'circle'; // circle, star, line
                this.gravity = type === 'fountain' ? 0.08 : 0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.985;
                this.vy *= 0.985;
                this.life--;
            }
            draw(ctx) {
                const alpha = (this.life / this.maxLife) * 0.8;
                const s = this.size * (0.3 + 0.7 * this.life / this.maxLife);
                const h = this.hue;
                ctx.fillStyle = `hsla(${h}, 85%, 65%, ${alpha})`;
                if (this.type === 'star') {
                    drawStar(ctx, this.x, this.y, 5, s, s * 0.4, alpha, h);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, s, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawStar(ctx, x, y, points, outer, inner, alpha, hue) {
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const r = i % 2 === 0 ? outer : inner;
                const a = (i * Math.PI) / points - Math.PI / 2;
                const px = x + Math.cos(a) * r;
                const py = y + Math.sin(a) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = `hsla(${hue}, 85%, 65%, ${alpha})`;
            ctx.fill();
        }

        function emitBassParticles(intensity) {
            const count = Math.floor(intensity * 0.3);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * intensity * 0.06;
                particles.push(new Particle(
                    cx + cameraShake.x, cy + cameraShake.y,
                    Math.cos(angle) * speed, Math.sin(angle) * speed,
                    40 + Math.floor(Math.random() * 60),
                    getThemeHue(Math.random()), 2 + Math.random() * 4,
                    Math.random() > 0.7 ? 'star' : 'circle'
                ));
            }
        }

        function emitFountainParticles(bass) {
            const count = Math.floor(bass * 0.15);
            for (let i = 0; i < count; i++) {
                const spread = (Math.random() - 0.5) * 4;
                particles.push(new Particle(
                    cx + spread * 20, H * 0.85,
                    spread, -4 - Math.random() * bass * 0.04,
                    60 + Math.floor(Math.random() * 80),
                    getThemeHue(Math.random()), 1.5 + Math.random() * 3,
                    'fountain'
                ));
            }
        }

        // --- Color Themes ---
        function getThemeHue(t) {
            const h0 = theme.hues[0];
            const h1 = theme.hues[1];
            if (theme.name === 'Rainbow') return (time * 0.5 + t * 360) % 360;
            return h0 + (h1 - h0) * t;
        }

        function cycleTheme() {
            currentThemeIdx = (currentThemeIdx + 1) % THEME_KEYS.length;
            theme = THEMES[THEME_KEYS[currentThemeIdx]];
        }

        // --- Beat Detection ---
        function detectBeat() {
            const bass = getFrequencyAvg(0, 15);
            beatHistory.push(bass);
            if (beatHistory.length > 60) beatHistory.shift();

            const avg = beatHistory.reduce((a, b) => a + b, 0) / beatHistory.length;
            beatEnergy = bass / (avg + 1);

            if (beatEnergy > beatThreshold && time - lastBeatTime > 12) {
                lastBeatTime = time;
                const now = performance.now();
                beatTimes.push(now);
                if (beatTimes.length > 20) beatTimes.shift();

                // Calculate BPM from intervals
                if (beatTimes.length > 3) {
                    let totalInterval = 0;
                    let count = 0;
                    for (let i = 1; i < beatTimes.length; i++) {
                        const diff = beatTimes[i] - beatTimes[i - 1];
                        if (diff > 200 && diff < 2000) {
                            totalInterval += diff;
                            count++;
                        }
                    }
                    if (count > 0) {
                        const avgInterval = totalInterval / count;
                        bpm = Math.round(60000 / avgInterval);
                        if (bpm > 200) bpm = Math.round(bpm / 2);
                        if (bpm < 60) bpm = Math.round(bpm * 2);
                    }
                }

                // Visual events on beat
                bassFlash = 1;
                cameraShake.x = (Math.random() - 0.5) * 8;
                cameraShake.y = (Math.random() - 0.5) * 8;
                emitBassParticles(bass);
                return true;
            }
            return false;
        }

        // --- Frequency helpers ---
        function getFrequencyAvg(start, end) {
            let sum = 0;
            for (let i = start; i < end && i < freqData.length; i++) sum += freqData[i];
            return sum / Math.max(1, end - start);
        }

        function getBandValue(band) {
            const len = freqData.length;
            switch(band) {
                case 0: return getFrequencyAvg(0, 5) / 255;       // sub
                case 1: return getFrequencyAvg(2, 15) / 255;      // bass
                case 2: return getFrequencyAvg(15, 100) / 255;    // mid
                case 3: return getFrequencyAvg(100, 400) / 255;   // treble
                default: return 0;
            }
        }

        // --- Hz label for a bin ---
        function binToHz(bin) {
            if (!audioCtx) return 0;
            return bin * audioCtx.sampleRate / (analyser.fftSize);
        }

        // --- Update peak hold ---
        function updatePeakHold() {
            const step = Math.floor(freqData.length / PEAK_BARS);
            for (let i = 0; i < PEAK_BARS; i++) {
                const idx = Math.min(i * step, freqData.length - 1);
                const val = freqData[idx] / 255;
                if (val >= peakHold[i]) {
                    peakHold[i] = val;
                    peakDecay[i] = 0;
                } else {
                    peakDecay[i]++;
                    if (peakDecay[i] > 20) {
                        peakHold[i] -= 0.015;
                        if (peakHold[i] < 0) peakHold[i] = 0;
                    }
                }
            }
        }

        // ========== VISUALIZATION MODES ==========

        // --- Mode 0: Circular Spectrum ---
        function drawCircularSpectrum() {
            const barCount = 180;
            const innerRadius = Math.min(W, H) * 0.12;
            const maxBarHeight = Math.min(W, H) * 0.22;
            const step = Math.floor(freqData.length / barCount);

            for (let i = 0; i < barCount; i++) {
                const angle = (i / barCount) * Math.PI * 2 - Math.PI / 2;
                const freqIdx = Math.min(i * step, freqData.length - 1);
                const val = freqData[freqIdx] / 255;
                const barH = val * maxBarHeight + 2;

                const x1 = cx + Math.cos(angle) * innerRadius;
                const y1 = cy + Math.sin(angle) * innerRadius;
                const x2 = cx + Math.cos(angle) * (innerRadius + barH);
                const y2 = cy + Math.sin(angle) * (innerRadius + barH);

                const hue = getThemeHue(i / barCount);
                const alpha = 0.4 + val * 0.6;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = `hsla(${hue}, ${theme.sat}%, ${50 + val * 30}%, ${alpha})`;
                ctx.lineWidth = Math.max(1.5, (W / barCount) * 0.6);
                ctx.lineCap = 'round';
                ctx.stroke();

                // Mirror bar inward
                if (val > 0.3) {
                    const x3 = cx + Math.cos(angle) * (innerRadius - barH * 0.3);
                    const y3 = cy + Math.sin(angle) * (innerRadius - barH * 0.3);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x3, y3);
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${alpha * 0.4})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Peak indicator
                const peakI = Math.min(Math.floor(i * PEAK_BARS / barCount), PEAK_BARS - 1);
                const pk = peakHold[peakI];
                if (pk > 0.05) {
                    const pkR = innerRadius + pk * maxBarHeight;
                    const px = cx + Math.cos(angle) * pkR;
                    const py = cy + Math.sin(angle) * pkR;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${hue}, 100%, 80%, 0.8)`;
                    ctx.fill();
                }
            }

            // Center glow
            const bass = getFrequencyAvg(0, 10) / 255;
            const glowR = innerRadius * 0.8;
            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
            grd.addColorStop(0, `hsla(${getThemeHue(0.5)}, 80%, 60%, ${0.15 + bass * 0.3})`);
            grd.addColorStop(1, 'transparent');
            ctx.beginPath();
            ctx.arc(cx, cy, glowR, 0, Math.PI * 2);
            ctx.fillStyle = grd;
            ctx.fill();
        }

        // --- Mode 1: Linear Bars with Hz Labels ---
        function drawLinearBars() {
            const bars = PEAK_BARS;
            const barW = W / bars;
            const step = Math.floor(freqData.length / bars);
            const maxH = H * 0.6;

            // Left channel (top half) and Right channel (bottom half)
            for (let i = 0; i < bars; i++) {
                const idx = Math.min(i * step, freqData.length - 1);
                const valL = freqDataL ? freqDataL[Math.min(idx, freqDataL.length - 1)] / 255 : freqData[idx] / 255;
                const valR = freqDataR ? freqDataR[Math.min(idx, freqDataR.length - 1)] / 255 : freqData[idx] / 255;
                const hue = getThemeHue(i / bars);

                // Left channel bars going up from center
                const hL = valL * maxH * 0.5;
                ctx.fillStyle = `hsla(${hue}, ${theme.sat}%, 55%, ${0.4 + valL * 0.5})`;
                ctx.fillRect(i * barW, cy - hL, barW - 1, hL);

                // Right channel bars going down from center
                const hR = valR * maxH * 0.5;
                ctx.fillStyle = `hsla(${hue}, ${theme.sat}%, 55%, ${0.4 + valR * 0.5})`;
                ctx.fillRect(i * barW, cy, barW - 1, hR);

                // Peak hold (left)
                const pk = peakHold[i];
                if (pk > 0.05) {
                    ctx.fillStyle = `hsla(${hue}, 100%, 80%, 0.9)`;
                    ctx.fillRect(i * barW, cy - pk * maxH * 0.5 - 2, barW - 1, 2);
                }

                // Hz labels every ~10 bars
                if (i % 12 === 0 && i > 0) {
                    const hz = binToHz(idx);
                    let label = hz < 1000 ? Math.round(hz) + 'Hz' : (hz / 1000).toFixed(1) + 'k';
                    ctx.fillStyle = 'rgba(200,220,255,0.25)';
                    ctx.font = '9px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, i * barW + barW / 2, cy + maxH * 0.5 + 14);
                }
            }

            // Stereo labels
            ctx.fillStyle = 'rgba(200,220,255,0.2)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('L', 8, cy - 10);
            ctx.fillText('R', 8, cy + 18);
        }

        // --- Mode 2: Radial Web ---
        function drawRadialWeb() {
            const nodes = 64;
            const layers = 5;
            const maxRadius = Math.min(W, H) * 0.4;
            const step = Math.floor(freqData.length / nodes);

            for (let layer = 0; layer < layers; layer++) {
                const baseR = maxRadius * (0.15 + layer * 0.18);
                ctx.beginPath();
                for (let i = 0; i <= nodes; i++) {
                    const idx = Math.min((i % nodes) * step + layer * 3, freqData.length - 1);
                    const val = freqData[idx] / 255;
                    const angle = (i / nodes) * Math.PI * 2 - Math.PI / 2;
                    const r = baseR + val * maxRadius * 0.2;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                const hue = getThemeHue(layer / layers);
                ctx.strokeStyle = `hsla(${hue}, ${theme.sat}%, 60%, ${0.15 + layer * 0.08})`;
                ctx.lineWidth = 1 + layer * 0.3;
                ctx.stroke();

                // Fill with low alpha
                ctx.fillStyle = `hsla(${hue}, ${theme.sat}%, 50%, 0.02)`;
                ctx.fill();
            }

            // Connecting spokes
            for (let i = 0; i < nodes; i += 4) {
                const angle = (i / nodes) * Math.PI * 2 - Math.PI / 2;
                const idx = Math.min(i * step, freqData.length - 1);
                const val = freqData[idx] / 255;
                if (val > 0.2) {
                    const r1 = maxRadius * 0.15;
                    const r2 = maxRadius * (0.15 + layers * 0.18) + val * maxRadius * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(cx + Math.cos(angle) * r1, cy + Math.sin(angle) * r1);
                    ctx.lineTo(cx + Math.cos(angle) * r2, cy + Math.sin(angle) * r2);
                    ctx.strokeStyle = `hsla(${getThemeHue(i / nodes)}, 60%, 55%, ${val * 0.2})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // --- Mode 3: Waveform Tunnel ---
        function drawWaveformTunnel() {
            const rings = 30;
            const pointsPerRing = 128;
            const maxR = Math.min(W, H) * 0.5;

            for (let r = rings - 1; r >= 0; r--) {
                const ringT = r / rings;
                const phase = time * 0.02 + r * 0.15;
                const radius = maxR * (0.05 + ringT * 0.95);
                const z = (r + (time * 0.05) % 1) / rings; // scroll effect
                const alpha = (1 - ringT) * 0.3;
                const hue = getThemeHue(ringT);

                ctx.beginPath();
                for (let i = 0; i <= pointsPerRing; i++) {
                    const angle = (i / pointsPerRing) * Math.PI * 2;
                    const tdIdx = Math.floor((i / pointsPerRing) * timeData.length);
                    const waveVal = (timeData[tdIdx] / 128 - 1);
                    const wobble = waveVal * 20 * (1 - ringT * 0.5);
                    const px = cx + Math.cos(angle + phase) * (radius + wobble);
                    const py = cy + Math.sin(angle + phase) * (radius + wobble);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = `hsla(${hue}, ${theme.sat}%, 60%, ${alpha})`;
                ctx.lineWidth = 1.2 - ringT * 0.6;
                ctx.stroke();
            }
        }

        // --- Mode 4: Particle Fountain ---
        function drawParticleFountain() {
            const bass = getFrequencyAvg(0, 10) / 255;
            emitFountainParticles(bass * 255);

            // Draw frequency arcs at bottom
            const barCount = 80;
            const step = Math.floor(freqData.length / barCount);
            for (let i = 0; i < barCount; i++) {
                const idx = Math.min(i * step, freqData.length - 1);
                const val = freqData[idx] / 255;
                const x = (i / barCount) * W;
                const h = val * H * 0.15;
                const hue = getThemeHue(i / barCount);
                ctx.fillStyle = `hsla(${hue}, ${theme.sat}%, 55%, ${0.3 + val * 0.4})`;
                ctx.fillRect(x, H - h, W / barCount - 1, h);
            }
        }

        // --- Mode 5: 3D Tunnel ---
        function draw3DTunnel() {
            const segmentCount = 40;
            const slices = 32;
            const tunnelLength = 20;

            for (let s = segmentCount - 1; s >= 0; s--) {
                const z = (s + (time * 0.04 % 1)) / segmentCount;
                const perspScale = 1 / (0.5 + z * 2);
                const baseRadius = Math.min(W, H) * 0.4 * perspScale;
                const freqIdx = Math.floor((s / segmentCount) * freqData.length * 0.5);
                const val = freqData[Math.min(freqIdx, freqData.length - 1)] / 255;
                const hue = getThemeHue(s / segmentCount);
                const alpha = (1 - z) * 0.4;

                ctx.beginPath();
                for (let i = 0; i <= slices; i++) {
                    const angle = (i / slices) * Math.PI * 2;
                    const modR = baseRadius + val * baseRadius * 0.4 * Math.sin(angle * 3 + time * 0.03);
                    const px = cx + Math.cos(angle) * modR;
                    const py = cy + Math.sin(angle) * modR;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = `hsla(${hue}, ${theme.sat}%, ${50 + val * 30}%, ${alpha})`;
                ctx.lineWidth = 1.5 * perspScale;
                ctx.stroke();
            }
        }

        // ========== BACKGROUND GEOMETRY ==========
        function drawBgShapes() {
            for (const shape of bgShapes) {
                const bandVal = getBandValue(shape.freqBand);
                shape.size = shape.baseSize * (0.8 + bandVal * 1.5);
                shape.rotation += shape.rotSpeed * (1 + bandVal * 3);
                shape.x += shape.drift.x;
                shape.y += shape.drift.y;
                shape.alpha = 0.02 + bandVal * 0.08;

                // Wrap
                if (shape.x < -100) shape.x = W + 100;
                if (shape.x > W + 100) shape.x = -100;
                if (shape.y < -100) shape.y = H + 100;
                if (shape.y > H + 100) shape.y = -100;

                ctx.save();
                ctx.translate(shape.x, shape.y);
                ctx.rotate(shape.rotation);
                ctx.beginPath();
                for (let i = 0; i < shape.sides; i++) {
                    const a = (i / shape.sides) * Math.PI * 2 - Math.PI / 2;
                    const px = Math.cos(a) * shape.size;
                    const py = Math.sin(a) * shape.size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                const hue = getThemeHue(shape.freqBand / 4);
                ctx.strokeStyle = `hsla(${hue}, ${theme.sat}%, 50%, ${shape.alpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
        }

        // ========== WAVEFORM OVERLAY ==========
        function drawWaveform() {
            const sliceWidth = W / timeData.length;
            ctx.beginPath();
            let x = 0;
            for (let i = 0; i < timeData.length; i++) {
                const v = timeData[i] / 128.0;
                const y = cy + (v - 1) * H * 0.2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                x += sliceWidth;
            }
            ctx.strokeStyle = `hsla(${getThemeHue(0.3)}, 60%, 60%, 0.15)`;
            ctx.lineWidth = 1.2;
            ctx.stroke();
        }

        // ========== ORBIT RINGS ==========
        function drawOrbitRings() {
            const treble = getFrequencyAvg(freqData.length * 0.6, freqData.length * 0.9) / 255;
            const mid = getFrequencyAvg(freqData.length * 0.2, freqData.length * 0.5) / 255;
            for (let r = 0; r < 3; r++) {
                const radius = Math.min(W, H) * (0.25 + r * 0.08);
                const rotSpeed = (r % 2 === 0 ? 1 : -1) * 0.0005 * (1 + treble);
                const rotation = time * rotSpeed + r * 1.2;
                ctx.beginPath();
                ctx.ellipse(cx, cy, radius, radius * 0.3, rotation, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${getThemeHue(r / 3)}, 50%, 55%, ${0.04 + mid * 0.08})`;
                ctx.lineWidth = 0.8;
                ctx.stroke();
            }
        }

        // ========== CONNECTING LINES ==========
        function drawConnectingLines() {
            const points = [];
            const barCount = 60;
            const innerRadius = Math.min(W, H) * 0.12;
            const maxBarHeight = Math.min(W, H) * 0.22;
            const step = Math.floor(freqData.length / barCount);
            for (let i = 0; i < barCount; i++) {
                const angle = (i / barCount) * Math.PI * 2 - Math.PI / 2;
                const freqIdx = Math.min(i * step, freqData.length - 1);
                const val = freqData[freqIdx] / 255;
                if (val > 0.5) {
                    const r = innerRadius + val * maxBarHeight;
                    points.push({ x: cx + Math.cos(angle) * r, y: cy + Math.sin(angle) * r });
                }
            }
            if (points.length > 2) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                ctx.closePath();
                ctx.strokeStyle = `hsla(${getThemeHue(0.2)}, 50%, 50%, 0.06)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // ========== BACKGROUND ==========
        function drawBackground() {
            const bg = theme.bg;
            ctx.fillStyle = `rgba(${bg[0]}, ${bg[1]}, ${bg[2]}, ${0.15 + bassFlash * 0.1})`;
            ctx.fillRect(0, 0, W, H);

            if (bassFlash > 0) {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.6);
                grd.addColorStop(0, `hsla(${getThemeHue(0.5)}, 60%, 20%, ${bassFlash * 0.15})`);
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, W, H);
                bassFlash *= 0.92;
            }
        }

        // ========== KALEIDOSCOPE ==========
        function applyKaleidoscope() {
            if (!kaleidoscope) return;
            const segments = 6;
            const angleStep = (Math.PI * 2) / segments;
            const imgData = ctx.getImageData(0, 0, W, H);
            // Take a wedge from top-center and mirror it
            ctx.save();
            ctx.clearRect(0, 0, W, H);
            for (let i = 0; i < segments; i++) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angleStep * i);
                if (i % 2 === 1) ctx.scale(1, -1);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(W, 0);
                ctx.lineTo(W, -H);
                ctx.lineTo(0, -H);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(canvas, -cx, -cy);
                ctx.restore();
            }
            ctx.restore();
        }

        // ========== HUD ==========
        function updateHUD() {
            const modeLabel = MODE_NAMES[vizMode];
            hudCenter.textContent = modeLabel;
            hudRight.innerHTML =
                (bpm > 0 ? 'BPM: ' + bpm + '<br>' : '') +
                'Theme: ' + theme.name +
                (kaleidoscope ? '<br>KALEIDOSCOPE' : '') +
                (usingMic ? '<br>MIC INPUT' : '') +
                (isRecording ? '<br>REC' : '');
            hudLeft.innerHTML =
                (reverbActive ? 'RVB ' : '') +
                (delayActive ? 'DLY ' : '') +
                (distortionActive ? 'DST' : '');
        }

        // ========== RECORDING ==========
        function toggleRecording() {
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('btnRecord').classList.remove('active');
                return;
            }
            const stream = canvas.captureStream(30);
            // Also capture audio if available
            if (audioCtx && audioCtx.state === 'running') {
                const dest = audioCtx.createMediaStreamDestination();
                analyser.connect(dest);
                for (const track of dest.stream.getAudioTracks()) {
                    stream.addTrack(track);
                }
            }
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'visualizer-clip.webm';
                a.click();
                URL.revokeObjectURL(url);
            };
            mediaRecorder.start();
            isRecording = true;
            document.getElementById('btnRecord').classList.add('active');
            // Auto-stop after 15 seconds
            setTimeout(() => { if (isRecording) toggleRecording(); }, 15000);
        }

        // ========== MAIN LOOP ==========
        function animate() {
            if (!running) return;
            if (paused) {
                animId = requestAnimationFrame(animate);
                return;
            }

            time++;

            analyser.getByteFrequencyData(freqData);
            analyser.getByteTimeDomainData(timeData);
            if (analyserL) { analyserL.getByteFrequencyData(freqDataL); }
            if (analyserR) { analyserR.getByteFrequencyData(freqDataR); }

            updatePeakHold();
            detectBeat();

            // Dampen camera shake
            cameraShake.x *= 0.9;
            cameraShake.y *= 0.9;

            // Color shift for default theme
            if (theme.name === 'Cinematic') {
                const bass = getFrequencyAvg(0, 10);
                const mid = getFrequencyAvg(10, 100);
                const treble = getFrequencyAvg(100, 400);
                if (bass > mid && bass > treble) hueBase += (0 - hueBase) * 0.01;
                else if (mid > bass && mid > treble) hueBase += (200 - hueBase) * 0.01;
                else hueBase += (280 - hueBase) * 0.01;
                hueBase = ((hueBase % 360) + 360) % 360;
            }

            // Apply camera shake
            ctx.save();
            ctx.translate(cameraShake.x, cameraShake.y);

            // Draw
            drawBackground();
            drawBgShapes();
            drawOrbitRings();

            // Active viz mode
            switch (vizMode) {
                case 0: drawCircularSpectrum(); drawWaveform(); drawConnectingLines(); break;
                case 1: drawLinearBars(); break;
                case 2: drawRadialWeb(); break;
                case 3: drawWaveformTunnel(); break;
                case 4: drawParticleFountain(); break;
                case 5: draw3DTunnel(); break;
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw(ctx);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            if (particles.length > 800) particles.splice(0, particles.length - 800);

            ctx.restore();

            applyKaleidoscope();

            // HUD update every 10 frames
            if (time % 10 === 0) updateHUD();

            animId = requestAnimationFrame(animate);
        }

        // --- Start / Reset ---
        function start() {
            if (running) return;
            initAudio();
            running = true;
            overlay.classList.add('hidden');
            animate();
        }

        function stopAudio() {
            if (schedulerTimer) clearTimeout(schedulerTimer);
            oscillators.forEach(o => { try { o.stop(); } catch(e) {} });
            oscillators = [];
            gainNodes = [];
            if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
            if (micSource) { micSource.disconnect(); micSource = null; }
            usingMic = false;
            if (audioCtx) { audioCtx.close(); audioCtx = null; }
        }

        window.reset = function() {
            running = false;
            paused = false;
            if (animId) cancelAnimationFrame(animId);
            stopAudio();
            particles = [];
            time = 0;
            hueBase = 200;
            bassFlash = 0;
            beatHistory = [];
            beatTimes = [];
            bpm = 0;
            vizMode = 0;
            kaleidoscope = false;
            currentThemeIdx = 5;
            theme = THEMES.default;
            reverbActive = false; delayActive = false; distortionActive = false;
            isRecording = false;
            for (let i = 0; i < PEAK_BARS; i++) { peakHold[i] = 0; peakDecay[i] = 0; }
            document.querySelectorAll('.ctrl-btn').forEach(b => b.classList.remove('active'));
            ctx.clearRect(0, 0, W, H);
            overlay.classList.remove('hidden');
            hudRight.textContent = '';
            hudCenter.textContent = '';
            hudLeft.textContent = '';
        };

        // Click to start
        overlay.addEventListener('click', function(e) {
            e.stopPropagation();
            start();
        });
        canvas.addEventListener('click', function() {
            if (!running) start();
        });

        // Button handlers
        document.getElementById('btnMic').addEventListener('click', e => { e.stopPropagation(); if (running) toggleMic(); });
        document.getElementById('btnReverb').addEventListener('click', e => {
            e.stopPropagation();
            reverbActive = !reverbActive;
            e.target.classList.toggle('active', reverbActive);
            rebuildEffectsChain();
        });
        document.getElementById('btnDelay').addEventListener('click', e => {
            e.stopPropagation();
            delayActive = !delayActive;
            e.target.classList.toggle('active', delayActive);
            rebuildEffectsChain();
        });
        document.getElementById('btnDistort').addEventListener('click', e => {
            e.stopPropagation();
            distortionActive = !distortionActive;
            e.target.classList.toggle('active', distortionActive);
            rebuildEffectsChain();
        });
        document.getElementById('btnKaleid').addEventListener('click', e => {
            e.stopPropagation();
            kaleidoscope = !kaleidoscope;
            e.target.classList.toggle('active', kaleidoscope);
        });
        document.getElementById('btnRecord').addEventListener('click', e => {
            e.stopPropagation();
            if (running) toggleRecording();
        });

        // Keyboard
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                if (running) {
                    paused = !paused;
                    if (paused && audioCtx) audioCtx.suspend();
                    if (!paused && audioCtx) audioCtx.resume();
                }
            }
            // Number keys for viz modes
            if (e.key >= '1' && e.key <= '6') {
                vizMode = parseInt(e.key) - 1;
            }
            // C for theme cycle
            if (e.key === 'c' || e.key === 'C') {
                cycleTheme();
            }
            // K for kaleidoscope
            if (e.key === 'k' || e.key === 'K') {
                kaleidoscope = !kaleidoscope;
                document.getElementById('btnKaleid').classList.toggle('active', kaleidoscope);
            }
            // M for mic
            if (e.key === 'm' || e.key === 'M') {
                if (running) toggleMic();
            }
        });
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
