<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burning Ship Fractal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 150, 50, 0.3);
            z-index: 100;
            min-width: 280px;
        }

        h1 {
            font-size: 1.4em;
            margin-bottom: 5px;
            color: #ff9933;
        }

        .subtitle {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #aaa;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid rgba(255, 150, 50, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ff9933;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #ff6600, #ff9933);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 100, 0, 0.4);
        }

        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 8px;
            font-size: 0.8em;
            background: rgba(60, 60, 80, 0.8);
        }

        .preset-btn:hover {
            background: rgba(255, 100, 0, 0.3);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.85em;
            border: 1px solid rgba(255, 150, 50, 0.3);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #ff9933;
            font-family: 'Consolas', monospace;
        }

        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.85em;
            border: 1px solid rgba(255, 150, 50, 0.3);
            max-width: 220px;
        }

        .instructions h3 {
            color: #ff9933;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style: none;
            padding: 0;
        }

        .instructions li {
            margin: 5px 0;
            color: #aaa;
        }

        .instructions kbd {
            background: rgba(255, 150, 50, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #ff9933;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(255, 150, 50, 0.3);
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(255, 100, 0, 0.2);
        }

        .rendering {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.95);
            padding: 30px 50px;
            border-radius: 12px;
            border: 1px solid rgba(255, 150, 50, 0.5);
            display: none;
        }

        .rendering.active {
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 150, 50, 0.2);
            border-top-color: #ff9933;
            border-radius: 50%;
            margin: 0 auto 15px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üî• Burning Ship Fractal</h1>
        <p class="subtitle">z ‚Üí (|Re(z)| + i|Im(z)|)¬≤ + c</p>

        <div class="control-group">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="fire">Fire</option>
                <option value="ocean">Deep Ocean</option>
                <option value="electric">Electric</option>
                <option value="grayscale">Grayscale</option>
                <option value="rainbow">Rainbow</option>
                <option value="sunset">Sunset</option>
            </select>
        </div>

        <div class="control-group">
            <label>Max Iterations: <span id="iterValue">200</span></label>
            <input type="range" id="maxIter" min="50" max="1000" value="200" step="50">
        </div>

        <div class="control-group">
            <label>Smooth Coloring</label>
            <select id="smoothing">
                <option value="smooth">Smooth (Continuous)</option>
                <option value="bands">Bands</option>
                <option value="histogram">Histogram Equalized</option>
            </select>
        </div>

        <div class="btn-row">
            <button onclick="resetView()">Reset View</button>
            <button onclick="render()">Re-render</button>
        </div>

        <label style="margin-top: 15px;">Zoom Presets</label>
        <div class="presets">
            <button class="preset-btn" onclick="loadPreset('ship')">The Ship</button>
            <button class="preset-btn" onclick="loadPreset('antenna')">Antenna</button>
            <button class="preset-btn" onclick="loadPreset('spiral')">Spiral</button>
            <button class="preset-btn" onclick="loadPreset('armada')">Armada</button>
        </div>
    </div>

    <div class="instructions">
        <h3>Controls</h3>
        <ul>
            <li><kbd>Drag</kbd> Select zoom area</li>
            <li><kbd>Scroll</kbd> Zoom in/out</li>
            <li><kbd>Right-click</kbd> Zoom out</li>
            <li><kbd>Shift+Drag</kbd> Pan view</li>
        </ul>
    </div>

    <div class="info">
        <div class="info-row">
            <span class="info-label">Center X:</span>
            <span class="info-value" id="centerX">-0.4</span>
        </div>
        <div class="info-row">
            <span class="info-label">Center Y:</span>
            <span class="info-value" id="centerY">-0.6</span>
        </div>
        <div class="info-row">
            <span class="info-label">Zoom:</span>
            <span class="info-value" id="zoomLevel">1x</span>
        </div>
    </div>

    <div class="rendering" id="rendering">
        <div class="spinner"></div>
        <div>Rendering...</div>
    </div>

    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Fractal parameters
        let centerX = -0.4;
        let centerY = -0.6;
        let zoom = 0.8;
        let maxIterations = 200;

        // Interaction state
        let isDragging = false;
        let isPanning = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };

        // Color schemes
        const colorSchemes = {
            fire: (t) => {
                const r = Math.min(255, t * 3 * 255);
                const g = Math.min(255, Math.max(0, (t - 0.33) * 3 * 255));
                const b = Math.min(255, Math.max(0, (t - 0.66) * 3 * 255));
                return [r, g, b];
            },
            ocean: (t) => {
                const r = Math.floor(9 * (1 - t) * t * t * t * 255);
                const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
                const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255 + 100 * t);
                return [r, g, Math.min(255, b + 50)];
            },
            electric: (t) => {
                const phase = t * Math.PI * 2;
                const r = Math.floor(Math.sin(phase) * 127 + 128);
                const g = Math.floor(Math.sin(phase + 2) * 127 + 128);
                const b = Math.floor(Math.sin(phase + 4) * 127 + 128);
                return [r, g, b];
            },
            grayscale: (t) => {
                const v = Math.floor(t * 255);
                return [v, v, v];
            },
            rainbow: (t) => {
                const h = t * 360;
                return hslToRgb(h, 100, 50);
            },
            sunset: (t) => {
                if (t < 0.5) {
                    const tt = t * 2;
                    return [
                        Math.floor(255 * tt + 50 * (1 - tt)),
                        Math.floor(100 * tt),
                        Math.floor(150 * (1 - tt))
                    ];
                } else {
                    const tt = (t - 0.5) * 2;
                    return [
                        Math.floor(255 * (1 - tt * 0.3)),
                        Math.floor(100 + 155 * tt),
                        Math.floor(50 * tt)
                    ];
                }
            }
        };

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;

            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return [
                Math.floor((r + m) * 255),
                Math.floor((g + m) * 255),
                Math.floor((b + m) * 255)
            ];
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function screenToComplex(sx, sy) {
            const aspect = canvas.width / canvas.height;
            const scale = 3 / zoom;

            const x = centerX + (sx / canvas.width - 0.5) * scale * aspect;
            const y = centerY + (sy / canvas.height - 0.5) * scale;

            return { x, y };
        }

        function burningShip(cx, cy, maxIter) {
            let x = 0, y = 0;
            let x2 = 0, y2 = 0;
            let iteration = 0;

            while (x2 + y2 <= 4 && iteration < maxIter) {
                // The key difference: take absolute values before squaring
                y = Math.abs(2 * x * y) + cy;
                x = x2 - y2 + cx;

                x2 = x * x;
                y2 = y * y;
                iteration++;
            }

            if (iteration === maxIter) {
                return -1; // Inside the set
            }

            // Smooth coloring using escape time algorithm
            // Add a few more iterations for smoother result
            for (let i = 0; i < 2; i++) {
                y = Math.abs(2 * x * y) + cy;
                x = x2 - y2 + cx;
                x2 = x * x;
                y2 = y * y;
                iteration++;
            }

            const log_zn = Math.log(x2 + y2) / 2;
            const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);

            return iteration + 1 - nu;
        }

        function render() {
            const renderingEl = document.getElementById('rendering');
            renderingEl.classList.add('active');

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;

                const colorScheme = document.getElementById('colorScheme').value;
                const smoothing = document.getElementById('smoothing').value;
                const colorFn = colorSchemes[colorScheme];

                const aspect = canvas.width / canvas.height;
                const scale = 3 / zoom;

                // For histogram equalization
                const histogram = new Array(maxIterations + 1).fill(0);
                const iterations = new Float32Array(canvas.width * canvas.height);

                // First pass: calculate iterations
                for (let py = 0; py < canvas.height; py++) {
                    for (let px = 0; px < canvas.width; px++) {
                        const cx = centerX + (px / canvas.width - 0.5) * scale * aspect;
                        const cy = centerY + (py / canvas.height - 0.5) * scale;

                        const iter = burningShip(cx, cy, maxIterations);
                        const idx = py * canvas.width + px;
                        iterations[idx] = iter;

                        if (iter >= 0 && smoothing === 'histogram') {
                            histogram[Math.floor(iter)]++;
                        }
                    }
                }

                // Build cumulative histogram for equalization
                let total = 0;
                const cumulative = histogram.map(h => {
                    total += h;
                    return total;
                });

                // Second pass: apply colors
                for (let py = 0; py < canvas.height; py++) {
                    for (let px = 0; px < canvas.width; px++) {
                        const idx = py * canvas.width + px;
                        const iter = iterations[idx];
                        const pixelIdx = idx * 4;

                        if (iter < 0) {
                            // Inside the set - black
                            data[pixelIdx] = 0;
                            data[pixelIdx + 1] = 0;
                            data[pixelIdx + 2] = 0;
                            data[pixelIdx + 3] = 255;
                        } else {
                            let t;

                            if (smoothing === 'smooth') {
                                t = (iter % 50) / 50;
                            } else if (smoothing === 'bands') {
                                t = (Math.floor(iter) % 16) / 16;
                            } else {
                                // Histogram equalized
                                const iterInt = Math.floor(iter);
                                t = cumulative[iterInt] / total;
                            }

                            const [r, g, b] = colorFn(t);
                            data[pixelIdx] = r;
                            data[pixelIdx + 1] = g;
                            data[pixelIdx + 2] = b;
                            data[pixelIdx + 3] = 255;
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                updateInfo();
                renderingEl.classList.remove('active');
            }, 10);
        }

        function updateInfo() {
            document.getElementById('centerX').textContent = centerX.toFixed(10);
            document.getElementById('centerY').textContent = centerY.toFixed(10);
            document.getElementById('zoomLevel').textContent = zoom.toFixed(2) + 'x';
        }

        function resetView() {
            centerX = -0.4;
            centerY = -0.6;
            zoom = 0.8;
            render();
        }

        function loadPreset(name) {
            const presets = {
                ship: { x: -1.762, y: -0.028, z: 20 },
                antenna: { x: -1.859, y: -0.0, z: 50 },
                spiral: { x: -1.755, y: -0.025, z: 200 },
                armada: { x: -1.94, y: -0.001, z: 100 }
            };

            const p = presets[name];
            centerX = p.x;
            centerY = p.y;
            zoom = p.z;
            render();
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                // Right click - zoom out
                e.preventDefault();
                zoom *= 0.5;
                render();
                return;
            }

            dragStart = { x: e.clientX, y: e.clientY };

            if (e.shiftKey) {
                isPanning = true;
            } else {
                isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;

                const scale = 3 / zoom;
                const aspect = canvas.width / canvas.height;

                centerX -= (dx / canvas.width) * scale * aspect;
                centerY -= (dy / canvas.height) * scale;

                dragStart = { x: e.clientX, y: e.clientY };
                render();
            } else if (isDragging) {
                dragEnd = { x: e.clientX, y: e.clientY };

                // Draw selection rectangle
                render();
                ctx.strokeStyle = 'rgba(255, 150, 50, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    dragStart.x,
                    dragStart.y,
                    dragEnd.x - dragStart.x,
                    dragEnd.y - dragStart.y
                );
                ctx.setLineDash([]);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDragging) {
                dragEnd = { x: e.clientX, y: e.clientY };

                const dx = Math.abs(dragEnd.x - dragStart.x);
                const dy = Math.abs(dragEnd.y - dragStart.y);

                if (dx > 10 && dy > 10) {
                    // Zoom to selection
                    const startComplex = screenToComplex(
                        Math.min(dragStart.x, dragEnd.x),
                        Math.min(dragStart.y, dragEnd.y)
                    );
                    const endComplex = screenToComplex(
                        Math.max(dragStart.x, dragEnd.x),
                        Math.max(dragStart.y, dragEnd.y)
                    );

                    centerX = (startComplex.x + endComplex.x) / 2;
                    centerY = (startComplex.y + endComplex.y) / 2;

                    const newWidth = Math.abs(endComplex.x - startComplex.x);
                    const newHeight = Math.abs(endComplex.y - startComplex.y);
                    const currentWidth = 3 / zoom * (canvas.width / canvas.height);

                    zoom *= currentWidth / newWidth;
                    render();
                }
            }

            isDragging = false;
            isPanning = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const mouseComplex = screenToComplex(e.clientX, e.clientY);

            if (e.deltaY < 0) {
                zoom *= 1.5;
            } else {
                zoom /= 1.5;
            }

            // Zoom toward mouse position
            const newMouseComplex = screenToComplex(e.clientX, e.clientY);
            centerX += mouseComplex.x - newMouseComplex.x;
            centerY += mouseComplex.y - newMouseComplex.y;

            render();
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        document.getElementById('maxIter').addEventListener('input', (e) => {
            maxIterations = parseInt(e.target.value);
            document.getElementById('iterValue').textContent = maxIterations;
        });

        document.getElementById('maxIter').addEventListener('change', render);
        document.getElementById('colorScheme').addEventListener('change', render);
        document.getElementById('smoothing').addEventListener('change', render);

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            render();
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { resize(); render(); };
        window.init = window.reset;

        resize();
        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
