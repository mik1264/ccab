<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Neighborhood Cellular Automata (MNCA)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            color: #e0e0e0;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ffaa;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 170, 0.3);
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .controls h2 {
            color: #00ffaa;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #888;
            font-size: 0.85rem;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 170, 0.3);
            border-radius: 5px;
            color: #e0e0e0;
        }

        .range-value {
            text-align: right;
            font-size: 0.8rem;
            color: #00ffaa;
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00ffaa, #00aaff);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 8px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button.secondary {
            background: rgba(0, 255, 170, 0.2);
            color: #00ffaa;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 5px;
            font-size: 0.75rem;
            background: rgba(0, 255, 170, 0.15);
            border: 1px solid rgba(0, 255, 170, 0.3);
            border-radius: 5px;
            color: #00ffaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(0, 255, 170, 0.3);
        }

        .preset-btn.active {
            background: rgba(0, 255, 170, 0.4);
            border-color: #00ffaa;
        }

        .info-panel {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 100, 70, 0.2);
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            color: #00ffaa;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #666;
        }

        .toggle-controls {
            position: fixed;
            top: 20px;
            right: 340px;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(0, 255, 170, 0.3);
            border-radius: 8px;
            padding: 8px 15px;
            color: #00ffaa;
            cursor: pointer;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 700px) {
            .controls {
                width: 90vw;
                right: 5vw;
            }
            .toggle-controls {
                right: auto;
                left: 80px;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">
        <span>‚Üê</span> Back to Gallery
    </a>

    <button class="toggle-controls" onclick="toggleControls()">Toggle Panel</button>

    <canvas id="canvas"></canvas>

    <div class="controls" id="controls">
        <h2>MNCA Controls</h2>

        <div class="control-group">
            <label>Preset</label>
            <div class="preset-grid">
                <button class="preset-btn active" onclick="loadPreset('amoeba')">Amoeba</button>
                <button class="preset-btn" onclick="loadPreset('mitosis')">Mitosis</button>
                <button class="preset-btn" onclick="loadPreset('worms')">Worms</button>
                <button class="preset-btn" onclick="loadPreset('blobs')">Blobs</button>
                <button class="preset-btn" onclick="loadPreset('coral')">Coral</button>
                <button class="preset-btn" onclick="loadPreset('cells')">Cells</button>
            </div>
        </div>

        <div class="control-group">
            <label>Simulation Speed: <span id="speedValue">1</span>x</label>
            <input type="range" id="speed" min="1" max="10" value="1">
        </div>

        <div class="control-group">
            <label>Resolution: <span id="resValue">1.0</span></label>
            <input type="range" id="resolution" min="0.25" max="1" step="0.25" value="1">
        </div>

        <div class="control-group">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="viridis">Viridis</option>
                <option value="plasma">Plasma</option>
                <option value="inferno">Inferno</option>
                <option value="ocean">Ocean</option>
                <option value="rainbow">Rainbow</option>
                <option value="grayscale">Grayscale</option>
            </select>
        </div>

        <button onclick="reset()">Reset</button>
        <button class="secondary" onclick="randomize()">Randomize Rules</button>
        <button class="secondary" onclick="togglePause()">Pause/Resume</button>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="fps">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="generation">0</div>
                <div class="stat-label">Generation</div>
            </div>
        </div>

        <div class="info-panel">
            <strong>MNCA</strong> uses multiple ring neighborhoods with different radii. Each neighborhood contributes to the update rule, creating complex organic behaviors like cell mitosis, amoeba movement, and worm-like structures.
            <br><br>
            Pioneered by <strong>Slackermanz</strong> on Reddit/GitHub.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 required');
            throw new Error('WebGL 2 not supported');
        }

        // Presets - different MNCA configurations
        const presets = {
            amoeba: {
                neighborhoods: [
                    { inner: 0, outer: 1 },
                    { inner: 3, outer: 5 },
                    { inner: 6, outer: 10 }
                ],
                thresholds: [
                    { birth: [0.15, 0.22], survive: [0.12, 0.37] },
                    { birth: [0.35, 0.48], survive: [0.24, 0.55] },
                    { birth: [0.50, 0.62], survive: [0.48, 0.68] }
                ]
            },
            mitosis: {
                neighborhoods: [
                    { inner: 0, outer: 2 },
                    { inner: 4, outer: 8 },
                    { inner: 10, outer: 14 }
                ],
                thresholds: [
                    { birth: [0.18, 0.28], survive: [0.14, 0.42] },
                    { birth: [0.32, 0.45], survive: [0.28, 0.52] },
                    { birth: [0.45, 0.58], survive: [0.40, 0.65] }
                ]
            },
            worms: {
                neighborhoods: [
                    { inner: 0, outer: 1 },
                    { inner: 2, outer: 4 },
                    { inner: 8, outer: 12 }
                ],
                thresholds: [
                    { birth: [0.25, 0.35], survive: [0.20, 0.45] },
                    { birth: [0.38, 0.50], survive: [0.30, 0.58] },
                    { birth: [0.48, 0.62], survive: [0.45, 0.72] }
                ]
            },
            blobs: {
                neighborhoods: [
                    { inner: 0, outer: 3 },
                    { inner: 5, outer: 9 }
                ],
                thresholds: [
                    { birth: [0.20, 0.32], survive: [0.15, 0.45] },
                    { birth: [0.40, 0.55], survive: [0.35, 0.62] }
                ]
            },
            coral: {
                neighborhoods: [
                    { inner: 0, outer: 2 },
                    { inner: 3, outer: 6 },
                    { inner: 8, outer: 15 }
                ],
                thresholds: [
                    { birth: [0.12, 0.25], survive: [0.08, 0.38] },
                    { birth: [0.28, 0.42], survive: [0.22, 0.50] },
                    { birth: [0.42, 0.58], survive: [0.38, 0.65] }
                ]
            },
            cells: {
                neighborhoods: [
                    { inner: 0, outer: 1 },
                    { inner: 4, outer: 7 },
                    { inner: 10, outer: 16 }
                ],
                thresholds: [
                    { birth: [0.22, 0.32], survive: [0.18, 0.40] },
                    { birth: [0.35, 0.48], survive: [0.30, 0.55] },
                    { birth: [0.52, 0.65], survive: [0.48, 0.72] }
                ]
            }
        };

        let currentPreset = 'amoeba';
        let paused = false;
        let generation = 0;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let resolution = 1.0;

        // Shader sources
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_position * 0.5 + 0.5;
            }
        `;

        function getUpdateShaderSource(preset) {
            const p = presets[preset];
            const numNeighborhoods = p.neighborhoods.length;

            let neighborhoodCode = '';
            for (let i = 0; i < numNeighborhoods; i++) {
                const n = p.neighborhoods[i];
                neighborhoodCode += `
                    float sum${i} = 0.0;
                    float count${i} = 0.0;
                    for (int dy = -${n.outer}; dy <= ${n.outer}; dy++) {
                        for (int dx = -${n.outer}; dx <= ${n.outer}; dx++) {
                            float dist = sqrt(float(dx*dx + dy*dy));
                            if (dist >= ${n.inner.toFixed(1)} && dist <= ${n.outer.toFixed(1)}) {
                                vec2 samplePos = (gl_FragCoord.xy + vec2(dx, dy)) / u_resolution;
                                sum${i} += texture(u_state, samplePos).r;
                                count${i} += 1.0;
                            }
                        }
                    }
                    float avg${i} = count${i} > 0.0 ? sum${i} / count${i} : 0.0;
                `;
            }

            let ruleCode = 'float newState = current;\n';
            for (let i = 0; i < numNeighborhoods; i++) {
                const t = p.thresholds[i];
                ruleCode += `
                    if (current < 0.5) {
                        if (avg${i} >= ${t.birth[0].toFixed(3)} && avg${i} <= ${t.birth[1].toFixed(3)}) {
                            newState = min(1.0, newState + 0.15);
                        }
                    } else {
                        if (avg${i} >= ${t.survive[0].toFixed(3)} && avg${i} <= ${t.survive[1].toFixed(3)}) {
                            newState = min(1.0, newState + 0.05);
                        } else if (avg${i} < ${t.survive[0].toFixed(3)} * 0.5 || avg${i} > ${t.survive[1].toFixed(3)} * 1.2) {
                            newState = max(0.0, newState - 0.08);
                        }
                    }
                `;
            }

            return `#version 300 es
                precision highp float;
                uniform sampler2D u_state;
                uniform vec2 u_resolution;
                out vec4 fragColor;

                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution;
                    float current = texture(u_state, uv).r;

                    ${neighborhoodCode}

                    ${ruleCode}

                    fragColor = vec4(newState, newState, newState, 1.0);
                }
            `;
        }

        const renderShaderSource = `#version 300 es
            precision highp float;
            uniform sampler2D u_state;
            uniform int u_colorScheme;
            in vec2 v_texCoord;
            out vec4 fragColor;

            vec3 viridis(float t) {
                vec3 c0 = vec3(0.267, 0.004, 0.329);
                vec3 c1 = vec3(0.282, 0.140, 0.457);
                vec3 c2 = vec3(0.254, 0.265, 0.530);
                vec3 c3 = vec3(0.207, 0.372, 0.553);
                vec3 c4 = vec3(0.163, 0.471, 0.558);
                vec3 c5 = vec3(0.127, 0.566, 0.550);
                vec3 c6 = vec3(0.135, 0.659, 0.518);
                vec3 c7 = vec3(0.267, 0.749, 0.441);
                vec3 c8 = vec3(0.478, 0.821, 0.318);
                vec3 c9 = vec3(0.741, 0.873, 0.150);
                vec3 c10 = vec3(0.993, 0.906, 0.144);

                if (t < 0.1) return mix(c0, c1, t * 10.0);
                if (t < 0.2) return mix(c1, c2, (t - 0.1) * 10.0);
                if (t < 0.3) return mix(c2, c3, (t - 0.2) * 10.0);
                if (t < 0.4) return mix(c3, c4, (t - 0.3) * 10.0);
                if (t < 0.5) return mix(c4, c5, (t - 0.4) * 10.0);
                if (t < 0.6) return mix(c5, c6, (t - 0.5) * 10.0);
                if (t < 0.7) return mix(c6, c7, (t - 0.6) * 10.0);
                if (t < 0.8) return mix(c7, c8, (t - 0.7) * 10.0);
                if (t < 0.9) return mix(c8, c9, (t - 0.8) * 10.0);
                return mix(c9, c10, (t - 0.9) * 10.0);
            }

            vec3 plasma(float t) {
                return vec3(
                    0.5 + 0.5 * sin(3.14159 * (t * 2.0)),
                    0.5 + 0.5 * sin(3.14159 * (t * 2.0 - 0.5)),
                    0.5 + 0.5 * sin(3.14159 * (t * 2.0 - 1.0))
                );
            }

            vec3 inferno(float t) {
                return vec3(
                    t,
                    t * t,
                    sin(t * 3.14159)
                );
            }

            vec3 ocean(float t) {
                return vec3(
                    0.0,
                    t * 0.5,
                    0.2 + t * 0.8
                );
            }

            vec3 rainbow(float t) {
                return vec3(
                    0.5 + 0.5 * sin(6.28318 * (t + 0.0)),
                    0.5 + 0.5 * sin(6.28318 * (t + 0.33)),
                    0.5 + 0.5 * sin(6.28318 * (t + 0.67))
                );
            }

            void main() {
                float state = texture(u_state, v_texCoord).r;
                vec3 color;

                if (u_colorScheme == 0) color = viridis(state);
                else if (u_colorScheme == 1) color = plasma(state);
                else if (u_colorScheme == 2) color = inferno(state);
                else if (u_colorScheme == 3) color = ocean(state);
                else if (u_colorScheme == 4) color = rainbow(state);
                else color = vec3(state);

                fragColor = vec4(color, 1.0);
            }
        `;

        let updateProgram, renderProgram;
        let stateTextures = [];
        let framebuffers = [];
        let currentState = 0;
        let quadVAO;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vsSource, fsSource) {
            const vs = createShader(gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function createTexture(width, height, data) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, width, height, 0, gl.RED, gl.FLOAT, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return texture;
        }

        function initWebGL() {
            // Check for float texture support
            const ext = gl.getExtension('EXT_color_buffer_float');
            if (!ext) {
                console.warn('EXT_color_buffer_float not available, using fallback');
            }

            // Create quad VAO
            const positions = new Float32Array([
                -1, -1,  1, -1,  -1, 1,
                -1,  1,  1, -1,   1, 1
            ]);

            quadVAO = gl.createVertexArray();
            gl.bindVertexArray(quadVAO);

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            // Create programs
            updateProgram = createProgram(vertexShaderSource, getUpdateShaderSource(currentPreset));
            renderProgram = createProgram(vertexShaderSource, renderShaderSource);

            // Initialize textures and framebuffers
            initStateBuffers();
        }

        function initStateBuffers() {
            const width = Math.floor(canvas.width * resolution);
            const height = Math.floor(canvas.height * resolution);

            // Random initial state
            const data = new Float32Array(width * height);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() < 0.4 ? Math.random() : 0;
            }

            // Create two textures for ping-pong rendering
            for (let i = 0; i < 2; i++) {
                if (stateTextures[i]) gl.deleteTexture(stateTextures[i]);
                if (framebuffers[i]) gl.deleteFramebuffer(framebuffers[i]);

                stateTextures[i] = createTexture(width, height, i === 0 ? data : null);

                framebuffers[i] = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[i]);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, stateTextures[i], 0);
            }

            currentState = 0;
            generation = 0;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            initStateBuffers();
        }

        function update() {
            const width = Math.floor(canvas.width * resolution);
            const height = Math.floor(canvas.height * resolution);

            gl.useProgram(updateProgram);
            gl.uniform2f(gl.getUniformLocation(updateProgram, 'u_resolution'), width, height);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1 - currentState]);
            gl.viewport(0, 0, width, height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_state'), 0);

            gl.bindVertexArray(quadVAO);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            currentState = 1 - currentState;
            generation++;
        }

        function render() {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.useProgram(renderProgram);

            const colorSchemes = ['viridis', 'plasma', 'inferno', 'ocean', 'rainbow', 'grayscale'];
            const scheme = colorSchemes.indexOf(document.getElementById('colorScheme').value);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_colorScheme'), scheme);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_state'), 0);

            gl.bindVertexArray(quadVAO);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function animate() {
            if (!paused) {
                const speed = parseInt(document.getElementById('speed').value);
                for (let i = 0; i < speed; i++) {
                    update();
                }
            }

            render();

            // Update FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }

            document.getElementById('generation').textContent = generation;

            requestAnimationFrame(animate);
        }

        function loadPreset(name) {
            currentPreset = name;

            // Update active button
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === name);
            });

            // Recreate update shader with new preset
            if (updateProgram) gl.deleteProgram(updateProgram);
            updateProgram = createProgram(vertexShaderSource, getUpdateShaderSource(name));

            reset();
        }

        function reset() {
            initStateBuffers();
        }

        function randomize() {
            // Generate random thresholds
            const randomPreset = {
                neighborhoods: [
                    { inner: 0, outer: Math.floor(Math.random() * 3) + 1 },
                    { inner: Math.floor(Math.random() * 4) + 2, outer: Math.floor(Math.random() * 6) + 4 },
                    { inner: Math.floor(Math.random() * 6) + 6, outer: Math.floor(Math.random() * 8) + 10 }
                ],
                thresholds: []
            };

            for (let i = 0; i < 3; i++) {
                const birthLow = Math.random() * 0.3 + 0.1;
                const birthHigh = birthLow + Math.random() * 0.2 + 0.1;
                const surviveLow = birthLow - Math.random() * 0.1;
                const surviveHigh = birthHigh + Math.random() * 0.15;
                randomPreset.thresholds.push({
                    birth: [birthLow, birthHigh],
                    survive: [surviveLow, surviveHigh]
                });
            }

            presets['random'] = randomPreset;
            loadPreset('random');
        }

        function togglePause() {
            paused = !paused;
        }

        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }

        // Event listeners
        document.getElementById('speed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        });

        document.getElementById('resolution').addEventListener('input', (e) => {
            document.getElementById('resValue').textContent = e.target.value;
            resolution = parseFloat(e.target.value);
            initStateBuffers();
        });

        window.addEventListener('resize', resize);

        // Mouse drawing
        let mouseDown = false;

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mouseleave', () => mouseDown = false);

        canvas.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;

            const width = Math.floor(canvas.width * resolution);
            const height = Math.floor(canvas.height * resolution);
            const x = Math.floor(e.clientX * resolution);
            const y = Math.floor((canvas.height - e.clientY) * resolution);

            // Create a small brush of activation
            const brushSize = 10;
            const brushData = new Float32Array(brushSize * brushSize);
            for (let i = 0; i < brushData.length; i++) {
                brushData[i] = 1.0;
            }

            gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
            gl.texSubImage2D(gl.TEXTURE_2D, 0,
                Math.max(0, x - brushSize/2),
                Math.max(0, y - brushSize/2),
                brushSize, brushSize,
                gl.RED, gl.FLOAT, brushData);
        });

        // Initialize
        resize();
        initWebGL();
        animate();
    </script>
</body>
</html>
