<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parameter Sweep - Gini Sensitivity</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #373B44 0%, #4286f4 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: white;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid white;
            border-radius: 10px;
            background: white;
        }
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        button {
            background: #2ECC71;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background: #27AE60;
        }
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            max-width: 600px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Parameter Sweep - Gini Sensitivity</h1>
    <p class="subtitle">Explore how vision range and metabolism affect final inequality</p>

    <div class="controls">
        <button id="runSweepBtn">Run Sweep</button>
        <button id="clearBtn">Clear</button>
    </div>

    <canvas id="canvas"></canvas>

    <div class="info">
        <p style="font-size: 12px;">
            <strong>Status:</strong> <span id="status">Click "Run Sweep" to begin</span>
        </p>
        <p style="font-size: 12px;">
            This heat map shows equilibrium Gini coefficients for different combinations of max vision (x-axis) and max metabolism (y-axis). Warmer colors = higher inequality.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 600;
        canvas.height = 500;

        const GRID_SIZE = 40;
        let sweepResults = {};
        let sweeping = false;

        class Agent {
            constructor(x, y, maxVision, maxMetab) {
                this.x = x;
                this.y = y;
                this.vision = Math.floor(Math.random() * maxVision) + 1;
                this.metabolism = Math.floor(Math.random() * maxMetab) + 1;
                this.wealth = 15;
                this.age = 0;
                this.maxAge = 200;
            }

            lookAround(sugarGrid, agents) {
                let bestPatch = { x: this.x, y: this.y, sugar: sugarGrid[this.y][this.x] };

                for (let d = 1; d <= this.vision; d++) {
                    const positions = [
                        { x: this.x, y: (this.y - d + GRID_SIZE) % GRID_SIZE },
                        { x: this.x, y: (this.y + d) % GRID_SIZE },
                        { x: (this.x - d + GRID_SIZE) % GRID_SIZE, y: this.y },
                        { x: (this.x + d) % GRID_SIZE, y: this.y }
                    ];

                    for (let pos of positions) {
                        const occupied = agents.some(a => a.x === pos.x && a.y === pos.y);
                        if (!occupied && sugarGrid[pos.y][pos.x] > bestPatch.sugar) {
                            bestPatch = { x: pos.x, y: pos.y, sugar: sugarGrid[pos.y][pos.x] };
                        }
                    }
                }

                return bestPatch;
            }

            move(sugarGrid, agents) {
                const bestPatch = this.lookAround(sugarGrid, agents);
                this.x = bestPatch.x;
                this.y = bestPatch.y;
                this.wealth += sugarGrid[this.y][this.x];
                sugarGrid[this.y][this.x] = 0;
                this.wealth -= this.metabolism;
                this.age++;
            }

            isDead() {
                return this.wealth <= 0 || this.age >= this.maxAge;
            }
        }

        function initSugarscape() {
            const sugarGrid = [];
            const maxSugar = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                sugarGrid[y] = [];
                maxSugar[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const dist1 = Math.sqrt(Math.pow(x - 15, 2) + Math.pow(y - 15, 2));
                    const dist2 = Math.sqrt(Math.pow(x - 25, 2) + Math.pow(y - 25, 2));
                    const sugar1 = Math.max(0, 4 - dist1 / 4);
                    const sugar2 = Math.max(0, 4 - dist2 / 4);
                    const sugar = Math.floor(Math.max(sugar1, sugar2));
                    sugarGrid[y][x] = sugar;
                    maxSugar[y][x] = sugar;
                }
            }

            return { sugarGrid, maxSugar };
        }

        function calculateGini(agents) {
            if (agents.length === 0) return 0;
            const wealths = agents.map(a => a.wealth).sort((a, b) => a - b);
            let sum = 0;
            let weightedSum = 0;

            for (let i = 0; i < wealths.length; i++) {
                sum += wealths[i];
                weightedSum += (i + 1) * wealths[i];
            }

            if (sum === 0) return 0;
            return (2 * weightedSum) / (wealths.length * sum) - (wealths.length + 1) / wealths.length;
        }

        async function runSimulation(maxVision, maxMetab, steps = 100) {
            const { sugarGrid, maxSugar } = initSugarscape();
            let agents = [];

            // Initialize agents
            for (let i = 0; i < 100; i++) {
                let x = Math.floor(Math.random() * GRID_SIZE);
                let y = Math.floor(Math.random() * GRID_SIZE);
                agents.push(new Agent(x, y, maxVision, maxMetab));
            }

            // Run simulation
            for (let step = 0; step < steps; step++) {
                agents.forEach(agent => agent.move(sugarGrid, agents));
                agents = agents.filter(agent => !agent.isDead());

                // Regenerate sugar
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (sugarGrid[y][x] < maxSugar[y][x]) {
                            sugarGrid[y][x]++;
                        }
                    }
                }
            }

            return calculateGini(agents);
        }

        async function runParameterSweep() {
            sweeping = true;
            sweepResults = {};

            const visionRange = [1, 2, 3, 4, 5, 6, 7, 8];
            const metabRange = [1, 2, 3, 4, 5, 6, 7, 8];

            let completed = 0;
            const total = visionRange.length * metabRange.length;

            for (let vision of visionRange) {
                for (let metab of metabRange) {
                    document.getElementById('status').textContent =
                        `Running ${completed}/${total} simulations...`;

                    const gini = await runSimulation(vision, metab, 150);
                    sweepResults[`${vision},${metab}`] = gini;

                    completed++;
                    drawHeatmap();

                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            document.getElementById('status').textContent = `Sweep complete! ${total} simulations run.`;
            sweeping = false;
        }

        function drawHeatmap() {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const margin = 80;
            const width = canvas.width - 2 * margin;
            const height = canvas.height - 2 * margin;

            const visionRange = [1, 2, 3, 4, 5, 6, 7, 8];
            const metabRange = [1, 2, 3, 4, 5, 6, 7, 8];

            const cellWidth = width / visionRange.length;
            const cellHeight = height / metabRange.length;

            // Find min/max for scaling
            const values = Object.values(sweepResults);
            const minGini = values.length > 0 ? Math.min(...values) : 0;
            const maxGini = values.length > 0 ? Math.max(...values) : 1;

            // Draw cells
            for (let i = 0; i < visionRange.length; i++) {
                for (let j = 0; j < metabRange.length; j++) {
                    const vision = visionRange[i];
                    const metab = metabRange[j];
                    const gini = sweepResults[`${vision},${metab}`];

                    if (gini !== undefined) {
                        const normalized = (gini - minGini) / (maxGini - minGini || 1);
                        const hue = 240 - normalized * 240; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;

                        const x = margin + i * cellWidth;
                        const y = margin + (metabRange.length - 1 - j) * cellHeight;

                        ctx.fillRect(x, y, cellWidth - 2, cellHeight - 2);

                        // Draw value
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(gini.toFixed(2), x + cellWidth / 2, y + cellHeight / 2);
                    }
                }
            }

            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, margin + height);
            ctx.lineTo(margin + width, margin + height);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';

            // X-axis labels
            for (let i = 0; i < visionRange.length; i++) {
                const x = margin + i * cellWidth + cellWidth / 2;
                ctx.fillText(visionRange[i], x, margin + height + 20);
            }

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let j = 0; j < metabRange.length; j++) {
                const y = margin + j * cellHeight + cellHeight / 2;
                ctx.fillText(metabRange[metabRange.length - 1 - j], margin - 10, y);
            }

            // Axis titles
            ctx.textAlign = 'center';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText('Max Vision Range', margin + width / 2, margin + height + 50);

            ctx.save();
            ctx.translate(25, margin + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Max Metabolism', 0, 0);
            ctx.restore();

            // Title
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Equilibrium Gini Coefficient Heatmap', margin + width / 2, 30);
        }

        document.getElementById('runSweepBtn').addEventListener('click', () => {
            if (!sweeping) {
                runParameterSweep();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            sweepResults = {};
            drawHeatmap();
            document.getElementById('status').textContent = 'Cleared. Click "Run Sweep" to begin';
        });

        drawHeatmap();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
