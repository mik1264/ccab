<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cobb-Douglas Welfare Function 3D</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1A2980 0%, #26D0CE 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: white;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid white;
            border-radius: 10px;
            background: white;
        }
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            max-width: 600px;
        }
        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-size: 16px;
            text-align: center;
        }
        .slider-group {
            margin: 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            float: right;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Cobb-Douglas Welfare Function 3D</h1>
    <p class="subtitle">W(sugar, spice) = sugar^(m₁/mₜ) × spice^(m₂/mₜ)</p>

    <canvas id="canvas"></canvas>

    <div class="info">
        <h3>Welfare Function Controls</h3>

        <div class="slider-group">
            <label>
                Sugar Metabolism (m₁): <span class="value-display" id="m1Val">2</span>
            </label>
            <input type="range" id="m1Slider" min="1" max="5" value="2" step="0.1">
        </div>

        <div class="slider-group">
            <label>
                Spice Metabolism (m₂): <span class="value-display" id="m2Val">2</span>
            </label>
            <input type="range" id="m2Slider" min="1" max="5" value="2" step="0.1">
        </div>

        <div class="formula">
            W = sugar^<span id="exp1">0.50</span> × spice^<span id="exp2">0.50</span>
        </div>

        <p style="font-size: 12px;">
            <strong>Interpretation:</strong> Agents optimize this utility function. Higher exponents mean stronger preference for that resource. Equal exponents create symmetric preferences. The function explains why agents trade: they seek to maximize W by balancing resource holdings according to their metabolic needs.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 600;
        canvas.height = 500;

        let m1 = 2;
        let m2 = 2;
        let rotation = 0;

        function welfare(sugar, spice, m1, m2) {
            const mt = m1 + m2;
            return Math.pow(sugar, m1 / mt) * Math.pow(spice, m2 / mt);
        }

        function draw3DSurface() {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 8;

            rotation += 0.005;

            // Generate welfare surface
            const points = [];
            for (let sugar = 1; sugar <= 30; sugar += 1) {
                for (let spice = 1; spice <= 30; spice += 1) {
                    const w = welfare(sugar, spice, m1, m2);

                    // 3D rotation
                    const x = sugar - 15;
                    const y = w;
                    const z = spice - 15;

                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);

                    const rotX = x * cosR - z * sinR;
                    const rotZ = x * sinR + z * cosR;

                    // Perspective projection
                    const distance = 400;
                    const perspective = distance / (distance + rotZ);

                    const screenX = centerX + rotX * scale * perspective;
                    const screenY = centerY - y * scale * perspective;

                    // Color based on welfare value
                    const maxW = welfare(30, 30, m1, m2);
                    const wRatio = w / maxW;

                    points.push({
                        x: screenX,
                        y: screenY,
                        z: rotZ,
                        w: wRatio
                    });
                }
            }

            // Sort by depth
            points.sort((a, b) => a.z - b.z);

            // Draw points
            points.forEach(point => {
                const hue = 240 - point.w * 200; // Blue to red gradient
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                const size = 2 + point.w * 3;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw axes labels
            ctx.fillStyle = '#000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';

            ctx.save();
            ctx.translate(50, centerY);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Welfare ↑', 0, 0);
            ctx.restore();

            ctx.fillText('Sugar →', canvas.width - 50, canvas.height - 20);
            ctx.fillText('Spice →', 50, canvas.height - 20);

            // Title
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Welfare Surface (rotating)', centerX, 30);

            // Color legend
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Low welfare', 20, 60);
            ctx.fillStyle = 'hsl(240, 70%, 50%)';
            ctx.fillRect(90, 52, 20, 10);

            ctx.fillStyle = '#000';
            ctx.fillText('High welfare', 120, 60);
            ctx.fillStyle = 'hsl(40, 70%, 50%)';
            ctx.fillRect(195, 52, 20, 10);
        }

        function updateDisplay() {
            const mt = m1 + m2;
            document.getElementById('m1Val').textContent = m1.toFixed(1);
            document.getElementById('m2Val').textContent = m2.toFixed(1);
            document.getElementById('exp1').textContent = (m1 / mt).toFixed(2);
            document.getElementById('exp2').textContent = (m2 / mt).toFixed(2);
        }

        function animate() {
            draw3DSurface();
            requestAnimationFrame(animate);
        }

        document.getElementById('m1Slider').addEventListener('input', (e) => {
            m1 = parseFloat(e.target.value);
            updateDisplay();
        });

        document.getElementById('m2Slider').addEventListener('input', (e) => {
            m2 = parseFloat(e.target.value);
            updateDisplay();
        });

        updateDisplay();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
