<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydrogen Orbitals - Quantum Visualizations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas {
            display: block;
            background: #0a0e1a;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(15, 20, 35, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            min-width: 300px;
        }

        .controls h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .orbital-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .orbital-btn {
            background: linear-gradient(135deg, #00d4ff, #9000ff);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
            font-size: 14px;
        }

        .orbital-btn:hover {
            transform: scale(1.05);
        }

        .orbital-btn.active {
            background: linear-gradient(135deg, #ff0080, #ff8000);
            box-shadow: 0 0 15px rgba(255, 0, 128, 0.5);
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(15, 20, 35, 0.9);
            color: #00d4ff;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            border: 1px solid rgba(100, 200, 255, 0.3);
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(20, 30, 50, 0.95);
            transform: translateX(-5px);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 20, 35, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            max-width: 450px;
        }

        .info h4 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
        }

        .orbital-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .info-label {
            color: #b0b0b0;
        }

        .info-value {
            color: #00d4ff;
            font-weight: bold;
        }

        .view-toggle {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            color: #b0b0b0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h3>Hydrogen Orbitals</h3>

        <div class="orbital-buttons">
            <button class="orbital-btn active" onclick="setOrbital('1s')">1s</button>
            <button class="orbital-btn" onclick="setOrbital('2s')">2s</button>
            <button class="orbital-btn" onclick="setOrbital('2px')">2p<sub>x</sub></button>
            <button class="orbital-btn" onclick="setOrbital('2py')">2p<sub>y</sub></button>
            <button class="orbital-btn" onclick="setOrbital('3dz2')">3d<sub>z²</sub></button>
            <button class="orbital-btn" onclick="setOrbital('3dxy')">3d<sub>xy</sub></button>
        </div>

        <div class="orbital-info">
            <div class="info-row">
                <span class="info-label">Orbital:</span>
                <span class="info-value" id="orbitalName">1s</span>
            </div>
            <div class="info-row">
                <span class="info-label">Principal (n):</span>
                <span class="info-value" id="principalN">1</span>
            </div>
            <div class="info-row">
                <span class="info-label">Angular (l):</span>
                <span class="info-value" id="angularL">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">Nodes:</span>
                <span class="info-value" id="nodesValue">0</span>
            </div>
        </div>

        <div class="view-toggle">
            2D Cross-Section (x-y plane)<br>
            Brightness = Probability Density
        </div>
    </div>

    <div class="info">
        <h4>Atomic Orbitals</h4>
        <p>
            Electrons in atoms don't orbit like planets. Instead, they exist in probability clouds
            called orbitals, described by quantum numbers n, l, and m.
        </p>
        <p style="margin-top: 10px;">
            <strong>Orbital types:</strong><br>
            • <strong>s orbitals</strong> (l=0): Spherically symmetric<br>
            • <strong>p orbitals</strong> (l=1): Dumbbell shaped, 3 orientations<br>
            • <strong>d orbitals</strong> (l=2): Complex shapes, 5 orientations
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // State
        let currentOrbital = '1s';
        let phase = 0;

        const orbitalData = {
            '1s': { n: 1, l: 0, name: '1s', nodes: 0 },
            '2s': { n: 2, l: 0, name: '2s', nodes: 1 },
            '2px': { n: 2, l: 1, name: '2pₓ', nodes: 0 },
            '2py': { n: 2, l: 1, name: '2pᵧ', nodes: 0 },
            '3dz2': { n: 3, l: 2, name: '3d<sub>z²</sub>', nodes: 0 },
            '3dxy': { n: 3, l: 2, name: '3d<sub>xy</sub>', nodes: 0 }
        };

        // Radial wave functions (simplified)
        function radialWaveFunction(orbital, r) {
            const a0 = 1; // Bohr radius (normalized)

            switch(orbital) {
                case '1s':
                    return 2 * Math.exp(-r / a0);
                case '2s':
                    return (1 / Math.sqrt(2)) * (2 - r / a0) * Math.exp(-r / (2 * a0));
                case '2px':
                case '2py':
                    return (1 / Math.sqrt(24)) * (r / a0) * Math.exp(-r / (2 * a0));
                case '3dz2':
                case '3dxy':
                    return (1 / Math.sqrt(2)) * (r * r / (a0 * a0)) * Math.exp(-r / (3 * a0));
                default:
                    return 0;
            }
        }

        // Angular wave functions
        function angularWaveFunction(orbital, x, y, z, r) {
            if (r < 0.001) return 0;

            switch(orbital) {
                case '1s':
                case '2s':
                    return 1; // Spherically symmetric

                case '2px':
                    return x / r;

                case '2py':
                    return y / r;

                case '3dz2':
                    // 3z² - r²
                    return (3 * z * z - r * r) / (r * r);

                case '3dxy':
                    return x * y / (r * r);

                default:
                    return 0;
            }
        }

        function getWaveFunction(orbital, x, y, z) {
            const r = Math.sqrt(x * x + y * y + z * z);
            const radial = radialWaveFunction(orbital, r);
            const angular = angularWaveFunction(orbital, x, y, z, r);
            return radial * angular;
        }

        function setOrbital(orbital) {
            currentOrbital = orbital;
            updateDisplay();

            // Update active button
            document.querySelectorAll('.orbital-btn').forEach(btn => {
                const btnText = btn.textContent.replace(/[₀₁₂₃₄]/g, '').toLowerCase();
                const isActive = btnText === orbital.toLowerCase() ||
                    (orbital === '2px' && btnText.includes('2px')) ||
                    (orbital === '2py' && btnText.includes('2py')) ||
                    (orbital === '3dz2' && btnText.includes('3dz')) ||
                    (orbital === '3dxy' && btnText.includes('3dxy'));
                btn.classList.toggle('active', isActive);
            });
        }

        function updateDisplay() {
            const data = orbitalData[currentOrbital];
            document.getElementById('orbitalName').textContent = data.name;
            document.getElementById('principalN').textContent = data.n;
            document.getElementById('angularL').textContent = data.l;
            document.getElementById('nodesValue').textContent = data.nodes;
        }

        function drawOrbital() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 60;

            // Draw in x-y plane (z=0 cross-section)
            const resolution = 3;
            const range = 8;

            for (let py = -range; py <= range; py += resolution / scale) {
                for (let px = -range; px <= range; px += resolution / scale) {
                    const x = px;
                    const y = py;
                    const z = 0;

                    const psi = getWaveFunction(currentOrbital, x, y, z);
                    const prob = psi * psi;

                    if (prob > 0.001) {
                        const screenX = centerX + x * scale;
                        const screenY = centerY + y * scale;

                        // Color based on sign and magnitude
                        let hue, brightness, alpha;

                        if (psi >= 0) {
                            hue = 200; // Cyan for positive
                            brightness = 50 + prob * 500;
                            alpha = Math.min(0.8, prob * 10);
                        } else {
                            hue = 280; // Purple for negative
                            brightness = 50 + prob * 500;
                            alpha = Math.min(0.8, prob * 10);
                        }

                        brightness = Math.min(100, brightness);

                        ctx.fillStyle = `hsla(${hue}, 100%, ${brightness}%, ${alpha})`;
                        ctx.fillRect(screenX, screenY, resolution, resolution);
                    }
                }
            }

            // Draw nucleus
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 15);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#ff0080');
            gradient.addColorStop(1, 'transparent');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
            ctx.fill();

            // Nucleus core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawAxes() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;

            // X axis
            ctx.beginPath();
            ctx.moveTo(centerX - 400, centerY);
            ctx.lineTo(centerX + 400, centerY);
            ctx.stroke();

            // Y axis
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - 400);
            ctx.lineTo(centerX, centerY + 400);
            ctx.stroke();

            // Labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x', centerX + 410, centerY + 5);

            ctx.save();
            ctx.translate(centerX - 10, centerY - 410);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('y', 0, 0);
            ctx.restore();
        }

        function drawContours() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 60;

            // Draw probability contours
            const contourLevels = [0.1, 0.05, 0.02, 0.01];
            const numPoints = 100;

            contourLevels.forEach((level, index) => {
                ctx.strokeStyle = `rgba(0, 212, 255, ${0.3 - index * 0.05})`;
                ctx.lineWidth = 1;

                // Approximate contour by sampling
                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    // Find radius where probability equals level
                    let foundRadius = 0;

                    for (let r = 0; r < 8; r += 0.1) {
                        const x = r * Math.cos(angle);
                        const y = r * Math.sin(angle);
                        const psi = getWaveFunction(currentOrbital, x, y, 0);
                        const prob = psi * psi;

                        if (prob >= level) {
                            foundRadius = r;
                            break;
                        }
                    }

                    if (foundRadius > 0) {
                        const screenX = centerX + foundRadius * Math.cos(angle) * scale;
                        const screenY = centerY + foundRadius * Math.sin(angle) * scale;

                        if (angle === 0) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                        } else {
                            ctx.lineTo(screenX, screenY);
                        }
                    }
                }

                ctx.stroke();
            });
        }

        function drawLegend() {
            const x = 50;
            const y = canvas.height - 120;

            // Background
            ctx.fillStyle = 'rgba(15, 20, 35, 0.8)';
            ctx.fillRect(x - 10, y - 10, 200, 80);

            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 10, y - 10, 200, 80);

            // Positive phase
            ctx.fillStyle = '#00d4ff';
            ctx.fillRect(x, y, 20, 20);
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Positive phase', x + 30, y + 15);

            // Negative phase
            ctx.fillStyle = '#9000ff';
            ctx.fillRect(x, y + 30, 20, 20);
            ctx.fillStyle = '#b0b0b0';
            ctx.fillText('Negative phase', x + 30, y + 45);
        }

        function animate() {
            phase += 0.02;

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawAxes();
            drawOrbital();
            drawContours();
            drawLegend();

            requestAnimationFrame(animate);
        }

        updateDisplay();
        animate();
    </script>
</body>
</html>
