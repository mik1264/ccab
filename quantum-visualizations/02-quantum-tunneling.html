<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Tunneling - Quantum Visualizations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas {
            display: block;
            background: #0a0e1a;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(15, 20, 35, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(144, 0, 255, 0.3);
            min-width: 280px;
        }

        .controls h3 {
            color: #9000ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #b0b0b0;
        }

        input[type="range"] {
            width: 100%;
        }

        button {
            background: linear-gradient(135deg, #9000ff, #00d4ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-bottom: 10px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(15, 20, 35, 0.9);
            color: #9000ff;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            border: 1px solid rgba(144, 0, 255, 0.3);
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(20, 30, 50, 0.95);
            transform: translateX(-5px);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 20, 35, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(144, 0, 255, 0.3);
            max-width: 400px;
        }

        .info h4 {
            color: #9000ff;
            margin-bottom: 10px;
        }

        .info p {
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0b0;
        }

        .stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(144, 0, 255, 0.2);
            font-size: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #b0b0b0;
        }

        .stat-value {
            color: #9000ff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h3>Quantum Tunneling</h3>
        <button id="launchBtn">Launch Particle</button>
        <button id="resetBtn">Reset Statistics</button>

        <div class="control-group">
            <label>Barrier Height: <span id="heightValue">50</span>%</label>
            <input type="range" id="heightSlider" min="20" max="90" value="50">
        </div>

        <div class="control-group">
            <label>Barrier Width: <span id="widthValue">100</span>px</label>
            <input type="range" id="widthSlider" min="50" max="200" value="100">
        </div>

        <div class="control-group">
            <label>Particle Energy: <span id="energyValue">30</span>%</label>
            <input type="range" id="energySlider" min="10" max="60" value="30">
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Transmitted:</span>
                <span class="stat-value" id="transmitted">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Reflected:</span>
                <span class="stat-value" id="reflected">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Tunnel Probability:</span>
                <span class="stat-value" id="probability">0%</span>
            </div>
        </div>
    </div>

    <div class="info">
        <h4>Quantum Tunneling</h4>
        <p>
            In classical physics, a particle with less energy than a barrier cannot pass through.
            But in quantum mechanics, there's a probability the particle can "tunnel" through!
        </p>
        <p style="margin-top: 10px;">
            <strong>Try it:</strong> Launch particles and watch how some magically pass through the barrier
            even when their energy (cyan) is less than the barrier height (purple).
            Adjust the barrier and particle energy to see how tunneling probability changes.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Configuration
        let barrierHeight = 0.5; // 0-1
        let barrierWidth = 100;
        let particleEnergy = 0.3; // 0-1

        const barrierX = canvas.width * 0.5;
        let transmitted = 0;
        let reflected = 0;

        const particles = [];
        const wavePackets = [];

        class Particle {
            constructor() {
                this.x = 100;
                this.y = canvas.height / 2;
                this.vx = 4;
                this.energy = particleEnergy;
                this.alive = true;
                this.isQuantum = true;
                this.inBarrier = false;
                this.transmitted = false;
                this.reflected = false;

                // Wave packet properties
                this.wavelength = 20 / (1 + this.energy);
                this.phase = 0;
                this.amplitude = 1;
            }

            update() {
                if (!this.alive) return;

                const centerY = canvas.height / 2;
                const barrierTop = centerY - barrierWidth / 2;
                const barrierBottom = centerY + barrierWidth / 2;

                // Check if in barrier
                this.inBarrier = this.x >= barrierX && this.x <= barrierX + barrierWidth;

                if (this.inBarrier && !this.transmitted && !this.reflected) {
                    // Calculate tunneling probability
                    const energyDeficit = barrierHeight - this.energy;
                    const tunnelingProb = Math.exp(-2 * barrierWidth * energyDeficit / 50);

                    // Quantum decision
                    if (Math.random() < tunnelingProb) {
                        this.transmitted = true;
                        this.amplitude = Math.sqrt(tunnelingProb);
                    } else {
                        this.reflected = true;
                        this.vx = -this.vx;
                    }
                }

                this.x += this.vx;
                this.phase += 0.3;

                // Decay amplitude in barrier if transmitting
                if (this.inBarrier && this.transmitted) {
                    const penetration = (this.x - barrierX) / barrierWidth;
                    this.amplitude = Math.exp(-penetration * 2);
                }

                // Restore amplitude after barrier
                if (this.transmitted && this.x > barrierX + barrierWidth) {
                    this.amplitude = Math.min(1, this.amplitude + 0.1);
                }

                // Remove if off screen
                if (this.x < 0 || this.x > canvas.width) {
                    this.alive = false;
                    if (this.transmitted) transmitted++;
                    if (this.reflected) reflected++;
                }
            }

            draw() {
                if (!this.alive) return;

                // Draw wave packet
                const numWaves = 5;
                for (let i = 0; i < numWaves; i++) {
                    const offset = (i - numWaves / 2) * this.wavelength;
                    const waveAlpha = this.amplitude * (1 - Math.abs(i - numWaves / 2) / numWaves);

                    ctx.strokeStyle = `rgba(0, 212, 255, ${waveAlpha * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    for (let x = -30; x <= 30; x += 2) {
                        const waveX = this.x + x;
                        const waveY = this.y + Math.sin((x / this.wavelength) * Math.PI * 2 + this.phase) * 15 * this.amplitude;
                        if (x === -30) {
                            ctx.moveTo(waveX, waveY);
                        } else {
                            ctx.lineTo(waveX, waveY);
                        }
                    }
                    ctx.stroke();
                }

                // Draw particle core
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 10);
                gradient.addColorStop(0, `rgba(0, 212, 255, ${this.amplitude})`);
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 10 * this.amplitude, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBarrier() {
            const centerY = canvas.height / 2;
            const barrierHeightPx = canvas.height * barrierHeight;

            // Draw barrier
            const gradient = ctx.createLinearGradient(barrierX, 0, barrierX + barrierWidth, 0);
            gradient.addColorStop(0, 'rgba(144, 0, 255, 0.3)');
            gradient.addColorStop(0.5, 'rgba(144, 0, 255, 0.6)');
            gradient.addColorStop(1, 'rgba(144, 0, 255, 0.3)');

            ctx.fillStyle = gradient;
            ctx.fillRect(
                barrierX,
                centerY - barrierHeightPx / 2,
                barrierWidth,
                barrierHeightPx
            );

            // Draw barrier outline
            ctx.strokeStyle = '#9000ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                barrierX,
                centerY - barrierHeightPx / 2,
                barrierWidth,
                barrierHeightPx
            );

            // Draw energy level indicator
            const energyY = centerY + barrierHeightPx / 2 - (particleEnergy * barrierHeightPx);
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(barrierX - 50, energyY);
            ctx.lineTo(barrierX + barrierWidth + 50, energyY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#9000ff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Barrier', barrierX + barrierWidth / 2 - 25, centerY - barrierHeightPx / 2 - 10);

            ctx.fillStyle = '#00d4ff';
            ctx.fillText('Particle Energy', barrierX - 110, energyY - 5);
        }

        function animate() {
            ctx.fillStyle = 'rgba(10, 14, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBarrier();

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Remove dead particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].alive) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('launchBtn').addEventListener('click', () => {
            particles.push(new Particle());
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            transmitted = 0;
            reflected = 0;
            particles.length = 0;
        });

        document.getElementById('heightSlider').addEventListener('input', (e) => {
            barrierHeight = parseInt(e.target.value) / 100;
            document.getElementById('heightValue').textContent = e.target.value;
        });

        document.getElementById('widthSlider').addEventListener('input', (e) => {
            barrierWidth = parseInt(e.target.value);
            document.getElementById('widthValue').textContent = e.target.value;
        });

        document.getElementById('energySlider').addEventListener('input', (e) => {
            particleEnergy = parseInt(e.target.value) / 100;
            document.getElementById('energyValue').textContent = e.target.value;
        });

        // Update stats
        setInterval(() => {
            const total = transmitted + reflected;
            const prob = total > 0 ? ((transmitted / total) * 100).toFixed(1) : 0;

            document.getElementById('transmitted').textContent = transmitted;
            document.getElementById('reflected').textContent = reflected;
            document.getElementById('probability').textContent = prob + '%';
        }, 100);

        // Start animation
        animate();
    </script>
</body>
</html>
