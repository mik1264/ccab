<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorenz Attractor - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 150px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin: 20px auto;
        }

        canvas {
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--theme-color);
            font-family: var(--font-mono);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .preset-btn {
            padding: 8px 16px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .preset-btn:hover {
            background: rgba(224, 224, 255, 0.2);
        }

        .preset-btn.featured {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            border-color: #ff6b6b;
        }

        .multi-canvas {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .projection-container {
            text-align: center;
        }

        .projection-container h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            .control-group label {
                font-size: 0.8em;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Lorenz Attractor</h1>
        <p class="subtitle">The Butterfly Effect: Exploring Chaos Theory and Strange Attractors</p>

        <div class="tabs">
            <div class="tab active" data-view="3d">3D View</div>
            <div class="tab" data-view="multi">Multi-Trajectory</div>
            <div class="tab" data-view="parameters">Parameter Explorer</div>
            <div class="tab" data-view="projections">2D Projections</div>
        </div>

        <!-- 3D View -->
        <div class="view active" id="3d">
            <div class="info-box">
                <h3>The Lorenz Attractor</h3>
                <p>Discovered by Edward Lorenz in 1963 while studying atmospheric convection, the Lorenz attractor
                revolutionized our understanding of deterministic chaos. The system's sensitive dependence on initial
                conditions became known as the "butterfly effect" - the idea that a butterfly flapping its wings in Brazil
                could theoretically cause a tornado in Texas.</p>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setPreset('classic')">Classic (10, 28, 8/3)</button>
                <button class="preset-btn" onclick="setPreset('slow')">Slow Motion</button>
                <button class="preset-btn" onclick="setPreset('chaotic')">Extra Chaotic</button>
                <button class="preset-btn" onclick="setPreset('simple')">Simple Attractor</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="sigma">σ (sigma): <span id="sigmaVal">10.0</span></label>
                    <input type="range" id="sigma" min="0" max="20" step="0.1" value="10">
                </div>
                <div class="control-group">
                    <label for="rho">ρ (rho): <span id="rhoVal">28.0</span></label>
                    <input type="range" id="rho" min="0" max="50" step="0.1" value="28">
                </div>
                <div class="control-group">
                    <label for="beta">β (beta): <span id="betaVal">2.67</span></label>
                    <input type="range" id="beta" min="0" max="10" step="0.01" value="2.67">
                </div>
                <div class="control-group">
                    <label for="trailLength">Trail Length: <span id="trailVal">5000</span></label>
                    <input type="range" id="trailLength" min="1000" max="50000" step="1000" value="5000">
                </div>
                <div class="control-group">
                    <label for="rotationSpeed">Rotation: <span id="rotSpeedVal">0.005</span></label>
                    <input type="range" id="rotationSpeed" min="0" max="0.02" step="0.001" value="0.005">
                </div>
                <div class="control-group">
                    <label for="colorScheme">Color Scheme:</label>
                    <select id="colorScheme" onchange="updateColorScheme()">
                        <option value="velocity">Velocity</option>
                        <option value="position">Position (Z)</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="blue-red">Blue-Red</option>
                    </select>
                </div>
                <button onclick="toggleAnimation()">Pause</button>
                <button onclick="resetAttractor()">Reset</button>
            </div>

            <div class="canvas-container">
                <canvas id="canvas3d" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="xPos">0.00</div>
                        <div class="stat-label">X Position</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="yPos">0.00</div>
                        <div class="stat-label">Y Position</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="zPos">0.00</div>
                        <div class="stat-label">Z Position</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="velocity">0.00</div>
                        <div class="stat-label">Velocity</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="lyapunov">~0.90</div>
                        <div class="stat-label">Lyapunov Exponent</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multi-Trajectory View -->
        <div class="view" id="multi">
            <div class="info-box">
                <h3>Butterfly Effect Demonstration</h3>
                <p>Watch multiple trajectories with slightly different starting conditions diverge exponentially,
                then reconverge onto the same strange attractor. This sensitive dependence on initial conditions
                is the hallmark of chaotic systems and makes long-term weather prediction fundamentally impossible.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="numTrajectories">Trajectories: <span id="numTrajVal">5</span></label>
                    <input type="range" id="numTrajectories" min="2" max="10" step="1" value="5">
                </div>
                <div class="control-group">
                    <label for="divergence">Divergence: <span id="divergenceVal">0.001</span></label>
                    <input type="range" id="divergence" min="0.0001" max="0.01" step="0.0001" value="0.001">
                </div>
                <button onclick="resetMulti()">Reset Trajectories</button>
            </div>

            <div class="canvas-container">
                <canvas id="canvasMulti" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-value" id="maxDivergence">0.00</div>
                    <div class="stat-label">Maximum Separation Distance</div>
                </div>
            </div>
        </div>

        <!-- Parameter Explorer View -->
        <div class="view" id="parameters">
            <div class="info-box">
                <h3>Parameter Space Exploration</h3>
                <p>The Lorenz system's behavior changes dramatically with different parameters:</p>
                <ul>
                    <li><strong>σ (sigma):</strong> Prandtl number - ratio of momentum diffusivity to thermal diffusivity</li>
                    <li><strong>ρ (rho):</strong> Rayleigh number - temperature difference driving convection</li>
                    <li><strong>β (beta):</strong> Geometric factor - aspect ratio of the convection cell</li>
                    <li>Classic values: σ=10, ρ=28, β=8/3 produce the iconic butterfly shape</li>
                    <li>Below ρ=24.74: System converges to fixed points (no chaos)</li>
                    <li>Above ρ=24.74: Strange attractor emerges</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="exploreRho">ρ (rho): <span id="exploreRhoVal">28.0</span></label>
                    <input type="range" id="exploreRho" min="0" max="50" step="0.5" value="28">
                </div>
                <button onclick="updateExplorer()">Update</button>
                <button onclick="animateRho()">Animate ρ</button>
            </div>

            <div class="canvas-container">
                <canvas id="canvasExplore" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-value" id="attractorType">Strange Attractor</div>
                    <div class="stat-label">System Behavior</div>
                </div>
            </div>
        </div>

        <!-- 2D Projections View -->
        <div class="view" id="projections">
            <div class="info-box">
                <h3>2D Phase Space Projections</h3>
                <p>View the attractor from different angles by projecting the 3D trajectory onto 2D planes.
                The XY and XZ projections reveal the butterfly wings, while the YZ projection shows the
                continuous looping behavior.</p>
            </div>

            <div class="multi-canvas">
                <div class="projection-container">
                    <h3>XY Plane</h3>
                    <canvas id="canvasXY" width="350" height="350"></canvas>
                </div>
                <div class="projection-container">
                    <h3>XZ Plane</h3>
                    <canvas id="canvasXZ" width="350" height="350"></canvas>
                </div>
                <div class="projection-container">
                    <h3>YZ Plane</h3>
                    <canvas id="canvasYZ" width="350" height="350"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Lorenz System Parameters
        let sigma = 10.0;
        let rho = 28.0;
        let beta = 8/3;
        let dt = 0.005;

        // State
        let x = 0.1, y = 0, z = 0;
        let points = [];
        let maxPoints = 5000;
        let animating = true;
        let colorScheme = 'velocity';

        // Three.js scene
        let scene, camera, renderer, controls;
        let line, geometry, material;
        let rotation = 0;

        // Multi-trajectory state
        let trajectories = [];
        let multiScene, multiCamera, multiRenderer, multiControls;
        let numTrajectories = 5;

        // Explorer state
        let explorerScene, explorerCamera, explorerRenderer, explorerControls;
        let explorerLine;

        // Projection canvases
        let ctxXY, ctxXZ, ctxYZ;
        let projectionPoints = [];

        // Initialize
        function init() {
            setupTabs();
            setupControls();
            setup3DView();
            setupMultiView();
            setupExplorerView();
            setupProjectionView();
            animate();
        }

        // Tab System
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');

                    // Resize renderers when switching tabs
                    if (tab.dataset.view === '3d') {
                        renderer.setSize(800, 600);
                    } else if (tab.dataset.view === 'multi') {
                        multiRenderer.setSize(800, 600);
                    } else if (tab.dataset.view === 'parameters') {
                        explorerRenderer.setSize(800, 600);
                    }
                });
            });
        }

        // Controls Setup
        function setupControls() {
            const sigmaInput = document.getElementById('sigma');
            const rhoInput = document.getElementById('rho');
            const betaInput = document.getElementById('beta');
            const trailInput = document.getElementById('trailLength');
            const rotInput = document.getElementById('rotationSpeed');

            sigmaInput.addEventListener('input', (e) => {
                sigma = parseFloat(e.target.value);
                document.getElementById('sigmaVal').textContent = sigma.toFixed(1);
            });

            rhoInput.addEventListener('input', (e) => {
                rho = parseFloat(e.target.value);
                document.getElementById('rhoVal').textContent = rho.toFixed(1);
            });

            betaInput.addEventListener('input', (e) => {
                beta = parseFloat(e.target.value);
                document.getElementById('betaVal').textContent = beta.toFixed(2);
            });

            trailInput.addEventListener('input', (e) => {
                maxPoints = parseInt(e.target.value);
                document.getElementById('trailVal').textContent = maxPoints;
            });

            rotInput.addEventListener('input', (e) => {
                document.getElementById('rotSpeedVal').textContent = parseFloat(e.target.value).toFixed(3);
            });

            document.getElementById('numTrajectories').addEventListener('input', (e) => {
                numTrajectories = parseInt(e.target.value);
                document.getElementById('numTrajVal').textContent = numTrajectories;
            });

            document.getElementById('divergence').addEventListener('input', (e) => {
                document.getElementById('divergenceVal').textContent = parseFloat(e.target.value).toFixed(4);
            });

            document.getElementById('exploreRho').addEventListener('input', (e) => {
                document.getElementById('exploreRhoVal').textContent = parseFloat(e.target.value).toFixed(1);
            });
        }

        // Lorenz System Equations
        function lorenz(x, y, z) {
            const dx = sigma * (y - x);
            const dy = x * (rho - z) - y;
            const dz = x * y - beta * z;
            return { dx, dy, dz };
        }

        // RK4 Integration
        function rk4Step(x, y, z, dt) {
            const k1 = lorenz(x, y, z);
            const k2 = lorenz(x + dt/2 * k1.dx, y + dt/2 * k1.dy, z + dt/2 * k1.dz);
            const k3 = lorenz(x + dt/2 * k2.dx, y + dt/2 * k2.dy, z + dt/2 * k2.dz);
            const k4 = lorenz(x + dt * k3.dx, y + dt * k3.dy, z + dt * k3.dz);

            return {
                x: x + dt/6 * (k1.dx + 2*k2.dx + 2*k3.dx + k4.dx),
                y: y + dt/6 * (k1.dy + 2*k2.dy + 2*k3.dy + k4.dy),
                z: z + dt/6 * (k1.dz + 2*k2.dz + 2*k3.dz + k4.dz)
            };
        }

        // 3D View Setup
        function setup3DView() {
            const canvas = document.getElementById('canvas3d');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
            camera.position.set(50, 50, 50);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Create line geometry
            geometry = new THREE.BufferGeometry();
            material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2
            });
            line = new THREE.Line(geometry, material);
            scene.add(line);

            // Add coordinate axes
            const axesHelper = new THREE.AxesHelper(30);
            scene.add(axesHelper);

            // Add subtle ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
        }

        // Setup Multi-Trajectory View
        function setupMultiView() {
            const canvas = document.getElementById('canvasMulti');

            multiScene = new THREE.Scene();
            multiScene.background = new THREE.Color(0x000000);

            multiCamera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
            multiCamera.position.set(50, 50, 50);

            multiRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            multiRenderer.setSize(canvas.width, canvas.height);

            multiControls = new OrbitControls(multiCamera, multiRenderer.domElement);
            multiControls.enableDamping = true;
            multiControls.dampingFactor = 0.05;

            const axesHelper = new THREE.AxesHelper(30);
            multiScene.add(axesHelper);

            resetMulti();
        }

        // Setup Explorer View
        function setupExplorerView() {
            const canvas = document.getElementById('canvasExplore');

            explorerScene = new THREE.Scene();
            explorerScene.background = new THREE.Color(0x000000);

            explorerCamera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
            explorerCamera.position.set(50, 50, 50);

            explorerRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            explorerRenderer.setSize(canvas.width, canvas.height);

            explorerControls = new OrbitControls(explorerCamera, explorerRenderer.domElement);
            explorerControls.enableDamping = true;
            explorerControls.dampingFactor = 0.05;

            const axesHelper = new THREE.AxesHelper(30);
            explorerScene.add(axesHelper);
        }

        // Setup Projection View
        function setupProjectionView() {
            const canvasXY = document.getElementById('canvasXY');
            const canvasXZ = document.getElementById('canvasXZ');
            const canvasYZ = document.getElementById('canvasYZ');

            ctxXY = canvasXY.getContext('2d');
            ctxXZ = canvasXZ.getContext('2d');
            ctxYZ = canvasYZ.getContext('2d');

            // Clear canvases
            ctxXY.fillStyle = '#000';
            ctxXY.fillRect(0, 0, 350, 350);
            ctxXZ.fillStyle = '#000';
            ctxXZ.fillRect(0, 0, 350, 350);
            ctxYZ.fillStyle = '#000';
            ctxYZ.fillRect(0, 0, 350, 350);
        }

        // Update 3D View
        function update3D() {
            if (!animating) return;

            // Integrate system
            const next = rk4Step(x, y, z, dt);
            x = next.x;
            y = next.y;
            z = next.z;

            // Add to points array
            points.push(new THREE.Vector3(x, y, z));
            if (points.length > maxPoints) {
                points.shift();
            }

            // Update geometry
            const positions = new Float32Array(points.length * 3);
            const colors = new Float32Array(points.length * 3);

            for (let i = 0; i < points.length; i++) {
                positions[i * 3] = points[i].x;
                positions[i * 3 + 1] = points[i].y;
                positions[i * 3 + 2] = points[i].z;

                // Color based on scheme
                const color = getColor(i, points[i]);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Update stats
            const velocity = Math.sqrt(
                Math.pow(points[points.length-1].x - (points[points.length-2]?.x || 0), 2) +
                Math.pow(points[points.length-1].y - (points[points.length-2]?.y || 0), 2) +
                Math.pow(points[points.length-1].z - (points[points.length-2]?.z || 0), 2)
            ) / dt;

            document.getElementById('xPos').textContent = x.toFixed(2);
            document.getElementById('yPos').textContent = y.toFixed(2);
            document.getElementById('zPos').textContent = z.toFixed(2);
            document.getElementById('velocity').textContent = velocity.toFixed(2);

            // Auto-rotate if enabled
            const rotSpeed = parseFloat(document.getElementById('rotationSpeed').value);
            if (rotSpeed > 0) {
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotSpeed);
                camera.lookAt(0, 0, 0);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Get color based on scheme
        function getColor(index, point) {
            const t = index / points.length;

            switch(colorScheme) {
                case 'velocity':
                    const v = Math.min(1, Math.sqrt(point.x*point.x + point.y*point.y + point.z*point.z) / 50);
                    return new THREE.Color().setHSL(0.6 - v * 0.6, 1, 0.5);

                case 'position':
                    const z = Math.min(1, Math.max(0, point.z / 50));
                    return new THREE.Color().setHSL(0.6 - z * 0.6, 1, 0.5);

                case 'rainbow':
                    return new THREE.Color().setHSL(t, 1, 0.5);

                case 'blue-red':
                    return new THREE.Color(t, 0, 1-t);

                default:
                    return new THREE.Color(0x667eea);
            }
        }

        // Update Multi-Trajectory View
        function updateMulti() {
            // Update each trajectory
            trajectories.forEach(traj => {
                const next = rk4Step(traj.x, traj.y, traj.z, dt);
                traj.x = next.x;
                traj.y = next.y;
                traj.z = next.z;

                traj.points.push(new THREE.Vector3(traj.x, traj.y, traj.z));
                if (traj.points.length > maxPoints / 2) {
                    traj.points.shift();
                }

                // Update geometry
                const positions = new Float32Array(traj.points.length * 3);
                const colors = new Float32Array(traj.points.length * 3);

                for (let i = 0; i < traj.points.length; i++) {
                    positions[i * 3] = traj.points[i].x;
                    positions[i * 3 + 1] = traj.points[i].y;
                    positions[i * 3 + 2] = traj.points[i].z;

                    colors[i * 3] = traj.color.r;
                    colors[i * 3 + 1] = traj.color.g;
                    colors[i * 3 + 2] = traj.color.b;
                }

                traj.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                traj.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            });

            // Calculate max divergence
            let maxDist = 0;
            for (let i = 0; i < trajectories.length; i++) {
                for (let j = i + 1; j < trajectories.length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(trajectories[i].x - trajectories[j].x, 2) +
                        Math.pow(trajectories[i].y - trajectories[j].y, 2) +
                        Math.pow(trajectories[i].z - trajectories[j].z, 2)
                    );
                    maxDist = Math.max(maxDist, dist);
                }
            }
            document.getElementById('maxDivergence').textContent = maxDist.toFixed(3);

            multiControls.update();
            multiRenderer.render(multiScene, multiCamera);
        }

        // Update Explorer View
        function updateExplorer() {
            const explorerRho = parseFloat(document.getElementById('exploreRho').value);

            // Clear previous line
            if (explorerLine) {
                explorerScene.remove(explorerLine);
            }

            // Generate new trajectory with different rho
            let ex = 0.1, ey = 0, ez = 0;
            const explorerPoints = [];

            for (let i = 0; i < 5000; i++) {
                const dx = sigma * (ey - ex);
                const dy = ex * (explorerRho - ez) - ey;
                const dz = ex * ey - beta * ez;

                ex += dx * dt;
                ey += dy * dt;
                ez += dz * dt;

                explorerPoints.push(new THREE.Vector3(ex, ey, ez));
            }

            // Create geometry
            const explorerGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(explorerPoints.length * 3);
            const colors = new Float32Array(explorerPoints.length * 3);

            for (let i = 0; i < explorerPoints.length; i++) {
                positions[i * 3] = explorerPoints[i].x;
                positions[i * 3 + 1] = explorerPoints[i].y;
                positions[i * 3 + 2] = explorerPoints[i].z;

                const t = i / explorerPoints.length;
                const color = new THREE.Color().setHSL(t, 1, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            explorerGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            explorerGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const explorerMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
            explorerLine = new THREE.Line(explorerGeometry, explorerMaterial);
            explorerScene.add(explorerLine);

            // Update attractor type label
            let type = 'Strange Attractor';
            if (explorerRho < 1) {
                type = 'Fixed Point (Origin)';
            } else if (explorerRho < 24.74) {
                type = 'Fixed Points (Non-chaotic)';
            } else {
                type = 'Strange Attractor (Chaotic)';
            }
            document.getElementById('attractorType').textContent = type;

            explorerControls.update();
            explorerRenderer.render(explorerScene, explorerCamera);
        }

        // Update Projection View
        function updateProjections() {
            // Add current point to projection history
            projectionPoints.push({ x, y, z });
            if (projectionPoints.length > 2000) {
                projectionPoints.shift();
            }

            // Clear canvases
            ctxXY.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctxXY.fillRect(0, 0, 350, 350);
            ctxXZ.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctxXZ.fillRect(0, 0, 350, 350);
            ctxYZ.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctxYZ.fillRect(0, 0, 350, 350);

            // Draw projections
            projectionPoints.forEach((p, i) => {
                const alpha = i / projectionPoints.length;
                const color = `rgba(102, 126, 234, ${alpha})`;

                // XY plane
                const xyX = (p.x + 25) * 6 + 25;
                const xyY = (p.y + 25) * 6 + 25;
                ctxXY.fillStyle = color;
                ctxXY.fillRect(xyX, xyY, 2, 2);

                // XZ plane
                const xzX = (p.x + 25) * 6 + 25;
                const xzZ = (50 - p.z) * 6 + 25;
                ctxXZ.fillStyle = color;
                ctxXZ.fillRect(xzX, xzZ, 2, 2);

                // YZ plane
                const yzY = (p.y + 25) * 6 + 25;
                const yzZ = (50 - p.z) * 6 + 25;
                ctxYZ.fillStyle = color;
                ctxYZ.fillRect(yzY, yzZ, 2, 2);
            });
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            update3D();
            updateMulti();
            updateProjections();
        }

        // Global functions for buttons
        window.toggleAnimation = function() {
            animating = !animating;
            event.target.textContent = animating ? 'Pause' : 'Resume';
        };

        window.resetAttractor = function() {
            x = 0.1;
            y = 0;
            z = 0;
            points = [];
            projectionPoints = [];
        };

        window.setPreset = function(preset) {
            switch(preset) {
                case 'classic':
                    sigma = 10.0;
                    rho = 28.0;
                    beta = 8/3;
                    break;
                case 'slow':
                    sigma = 5.0;
                    rho = 15.0;
                    beta = 2.0;
                    break;
                case 'chaotic':
                    sigma = 15.0;
                    rho = 40.0;
                    beta = 3.5;
                    break;
                case 'simple':
                    sigma = 8.0;
                    rho = 20.0;
                    beta = 2.0;
                    break;
            }

            document.getElementById('sigma').value = sigma;
            document.getElementById('rho').value = rho;
            document.getElementById('beta').value = beta.toFixed(2);
            document.getElementById('sigmaVal').textContent = sigma.toFixed(1);
            document.getElementById('rhoVal').textContent = rho.toFixed(1);
            document.getElementById('betaVal').textContent = beta.toFixed(2);

            resetAttractor();
        };

        window.updateColorScheme = function() {
            colorScheme = document.getElementById('colorScheme').value;
        };

        window.resetMulti = function() {
            // Clear existing trajectories
            trajectories.forEach(traj => {
                multiScene.remove(traj.line);
            });
            trajectories = [];

            const divergence = parseFloat(document.getElementById('divergence').value);
            const colors = [
                new THREE.Color(0xff6b6b),
                new THREE.Color(0x4ecdc4),
                new THREE.Color(0x45b7d1),
                new THREE.Color(0xf9ca24),
                new THREE.Color(0xe056fd),
                new THREE.Color(0x686de0),
                new THREE.Color(0xf8b500),
                new THREE.Color(0xff7675),
                new THREE.Color(0x74b9ff),
                new THREE.Color(0xa29bfe)
            ];

            for (let i = 0; i < numTrajectories; i++) {
                const traj = {
                    x: 0.1 + (i - numTrajectories/2) * divergence,
                    y: 0 + (i - numTrajectories/2) * divergence * 0.5,
                    z: 0,
                    points: [],
                    color: colors[i],
                    geometry: new THREE.BufferGeometry(),
                    material: new THREE.LineBasicMaterial({
                        vertexColors: true,
                        linewidth: 2
                    })
                };

                traj.line = new THREE.Line(traj.geometry, traj.material);
                multiScene.add(traj.line);
                trajectories.push(traj);
            }
        };

        window.animateRho = function() {
            let currentRho = 0;
            const interval = setInterval(() => {
                currentRho += 0.5;
                if (currentRho > 50) {
                    clearInterval(interval);
                    return;
                }
                document.getElementById('exploreRho').value = currentRho;
                document.getElementById('exploreRhoVal').textContent = currentRho.toFixed(1);
                updateExplorer();
            }, 100);
        };

        // Initialize on load
        window.addEventListener('load', init);
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
