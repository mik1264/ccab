<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN Visualization | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 150, 0.3);
            max-height: 90vh;
            overflow-y: auto;
        }
        h1 { color: #ff6496; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff6496; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff6496; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff88b0; }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        .layer-info {
            background: #222; padding: 10px; border-radius: 8px;
            margin: 10px 0; font-size: 0.85em;
        }
        .layer-info h4 { color: #ff6496; margin-bottom: 5px; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6496; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .filter-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        .filter-cell {
            aspect-ratio: 1;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Machine Learning</a>

    <div class="controls">
        <h1>CNN Visualization</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Convolutional Neural Network layers</p>

        <div class="control-group">
            <label>Input Image:</label>
            <select id="inputImage">
                <option value="digit">Digit Pattern</option>
                <option value="edge">Edge Pattern</option>
                <option value="checker">Checkerboard</option>
                <option value="gradient">Gradient</option>
                <option value="noise">Random Noise</option>
            </select>
        </div>

        <div class="control-group">
            <label>Convolution Filter:</label>
            <select id="filter">
                <option value="edge_h">Horizontal Edge</option>
                <option value="edge_v">Vertical Edge</option>
                <option value="sobel_x">Sobel X</option>
                <option value="sobel_y">Sobel Y</option>
                <option value="sharpen">Sharpen</option>
                <option value="blur">Blur</option>
                <option value="emboss">Emboss</option>
            </select>
        </div>

        <div class="control-group">
            <label>Pooling:</label>
            <select id="pooling">
                <option value="max">Max Pooling 2x2</option>
                <option value="avg">Average Pooling 2x2</option>
                <option value="none">No Pooling</option>
            </select>
        </div>

        <div class="control-group">
            <label>Activation:</label>
            <select id="activation">
                <option value="relu">ReLU</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="tanh">Tanh</option>
                <option value="none">None</option>
            </select>
        </div>

        <button id="forwardBtn">Forward Pass</button>
        <button id="animateBtn" class="secondary">Animate Convolution</button>
        <button id="resetBtn" class="secondary">Reset</button>

        <div class="layer-info">
            <h4>Current Filter (3×3)</h4>
            <div class="filter-display" id="filterDisplay"></div>
        </div>

        <div class="layer-info">
            <h4>Layer Dimensions</h4>
            <div id="dimensions">
                Input: 28×28×1<br>
                Conv: 26×26×1<br>
                Pool: 13×13×1
            </div>
        </div>

        <div class="info">
            <strong>CNN</strong> extracts features using convolutions.<br>
            Watch how filters detect patterns and pooling reduces dimensions.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        const INPUT_SIZE = 28;
        let inputImage = [];
        let convOutput = [];
        let activationOutput = [];
        let poolOutput = [];
        let animating = false;
        let animStep = 0;

        const filters = {
            edge_h: [[-1, -1, -1], [0, 0, 0], [1, 1, 1]],
            edge_v: [[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]],
            sobel_x: [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],
            sobel_y: [[-1, -2, -1], [0, 0, 0], [1, 2, 1]],
            sharpen: [[0, -1, 0], [-1, 5, -1], [0, -1, 0]],
            blur: [[1/9, 1/9, 1/9], [1/9, 1/9, 1/9], [1/9, 1/9, 1/9]],
            emboss: [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]
        };

        function generateInputImage(type) {
            inputImage = [];

            for (let y = 0; y < INPUT_SIZE; y++) {
                inputImage[y] = [];
                for (let x = 0; x < INPUT_SIZE; x++) {
                    let val = 0;

                    switch (type) {
                        case 'digit':
                            // Draw a simple "7" shape
                            if (y >= 4 && y <= 6 && x >= 6 && x <= 20) val = 1;
                            if (x >= 18 && x <= 20 && y >= 4 && y <= 24) val = 1;
                            // Add some variation
                            val += (Math.random() - 0.5) * 0.1;
                            break;

                        case 'edge':
                            if (x < INPUT_SIZE / 2) val = 0.2;
                            else val = 0.8;
                            val += (Math.random() - 0.5) * 0.1;
                            break;

                        case 'checker':
                            const cx = Math.floor(x / 4);
                            const cy = Math.floor(y / 4);
                            val = (cx + cy) % 2 === 0 ? 0.8 : 0.2;
                            break;

                        case 'gradient':
                            val = x / INPUT_SIZE;
                            break;

                        case 'noise':
                            val = Math.random();
                            break;
                    }

                    inputImage[y][x] = Math.max(0, Math.min(1, val));
                }
            }

            convOutput = [];
            activationOutput = [];
            poolOutput = [];
        }

        function convolve(input, filter) {
            const output = [];
            const outSize = input.length - 2;

            for (let y = 0; y < outSize; y++) {
                output[y] = [];
                for (let x = 0; x < outSize; x++) {
                    let sum = 0;
                    for (let fy = 0; fy < 3; fy++) {
                        for (let fx = 0; fx < 3; fx++) {
                            sum += input[y + fy][x + fx] * filter[fy][fx];
                        }
                    }
                    output[y][x] = sum;
                }
            }

            return output;
        }

        function applyActivation(input, type) {
            const output = [];

            for (let y = 0; y < input.length; y++) {
                output[y] = [];
                for (let x = 0; x < input[y].length; x++) {
                    const val = input[y][x];
                    switch (type) {
                        case 'relu':
                            output[y][x] = Math.max(0, val);
                            break;
                        case 'sigmoid':
                            output[y][x] = 1 / (1 + Math.exp(-val));
                            break;
                        case 'tanh':
                            output[y][x] = Math.tanh(val);
                            break;
                        default:
                            output[y][x] = val;
                    }
                }
            }

            return output;
        }

        function pool(input, type) {
            if (type === 'none') return input;

            const output = [];
            const outSize = Math.floor(input.length / 2);

            for (let y = 0; y < outSize; y++) {
                output[y] = [];
                for (let x = 0; x < outSize; x++) {
                    const vals = [
                        input[y * 2][x * 2],
                        input[y * 2][x * 2 + 1],
                        input[y * 2 + 1][x * 2],
                        input[y * 2 + 1][x * 2 + 1]
                    ];

                    if (type === 'max') {
                        output[y][x] = Math.max(...vals);
                    } else {
                        output[y][x] = vals.reduce((a, b) => a + b) / 4;
                    }
                }
            }

            return output;
        }

        function forwardPass() {
            const filterType = document.getElementById('filter').value;
            const activationType = document.getElementById('activation').value;
            const poolingType = document.getElementById('pooling').value;

            convOutput = convolve(inputImage, filters[filterType]);
            activationOutput = applyActivation(convOutput, activationType);
            poolOutput = pool(activationOutput, poolingType);

            updateDimensions();
        }

        function updateFilterDisplay() {
            const filterType = document.getElementById('filter').value;
            const filter = filters[filterType];
            const display = document.getElementById('filterDisplay');
            display.innerHTML = '';

            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'filter-cell';
                    const val = filter[y][x];
                    cell.textContent = val.toFixed(2);

                    const intensity = Math.abs(val);
                    if (val > 0) {
                        cell.style.background = `rgba(100, 200, 255, ${intensity * 0.5})`;
                    } else if (val < 0) {
                        cell.style.background = `rgba(255, 100, 150, ${intensity * 0.5})`;
                    }
                    display.appendChild(cell);
                }
            }
        }

        function updateDimensions() {
            const poolingType = document.getElementById('pooling').value;
            const convSize = INPUT_SIZE - 2;
            const poolSize = poolingType === 'none' ? convSize : Math.floor(convSize / 2);

            document.getElementById('dimensions').innerHTML = `
                Input: ${INPUT_SIZE}×${INPUT_SIZE}×1<br>
                Conv: ${convSize}×${convSize}×1<br>
                Pool: ${poolSize}×${poolSize}×1
            `;
        }

        function drawMatrix(matrix, x, y, cellSize, label, normalize = true) {
            if (!matrix || matrix.length === 0) return;

            // Find min/max for normalization
            let min = Infinity, max = -Infinity;
            for (const row of matrix) {
                for (const val of row) {
                    min = Math.min(min, val);
                    max = Math.max(max, val);
                }
            }

            const range = max - min || 1;

            // Draw cells
            for (let my = 0; my < matrix.length; my++) {
                for (let mx = 0; mx < matrix[my].length; mx++) {
                    let val = matrix[my][mx];
                    if (normalize) {
                        val = (val - min) / range;
                    }
                    val = Math.max(0, Math.min(1, val));

                    const intensity = Math.floor(val * 255);
                    ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    ctx.fillRect(x + mx * cellSize, y + my * cellSize, cellSize - 1, cellSize - 1);
                }
            }

            // Draw label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(label, x, y - 10);

            // Draw border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 2, y - 2, matrix[0].length * cellSize + 4, matrix.length * cellSize + 4);
        }

        function drawArrow(x1, y1, x2, y2, label) {
            ctx.beginPath();
            ctx.strokeStyle = '#ff6496';
            ctx.lineWidth = 2;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle - 0.3), y2 - 10 * Math.sin(angle - 0.3));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle + 0.3), y2 - 10 * Math.sin(angle + 0.3));
            ctx.stroke();

            // Label
            if (label) {
                ctx.fillStyle = '#ff6496';
                ctx.font = '12px sans-serif';
                ctx.fillText(label, (x1 + x2) / 2, (y1 + y2) / 2 - 10);
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const startX = 50;
            const startY = 100;
            const inputCellSize = 10;
            const convCellSize = 10;
            const poolCellSize = 12;

            // Draw input image
            drawMatrix(inputImage, startX, startY, inputCellSize, 'Input (28×28)', false);

            // Draw convolution output
            const convX = startX + INPUT_SIZE * inputCellSize + 80;
            if (convOutput.length > 0) {
                drawMatrix(convOutput, convX, startY, convCellSize, 'Conv Output (26×26)');
                drawArrow(
                    startX + INPUT_SIZE * inputCellSize + 10,
                    startY + INPUT_SIZE * inputCellSize / 2,
                    convX - 10,
                    startY + (INPUT_SIZE - 2) * convCellSize / 2,
                    'Conv 3×3'
                );
            }

            // Draw activation output
            const actX = convX + (INPUT_SIZE - 2) * convCellSize + 80;
            if (activationOutput.length > 0) {
                drawMatrix(activationOutput, actX, startY, convCellSize, 'After Activation');
                drawArrow(
                    convX + (INPUT_SIZE - 2) * convCellSize + 10,
                    startY + (INPUT_SIZE - 2) * convCellSize / 2,
                    actX - 10,
                    startY + (INPUT_SIZE - 2) * convCellSize / 2,
                    document.getElementById('activation').value.toUpperCase()
                );
            }

            // Draw pooling output
            const poolX = actX + (INPUT_SIZE - 2) * convCellSize + 80;
            if (poolOutput.length > 0) {
                drawMatrix(poolOutput, poolX, startY, poolCellSize, `Pool Output (${poolOutput.length}×${poolOutput.length})`);
                drawArrow(
                    actX + (INPUT_SIZE - 2) * convCellSize + 10,
                    startY + (INPUT_SIZE - 2) * convCellSize / 2,
                    poolX - 10,
                    startY + poolOutput.length * poolCellSize / 2,
                    document.getElementById('pooling').value === 'none' ? 'No Pool' : 'Pool 2×2'
                );
            }

            // Animation overlay
            if (animating && convOutput.length > 0) {
                const filterType = document.getElementById('filter').value;
                const filter = filters[filterType];

                const convOutSize = INPUT_SIZE - 2;
                const animX = animStep % convOutSize;
                const animY = Math.floor(animStep / convOutSize);

                if (animY < convOutSize) {
                    // Highlight input region
                    ctx.strokeStyle = '#ff6496';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        startX + animX * inputCellSize - 2,
                        startY + animY * inputCellSize - 2,
                        3 * inputCellSize + 4,
                        3 * inputCellSize + 4
                    );

                    // Highlight output cell
                    ctx.fillStyle = 'rgba(255, 100, 150, 0.5)';
                    ctx.fillRect(
                        convX + animX * convCellSize,
                        startY + animY * convCellSize,
                        convCellSize,
                        convCellSize
                    );

                    // Show calculation
                    ctx.fillStyle = '#fff';
                    ctx.font = '14px monospace';
                    let calcText = 'Σ(input × filter) = ';
                    let sum = 0;
                    for (let fy = 0; fy < 3; fy++) {
                        for (let fx = 0; fx < 3; fx++) {
                            sum += inputImage[animY + fy][animX + fx] * filter[fy][fx];
                        }
                    }
                    calcText += sum.toFixed(3);
                    ctx.fillText(calcText, startX, startY + INPUT_SIZE * inputCellSize + 40);

                    animStep++;
                    if (animStep >= convOutSize * convOutSize) {
                        animStep = 0;
                    }
                }
            }

            // Legend
            ctx.fillStyle = '#888';
            ctx.font = '13px sans-serif';
            ctx.fillText('CNN Architecture: Input → Convolution → Activation → Pooling → Output', startX, canvas.height - 50);

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('inputImage').onchange = (e) => {
            generateInputImage(e.target.value);
        };

        document.getElementById('filter').onchange = updateFilterDisplay;

        document.getElementById('forwardBtn').onclick = forwardPass;

        document.getElementById('animateBtn').onclick = () => {
            animating = !animating;
            animStep = 0;
            document.getElementById('animateBtn').textContent = animating ? 'Stop Animation' : 'Animate Convolution';
            if (animating && convOutput.length === 0) {
                forwardPass();
            }
        };

        document.getElementById('resetBtn').onclick = () => {
            convOutput = [];
            activationOutput = [];
            poolOutput = [];
            animating = false;
            animStep = 0;
            document.getElementById('animateBtn').textContent = 'Animate Convolution';
        };

        // Initialize
        generateInputImage('digit');
        updateFilterDisplay();
        updateDimensions();
        draw();
    </script>
</body>
</html>
