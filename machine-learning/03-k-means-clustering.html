<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 150, 0.3);
        }
        h1 { color: #ff6496; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff6496; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff6496; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff88b0; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff6496; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6496; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .cluster-legend { margin-top: 15px; }
        .legend-item { display: flex; align-items: center; gap: 10px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 15px; height: 15px; border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Machine Learning</a>

    <div class="controls">
        <h1>K-Means Clustering</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Interactive clustering visualization</p>

        <div class="control-group">
            <label>Number of Clusters (K): <span class="value" id="kValue">3</span></label>
            <input type="range" id="kClusters" min="2" max="8" value="3">
        </div>

        <div class="control-group">
            <label>Data Distribution</label>
            <select id="distribution">
                <option value="random">Random</option>
                <option value="blobs">Gaussian Blobs</option>
                <option value="moons">Two Moons</option>
                <option value="rings">Concentric Rings</option>
            </select>
        </div>

        <div class="control-group">
            <label>Points: <span class="value" id="nValue">200</span></label>
            <input type="range" id="nPoints" min="50" max="500" step="50" value="200">
        </div>

        <button id="generateBtn">Generate Data</button>
        <button id="initBtn">Initialize Centroids</button>
        <button id="stepBtn">Step</button>
        <button id="runBtn">Run</button>
        <button id="resetBtn">Reset Centroids</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Iteration</span>
                <span class="stat-value" id="iteration">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Inertia (WCSS)</span>
                <span class="stat-value" id="inertia">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Converged</span>
                <span class="stat-value" id="converged">No</span>
            </div>
        </div>

        <div class="cluster-legend" id="legend"></div>

        <div class="info">
            <strong>Click</strong> on the canvas to add points.<br>
            <strong>K-Means</strong> minimizes within-cluster sum of squares by iteratively updating centroids.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let points = [];
        let centroids = [];
        let assignments = [];
        let k = 3;
        let iteration = 0;
        let running = false;
        let converged = false;

        const colors = [
            '#ff6496', '#64c8ff', '#64ff96', '#ffc864',
            '#c864ff', '#ff9664', '#64ffc8', '#ff64c8'
        ];

        function generateData(type, n) {
            points = [];

            switch (type) {
                case 'random':
                    for (let i = 0; i < n; i++) {
                        points.push({
                            x: Math.random() * 600 + 100,
                            y: Math.random() * 400 + 100
                        });
                    }
                    break;

                case 'blobs':
                    const blobCenters = [
                        { x: 200, y: 200 },
                        { x: 400, y: 400 },
                        { x: 600, y: 200 }
                    ];
                    for (let i = 0; i < n; i++) {
                        const center = blobCenters[i % blobCenters.length];
                        points.push({
                            x: center.x + (Math.random() - 0.5) * 150,
                            y: center.y + (Math.random() - 0.5) * 150
                        });
                    }
                    break;

                case 'moons':
                    for (let i = 0; i < n / 2; i++) {
                        const angle = (i / (n / 2)) * Math.PI;
                        points.push({
                            x: 300 + Math.cos(angle) * 150 + (Math.random() - 0.5) * 30,
                            y: 300 - Math.sin(angle) * 150 + (Math.random() - 0.5) * 30
                        });
                        points.push({
                            x: 400 - Math.cos(angle) * 150 + (Math.random() - 0.5) * 30,
                            y: 350 + Math.sin(angle) * 150 + (Math.random() - 0.5) * 30
                        });
                    }
                    break;

                case 'rings':
                    for (let i = 0; i < n / 2; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r1 = 100 + (Math.random() - 0.5) * 20;
                        const r2 = 200 + (Math.random() - 0.5) * 20;
                        points.push({
                            x: 400 + Math.cos(angle) * r1,
                            y: 300 + Math.sin(angle) * r1
                        });
                        points.push({
                            x: 400 + Math.cos(angle) * r2,
                            y: 300 + Math.sin(angle) * r2
                        });
                    }
                    break;
            }

            assignments = new Array(points.length).fill(-1);
            centroids = [];
            iteration = 0;
            converged = false;
            updateStats();
        }

        function initCentroids() {
            centroids = [];
            // K-means++ initialization
            const idx = Math.floor(Math.random() * points.length);
            centroids.push({ x: points[idx].x, y: points[idx].y });

            while (centroids.length < k) {
                const distances = points.map(p => {
                    let minDist = Infinity;
                    centroids.forEach(c => {
                        const d = Math.pow(p.x - c.x, 2) + Math.pow(p.y - c.y, 2);
                        minDist = Math.min(minDist, d);
                    });
                    return minDist;
                });

                const totalDist = distances.reduce((a, b) => a + b, 0);
                let r = Math.random() * totalDist;

                for (let i = 0; i < points.length; i++) {
                    r -= distances[i];
                    if (r <= 0) {
                        centroids.push({ x: points[i].x, y: points[i].y });
                        break;
                    }
                }
            }

            iteration = 0;
            converged = false;
            assignPoints();
            updateStats();
            updateLegend();
        }

        function assignPoints() {
            assignments = points.map(p => {
                let minDist = Infinity;
                let minIdx = 0;

                centroids.forEach((c, i) => {
                    const d = Math.pow(p.x - c.x, 2) + Math.pow(p.y - c.y, 2);
                    if (d < minDist) {
                        minDist = d;
                        minIdx = i;
                    }
                });

                return minIdx;
            });
        }

        function updateCentroids() {
            const newCentroids = centroids.map((_, i) => {
                const clusterPoints = points.filter((_, j) => assignments[j] === i);
                if (clusterPoints.length === 0) return centroids[i];

                return {
                    x: clusterPoints.reduce((s, p) => s + p.x, 0) / clusterPoints.length,
                    y: clusterPoints.reduce((s, p) => s + p.y, 0) / clusterPoints.length
                };
            });

            // Check convergence
            let moved = false;
            newCentroids.forEach((c, i) => {
                if (Math.abs(c.x - centroids[i].x) > 0.1 || Math.abs(c.y - centroids[i].y) > 0.1) {
                    moved = true;
                }
            });

            centroids = newCentroids;
            return moved;
        }

        function step() {
            if (centroids.length === 0) initCentroids();
            if (converged) return;

            assignPoints();
            const moved = updateCentroids();
            iteration++;

            if (!moved) {
                converged = true;
            }

            updateStats();
        }

        function calculateInertia() {
            let inertia = 0;
            points.forEach((p, i) => {
                if (assignments[i] >= 0 && assignments[i] < centroids.length) {
                    const c = centroids[assignments[i]];
                    inertia += Math.pow(p.x - c.x, 2) + Math.pow(p.y - c.y, 2);
                }
            });
            return inertia;
        }

        function updateStats() {
            document.getElementById('iteration').textContent = iteration;
            document.getElementById('inertia').textContent = centroids.length > 0 ?
                calculateInertia().toFixed(0) : '-';
            document.getElementById('converged').textContent = converged ? 'Yes' : 'No';
            document.getElementById('converged').style.color = converged ? '#64ff96' : '#ff6496';
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';

            centroids.forEach((_, i) => {
                const count = assignments.filter(a => a === i).length;
                legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background:${colors[i]}"></div>
                        <span>Cluster ${i + 1}: ${count} points</span>
                    </div>
                `;
            });
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Voronoi regions
            if (centroids.length > 0) {
                const plotWidth = canvas.width - 350;
                const plotHeight = canvas.height;

                for (let x = 0; x < plotWidth; x += 10) {
                    for (let y = 0; y < plotHeight; y += 10) {
                        let minDist = Infinity;
                        let minIdx = 0;

                        centroids.forEach((c, i) => {
                            const d = Math.pow(x - c.x, 2) + Math.pow(y - c.y, 2);
                            if (d < minDist) {
                                minDist = d;
                                minIdx = i;
                            }
                        });

                        ctx.fillStyle = colors[minIdx] + '22';
                        ctx.fillRect(x, y, 10, 10);
                    }
                }
            }

            // Draw points
            points.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);

                if (assignments[i] >= 0) {
                    ctx.fillStyle = colors[assignments[i]];
                } else {
                    ctx.fillStyle = '#888';
                }
                ctx.fill();
            });

            // Draw centroids
            centroids.forEach((c, i) => {
                // Connection lines
                points.forEach((p, j) => {
                    if (assignments[j] === i) {
                        ctx.beginPath();
                        ctx.strokeStyle = colors[i] + '33';
                        ctx.lineWidth = 1;
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(c.x, c.y);
                        ctx.stroke();
                    }
                });

                // Centroid marker
                ctx.beginPath();
                ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
                ctx.fillStyle = colors[i];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // X mark
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.moveTo(c.x - 5, c.y - 5);
                ctx.lineTo(c.x + 5, c.y + 5);
                ctx.moveTo(c.x + 5, c.y - 5);
                ctx.lineTo(c.x - 5, c.y + 5);
                ctx.stroke();
            });
        }

        function animate() {
            if (running && !converged) {
                step();
                updateLegend();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('kClusters').oninput = (e) => {
            k = parseInt(e.target.value);
            document.getElementById('kValue').textContent = k;
        };

        document.getElementById('nPoints').oninput = (e) => {
            document.getElementById('nValue').textContent = e.target.value;
        };

        document.getElementById('distribution').onchange = (e) => {
            const n = parseInt(document.getElementById('nPoints').value);
            generateData(e.target.value, n);
        };

        document.getElementById('generateBtn').onclick = () => {
            const n = parseInt(document.getElementById('nPoints').value);
            const dist = document.getElementById('distribution').value;
            generateData(dist, n);
        };

        document.getElementById('initBtn').onclick = initCentroids;
        document.getElementById('stepBtn').onclick = () => {
            step();
            updateLegend();
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Run';
        };

        document.getElementById('resetBtn').onclick = () => {
            centroids = [];
            assignments = new Array(points.length).fill(-1);
            iteration = 0;
            converged = false;
            running = false;
            document.getElementById('runBtn').textContent = 'Run';
            updateStats();
            document.getElementById('legend').innerHTML = '';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (x < canvas.width - 350) {
                points.push({ x, y });
                assignments.push(-1);

                if (centroids.length > 0) {
                    converged = false;
                    assignPoints();
                    updateLegend();
                }
            }
        };

        // Initialize
        generateData('blobs', 200);
        animate();
    </script>
</body>
</html>
