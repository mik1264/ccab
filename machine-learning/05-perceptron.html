<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perceptron | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(200, 150, 255, 0.3);
        }
        h1 { color: #c896ff; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"] { width: 100%; }
        .value { float: right; color: #c896ff; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #c896ff; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #dcb4ff; }
        .class-btns { display: flex; gap: 10px; margin: 10px 0; }
        .class-btn {
            flex: 1; padding: 10px; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold;
        }
        .class-btn.class-0 { background: #64c8ff; color: #1a1a2e; }
        .class-btn.class-1 { background: #ff6464; color: #fff; }
        .class-btn.active { outline: 3px solid #fff; }
        .weights-display {
            background: rgba(200, 150, 255, 0.1);
            border-radius: 8px; padding: 10px; margin: 10px 0;
            font-family: monospace; font-size: 0.9em;
        }
        .weight-row { display: flex; justify-content: space-between; padding: 3px 0; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #c896ff; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c896ff; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Machine Learning</a>

    <div class="controls">
        <h1>Perceptron</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">The simplest neural network unit</p>

        <div class="control-group">
            <label>Learning Rate: <span class="value" id="lrValue">0.1</span></label>
            <input type="range" id="learningRate" min="0.01" max="1" step="0.01" value="0.1">
        </div>

        <div class="class-btns">
            <button class="class-btn class-0 active" data-class="0">Class 0 (-1)</button>
            <button class="class-btn class-1" data-class="1">Class 1 (+1)</button>
        </div>

        <button id="generateBtn">Generate Linearly Separable Data</button>
        <button id="stepBtn">Train Step</button>
        <button id="trainBtn">Train to Convergence</button>
        <button id="resetBtn">Reset Weights</button>
        <button id="clearBtn">Clear Data</button>

        <div class="weights-display">
            <div style="color:#888; margin-bottom:5px;">Weights:</div>
            <div class="weight-row">
                <span>w₁ (x):</span>
                <span id="w1">0.000</span>
            </div>
            <div class="weight-row">
                <span>w₂ (y):</span>
                <span id="w2">0.000</span>
            </div>
            <div class="weight-row">
                <span>b (bias):</span>
                <span id="bias">0.000</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Epoch</span>
                <span class="stat-value" id="epoch">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Misclassified</span>
                <span class="stat-value" id="errors">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Accuracy</span>
                <span class="stat-value" id="accuracy">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Converged</span>
                <span class="stat-value" id="converged">No</span>
            </div>
        </div>

        <div class="info">
            <strong>Perceptron Rule:</strong><br>
            y = sign(w₁x₁ + w₂x₂ + b)<br>
            Update: w = w + η(target - pred)·x<br><br>
            <strong>Click</strong> to add points. Perceptron finds a linear decision boundary.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let points = [];
        let w1 = 0, w2 = 0, bias = 0;
        let learningRate = 0.1;
        let selectedClass = 0;
        let epoch = 0;
        let converged = false;

        function normalize(value, min, max) {
            return (value - min) / (max - min) * 2 - 1;
        }

        function denormalize(value, min, max) {
            return (value + 1) / 2 * (max - min) + min;
        }

        function predict(x, y) {
            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;

            const nx = normalize(x, 0, plotWidth);
            const ny = normalize(y, plotHeight, 0);

            const sum = w1 * nx + w2 * ny + bias;
            return sum >= 0 ? 1 : -1;
        }

        function trainStep() {
            if (points.length === 0) return;

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;

            let errors = 0;

            // Shuffle points for stochastic update
            const shuffled = [...points].sort(() => Math.random() - 0.5);

            shuffled.forEach(p => {
                const nx = normalize(p.x, 0, plotWidth);
                const ny = normalize(p.y, plotHeight, 0);
                const target = p.label === 1 ? 1 : -1;

                const sum = w1 * nx + w2 * ny + bias;
                const pred = sum >= 0 ? 1 : -1;

                if (pred !== target) {
                    errors++;
                    const update = learningRate * (target - pred);
                    w1 += update * nx;
                    w2 += update * ny;
                    bias += update;
                }
            });

            epoch++;
            converged = errors === 0;
            updateDisplay();
        }

        function trainToConvergence() {
            let maxIterations = 1000;
            let iterations = 0;

            while (!converged && iterations < maxIterations) {
                trainStep();
                iterations++;
            }
        }

        function generateLinearData() {
            points = [];

            // Generate linearly separable data
            const angle = Math.random() * Math.PI;
            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;

            for (let i = 0; i < 50; i++) {
                const x = Math.random() * plotWidth * 0.8 + plotWidth * 0.1;
                const y = Math.random() * plotHeight * 0.8 + plotHeight * 0.1;

                // Determine class based on a random line
                const cx = plotWidth / 2;
                const cy = plotHeight / 2;
                const side = (x - cx) * Math.cos(angle) + (y - cy) * Math.sin(angle);

                points.push({
                    x: x + (Math.random() - 0.5) * 50,
                    y: y + (Math.random() - 0.5) * 50,
                    label: side > 0 ? 1 : 0
                });
            }

            resetWeights();
        }

        function resetWeights() {
            w1 = (Math.random() - 0.5) * 0.1;
            w2 = (Math.random() - 0.5) * 0.1;
            bias = (Math.random() - 0.5) * 0.1;
            epoch = 0;
            converged = false;
            updateDisplay();
        }

        function countErrors() {
            let errors = 0;
            points.forEach(p => {
                const pred = predict(p.x, p.y);
                const target = p.label === 1 ? 1 : -1;
                if (pred !== target) errors++;
            });
            return errors;
        }

        function updateDisplay() {
            document.getElementById('w1').textContent = w1.toFixed(4);
            document.getElementById('w2').textContent = w2.toFixed(4);
            document.getElementById('bias').textContent = bias.toFixed(4);
            document.getElementById('epoch').textContent = epoch;

            const errors = countErrors();
            document.getElementById('errors').textContent = errors;

            const accuracy = points.length > 0 ?
                ((points.length - errors) / points.length * 100).toFixed(1) + '%' : '-';
            document.getElementById('accuracy').textContent = accuracy;

            document.getElementById('converged').textContent = converged ? 'Yes' : 'No';
            document.getElementById('converged').style.color = converged ? '#64ff64' : '#ff6464';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;

            // Draw decision regions
            const resolution = 10;
            for (let x = 0; x < plotWidth; x += resolution) {
                for (let y = 0; y < plotHeight; y += resolution) {
                    const pred = predict(x, y);
                    ctx.fillStyle = pred === 1 ? 'rgba(255, 100, 100, 0.15)' : 'rgba(100, 200, 255, 0.15)';
                    ctx.fillRect(x, y, resolution, resolution);
                }
            }

            // Draw decision boundary
            if (w2 !== 0) {
                ctx.beginPath();
                ctx.strokeStyle = '#c896ff';
                ctx.lineWidth = 3;

                // Line equation: w1*x + w2*y + b = 0
                // y = -(w1*x + b) / w2
                for (let px = 0; px < plotWidth; px += 5) {
                    const nx = normalize(px, 0, plotWidth);
                    const ny = -(w1 * nx + bias) / w2;
                    const py = denormalize(ny, plotHeight, 0);

                    if (px === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            } else if (w1 !== 0) {
                // Vertical line
                const nx = -bias / w1;
                const px = denormalize(nx, 0, plotWidth);

                ctx.beginPath();
                ctx.strokeStyle = '#c896ff';
                ctx.lineWidth = 3;
                ctx.moveTo(px, 0);
                ctx.lineTo(px, plotHeight);
                ctx.stroke();
            }

            // Draw weight vector (normal to decision boundary)
            const cx = plotWidth / 2;
            const cy = plotHeight / 2;
            const vecLength = 80;
            const vecMag = Math.sqrt(w1 * w1 + w2 * w2) || 1;

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.lineWidth = 2;
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + (w1 / vecMag) * vecLength, cy - (w2 / vecMag) * vecLength);
            ctx.stroke();

            // Arrow head
            const angle = Math.atan2(-w2, w1);
            const arrowX = cx + (w1 / vecMag) * vecLength;
            const arrowY = cy - (w2 / vecMag) * vecLength;

            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 10 * Math.cos(angle - 0.4), arrowY + 10 * Math.sin(angle - 0.4));
            ctx.lineTo(arrowX - 10 * Math.cos(angle + 0.4), arrowY + 10 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.font = '12px sans-serif';
            ctx.fillText('w', arrowX + 10, arrowY - 5);

            // Draw points
            points.forEach(p => {
                const pred = predict(p.x, p.y);
                const target = p.label === 1 ? 1 : -1;
                const isCorrect = pred === target;

                ctx.beginPath();
                ctx.arc(p.x, p.y, isCorrect ? 6 : 8, 0, Math.PI * 2);
                ctx.fillStyle = p.label === 1 ? '#ff6464' : '#64c8ff';
                ctx.fill();

                ctx.strokeStyle = isCorrect ? '#fff' : '#ffff00';
                ctx.lineWidth = isCorrect ? 1 : 3;
                ctx.stroke();
            });

            // Draw perceptron diagram
            drawPerceptronDiagram();
        }

        function drawPerceptronDiagram() {
            const diagX = canvas.width - 300;
            const diagY = canvas.height - 180;
            const diagW = 260;
            const diagH = 150;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(diagX, diagY, diagW, diagH);

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Perceptron Diagram', diagX + 10, diagY + 20);

            // Input nodes
            const inputs = [
                { name: 'x₁', y: diagY + 50 },
                { name: 'x₂', y: diagY + 90 },
                { name: '1', y: diagY + 130 }
            ];

            const weights = [w1, w2, bias];
            const neuronX = diagX + diagW - 60;
            const neuronY = diagY + 90;

            inputs.forEach((inp, i) => {
                const inputX = diagX + 40;

                // Input node
                ctx.beginPath();
                ctx.arc(inputX, inp.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#444';
                ctx.fill();
                ctx.strokeStyle = '#c896ff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(inp.name, inputX, inp.y + 4);

                // Connection with weight
                const weightColor = weights[i] > 0 ? '#ff6464' : '#64c8ff';
                const weightWidth = 1 + Math.abs(weights[i]) * 2;

                ctx.beginPath();
                ctx.strokeStyle = weightColor;
                ctx.lineWidth = Math.min(weightWidth, 5);
                ctx.moveTo(inputX + 15, inp.y);
                ctx.lineTo(neuronX - 20, neuronY);
                ctx.stroke();

                // Weight label
                ctx.fillStyle = weightColor;
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(weights[i].toFixed(2), inputX + 50, inp.y - 5);
            });

            // Neuron (sum + activation)
            ctx.beginPath();
            ctx.arc(neuronX, neuronY, 20, 0, Math.PI * 2);
            ctx.fillStyle = '#c896ff';
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Σ', neuronX, neuronY + 5);

            // Output
            ctx.beginPath();
            ctx.strokeStyle = '#c896ff';
            ctx.lineWidth = 2;
            ctx.moveTo(neuronX + 20, neuronY);
            ctx.lineTo(neuronX + 50, neuronY);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('y', neuronX + 60, neuronY + 4);
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('learningRate').oninput = (e) => {
            learningRate = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = learningRate.toFixed(2);
        };

        document.querySelectorAll('.class-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedClass = parseInt(btn.dataset.class);
            };
        });

        document.getElementById('generateBtn').onclick = generateLinearData;
        document.getElementById('stepBtn').onclick = trainStep;
        document.getElementById('trainBtn').onclick = trainToConvergence;
        document.getElementById('resetBtn').onclick = resetWeights;

        document.getElementById('clearBtn').onclick = () => {
            points = [];
            resetWeights();
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (x < canvas.width - 350) {
                points.push({ x, y, label: selectedClass });
                converged = false;
                updateDisplay();
            }
        };

        // Initialize
        resetWeights();
        animate();
    </script>
</body>
</html>
