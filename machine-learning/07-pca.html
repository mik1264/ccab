<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Principal Component Analysis | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 150, 0.3);
        }
        h1 { color: #ff6496; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff6496; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff6496; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff88b0; }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff6496; font-weight: bold; }
        .variance-bar {
            height: 20px; background: #333; border-radius: 10px;
            margin: 5px 0; overflow: hidden;
        }
        .variance-fill { height: 100%; border-radius: 10px; transition: width 0.3s; }
        .pc1-fill { background: linear-gradient(90deg, #ff6496, #ff88b0); }
        .pc2-fill { background: linear-gradient(90deg, #64c8ff, #88d8ff); }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6496; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
        .checkbox-group input { width: auto; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Machine Learning</a>

    <div class="controls">
        <h1>Principal Component Analysis</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Dimensionality reduction visualization</p>

        <div class="control-group">
            <label>Dataset:</label>
            <select id="dataset">
                <option value="ellipse">Ellipse</option>
                <option value="clusters">Clusters</option>
                <option value="spiral">Spiral</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div class="control-group">
            <label>Points: <span class="value" id="nValue">100</span></label>
            <input type="range" id="nPoints" min="20" max="300" step="10" value="100">
        </div>

        <div class="control-group">
            <label>Noise: <span class="value" id="noiseValue">0.1</span></label>
            <input type="range" id="noise" min="0" max="0.5" step="0.05" value="0.1">
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showPC1" checked>
            <label for="showPC1" style="margin:0">Show PC1</label>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showPC2" checked>
            <label for="showPC2" style="margin:0">Show PC2</label>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showProjection" checked>
            <label for="showProjection" style="margin:0">Show Projections</label>
        </div>

        <button id="generateBtn">Generate Data</button>
        <button id="animateBtn" class="secondary">Animate PCA</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Total Points</span>
                <span class="stat-value" id="totalPoints">100</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">PC1 Variance</span>
                <span class="stat-value" id="pc1Var">-</span>
            </div>
            <div class="variance-bar">
                <div class="variance-fill pc1-fill" id="pc1Bar" style="width: 0%"></div>
            </div>
            <div class="stat-row">
                <span class="stat-label">PC2 Variance</span>
                <span class="stat-value" id="pc2Var">-</span>
            </div>
            <div class="variance-bar">
                <div class="variance-fill pc2-fill" id="pc2Bar" style="width: 0%"></div>
            </div>
        </div>

        <div class="info">
            <strong>PCA</strong> finds orthogonal axes that maximize variance.<br>
            <strong>Click</strong> to add points. Principal components update in real-time.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let points = [];
        let mean = { x: 0, y: 0 };
        let pc1 = { x: 1, y: 0 };
        let pc2 = { x: 0, y: 1 };
        let eigenvalues = [0, 0];
        let animating = false;
        let animationPhase = 0;

        function generateData() {
            const n = parseInt(document.getElementById('nPoints').value);
            const noise = parseFloat(document.getElementById('noise').value);
            const dataset = document.getElementById('dataset').value;

            points = [];

            switch (dataset) {
                case 'ellipse':
                    for (let i = 0; i < n; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const rx = 0.3 + (Math.random() - 0.5) * noise;
                        const ry = 0.1 + (Math.random() - 0.5) * noise;
                        // Rotate ellipse by 30 degrees
                        const rotAngle = Math.PI / 6;
                        const x = rx * Math.cos(angle);
                        const y = ry * Math.sin(angle);
                        points.push({
                            x: 0.5 + x * Math.cos(rotAngle) - y * Math.sin(rotAngle),
                            y: 0.5 + x * Math.sin(rotAngle) + y * Math.cos(rotAngle)
                        });
                    }
                    break;

                case 'clusters':
                    const centers = [
                        { x: 0.3, y: 0.3 },
                        { x: 0.7, y: 0.7 },
                        { x: 0.3, y: 0.7 }
                    ];
                    for (let i = 0; i < n; i++) {
                        const center = centers[i % centers.length];
                        points.push({
                            x: center.x + (Math.random() - 0.5) * noise * 2,
                            y: center.y + (Math.random() - 0.5) * noise * 2
                        });
                    }
                    break;

                case 'spiral':
                    for (let i = 0; i < n; i++) {
                        const t = (i / n) * 3 * Math.PI;
                        const r = 0.1 + t * 0.05;
                        points.push({
                            x: 0.5 + r * Math.cos(t) + (Math.random() - 0.5) * noise,
                            y: 0.5 + r * Math.sin(t) + (Math.random() - 0.5) * noise
                        });
                    }
                    break;

                case 'random':
                    for (let i = 0; i < n; i++) {
                        points.push({
                            x: 0.2 + Math.random() * 0.6,
                            y: 0.2 + Math.random() * 0.6
                        });
                    }
                    break;
            }

            computePCA();
            updateStats();
        }

        function computePCA() {
            if (points.length < 2) return;

            // Compute mean
            mean.x = points.reduce((s, p) => s + p.x, 0) / points.length;
            mean.y = points.reduce((s, p) => s + p.y, 0) / points.length;

            // Compute covariance matrix
            let cxx = 0, cxy = 0, cyy = 0;
            for (const p of points) {
                const dx = p.x - mean.x;
                const dy = p.y - mean.y;
                cxx += dx * dx;
                cxy += dx * dy;
                cyy += dy * dy;
            }
            cxx /= points.length;
            cxy /= points.length;
            cyy /= points.length;

            // Compute eigenvalues and eigenvectors analytically
            const trace = cxx + cyy;
            const det = cxx * cyy - cxy * cxy;
            const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));

            eigenvalues[0] = trace / 2 + discriminant;
            eigenvalues[1] = trace / 2 - discriminant;

            // Compute eigenvectors
            if (Math.abs(cxy) > 1e-10) {
                pc1.x = eigenvalues[0] - cyy;
                pc1.y = cxy;
                const len1 = Math.sqrt(pc1.x * pc1.x + pc1.y * pc1.y);
                pc1.x /= len1;
                pc1.y /= len1;

                pc2.x = eigenvalues[1] - cyy;
                pc2.y = cxy;
                const len2 = Math.sqrt(pc2.x * pc2.x + pc2.y * pc2.y);
                pc2.x /= len2;
                pc2.y /= len2;
            } else {
                if (cxx >= cyy) {
                    pc1 = { x: 1, y: 0 };
                    pc2 = { x: 0, y: 1 };
                } else {
                    pc1 = { x: 0, y: 1 };
                    pc2 = { x: 1, y: 0 };
                }
            }
        }

        function updateStats() {
            document.getElementById('totalPoints').textContent = points.length;

            const totalVar = eigenvalues[0] + eigenvalues[1];
            if (totalVar > 0) {
                const pc1Pct = (eigenvalues[0] / totalVar * 100).toFixed(1);
                const pc2Pct = (eigenvalues[1] / totalVar * 100).toFixed(1);

                document.getElementById('pc1Var').textContent = pc1Pct + '%';
                document.getElementById('pc2Var').textContent = pc2Pct + '%';
                document.getElementById('pc1Bar').style.width = pc1Pct + '%';
                document.getElementById('pc2Bar').style.width = pc2Pct + '%';
            } else {
                document.getElementById('pc1Var').textContent = '-';
                document.getElementById('pc2Var').textContent = '-';
                document.getElementById('pc1Bar').style.width = '0%';
                document.getElementById('pc2Bar').style.width = '0%';
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;
            const margin = 80;
            const scale = Math.min(plotWidth, plotHeight) - 2 * margin;

            const toScreen = (x, y) => ({
                sx: margin + x * scale,
                sy: margin + y * scale
            });

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const { sx: x1, sy: y1 } = toScreen(t, 0);
                const { sx: x2, sy: y2 } = toScreen(t, 1);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                const { sx: x3, sy: y3 } = toScreen(0, t);
                const { sx: x4, sy: y4 } = toScreen(1, t);
                ctx.beginPath();
                ctx.moveTo(x3, y3);
                ctx.lineTo(x4, y4);
                ctx.stroke();
            }

            if (points.length < 2) {
                // Draw points only
                for (const p of points) {
                    const { sx, sy } = toScreen(p.x, p.y);
                    ctx.beginPath();
                    ctx.arc(sx, sy, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#64c8ff';
                    ctx.fill();
                }
                requestAnimationFrame(draw);
                return;
            }

            const showPC1 = document.getElementById('showPC1').checked;
            const showPC2 = document.getElementById('showPC2').checked;
            const showProjection = document.getElementById('showProjection').checked;

            const { sx: mx, sy: my } = toScreen(mean.x, mean.y);

            // Draw projection lines
            if (showProjection) {
                for (const p of points) {
                    const { sx: px, sy: py } = toScreen(p.x, p.y);

                    if (showPC1) {
                        // Project onto PC1
                        const dx = p.x - mean.x;
                        const dy = p.y - mean.y;
                        const proj1 = dx * pc1.x + dy * pc1.y;
                        const projX1 = mean.x + proj1 * pc1.x;
                        const projY1 = mean.y + proj1 * pc1.y;
                        const { sx: prx1, sy: pry1 } = toScreen(projX1, projY1);

                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255, 100, 150, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.moveTo(px, py);
                        ctx.lineTo(prx1, pry1);
                        ctx.stroke();
                    }
                }
            }

            // Draw principal components
            const pcLength = 0.4;

            if (showPC1) {
                const { sx: p1x1, sy: p1y1 } = toScreen(mean.x - pc1.x * pcLength, mean.y - pc1.y * pcLength);
                const { sx: p1x2, sy: p1y2 } = toScreen(mean.x + pc1.x * pcLength, mean.y + pc1.y * pcLength);

                ctx.beginPath();
                ctx.strokeStyle = '#ff6496';
                ctx.lineWidth = 3;
                ctx.moveTo(p1x1, p1y1);
                ctx.lineTo(p1x2, p1y2);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(pc1.y, pc1.x);
                ctx.beginPath();
                ctx.moveTo(p1x2, p1y2);
                ctx.lineTo(p1x2 - 15 * Math.cos(angle - 0.3), p1y2 - 15 * Math.sin(angle - 0.3));
                ctx.moveTo(p1x2, p1y2);
                ctx.lineTo(p1x2 - 15 * Math.cos(angle + 0.3), p1y2 - 15 * Math.sin(angle + 0.3));
                ctx.stroke();

                ctx.fillStyle = '#ff6496';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText('PC1', p1x2 + 10, p1y2);
            }

            if (showPC2) {
                const { sx: p2x1, sy: p2y1 } = toScreen(mean.x - pc2.x * pcLength * 0.5, mean.y - pc2.y * pcLength * 0.5);
                const { sx: p2x2, sy: p2y2 } = toScreen(mean.x + pc2.x * pcLength * 0.5, mean.y + pc2.y * pcLength * 0.5);

                ctx.beginPath();
                ctx.strokeStyle = '#64c8ff';
                ctx.lineWidth = 3;
                ctx.moveTo(p2x1, p2y1);
                ctx.lineTo(p2x2, p2y2);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(pc2.y, pc2.x);
                ctx.beginPath();
                ctx.moveTo(p2x2, p2y2);
                ctx.lineTo(p2x2 - 12 * Math.cos(angle - 0.3), p2y2 - 12 * Math.sin(angle - 0.3));
                ctx.moveTo(p2x2, p2y2);
                ctx.lineTo(p2x2 - 12 * Math.cos(angle + 0.3), p2y2 - 12 * Math.sin(angle + 0.3));
                ctx.stroke();

                ctx.fillStyle = '#64c8ff';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText('PC2', p2x2 + 10, p2y2);
            }

            // Draw points
            for (const p of points) {
                const { sx, sy } = toScreen(p.x, p.y);
                ctx.beginPath();
                ctx.arc(sx, sy, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#64c8ff';
                ctx.fill();
            }

            // Draw mean
            ctx.beginPath();
            ctx.arc(mx, my, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ffd700';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Animation
            if (animating) {
                animationPhase += 0.02;
                if (animationPhase > Math.PI * 2) {
                    animationPhase = 0;
                }

                // Draw rotating line to show variance
                const rotAngle = animationPhase;
                const rotDir = { x: Math.cos(rotAngle), y: Math.sin(rotAngle) };

                // Calculate variance in this direction
                let variance = 0;
                for (const p of points) {
                    const dx = p.x - mean.x;
                    const dy = p.y - mean.y;
                    const proj = dx * rotDir.x + dy * rotDir.y;
                    variance += proj * proj;
                }
                variance /= points.length;

                const maxVar = eigenvalues[0];
                const varRatio = variance / maxVar;

                const lineLen = 0.3 * varRatio + 0.1;
                const { sx: rx1, sy: ry1 } = toScreen(mean.x - rotDir.x * lineLen, mean.y - rotDir.y * lineLen);
                const { sx: rx2, sy: ry2 } = toScreen(mean.x + rotDir.x * lineLen, mean.y + rotDir.y * lineLen);

                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + varRatio * 0.5})`;
                ctx.lineWidth = 2 + varRatio * 3;
                ctx.moveTo(rx1, ry1);
                ctx.lineTo(rx2, ry2);
                ctx.stroke();
            }

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('nPoints').oninput = (e) => {
            document.getElementById('nValue').textContent = e.target.value;
        };

        document.getElementById('noise').oninput = (e) => {
            document.getElementById('noiseValue').textContent = e.target.value;
        };

        document.getElementById('dataset').onchange = generateData;
        document.getElementById('generateBtn').onclick = generateData;

        document.getElementById('animateBtn').onclick = () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? 'Stop Animation' : 'Animate PCA';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;
            const margin = 80;
            const scale = Math.min(plotWidth, plotHeight) - 2 * margin;

            if (px < plotWidth) {
                const x = (px - margin) / scale;
                const y = (py - margin) / scale;

                if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                    points.push({ x, y });
                    computePCA();
                    updateStats();
                }
            }
        };

        // Initialize
        generateData();
        draw();
    </script>
</body>
</html>
