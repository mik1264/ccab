<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 150, 0.3);
        }
        h1 { color: #ff6496; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff6496; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff6496; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff88b0; }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff6496; font-weight: bold; }
        .best-solution {
            background: #222; padding: 10px; border-radius: 8px;
            margin: 10px 0; font-family: monospace; font-size: 0.9em;
            word-break: break-all;
        }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6496; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Machine Learning</a>

    <div class="controls">
        <h1>Genetic Algorithm</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Evolutionary optimization</p>

        <div class="control-group">
            <label>Problem:</label>
            <select id="problem">
                <option value="tsp">Traveling Salesman (TSP)</option>
                <option value="string">String Evolution</option>
                <option value="function">Function Optimization</option>
            </select>
        </div>

        <div class="control-group">
            <label>Population Size: <span class="value" id="popValue">50</span></label>
            <input type="range" id="popSize" min="20" max="200" step="10" value="50">
        </div>

        <div class="control-group">
            <label>Mutation Rate: <span class="value" id="mutValue">0.01</span></label>
            <input type="range" id="mutRate" min="0.001" max="0.1" step="0.001" value="0.01">
        </div>

        <div class="control-group">
            <label>Crossover Rate: <span class="value" id="crossValue">0.7</span></label>
            <input type="range" id="crossRate" min="0.1" max="1" step="0.1" value="0.7">
        </div>

        <div class="control-group">
            <label>Selection:</label>
            <select id="selection">
                <option value="tournament">Tournament</option>
                <option value="roulette">Roulette Wheel</option>
                <option value="rank">Rank Selection</option>
            </select>
        </div>

        <button id="runBtn">Run Evolution</button>
        <button id="stepBtn" class="secondary">Step</button>
        <button id="resetBtn" class="secondary">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Generation</span>
                <span class="stat-value" id="generation">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Best Fitness</span>
                <span class="stat-value" id="bestFitness">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Fitness</span>
                <span class="stat-value" id="avgFitness">-</span>
            </div>
        </div>

        <div class="best-solution" id="bestSolution">Best: -</div>

        <div class="info">
            <strong>GA</strong> evolves solutions through selection, crossover, and mutation.<br>
            Watch populations converge toward optimal solutions.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let population = [];
        let generation = 0;
        let running = false;
        let fitnessHistory = [];
        let cities = [];
        let targetString = "HELLO GENETIC ALGORITHM";

        let popSize = 50;
        let mutRate = 0.01;
        let crossRate = 0.7;
        let selectionType = 'tournament';
        let problemType = 'tsp';

        // TSP functions
        function generateCities(n = 15) {
            cities = [];
            for (let i = 0; i < n; i++) {
                cities.push({
                    x: 100 + Math.random() * 500,
                    y: 100 + Math.random() * 400
                });
            }
        }

        function tspDistance(route) {
            let dist = 0;
            for (let i = 0; i < route.length; i++) {
                const c1 = cities[route[i]];
                const c2 = cities[route[(i + 1) % route.length]];
                dist += Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
            }
            return dist;
        }

        function createTSPIndividual() {
            const route = [...Array(cities.length).keys()];
            // Shuffle
            for (let i = route.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [route[i], route[j]] = [route[j], route[i]];
            }
            return route;
        }

        function tspCrossover(p1, p2) {
            // Order crossover (OX)
            const start = Math.floor(Math.random() * p1.length);
            const end = start + Math.floor(Math.random() * (p1.length - start));

            const child = new Array(p1.length).fill(-1);

            // Copy segment from p1
            for (let i = start; i <= end; i++) {
                child[i] = p1[i];
            }

            // Fill rest from p2
            let pos = (end + 1) % p1.length;
            for (let i = 0; i < p2.length; i++) {
                const idx = (end + 1 + i) % p2.length;
                if (!child.includes(p2[idx])) {
                    child[pos] = p2[idx];
                    pos = (pos + 1) % p1.length;
                }
            }

            return child;
        }

        function tspMutate(route) {
            if (Math.random() < mutRate) {
                // Swap mutation
                const i = Math.floor(Math.random() * route.length);
                const j = Math.floor(Math.random() * route.length);
                [route[i], route[j]] = [route[j], route[i]];
            }
            return route;
        }

        // String evolution functions
        function stringFitness(str) {
            let score = 0;
            for (let i = 0; i < targetString.length; i++) {
                if (str[i] === targetString[i]) score++;
            }
            return score / targetString.length;
        }

        function createStringIndividual() {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
            let str = "";
            for (let i = 0; i < targetString.length; i++) {
                str += chars[Math.floor(Math.random() * chars.length)];
            }
            return str;
        }

        function stringCrossover(p1, p2) {
            const mid = Math.floor(Math.random() * p1.length);
            return p1.slice(0, mid) + p2.slice(mid);
        }

        function stringMutate(str) {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
            let result = str.split('');
            for (let i = 0; i < result.length; i++) {
                if (Math.random() < mutRate) {
                    result[i] = chars[Math.floor(Math.random() * chars.length)];
                }
            }
            return result.join('');
        }

        // Function optimization
        function funcFitness(genes) {
            // Rastrigin function (minimize)
            const x = genes[0] * 10 - 5;
            const y = genes[1] * 10 - 5;
            const A = 10;
            const f = A * 2 + (x * x - A * Math.cos(2 * Math.PI * x)) +
                (y * y - A * Math.cos(2 * Math.PI * y));
            return 1 / (1 + f); // Convert to maximization
        }

        function createFuncIndividual() {
            return [Math.random(), Math.random()];
        }

        function funcCrossover(p1, p2) {
            const alpha = Math.random();
            return [
                alpha * p1[0] + (1 - alpha) * p2[0],
                alpha * p1[1] + (1 - alpha) * p2[1]
            ];
        }

        function funcMutate(genes) {
            return genes.map(g => {
                if (Math.random() < mutRate) {
                    return Math.max(0, Math.min(1, g + (Math.random() - 0.5) * 0.2));
                }
                return g;
            });
        }

        // Selection methods
        function tournamentSelect(pop, fitnesses) {
            const tournamentSize = 3;
            let best = Math.floor(Math.random() * pop.length);

            for (let i = 1; i < tournamentSize; i++) {
                const idx = Math.floor(Math.random() * pop.length);
                if (fitnesses[idx] > fitnesses[best]) {
                    best = idx;
                }
            }

            return pop[best];
        }

        function rouletteSelect(pop, fitnesses) {
            const total = fitnesses.reduce((a, b) => a + Math.max(0, b), 0);
            let r = Math.random() * total;

            for (let i = 0; i < pop.length; i++) {
                r -= Math.max(0, fitnesses[i]);
                if (r <= 0) return pop[i];
            }

            return pop[pop.length - 1];
        }

        function rankSelect(pop, fitnesses) {
            const indices = [...Array(pop.length).keys()];
            indices.sort((a, b) => fitnesses[a] - fitnesses[b]);

            const ranks = new Array(pop.length);
            indices.forEach((idx, rank) => ranks[idx] = rank + 1);

            const total = (pop.length * (pop.length + 1)) / 2;
            let r = Math.random() * total;

            for (let i = 0; i < pop.length; i++) {
                r -= ranks[i];
                if (r <= 0) return pop[i];
            }

            return pop[pop.length - 1];
        }

        function select(pop, fitnesses) {
            switch (selectionType) {
                case 'tournament': return tournamentSelect(pop, fitnesses);
                case 'roulette': return rouletteSelect(pop, fitnesses);
                case 'rank': return rankSelect(pop, fitnesses);
            }
        }

        // Generic GA functions
        function getFitness(individual) {
            switch (problemType) {
                case 'tsp': return 1 / tspDistance(individual);
                case 'string': return stringFitness(individual);
                case 'function': return funcFitness(individual);
            }
        }

        function createIndividual() {
            switch (problemType) {
                case 'tsp': return createTSPIndividual();
                case 'string': return createStringIndividual();
                case 'function': return createFuncIndividual();
            }
        }

        function crossover(p1, p2) {
            switch (problemType) {
                case 'tsp': return tspCrossover(p1, p2);
                case 'string': return stringCrossover(p1, p2);
                case 'function': return funcCrossover(p1, p2);
            }
        }

        function mutate(individual) {
            switch (problemType) {
                case 'tsp': return tspMutate([...individual]);
                case 'string': return stringMutate(individual);
                case 'function': return funcMutate([...individual]);
            }
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                population.push(createIndividual());
            }
            generation = 0;
            fitnessHistory = [];

            if (problemType === 'tsp') {
                generateCities();
            }

            updateStats();
        }

        function evolve() {
            const fitnesses = population.map(getFitness);

            // Elitism: keep best individual
            const bestIdx = fitnesses.indexOf(Math.max(...fitnesses));
            const elite = problemType === 'function' ?
                [...population[bestIdx]] :
                (problemType === 'tsp' ? [...population[bestIdx]] : population[bestIdx]);

            const newPop = [elite];

            while (newPop.length < popSize) {
                const p1 = select(population, fitnesses);
                const p2 = select(population, fitnesses);

                let child;
                if (Math.random() < crossRate) {
                    child = crossover(p1, p2);
                } else {
                    child = problemType === 'function' ? [...p1] :
                        (problemType === 'tsp' ? [...p1] : p1);
                }

                child = mutate(child);
                newPop.push(child);
            }

            population = newPop;
            generation++;

            const newFitnesses = population.map(getFitness);
            const maxFit = Math.max(...newFitnesses);
            const avgFit = newFitnesses.reduce((a, b) => a + b) / newFitnesses.length;

            fitnessHistory.push({ max: maxFit, avg: avgFit });
            if (fitnessHistory.length > 200) fitnessHistory.shift();

            updateStats();
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation;

            if (population.length > 0) {
                const fitnesses = population.map(getFitness);
                const bestIdx = fitnesses.indexOf(Math.max(...fitnesses));
                const best = population[bestIdx];
                const maxFit = fitnesses[bestIdx];
                const avgFit = fitnesses.reduce((a, b) => a + b) / fitnesses.length;

                document.getElementById('bestFitness').textContent = maxFit.toFixed(6);
                document.getElementById('avgFitness').textContent = avgFit.toFixed(6);

                let bestStr;
                switch (problemType) {
                    case 'tsp':
                        bestStr = `Route: ${best.join('→')} (dist: ${tspDistance(best).toFixed(1)})`;
                        break;
                    case 'string':
                        bestStr = `"${best}"`;
                        break;
                    case 'function':
                        const x = best[0] * 10 - 5;
                        const y = best[1] * 10 - 5;
                        bestStr = `x=${x.toFixed(4)}, y=${y.toFixed(4)}`;
                        break;
                }
                document.getElementById('bestSolution').textContent = `Best: ${bestStr}`;
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;

            // Draw problem-specific visualization
            if (problemType === 'tsp' && cities.length > 0) {
                drawTSP(plotWidth, plotHeight);
            } else if (problemType === 'string') {
                drawStringEvolution(plotWidth, plotHeight);
            } else if (problemType === 'function') {
                drawFunctionOptimization(plotWidth, plotHeight);
            }

            // Draw fitness graph
            drawFitnessGraph(50, plotHeight - 200, plotWidth - 100, 150);

            if (running) {
                evolve();
            }

            requestAnimationFrame(draw);
        }

        function drawTSP(width, height) {
            const fitnesses = population.map(getFitness);
            const bestIdx = fitnesses.indexOf(Math.max(...fitnesses));
            const best = population[bestIdx];

            // Draw cities
            for (let i = 0; i < cities.length; i++) {
                ctx.beginPath();
                ctx.arc(cities[i].x, cities[i].y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6496';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.fillText(i.toString(), cities[i].x - 4, cities[i].y + 4);
            }

            // Draw best route
            if (best) {
                ctx.beginPath();
                ctx.strokeStyle = '#64c8ff';
                ctx.lineWidth = 2;

                ctx.moveTo(cities[best[0]].x, cities[best[0]].y);
                for (let i = 1; i < best.length; i++) {
                    ctx.lineTo(cities[best[i]].x, cities[best[i]].y);
                }
                ctx.lineTo(cities[best[0]].x, cities[best[0]].y);
                ctx.stroke();
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('Traveling Salesman Problem', 50, 50);
        }

        function drawStringEvolution(width, height) {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('String Evolution', 50, 50);

            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#888';
            ctx.fillText(`Target: "${targetString}"`, 50, 80);

            // Show top individuals
            const fitnesses = population.map(getFitness);
            const sorted = [...population].sort((a, b) =>
                stringFitness(b) - stringFitness(a)
            );

            ctx.font = '16px monospace';
            for (let i = 0; i < Math.min(15, sorted.length); i++) {
                const fit = stringFitness(sorted[i]);

                // Color code matches
                for (let j = 0; j < sorted[i].length; j++) {
                    const char = sorted[i][j];
                    if (char === targetString[j]) {
                        ctx.fillStyle = '#64ff96';
                    } else {
                        ctx.fillStyle = '#ff6496';
                    }
                    ctx.fillText(char, 50 + j * 12, 120 + i * 25);
                }

                ctx.fillStyle = '#888';
                ctx.fillText(`${(fit * 100).toFixed(0)}%`, 50 + sorted[i].length * 12 + 20, 120 + i * 25);
            }
        }

        function drawFunctionOptimization(width, height) {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('Function Optimization (Rastrigin)', 50, 50);

            // Draw fitness landscape
            const plotX = 50;
            const plotY = 80;
            const plotW = 400;
            const plotH = 300;

            // Draw heatmap
            const resolution = 4;
            for (let px = 0; px < plotW; px += resolution) {
                for (let py = 0; py < plotH; py += resolution) {
                    const x = (px / plotW);
                    const y = (py / plotH);
                    const fit = funcFitness([x, y]);

                    const intensity = Math.floor(fit * 255);
                    ctx.fillStyle = `rgb(${intensity}, ${intensity * 0.5}, ${255 - intensity})`;
                    ctx.fillRect(plotX + px, plotY + py, resolution, resolution);
                }
            }

            // Draw population
            for (const ind of population) {
                const px = plotX + ind[0] * plotW;
                const py = plotY + ind[1] * plotH;

                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fill();
            }

            // Highlight best
            const fitnesses = population.map(getFitness);
            const bestIdx = fitnesses.indexOf(Math.max(...fitnesses));
            const best = population[bestIdx];

            ctx.beginPath();
            ctx.arc(plotX + best[0] * plotW, plotY + best[1] * plotH, 8, 0, Math.PI * 2);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawFitnessGraph(x, y, width, height) {
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(x - 10, y - 30, width + 20, height + 50);

            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Fitness Over Generations', x, y - 10);

            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height);
            ctx.lineTo(x + width, y + height);
            ctx.stroke();

            if (fitnessHistory.length < 2) return;

            // Find range
            let maxFit = 0;
            for (const h of fitnessHistory) {
                maxFit = Math.max(maxFit, h.max);
            }
            maxFit = maxFit || 1;

            // Draw average fitness
            ctx.beginPath();
            ctx.strokeStyle = '#64c8ff';
            ctx.lineWidth = 1;
            for (let i = 0; i < fitnessHistory.length; i++) {
                const px = x + (i / (fitnessHistory.length - 1)) * width;
                const py = y + height - (fitnessHistory[i].avg / maxFit) * height;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw best fitness
            ctx.beginPath();
            ctx.strokeStyle = '#ff6496';
            ctx.lineWidth = 2;
            for (let i = 0; i < fitnessHistory.length; i++) {
                const px = x + (i / (fitnessHistory.length - 1)) * width;
                const py = y + height - (fitnessHistory[i].max / maxFit) * height;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Legend
            ctx.fillStyle = '#ff6496';
            ctx.fillRect(x + width - 100, y + 10, 15, 10);
            ctx.fillStyle = '#fff';
            ctx.fillText('Best', x + width - 80, y + 18);

            ctx.fillStyle = '#64c8ff';
            ctx.fillRect(x + width - 100, y + 25, 15, 10);
            ctx.fillStyle = '#fff';
            ctx.fillText('Avg', x + width - 80, y + 33);
        }

        // Event listeners
        document.getElementById('problem').onchange = (e) => {
            problemType = e.target.value;
            initPopulation();
        };

        document.getElementById('popSize').oninput = (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = popSize;
        };

        document.getElementById('mutRate').oninput = (e) => {
            mutRate = parseFloat(e.target.value);
            document.getElementById('mutValue').textContent = mutRate.toFixed(3);
        };

        document.getElementById('crossRate').oninput = (e) => {
            crossRate = parseFloat(e.target.value);
            document.getElementById('crossValue').textContent = crossRate.toFixed(1);
        };

        document.getElementById('selection').onchange = (e) => {
            selectionType = e.target.value;
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Run Evolution';
        };

        document.getElementById('stepBtn').onclick = evolve;

        document.getElementById('resetBtn').onclick = () => {
            running = false;
            document.getElementById('runBtn').textContent = 'Run Evolution';
            initPopulation();
        };

        // Initialize
        initPopulation();
        draw();
    </script>
</body>
</html>
