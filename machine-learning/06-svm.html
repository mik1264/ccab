<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support Vector Machine | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 150, 0.3);
        }
        h1 { color: #ff6496; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff6496; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff6496; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff88b0; }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff6496; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6496; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 8px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Machine Learning</a>

    <div class="controls">
        <h1>Support Vector Machine</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Interactive SVM classifier</p>

        <div class="control-group">
            <label>Kernel: <span class="value" id="kernelValue">RBF</span></label>
            <select id="kernel">
                <option value="linear">Linear</option>
                <option value="rbf" selected>RBF (Gaussian)</option>
                <option value="polynomial">Polynomial</option>
            </select>
        </div>

        <div class="control-group">
            <label>C (Regularization): <span class="value" id="cValue">1.0</span></label>
            <input type="range" id="cParam" min="-2" max="2" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Gamma (RBF): <span class="value" id="gammaValue">1.0</span></label>
            <input type="range" id="gamma" min="-2" max="2" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Degree (Polynomial): <span class="value" id="degreeValue">3</span></label>
            <input type="range" id="degree" min="2" max="5" step="1" value="3">
        </div>

        <div class="control-group">
            <label>Class to Add:</label>
            <select id="currentClass">
                <option value="1">Class 1 (Blue)</option>
                <option value="-1">Class -1 (Red)</option>
            </select>
        </div>

        <button id="trainBtn">Train SVM</button>
        <button id="generateBtn" class="secondary">Generate Data</button>
        <button id="clearBtn" class="secondary">Clear Points</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Total Points</span>
                <span class="stat-value" id="totalPoints">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Support Vectors</span>
                <span class="stat-value" id="supportVectors">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Training Accuracy</span>
                <span class="stat-value" id="accuracy">-</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background:#64c8ff"></div>
                <span>Class 1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#ff6496"></div>
                <span>Class -1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#ffd700; border: 2px solid #fff"></div>
                <span>Support Vectors</span>
            </div>
        </div>

        <div class="info">
            <strong>Click</strong> to add points.<br>
            <strong>SVM</strong> finds the optimal hyperplane that maximizes margin between classes.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let points = [];
        let supportVectorIndices = [];
        let alphas = [];
        let bias = 0;
        let trained = false;

        let kernel = 'rbf';
        let C = 1.0;
        let gamma = 1.0;
        let degree = 3;

        // Kernel functions
        function linearKernel(x1, x2) {
            return x1[0] * x2[0] + x1[1] * x2[1];
        }

        function rbfKernel(x1, x2) {
            const dx = x1[0] - x2[0];
            const dy = x1[1] - x2[1];
            return Math.exp(-gamma * (dx * dx + dy * dy));
        }

        function polyKernel(x1, x2) {
            return Math.pow(1 + linearKernel(x1, x2), degree);
        }

        function getKernel() {
            switch (kernel) {
                case 'linear': return linearKernel;
                case 'rbf': return rbfKernel;
                case 'polynomial': return polyKernel;
            }
        }

        // Simplified SMO algorithm
        function trainSVM() {
            if (points.length < 2) return;

            const n = points.length;
            alphas = new Array(n).fill(0);
            bias = 0;
            const K = getKernel();

            // Precompute kernel matrix
            const kernelMatrix = [];
            for (let i = 0; i < n; i++) {
                kernelMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    kernelMatrix[i][j] = K(
                        [points[i].x, points[i].y],
                        [points[j].x, points[j].y]
                    );
                }
            }

            // SMO-like optimization (simplified)
            const maxIter = 1000;
            const tol = 1e-3;

            for (let iter = 0; iter < maxIter; iter++) {
                let alphaChanged = 0;

                for (let i = 0; i < n; i++) {
                    // Calculate error for point i
                    let fi = bias;
                    for (let j = 0; j < n; j++) {
                        fi += alphas[j] * points[j].label * kernelMatrix[i][j];
                    }
                    const Ei = fi - points[i].label;

                    // Check KKT conditions
                    if ((points[i].label * Ei < -tol && alphas[i] < C) ||
                        (points[i].label * Ei > tol && alphas[i] > 0)) {

                        // Select j randomly
                        let j = Math.floor(Math.random() * n);
                        while (j === i) j = Math.floor(Math.random() * n);

                        // Calculate error for point j
                        let fj = bias;
                        for (let k = 0; k < n; k++) {
                            fj += alphas[k] * points[k].label * kernelMatrix[j][k];
                        }
                        const Ej = fj - points[j].label;

                        const alphaIOld = alphas[i];
                        const alphaJOld = alphas[j];

                        // Compute bounds
                        let L, H;
                        if (points[i].label !== points[j].label) {
                            L = Math.max(0, alphas[j] - alphas[i]);
                            H = Math.min(C, C + alphas[j] - alphas[i]);
                        } else {
                            L = Math.max(0, alphas[i] + alphas[j] - C);
                            H = Math.min(C, alphas[i] + alphas[j]);
                        }

                        if (L >= H) continue;

                        const eta = 2 * kernelMatrix[i][j] - kernelMatrix[i][i] - kernelMatrix[j][j];
                        if (eta >= 0) continue;

                        // Update alpha j
                        alphas[j] -= points[j].label * (Ei - Ej) / eta;
                        alphas[j] = Math.min(H, Math.max(L, alphas[j]));

                        if (Math.abs(alphas[j] - alphaJOld) < 1e-5) continue;

                        // Update alpha i
                        alphas[i] += points[i].label * points[j].label * (alphaJOld - alphas[j]);

                        // Update bias
                        const b1 = bias - Ei - points[i].label * (alphas[i] - alphaIOld) * kernelMatrix[i][i]
                            - points[j].label * (alphas[j] - alphaJOld) * kernelMatrix[i][j];
                        const b2 = bias - Ej - points[i].label * (alphas[i] - alphaIOld) * kernelMatrix[i][j]
                            - points[j].label * (alphas[j] - alphaJOld) * kernelMatrix[j][j];

                        if (0 < alphas[i] && alphas[i] < C) {
                            bias = b1;
                        } else if (0 < alphas[j] && alphas[j] < C) {
                            bias = b2;
                        } else {
                            bias = (b1 + b2) / 2;
                        }

                        alphaChanged++;
                    }
                }

                if (alphaChanged === 0) break;
            }

            // Find support vectors
            supportVectorIndices = [];
            for (let i = 0; i < n; i++) {
                if (alphas[i] > 1e-5) {
                    supportVectorIndices.push(i);
                }
            }

            trained = true;
            updateStats();
        }

        function predict(x, y) {
            if (!trained) return 0;

            const K = getKernel();
            let result = bias;

            for (let i = 0; i < points.length; i++) {
                if (alphas[i] > 1e-5) {
                    result += alphas[i] * points[i].label * K(
                        [points[i].x, points[i].y],
                        [x, y]
                    );
                }
            }

            return result;
        }

        function calculateAccuracy() {
            if (!trained || points.length === 0) return 0;

            let correct = 0;
            for (const p of points) {
                const pred = predict(p.x, p.y);
                if ((pred >= 0 && p.label === 1) || (pred < 0 && p.label === -1)) {
                    correct++;
                }
            }
            return (correct / points.length * 100).toFixed(1);
        }

        function generateData() {
            points = [];
            trained = false;

            // Generate two clusters
            const patterns = ['clusters', 'xor', 'circles'][Math.floor(Math.random() * 3)];

            if (patterns === 'clusters') {
                // Linear-ish separation
                for (let i = 0; i < 40; i++) {
                    points.push({
                        x: 0.2 + Math.random() * 0.25,
                        y: 0.2 + Math.random() * 0.6,
                        label: 1
                    });
                    points.push({
                        x: 0.55 + Math.random() * 0.25,
                        y: 0.2 + Math.random() * 0.6,
                        label: -1
                    });
                }
            } else if (patterns === 'xor') {
                // XOR pattern
                for (let i = 0; i < 25; i++) {
                    points.push({ x: 0.2 + Math.random() * 0.2, y: 0.2 + Math.random() * 0.2, label: 1 });
                    points.push({ x: 0.6 + Math.random() * 0.2, y: 0.6 + Math.random() * 0.2, label: 1 });
                    points.push({ x: 0.2 + Math.random() * 0.2, y: 0.6 + Math.random() * 0.2, label: -1 });
                    points.push({ x: 0.6 + Math.random() * 0.2, y: 0.2 + Math.random() * 0.2, label: -1 });
                }
            } else {
                // Concentric circles
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r1 = 0.1 + Math.random() * 0.05;
                    const r2 = 0.25 + Math.random() * 0.05;
                    points.push({
                        x: 0.5 + Math.cos(angle) * r1,
                        y: 0.5 + Math.sin(angle) * r1,
                        label: 1
                    });
                    points.push({
                        x: 0.5 + Math.cos(angle) * r2,
                        y: 0.5 + Math.sin(angle) * r2,
                        label: -1
                    });
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('totalPoints').textContent = points.length;
            document.getElementById('supportVectors').textContent = supportVectorIndices.length;
            document.getElementById('accuracy').textContent = trained ? calculateAccuracy() + '%' : '-';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;
            const margin = 50;

            // Draw decision boundary
            if (trained) {
                const resolution = 8;
                for (let px = 0; px < plotWidth; px += resolution) {
                    for (let py = 0; py < plotHeight; py += resolution) {
                        const x = (px - margin) / (plotWidth - 2 * margin);
                        const y = (py - margin) / (plotHeight - 2 * margin);

                        const val = predict(x, y);
                        const intensity = Math.min(Math.abs(val) * 0.3, 0.4);

                        if (val >= 0) {
                            ctx.fillStyle = `rgba(100, 200, 255, ${intensity})`;
                        } else {
                            ctx.fillStyle = `rgba(255, 100, 150, ${intensity})`;
                        }
                        ctx.fillRect(px, py, resolution, resolution);
                    }
                }

                // Draw decision boundary contour (where predict = 0)
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let px = margin; px < plotWidth - margin; px += 5) {
                    for (let py = margin; py < plotHeight - margin; py += 5) {
                        const x = (px - margin) / (plotWidth - 2 * margin);
                        const y = (py - margin) / (plotHeight - 2 * margin);
                        const val = predict(x, y);

                        if (Math.abs(val) < 0.1) {
                            ctx.moveTo(px, py);
                            ctx.arc(px, py, 1, 0, Math.PI * 2);
                        }
                    }
                }
                ctx.stroke();
            }

            // Draw points
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const px = margin + p.x * (plotWidth - 2 * margin);
                const py = margin + p.y * (plotHeight - 2 * margin);

                const isSV = supportVectorIndices.includes(i);

                ctx.beginPath();
                ctx.arc(px, py, isSV ? 10 : 6, 0, Math.PI * 2);

                if (p.label === 1) {
                    ctx.fillStyle = '#64c8ff';
                } else {
                    ctx.fillStyle = '#ff6496';
                }
                ctx.fill();

                if (isSV) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, plotHeight - margin);
            ctx.lineTo(plotWidth - margin, plotHeight - margin);
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, plotHeight - margin);
            ctx.stroke();

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('kernel').onchange = (e) => {
            kernel = e.target.value;
            document.getElementById('kernelValue').textContent = e.target.options[e.target.selectedIndex].text;
            trained = false;
            updateStats();
        };

        document.getElementById('cParam').oninput = (e) => {
            C = Math.pow(10, parseFloat(e.target.value));
            document.getElementById('cValue').textContent = C.toFixed(2);
        };

        document.getElementById('gamma').oninput = (e) => {
            gamma = Math.pow(10, parseFloat(e.target.value));
            document.getElementById('gammaValue').textContent = gamma.toFixed(2);
        };

        document.getElementById('degree').oninput = (e) => {
            degree = parseInt(e.target.value);
            document.getElementById('degreeValue').textContent = degree;
        };

        document.getElementById('trainBtn').onclick = trainSVM;
        document.getElementById('generateBtn').onclick = generateData;
        document.getElementById('clearBtn').onclick = () => {
            points = [];
            trained = false;
            supportVectorIndices = [];
            updateStats();
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;
            const margin = 50;

            if (px < plotWidth - margin && px > margin && py > margin && py < plotHeight - margin) {
                const x = (px - margin) / (plotWidth - 2 * margin);
                const y = (py - margin) / (plotHeight - 2 * margin);

                const currentClass = parseInt(document.getElementById('currentClass').value);
                points.push({ x, y, label: currentClass });
                trained = false;
                updateStats();
            }
        };

        // Initialize
        generateData();
        draw();
    </script>
</body>
</html>
