<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 150, 50, 0.3);
        }
        h1 { color: #ff9632; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff9632; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff9632; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ffb060; }
        .optimizer-btns { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin: 10px 0; }
        .opt-btn {
            padding: 8px; border: 1px solid rgba(255, 150, 50, 0.3);
            background: rgba(255, 150, 50, 0.1);
            color: #ff9632; border-radius: 5px;
            cursor: pointer; font-size: 0.8em;
        }
        .opt-btn.active { background: #ff9632; color: #1a1a2e; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff9632; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff9632; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        #lossChart { margin-top: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Machine Learning</a>

    <div class="controls">
        <h1>Gradient Descent</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Optimization on loss landscapes</p>

        <div class="control-group">
            <label>Loss Function</label>
            <select id="lossFunction">
                <option value="bowl">Quadratic Bowl</option>
                <option value="rosenbrock">Rosenbrock</option>
                <option value="saddle">Saddle Point</option>
                <option value="rastrigin">Rastrigin (Many Minima)</option>
                <option value="beale">Beale Function</option>
            </select>
        </div>

        <div class="optimizer-btns">
            <button class="opt-btn active" data-opt="sgd">SGD</button>
            <button class="opt-btn" data-opt="momentum">Momentum</button>
            <button class="opt-btn" data-opt="rmsprop">RMSProp</button>
            <button class="opt-btn" data-opt="adam">Adam</button>
        </div>

        <div class="control-group">
            <label>Learning Rate: <span class="value" id="lrValue">0.01</span></label>
            <input type="range" id="learningRate" min="-4" max="0" step="0.1" value="-2">
        </div>

        <div class="control-group">
            <label>Momentum (β): <span class="value" id="betaValue">0.9</span></label>
            <input type="range" id="beta" min="0" max="0.99" step="0.01" value="0.9">
        </div>

        <button id="stepBtn">Step</button>
        <button id="runBtn">Run</button>
        <button id="resetBtn">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Iteration</span>
                <span class="stat-value" id="iteration">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Loss</span>
                <span class="stat-value" id="loss">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Position</span>
                <span class="stat-value" id="position">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Gradient Norm</span>
                <span class="stat-value" id="gradNorm">-</span>
            </div>
        </div>

        <canvas id="lossChart" width="240" height="80"></canvas>

        <div class="info">
            <strong>Click</strong> on the landscape to set starting position.<br>
            Compare how different optimizers navigate the loss surface!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('lossChart');
        const chartCtx = chartCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let x = 2, y = 2;
        let vx = 0, vy = 0; // velocity for momentum
        let sx = 0, sy = 0; // squared gradient for RMSProp
        let mx = 0, my = 0; // first moment for Adam
        let iteration = 0;
        let running = false;
        let lossHistory = [];

        let lossFunction = 'bowl';
        let optimizer = 'sgd';
        let learningRate = 0.01;
        let beta = 0.9;
        let beta2 = 0.999;
        let epsilon = 1e-8;

        let trail = [];

        // Loss functions
        function loss(x, y) {
            switch (lossFunction) {
                case 'bowl':
                    return x * x + y * y;
                case 'rosenbrock':
                    return Math.pow(1 - x, 2) + 100 * Math.pow(y - x * x, 2);
                case 'saddle':
                    return x * x - y * y;
                case 'rastrigin':
                    return 20 + (x * x - 10 * Math.cos(2 * Math.PI * x)) +
                           (y * y - 10 * Math.cos(2 * Math.PI * y));
                case 'beale':
                    return Math.pow(1.5 - x + x * y, 2) +
                           Math.pow(2.25 - x + x * y * y, 2) +
                           Math.pow(2.625 - x + x * y * y * y, 2);
            }
        }

        function gradient(x, y) {
            const h = 0.0001;
            const dx = (loss(x + h, y) - loss(x - h, y)) / (2 * h);
            const dy = (loss(x, y + h) - loss(x, y - h)) / (2 * h);
            return { dx, dy };
        }

        function step() {
            const grad = gradient(x, y);
            iteration++;

            switch (optimizer) {
                case 'sgd':
                    x -= learningRate * grad.dx;
                    y -= learningRate * grad.dy;
                    break;

                case 'momentum':
                    vx = beta * vx + learningRate * grad.dx;
                    vy = beta * vy + learningRate * grad.dy;
                    x -= vx;
                    y -= vy;
                    break;

                case 'rmsprop':
                    sx = beta * sx + (1 - beta) * grad.dx * grad.dx;
                    sy = beta * sy + (1 - beta) * grad.dy * grad.dy;
                    x -= learningRate * grad.dx / (Math.sqrt(sx) + epsilon);
                    y -= learningRate * grad.dy / (Math.sqrt(sy) + epsilon);
                    break;

                case 'adam':
                    mx = beta * mx + (1 - beta) * grad.dx;
                    my = beta * my + (1 - beta) * grad.dy;
                    sx = beta2 * sx + (1 - beta2) * grad.dx * grad.dx;
                    sy = beta2 * sy + (1 - beta2) * grad.dy * grad.dy;

                    const mxHat = mx / (1 - Math.pow(beta, iteration));
                    const myHat = my / (1 - Math.pow(beta, iteration));
                    const sxHat = sx / (1 - Math.pow(beta2, iteration));
                    const syHat = sy / (1 - Math.pow(beta2, iteration));

                    x -= learningRate * mxHat / (Math.sqrt(sxHat) + epsilon);
                    y -= learningRate * myHat / (Math.sqrt(syHat) + epsilon);
                    break;
            }

            // Clamp to bounds
            x = Math.max(-5, Math.min(5, x));
            y = Math.max(-5, Math.min(5, y));

            trail.push({ x, y });
            if (trail.length > 500) trail.shift();

            const currentLoss = loss(x, y);
            lossHistory.push(currentLoss);
            if (lossHistory.length > 200) lossHistory.shift();

            updateStats(grad);
        }

        function reset() {
            x = 2;
            y = 2;
            vx = vy = 0;
            sx = sy = 0;
            mx = my = 0;
            iteration = 0;
            trail = [];
            lossHistory = [];
            running = false;
            document.getElementById('runBtn').textContent = 'Run';
            updateStats({ dx: 0, dy: 0 });
        }

        function updateStats(grad) {
            const currentLoss = loss(x, y);
            const gradNorm = Math.sqrt(grad.dx * grad.dx + grad.dy * grad.dy);

            document.getElementById('iteration').textContent = iteration;
            document.getElementById('loss').textContent = currentLoss.toFixed(6);
            document.getElementById('position').textContent = `(${x.toFixed(3)}, ${y.toFixed(3)})`;
            document.getElementById('gradNorm').textContent = gradNorm.toFixed(6);

            drawLossChart();
        }

        function draw() {
            const plotSize = Math.min(canvas.width - 350, canvas.height - 100);
            const plotX = 50;
            const plotY = (canvas.height - plotSize) / 2;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw loss surface as heatmap
            const resolution = 100;
            const cellSize = plotSize / resolution;

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const px = -5 + (i / resolution) * 10;
                    const py = 5 - (j / resolution) * 10;
                    const l = loss(px, py);

                    // Map loss to color
                    let normalizedL;
                    if (lossFunction === 'rosenbrock') {
                        normalizedL = Math.min(1, Math.log(l + 1) / 10);
                    } else if (lossFunction === 'rastrigin') {
                        normalizedL = Math.min(1, l / 80);
                    } else if (lossFunction === 'beale') {
                        normalizedL = Math.min(1, Math.log(l + 1) / 5);
                    } else {
                        normalizedL = Math.min(1, l / 25);
                    }

                    const r = Math.floor(normalizedL * 200 + 30);
                    const g = Math.floor((1 - normalizedL) * 150 + 50);
                    const b = Math.floor((1 - normalizedL) * 200 + 50);

                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(plotX + i * cellSize, plotY + j * cellSize, cellSize + 1, cellSize + 1);
                }
            }

            // Draw contour lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;

            const contourLevels = lossFunction === 'rosenbrock' ?
                [0.1, 1, 10, 100, 1000] :
                [1, 5, 10, 20, 30];

            // Draw trail
            if (trail.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 150, 50, 0.8)';
                ctx.lineWidth = 2;

                trail.forEach((p, i) => {
                    const px = plotX + ((p.x + 5) / 10) * plotSize;
                    const py = plotY + ((5 - p.y) / 10) * plotSize;

                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.stroke();
            }

            // Draw current position
            const currentPx = plotX + ((x + 5) / 10) * plotSize;
            const currentPy = plotY + ((5 - y) / 10) * plotSize;

            ctx.beginPath();
            ctx.arc(currentPx, currentPy, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ff9632';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw gradient arrow
            const grad = gradient(x, y);
            const gradScale = 50 / (Math.sqrt(grad.dx * grad.dx + grad.dy * grad.dy) + 1);
            const arrowX = currentPx - grad.dx * gradScale;
            const arrowY = currentPy + grad.dy * gradScale;

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.lineWidth = 2;
            ctx.moveTo(currentPx, currentPy);
            ctx.lineTo(arrowX, arrowY);
            ctx.stroke();

            // Arrow head
            const angle = Math.atan2(arrowY - currentPy, arrowX - currentPx);
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 8 * Math.cos(angle - 0.4), arrowY - 8 * Math.sin(angle - 0.4));
            ctx.lineTo(arrowX - 8 * Math.cos(angle + 0.4), arrowY - 8 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.fill();

            // Draw minimum marker
            let minX = 0, minY = 0;
            if (lossFunction === 'rosenbrock') { minX = 1; minY = 1; }
            else if (lossFunction === 'beale') { minX = 3; minY = 0.5; }

            const minPx = plotX + ((minX + 5) / 10) * plotSize;
            const minPy = plotY + ((5 - minY) / 10) * plotSize;

            ctx.beginPath();
            ctx.arc(minPx, minPy, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#64ff64';
            ctx.fill();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('-5', plotX - 20, plotY + plotSize / 2);
            ctx.fillText('5', plotX + plotSize + 5, plotY + plotSize / 2);
            ctx.fillText('5', plotX + plotSize / 2, plotY - 5);
            ctx.fillText('-5', plotX + plotSize / 2, plotY + plotSize + 15);
        }

        function drawLossChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;

            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, w, h);

            if (lossHistory.length < 2) return;

            const maxLoss = Math.max(...lossHistory);
            const minLoss = Math.min(...lossHistory);
            const range = maxLoss - minLoss || 1;

            chartCtx.beginPath();
            chartCtx.strokeStyle = '#ff9632';
            chartCtx.lineWidth = 2;

            lossHistory.forEach((l, i) => {
                const px = (i / (lossHistory.length - 1)) * w;
                const py = h - ((l - minLoss) / range) * (h - 20) - 10;
                if (i === 0) chartCtx.moveTo(px, py);
                else chartCtx.lineTo(px, py);
            });
            chartCtx.stroke();

            chartCtx.fillStyle = '#666';
            chartCtx.font = '10px sans-serif';
            chartCtx.fillText('Loss over iterations', 5, 12);
        }

        function animate() {
            if (running) {
                step();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('lossFunction').onchange = (e) => {
            lossFunction = e.target.value;
            reset();
        };

        document.querySelectorAll('.opt-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.opt-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                optimizer = btn.dataset.opt;
            };
        });

        document.getElementById('learningRate').oninput = (e) => {
            learningRate = Math.pow(10, parseFloat(e.target.value));
            document.getElementById('lrValue').textContent = learningRate.toFixed(4);
        };

        document.getElementById('beta').oninput = (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('betaValue').textContent = beta.toFixed(2);
        };

        document.getElementById('stepBtn').onclick = step;
        document.getElementById('resetBtn').onclick = reset;

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Pause' : 'Run';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const plotSize = Math.min(canvas.width - 350, canvas.height - 100);
            const plotX = 50;
            const plotY = (canvas.height - plotSize) / 2;

            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            if (clickX >= plotX && clickX <= plotX + plotSize &&
                clickY >= plotY && clickY <= plotY + plotSize) {
                x = ((clickX - plotX) / plotSize) * 10 - 5;
                y = 5 - ((clickY - plotY) / plotSize) * 10;
                vx = vy = sx = sy = mx = my = 0;
                iteration = 0;
                trail = [{ x, y }];
                lossHistory = [loss(x, y)];
                updateStats({ dx: 0, dy: 0 });
            }
        };

        // Initialize
        trail = [{ x, y }];
        lossHistory = [loss(x, y)];
        updateStats({ dx: 0, dy: 0 });
        animate();
    </script>
</body>
</html>
