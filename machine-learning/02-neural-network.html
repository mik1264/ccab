<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        h1 { color: #64c8ff; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #64c8ff; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c8ff; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88d8ff; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64c8ff; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c8ff; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        #lossChart { margin-top: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
        .layer-config { display: flex; gap: 5px; margin: 10px 0; }
        .layer-input {
            flex: 1; padding: 5px; border-radius: 5px;
            background: #333; color: #fff; border: 1px solid #555;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Machine Learning</a>

    <div class="controls">
        <h1>Neural Network</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Visualize forward & backward propagation</p>

        <div class="control-group">
            <label>Dataset</label>
            <select id="dataset">
                <option value="xor">XOR Problem</option>
                <option value="circle">Circle</option>
                <option value="spiral">Spiral</option>
                <option value="clusters">Clusters</option>
            </select>
        </div>

        <div class="control-group">
            <label>Hidden Layers (comma-separated)</label>
            <div class="layer-config">
                <input type="text" id="layers" class="layer-input" value="4,4">
            </div>
        </div>

        <div class="control-group">
            <label>Learning Rate: <span class="value" id="lrValue">0.1</span></label>
            <input type="range" id="learningRate" min="-3" max="0" step="0.1" value="-1">
        </div>

        <div class="control-group">
            <label>Activation</label>
            <select id="activation">
                <option value="relu">ReLU</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="tanh">Tanh</option>
            </select>
        </div>

        <button id="initBtn">Initialize Network</button>
        <button id="stepBtn">Train Step</button>
        <button id="trainBtn">Train 100 Steps</button>
        <button id="runBtn">Auto Train</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Epoch</span>
                <span class="stat-value" id="epoch">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Loss</span>
                <span class="stat-value" id="loss">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Accuracy</span>
                <span class="stat-value" id="accuracy">-</span>
            </div>
        </div>

        <canvas id="lossChart" width="240" height="80"></canvas>

        <div class="info">
            <strong>Colors:</strong> Node brightness = activation<br>
            Edge color = weight (blue=neg, red=pos)<br>
            Decision boundary shown in the data plot.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('lossChart');
        const chartCtx = chartCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let network = null;
        let data = [];
        let epoch = 0;
        let running = false;
        let lossHistory = [];
        let learningRate = 0.1;
        let activationType = 'relu';

        // Neural Network class
        class NeuralNetwork {
            constructor(layerSizes) {
                this.layers = layerSizes;
                this.weights = [];
                this.biases = [];
                this.activations = [];
                this.zValues = [];

                // Initialize weights and biases
                for (let i = 1; i < layerSizes.length; i++) {
                    const w = [];
                    const b = [];
                    for (let j = 0; j < layerSizes[i]; j++) {
                        const row = [];
                        for (let k = 0; k < layerSizes[i-1]; k++) {
                            row.push((Math.random() - 0.5) * Math.sqrt(2 / layerSizes[i-1]));
                        }
                        w.push(row);
                        b.push(0);
                    }
                    this.weights.push(w);
                    this.biases.push(b);
                }
            }

            activation(x) {
                switch (activationType) {
                    case 'relu': return Math.max(0, x);
                    case 'sigmoid': return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
                    case 'tanh': return Math.tanh(x);
                }
            }

            activationDerivative(x) {
                switch (activationType) {
                    case 'relu': return x > 0 ? 1 : 0;
                    case 'sigmoid': const s = this.activation(x); return s * (1 - s);
                    case 'tanh': const t = Math.tanh(x); return 1 - t * t;
                }
            }

            forward(input) {
                this.activations = [input];
                this.zValues = [];

                let current = input;
                for (let l = 0; l < this.weights.length; l++) {
                    const z = [];
                    const a = [];
                    for (let j = 0; j < this.weights[l].length; j++) {
                        let sum = this.biases[l][j];
                        for (let k = 0; k < current.length; k++) {
                            sum += this.weights[l][j][k] * current[k];
                        }
                        z.push(sum);
                        // Use sigmoid for output layer
                        if (l === this.weights.length - 1) {
                            a.push(1 / (1 + Math.exp(-Math.max(-500, Math.min(500, sum)))));
                        } else {
                            a.push(this.activation(sum));
                        }
                    }
                    this.zValues.push(z);
                    this.activations.push(a);
                    current = a;
                }

                return current;
            }

            backward(target, lr) {
                const deltas = [];

                // Output layer delta
                const outputLayer = this.activations.length - 1;
                const outputDelta = [];
                for (let j = 0; j < this.activations[outputLayer].length; j++) {
                    const a = this.activations[outputLayer][j];
                    const error = a - target[j];
                    outputDelta.push(error * a * (1 - a)); // sigmoid derivative
                }
                deltas.unshift(outputDelta);

                // Hidden layer deltas
                for (let l = this.weights.length - 2; l >= 0; l--) {
                    const layerDelta = [];
                    for (let j = 0; j < this.weights[l].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < this.weights[l + 1].length; k++) {
                            sum += this.weights[l + 1][k][j] * deltas[0][k];
                        }
                        layerDelta.push(sum * this.activationDerivative(this.zValues[l][j]));
                    }
                    deltas.unshift(layerDelta);
                }

                // Update weights and biases
                for (let l = 0; l < this.weights.length; l++) {
                    for (let j = 0; j < this.weights[l].length; j++) {
                        for (let k = 0; k < this.weights[l][j].length; k++) {
                            this.weights[l][j][k] -= lr * deltas[l][j] * this.activations[l][k];
                        }
                        this.biases[l][j] -= lr * deltas[l][j];
                    }
                }
            }

            train(inputs, targets, lr) {
                let totalLoss = 0;
                for (let i = 0; i < inputs.length; i++) {
                    const output = this.forward(inputs[i]);
                    this.backward(targets[i], lr);

                    for (let j = 0; j < output.length; j++) {
                        totalLoss += Math.pow(output[j] - targets[i][j], 2);
                    }
                }
                return totalLoss / inputs.length;
            }

            predict(input) {
                return this.forward(input);
            }
        }

        function generateData(type) {
            data = [];
            const n = 100;

            switch (type) {
                case 'xor':
                    for (let i = 0; i < n; i++) {
                        const x = Math.random() * 2 - 1;
                        const y = Math.random() * 2 - 1;
                        const label = (x > 0) !== (y > 0) ? 1 : 0;
                        data.push({ input: [x, y], target: [label] });
                    }
                    break;

                case 'circle':
                    for (let i = 0; i < n; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() < 0.5 ?
                            Math.random() * 0.4 :
                            0.6 + Math.random() * 0.4;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        const label = r < 0.5 ? 1 : 0;
                        data.push({ input: [x, y], target: [label] });
                    }
                    break;

                case 'spiral':
                    for (let i = 0; i < n / 2; i++) {
                        const t = i / (n / 2) * 2 * Math.PI;
                        const r = t / (2 * Math.PI) * 0.8;
                        const noise = (Math.random() - 0.5) * 0.1;
                        data.push({
                            input: [Math.cos(t) * r + noise, Math.sin(t) * r + noise],
                            target: [1]
                        });
                        data.push({
                            input: [Math.cos(t + Math.PI) * r + noise, Math.sin(t + Math.PI) * r + noise],
                            target: [0]
                        });
                    }
                    break;

                case 'clusters':
                    const centers = [[0.5, 0.5], [-0.5, -0.5], [0.5, -0.5], [-0.5, 0.5]];
                    for (let i = 0; i < n; i++) {
                        const c = centers[i % 4];
                        const x = c[0] + (Math.random() - 0.5) * 0.4;
                        const y = c[1] + (Math.random() - 0.5) * 0.4;
                        const label = i % 4 < 2 ? 1 : 0;
                        data.push({ input: [x, y], target: [label] });
                    }
                    break;
            }
        }

        function initNetwork() {
            const layerText = document.getElementById('layers').value;
            const hiddenLayers = layerText.split(',').map(x => parseInt(x.trim())).filter(x => x > 0);
            const layerSizes = [2, ...hiddenLayers, 1];

            network = new NeuralNetwork(layerSizes);
            epoch = 0;
            lossHistory = [];
            updateStats();
        }

        function trainStep() {
            if (!network) initNetwork();

            const inputs = data.map(d => d.input);
            const targets = data.map(d => d.target);
            const loss = network.train(inputs, targets, learningRate);

            epoch++;
            lossHistory.push(loss);
            if (lossHistory.length > 200) lossHistory.shift();

            updateStats();
        }

        function updateStats() {
            let correct = 0;
            data.forEach(d => {
                const pred = network.predict(d.input)[0];
                if ((pred > 0.5) === (d.target[0] > 0.5)) correct++;
            });

            const accuracy = (correct / data.length * 100).toFixed(1);
            const loss = lossHistory.length > 0 ? lossHistory[lossHistory.length - 1].toFixed(6) : '-';

            document.getElementById('epoch').textContent = epoch;
            document.getElementById('loss').textContent = loss;
            document.getElementById('accuracy').textContent = accuracy + '%';

            drawLossChart();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!network) return;

            // Layout
            const dataPlotSize = 300;
            const dataPlotX = 50;
            const dataPlotY = 50;

            // Draw decision boundary
            drawDecisionBoundary(dataPlotX, dataPlotY, dataPlotSize);

            // Draw data points
            drawDataPoints(dataPlotX, dataPlotY, dataPlotSize);

            // Draw network
            const netX = dataPlotX + dataPlotSize + 100;
            const netY = 50;
            const netWidth = canvas.width - netX - 350;
            const netHeight = canvas.height - 100;
            drawNetwork(netX, netY, netWidth, netHeight);
        }

        function drawDecisionBoundary(x, y, size) {
            const resolution = 50;
            const cellSize = size / resolution;

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const px = (i / resolution) * 2 - 1;
                    const py = 1 - (j / resolution) * 2;

                    const pred = network.predict([px, py])[0];

                    const r = Math.floor(pred * 100 + 50);
                    const g = Math.floor((1 - pred) * 100 + 50);
                    const b = Math.floor(150);

                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x + i * cellSize, y + j * cellSize, cellSize + 1, cellSize + 1);
                }
            }

            // Border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, size, size);
        }

        function drawDataPoints(x, y, size) {
            data.forEach(d => {
                const px = x + ((d.input[0] + 1) / 2) * size;
                const py = y + ((1 - d.input[1]) / 2) * size;

                ctx.beginPath();
                ctx.arc(px, py, 5, 0, Math.PI * 2);
                ctx.fillStyle = d.target[0] > 0.5 ? '#64c8ff' : '#ff6464';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        function drawNetwork(x, y, w, h) {
            const layers = network.layers;
            const layerSpacing = w / (layers.length - 1);
            const nodePositions = [];

            // Calculate node positions
            for (let l = 0; l < layers.length; l++) {
                const layerNodes = [];
                const nodeSpacing = h / (layers[l] + 1);

                for (let n = 0; n < layers[l]; n++) {
                    layerNodes.push({
                        x: x + l * layerSpacing,
                        y: y + (n + 1) * nodeSpacing
                    });
                }
                nodePositions.push(layerNodes);
            }

            // Draw edges
            for (let l = 0; l < network.weights.length; l++) {
                for (let j = 0; j < network.weights[l].length; j++) {
                    for (let k = 0; k < network.weights[l][j].length; k++) {
                        const weight = network.weights[l][j][k];
                        const from = nodePositions[l][k];
                        const to = nodePositions[l + 1][j];

                        const intensity = Math.min(1, Math.abs(weight));
                        const r = weight > 0 ? Math.floor(255 * intensity) : 100;
                        const g = 100;
                        const b = weight < 0 ? Math.floor(255 * intensity) : 100;

                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + intensity * 0.5})`;
                        ctx.lineWidth = 1 + intensity * 2;
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            for (let l = 0; l < layers.length; l++) {
                for (let n = 0; n < layers[l]; n++) {
                    const pos = nodePositions[l][n];
                    const activation = network.activations[l] ? network.activations[l][n] : 0.5;
                    const brightness = Math.floor(50 + activation * 205);

                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    ctx.fill();
                    ctx.strokeStyle = '#64c8ff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Layer labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Input', x, y + h + 20);
            ctx.fillText('Output', x + (layers.length - 1) * layerSpacing, y + h + 20);

            for (let l = 1; l < layers.length - 1; l++) {
                ctx.fillText(`Hidden ${l}`, x + l * layerSpacing, y + h + 20);
            }
        }

        function drawLossChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;

            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, w, h);

            if (lossHistory.length < 2) return;

            const maxLoss = Math.max(...lossHistory);
            const minLoss = Math.min(...lossHistory);
            const range = maxLoss - minLoss || 1;

            chartCtx.beginPath();
            chartCtx.strokeStyle = '#64c8ff';
            chartCtx.lineWidth = 2;

            lossHistory.forEach((l, i) => {
                const px = (i / (lossHistory.length - 1)) * w;
                const py = h - ((l - minLoss) / range) * (h - 20) - 10;
                if (i === 0) chartCtx.moveTo(px, py);
                else chartCtx.lineTo(px, py);
            });
            chartCtx.stroke();

            chartCtx.fillStyle = '#666';
            chartCtx.font = '10px sans-serif';
            chartCtx.fillText('Loss', 5, 12);
        }

        function animate() {
            if (running && network) {
                trainStep();
            }

            // Do a forward pass for visualization
            if (network && data.length > 0) {
                network.forward(data[0].input);
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('dataset').onchange = (e) => {
            generateData(e.target.value);
            initNetwork();
        };

        document.getElementById('learningRate').oninput = (e) => {
            learningRate = Math.pow(10, parseFloat(e.target.value));
            document.getElementById('lrValue').textContent = learningRate.toFixed(3);
        };

        document.getElementById('activation').onchange = (e) => {
            activationType = e.target.value;
        };

        document.getElementById('initBtn').onclick = initNetwork;
        document.getElementById('stepBtn').onclick = trainStep;

        document.getElementById('trainBtn').onclick = () => {
            for (let i = 0; i < 100; i++) trainStep();
        };

        document.getElementById('runBtn').onclick = () => {
            running = !running;
            document.getElementById('runBtn').textContent = running ? 'Stop' : 'Auto Train';
        };

        // Initialize
        generateData('xor');
        initNetwork();
        animate();
    </script>
</body>
</html>
