<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree | Machine Learning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 255, 150, 0.3);
        }
        h1 { color: #64ff96; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #64ff96; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64ff96; color: #1a1a2e;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88ffb0; }
        .class-btns { display: flex; gap: 10px; margin: 10px 0; }
        .class-btn {
            flex: 1; padding: 10px; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold;
        }
        .class-btn.class-0 { background: #64c8ff; color: #1a1a2e; }
        .class-btn.class-1 { background: #ff6464; color: #fff; }
        .class-btn.active { outline: 3px solid #fff; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64ff96; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64ff96; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Machine Learning</a>

    <div class="controls">
        <h1>Decision Tree</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Build and visualize decision boundaries</p>

        <div class="control-group">
            <label>Max Depth: <span class="value" id="depthValue">4</span></label>
            <input type="range" id="maxDepth" min="1" max="10" value="4">
        </div>

        <div class="control-group">
            <label>Min Samples Split: <span class="value" id="minSamplesValue">2</span></label>
            <input type="range" id="minSamples" min="1" max="20" value="2">
        </div>

        <div class="control-group">
            <label>Criterion</label>
            <select id="criterion">
                <option value="gini">Gini Impurity</option>
                <option value="entropy">Entropy</option>
            </select>
        </div>

        <div class="class-btns">
            <button class="class-btn class-0 active" data-class="0">Class A</button>
            <button class="class-btn class-1" data-class="1">Class B</button>
        </div>

        <button id="generateBtn">Generate Sample Data</button>
        <button id="trainBtn">Train Tree</button>
        <button id="clearBtn">Clear Data</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Points</span>
                <span class="stat-value" id="pointCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Tree Depth</span>
                <span class="stat-value" id="treeDepth">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Leaf Nodes</span>
                <span class="stat-value" id="leafCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Accuracy</span>
                <span class="stat-value" id="accuracy">-</span>
            </div>
        </div>

        <div class="info">
            <strong>Click</strong> to add points of selected class.<br>
            Decision trees partition space with axis-aligned splits.<br>
            Watch how tree structure creates decision boundaries!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let points = [];
        let tree = null;
        let selectedClass = 0;
        let maxDepth = 4;
        let minSamples = 2;
        let criterion = 'gini';

        class DecisionTreeNode {
            constructor() {
                this.feature = null;
                this.threshold = null;
                this.left = null;
                this.right = null;
                this.prediction = null;
                this.depth = 0;
            }
        }

        function giniImpurity(labels) {
            if (labels.length === 0) return 0;
            const counts = {};
            labels.forEach(l => counts[l] = (counts[l] || 0) + 1);
            let impurity = 1;
            Object.values(counts).forEach(c => {
                const p = c / labels.length;
                impurity -= p * p;
            });
            return impurity;
        }

        function entropy(labels) {
            if (labels.length === 0) return 0;
            const counts = {};
            labels.forEach(l => counts[l] = (counts[l] || 0) + 1);
            let ent = 0;
            Object.values(counts).forEach(c => {
                const p = c / labels.length;
                if (p > 0) ent -= p * Math.log2(p);
            });
            return ent;
        }

        function impurity(labels) {
            return criterion === 'gini' ? giniImpurity(labels) : entropy(labels);
        }

        function findBestSplit(data, depth) {
            if (data.length < minSamples || depth >= maxDepth) {
                return null;
            }

            const labels = data.map(d => d.label);
            const currentImpurity = impurity(labels);

            if (currentImpurity === 0) return null;

            let bestGain = 0;
            let bestFeature = null;
            let bestThreshold = null;

            // Try each feature (x=0, y=1)
            for (let feature = 0; feature < 2; feature++) {
                const values = [...new Set(data.map(d => feature === 0 ? d.x : d.y))].sort((a, b) => a - b);

                for (let i = 0; i < values.length - 1; i++) {
                    const threshold = (values[i] + values[i + 1]) / 2;

                    const left = data.filter(d => (feature === 0 ? d.x : d.y) <= threshold);
                    const right = data.filter(d => (feature === 0 ? d.x : d.y) > threshold);

                    if (left.length === 0 || right.length === 0) continue;

                    const leftImpurity = impurity(left.map(d => d.label));
                    const rightImpurity = impurity(right.map(d => d.label));

                    const weightedImpurity = (left.length / data.length) * leftImpurity +
                                            (right.length / data.length) * rightImpurity;

                    const gain = currentImpurity - weightedImpurity;

                    if (gain > bestGain) {
                        bestGain = gain;
                        bestFeature = feature;
                        bestThreshold = threshold;
                    }
                }
            }

            if (bestGain > 0) {
                return { feature: bestFeature, threshold: bestThreshold };
            }

            return null;
        }

        function buildTree(data, depth = 0) {
            const node = new DecisionTreeNode();
            node.depth = depth;

            const labels = data.map(d => d.label);
            const counts = {};
            labels.forEach(l => counts[l] = (counts[l] || 0) + 1);

            // Majority vote for prediction
            node.prediction = Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];

            const split = findBestSplit(data, depth);

            if (split) {
                node.feature = split.feature;
                node.threshold = split.threshold;

                const left = data.filter(d => (split.feature === 0 ? d.x : d.y) <= split.threshold);
                const right = data.filter(d => (split.feature === 0 ? d.x : d.y) > split.threshold);

                node.left = buildTree(left, depth + 1);
                node.right = buildTree(right, depth + 1);
            }

            return node;
        }

        function predict(node, point) {
            if (node.feature === null) {
                return parseInt(node.prediction);
            }

            const value = node.feature === 0 ? point.x : point.y;
            if (value <= node.threshold) {
                return predict(node.left, point);
            } else {
                return predict(node.right, point);
            }
        }

        function getTreeDepth(node) {
            if (!node || node.feature === null) return 0;
            return 1 + Math.max(getTreeDepth(node.left), getTreeDepth(node.right));
        }

        function countLeaves(node) {
            if (!node) return 0;
            if (node.feature === null) return 1;
            return countLeaves(node.left) + countLeaves(node.right);
        }

        function trainTree() {
            if (points.length < 2) return;
            tree = buildTree(points);
            updateStats();
        }

        function generateSampleData() {
            points = [];

            // Generate XOR-like pattern
            for (let i = 0; i < 50; i++) {
                points.push({
                    x: 100 + Math.random() * 200,
                    y: 100 + Math.random() * 200,
                    label: 0
                });
                points.push({
                    x: 400 + Math.random() * 200,
                    y: 400 + Math.random() * 200,
                    label: 0
                });
                points.push({
                    x: 100 + Math.random() * 200,
                    y: 400 + Math.random() * 200,
                    label: 1
                });
                points.push({
                    x: 400 + Math.random() * 200,
                    y: 100 + Math.random() * 200,
                    label: 1
                });
            }

            tree = null;
            updateStats();
        }

        function updateStats() {
            const depth = tree ? getTreeDepth(tree) : 0;
            const leaves = tree ? countLeaves(tree) : 0;

            let accuracy = '-';
            if (tree && points.length > 0) {
                let correct = 0;
                points.forEach(p => {
                    if (predict(tree, p) === p.label) correct++;
                });
                accuracy = (correct / points.length * 100).toFixed(1) + '%';
            }

            document.getElementById('pointCount').textContent = points.length;
            document.getElementById('treeDepth').textContent = depth;
            document.getElementById('leafCount').textContent = leaves;
            document.getElementById('accuracy').textContent = accuracy;
        }

        function drawDecisionBoundary() {
            if (!tree) return;

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height;
            const resolution = 5;

            for (let x = 0; x < plotWidth; x += resolution) {
                for (let y = 0; y < plotHeight; y += resolution) {
                    const pred = predict(tree, { x, y });
                    ctx.fillStyle = pred === 0 ? 'rgba(100, 200, 255, 0.2)' : 'rgba(255, 100, 100, 0.2)';
                    ctx.fillRect(x, y, resolution, resolution);
                }
            }
        }

        function drawSplits(node, x1, y1, x2, y2) {
            if (!node || node.feature === null) return;

            ctx.strokeStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            if (node.feature === 0) {
                // Vertical split
                ctx.moveTo(node.threshold, y1);
                ctx.lineTo(node.threshold, y2);
                ctx.stroke();

                drawSplits(node.left, x1, y1, node.threshold, y2);
                drawSplits(node.right, node.threshold, y1, x2, y2);
            } else {
                // Horizontal split
                ctx.moveTo(x1, node.threshold);
                ctx.lineTo(x2, node.threshold);
                ctx.stroke();

                drawSplits(node.left, x1, y1, x2, node.threshold);
                drawSplits(node.right, x1, node.threshold, x2, y2);
            }
        }

        function drawTree() {
            if (!tree) return;

            const treeX = canvas.width - 320;
            const treeY = canvas.height - 250;
            const treeWidth = 280;
            const treeHeight = 200;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(treeX, treeY, treeWidth, treeHeight);

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Tree Structure', treeX + 10, treeY + 20);

            drawTreeNode(tree, treeX + treeWidth / 2, treeY + 50, treeWidth / 3);
        }

        function drawTreeNode(node, x, y, spread) {
            if (!node) return;

            const nodeRadius = 15;

            // Draw edges to children
            if (node.left) {
                ctx.beginPath();
                ctx.strokeStyle = '#64c8ff';
                ctx.lineWidth = 1;
                ctx.moveTo(x, y + nodeRadius);
                ctx.lineTo(x - spread, y + 50 - nodeRadius);
                ctx.stroke();
                drawTreeNode(node.left, x - spread, y + 50, spread / 2);
            }

            if (node.right) {
                ctx.beginPath();
                ctx.strokeStyle = '#ff6464';
                ctx.lineWidth = 1;
                ctx.moveTo(x, y + nodeRadius);
                ctx.lineTo(x + spread, y + 50 - nodeRadius);
                ctx.stroke();
                drawTreeNode(node.right, x + spread, y + 50, spread / 2);
            }

            // Draw node
            ctx.beginPath();
            ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);

            if (node.feature === null) {
                // Leaf node
                ctx.fillStyle = parseInt(node.prediction) === 0 ? '#64c8ff' : '#ff6464';
            } else {
                ctx.fillStyle = '#64ff96';
            }
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#000';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            if (node.feature !== null) {
                ctx.fillText(node.feature === 0 ? 'x' : 'y', x, y + 4);
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw decision boundary
            drawDecisionBoundary();

            // Draw split lines
            if (tree) {
                drawSplits(tree, 0, 0, canvas.width - 350, canvas.height);
            }

            // Draw points
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = p.label === 0 ? '#64c8ff' : '#ff6464';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw tree visualization
            drawTree();
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('maxDepth').oninput = (e) => {
            maxDepth = parseInt(e.target.value);
            document.getElementById('depthValue').textContent = maxDepth;
        };

        document.getElementById('minSamples').oninput = (e) => {
            minSamples = parseInt(e.target.value);
            document.getElementById('minSamplesValue').textContent = minSamples;
        };

        document.getElementById('criterion').onchange = (e) => {
            criterion = e.target.value;
        };

        document.querySelectorAll('.class-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedClass = parseInt(btn.dataset.class);
            };
        });

        document.getElementById('generateBtn').onclick = generateSampleData;
        document.getElementById('trainBtn').onclick = trainTree;

        document.getElementById('clearBtn').onclick = () => {
            points = [];
            tree = null;
            updateStats();
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (x < canvas.width - 350) {
                points.push({ x, y, label: selectedClass });
                updateStats();
            }
        };

        // Initialize
        updateStats();
        animate();
    </script>
</body>
</html>
