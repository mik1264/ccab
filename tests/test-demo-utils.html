<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Utils Unit Tests</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: #1a1a2e;
            color: #e8e6e1;
            padding: 2rem;
            margin: 0;
            min-height: 100vh;
        }
        h1 {
            color: #fbbf24;
            margin-bottom: 1rem;
        }
        .summary {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }
        .summary.pass {
            border-left: 4px solid #10b981;
        }
        .summary.fail {
            border-left: 4px solid #e11d48;
        }
        .stats {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .passed { color: #10b981; }
        .failed { color: #e11d48; }
        #output {
            background: #0d0d1a;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
            line-height: 1.6;
        }
        .test-pass {
            color: #10b981;
        }
        .test-fail {
            color: #e11d48;
        }
        .test-error {
            color: #fbbf24;
            padding-left: 2rem;
            font-size: 0.9rem;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 1rem;
            color: #8b8b8b;
            text-decoration: none;
        }
        .back-link:hover {
            color: #fbbf24;
        }
        button {
            background: #fbbf24;
            color: #1a1a2e;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 1rem;
        }
        button:hover {
            background: #f59e0b;
        }
        .controls {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">&larr; Back to Gallery</a>
    <h1>Demo Utils Unit Tests</h1>

    <div class="controls">
        <button onclick="runTests()">Run Tests</button>
    </div>

    <div id="summary" class="summary" style="display: none;">
        <div class="stats">
            <span class="passed" id="passed-count">0</span> passed,
            <span class="failed" id="failed-count">0</span> failed
        </div>
        <div id="status"></div>
    </div>

    <pre id="output">Click "Run Tests" to start...</pre>

    <!-- Load the utility library -->
    <script src="../assets/js/demo-utils.js"></script>

    <script>
        // Simple test framework (embedded for browser)
        class TestRunner {
            constructor() {
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
                this.errors = [];
                this.output = [];
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            log(message, className = '') {
                this.output.push({ message, className });
            }

            async run() {
                this.passed = 0;
                this.failed = 0;
                this.errors = [];
                this.output = [];

                this.log('Running demo-utils.js unit tests...\n');
                this.log('='.repeat(60));

                for (const { name, fn } of this.tests) {
                    try {
                        await fn();
                        this.passed++;
                        this.log(`  \u2713 ${name}`, 'test-pass');
                    } catch (error) {
                        this.failed++;
                        this.errors.push({ name, error: error.message });
                        this.log(`  \u2717 ${name}`, 'test-fail');
                        this.log(`    Error: ${error.message}`, 'test-error');
                    }
                }

                this.log('\n' + '='.repeat(60));
                this.log(`Results: ${this.passed} passed, ${this.failed} failed`);
                this.log('='.repeat(60));

                return this.failed === 0;
            }

            render(outputEl, summaryEl) {
                let html = '';
                for (const { message, className } of this.output) {
                    if (className) {
                        html += `<span class="${className}">${this.escapeHtml(message)}</span>\n`;
                    } else {
                        html += this.escapeHtml(message) + '\n';
                    }
                }
                outputEl.innerHTML = html;

                document.getElementById('passed-count').textContent = this.passed;
                document.getElementById('failed-count').textContent = this.failed;
                document.getElementById('status').textContent = this.failed === 0
                    ? 'All tests passed!'
                    : `${this.failed} test(s) failed`;
                summaryEl.className = 'summary ' + (this.failed === 0 ? 'pass' : 'fail');
                summaryEl.style.display = 'block';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Assertion helpers
        function assertEqual(actual, expected, message = '') {
            if (actual !== expected) {
                throw new Error(`${message} Expected ${expected}, got ${actual}`);
            }
        }

        function assertAlmostEqual(actual, expected, tolerance = 0.0001, message = '') {
            if (Math.abs(actual - expected) > tolerance) {
                throw new Error(`${message} Expected ~${expected}, got ${actual}`);
            }
        }

        function assertTrue(condition, message = 'Expected true') {
            if (!condition) {
                throw new Error(message);
            }
        }

        function assertFalse(condition, message = 'Expected false') {
            if (condition) {
                throw new Error(message);
            }
        }

        function assertDeepEqual(actual, expected, message = '') {
            const actualStr = JSON.stringify(actual);
            const expectedStr = JSON.stringify(expected);
            if (actualStr !== expectedStr) {
                throw new Error(`${message} Expected ${expectedStr}, got ${actualStr}`);
            }
        }

        // Create test runner
        const runner = new TestRunner();

        // --- clamp() tests ---
        runner.test('clamp: value within range returns unchanged', () => {
            assertEqual(clamp(5, 0, 10), 5);
        });
        runner.test('clamp: value below min returns min', () => {
            assertEqual(clamp(-5, 0, 10), 0);
        });
        runner.test('clamp: value above max returns max', () => {
            assertEqual(clamp(15, 0, 10), 10);
        });
        runner.test('clamp: value at boundaries', () => {
            assertEqual(clamp(0, 0, 10), 0);
            assertEqual(clamp(10, 0, 10), 10);
        });
        runner.test('clamp: negative range', () => {
            assertEqual(clamp(-5, -10, -1), -5);
        });

        // --- lerp() tests ---
        runner.test('lerp: t=0 returns a', () => {
            assertEqual(lerp(0, 10, 0), 0);
        });
        runner.test('lerp: t=1 returns b', () => {
            assertEqual(lerp(0, 10, 1), 10);
        });
        runner.test('lerp: t=0.5 returns midpoint', () => {
            assertEqual(lerp(0, 10, 0.5), 5);
        });
        runner.test('lerp: negative values', () => {
            assertEqual(lerp(-10, 10, 0.5), 0);
        });
        runner.test('lerp: t clamped to [0, 1]', () => {
            assertEqual(lerp(0, 10, -0.5), 0);
            assertEqual(lerp(0, 10, 1.5), 10);
        });

        // --- map() tests ---
        runner.test('map: maps midpoint correctly', () => {
            assertEqual(map(5, 0, 10, 0, 100), 50);
        });
        runner.test('map: maps range boundaries', () => {
            assertEqual(map(0, 0, 10, 0, 100), 0);
            assertEqual(map(10, 0, 10, 0, 100), 100);
        });
        runner.test('map: handles inverted output range', () => {
            assertEqual(map(0, 0, 10, 100, 0), 100);
        });

        // --- random() tests ---
        runner.test('random: returns value in range', () => {
            for (let i = 0; i < 100; i++) {
                const val = random(5, 10);
                assertTrue(val >= 5 && val < 10, `Value ${val} out of range`);
            }
        });
        runner.test('random: single arg uses 0 as min', () => {
            for (let i = 0; i < 100; i++) {
                const val = random(10);
                assertTrue(val >= 0 && val < 10, `Value ${val} out of range`);
            }
        });

        // --- randomInt() tests ---
        runner.test('randomInt: returns integers', () => {
            for (let i = 0; i < 100; i++) {
                const val = randomInt(0, 10);
                assertTrue(Number.isInteger(val), `Expected integer, got ${val}`);
            }
        });
        runner.test('randomInt: inclusive range', () => {
            const seen = new Set();
            for (let i = 0; i < 1000; i++) {
                seen.add(randomInt(1, 3));
            }
            assertTrue(seen.has(1) && seen.has(2) && seen.has(3), 'Should cover full range');
        });

        // --- degToRad() tests ---
        runner.test('degToRad: converts correctly', () => {
            assertEqual(degToRad(0), 0);
            assertAlmostEqual(degToRad(180), Math.PI);
            assertAlmostEqual(degToRad(90), Math.PI / 2);
            assertAlmostEqual(degToRad(360), Math.PI * 2);
        });

        // --- radToDeg() tests ---
        runner.test('radToDeg: converts correctly', () => {
            assertEqual(radToDeg(0), 0);
            assertAlmostEqual(radToDeg(Math.PI), 180);
            assertAlmostEqual(radToDeg(Math.PI / 2), 90);
        });
        runner.test('radToDeg and degToRad are inverses', () => {
            assertAlmostEqual(radToDeg(degToRad(45)), 45);
        });

        // --- hslToRgb() tests ---
        runner.test('hslToRgb: pure red', () => {
            assertDeepEqual(hslToRgb(0, 100, 50), { r: 255, g: 0, b: 0 });
        });
        runner.test('hslToRgb: pure green', () => {
            assertDeepEqual(hslToRgb(120, 100, 50), { r: 0, g: 255, b: 0 });
        });
        runner.test('hslToRgb: pure blue', () => {
            assertDeepEqual(hslToRgb(240, 100, 50), { r: 0, g: 0, b: 255 });
        });
        runner.test('hslToRgb: white and black', () => {
            assertDeepEqual(hslToRgb(0, 0, 100), { r: 255, g: 255, b: 255 });
            assertDeepEqual(hslToRgb(0, 0, 0), { r: 0, g: 0, b: 0 });
        });
        runner.test('hslToRgb: secondary colors', () => {
            assertDeepEqual(hslToRgb(60, 100, 50), { r: 255, g: 255, b: 0 });  // yellow
            assertDeepEqual(hslToRgb(180, 100, 50), { r: 0, g: 255, b: 255 }); // cyan
            assertDeepEqual(hslToRgb(300, 100, 50), { r: 255, g: 0, b: 255 }); // magenta
        });

        // --- rgb() tests ---
        runner.test('rgb: creates rgb string', () => {
            assertEqual(rgb(255, 128, 64), 'rgb(255, 128, 64)');
        });
        runner.test('rgb: creates rgba string with alpha', () => {
            assertEqual(rgb(255, 128, 64, 0.5), 'rgba(255, 128, 64, 0.5)');
        });
        runner.test('rgb: alpha=1 uses rgb format', () => {
            assertEqual(rgb(100, 100, 100, 1), 'rgb(100, 100, 100)');
        });

        // --- Class instantiation tests ---
        runner.test('FPSCounter: can be instantiated', () => {
            assertTrue(typeof FPSCounter === 'function', 'FPSCounter should be a class');
        });

        runner.test('CanvasManager: requires canvas element', () => {
            let threw = false;
            try {
                new CanvasManager('nonexistent-canvas');
            } catch (e) {
                threw = true;
                assertTrue(e.message.includes('not found'), 'Should throw "not found" error');
            }
            assertTrue(threw, 'Should throw when canvas not found');
        });

        runner.test('ErrorManager: can be instantiated', () => {
            const em = new ErrorManager();
            assertTrue(em.errorElement !== null, 'Should create error element');
            em.destroy();
        });

        runner.test('LoadingManager: can be instantiated', () => {
            const lm = new LoadingManager('Test loading');
            assertTrue(lm.loadingElement !== null, 'Should create loading element');
            lm.destroy();
        });

        runner.test('AnimationLoop: can be instantiated', () => {
            const loop = new AnimationLoop(() => {});
            assertTrue(loop.running === false, 'Should start not running');
            loop.start();
            assertTrue(loop.running === true, 'Should be running after start');
            loop.stop();
            assertTrue(loop.running === false, 'Should stop running after stop');
        });

        // Run tests function
        async function runTests() {
            const outputEl = document.getElementById('output');
            const summaryEl = document.getElementById('summary');

            outputEl.textContent = 'Running tests...';

            await runner.run();
            runner.render(outputEl, summaryEl);
        }

        // Auto-run on load
        window.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
