<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lattice Boltzmann Method (D2Q9)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            min-height: 100vh;
            color: #e0e0ff;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff6699;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 102, 153, 0.3);
            width: 280px;
            z-index: 100;
            max-height: 90vh;
            overflow-y: auto;
        }

        .controls h2 {
            color: #ff6699;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #888;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 102, 153, 0.3);
            border-radius: 5px;
            color: #e0e0ff;
        }

        .range-value {
            text-align: right;
            font-size: 0.8rem;
            color: #ff6699;
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #ff6699, #ff3366);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 8px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button.secondary {
            background: rgba(255, 102, 153, 0.2);
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            color: #ff6699;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #666;
        }

        .info-panel {
            margin-top: 15px;
            padding: 10px;
            background: rgba(150, 50, 100, 0.2);
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .toggle-controls {
            position: fixed;
            top: 20px;
            right: 320px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(255, 102, 153, 0.3);
            border-radius: 8px;
            padding: 8px 15px;
            color: #ff6699;
            cursor: pointer;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">
        <span>‚Üê</span> Back to Gallery
    </a>

    <button class="toggle-controls" onclick="toggleControls()">Toggle Panel</button>

    <canvas id="canvas"></canvas>

    <div class="controls" id="controls">
        <h2>Lattice Boltzmann (D2Q9)</h2>

        <div class="control-group">
            <label>Resolution: <span id="resValue">1.0</span>x</label>
            <input type="range" id="resolution" min="0.25" max="1" step="0.25" value="0.5">
        </div>

        <div class="control-group">
            <label>Viscosity (tau): <span id="tauValue">0.6</span></label>
            <input type="range" id="tau" min="0.51" max="2" step="0.01" value="0.6">
        </div>

        <div class="control-group">
            <label>Flow Speed: <span id="flowValue">0.1</span></label>
            <input type="range" id="flowSpeed" min="0.01" max="0.2" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Visualization</label>
            <select id="vizMode">
                <option value="velocity">Velocity Magnitude</option>
                <option value="vorticity">Vorticity (Curl)</option>
                <option value="density">Density</option>
                <option value="vectors">Velocity Vectors</option>
            </select>
        </div>

        <div class="control-group">
            <label>Obstacle Shape</label>
            <select id="obstacleShape">
                <option value="circle">Circle</option>
                <option value="rectangle">Rectangle</option>
                <option value="airfoil">Airfoil</option>
                <option value="none">None</option>
            </select>
        </div>

        <button onclick="reset()">Reset Simulation</button>
        <button class="secondary" onclick="togglePause()">Pause/Resume</button>
        <button class="secondary" onclick="clearObstacles()">Clear Obstacles</button>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="fps">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="reynolds">0</div>
                <div class="stat-label">Reynolds #</div>
            </div>
        </div>

        <div class="info-panel">
            <strong>LBM</strong> simulates fluid by tracking distribution functions on a lattice. D2Q9 means 2D with 9 velocity directions. The BGK collision model relaxes distributions toward equilibrium.
            <br><br>
            <em>Draw obstacles with mouse!</em>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let resolution = 0.5;
        let nx, ny;

        // D2Q9 velocity directions: 0=rest, 1-4=cardinal, 5-8=diagonal
        const ex = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const ey = [0, 0, 1, 0, -1, 1, 1, -1, -1];

        // D2Q9 weights
        const weights = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];

        // Opposite directions for bounce-back
        const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6];

        // Simulation arrays
        let f = [];     // Distribution functions
        let fNew = [];  // New distribution functions
        let obstacle = [];
        let rho = [];   // Density
        let ux = [];    // Velocity x
        let uy = [];    // Velocity y

        let tau = 0.6;  // Relaxation time (viscosity)
        let u0 = 0.1;   // Initial/inlet velocity

        let paused = false;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let mouseDown = false;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function initLattice() {
            resolution = parseFloat(document.getElementById('resolution').value);
            nx = Math.floor(width * resolution);
            ny = Math.floor(height * resolution);

            f = new Array(9).fill(null).map(() => new Float32Array(nx * ny));
            fNew = new Array(9).fill(null).map(() => new Float32Array(nx * ny));
            obstacle = new Uint8Array(nx * ny);
            rho = new Float32Array(nx * ny);
            ux = new Float32Array(nx * ny);
            uy = new Float32Array(nx * ny);

            // Initialize with equilibrium at uniform velocity
            for (let y = 0; y < ny; y++) {
                for (let x = 0; x < nx; x++) {
                    const idx = y * nx + x;
                    rho[idx] = 1.0;
                    ux[idx] = u0;
                    uy[idx] = 0;

                    for (let i = 0; i < 9; i++) {
                        f[i][idx] = equilibrium(i, rho[idx], ux[idx], uy[idx]);
                    }
                }
            }

            // Add initial obstacle
            addObstacle();
        }

        function equilibrium(i, rho, ux, uy) {
            const eu = ex[i] * ux + ey[i] * uy;
            const usq = ux * ux + uy * uy;
            return weights[i] * rho * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * usq);
        }

        function addObstacle() {
            const shape = document.getElementById('obstacleShape').value;
            const cx = Math.floor(nx * 0.25);
            const cy = Math.floor(ny * 0.5);

            if (shape === 'circle') {
                const r = Math.floor(ny * 0.08);
                for (let y = 0; y < ny; y++) {
                    for (let x = 0; x < nx; x++) {
                        const dx = x - cx;
                        const dy = y - cy;
                        if (dx * dx + dy * dy < r * r) {
                            obstacle[y * nx + x] = 1;
                        }
                    }
                }
            } else if (shape === 'rectangle') {
                const hw = Math.floor(ny * 0.04);
                const hh = Math.floor(ny * 0.15);
                for (let y = cy - hh; y < cy + hh; y++) {
                    for (let x = cx - hw; x < cx + hw; x++) {
                        if (x >= 0 && x < nx && y >= 0 && y < ny) {
                            obstacle[y * nx + x] = 1;
                        }
                    }
                }
            } else if (shape === 'airfoil') {
                const length = Math.floor(ny * 0.2);
                const thickness = Math.floor(ny * 0.03);
                for (let y = 0; y < ny; y++) {
                    for (let x = 0; x < nx; x++) {
                        const dx = x - cx;
                        const dy = y - cy;
                        // Simple NACA-like shape
                        if (dx >= 0 && dx < length) {
                            const t = dx / length;
                            const profile = thickness * (1 - t * t) * 4;
                            if (Math.abs(dy) < profile) {
                                obstacle[y * nx + x] = 1;
                            }
                        }
                    }
                }
            }
        }

        function clearObstacles() {
            obstacle.fill(0);
            addObstacle();
        }

        function collide() {
            const omega = 1 / tau;

            for (let idx = 0; idx < nx * ny; idx++) {
                if (obstacle[idx]) continue;

                // Compute macroscopic quantities
                let density = 0;
                let velX = 0;
                let velY = 0;

                for (let i = 0; i < 9; i++) {
                    density += f[i][idx];
                    velX += ex[i] * f[i][idx];
                    velY += ey[i] * f[i][idx];
                }

                velX /= density;
                velY /= density;

                rho[idx] = density;
                ux[idx] = velX;
                uy[idx] = velY;

                // BGK collision
                for (let i = 0; i < 9; i++) {
                    const feq = equilibrium(i, density, velX, velY);
                    fNew[i][idx] = f[i][idx] + omega * (feq - f[i][idx]);
                }
            }
        }

        function stream() {
            for (let y = 0; y < ny; y++) {
                for (let x = 0; x < nx; x++) {
                    const idx = y * nx + x;

                    for (let i = 0; i < 9; i++) {
                        const nx2 = x - ex[i];
                        const ny2 = y - ey[i];

                        if (nx2 >= 0 && nx2 < nx && ny2 >= 0 && ny2 < ny) {
                            const srcIdx = ny2 * nx + nx2;

                            if (obstacle[idx]) {
                                // Bounce-back for obstacle
                                f[opposite[i]][srcIdx] = fNew[i][srcIdx];
                            } else {
                                f[i][idx] = fNew[i][srcIdx];
                            }
                        }
                    }
                }
            }

            // Left boundary: inlet (constant velocity)
            for (let y = 1; y < ny - 1; y++) {
                const idx = y * nx;
                rho[idx] = 1.0;
                ux[idx] = u0;
                uy[idx] = 0;
                for (let i = 0; i < 9; i++) {
                    f[i][idx] = equilibrium(i, 1.0, u0, 0);
                }
            }

            // Right boundary: outlet (zero gradient)
            for (let y = 1; y < ny - 1; y++) {
                const idx = y * nx + nx - 1;
                const srcIdx = y * nx + nx - 2;
                for (let i = 0; i < 9; i++) {
                    f[i][idx] = f[i][srcIdx];
                }
            }

            // Top/bottom: no-slip walls
            for (let x = 0; x < nx; x++) {
                obstacle[x] = 1;
                obstacle[(ny - 1) * nx + x] = 1;
            }
        }

        function update() {
            collide();
            stream();
        }

        function draw() {
            const vizMode = document.getElementById('vizMode').value;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const cellW = width / nx;
            const cellH = height / ny;

            // Precompute max values for normalization
            let maxVel = 0.001;
            let maxVort = 0.001;

            for (let idx = 0; idx < nx * ny; idx++) {
                if (!obstacle[idx]) {
                    const vel = Math.sqrt(ux[idx] * ux[idx] + uy[idx] * uy[idx]);
                    maxVel = Math.max(maxVel, vel);
                }
            }

            // Calculate vorticity if needed
            let vorticity = null;
            if (vizMode === 'vorticity') {
                vorticity = new Float32Array(nx * ny);
                for (let y = 1; y < ny - 1; y++) {
                    for (let x = 1; x < nx - 1; x++) {
                        const idx = y * nx + x;
                        // duy/dx - dux/dy
                        const duyDx = (uy[idx + 1] - uy[idx - 1]) * 0.5;
                        const duxDy = (ux[idx + nx] - ux[idx - nx]) * 0.5;
                        vorticity[idx] = duyDx - duxDy;
                        maxVort = Math.max(maxVort, Math.abs(vorticity[idx]));
                    }
                }
            }

            // Draw
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const lx = Math.floor(px * resolution);
                    const ly = Math.floor(py * resolution);
                    const idx = ly * nx + lx;

                    let r, g, b;

                    if (obstacle[idx]) {
                        r = g = b = 40;
                    } else {
                        if (vizMode === 'velocity') {
                            const vel = Math.sqrt(ux[idx] * ux[idx] + uy[idx] * uy[idx]);
                            const t = vel / maxVel;
                            // Plasma-like colormap
                            r = Math.floor(Math.min(255, t * 400));
                            g = Math.floor(Math.min(255, t * 200));
                            b = Math.floor(Math.min(255, 100 + t * 155));
                        } else if (vizMode === 'vorticity') {
                            const v = vorticity[idx] / maxVort;
                            if (v > 0) {
                                r = Math.floor(v * 255);
                                g = 50;
                                b = 100;
                            } else {
                                r = 50;
                                g = 100;
                                b = Math.floor(-v * 255);
                            }
                        } else if (vizMode === 'density') {
                            const d = (rho[idx] - 0.8) / 0.4;
                            r = Math.floor(d * 200);
                            g = Math.floor(d * 150);
                            b = Math.floor(d * 255);
                        } else {
                            r = g = b = 20;
                        }
                    }

                    const i = (py * width + px) * 4;
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                    data[i + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw velocity vectors if selected
            if (vizMode === 'vectors') {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;

                const step = Math.max(1, Math.floor(10 / resolution));
                const scale = 50 / maxVel;

                for (let ly = 0; ly < ny; ly += step) {
                    for (let lx = 0; lx < nx; lx += step) {
                        const idx = ly * nx + lx;
                        if (obstacle[idx]) continue;

                        const px = lx / resolution;
                        const py = ly / resolution;

                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + ux[idx] * scale, py + uy[idx] * scale);
                        ctx.stroke();
                    }
                }
            }
        }

        function animate() {
            if (!paused) {
                // Multiple substeps
                for (let i = 0; i < 5; i++) {
                    update();
                }
            }

            draw();

            // Update FPS and Reynolds number
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;

                // Reynolds number: Re = u * L / nu, where nu = (tau - 0.5) / 3
                const L = Math.floor(ny * 0.16); // Obstacle size
                const nu = (tau - 0.5) / 3;
                const Re = Math.round(u0 * L / nu);
                document.getElementById('reynolds').textContent = Re;

                frameCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(animate);
        }

        function reset() {
            tau = parseFloat(document.getElementById('tau').value);
            u0 = parseFloat(document.getElementById('flowSpeed').value);
            initLattice();
        }

        function togglePause() {
            paused = !paused;
        }

        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }

        // Mouse drawing
        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            drawObstacle(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) drawObstacle(e);
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });

        function drawObstacle(e) {
            const lx = Math.floor(e.clientX * resolution);
            const ly = Math.floor(e.clientY * resolution);
            const radius = Math.floor(5 * resolution);

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const x = lx + dx;
                        const y = ly + dy;
                        if (x > 0 && x < nx - 1 && y > 0 && y < ny - 1) {
                            obstacle[y * nx + x] = 1;
                        }
                    }
                }
            }
        }

        // Event listeners
        document.getElementById('resolution').addEventListener('input', (e) => {
            document.getElementById('resValue').textContent = e.target.value;
        });
        document.getElementById('resolution').addEventListener('change', reset);

        document.getElementById('tau').addEventListener('input', (e) => {
            document.getElementById('tauValue').textContent = e.target.value;
            tau = parseFloat(e.target.value);
        });

        document.getElementById('flowSpeed').addEventListener('input', (e) => {
            document.getElementById('flowValue').textContent = e.target.value;
            u0 = parseFloat(e.target.value);
        });

        document.getElementById('obstacleShape').addEventListener('change', () => {
            obstacle.fill(0);
            addObstacle();
        });

        window.addEventListener('resize', () => {
            resize();
            reset();
        });

        // Initialize
        resize();
        initLattice();
        animate();
    </script>
</body>
</html>
