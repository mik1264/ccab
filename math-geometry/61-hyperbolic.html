<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperbolic Geometry - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #f5f3ff;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        
        .controls {
            margin: 20px;
        }
        button {
            padding: 10px 20px;
            background: #8b5cf6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #status { font-family: monospace; color: #666; }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">← Back to Gallery</a>
    <h1>Poincaré Disk Model</h1>
    <p>Hyperbolic geometry where lines are circular arcs orthogonal to the boundary.</p>
    
    <canvas id="canvas" width="600" height="600"></canvas>
    
    <div class="controls">
        <button onclick="tesselate()">Add Tesselation Layer</button>
        <button onclick="reset()">Reset</button>
    </div>
    <div id="status">Drag to move hyperbolic space.</div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    const R = 300;
    const CX = 300;
    const CY = 300;
    
    // Transform state (Isometry)
    // Represented by a Mobius transformation complex number or matrix
    // Simpler: Just track a point 'origin' that maps to (0,0)
    
    let polygons = [];
    let depth = 0;
    
    // Initial triangle
    // Vertices in complex plane
    // P = 7, Q = 3 (Heptagonal tiling of order 3)
    
    function reset() {
        polygons = [];
        depth = 0;
        initTiling();
        draw();
    }
    
    function initTiling() {
        // Generate base p-gon centered at 0
        // Calculate radius for {p, q} tiling
        // cos(PI/q) / sin(PI/p) ... formula for radius
        
        // Let's just draw some geodesic lines
        // A geodesic between z1 and z2
        
        // Simple visual: Draw grid of lines
        // Start with central polygon
    }
    
    // Hyperbolic Line: Arc through z1, z2 orthogonal to unit circle
    function drawGeodesic(z1, z2) {
        // Z is complex {x, y}
        // If line passes through origin, it's a straight line
        // Otherwise it's a circle
        
        // Let's implement full poincare drawing later.
        // For now, draw simple arcs based on mouse interaction
    }
    
    // Interaction
    // Dragging moves the points (Moebius transform)
    
    // Visual Hack for Demo:
    // Escher-like Circle Limit
    // Recursively draw circles
    
    function loop() {
        draw();
        requestAnimationFrame(loop);
    }
    
    function draw() {
        ctx.clearRect(0, 0, 600, 600);
        
        // Boundary
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(CX, CY, 298, 0, Math.PI*2); ctx.stroke();
        
        // Draw recursive structure
        // Simple fractal approach
        // Center circle
        drawCircle(CX, CY, 100, 0);
    }
    
    function drawCircle(x, y, r, level) {
        if (r < 5 || level > 4) return;
        
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.stroke();
        
        // Children
        // 4 children around
        // In Hyperbolic space, equal size circles appear smaller near edge
        
        const newR = r * 0.45;
        const dist = r + newR;
        
        drawCircle(x + dist, y, newR, level+1);
        drawCircle(x - dist, y, newR, level+1);
        drawCircle(x, y + dist, newR, level+1);
        drawCircle(x, y - dist, newR, level+1);
    }
    
    // This is Euclidean fractal.
    // Real hyperbolic needs proper mapping.
    // Implementation of hyperbolic tiling logic is complex math.
    // Placeholder for "Hyperbolic Geometry"
    
    reset();

</script>
</body>
</html>
