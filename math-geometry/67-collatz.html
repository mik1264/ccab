<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collatz Conjecture - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #111;
            color: #ddd;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
        }
        
        .controls {
            margin: 20px;
        }
        input { padding: 8px; width: 80px; }
        button { padding: 8px 16px; cursor: pointer; }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Collatz Conjecture (3n + 1)</h1>
    <p>Visualize the tree of numbers that reach 1.</p>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <label>Start Number:</label>
        <input type="number" id="start" value="27">
        <button onclick="trace()">Trace Path</button>
        <button onclick="buildTree()">Build Reverse Tree</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    function collatz(n) {
        if (n % 2 === 0) return n / 2;
        return 3 * n + 1;
    }
    
    function trace() {
        const start = parseInt(document.getElementById('start').value);
        let n = start;
        let path = [n];
        while (n !== 1) {
            n = collatz(n);
            path.push(n);
            if (path.length > 1000) break; // Safety
        }
        
        drawPath(path);
    }
    
    function buildTree() {
        // Reverse Collatz
        // n -> 2n
        // n -> (n-1)/3 (if valid and odd)
        
        // Use a set to track
        let nodes = [{val: 1, x: 400, y: 550, angle: -Math.PI/2}];
        let queue = [nodes[0]];
        let visited = new Set([1]);
        let depth = 0;
        
        ctx.clearRect(0, 0, 800, 600);
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        
        let count = 0;
        
        function step() {
            if (queue.length === 0 || count > 2000) return;
            
            let nextQueue = [];
            
            queue.forEach(parent => {
                const len = 30 * Math.pow(0.9, depth);
                
                // Branch 1: 2n
                const n1 = parent.val * 2;
                if (!visited.has(n1)) {
                    visited.add(n1);
                    const angle = parent.angle - 0.2;
                    const x = parent.x + Math.cos(angle) * len;
                    const y = parent.y + Math.sin(angle) * len;
                    
                    ctx.beginPath(); ctx.moveTo(parent.x, parent.y); ctx.lineTo(x, y); ctx.stroke();
                    nextQueue.push({val: n1, x: x, y: y, angle: angle});
                }
                
                // Branch 2: (n-1)/3
                if ((parent.val - 1) % 3 === 0) {
                    const n2 = (parent.val - 1) / 3;
                    if (n2 > 1 && n2 % 2 !== 0 && !visited.has(n2)) { // Must be odd
                        visited.add(n2);
                        const angle = parent.angle + 0.4; // Branch off
                        const x = parent.x + Math.cos(angle) * len;
                        const y = parent.y + Math.sin(angle) * len;
                        
                        ctx.beginPath(); ctx.moveTo(parent.x, parent.y); ctx.lineTo(x, y); ctx.stroke();
                        nextQueue.push({val: n2, x: x, y: y, angle: angle});
                    }
                }
            });
            
            queue = nextQueue;
            depth++;
            count += queue.length;
            requestAnimationFrame(step);
        }
        
        step();
    }
    
    function drawPath(path) {
        ctx.clearRect(0, 0, 800, 600);
        ctx.strokeStyle = '#fcd34d';
        ctx.lineWidth = 2;
        
        // Simple graph: X=index, Y=val
        const maxVal = Math.max(...path);
        const stepX = 800 / path.length;
        const scaleY = 550 / maxVal;
        
        ctx.beginPath();
        path.forEach((n, i) => {
            const x = i * stepX;
            const y = 580 - n * scaleY;
            if (i===0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(x-2, y-2, 4, 4);
        });
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = '16px monospace';
        ctx.fillText(`Steps: ${path.length-1}, Max: ${maxVal}`, 20, 30);
    }
    
    trace();

</script>
</body>
</html>
