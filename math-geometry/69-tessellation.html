<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tessellation Editor - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #fff;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; display: flex; gap: 40px; }
        
        .editor {
            border: 2px solid #ccc;
            background: #fafafa;
            position: relative;
        }
        
        canvas { display: block; }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            text-align: left;
        }
        
        button {
            padding: 10px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<a href="../index.html" class="gallery-back">← Back to Gallery</a>
<h1>Tessellation Editor</h1>
<p>Draw in the primary cell to see it tile across the plane.</p>

<div class="container">
    <div class="editor">
        <canvas id="canvas" width="600" height="600"></canvas>
    </div>
    
    <div class="controls">
        <label>Symmetry Group:</label>
        <select id="group">
            <option value="p1">p1 (Translation only)</option>
            <option value="p2">p2 (180° rotation)</option>
            <option value="pm">pm (Mirror)</option>
            <option value="p4">p4 (90° rotation)</option>
            <option value="p6">p6 (60° rotation - Hex)</option>
        </select>
        
        <button onclick="clearCanvas()">Clear</button>
        <p style="color:#666; font-size:0.9rem;">
            Draw on the canvas. The pattern will repeat automatically based on the symmetry group.
        </p>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let strokes = []; // { points: [{x,y}], color }
    let isDrawing = false;
    
    // Config
    let group = 'p1';
    const CELL_SIZE = 100;
    
    canvas.addEventListener('mousedown', e => {
        isDrawing = true;
        const p = getPos(e);
        strokes.push({ points: [p], color: getRandomColor() });
        draw();
    });
    
    canvas.addEventListener('mousemove', e => {
        if (isDrawing) {
            const p = getPos(e);
            strokes[strokes.length-1].points.push(p);
            draw();
        }
    });
    
    window.addEventListener('mouseup', () => isDrawing = false);
    document.getElementById('group').addEventListener('change', e => {
        group = e.target.value;
        draw();
    });
    
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    
    function getRandomColor() {
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 70%, 50%)`;
    }
    
    function clearCanvas() {
        strokes = [];
        draw();
    }
    
    function draw() {
        ctx.clearRect(0, 0, 600, 600);
        
        // Pattern logic
        // We draw the strokes multiple times with transforms
        
        // Clip to cell? No, let them draw anywhere and repeat it?
        // Or constrain drawing to fundamental domain?
        // Let's just repeat whatever is drawn.
        
        // p1: Translate x, y
        if (group === 'p1') {
            for(let i=-2; i<=6; i++) {
                for(let j=-2; j<=6; j++) {
                    ctx.save();
                    ctx.translate(i * CELL_SIZE, j * CELL_SIZE);
                    // Clip box?
                    ctx.strokeStyle = '#eee'; ctx.strokeRect(0, 0, CELL_SIZE, CELL_SIZE);
                    drawStrokes();
                    ctx.restore();
                }
            }
        }
        else if (group === 'p4') {
            // Square grid. 4-fold rotation at corners.
            // Fundamental domain is square.
            // Operations: Rot 90 around 0,0. Translate by vector.
            for(let i=-2; i<=6; i++) {
                for(let j=-2; j<=6; j++) {
                    ctx.save();
                    ctx.translate(i * CELL_SIZE, j * CELL_SIZE);
                    
                    // Draw 4 rotations
                    for(let r=0; r<4; r++) {
                        ctx.save();
                        // Rotate around center of cell
                        ctx.translate(CELL_SIZE/2, CELL_SIZE/2);
                        ctx.rotate(r * Math.PI/2);
                        ctx.translate(-CELL_SIZE/2, -CELL_SIZE/2);
                        drawStrokes();
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
        else if (group === 'pm') {
            // Mirror
            for(let i=-2; i<=6; i++) {
                for(let j=-2; j<=6; j++) {
                    ctx.save();
                    ctx.translate(i * CELL_SIZE, j * CELL_SIZE);
                    
                    // Normal
                    drawStrokes();
                    
                    // Mirror (Flip X)
                    ctx.save();
                    ctx.translate(CELL_SIZE, 0);
                    ctx.scale(-1, 1);
                    drawStrokes();
                    ctx.restore();
                    
                    ctx.restore();
                }
            }
        }
        else if (group === 'p6') {
            // Hexagonal
            const w = CELL_SIZE;
            const h = CELL_SIZE * Math.sqrt(3) / 2;
            
            // Grid is offset
            for(let j=-2; j<=8; j++) {
                for(let i=-2; i<=6; i++) {
                    const x = i * w + (j%2) * w/2;
                    const y = j * h;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    
                    // Draw 3 rotations (p3)? Or p6?
                    // p6 has 6 rotations.
                    // Triangle domain.
                    
                    // Simple p6: rotate 60 deg around vertex
                    for(let r=0; r<6; r++) {
                        ctx.save();
                        ctx.rotate(r * Math.PI/3);
                        drawStrokes();
                        ctx.restore();
                    }
                    
                    ctx.restore();
                }
            }
        }
        else {
            // Default p1
            drawStrokes();
        }
    }
    
    function drawStrokes() {
        strokes.forEach(s => {
            if(s.points.length < 2) return;
            ctx.strokeStyle = s.color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(s.points[0].x % CELL_SIZE, s.points[0].y % CELL_SIZE); // Map to cell coords?
            // Actually, if we map to cell coords, drawing across boundary jumps.
            // Let's assume user draws in top-left cell 0,0.
            // So we just draw s.points raw.
            
            // But if we translate, drawing raw points will be offset.
            // We need to draw the points RELATIVE to origin of drawing (0,0).
            // But points are absolute screen coords.
            // When drawing, we capture raw coords.
            // If user draws in middle of screen, that's tile (3, 3).
            // We want to replicate THAT stroke to tile (0,0) and (1,0)...
            
            // Simplification: We take stroke modulo CELL_SIZE
            // s.points.x % CELL_SIZE.
            
            s.points.forEach((p, i) => {
                // Modulo logic handling negatives
                const mx = ((p.x % CELL_SIZE) + CELL_SIZE) % CELL_SIZE;
                const my = ((p.y % CELL_SIZE) + CELL_SIZE) % CELL_SIZE;
                
                // Jump check?
                if (i===0) ctx.moveTo(mx, my);
                else {
                    const prev = s.points[i-1];
                    const prevMx = ((prev.x % CELL_SIZE) + CELL_SIZE) % CELL_SIZE;
                    const prevMy = ((prev.y % CELL_SIZE) + CELL_SIZE) % CELL_SIZE;
                    
                    if (Math.abs(mx - prevMx) > 50 || Math.abs(my - prevMy) > 50) {
                        ctx.moveTo(mx, my); // Gap
                    } else {
                        ctx.lineTo(mx, my);
                    }
                }
            });
            ctx.stroke();
        });
    }

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
