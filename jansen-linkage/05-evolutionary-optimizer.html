<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - Evolutionary Optimizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            color: #0f0;
            padding: 20px;
        }
        h1 { text-align: center; margin-bottom: 20px; font-size: 1.4rem; }
        .container { display: flex; gap: 20px; max-width: 1400px; margin: 0 auto; }
        .population {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            flex: 1;
        }
        .individual {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .individual:hover { border-color: #0f0; }
        .individual.elite { border-color: #ff0; }
        .individual canvas { display: block; margin: 0 auto; }
        .fitness {
            text-align: center;
            font-size: 0.75rem;
            margin-top: 5px;
            color: #888;
        }
        .fitness span { color: #0f0; }
        .controls {
            width: 280px;
            background: #111;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .controls h3 { color: #0f0; margin-bottom: 15px; font-size: 1rem; }
        .stat { margin: 10px 0; font-size: 0.85rem; }
        .stat-value { color: #0f0; font-weight: bold; }
        button {
            width: 100%;
            background: #0a0;
            color: #000;
            border: none;
            padding: 12px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background: #0f0; }
        button:disabled { background: #333; color: #666; }
        .target-info {
            background: #0a0a0a;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.8rem;
        }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #0f0; text-decoration: none;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <h1>Evolutionary Linkage Optimizer</h1>
    <p style="text-align: center; color: #666; margin-bottom: 20px; font-size: 0.9rem;">
        Genetic algorithm evolving towards optimal walking trajectories
    </p>

    <div class="container">
        <div class="population" id="population"></div>
        <div class="controls">
            <h3>Evolution Controls</h3>
            <div class="stat">Generation: <span class="stat-value" id="gen">0</span></div>
            <div class="stat">Best Fitness: <span class="stat-value" id="bestFit">0</span></div>
            <div class="stat">Avg Fitness: <span class="stat-value" id="avgFit">0</span></div>
            <div class="stat">Mutations: <span class="stat-value" id="mutations">0</span></div>

            <button id="evolve">Evolve Generation</button>
            <button id="autoEvolve">Auto-Evolve</button>
            <button id="reset">Reset Population</button>

            <div class="target-info">
                <strong>Fitness Criteria:</strong><br>
                • Flat ground contact phase<br>
                • Smooth trajectory curve<br>
                • Vertical lift height<br>
                • Path continuity
            </div>

            <div class="target-info" style="margin-top: 10px;">
                <strong>Theo Jansen's Original:</strong><br>
                <span style="color: #ff0;">a=38, b=41.5, c=39.3...</span>
            </div>
        </div>
    </div>

    <script>
        const POPULATION_SIZE = 16;
        const ELITE_COUNT = 2;
        const MUTATION_RATE = 0.15;
        const MUTATION_STRENGTH = 5;

        const PARAM_RANGES = {
            a: [25, 55], b: [30, 60], c: [28, 55], d: [30, 55], e: [40, 75],
            f: [28, 55], g: [25, 50], h: [50, 90], i: [35, 65], j: [35, 65],
            k: [45, 80], l: [3, 15], m: [8, 25]
        };

        let population = [];
        let generation = 0;
        let totalMutations = 0;
        let autoEvolving = false;

        function circleIntersection(x1, y1, r1, x2, y2, r2, selectUpper = true) {
            const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));
            const px = x1 + a * (x2 - x1) / d;
            const py = y1 + a * (y2 - y1) / d;
            const ix1 = px + h * (y2 - y1) / d;
            const iy1 = py - h * (x2 - x1) / d;
            const ix2 = px - h * (y2 - y1) / d;
            const iy2 = py + h * (x2 - x1) / d;
            return selectUpper ? (iy1 < iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 })
                               : (iy1 > iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 });
        }

        function calculateJoints(params, theta) {
            const p = params;
            const O = { x: 0, y: 0 };
            const M = { x: -p.l, y: -p.m };
            const A = { x: p.a * Math.cos(theta), y: p.a * Math.sin(theta) };
            const B = circleIntersection(A.x, A.y, p.b, M.x, M.y, p.j, true);
            if (!B) return null;
            const C = circleIntersection(A.x, A.y, p.d, B.x, B.y, p.c, false);
            if (!C) return null;
            const D = circleIntersection(B.x, B.y, p.e, C.x, C.y, p.f, false);
            if (!D) return null;
            const E = circleIntersection(M.x, M.y, p.i, D.x, D.y, p.g, true);
            if (!E) return null;
            const F = circleIntersection(E.x, E.y, p.h, D.x, D.y, p.k, false);
            if (!F) return null;
            return { O, M, A, B, C, D, E, F };
        }

        function calculateFitness(params) {
            const path = [];
            let validPoints = 0;

            for (let t = 0; t < Math.PI * 2; t += 0.05) {
                const joints = calculateJoints(params, t);
                if (joints && joints.F) {
                    path.push({ x: joints.F.x, y: joints.F.y });
                    validPoints++;
                }
            }

            if (validPoints < 100) return 0; // Invalid mechanism

            // Calculate fitness metrics
            const ys = path.map(p => p.y);
            const xs = path.map(p => p.x);
            const maxY = Math.max(...ys);
            const minY = Math.min(...ys);
            const height = maxY - minY;
            const width = Math.max(...xs) - Math.min(...xs);

            // Ground contact flatness (points near max Y)
            const groundThreshold = maxY - height * 0.1;
            const groundPoints = path.filter(p => p.y > groundThreshold);
            const groundYVariance = groundPoints.length > 0 ?
                groundPoints.reduce((sum, p) => sum + Math.pow(p.y - maxY, 2), 0) / groundPoints.length : 1000;
            const flatnessScore = Math.max(0, 100 - groundYVariance * 10);

            // Lift height score
            const liftScore = Math.min(100, height * 2);

            // Path smoothness (penalize sharp corners)
            let smoothnessScore = 100;
            for (let i = 1; i < path.length - 1; i++) {
                const dx1 = path[i].x - path[i-1].x;
                const dy1 = path[i].y - path[i-1].y;
                const dx2 = path[i+1].x - path[i].x;
                const dy2 = path[i+1].y - path[i].y;
                const dot = dx1*dx2 + dy1*dy2;
                const mag1 = Math.sqrt(dx1*dx1 + dy1*dy1);
                const mag2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                if (mag1 > 0 && mag2 > 0) {
                    const angle = Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
                    smoothnessScore -= angle * 2;
                }
            }
            smoothnessScore = Math.max(0, smoothnessScore);

            // Width score (want reasonable stride)
            const widthScore = Math.min(100, width * 1.5);

            // Ground contact percentage
            const contactPercent = (groundPoints.length / path.length) * 100;
            const contactScore = Math.min(100, contactPercent * 3);

            return (flatnessScore * 0.35 + liftScore * 0.2 + smoothnessScore * 0.2 +
                    widthScore * 0.15 + contactScore * 0.1);
        }

        function createRandomIndividual() {
            const params = {};
            for (const [key, [min, max]] of Object.entries(PARAM_RANGES)) {
                params[key] = min + Math.random() * (max - min);
            }
            return { params, fitness: 0 };
        }

        function mutate(params) {
            const newParams = { ...params };
            for (const [key, [min, max]] of Object.entries(PARAM_RANGES)) {
                if (Math.random() < MUTATION_RATE) {
                    newParams[key] += (Math.random() - 0.5) * MUTATION_STRENGTH * 2;
                    newParams[key] = Math.max(min, Math.min(max, newParams[key]));
                    totalMutations++;
                }
            }
            return newParams;
        }

        function crossover(parent1, parent2) {
            const child = {};
            for (const key of Object.keys(PARAM_RANGES)) {
                child[key] = Math.random() < 0.5 ? parent1[key] : parent2[key];
            }
            return child;
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < POPULATION_SIZE; i++) {
                const individual = createRandomIndividual();
                individual.fitness = calculateFitness(individual.params);
                population.push(individual);
            }
            population.sort((a, b) => b.fitness - a.fitness);
            generation = 0;
            totalMutations = 0;
        }

        function evolve() {
            const newPop = [];

            // Keep elite
            for (let i = 0; i < ELITE_COUNT; i++) {
                newPop.push({ params: { ...population[i].params }, fitness: population[i].fitness });
            }

            // Create offspring
            while (newPop.length < POPULATION_SIZE) {
                // Tournament selection
                const tournamentSize = 3;
                const selectParent = () => {
                    let best = population[Math.floor(Math.random() * population.length)];
                    for (let i = 1; i < tournamentSize; i++) {
                        const candidate = population[Math.floor(Math.random() * population.length)];
                        if (candidate.fitness > best.fitness) best = candidate;
                    }
                    return best;
                };

                const parent1 = selectParent();
                const parent2 = selectParent();
                const childParams = mutate(crossover(parent1.params, parent2.params));
                const fitness = calculateFitness(childParams);
                newPop.push({ params: childParams, fitness });
            }

            population = newPop;
            population.sort((a, b) => b.fitness - a.fitness);
            generation++;
            updateUI();
        }

        function drawIndividual(canvas, params, isElite) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scale = 1.2;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2 - 10;

            // Draw foot path
            ctx.strokeStyle = isElite ? '#ff0' : '#0a0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            let first = true;
            for (let t = 0; t < Math.PI * 2; t += 0.05) {
                const joints = calculateJoints(params, t);
                if (joints && joints.F) {
                    const x = cx + joints.F.x * scale;
                    const y = cy + joints.F.y * scale;
                    if (first) { ctx.moveTo(x, y); first = false; }
                    else ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();

            // Draw current linkage position
            const joints = calculateJoints(params, Date.now() * 0.002);
            if (joints) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                const links = [
                    [joints.O, joints.A], [joints.A, joints.B], [joints.M, joints.B],
                    [joints.A, joints.C], [joints.B, joints.C], [joints.B, joints.D],
                    [joints.C, joints.D], [joints.M, joints.E], [joints.D, joints.E],
                    [joints.E, joints.F], [joints.D, joints.F]
                ];
                links.forEach(([p1, p2]) => {
                    ctx.beginPath();
                    ctx.moveTo(cx + p1.x * scale, cy + p1.y * scale);
                    ctx.lineTo(cx + p2.x * scale, cy + p2.y * scale);
                    ctx.stroke();
                });

                ctx.fillStyle = isElite ? '#ff0' : '#0f0';
                ctx.beginPath();
                ctx.arc(cx + joints.F.x * scale, cy + joints.F.y * scale, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateUI() {
            document.getElementById('gen').textContent = generation;
            document.getElementById('bestFit').textContent = population[0].fitness.toFixed(2);
            const avgFit = population.reduce((s, i) => s + i.fitness, 0) / population.length;
            document.getElementById('avgFit').textContent = avgFit.toFixed(2);
            document.getElementById('mutations').textContent = totalMutations;
        }

        function renderPopulation() {
            const container = document.getElementById('population');
            container.innerHTML = '';

            population.forEach((ind, idx) => {
                const div = document.createElement('div');
                div.className = 'individual' + (idx < ELITE_COUNT ? ' elite' : '');

                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 120;
                drawIndividual(canvas, ind.params, idx < ELITE_COUNT);

                const fitness = document.createElement('div');
                fitness.className = 'fitness';
                fitness.innerHTML = `Fitness: <span>${ind.fitness.toFixed(1)}</span>`;

                div.appendChild(canvas);
                div.appendChild(fitness);
                container.appendChild(div);
            });
        }

        // Animation loop for live rendering
        function animate() {
            const canvases = document.querySelectorAll('.individual canvas');
            canvases.forEach((canvas, idx) => {
                if (population[idx]) {
                    drawIndividual(canvas, population[idx].params, idx < ELITE_COUNT);
                }
            });
            requestAnimationFrame(animate);
        }

        document.getElementById('evolve').addEventListener('click', () => {
            evolve();
            renderPopulation();
        });

        document.getElementById('autoEvolve').addEventListener('click', function() {
            autoEvolving = !autoEvolving;
            this.textContent = autoEvolving ? 'Stop Auto' : 'Auto-Evolve';

            const autoStep = () => {
                if (autoEvolving) {
                    evolve();
                    renderPopulation();
                    setTimeout(autoStep, 100);
                }
            };
            if (autoEvolving) autoStep();
        });

        document.getElementById('reset').addEventListener('click', () => {
            autoEvolving = false;
            document.getElementById('autoEvolve').textContent = 'Auto-Evolve';
            initPopulation();
            renderPopulation();
            updateUI();
        });

        initPopulation();
        renderPopulation();
        updateUI();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
