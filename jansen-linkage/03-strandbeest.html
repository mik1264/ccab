<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - Strandbeest Walking Creature</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 40%, #F4D03F 40%, #E67E22 100%);
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        canvas { display: block; }
        h1 {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #2c3e50; font-size: 1.3rem; text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #2c3e50; text-decoration: none; font-weight: bold;
        }
        .info {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #2c3e50; font-size: 0.9rem; background: rgba(255,255,255,0.7);
            padding: 10px 20px; border-radius: 20px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Strandbeest - Walking Beach Creature</h1>
    <canvas id="canvas"></canvas>
    <div class="info">Theo Jansen's kinetic sculptures walk on beaches powered by wind</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        const PARAMS = {
            a: 38.0, b: 41.5, c: 39.3, d: 40.1, e: 55.8,
            f: 39.4, g: 36.7, h: 65.7, i: 49.0, j: 50.0,
            k: 61.9, l: 7.8, m: 15.0
        };

        function circleIntersection(x1, y1, r1, x2, y2, r2, selectUpper = true) {
            const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));
            const px = x1 + a * (x2 - x1) / d;
            const py = y1 + a * (y2 - y1) / d;
            const ix1 = px + h * (y2 - y1) / d;
            const iy1 = py - h * (x2 - x1) / d;
            const ix2 = px - h * (y2 - y1) / d;
            const iy2 = py + h * (x2 - x1) / d;
            return selectUpper ? (iy1 < iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 })
                               : (iy1 > iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 });
        }

        function calculateJoints(theta) {
            const p = PARAMS;
            const O = { x: 0, y: 0 };
            const M = { x: -p.l, y: -p.m };
            const A = { x: p.a * Math.cos(theta), y: p.a * Math.sin(theta) };
            const B = circleIntersection(A.x, A.y, p.b, M.x, M.y, p.j, true);
            if (!B) return null;
            const C = circleIntersection(A.x, A.y, p.d, B.x, B.y, p.c, false);
            if (!C) return null;
            const D = circleIntersection(B.x, B.y, p.e, C.x, C.y, p.f, false);
            if (!D) return null;
            const E = circleIntersection(M.x, M.y, p.i, D.x, D.y, p.g, true);
            if (!E) return null;
            const F = circleIntersection(E.x, E.y, p.h, D.x, D.y, p.k, false);
            if (!F) return null;
            return { O, M, A, B, C, D, E, F };
        }

        class Strandbeest {
            constructor() {
                this.x = canvas.width + 200;
                this.scale = 2.2;
                this.theta = 0;
                this.numLegs = 6; // 3 pairs
                this.speed = 1;
            }

            drawLeg(theta, yOffset, mirror = false) {
                const joints = calculateJoints(theta);
                if (!joints) return;

                ctx.save();
                if (mirror) ctx.scale(-1, 1);

                const color = '#8B4513';
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                const links = [
                    [joints.O, joints.A], [joints.A, joints.B], [joints.M, joints.B],
                    [joints.A, joints.C], [joints.B, joints.C], [joints.B, joints.D],
                    [joints.C, joints.D], [joints.M, joints.E], [joints.D, joints.E],
                    [joints.E, joints.F], [joints.D, joints.F]
                ];

                links.forEach(([p1, p2]) => {
                    ctx.beginPath();
                    ctx.moveTo(p1.x * this.scale, p1.y * this.scale + yOffset);
                    ctx.lineTo(p2.x * this.scale, p2.y * this.scale + yOffset);
                    ctx.stroke();
                });

                // Joints
                ctx.fillStyle = '#5D3A1A';
                [joints.O, joints.M, joints.A, joints.B, joints.C, joints.D, joints.E].forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x * this.scale, p.y * this.scale + yOffset, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Foot
                ctx.fillStyle = '#2C1810';
                ctx.beginPath();
                ctx.arc(joints.F.x * this.scale, joints.F.y * this.scale + yOffset, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, canvas.height * 0.38);

                // Body (spine)
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(-120 * this.scale, -20, 240 * this.scale, 15);

                // Leg phases offset
                const phaseOffsets = [0, Math.PI * 2/3, Math.PI * 4/3];

                // Draw back legs first (for depth)
                for (let i = 0; i < 3; i++) {
                    const xOffset = (i - 1) * 80 * this.scale;
                    ctx.save();
                    ctx.translate(xOffset, 0);
                    ctx.globalAlpha = 0.5;
                    this.drawLeg(this.theta + phaseOffsets[i], 5, true);
                    ctx.restore();
                }

                // Draw front legs
                for (let i = 0; i < 3; i++) {
                    const xOffset = (i - 1) * 80 * this.scale;
                    ctx.save();
                    ctx.translate(xOffset, 0);
                    this.drawLeg(this.theta + phaseOffsets[i], 0, false);
                    ctx.restore();
                }

                // Central axle
                ctx.fillStyle = '#654321';
                for (let i = 0; i < 3; i++) {
                    const xOffset = (i - 1) * 80 * this.scale;
                    ctx.beginPath();
                    ctx.arc(xOffset, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            update() {
                this.theta += 0.025 * this.speed;
                if (this.theta > Math.PI * 2) this.theta -= Math.PI * 2;

                // Move across screen
                this.x -= 1.5 * this.speed;
                if (this.x < -300) {
                    this.x = canvas.width + 300;
                }
            }
        }

        const beast = new Strandbeest();

        // Beach decoration
        function drawBeach() {
            // Sand texture
            ctx.fillStyle = '#F4D03F';
            const groundY = canvas.height * 0.4;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Sand ripples
            ctx.strokeStyle = 'rgba(230, 126, 34, 0.3)';
            ctx.lineWidth = 2;
            for (let y = groundY + 30; y < canvas.height; y += 40) {
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 5) {
                    const wave = Math.sin(x * 0.02 + y * 0.1) * 3;
                    if (x === 0) ctx.moveTo(x, y + wave);
                    else ctx.lineTo(x, y + wave);
                }
                ctx.stroke();
            }

            // Water edge
            ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            for (let x = 0; x <= canvas.width; x += 10) {
                const wave = Math.sin(x * 0.02 + Date.now() * 0.002) * 5;
                ctx.lineTo(x, groundY + wave - 10);
            }
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.fill();
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBeach();
            beast.update();
            beast.draw();
            requestAnimationFrame(animate);
        }

        // Expose for enhance.js
        window.reset = function() { beast.theta = 0; };

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
