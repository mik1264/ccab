<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - Mechanical Blueprint</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a3a5c;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
        h1 {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 1.1rem; letter-spacing: 4px;
            text-transform: uppercase;
        }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #fff; text-decoration: none;
        }
        .stamp {
            position: fixed; bottom: 20px; right: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 10px 20px; font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            transform: rotate(-5deg);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Technical Drawing - Jansen Mechanism</h1>
    <canvas id="canvas"></canvas>
    <div class="stamp">ENGINEERING DIAGRAM<br>THEO JANSEN 1990<br>SCALE 1:1</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = Math.min(window.innerWidth * 0.95, 1000);
            canvas.height = Math.min(window.innerHeight * 0.8, 700);
        }
        resize();
        window.addEventListener('resize', resize);

        const PARAMS = {
            a: 38.0, b: 41.5, c: 39.3, d: 40.1, e: 55.8,
            f: 39.4, g: 36.7, h: 65.7, i: 49.0, j: 50.0,
            k: 61.9, l: 7.8, m: 15.0
        };

        let theta = 0;

        function circleIntersection(x1, y1, r1, x2, y2, r2, selectUpper = true) {
            const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));
            const px = x1 + a * (x2 - x1) / d;
            const py = y1 + a * (y2 - y1) / d;
            const ix1 = px + h * (y2 - y1) / d;
            const iy1 = py - h * (x2 - x1) / d;
            const ix2 = px - h * (y2 - y1) / d;
            const iy2 = py + h * (x2 - x1) / d;
            return selectUpper ? (iy1 < iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 })
                               : (iy1 > iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 });
        }

        function calculateJoints(theta) {
            const p = PARAMS;
            const O = { x: 0, y: 0 };
            const M = { x: -p.l, y: -p.m };
            const A = { x: p.a * Math.cos(theta), y: p.a * Math.sin(theta) };
            const B = circleIntersection(A.x, A.y, p.b, M.x, M.y, p.j, true);
            if (!B) return null;
            const C = circleIntersection(A.x, A.y, p.d, B.x, B.y, p.c, false);
            if (!C) return null;
            const D = circleIntersection(B.x, B.y, p.e, C.x, C.y, p.f, false);
            if (!D) return null;
            const E = circleIntersection(M.x, M.y, p.i, D.x, D.y, p.g, true);
            if (!E) return null;
            const F = circleIntersection(E.x, E.y, p.h, D.x, D.y, p.k, false);
            if (!F) return null;
            return { O, M, A, B, C, D, E, F };
        }

        function drawGrid() {
            const gridSize = 20;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 0.5;

            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawDimensionLine(x1, y1, x2, y2, label, offset = 20) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const nx = -dy / len * offset;
            const ny = dx / len * offset;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([3, 3]);

            // Extension lines
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + nx, y1 + ny);
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 + nx, y2 + ny);
            ctx.stroke();

            // Dimension line
            ctx.beginPath();
            ctx.moveTo(x1 + nx * 0.8, y1 + ny * 0.8);
            ctx.lineTo(x2 + nx * 0.8, y2 + ny * 0.8);
            ctx.stroke();

            ctx.setLineDash([]);

            // Arrows
            const arrowSize = 5;
            const midX = (x1 + x2) / 2 + nx * 0.8;
            const midY = (y1 + y2) / 2 + ny * 0.8;

            // Label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '9px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, midX, midY - 8);
        }

        function drawJointLabel(x, y, label) {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px Courier New';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x + 10, y - 10);
        }

        function animate() {
            // Blueprint background
            ctx.fillStyle = '#1a3a5c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();

            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);

            const SCALE = 2.8;
            const cx = canvas.width / 2 - 50;
            const cy = canvas.height / 2 - 20;

            const joints = calculateJoints(theta);
            if (!joints) { theta += 0.012; requestAnimationFrame(animate); return; }

            const toScreen = (p) => ({ x: cx + p.x * SCALE, y: cy + p.y * SCALE });

            // Calculate foot path for entire cycle
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            let first = true;
            for (let t = 0; t < Math.PI * 2; t += 0.05) {
                const j = calculateJoints(t);
                if (j) {
                    const p = toScreen(j.F);
                    if (first) { ctx.moveTo(p.x, p.y); first = false; }
                    else ctx.lineTo(p.x, p.y);
                }
            }
            ctx.closePath();
            ctx.stroke();

            // Draw construction circles (faint)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 4]);

            const O = toScreen(joints.O);
            const M = toScreen(joints.M);

            // Crank circle
            ctx.beginPath();
            ctx.arc(O.x, O.y, PARAMS.a * SCALE, 0, Math.PI * 2);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw linkage
            const links = [
                [joints.O, joints.A, 'a=' + PARAMS.a],
                [joints.A, joints.B, 'b=' + PARAMS.b],
                [joints.M, joints.B, 'j=' + PARAMS.j],
                [joints.A, joints.C, 'd=' + PARAMS.d],
                [joints.B, joints.C, 'c=' + PARAMS.c],
                [joints.B, joints.D, 'e=' + PARAMS.e],
                [joints.C, joints.D, 'f=' + PARAMS.f],
                [joints.M, joints.E, 'i=' + PARAMS.i],
                [joints.D, joints.E, 'g=' + PARAMS.g],
                [joints.E, joints.F, 'h=' + PARAMS.h],
                [joints.D, joints.F, 'k=' + PARAMS.k]
            ];

            // Draw links
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            links.forEach(([p1, p2, label], i) => {
                const s1 = toScreen(p1);
                const s2 = toScreen(p2);
                ctx.beginPath();
                ctx.moveTo(s1.x, s1.y);
                ctx.lineTo(s2.x, s2.y);
                ctx.stroke();

                // Add dimension
                if (i % 3 === 0) {
                    drawDimensionLine(s1.x, s1.y, s2.x, s2.y, label, 15 + (i % 2) * 10);
                }
            });

            // Draw joints
            const jointData = [
                [joints.O, 'O (fixed)'],
                [joints.M, 'M (fixed)'],
                [joints.A, 'A (crank)'],
                [joints.B, 'B'],
                [joints.C, 'C'],
                [joints.D, 'D'],
                [joints.E, 'E'],
                [joints.F, 'F (foot)']
            ];

            jointData.forEach(([p, label], i) => {
                const s = toScreen(p);

                // Joint style based on type
                if (i < 2) {
                    // Fixed joints - crossed circle
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(s.x - 8, s.y);
                    ctx.lineTo(s.x + 8, s.y);
                    ctx.moveTo(s.x, s.y - 8);
                    ctx.lineTo(s.x, s.y + 8);
                    ctx.stroke();
                } else if (i === 7) {
                    // Foot - filled with target rings
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Moving joints - simple circles
                    ctx.fillStyle = '#1a3a5c';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                drawJointLabel(s.x, s.y, label);
            });

            // Title block
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(canvas.width - 220, canvas.height - 130, 200, 110);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.strokeRect(canvas.width - 220, canvas.height - 130, 200, 110);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText('JANSEN LINKAGE', canvas.width - 210, canvas.height - 110);
            ctx.font = '10px Courier New';
            ctx.fillText('11-BAR MECHANISM', canvas.width - 210, canvas.height - 90);
            ctx.fillText('THEO JANSEN - 1990', canvas.width - 210, canvas.height - 70);
            ctx.fillText(`θ = ${(theta * 180 / Math.PI).toFixed(1)}°`, canvas.width - 210, canvas.height - 50);

            theta += 0.012;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
