<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - WebGL Shader</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        h1 {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-family: sans-serif; font-size: 1.2rem;
            text-shadow: 0 0 20px #f0f;
        }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #0ff; text-decoration: none; font-family: sans-serif;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>WebGL Shader Visualization</h1>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:50px">WebGL not supported</h1>';
        }

        function resize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        const vertexShaderSrc = `
            attribute vec4 a_position;
            void main() {
                gl_Position = a_position;
            }
        `;

        const fragmentShaderSrc = `
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;

            #define PI 3.14159265359

            // Jansen linkage parameters (Holy Numbers)
            const float a = 38.0, b = 41.5, c = 39.3, d = 40.1, e = 55.8;
            const float f = 39.4, g = 36.7, h = 65.7, i = 49.0, j = 50.0;
            const float k = 61.9, l = 7.8, m = 15.0;

            // Circle-circle intersection
            vec2 circleIntersect(vec2 c1, float r1, vec2 c2, float r2, bool selectUpper) {
                float dist = length(c2 - c1);
                if (dist > r1 + r2 || dist < abs(r1 - r2)) return vec2(0.0);

                float aa = (r1*r1 - r2*r2 + dist*dist) / (2.0 * dist);
                float hh = sqrt(max(0.0, r1*r1 - aa*aa));

                vec2 p = c1 + aa * (c2 - c1) / dist;
                vec2 offset = hh * vec2(c2.y - c1.y, c1.x - c2.x) / dist;

                vec2 i1 = p + offset;
                vec2 i2 = p - offset;

                return selectUpper ? (i1.y < i2.y ? i1 : i2) : (i1.y > i2.y ? i1 : i2);
            }

            // Calculate all joint positions
            void calcJoints(float theta, out vec2 joints[8]) {
                joints[0] = vec2(0.0, 0.0);  // O
                joints[1] = vec2(-l, -m);     // M
                joints[2] = vec2(a * cos(theta), a * sin(theta)); // A

                joints[3] = circleIntersect(joints[2], b, joints[1], j, true);  // B
                joints[4] = circleIntersect(joints[2], d, joints[3], c, false); // C
                joints[5] = circleIntersect(joints[3], e, joints[4], f, false); // D
                joints[6] = circleIntersect(joints[1], i, joints[5], g, true);  // E
                joints[7] = circleIntersect(joints[6], h, joints[5], k, false); // F (foot)
            }

            // Distance to line segment
            float sdSegment(vec2 p, vec2 a, vec2 b) {
                vec2 pa = p - a, ba = b - a;
                float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                return length(pa - ba * h);
            }

            // Distance to circle
            float sdCircle(vec2 p, vec2 c, float r) {
                return abs(length(p - c) - r);
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y);
                uv *= 200.0; // Scale to mechanism space

                float theta = u_time * 0.5;
                vec2 joints[8];
                calcJoints(theta, joints);

                // Background gradient
                vec3 col = vec3(0.02, 0.02, 0.05);

                // Glow effect accumulator
                float glow = 0.0;

                // Draw links
                int links[22];
                links[0] = 0; links[1] = 2;   // O-A
                links[2] = 2; links[3] = 3;   // A-B
                links[4] = 1; links[5] = 3;   // M-B
                links[6] = 2; links[7] = 4;   // A-C
                links[8] = 3; links[9] = 4;   // B-C
                links[10] = 3; links[11] = 5; // B-D
                links[12] = 4; links[13] = 5; // C-D
                links[14] = 1; links[15] = 6; // M-E
                links[16] = 5; links[17] = 6; // D-E
                links[18] = 6; links[19] = 7; // E-F
                links[20] = 5; links[21] = 7; // D-F

                for (int n = 0; n < 11; n++) {
                    int i1 = links[n*2];
                    int i2 = links[n*2+1];
                    float d = sdSegment(uv, joints[i1], joints[i2]);

                    // Colorful neon effect
                    float hue = float(n) / 11.0 + u_time * 0.1;
                    vec3 linkCol = 0.5 + 0.5 * cos(2.0 * PI * (hue + vec3(0.0, 0.33, 0.67)));

                    glow += 0.8 / (d + 1.0) * 0.3;
                    col += linkCol * (1.0 / (d * 0.5 + 0.5)) * 0.02;
                    col = mix(col, linkCol, smoothstep(2.0, 0.5, d));
                }

                // Draw joints
                for (int n = 0; n < 8; n++) {
                    float d = length(uv - joints[n]);
                    float radius = (n == 0 || n == 1) ? 5.0 : (n == 7 ? 6.0 : 3.0);

                    // Joint color
                    vec3 jCol = n == 7 ? vec3(0.2, 1.0, 0.5) :
                               (n < 2 ? vec3(1.0, 0.3, 0.3) : vec3(1.0, 0.8, 0.2));

                    glow += 2.0 / (d + 2.0);
                    col += jCol * (1.0 / (d + 1.0)) * 0.1;
                    col = mix(col, jCol, smoothstep(radius + 1.0, radius - 1.0, d));
                }

                // Foot trajectory
                for (float t = 0.0; t < PI * 2.0; t += 0.1) {
                    vec2 tJoints[8];
                    calcJoints(t, tJoints);
                    float d = length(uv - tJoints[7]);
                    col += vec3(0.0, 0.3, 0.5) / (d + 3.0) * 0.05;
                }

                // Add overall glow
                col += vec3(0.1, 0.05, 0.2) * glow * 0.05;

                // Tone mapping
                col = col / (col + 1.0);
                col = pow(col, vec3(0.9));

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        const timeLoc = gl.getUniformLocation(program, 'u_time');

        function render(time) {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.enableVertexAttribArray(positionLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
