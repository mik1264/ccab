<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - Single Leg</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            color: #fff;
        }
        h1 {
            margin: 20px 0 10px;
            font-size: 1.5rem;
            color: #ffd700;
        }
        .info {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 10px;
        }
        canvas {
            background: #0a0a1a;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.2);
        }
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        button {
            background: #ffd700;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 100px;
        }
        a.back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ffd700;
            text-decoration: none;
            font-size: 0.9rem;
        }
        a.back-link:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <h1>Jansen Linkage - Single Leg Mechanism</h1>
    <p class="info">Theo Jansen's "Holy Numbers" - The optimal walking linkage</p>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="controls">
        <button id="playPause">Pause</button>
        <button id="reset">Reset Trail</button>
        <div class="speed-control">
            <span>Speed:</span>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Theo Jansen's Holy Numbers
        const PARAMS = {
            a: 38.0,  // crank radius
            b: 41.5,
            c: 39.3,
            d: 40.1,
            e: 55.8,
            f: 39.4,
            g: 36.7,
            h: 65.7,
            i: 49.0,
            j: 50.0,
            k: 61.9,
            l: 7.8,   // x offset
            m: 15.0   // y offset (negative in mechanism)
        };

        // Scale factor for display
        const SCALE = 3;
        const CENTER_X = canvas.width / 2 - 50;
        const CENTER_Y = canvas.height / 2 - 80;

        let theta = 0;
        let running = true;
        let speedMultiplier = 1;
        let footPath = [];

        // Circle-circle intersection solver
        function circleIntersection(x1, y1, r1, x2, y2, r2, selectUpper = true) {
            const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));
            const px = x1 + a * (x2 - x1) / d;
            const py = y1 + a * (y2 - y1) / d;
            const ix1 = px + h * (y2 - y1) / d;
            const iy1 = py - h * (x2 - x1) / d;
            const ix2 = px - h * (y2 - y1) / d;
            const iy2 = py + h * (x2 - x1) / d;
            return selectUpper ? (iy1 < iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 })
                               : (iy1 > iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 });
        }

        function calculateJoints(theta) {
            const p = PARAMS;
            const O = { x: 0, y: 0 };
            const M = { x: -p.l, y: -p.m };
            const A = { x: p.a * Math.cos(theta), y: p.a * Math.sin(theta) };
            const B = circleIntersection(A.x, A.y, p.b, M.x, M.y, p.j, true);
            if (!B) return null;
            const C = circleIntersection(A.x, A.y, p.d, B.x, B.y, p.c, false);
            if (!C) return null;
            const D = circleIntersection(B.x, B.y, p.e, C.x, C.y, p.f, false);
            if (!D) return null;
            const E = circleIntersection(M.x, M.y, p.i, D.x, D.y, p.g, true);
            if (!E) return null;
            const F = circleIntersection(E.x, E.y, p.h, D.x, D.y, p.k, false);
            if (!F) return null;
            return { O, M, A, B, C, D, E, F };
        }

        function drawLinkage(joints) {
            if (!joints) return;

            ctx.save();
            ctx.translate(CENTER_X, CENTER_Y);
            ctx.scale(SCALE, SCALE);

            // Draw links
            ctx.lineWidth = 2 / SCALE;
            ctx.lineCap = 'round';

            // Link colors
            const linkStyle = (color) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5 / SCALE;
            };

            // Crank OA
            linkStyle('#ff6b6b');
            ctx.beginPath();
            ctx.moveTo(joints.O.x, joints.O.y);
            ctx.lineTo(joints.A.x, joints.A.y);
            ctx.stroke();

            // Link AB
            linkStyle('#ffd93d');
            ctx.beginPath();
            ctx.moveTo(joints.A.x, joints.A.y);
            ctx.lineTo(joints.B.x, joints.B.y);
            ctx.stroke();

            // Link MJ (M to B via j)
            linkStyle('#6bcb77');
            ctx.beginPath();
            ctx.moveTo(joints.M.x, joints.M.y);
            ctx.lineTo(joints.B.x, joints.B.y);
            ctx.stroke();

            // Link AC (d)
            linkStyle('#4d96ff');
            ctx.beginPath();
            ctx.moveTo(joints.A.x, joints.A.y);
            ctx.lineTo(joints.C.x, joints.C.y);
            ctx.stroke();

            // Link BC (c)
            linkStyle('#9b59b6');
            ctx.beginPath();
            ctx.moveTo(joints.B.x, joints.B.y);
            ctx.lineTo(joints.C.x, joints.C.y);
            ctx.stroke();

            // Link BE (e)
            linkStyle('#ff9f43');
            ctx.beginPath();
            ctx.moveTo(joints.B.x, joints.B.y);
            ctx.lineTo(joints.D.x, joints.D.y);
            ctx.stroke();

            // Link CF (f)
            linkStyle('#00d2d3');
            ctx.beginPath();
            ctx.moveTo(joints.C.x, joints.C.y);
            ctx.lineTo(joints.D.x, joints.D.y);
            ctx.stroke();

            // Link MI (i)
            linkStyle('#ff6b9d');
            ctx.beginPath();
            ctx.moveTo(joints.M.x, joints.M.y);
            ctx.lineTo(joints.E.x, joints.E.y);
            ctx.stroke();

            // Link DG (g)
            linkStyle('#c7ecee');
            ctx.beginPath();
            ctx.moveTo(joints.D.x, joints.D.y);
            ctx.lineTo(joints.E.x, joints.E.y);
            ctx.stroke();

            // Link EH (h)
            linkStyle('#dfe6e9');
            ctx.beginPath();
            ctx.moveTo(joints.E.x, joints.E.y);
            ctx.lineTo(joints.F.x, joints.F.y);
            ctx.stroke();

            // Link DK (k)
            linkStyle('#a29bfe');
            ctx.beginPath();
            ctx.moveTo(joints.D.x, joints.D.y);
            ctx.lineTo(joints.F.x, joints.F.y);
            ctx.stroke();

            // Draw joints
            const drawJoint = (point, color, radius = 3) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius / SCALE, 0, Math.PI * 2);
                ctx.fill();
            };

            // Fixed joints (larger, red)
            drawJoint(joints.O, '#ff0000', 5);
            drawJoint(joints.M, '#ff0000', 5);

            // Moving joints
            drawJoint(joints.A, '#ffd700', 4);
            drawJoint(joints.B, '#ffd700', 4);
            drawJoint(joints.C, '#ffd700', 4);
            drawJoint(joints.D, '#ffd700', 4);
            drawJoint(joints.E, '#ffd700', 4);

            // Foot (larger, bright)
            drawJoint(joints.F, '#00ff00', 6);

            ctx.restore();
        }

        function drawFootPath() {
            if (footPath.length < 2) return;

            ctx.save();
            ctx.translate(CENTER_X, CENTER_Y);
            ctx.scale(SCALE, SCALE);

            ctx.strokeStyle = 'rgba(0, 255, 100, 0.6)';
            ctx.lineWidth = 1.5 / SCALE;
            ctx.beginPath();
            ctx.moveTo(footPath[0].x, footPath[0].y);

            for (let i = 1; i < footPath.length; i++) {
                ctx.lineTo(footPath[i].x, footPath[i].y);
            }
            ctx.stroke();

            ctx.restore();
        }

        function drawParameters() {
            ctx.fillStyle = '#ffd700';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';

            const params = [
                `a = ${PARAMS.a}  g = ${PARAMS.g}`,
                `b = ${PARAMS.b}  h = ${PARAMS.h}`,
                `c = ${PARAMS.c}  i = ${PARAMS.i}`,
                `d = ${PARAMS.d}  j = ${PARAMS.j}`,
                `e = ${PARAMS.e}  k = ${PARAMS.k}`,
                `f = ${PARAMS.f}  l = ${PARAMS.l}`,
                `m = ${PARAMS.m}`
            ];

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(15, 50, 180, 140);
            ctx.strokeStyle = '#ffd700';
            ctx.strokeRect(15, 50, 180, 140);

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 12px monospace';
            ctx.fillText('Holy Numbers:', 25, 70);
            ctx.font = '12px monospace';
            params.forEach((line, i) => {
                ctx.fillText(line, 25, 90 + i * 14);
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw foot path first (underneath)
            drawFootPath();

            // Calculate and draw linkage
            const joints = calculateJoints(theta);
            drawLinkage(joints);

            // Store foot position for trail
            if (joints && joints.F) {
                footPath.push({ x: joints.F.x, y: joints.F.y });
                if (footPath.length > 500) footPath.shift();
            }

            // Draw parameters
            drawParameters();

            // Update angle
            if (running) {
                theta += 0.02 * speedMultiplier;
                if (theta > Math.PI * 2) theta -= Math.PI * 2;
            }

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('playPause').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Play';
        });

        document.getElementById('reset').addEventListener('click', () => {
            footPath = [];
        });

        document.getElementById('speed').addEventListener('input', function() {
            speedMultiplier = parseFloat(this.value);
        });

        animate();
    </script>
</body>
</html>
