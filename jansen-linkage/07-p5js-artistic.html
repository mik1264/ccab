<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - P5.js Artistic</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
        }
        main { display: block; }
        .info {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; text-align: center;
        }
        .info h1 { font-size: 1.3rem; color: #ff6b6b; }
        .info p { font-size: 0.8rem; color: #888; margin-top: 5px; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6b6b; text-decoration: none;
        }
        .controls {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px;
        }
        button {
            background: rgba(255,107,107,0.8); color: #fff; border: none;
            padding: 8px 16px; border-radius: 20px; cursor: pointer;
        }
        button:hover { background: #ff6b6b; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="info">
        <h1>Artistic Jansen Visualization</h1>
        <p>Generative art with P5.js • Click to change style</p>
    </div>
    <main></main>
    <div class="controls">
        <button onclick="changeStyle()">Change Style</button>
        <button onclick="clearCanvas()">Clear</button>
        <button onclick="saveArt()">Save Image</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        const PARAMS = {
            a: 38.0, b: 41.5, c: 39.3, d: 40.1, e: 55.8,
            f: 39.4, g: 36.7, h: 65.7, i: 49.0, j: 50.0,
            k: 61.9, l: 7.8, m: 15.0
        };

        let theta = 0;
        let styleIndex = 0;
        const styles = ['rainbow', 'particle', 'neon', 'ink', 'geometric'];
        let particles = [];
        let prevFoot = null;

        function circleIntersection(x1, y1, r1, x2, y2, r2, selectUpper = true) {
            const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));
            const px = x1 + a * (x2 - x1) / d;
            const py = y1 + a * (y2 - y1) / d;
            const ix1 = px + h * (y2 - y1) / d;
            const iy1 = py - h * (x2 - x1) / d;
            const ix2 = px - h * (y2 - y1) / d;
            const iy2 = py + h * (x2 - x1) / d;
            return selectUpper ? (iy1 < iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 })
                               : (iy1 > iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 });
        }

        function calculateJoints(t) {
            const p = PARAMS;
            const O = { x: 0, y: 0 };
            const M = { x: -p.l, y: -p.m };
            const A = { x: p.a * Math.cos(t), y: p.a * Math.sin(t) };
            const B = circleIntersection(A.x, A.y, p.b, M.x, M.y, p.j, true);
            if (!B) return null;
            const C = circleIntersection(A.x, A.y, p.d, B.x, B.y, p.c, false);
            if (!C) return null;
            const D = circleIntersection(B.x, B.y, p.e, C.x, C.y, p.f, false);
            if (!D) return null;
            const E = circleIntersection(M.x, M.y, p.i, D.x, D.y, p.g, true);
            if (!E) return null;
            const F = circleIntersection(E.x, E.y, p.h, D.x, D.y, p.k, false);
            if (!F) return null;
            return { O, M, A, B, C, D, E, F };
        }

        function setup() {
            createCanvas(900, 700);
            colorMode(HSB, 360, 100, 100, 100);
            background(0);
        }

        function draw() {
            const SCALE = 3;
            const cx = width / 2;
            const cy = height / 2;

            // Fade background for trails
            if (styles[styleIndex] !== 'particle') {
                fill(0, 0, 0, 5);
                noStroke();
                rect(0, 0, width, height);
            }

            const joints = calculateJoints(theta);
            if (!joints) { theta += 0.02; return; }

            const foot = createVector(cx + joints.F.x * SCALE, cy + joints.F.y * SCALE);

            // Draw based on current style
            switch (styles[styleIndex]) {
                case 'rainbow':
                    drawRainbowStyle(joints, SCALE, cx, cy, foot);
                    break;
                case 'particle':
                    drawParticleStyle(foot);
                    break;
                case 'neon':
                    drawNeonStyle(joints, SCALE, cx, cy, foot);
                    break;
                case 'ink':
                    drawInkStyle(joints, SCALE, cx, cy, foot);
                    break;
                case 'geometric':
                    drawGeometricStyle(joints, SCALE, cx, cy);
                    break;
            }

            prevFoot = foot.copy();
            theta += 0.025;
        }

        function drawRainbowStyle(joints, scale, cx, cy, foot) {
            const hue = (frameCount * 2) % 360;

            // Draw linkage with rainbow colors
            const links = [
                [joints.O, joints.A], [joints.A, joints.B], [joints.M, joints.B],
                [joints.A, joints.C], [joints.B, joints.C], [joints.B, joints.D],
                [joints.C, joints.D], [joints.M, joints.E], [joints.D, joints.E],
                [joints.E, joints.F], [joints.D, joints.F]
            ];

            links.forEach(([p1, p2], i) => {
                stroke((hue + i * 30) % 360, 80, 90, 80);
                strokeWeight(3);
                line(cx + p1.x * scale, cy + p1.y * scale,
                     cx + p2.x * scale, cy + p2.y * scale);
            });

            // Foot trail
            if (prevFoot) {
                stroke(hue, 100, 100);
                strokeWeight(4);
                line(prevFoot.x, prevFoot.y, foot.x, foot.y);
            }

            // Glowing foot
            noStroke();
            for (let r = 20; r > 0; r -= 4) {
                fill(hue, 80, 100, map(r, 20, 0, 0, 50));
                ellipse(foot.x, foot.y, r * 2, r * 2);
            }
        }

        function drawParticleStyle(foot) {
            // Spawn particles at foot
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: foot.x,
                    y: foot.y,
                    vx: random(-2, 2),
                    vy: random(-3, 0),
                    life: 255,
                    hue: random(360),
                    size: random(3, 8)
                });
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= 3;

                noStroke();
                fill(p.hue, 80, 100, p.life / 2.55);
                ellipse(p.x, p.y, p.size, p.size);

                if (p.life <= 0) particles.splice(i, 1);
            }

            // Limit particles
            if (particles.length > 1000) particles.splice(0, 100);
        }

        function drawNeonStyle(joints, scale, cx, cy, foot) {
            // Neon glow effect
            const colors = [
                color(320, 100, 100), // magenta
                color(180, 100, 100), // cyan
                color(60, 100, 100)   // yellow
            ];

            const links = [
                [joints.O, joints.A], [joints.A, joints.B], [joints.M, joints.B],
                [joints.A, joints.C], [joints.B, joints.C], [joints.B, joints.D],
                [joints.C, joints.D], [joints.M, joints.E], [joints.D, joints.E],
                [joints.E, joints.F], [joints.D, joints.F]
            ];

            // Draw glow layers
            for (let glow = 15; glow > 0; glow -= 3) {
                links.forEach(([p1, p2], i) => {
                    const c = colors[i % colors.length];
                    stroke(hue(c), saturation(c), brightness(c), map(glow, 15, 0, 5, 30));
                    strokeWeight(glow);
                    line(cx + p1.x * scale, cy + p1.y * scale,
                         cx + p2.x * scale, cy + p2.y * scale);
                });
            }

            // Core lines
            links.forEach(([p1, p2], i) => {
                stroke(colors[i % colors.length]);
                strokeWeight(2);
                line(cx + p1.x * scale, cy + p1.y * scale,
                     cx + p2.x * scale, cy + p2.y * scale);
            });

            // Foot glow
            noStroke();
            for (let r = 30; r > 0; r -= 5) {
                fill(120, 100, 100, map(r, 30, 0, 0, 40));
                ellipse(foot.x, foot.y, r * 2, r * 2);
            }
        }

        function drawInkStyle(joints, scale, cx, cy, foot) {
            // Ink brush style
            if (prevFoot) {
                const d = dist(prevFoot.x, prevFoot.y, foot.x, foot.y);
                const steps = max(1, floor(d / 2));

                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = lerp(prevFoot.x, foot.x, t);
                    const y = lerp(prevFoot.y, foot.y, t);
                    const size = map(sin(frameCount * 0.1 + i), -1, 1, 5, 20);

                    noStroke();
                    fill(0, 0, 100, 30);
                    ellipse(x + random(-3, 3), y + random(-3, 3), size, size);
                }
            }

            // Ink splatter at joints
            if (frameCount % 10 === 0) {
                [joints.F, joints.D, joints.E].forEach(j => {
                    for (let i = 0; i < 3; i++) {
                        fill(0, 0, 100, random(10, 30));
                        ellipse(
                            cx + j.x * scale + random(-20, 20),
                            cy + j.y * scale + random(-20, 20),
                            random(2, 8), random(2, 8)
                        );
                    }
                });
            }
        }

        function drawGeometricStyle(joints, scale, cx, cy) {
            const hue = (frameCount * 0.5) % 360;

            // Draw geometric shapes at each joint
            const jointPositions = [joints.O, joints.M, joints.A, joints.B, joints.C, joints.D, joints.E, joints.F];

            jointPositions.forEach((j, i) => {
                const x = cx + j.x * scale;
                const y = cy + j.y * scale;
                const size = i === 7 ? 25 : 15;

                push();
                translate(x, y);
                rotate(frameCount * 0.02 + i);

                stroke((hue + i * 40) % 360, 70, 90, 60);
                strokeWeight(2);
                noFill();

                if (i % 3 === 0) {
                    // Triangle
                    beginShape();
                    for (let a = 0; a < 3; a++) {
                        vertex(cos(a * TWO_PI / 3) * size, sin(a * TWO_PI / 3) * size);
                    }
                    endShape(CLOSE);
                } else if (i % 3 === 1) {
                    // Square
                    rectMode(CENTER);
                    rect(0, 0, size * 1.5, size * 1.5);
                } else {
                    // Hexagon
                    beginShape();
                    for (let a = 0; a < 6; a++) {
                        vertex(cos(a * TWO_PI / 6) * size, sin(a * TWO_PI / 6) * size);
                    }
                    endShape(CLOSE);
                }
                pop();
            });

            // Connect joints with lines
            const links = [
                [0, 2], [2, 3], [1, 3], [2, 4], [3, 4], [3, 5],
                [4, 5], [1, 6], [5, 6], [6, 7], [5, 7]
            ];

            links.forEach(([i1, i2], idx) => {
                const p1 = jointPositions[i1];
                const p2 = jointPositions[i2];
                stroke((hue + idx * 20) % 360, 60, 80, 40);
                strokeWeight(1);
                line(cx + p1.x * scale, cy + p1.y * scale,
                     cx + p2.x * scale, cy + p2.y * scale);
            });
        }

        function changeStyle() {
            styleIndex = (styleIndex + 1) % styles.length;
            clearCanvas();
        }

        function clearCanvas() {
            background(0);
            particles = [];
        }

        function saveArt() {
            saveCanvas('jansen-art', 'png');
        }

        function mousePressed() {
            if (mouseY > 60 && mouseY < height - 60) {
                changeStyle();
            }
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
