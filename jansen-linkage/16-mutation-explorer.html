<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jansen Linkage - Mutation Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1e1e2f;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            color: #fff;
        }
        h1 {
            text-align: center; padding: 20px;
            color: #ff6b9d; font-size: 1.3rem;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            padding: 0 20px 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .cell {
            background: #2a2a40;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .cell:hover { transform: scale(1.03); box-shadow: 0 0 20px rgba(255, 107, 157, 0.3); }
        .cell.original { border: 2px solid #ffd700; }
        .cell canvas { display: block; margin: 0 auto; background: #1a1a2a; border-radius: 5px; }
        .cell-label { font-size: 0.7rem; color: #888; margin-top: 5px; }
        .mutation-info { font-size: 0.65rem; color: #ff6b9d; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6b9d; text-decoration: none;
        }
        .controls {
            text-align: center; padding: 15px;
        }
        button {
            background: #ff6b9d; color: #fff; border: none;
            padding: 10px 25px; border-radius: 25px; cursor: pointer;
            margin: 0 10px; font-size: 0.9rem;
        }
        button:hover { background: #ff8fb3; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Random Mutation Explorer</h1>
    <p style="text-align: center; color: #888; margin-bottom: 15px; font-size: 0.85rem;">
        Explore how random parameter changes affect the walking trajectory
    </p>
    <div class="controls">
        <button onclick="generateMutations()">Generate New Mutations</button>
        <button onclick="evolveFromBest()">Evolve from Best</button>
    </div>
    <div class="grid" id="grid"></div>

    <script>
        const ORIGINAL = {
            a: 38.0, b: 41.5, c: 39.3, d: 40.1, e: 55.8,
            f: 39.4, g: 36.7, h: 65.7, i: 49.0, j: 50.0,
            k: 61.9, l: 7.8, m: 15.0
        };

        const PARAM_RANGES = {
            a: [25, 55], b: [28, 60], c: [25, 55], d: [28, 55], e: [40, 75],
            f: [28, 55], g: [25, 50], h: [50, 90], i: [35, 65], j: [35, 65],
            k: [45, 80], l: [3, 15], m: [8, 25]
        };

        let mutations = [];
        let selectedIndex = 0;

        function circleIntersection(x1, y1, r1, x2, y2, r2, selectUpper = true) {
            const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));
            const px = x1 + a * (x2 - x1) / d;
            const py = y1 + a * (y2 - y1) / d;
            const ix1 = px + h * (y2 - y1) / d;
            const iy1 = py - h * (x2 - x1) / d;
            const ix2 = px - h * (y2 - y1) / d;
            const iy2 = py + h * (x2 - x1) / d;
            return selectUpper ? (iy1 < iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 })
                               : (iy1 > iy2 ? { x: ix1, y: iy1 } : { x: ix2, y: iy2 });
        }

        function calculateJoints(params, theta) {
            const p = params;
            const O = { x: 0, y: 0 };
            const M = { x: -p.l, y: -p.m };
            const A = { x: p.a * Math.cos(theta), y: p.a * Math.sin(theta) };
            const B = circleIntersection(A.x, A.y, p.b, M.x, M.y, p.j, true);
            if (!B) return null;
            const C = circleIntersection(A.x, A.y, p.d, B.x, B.y, p.c, false);
            if (!C) return null;
            const D = circleIntersection(B.x, B.y, p.e, C.x, C.y, p.f, false);
            if (!D) return null;
            const E = circleIntersection(M.x, M.y, p.i, D.x, D.y, p.g, true);
            if (!E) return null;
            const F = circleIntersection(E.x, E.y, p.h, D.x, D.y, p.k, false);
            if (!F) return null;
            return { O, M, A, B, C, D, E, F };
        }

        function mutateParams(base, strength = 1) {
            const mutated = { ...base };
            const numMutations = Math.floor(Math.random() * 4) + 1;
            const keys = Object.keys(PARAM_RANGES);
            const mutatedKeys = [];

            for (let i = 0; i < numMutations; i++) {
                const key = keys[Math.floor(Math.random() * keys.length)];
                const [min, max] = PARAM_RANGES[key];
                const range = max - min;
                const change = (Math.random() - 0.5) * range * 0.3 * strength;
                mutated[key] = Math.max(min, Math.min(max, mutated[key] + change));
                mutatedKeys.push(key);
            }

            return { params: mutated, mutatedKeys };
        }

        function calculatePath(params) {
            const path = [];
            for (let t = 0; t < Math.PI * 2; t += 0.05) {
                const joints = calculateJoints(params, t);
                if (joints && joints.F) {
                    path.push({ x: joints.F.x, y: joints.F.y });
                }
            }
            return path;
        }

        function drawMutation(canvas, params, path, isOriginal, mutatedKeys) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const scale = 1.3;
            const cx = w / 2;
            const cy = h / 2;

            ctx.clearRect(0, 0, w, h);

            if (path.length < 50) {
                ctx.fillStyle = '#ff4444';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Invalid', cx, cy);
                return;
            }

            // Draw path
            ctx.strokeStyle = isOriginal ? '#ffd700' : '#ff6b9d';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cx + path[0].x * scale, cy + path[0].y * scale);
            for (const p of path) {
                ctx.lineTo(cx + p.x * scale, cy + p.y * scale);
            }
            ctx.closePath();
            ctx.stroke();

            // Draw current position
            const theta = Date.now() * 0.002;
            const joints = calculateJoints(params, theta);
            if (joints) {
                // Draw simplified linkage
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                const links = [
                    [joints.O, joints.A], [joints.A, joints.B], [joints.M, joints.B],
                    [joints.A, joints.C], [joints.B, joints.C], [joints.B, joints.D],
                    [joints.C, joints.D], [joints.M, joints.E], [joints.D, joints.E],
                    [joints.E, joints.F], [joints.D, joints.F]
                ];
                links.forEach(([p1, p2]) => {
                    ctx.beginPath();
                    ctx.moveTo(cx + p1.x * scale, cy + p1.y * scale);
                    ctx.lineTo(cx + p2.x * scale, cy + p2.y * scale);
                    ctx.stroke();
                });

                // Foot
                ctx.fillStyle = isOriginal ? '#ffd700' : '#ff6b9d';
                ctx.beginPath();
                ctx.arc(cx + joints.F.x * scale, cy + joints.F.y * scale, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function generateMutations() {
            mutations = [{ params: { ...ORIGINAL }, mutatedKeys: [], isOriginal: true }];

            for (let i = 1; i < 25; i++) {
                const { params, mutatedKeys } = mutateParams(ORIGINAL, 1 + Math.random());
                mutations.push({ params, mutatedKeys, isOriginal: false });
            }

            renderGrid();
        }

        function evolveFromBest() {
            if (selectedIndex > 0) {
                const baseParams = mutations[selectedIndex].params;
                mutations = [{ params: { ...ORIGINAL }, mutatedKeys: [], isOriginal: true }];

                for (let i = 1; i < 25; i++) {
                    const { params, mutatedKeys } = mutateParams(baseParams, 0.5);
                    mutations.push({ params, mutatedKeys, isOriginal: false });
                }

                renderGrid();
            }
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';

            mutations.forEach((mutation, idx) => {
                const cell = document.createElement('div');
                cell.className = 'cell' + (mutation.isOriginal ? ' original' : '');

                const canvas = document.createElement('canvas');
                canvas.width = 180;
                canvas.height = 120;

                const path = calculatePath(mutation.params);
                mutation.path = path;
                mutation.canvas = canvas;

                const label = document.createElement('div');
                label.className = 'cell-label';
                label.textContent = mutation.isOriginal ? 'Original (Holy Numbers)' : `Mutation #${idx}`;

                const info = document.createElement('div');
                info.className = 'mutation-info';
                if (!mutation.isOriginal) {
                    info.textContent = mutation.mutatedKeys.join(', ');
                }

                cell.appendChild(canvas);
                cell.appendChild(label);
                cell.appendChild(info);

                cell.addEventListener('click', () => {
                    selectedIndex = idx;
                    document.querySelectorAll('.cell').forEach(c => c.style.border = '');
                    cell.style.border = '2px solid #00ff00';
                });

                grid.appendChild(cell);
            });
        }

        function animate() {
            mutations.forEach(m => {
                if (m.canvas && m.path) {
                    drawMutation(m.canvas, m.params, m.path, m.isOriginal, m.mutatedKeys);
                }
            });
            requestAnimationFrame(animate);
        }

        generateMutations();
        animate();
    </script>
</body>
</html>
