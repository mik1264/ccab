<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Couette Flow Between Plates</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: bold; z-index: 999;
    text-shadow: 0 0 10px rgba(0,0,0,0.8); pointer-events: none;
}
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 16px; align-items: center; z-index: 999;
    background: rgba(0,0,0,0.7); padding: 12px 20px; border-radius: 10px;
    flex-wrap: wrap; justify-content: center;
}
.controls label { color: #ccc; font-size: 12px; }
.controls input[type=range] { width: 90px; cursor: pointer; }
.controls span { color: #fbbf24; font-size: 12px; min-width: 25px; }
.info {
    position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
    color: rgba(255,255,255,0.5); font-size: 12px; z-index: 999;
    pointer-events: none; text-align: center;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div class="title-overlay">Couette Flow Between Plates</div>
<div class="info">Top plate moves right. Add pressure gradient for combined Couette-Poiseuille flow.</div>
<div class="controls">
    <label>Plate Speed</label>
    <input type="range" id="plateSlider" min="0" max="20" value="12" step="1">
    <span id="plateVal">12</span>
    <label>Pressure Gradient</label>
    <input type="range" id="pressSlider" min="-10" max="10" value="0" step="1">
    <span id="pressVal">0</span>
    <label>Gap Width</label>
    <input type="range" id="gapSlider" min="3" max="10" value="6" step="1">
    <span id="gapVal">6</span>
    <label>Viscosity</label>
    <input type="range" id="viscSlider" min="1" max="15" value="5" step="1">
    <span id="viscVal">5</span>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

const NUM_PARTICLES = 600;
let particles = [];
let time = 0;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    initParticles();
}

function getGap() {
    return parseInt(document.getElementById('gapSlider').value) / 10 * (H * 0.3);
}

function getVelocity(y_norm) {
    // y_norm: 0 = bottom plate, 1 = top plate
    const U = parseInt(document.getElementById('plateSlider').value) * 0.3;
    const dP = parseInt(document.getElementById('pressSlider').value) * 0.15;
    const mu = parseInt(document.getElementById('viscSlider').value) * 0.3;
    const h = 1.0; // normalized gap

    // Couette: U * y/h
    // Poiseuille: -(dP/dx)/(2*mu) * y * (h - y)
    const couette = U * y_norm;
    const poiseuille = dP / (2 * mu) * y_norm * (h - y_norm) * 10;
    return couette + poiseuille;
}

function getMaxAbsVelocity() {
    let maxV = 0;
    for (let i = 0; i <= 100; i++) {
        maxV = Math.max(maxV, Math.abs(getVelocity(i / 100)));
    }
    return Math.max(0.01, maxV);
}

function initParticles() {
    particles = [];
    const gap = getGap();
    const centerY = H / 2;
    for (let i = 0; i < NUM_PARTICLES; i++) {
        const y_norm = Math.random();
        particles.push({
            x: Math.random() * W,
            y_norm: y_norm,
            trail: []
        });
    }
}

function drawPlates() {
    const gap = getGap();
    const centerY = H / 2;
    const topY = centerY - gap;
    const botY = centerY + gap;
    const U = parseInt(document.getElementById('plateSlider').value) * 0.3;

    // Top plate - moving
    ctx.fillStyle = '#556677';
    ctx.fillRect(0, topY - 25, W, 25);
    ctx.fillStyle = '#778899';
    ctx.fillRect(0, topY - 25, W, 3);

    // Arrows on top plate showing motion
    const arrowSpacing = 80;
    const arrowOffset = (time * U * 3) % arrowSpacing;
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 2;
    for (let x = -arrowSpacing + arrowOffset; x < W + arrowSpacing; x += arrowSpacing) {
        const ay = topY - 13;
        ctx.beginPath();
        ctx.moveTo(x - 15, ay);
        ctx.lineTo(x + 15, ay);
        ctx.lineTo(x + 10, ay - 5);
        ctx.moveTo(x + 15, ay);
        ctx.lineTo(x + 10, ay + 5);
        ctx.stroke();
    }

    // Bottom plate - stationary
    ctx.fillStyle = '#556677';
    ctx.fillRect(0, botY, W, 25);
    ctx.fillStyle = '#778899';
    ctx.fillRect(0, botY, W, 3);

    // Hash marks on bottom plate (stationary)
    ctx.strokeStyle = '#aabbcc';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, botY + 5);
        ctx.lineTo(x + 10, botY + 20);
        ctx.stroke();
    }

    // Labels
    ctx.fillStyle = '#fbbf24';
    ctx.font = '12px sans-serif';
    ctx.fillText('Moving plate (v = U)', 15, topY - 30);
    ctx.fillStyle = '#8899aa';
    ctx.fillText('Fixed plate (v = 0)', 15, botY + 40);
}

function drawVelocityProfile() {
    const gap = getGap();
    const centerY = H / 2;
    const topY = centerY - gap;
    const botY = centerY + gap;
    const maxV = getMaxAbsVelocity();
    const profileX = W - 150;
    const profileW = 100;

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(profileX - 20, topY - 10, profileW + 40, botY - topY + 20);
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.strokeRect(profileX - 20, topY - 10, profileW + 40, botY - topY + 20);

    // Zero line
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(profileX, topY);
    ctx.lineTo(profileX, botY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Velocity profile curve
    ctx.beginPath();
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 100; i++) {
        const y_norm = i / 100;
        const v = getVelocity(y_norm);
        const px = profileX + (v / maxV) * (profileW * 0.45);
        const py = botY - y_norm * (botY - topY);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Fill
    ctx.lineTo(profileX, topY);
    ctx.lineTo(profileX, botY);
    ctx.closePath();
    ctx.fillStyle = 'rgba(251, 191, 36, 0.1)';
    ctx.fill();

    // Label
    ctx.fillStyle = '#fbbf24';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('u(y)', profileX, topY - 15);
    ctx.textAlign = 'left';
}

function drawEquation() {
    const dP = parseInt(document.getElementById('pressSlider').value);
    let eqText = 'u(y) = U(y/h)';
    if (dP !== 0) {
        eqText += ' + (dP/dx)(hy - y\u00B2)/(2\u03BC)';
    }

    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    const tw = ctx.measureText(eqText).width + 40;
    ctx.fillRect(W / 2 - tw / 2, 50, tw, 35);
    ctx.strokeStyle = 'rgba(251,191,36,0.3)';
    ctx.strokeRect(W / 2 - tw / 2, 50, tw, 35);
    ctx.fillStyle = '#eee';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(eqText, W / 2, 73);
    ctx.textAlign = 'left';
}

function render() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const gap = getGap();
    const centerY = H / 2;
    const topY = centerY - gap;
    const botY = centerY + gap;
    const maxV = getMaxAbsVelocity();
    time += 0.016;

    // Background gradient in gap
    const bgGrad = ctx.createLinearGradient(0, topY, 0, botY);
    bgGrad.addColorStop(0, 'rgba(25, 35, 60, 0.8)');
    bgGrad.addColorStop(0.5, 'rgba(20, 30, 50, 0.6)');
    bgGrad.addColorStop(1, 'rgba(15, 25, 45, 0.8)');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, topY, W, botY - topY);

    // Draw shear lines
    ctx.strokeStyle = 'rgba(100, 120, 160, 0.15)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 20; i++) {
        const y_norm = i / 20;
        const y = botY - y_norm * (botY - topY);
        const v = getVelocity(y_norm);
        const offset = (time * v * 60) % 80;

        ctx.setLineDash([15, 25]);
        ctx.lineDashOffset = -offset;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
    }
    ctx.setLineDash([]);

    // Update and draw particles
    for (let p of particles) {
        const v = getVelocity(p.y_norm);
        const pxY = botY - p.y_norm * (botY - topY);
        p.x += v * 0.8;

        p.trail.push({ x: p.x, y: pxY });
        if (p.trail.length > 12) p.trail.shift();

        // Wrap
        if (p.x > W + 20) { p.x = -20; p.trail = []; }
        if (p.x < -20) { p.x = W + 20; p.trail = []; }

        // Color by speed
        const speed = Math.abs(v) / maxV;
        const hue = 200 - speed * 160;
        const alpha = 0.7 + speed * 0.3;

        // Trail
        if (p.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let t of p.trail) ctx.lineTo(t.x, t.y);
            ctx.strokeStyle = `hsla(${hue}, 80%, 55%, 0.25)`;
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        // Particle
        const size = 1.5 + speed * 2;
        ctx.beginPath();
        ctx.arc(p.x, pxY, size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${hue}, 85%, 60%, ${alpha})`;
        ctx.fill();
    }

    drawPlates();
    drawVelocityProfile();
    drawEquation();
}

['plateSlider', 'pressSlider', 'gapSlider', 'viscSlider'].forEach(id => {
    document.getElementById(id).addEventListener('input', function() {
        document.getElementById(id.replace('Slider', 'Val')).textContent = this.value;
        if (id === 'gapSlider') initParticles();
    });
});

function animate() {
    render();
    requestAnimationFrame(animate);
}

window.addEventListener('resize', resize);
resize();
animate();
</script>
</body>
</html>
