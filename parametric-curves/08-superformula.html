<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Superformula</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
    position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.7);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138,170,255,0.2); border-radius: 12px;
    padding: 18px; color: #cde; z-index: 100; min-width: 240px;
    max-height: calc(100vh - 60px); overflow-y: auto;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 1.1em; }
.ctrl { margin-bottom: 8px; }
.ctrl label { display: block; font-size: 0.8em; margin-bottom: 2px; color: #9ab; }
.ctrl input[type=range] { width: 100%; accent-color: #8af; }
.ctrl .val { float: right; color: #8af; font-size: 0.8em; }
.btn-row { display: flex; gap: 5px; flex-wrap: wrap; margin-top: 8px; }
.btn-row button {
    flex: 1; min-width: 55px; padding: 4px 6px; background: rgba(138,170,255,0.15);
    border: 1px solid rgba(138,170,255,0.3); border-radius: 6px;
    color: #8af; cursor: pointer; font-size: 0.72em;
}
.btn-row button:hover { background: rgba(138,170,255,0.3); }
.toggle-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.toggle-row label { font-size: 0.82em; color: #9ab; cursor: pointer; }
.toggle-row input { accent-color: #8af; }
#info {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    color: rgba(138,170,255,0.6); font-size: 0.85em; text-align: center;
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
    <h3>Superformula</h3>
    <div class="ctrl">
        <label>m (symmetry) <span class="val" id="mVal">5</span></label>
        <input type="range" id="mSlider" min="0" max="20" step="0.5" value="5">
    </div>
    <div class="ctrl">
        <label>n1 (shape) <span class="val" id="n1Val">1</span></label>
        <input type="range" id="n1Slider" min="0.1" max="20" step="0.1" value="1">
    </div>
    <div class="ctrl">
        <label>n2 <span class="val" id="n2Val">1</span></label>
        <input type="range" id="n2Slider" min="0.1" max="20" step="0.1" value="1">
    </div>
    <div class="ctrl">
        <label>n3 <span class="val" id="n3Val">1</span></label>
        <input type="range" id="n3Slider" min="0.1" max="20" step="0.1" value="1">
    </div>
    <div class="ctrl">
        <label>a <span class="val" id="aVal">1</span></label>
        <input type="range" id="aSlider" min="0.5" max="2" step="0.05" value="1">
    </div>
    <div class="ctrl">
        <label>b <span class="val" id="bVal">1</span></label>
        <input type="range" id="bSlider" min="0.5" max="2" step="0.05" value="1">
    </div>
    <div class="toggle-row">
        <input type="checkbox" id="fillToggle" checked><label for="fillToggle">Fill shape</label>
    </div>
    <div class="toggle-row">
        <input type="checkbox" id="morphToggle"><label for="morphToggle">Auto morph presets</label>
    </div>
    <div class="btn-row">
        <button onclick="setPreset('circle')">Circle</button>
        <button onclick="setPreset('square')">Square</button>
        <button onclick="setPreset('triangle')">Triangle</button>
        <button onclick="setPreset('star')">Star</button>
    </div>
    <div class="btn-row">
        <button onclick="setPreset('flower')">Flower</button>
        <button onclick="setPreset('starfish')">Starfish</button>
        <button onclick="setPreset('butterfly')">Butterfly</button>
        <button onclick="setPreset('gear')">Gear</button>
    </div>
</div>
<div id="info">Gielis Superformula &mdash; one equation to generate them all</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R;
let animating = true;

const presets = {
    circle:    { m: 0,  n1: 2,   n2: 2,   n3: 2,   a: 1, b: 1 },
    square:    { m: 4,  n1: 2,   n2: 2,   n3: 2,   a: 1, b: 1 },
    triangle:  { m: 3,  n1: 4,   n2: 2,   n3: 2,   a: 1, b: 1 },
    star:      { m: 5,  n1: 0.3, n2: 0.3, n3: 0.3, a: 1, b: 1 },
    flower:    { m: 8,  n1: 0.5, n2: 1,   n3: 1,   a: 1, b: 1 },
    starfish:  { m: 5,  n1: 2,   n2: 7,   n3: 7,   a: 1, b: 1 },
    butterfly: { m: 3,  n1: 0.5, n2: 0.5, n3: 4,   a: 1, b: 1 },
    gear:      { m: 12, n1: 15,  n2: 15,  n3: 15,  a: 1, b: 1 }
};

const presetNames = Object.keys(presets);
let morphFrom = presets.circle;
let morphTo = presets.flower;
let morphT = 0;
let morphIdx = 0;

let current = { ...presets.flower };

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2; cy = H / 2;
    R = Math.min(W, H) * 0.35;
}

function superformula(theta, m, n1, n2, n3, a, b) {
    const t = m * theta / 4;
    const term1 = Math.pow(Math.abs(Math.cos(t) / a), n2);
    const term2 = Math.pow(Math.abs(Math.sin(t) / b), n3);
    const sum = term1 + term2;
    if (sum === 0) return 0;
    return Math.pow(sum, -1 / n1);
}

function computePoints(params) {
    const pts = [];
    const steps = 1000;
    for (let i = 0; i <= steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        const r = superformula(theta, params.m, params.n1, params.n2, params.n3, params.a, params.b);
        pts.push({
            x: cx + r * R * Math.cos(theta),
            y: cy + r * R * Math.sin(theta),
            theta: theta,
            r: r
        });
    }
    return pts;
}

function lerp(a, b, t) { return a + (b - a) * t; }

function lerpParams(from, to, t) {
    return {
        m: lerp(from.m, to.m, t),
        n1: lerp(from.n1, to.n1, t),
        n2: lerp(from.n2, to.n2, t),
        n3: lerp(from.n3, to.n3, t),
        a: lerp(from.a, to.a, t),
        b: lerp(from.b, to.b, t)
    };
}

function setPreset(name) {
    const p = presets[name];
    current = { ...p };
    updateSliders(p);
}

function updateSliders(p) {
    document.getElementById('mSlider').value = p.m;
    document.getElementById('mVal').textContent = p.m;
    document.getElementById('n1Slider').value = p.n1;
    document.getElementById('n1Val').textContent = p.n1;
    document.getElementById('n2Slider').value = p.n2;
    document.getElementById('n2Val').textContent = p.n2;
    document.getElementById('n3Slider').value = p.n3;
    document.getElementById('n3Val').textContent = p.n3;
    document.getElementById('aSlider').value = p.a;
    document.getElementById('aVal').textContent = p.a;
    document.getElementById('bSlider').value = p.b;
    document.getElementById('bVal').textContent = p.b;
}

function readSliders() {
    current.m  = parseFloat(document.getElementById('mSlider').value);
    current.n1 = parseFloat(document.getElementById('n1Slider').value);
    current.n2 = parseFloat(document.getElementById('n2Slider').value);
    current.n3 = parseFloat(document.getElementById('n3Slider').value);
    current.a  = parseFloat(document.getElementById('aSlider').value);
    current.b  = parseFloat(document.getElementById('bSlider').value);
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const morphing = document.getElementById('morphToggle').checked;

    if (morphing && animating) {
        morphT += 0.005;
        if (morphT >= 1) {
            morphT = 0;
            morphIdx = (morphIdx + 1) % presetNames.length;
            morphFrom = presets[presetNames[morphIdx]];
            morphTo = presets[presetNames[(morphIdx + 1) % presetNames.length]];
        }
        const ease = morphT < 0.5 ? 2 * morphT * morphT : 1 - Math.pow(-2 * morphT + 2, 2) / 2;
        current = lerpParams(morphFrom, morphTo, ease);
        updateSliders({
            m: +current.m.toFixed(1),
            n1: +current.n1.toFixed(1),
            n2: +current.n2.toFixed(1),
            n3: +current.n3.toFixed(1),
            a: +current.a.toFixed(2),
            b: +current.b.toFixed(2)
        });
    } else if (!morphing) {
        readSliders();
    }

    const pts = computePoints(current);
    const filled = document.getElementById('fillToggle').checked;

    // Filled shape with gradient
    if (filled) {
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, R);
        grad.addColorStop(0, 'rgba(100,140,255,0.25)');
        grad.addColorStop(0.5, 'rgba(138,100,255,0.15)');
        grad.addColorStop(1, 'rgba(255,100,180,0.05)');
        ctx.beginPath();
        pts.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();
    }

    // Outline with rainbow
    for (let i = 1; i < pts.length; i++) {
        ctx.beginPath();
        ctx.moveTo(pts[i - 1].x, pts[i - 1].y);
        ctx.lineTo(pts[i].x, pts[i].y);
        const hue = (i / pts.length) * 360;
        ctx.strokeStyle = `hsla(${hue}, 85%, 65%, 0.9)`;
        ctx.lineWidth = 2.5;
        ctx.stroke();
    }

    // Glow at center
    const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, R * 0.4);
    glow.addColorStop(0, 'rgba(138,170,255,0.06)');
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.fillRect(0, 0, W, H);

    requestAnimationFrame(draw);
}

['mSlider', 'n1Slider', 'n2Slider', 'n3Slider', 'aSlider', 'bSlider'].forEach(id => {
    document.getElementById(id).addEventListener('input', function() {
        const valId = id.replace('Slider', 'Val');
        document.getElementById(valId).textContent = this.value;
    });
});

document.addEventListener('keydown', function(e) {
    if (e.code === 'Space') { e.preventDefault(); animating = !animating; }
});

window.addEventListener('resize', resize);

window.reset = function() {
    setPreset('flower');
    morphT = 0;
    morphIdx = 0;
    morphFrom = presets.circle;
    morphTo = presets.flower;
    animating = true;
};

resize();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
