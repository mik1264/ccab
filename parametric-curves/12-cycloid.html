<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cycloid & Brachistochrone - Curve of Fastest Descent</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a.back:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.8);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  padding: 18px; border-radius: 12px; color: #cde; z-index: 100;
  border: 1px solid rgba(138,170,255,0.15); min-width: 210px; font-size: 0.9em;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1.05em; }
.ctrl-row { margin-bottom: 8px; }
.ctrl-row label { display: block; margin-bottom: 3px; font-size: 0.85em; color: #9ab; }
.ctrl-row select, .ctrl-row input[type=range] { width: 100%; }
select { background: #161c30; color: #cde; border: 1px solid #335; padding: 4px; border-radius: 4px; }
input[type=range] { accent-color: #8af; }
button { background: #1a2540; color: #8af; border: 1px solid #335; padding: 6px 14px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 4px; }
button:hover { background: #253060; }
#info {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(10,14,26,0.8); backdrop-filter: blur(10px);
  padding: 12px 20px; border-radius: 10px; color: #9ab; font-size: 0.82em;
  border: 1px solid rgba(138,170,255,0.1); text-align: center; max-width: 620px; z-index: 100;
}
</style>
</head>
<body>
<a href="index.html" class="back">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Cycloid & Brachistochrone</h3>
  <div class="ctrl-row">
    <label>Mode</label>
    <select id="mode">
      <option value="rolling">Rolling Wheel</option>
      <option value="brach">Brachistochrone Race</option>
      <option value="tauto">Tautochrone</option>
    </select>
  </div>
  <div class="ctrl-row">
    <label>Wheel Radius: <span id="radVal">50</span></label>
    <input type="range" id="radius" min="20" max="100" step="5" value="50">
  </div>
  <div class="ctrl-row">
    <label>Gravity: <span id="gravVal">1.0</span></label>
    <input type="range" id="gravity" min="0.2" max="3" step="0.1" value="1">
  </div>
  <div class="ctrl-row">
    <button id="resetBtn">Reset / Replay</button>
  </div>
</div>
<div id="info">
  The cycloid solves two famous problems: the <b>brachistochrone</b> (fastest descent) and the <b>tautochrone</b> (equal time from any height). Johann Bernoulli posed the brachistochrone challenge in 1696.
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
window.addEventListener('resize', resize);

const modeEl = document.getElementById('mode');
const radiusEl = document.getElementById('radius');
const gravityEl = document.getElementById('gravity');
const resetBtn = document.getElementById('resetBtn');

radiusEl.oninput = () => { document.getElementById('radVal').textContent = radiusEl.value; resetState(); };
gravityEl.oninput = () => { document.getElementById('gravVal').textContent = parseFloat(gravityEl.value).toFixed(1); resetState(); };
modeEl.onchange = resetState;
resetBtn.onclick = resetState;

let t = 0, raceT = 0, raceRunning = false;
let trail = [];

function resetState() {
  t = 0; raceT = 0; raceRunning = true; trail = [];
  ctx.clearRect(0, 0, W, H);
}

// Cycloid point: x = r(t - sin t), y = r(1 - cos t)
function cycloidPt(r, param) {
  return { x: r * (param - Math.sin(param)), y: r * (1 - Math.cos(param)) };
}

function drawRolling() {
  const r = parseInt(radiusEl.value);
  const cx = 80;
  const cy = H * 0.35;

  t += 0.02;
  if (t > Math.PI * 6) t = 0;

  // Ground line
  ctx.beginPath();
  ctx.moveTo(0, cy + r);
  ctx.lineTo(W, cy + r);
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Trail
  const pt = cycloidPt(r, t);
  trail.push({ x: cx + pt.x, y: cy + pt.y });
  if (trail.length > 2000) trail.shift();

  ctx.beginPath();
  for (let i = 0; i < trail.length; i++) {
    const p = trail[i];
    i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
  }
  ctx.strokeStyle = '#ff6644';
  ctx.lineWidth = 2.5;
  ctx.shadowColor = '#ff6644';
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Full cycloid curve (faint)
  ctx.beginPath();
  for (let i = 0; i <= 600; i++) {
    const param = (i / 600) * Math.PI * 6;
    const p = cycloidPt(r, param);
    i === 0 ? ctx.moveTo(cx + p.x, cy + p.y) : ctx.lineTo(cx + p.x, cy + p.y);
  }
  ctx.strokeStyle = 'rgba(255,102,68,0.15)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Wheel
  const wheelCx = cx + r * t;
  const wheelCy = cy;
  ctx.beginPath();
  ctx.arc(wheelCx, wheelCy, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(130,170,255,0.4)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Spokes
  for (let i = 0; i < 6; i++) {
    const a = t + (i / 6) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(wheelCx, wheelCy);
    ctx.lineTo(wheelCx + r * Math.cos(a), wheelCy + r * Math.sin(a));
    ctx.strokeStyle = 'rgba(130,170,255,0.15)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Tracing point
  const tracePt = { x: cx + pt.x, y: cy + pt.y };
  ctx.beginPath();
  ctx.arc(tracePt.x, tracePt.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#ff6644';
  ctx.shadowColor = '#ff6644';
  ctx.shadowBlur = 15;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Line from center to tracing point
  ctx.beginPath();
  ctx.moveTo(wheelCx, wheelCy);
  ctx.lineTo(tracePt.x, tracePt.y);
  ctx.strokeStyle = 'rgba(255,102,68,0.5)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = '#8af';
  ctx.font = 'bold 16px "Segoe UI", sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('x = r(t - sin t),  y = r(1 - cos t)', W / 2, H * 0.78);
}

function drawBrach() {
  const g = parseFloat(gravityEl.value);
  raceT += 0.005 * g;

  const startX = W * 0.1, startY = H * 0.15;
  const endX = W * 0.75, endY = H * 0.7;
  const dx = endX - startX, dy = endY - startY;

  // Fit cycloid: one arch from (startX,startY) to (endX,endY)
  const r = dy / 2;
  const cycloidWidth = r * Math.PI;
  const scaleX = dx / cycloidWidth;

  // Draw straight line path
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.strokeStyle = 'rgba(255,80,80,0.4)';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Draw cycloid path (inverted)
  ctx.beginPath();
  for (let i = 0; i <= 200; i++) {
    const param = (i / 200) * Math.PI;
    const cx = startX + scaleX * r * (param - Math.sin(param));
    const cy = startY + r * (1 - Math.cos(param));
    i === 0 ? ctx.moveTo(cx, cy) : ctx.lineTo(cx, cy);
  }
  ctx.strokeStyle = 'rgba(100,200,255,0.5)';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Ball on straight line
  const lineFrac = Math.min(raceT / 2.2, 1);
  // Gravity on an incline: acceleration = g*sin(angle), normalized
  const angle = Math.atan2(dy, dx);
  const straightDist = Math.sqrt(dx * dx + dy * dy);
  const straightAccel = 9.8 * g * Math.sin(angle);
  const straightTime = Math.sqrt(2 * straightDist / straightAccel);
  const straightFrac = Math.min((raceT * 3) / straightTime, 1);
  const straightPos = 0.5 * straightAccel * Math.pow(Math.min(raceT * 3, straightTime), 2) / straightDist;
  const sp = Math.min(straightPos, 1);

  const lbx = startX + sp * dx;
  const lby = startY + sp * dy;
  ctx.beginPath();
  ctx.arc(lbx, lby, 10, 0, Math.PI * 2);
  ctx.fillStyle = '#ff4444';
  ctx.shadowColor = '#ff4444';
  ctx.shadowBlur = 15;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Ball on cycloid (brachistochrone is faster!)
  // Time for cycloid is T = pi * sqrt(r/g)
  const cycloidTime = Math.PI * Math.sqrt(r / (9.8 * g));
  const cf = Math.min((raceT * 3) / cycloidTime, 1);
  const cparam = cf * Math.PI;
  const cbx = startX + scaleX * r * (cparam - Math.sin(cparam));
  const cby = startY + r * (1 - Math.cos(cparam));

  ctx.beginPath();
  ctx.arc(cbx, cby, 10, 0, Math.PI * 2);
  ctx.fillStyle = '#44aaff';
  ctx.shadowColor = '#44aaff';
  ctx.shadowBlur = 15;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Labels
  ctx.fillStyle = '#ff6666';
  ctx.font = '14px "Segoe UI", sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Straight line (slower!)', startX, startY - 15);
  ctx.fillStyle = '#66bbff';
  ctx.fillText('Cycloid (fastest descent!)', startX, startY - 35);

  // Start/End markers
  ctx.beginPath();
  ctx.arc(startX, startY, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.fillStyle = '#aaa';
  ctx.font = '13px sans-serif';
  ctx.fillText('A', startX - 15, startY + 5);

  ctx.beginPath();
  ctx.arc(endX, endY, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.fillText('B', endX + 10, endY + 5);

  // Winner text
  if (cf >= 1 && sp < 1) {
    ctx.fillStyle = '#44aaff';
    ctx.font = 'bold 20px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Cycloid wins! The brachistochrone is the fastest path.', W / 2, H * 0.88);
  }
}

function drawTauto() {
  const g = parseFloat(gravityEl.value);
  raceT += 0.004 * g;

  const cx = W * 0.5, topY = H * 0.12;
  const r = Math.min(W * 0.25, H * 0.3);

  // Draw inverted cycloid
  ctx.beginPath();
  for (let i = 0; i <= 200; i++) {
    const param = (i / 200) * Math.PI * 2 - Math.PI;
    const px = cx + r * (param - Math.sin(param)) * 0.5;
    const py = topY + r * (1 - Math.cos(param)) * 0.5;
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.strokeStyle = 'rgba(130,220,180,0.4)';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Multiple balls starting from different heights
  const numBalls = 5;
  const tautoPeriod = Math.PI * Math.sqrt(r * 0.5 / (9.8 * g));
  const colors = ['#ff4466', '#ffaa22', '#44ff88', '#44aaff', '#cc66ff'];

  for (let b = 0; b < numBalls; b++) {
    // Start at different positions along the cycloid
    const startFrac = 0.1 + (b / (numBalls - 1)) * 0.4; // 0.1 to 0.5
    const startParam = -Math.PI + startFrac * Math.PI * 2;

    // All reach bottom (param=0) at the same time regardless of start!
    const frac = Math.min(raceT * 3 / tautoPeriod, 1);
    const currentParam = startParam + (0 - startParam) * (1 - Math.cos(frac * Math.PI / 2));

    // If past bottom, reflect
    let drawParam = currentParam;
    if (frac >= 1) {
      const excess = (raceT * 3 / tautoPeriod - 1);
      drawParam = Math.sin(excess * Math.PI) * startParam * 0.3;
    }

    const bx = cx + r * (drawParam - Math.sin(drawParam)) * 0.5;
    const by = topY + r * (1 - Math.cos(drawParam)) * 0.5;

    ctx.beginPath();
    ctx.arc(bx, by, 8, 0, Math.PI * 2);
    ctx.fillStyle = colors[b];
    ctx.shadowColor = colors[b];
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Bottom marker
  const bottomX = cx + r * (0 - Math.sin(0)) * 0.5;
  const bottomY = topY + r * (1 - Math.cos(0)) * 0.5;
  ctx.beginPath();
  ctx.arc(bottomX, bottomY, 4, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fill();

  ctx.fillStyle = '#8af';
  ctx.font = 'bold 16px "Segoe UI", sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Tautochrone: All balls reach the bottom at the SAME time!', W / 2, H * 0.85);
  ctx.fillStyle = '#6a8';
  ctx.font = '13px "Segoe UI", sans-serif';
  ctx.fillText('Each ball starts from a different height on the inverted cycloid', W / 2, H * 0.89);
}

function animate() {
  ctx.fillStyle = 'rgba(10,14,26,0.2)';
  ctx.fillRect(0, 0, W, H);

  const mode = modeEl.value;
  if (mode === 'rolling') drawRolling();
  else if (mode === 'brach') drawBrach();
  else if (mode === 'tauto') drawTauto();

  requestAnimationFrame(animate);
}

window.reset = function() { resetState(); };
resetState();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
