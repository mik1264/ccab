<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cardioid & Nephroid - Heart-Shaped Caustics</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a.back:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.8);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  padding: 18px; border-radius: 12px; color: #cde; z-index: 100;
  border: 1px solid rgba(138,170,255,0.15); min-width: 210px; font-size: 0.9em;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1.05em; }
.ctrl-row { margin-bottom: 8px; }
.ctrl-row label { display: block; margin-bottom: 3px; font-size: 0.85em; color: #9ab; }
.ctrl-row select, .ctrl-row input[type=range] { width: 100%; }
select { background: #161c30; color: #cde; border: 1px solid #335; padding: 4px; border-radius: 4px; }
input[type=range] { accent-color: #8af; }
.ctrl-row .cb { display: flex; align-items: center; gap: 6px; }
.ctrl-row .cb input { accent-color: #8af; }
#info {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(10,14,26,0.8); backdrop-filter: blur(10px);
  padding: 12px 20px; border-radius: 10px; color: #9ab; font-size: 0.82em;
  border: 1px solid rgba(138,170,255,0.1); text-align: center; max-width: 600px; z-index: 100;
}
</style>
</head>
<body>
<a href="index.html" class="back">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Cardioid & Nephroid</h3>
  <div class="ctrl-row">
    <label>Curve</label>
    <select id="curveType">
      <option value="cardioid">Cardioid</option>
      <option value="nephroid">Nephroid</option>
      <option value="both">Both</option>
    </select>
  </div>
  <div class="ctrl-row">
    <label>Speed: <span id="speedVal">1.0</span></label>
    <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
  </div>
  <div class="ctrl-row">
    <label>Rays: <span id="rayVal">60</span></label>
    <input type="range" id="rays" min="10" max="200" step="5" value="60">
  </div>
  <div class="ctrl-row">
    <div class="cb"><input type="checkbox" id="showRays" checked><label>Show Caustic Rays</label></div>
  </div>
  <div class="ctrl-row">
    <label>Color Scheme</label>
    <select id="colorScheme">
      <option value="warm">Warm (Red/Gold)</option>
      <option value="cool">Cool (Blue/Cyan)</option>
      <option value="neon">Neon (Pink/Green)</option>
    </select>
  </div>
</div>
<div id="info">
  The cardioid appears in coffee cups as light reflects inside the circular rim.
  It is also the main bulb boundary of the Mandelbrot set!
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
window.addEventListener('resize', resize);

const speedEl = document.getElementById('speed');
const raysEl = document.getElementById('rays');
const curveEl = document.getElementById('curveType');
const showRaysEl = document.getElementById('showRays');
const colorEl = document.getElementById('colorScheme');

speedEl.oninput = () => document.getElementById('speedVal').textContent = parseFloat(speedEl.value).toFixed(1);
raysEl.oninput = () => document.getElementById('rayVal').textContent = raysEl.value;

const schemes = {
  warm: { curve1: '#ff4466', curve2: '#ffaa22', rolling: '#ff6644', rays: 'rgba(255,170,60,0.15)', glow1: '#ff4466', glow2: '#ffaa22' },
  cool: { curve1: '#44aaff', curve2: '#22ffcc', rolling: '#4488ff', rays: 'rgba(60,180,255,0.15)', glow1: '#44aaff', glow2: '#22ffcc' },
  neon: { curve1: '#ff44cc', curve2: '#44ff88', rolling: '#ff66aa', rays: 'rgba(255,100,200,0.15)', glow1: '#ff44cc', glow2: '#44ff88' }
};

let t = 0;

function getColors() { return schemes[colorEl.value] || schemes.warm; }

function drawMirrorCircle(cx, cy, r, col) {
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function drawPolarCurve(cx, cy, scale, type, col, phase) {
  ctx.beginPath();
  for (let i = 0; i <= 720; i++) {
    const theta = (i / 720) * Math.PI * 2;
    let r;
    if (type === 'cardioid') r = scale * (1 + Math.cos(theta));
    else r = scale * (1 + 2 * Math.cos(theta)); // nephroid-like in polar
    const x = cx + r * Math.cos(theta);
    const y = cy + r * Math.sin(theta);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.strokeStyle = col;
  ctx.lineWidth = 2.5;
  ctx.shadowColor = col;
  ctx.shadowBlur = 15;
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function drawRollingCircle(cx, cy, R, rRatio, col, curveCol, phase) {
  const r = R * rRatio;
  // Rolling circle center
  const angle = phase;
  const ocx = cx + (R + r) * Math.cos(angle);
  const ocy = cy + (R + r) * Math.sin(angle);
  // Draw base circle
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.stroke();
  // Draw rolling circle
  ctx.beginPath();
  ctx.arc(ocx, ocy, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 1.2;
  ctx.stroke();
  // Tracing point
  const ptAngle = angle * (R + r) / r;
  const px = ocx + r * Math.cos(ptAngle);
  const py = ocy + r * Math.sin(ptAngle);
  ctx.beginPath();
  ctx.arc(px, py, 4, 0, Math.PI * 2);
  ctx.fillStyle = col;
  ctx.shadowColor = col;
  ctx.shadowBlur = 12;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Draw trail
  ctx.beginPath();
  for (let i = 0; i <= 500; i++) {
    const a = (i / 500) * phase;
    const tcx = cx + (R + r) * Math.cos(a);
    const tcy = cy + (R + r) * Math.sin(a);
    const ta = a * (R + r) / r;
    const tx = tcx + r * Math.cos(ta);
    const ty = tcy + r * Math.sin(ta);
    i === 0 ? ctx.moveTo(tx, ty) : ctx.lineTo(tx, ty);
  }
  ctx.strokeStyle = curveCol;
  ctx.lineWidth = 2;
  ctx.shadowColor = curveCol;
  ctx.shadowBlur = 10;
  ctx.stroke();
  ctx.shadowBlur = 0;
  // Line from rolling center to point
  ctx.beginPath();
  ctx.moveTo(ocx, ocy);
  ctx.lineTo(px, py);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawCausticRays(cx, cy, R, numRays, type, rayCol, curveCol, phase) {
  const maxRay = Math.min(numRays, Math.floor(phase * numRays / (Math.PI * 2)));
  for (let i = 0; i < maxRay; i++) {
    const theta = (i / numRays) * Math.PI * 2;
    // Light ray comes from the left (parallel)
    const hx = cx + R * Math.cos(theta);
    const hy = cy + R * Math.sin(theta);
    // Reflect off circle: incident is horizontal, normal is radial
    const nx = Math.cos(theta), ny = Math.sin(theta);
    let dx, dy;
    if (type === 'cardioid') {
      // Point source at (-R, 0) relative to center
      const sx = cx - R, sy = cy;
      dx = hx - sx; dy = hy - sy;
      const len = Math.sqrt(dx * dx + dy * dy);
      dx /= len; dy /= len;
    } else {
      // Parallel rays from left
      dx = 1; dy = 0;
    }
    // Reflect: d - 2(d.n)n
    const dot = dx * nx + dy * ny;
    const rx = dx - 2 * dot * nx;
    const ry = dy - 2 * dot * ny;
    // Draw incident ray
    ctx.beginPath();
    if (type === 'cardioid') {
      ctx.moveTo(cx - R, cy);
    } else {
      ctx.moveTo(hx - R * 1.5, hy);
    }
    ctx.lineTo(hx, hy);
    ctx.strokeStyle = showRaysEl.checked ? rayCol : 'transparent';
    ctx.lineWidth = 0.6;
    ctx.stroke();
    // Draw reflected ray
    ctx.beginPath();
    ctx.moveTo(hx, hy);
    ctx.lineTo(hx + rx * R * 2, hy + ry * R * 2);
    ctx.strokeStyle = showRaysEl.checked ? rayCol : 'transparent';
    ctx.lineWidth = 0.6;
    ctx.stroke();
  }
}

function drawLabel(x, y, text) {
  ctx.fillStyle = 'rgba(200,220,240,0.5)';
  ctx.font = '13px "Segoe UI", Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(text, x, y);
}

function animate() {
  const spd = parseFloat(speedEl.value);
  const numRays = parseInt(raysEl.value);
  const type = curveEl.value;
  const colors = getColors();

  t += 0.008 * spd;
  const phase = t % (Math.PI * 2 + 1);
  const loopPhase = t % (Math.PI * 2);

  ctx.fillStyle = 'rgba(10,14,26,0.15)';
  ctx.fillRect(0, 0, W, H);

  const colW = W / 3;
  const cy = H * 0.48;
  const baseR = Math.min(colW * 0.3, H * 0.22);

  function renderCurve(curveType, col1, col2) {
    // Left: rolling circle
    const lx = colW * 0.5;
    const rRatio = curveType === 'cardioid' ? 1 : 0.5;
    drawRollingCircle(lx, cy, baseR * 0.6, rRatio, col1, col2, loopPhase);
    drawLabel(lx, cy + baseR * 1.4, curveType === 'cardioid' ? 'Rolling Circle (R=r)' : 'Rolling Circle (R=2r)');

    // Center: polar curve
    const mcx = colW * 1.5;
    const pScale = baseR * (curveType === 'cardioid' ? 0.45 : 0.28);
    drawPolarCurve(mcx, cy, pScale, curveType, col2, loopPhase);
    drawLabel(mcx, cy + baseR * 1.4, curveType === 'cardioid' ? 'r = 1 + cos(theta)' : 'Nephroid Polar');

    // Right: caustic rays
    const rcx = colW * 2.5;
    drawMirrorCircle(rcx, cy, baseR * 0.75);
    drawCausticRays(rcx, cy, baseR * 0.75, numRays, curveType, colors.rays, col2, loopPhase + Math.PI * 2 * 2);
    drawLabel(rcx, cy + baseR * 1.4, curveType === 'cardioid' ? 'Point Source Caustic' : 'Parallel Ray Caustic');
  }

  if (type === 'cardioid' || type === 'both') {
    renderCurve('cardioid', colors.glow1, colors.curve1);
  }
  if (type === 'nephroid' || type === 'both') {
    if (type === 'both') {
      ctx.globalAlpha = 0.6;
    }
    renderCurve('nephroid', colors.glow2, colors.curve2);
    ctx.globalAlpha = 1;
  }

  // Title
  ctx.fillStyle = 'rgba(200,220,240,0.3)';
  ctx.font = 'bold 15px "Segoe UI", Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Rolling Circle', colW * 0.5, 60);
  ctx.fillText('Polar Equation', colW * 1.5, 60);
  ctx.fillText('Reflected Rays (Caustic)', colW * 2.5, 60);

  requestAnimationFrame(animate);
}

window.reset = function() {
  t = 0;
  ctx.clearRect(0, 0, W, H);
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
