<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activation Function Explorer - Neural Network Playgrounds</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e8e6e1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .back-link {
            color: #fbbf24;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-4px);
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .function-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .function-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .function-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fbbf24;
        }

        .function-formula {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #9ca3af;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
        }

        canvas {
            width: 100%;
            height: 200px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .function-info {
            margin-top: 15px;
            font-size: 13px;
            line-height: 1.6;
            color: #9ca3af;
        }

        .function-info strong {
            color: #e8e6e1;
        }

        .properties {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .property-tag {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
        }

        .tag-good {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .tag-warning {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .tag-neutral {
            background: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
        }

        .comparison-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .comparison-section h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #fbbf24;
        }

        #comparisonCanvas {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .input-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .input-section label {
            font-size: 14px;
            color: #9ca3af;
        }

        .input-section input[type="range"] {
            flex: 1;
            min-width: 200px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .input-section input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            font-family: 'Courier New', monospace;
            color: #fbbf24;
            min-width: 100px;
        }

        @media (max-width: 500px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">
                <span>←</span> Back to Gallery
            </a>
            <h1>Activation Function Explorer</h1>
        </header>

        <div class="grid" id="functionsGrid"></div>

        <div class="comparison-section">
            <h2>Side-by-Side Comparison</h2>
            <canvas id="comparisonCanvas"></canvas>
            <div class="legend" id="legend"></div>
            <div class="input-section">
                <label>Test Input (x):</label>
                <input type="range" id="inputValue" min="-5" max="5" step="0.1" value="0">
                <div class="value-display" id="inputDisplay">x = 0.0</div>
            </div>
        </div>
    </div>

    <script>
        const activationFunctions = [
            {
                name: 'Sigmoid',
                formula: 'σ(x) = 1 / (1 + e^(-x))',
                fn: x => 1 / (1 + Math.exp(-x)),
                derivative: x => {
                    const s = 1 / (1 + Math.exp(-x));
                    return s * (1 - s);
                },
                color: '#3b82f6',
                range: [0, 1],
                info: 'Classic activation that squashes values between 0 and 1. Historically popular but suffers from vanishing gradients.',
                properties: [
                    { text: 'Smooth', type: 'good' },
                    { text: 'Bounded [0,1]', type: 'neutral' },
                    { text: 'Vanishing Gradient', type: 'warning' },
                    { text: 'Not Zero-Centered', type: 'warning' }
                ]
            },
            {
                name: 'Tanh',
                formula: 'tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))',
                fn: x => Math.tanh(x),
                derivative: x => 1 - Math.pow(Math.tanh(x), 2),
                color: '#8b5cf6',
                range: [-1, 1],
                info: 'Zero-centered version of sigmoid. Better than sigmoid but still has vanishing gradient problem.',
                properties: [
                    { text: 'Smooth', type: 'good' },
                    { text: 'Zero-Centered', type: 'good' },
                    { text: 'Bounded [-1,1]', type: 'neutral' },
                    { text: 'Vanishing Gradient', type: 'warning' }
                ]
            },
            {
                name: 'ReLU',
                formula: 'ReLU(x) = max(0, x)',
                fn: x => Math.max(0, x),
                derivative: x => x > 0 ? 1 : 0,
                color: '#10b981',
                range: [0, Infinity],
                info: 'Most widely used activation. Fast to compute, helps with vanishing gradient. Can suffer from "dying ReLU" problem.',
                properties: [
                    { text: 'Fast Computation', type: 'good' },
                    { text: 'No Vanishing Gradient', type: 'good' },
                    { text: 'Dying ReLU', type: 'warning' },
                    { text: 'Not Zero-Centered', type: 'warning' }
                ]
            },
            {
                name: 'Leaky ReLU',
                formula: 'LeakyReLU(x) = max(0.01x, x)',
                fn: x => x > 0 ? x : 0.01 * x,
                derivative: x => x > 0 ? 1 : 0.01,
                color: '#f59e0b',
                range: [-Infinity, Infinity],
                info: 'Addresses the dying ReLU problem by allowing small negative gradients when x < 0.',
                properties: [
                    { text: 'Fast Computation', type: 'good' },
                    { text: 'No Dying Neurons', type: 'good' },
                    { text: 'Unbounded', type: 'neutral' }
                ]
            },
            {
                name: 'ELU',
                formula: 'ELU(x) = x if x > 0, α(e^x - 1) otherwise',
                fn: x => x > 0 ? x : 1.0 * (Math.exp(x) - 1),
                derivative: x => x > 0 ? 1 : 1.0 * Math.exp(x),
                color: '#ec4899',
                range: [-1, Infinity],
                info: 'Exponential Linear Unit. Smooth, with negative values that push mean closer to zero.',
                properties: [
                    { text: 'Smooth', type: 'good' },
                    { text: 'Near Zero-Centered', type: 'good' },
                    { text: 'Slower Than ReLU', type: 'warning' }
                ]
            },
            {
                name: 'GELU',
                formula: 'GELU(x) = x · Φ(x)',
                fn: x => x * 0.5 * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3)))),
                derivative: x => {
                    const cdf = 0.5 * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3))));
                    const pdf = Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
                    return cdf + x * pdf;
                },
                color: '#06b6d4',
                range: [-0.17, Infinity],
                info: 'Gaussian Error Linear Unit. Used in BERT, GPT-2, GPT-3. Smooth approximation of dropout.',
                properties: [
                    { text: 'Smooth', type: 'good' },
                    { text: 'State-of-the-Art', type: 'good' },
                    { text: 'Stochastic Regularization', type: 'good' }
                ]
            },
            {
                name: 'Swish',
                formula: 'Swish(x) = x · σ(x)',
                fn: x => x / (1 + Math.exp(-x)),
                derivative: x => {
                    const s = 1 / (1 + Math.exp(-x));
                    return s + x * s * (1 - s);
                },
                color: '#f97316',
                range: [-0.28, Infinity],
                info: 'Self-gated activation discovered through NAS. Outperforms ReLU on deep networks.',
                properties: [
                    { text: 'Smooth', type: 'good' },
                    { text: 'Self-Gating', type: 'good' },
                    { text: 'Non-Monotonic', type: 'neutral' }
                ]
            },
            {
                name: 'Softplus',
                formula: 'Softplus(x) = ln(1 + e^x)',
                fn: x => Math.log(1 + Math.exp(x)),
                derivative: x => 1 / (1 + Math.exp(-x)),
                color: '#84cc16',
                range: [0, Infinity],
                info: 'Smooth approximation of ReLU. Derivative is the sigmoid function.',
                properties: [
                    { text: 'Smooth', type: 'good' },
                    { text: 'ReLU Approximation', type: 'neutral' },
                    { text: 'Never Exactly Zero', type: 'neutral' }
                ]
            }
        ];

        // Draw individual function cards
        const grid = document.getElementById('functionsGrid');
        const legend = document.getElementById('legend');

        activationFunctions.forEach((func, index) => {
            // Create card
            const card = document.createElement('div');
            card.className = 'function-card';
            card.innerHTML = `
                <div class="function-header">
                    <span class="function-name">${func.name}</span>
                    <span class="function-formula">${func.formula}</span>
                </div>
                <canvas id="canvas-${index}"></canvas>
                <div class="function-info">
                    ${func.info}
                    <div class="properties">
                        ${func.properties.map(p => `<span class="property-tag tag-${p.type}">${p.text}</span>`).join('')}
                    </div>
                </div>
            `;
            grid.appendChild(card);

            // Draw function
            drawFunction(`canvas-${index}`, func);

            // Add to legend
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `
                <div class="legend-color" style="background: ${func.color};"></div>
                <span>${func.name}</span>
            `;
            legend.appendChild(legendItem);
        });

        function drawFunction(canvasId, func) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const padding = 30;

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = padding; x <= width - padding; x += (width - 2 * padding) / 10) {
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = padding; y <= height - padding; y += (height - 2 * padding) / 8) {
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;

            // X axis (y = 0)
            const yZero = height / 2;
            ctx.beginPath();
            ctx.moveTo(padding, yZero);
            ctx.lineTo(width - padding, yZero);
            ctx.stroke();

            // Y axis (x = 0)
            const xZero = width / 2;
            ctx.beginPath();
            ctx.moveTo(xZero, padding);
            ctx.lineTo(xZero, height - padding);
            ctx.stroke();

            // Draw function
            ctx.strokeStyle = func.color;
            ctx.lineWidth = 3;
            ctx.beginPath();

            const xRange = [-5, 5];
            const yRange = [-2, 3];

            for (let px = padding; px <= width - padding; px++) {
                const x = xRange[0] + (px - padding) / (width - 2 * padding) * (xRange[1] - xRange[0]);
                let y = func.fn(x);
                y = Math.max(yRange[0], Math.min(yRange[1], y));

                const py = height - padding - (y - yRange[0]) / (yRange[1] - yRange[0]) * (height - 2 * padding);

                if (px === padding) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();

            // Draw derivative (dashed)
            ctx.strokeStyle = func.color;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();

            for (let px = padding; px <= width - padding; px++) {
                const x = xRange[0] + (px - padding) / (width - 2 * padding) * (xRange[1] - xRange[0]);
                let y = func.derivative(x);
                y = Math.max(yRange[0], Math.min(yRange[1], y));

                const py = height - padding - (y - yRange[0]) / (yRange[1] - yRange[0]) * (height - 2 * padding);

                if (px === padding) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('-5', padding, height - 10);
            ctx.fillText('5', width - padding, height - 10);
            ctx.fillText('0', xZero, height - 10);

            ctx.textAlign = 'right';
            ctx.fillText('f(x)', padding - 5, padding + 5);
            ctx.fillText("f'(x) --", width - padding + 5, padding + 15);
        }

        // Comparison canvas
        function drawComparison(inputX) {
            const canvas = document.getElementById('comparisonCanvas');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const padding = 40;

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            for (let x = padding; x <= width - padding; x += (width - 2 * padding) / 10) {
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            for (let y = padding; y <= height - padding; y += (height - 2 * padding) / 6) {
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;

            const yZero = height - padding - (0 - (-2)) / (3 - (-2)) * (height - 2 * padding);
            ctx.beginPath();
            ctx.moveTo(padding, yZero);
            ctx.lineTo(width - padding, yZero);
            ctx.stroke();

            const xZero = padding + (0 - (-5)) / (5 - (-5)) * (width - 2 * padding);
            ctx.beginPath();
            ctx.moveTo(xZero, padding);
            ctx.lineTo(xZero, height - padding);
            ctx.stroke();

            // Draw all functions
            const xRange = [-5, 5];
            const yRange = [-2, 3];

            activationFunctions.forEach(func => {
                ctx.strokeStyle = func.color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let px = padding; px <= width - padding; px++) {
                    const x = xRange[0] + (px - padding) / (width - 2 * padding) * (xRange[1] - xRange[0]);
                    let y = func.fn(x);
                    y = Math.max(yRange[0], Math.min(yRange[1], y));

                    const py = height - padding - (y - yRange[0]) / (yRange[1] - yRange[0]) * (height - 2 * padding);

                    if (px === padding) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            });

            // Draw vertical line at input
            const inputPx = padding + (inputX - xRange[0]) / (xRange[1] - xRange[0]) * (width - 2 * padding);
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(inputPx, padding);
            ctx.lineTo(inputPx, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw output points
            activationFunctions.forEach(func => {
                let y = func.fn(inputX);
                y = Math.max(yRange[0], Math.min(yRange[1], y));

                const py = height - padding - (y - yRange[0]) / (yRange[1] - yRange[0]) * (height - 2 * padding);

                ctx.fillStyle = func.color;
                ctx.beginPath();
                ctx.arc(inputPx, py, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('-5', padding, height - 15);
            ctx.fillText('0', xZero, height - 15);
            ctx.fillText('5', width - padding, height - 15);

            ctx.textAlign = 'right';
            ctx.fillText('-2', padding - 5, height - padding);
            ctx.fillText('0', padding - 5, yZero + 4);
            ctx.fillText('3', padding - 5, padding + 10);
        }

        // Input slider
        const inputSlider = document.getElementById('inputValue');
        const inputDisplay = document.getElementById('inputDisplay');

        function updateComparison() {
            const x = parseFloat(inputSlider.value);
            inputDisplay.innerHTML = `x = ${x.toFixed(1)}<br>` +
                activationFunctions.map(f => `${f.name}: ${f.fn(x).toFixed(3)}`).join('<br>');
            drawComparison(x);
        }

        inputSlider.addEventListener('input', updateComparison);

        // Initial draw
        updateComparison();

        // Expose for enhance.js
        window.reset = updateComparison;

        // Redraw on resize
        window.addEventListener('resize', () => {
            activationFunctions.forEach((func, index) => {
                drawFunction(`canvas-${index}`, func);
            });
            updateComparison();
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
