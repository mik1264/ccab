<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backpropagation Flow - Neural Network Playgrounds</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e8e6e1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .back-link {
            color: #fbbf24;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-4px);
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #canvas {
            width: 100%;
            height: 500px;
            border-radius: 12px;
        }

        .phase-indicator {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .phase {
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .phase-forward {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .phase-forward.active {
            background: #3b82f6;
            color: white;
        }

        .phase-backward {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .phase-backward.active {
            background: #ef4444;
            color: white;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: #1a1a2e;
            font-weight: 600;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e8e6e1;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #9ca3af;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: #9ca3af;
        }

        .stat-value {
            color: #fbbf24;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
            line-height: 1.5;
            color: #9ca3af;
        }

        .legend {
            margin-top: 20px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .legend-title {
            font-size: 12px;
            color: #9ca3af;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .gradient-bar {
            height: 20px;
            border-radius: 4px;
            background: linear-gradient(to right, #3b82f6, #fbbf24, #ef4444);
            margin-bottom: 4px;
        }

        .gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #9ca3af;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">
                <span>←</span> Back to Gallery
            </a>
            <h1>Backpropagation Flow</h1>
        </header>

        <div class="main-content">
            <div class="visualization">
                <canvas id="canvas"></canvas>
                <div class="phase-indicator">
                    <div class="phase phase-forward" id="forwardPhase">Forward Pass →</div>
                    <div class="phase phase-backward" id="backwardPhase">← Backward Pass</div>
                </div>
            </div>

            <div class="controls">
                <div class="button-group">
                    <button class="btn-primary" id="stepBtn">Step</button>
                    <button class="btn-primary" id="playBtn">Play</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Animation Speed</label>
                    <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>Learning Rate: <span id="lrValue">0.5</span></label>
                    <input type="range" id="learningRate" min="0.1" max="2" step="0.1" value="0.5">
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Epoch</span>
                        <span class="stat-value" id="epoch">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Input</span>
                        <span class="stat-value" id="input">[1, 0]</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Target</span>
                        <span class="stat-value" id="target">1</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Output</span>
                        <span class="stat-value" id="output">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Loss (MSE)</span>
                        <span class="stat-value" id="loss">-</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Backpropagation</strong> computes gradients by the chain rule, flowing errors backward through the network.<br><br>
                    <strong>Blue</strong> = Forward pass (activations)<br>
                    <strong>Red</strong> = Backward pass (gradients)<br><br>
                    Watch how gradients propagate and weights update!
                </div>

                <div class="legend">
                    <div class="legend-title">Gradient Magnitude</div>
                    <div class="gradient-bar"></div>
                    <div class="gradient-labels">
                        <span>Low</span>
                        <span>High</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simple neural network for XOR
        const network = {
            // Layer sizes: 2 -> 3 -> 1
            weights: [
                // Hidden layer (2x3)
                [[0.5, -0.5], [0.3, 0.3], [-0.2, 0.4]],
                // Output layer (3x1)
                [[0.4], [-0.3], [0.5]]
            ],
            biases: [
                [0.1, -0.1, 0.2],
                [0.0]
            ],
            // Activations
            a: [[], [], []],
            z: [[], [], []],
            // Gradients
            dw: [[], []],
            db: [[], []],
            delta: [[], []]
        };

        // XOR training data
        const trainingData = [
            { input: [0, 0], target: 0 },
            { input: [0, 1], target: 1 },
            { input: [1, 0], target: 1 },
            { input: [1, 1], target: 0 }
        ];

        let currentSample = 0;
        let phase = 'idle'; // idle, forward, backward, update
        let animationProgress = 0;
        let playing = false;
        let speed = 1;
        let learningRate = 0.5;
        let epoch = 0;

        // Activation function
        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        function sigmoidDerivative(x) {
            const s = sigmoid(x);
            return s * (1 - s);
        }

        // Forward pass
        function forward(input) {
            network.a[0] = input;

            // Hidden layer
            network.z[1] = [];
            network.a[1] = [];
            for (let j = 0; j < 3; j++) {
                let sum = network.biases[0][j];
                for (let i = 0; i < 2; i++) {
                    sum += network.weights[0][j][i] * input[i];
                }
                network.z[1][j] = sum;
                network.a[1][j] = sigmoid(sum);
            }

            // Output layer
            network.z[2] = [];
            network.a[2] = [];
            let sum = network.biases[1][0];
            for (let j = 0; j < 3; j++) {
                sum += network.weights[1][j][0] * network.a[1][j];
            }
            network.z[2][0] = sum;
            network.a[2][0] = sigmoid(sum);

            return network.a[2][0];
        }

        // Backward pass
        function backward(target) {
            const output = network.a[2][0];

            // Output layer gradient
            const outputError = output - target;
            network.delta[1] = [outputError * sigmoidDerivative(network.z[2][0])];

            // Hidden layer gradients
            network.delta[0] = [];
            for (let j = 0; j < 3; j++) {
                const error = network.weights[1][j][0] * network.delta[1][0];
                network.delta[0][j] = error * sigmoidDerivative(network.z[1][j]);
            }

            // Compute weight gradients
            // Output layer
            network.dw[1] = [];
            for (let j = 0; j < 3; j++) {
                network.dw[1][j] = [network.delta[1][0] * network.a[1][j]];
            }
            network.db[1] = [network.delta[1][0]];

            // Hidden layer
            network.dw[0] = [];
            for (let j = 0; j < 3; j++) {
                network.dw[0][j] = [];
                for (let i = 0; i < 2; i++) {
                    network.dw[0][j][i] = network.delta[0][j] * network.a[0][i];
                }
            }
            network.db[0] = network.delta[0].slice();
        }

        // Update weights
        function updateWeights() {
            // Hidden layer
            for (let j = 0; j < 3; j++) {
                for (let i = 0; i < 2; i++) {
                    network.weights[0][j][i] -= learningRate * network.dw[0][j][i];
                }
                network.biases[0][j] -= learningRate * network.db[0][j];
            }

            // Output layer
            for (let j = 0; j < 3; j++) {
                network.weights[1][j][0] -= learningRate * network.dw[1][j][0];
            }
            network.biases[1][0] -= learningRate * network.db[1][0];
        }

        // Drawing
        function draw() {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Layer positions
            const layers = [
                { size: 2, x: width * 0.15, label: 'Input' },
                { size: 3, x: width * 0.5, label: 'Hidden' },
                { size: 1, x: width * 0.85, label: 'Output' }
            ];

            // Calculate neuron positions
            const neurons = [];
            layers.forEach((layer, li) => {
                neurons[li] = [];
                const spacing = height / (layer.size + 1);
                for (let i = 0; i < layer.size; i++) {
                    neurons[li][i] = {
                        x: layer.x,
                        y: spacing * (i + 1)
                    };
                }
            });

            // Draw connections and flow
            // Input -> Hidden
            for (let j = 0; j < 3; j++) {
                for (let i = 0; i < 2; i++) {
                    const from = neurons[0][i];
                    const to = neurons[1][j];
                    const weight = network.weights[0][j][i];

                    drawConnection(from, to, weight, 0, j, i);
                }
            }

            // Hidden -> Output
            for (let j = 0; j < 3; j++) {
                const from = neurons[1][j];
                const to = neurons[2][0];
                const weight = network.weights[1][j][0];

                drawConnection(from, to, weight, 1, 0, j);
            }

            // Draw neurons
            neurons.forEach((layer, li) => {
                layer.forEach((n, ni) => {
                    drawNeuron(n.x, n.y, li, ni);
                });
            });

            // Draw layer labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '14px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            layers.forEach(layer => {
                ctx.fillText(layer.label, layer.x, height - 20);
            });
        }

        function drawConnection(from, to, weight, layerIdx, toIdx, fromIdx) {
            const gradient = network.dw[layerIdx] ?
                (network.dw[layerIdx][toIdx] ? Math.abs(network.dw[layerIdx][toIdx][fromIdx] || network.dw[layerIdx][toIdx][0]) : 0) : 0;

            // Base connection
            ctx.beginPath();
            ctx.strokeStyle = weight > 0 ? 'rgba(59, 130, 246, 0.3)' : 'rgba(239, 68, 68, 0.3)';
            ctx.lineWidth = Math.abs(weight) * 3 + 1;
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // Forward flow animation
            if (phase === 'forward' && layerIdx === (animationProgress < 0.5 ? 0 : 1)) {
                const t = (animationProgress % 0.5) * 2;
                const x = from.x + (to.x - from.x) * t;
                const y = from.y + (to.y - from.y) * t;

                ctx.beginPath();
                ctx.fillStyle = '#3b82f6';
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Backward flow animation
            if (phase === 'backward') {
                const layerPhase = layerIdx === 1 ? 0 : 0.5;
                if (animationProgress >= layerPhase && animationProgress < layerPhase + 0.5) {
                    const t = 1 - ((animationProgress - layerPhase) * 2);
                    const x = from.x + (to.x - from.x) * t;
                    const y = from.y + (to.y - from.y) * t;

                    // Gradient magnitude color
                    const intensity = Math.min(1, gradient * 5);
                    ctx.beginPath();
                    ctx.fillStyle = `rgb(${239}, ${Math.floor(68 + 150 * (1 - intensity))}, ${Math.floor(68 + 100 * (1 - intensity))})`;
                    ctx.arc(x, y, 6 + intensity * 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw weight value
            if (phase !== 'idle') {
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2 - 10;
                ctx.fillStyle = '#fbbf24';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(weight.toFixed(2), midX, midY);
            }
        }

        function drawNeuron(x, y, layerIdx, neuronIdx) {
            const activation = network.a[layerIdx] ? network.a[layerIdx][neuronIdx] : 0;
            const delta = network.delta[layerIdx - 1] ? network.delta[layerIdx - 1][neuronIdx] : 0;

            // Glow effect based on activation
            if (activation && phase !== 'idle') {
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 40);
                gradient.addColorStop(0, `rgba(59, 130, 246, ${activation * 0.5})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 40, 0, Math.PI * 2);
                ctx.fill();
            }

            // Neuron body
            ctx.beginPath();
            const baseColor = phase === 'backward' && Math.abs(delta) > 0.01 ?
                `rgb(${Math.floor(239 - 100 * (1 - Math.abs(delta)))}, 68, 68)` :
                phase === 'forward' || phase === 'update' ? '#3b82f6' : '#4b5563';

            ctx.fillStyle = baseColor;
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Display value
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (phase === 'backward' && layerIdx > 0) {
                ctx.fillText(delta ? delta.toFixed(2) : '-', x, y);
            } else {
                ctx.fillText(activation ? activation.toFixed(2) : '-', x, y);
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (playing && phase !== 'idle') {
                animationProgress += deltaTime * speed;

                if (animationProgress >= 1) {
                    animationProgress = 0;
                    advancePhase();
                }
            }

            draw();
            updateUI();
            requestAnimationFrame(animate);
        }

        function advancePhase() {
            switch (phase) {
                case 'forward':
                    phase = 'backward';
                    backward(trainingData[currentSample].target);
                    break;
                case 'backward':
                    phase = 'update';
                    updateWeights();
                    break;
                case 'update':
                    currentSample = (currentSample + 1) % trainingData.length;
                    if (currentSample === 0) epoch++;
                    phase = 'forward';
                    forward(trainingData[currentSample].input);
                    break;
            }
        }

        function updateUI() {
            document.getElementById('forwardPhase').classList.toggle('active', phase === 'forward');
            document.getElementById('backwardPhase').classList.toggle('active', phase === 'backward');

            document.getElementById('epoch').textContent = epoch;
            document.getElementById('input').textContent = `[${trainingData[currentSample].input.join(', ')}]`;
            document.getElementById('target').textContent = trainingData[currentSample].target;

            const output = network.a[2][0];
            document.getElementById('output').textContent = output ? output.toFixed(4) : '-';

            if (output !== undefined) {
                const loss = Math.pow(output - trainingData[currentSample].target, 2) / 2;
                document.getElementById('loss').textContent = loss.toFixed(4);
            }
        }

        // Event handlers
        document.getElementById('stepBtn').addEventListener('click', () => {
            if (phase === 'idle') {
                phase = 'forward';
                forward(trainingData[currentSample].input);
            } else {
                advancePhase();
            }
            animationProgress = 0;
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            playing = !playing;
            document.getElementById('playBtn').textContent = playing ? 'Pause' : 'Play';

            if (playing && phase === 'idle') {
                phase = 'forward';
                forward(trainingData[currentSample].input);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            // Reset weights
            network.weights = [
                [[0.5, -0.5], [0.3, 0.3], [-0.2, 0.4]],
                [[0.4], [-0.3], [0.5]]
            ];
            network.biases = [
                [0.1, -0.1, 0.2],
                [0.0]
            ];
            network.a = [[], [], []];
            network.z = [[], [], []];
            network.dw = [[], []];
            network.db = [[], []];
            network.delta = [[], []];

            currentSample = 0;
            epoch = 0;
            phase = 'idle';
            animationProgress = 0;
            playing = false;
            document.getElementById('playBtn').textContent = 'Play';
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
        });

        document.getElementById('learningRate').addEventListener('input', (e) => {
            learningRate = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = learningRate.toFixed(1);
        });

        // Start
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
