<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering - Neural Network Playgrounds</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e8e6e1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .back-link {
            color: #fbbf24;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-4px);
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .visualization {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #canvas {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: #1a1a2e;
            font-weight: 600;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e8e6e1;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #9ca3af;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e8e6e1;
            font-size: 14px;
        }

        .stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: #9ca3af;
        }

        .stat-value {
            color: #fbbf24;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
            line-height: 1.5;
            color: #9ca3af;
        }

        .algorithm-steps {
            margin-top: 20px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.3s;
        }

        .step.active {
            background: rgba(251, 191, 36, 0.2);
        }

        .step.completed {
            opacity: 0.5;
        }

        .step-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .step.active .step-number {
            background: #fbbf24;
            color: #1a1a2e;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">
                <span>‚Üê</span> Back to Gallery
            </a>
            <h1>K-Means Clustering</h1>
        </header>

        <div class="main-content">
            <div class="visualization">
                <canvas id="canvas"></canvas>
                <div class="legend" id="legend"></div>
            </div>

            <div class="controls">
                <div class="button-group">
                    <button class="btn-primary" id="stepBtn">Step</button>
                    <button class="btn-primary" id="runBtn">Run</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Number of Clusters (K): <span id="kValue">3</span></label>
                    <input type="range" id="kSlider" min="2" max="8" step="1" value="3">
                </div>

                <div class="control-group">
                    <label>Data Pattern</label>
                    <select id="patternSelect">
                        <option value="random">Random</option>
                        <option value="blobs">Gaussian Blobs</option>
                        <option value="rings">Concentric Rings</option>
                        <option value="moons">Two Moons</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Number of Points: <span id="pointsValue">100</span></label>
                    <input type="range" id="pointsSlider" min="50" max="300" step="10" value="100">
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Iteration</span>
                        <span class="stat-value" id="iteration">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Inertia (WCSS)</span>
                        <span class="stat-value" id="inertia">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Status</span>
                        <span class="stat-value" id="status">Ready</span>
                    </div>
                </div>

                <div class="algorithm-steps">
                    <div class="step" id="step1">
                        <div class="step-number">1</div>
                        <span>Initialize random centroids</span>
                    </div>
                    <div class="step" id="step2">
                        <div class="step-number">2</div>
                        <span>Assign points to nearest centroid</span>
                    </div>
                    <div class="step" id="step3">
                        <div class="step-number">3</div>
                        <span>Update centroid positions</span>
                    </div>
                    <div class="step" id="step4">
                        <div class="step-number">4</div>
                        <span>Check for convergence</span>
                    </div>
                </div>

                <div class="info-box" style="margin-top: 20px;">
                    <strong>K-Means</strong> partitions data into K clusters by minimizing within-cluster variance. Click on canvas to add points manually!
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            draw();
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Colors for clusters
        const colors = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b',
            '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'
        ];

        // State
        let points = [];
        let centroids = [];
        let assignments = [];
        let k = 3;
        let numPoints = 100;
        let iteration = 0;
        let running = false;
        let converged = false;
        let currentStep = 0; // 0: init, 1: assign, 2: update, 3: check

        // Generate data
        function generateData(pattern) {
            points = [];

            switch (pattern) {
                case 'random':
                    for (let i = 0; i < numPoints; i++) {
                        points.push({
                            x: 0.1 + Math.random() * 0.8,
                            y: 0.1 + Math.random() * 0.8
                        });
                    }
                    break;

                case 'blobs':
                    const blobCenters = [];
                    for (let i = 0; i < k; i++) {
                        blobCenters.push({
                            x: 0.2 + Math.random() * 0.6,
                            y: 0.2 + Math.random() * 0.6
                        });
                    }
                    for (let i = 0; i < numPoints; i++) {
                        const center = blobCenters[i % k];
                        points.push({
                            x: center.x + (Math.random() - 0.5) * 0.15,
                            y: center.y + (Math.random() - 0.5) * 0.15
                        });
                    }
                    break;

                case 'rings':
                    for (let i = 0; i < numPoints; i++) {
                        const ring = Math.floor(i / (numPoints / 3));
                        const radius = 0.1 + ring * 0.12;
                        const angle = Math.random() * Math.PI * 2;
                        const noise = (Math.random() - 0.5) * 0.03;
                        points.push({
                            x: 0.5 + (radius + noise) * Math.cos(angle),
                            y: 0.5 + (radius + noise) * Math.sin(angle)
                        });
                    }
                    break;

                case 'moons':
                    for (let i = 0; i < numPoints; i++) {
                        const moon = i < numPoints / 2 ? 0 : 1;
                        const angle = (i / (numPoints / 2)) * Math.PI;
                        const noise = (Math.random() - 0.5) * 0.05;

                        if (moon === 0) {
                            points.push({
                                x: 0.3 + 0.2 * Math.cos(angle) + noise,
                                y: 0.5 - 0.2 * Math.sin(angle) + noise
                            });
                        } else {
                            points.push({
                                x: 0.5 + 0.2 * Math.cos(angle) + noise,
                                y: 0.5 + 0.2 * Math.sin(angle) + noise
                            });
                        }
                    }
                    break;
            }

            // Clamp points
            points = points.map(p => ({
                x: Math.max(0.05, Math.min(0.95, p.x)),
                y: Math.max(0.05, Math.min(0.95, p.y))
            }));

            resetClustering();
        }

        // Initialize centroids
        function initializeCentroids() {
            centroids = [];
            const usedIndices = new Set();

            // K-means++ initialization
            for (let i = 0; i < k; i++) {
                if (i === 0) {
                    const idx = Math.floor(Math.random() * points.length);
                    centroids.push({ ...points[idx] });
                    usedIndices.add(idx);
                } else {
                    // Choose point proportional to squared distance from nearest centroid
                    const distances = points.map((p, idx) => {
                        if (usedIndices.has(idx)) return 0;
                        let minDist = Infinity;
                        for (const c of centroids) {
                            const d = Math.pow(p.x - c.x, 2) + Math.pow(p.y - c.y, 2);
                            minDist = Math.min(minDist, d);
                        }
                        return minDist;
                    });

                    const sum = distances.reduce((a, b) => a + b, 0);
                    let r = Math.random() * sum;

                    for (let j = 0; j < distances.length; j++) {
                        r -= distances[j];
                        if (r <= 0) {
                            centroids.push({ ...points[j] });
                            usedIndices.add(j);
                            break;
                        }
                    }
                }
            }

            assignments = new Array(points.length).fill(-1);
            currentStep = 1;
        }

        // Assign points to nearest centroid
        function assignPoints() {
            let changed = false;

            for (let i = 0; i < points.length; i++) {
                let minDist = Infinity;
                let nearest = 0;

                for (let j = 0; j < centroids.length; j++) {
                    const dist = Math.pow(points[i].x - centroids[j].x, 2) +
                                Math.pow(points[i].y - centroids[j].y, 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = j;
                    }
                }

                if (assignments[i] !== nearest) {
                    assignments[i] = nearest;
                    changed = true;
                }
            }

            currentStep = 2;
            return changed;
        }

        // Update centroid positions
        function updateCentroids() {
            const newCentroids = centroids.map(() => ({ x: 0, y: 0, count: 0 }));

            for (let i = 0; i < points.length; i++) {
                const cluster = assignments[i];
                newCentroids[cluster].x += points[i].x;
                newCentroids[cluster].y += points[i].y;
                newCentroids[cluster].count++;
            }

            for (let i = 0; i < centroids.length; i++) {
                if (newCentroids[i].count > 0) {
                    centroids[i].x = newCentroids[i].x / newCentroids[i].count;
                    centroids[i].y = newCentroids[i].y / newCentroids[i].count;
                }
            }

            currentStep = 3;
        }

        // Calculate inertia (within-cluster sum of squares)
        function calculateInertia() {
            let inertia = 0;
            for (let i = 0; i < points.length; i++) {
                const cluster = assignments[i];
                if (cluster >= 0) {
                    inertia += Math.pow(points[i].x - centroids[cluster].x, 2) +
                              Math.pow(points[i].y - centroids[cluster].y, 2);
                }
            }
            return inertia;
        }

        // Single step
        function step() {
            if (converged) return;

            if (centroids.length === 0) {
                initializeCentroids();
            } else if (currentStep === 1) {
                const changed = assignPoints();
                if (!changed) {
                    converged = true;
                    document.getElementById('status').textContent = 'Converged!';
                }
            } else if (currentStep === 2) {
                updateCentroids();
                iteration++;
            } else {
                currentStep = 1;
            }

            updateStats();
            updateStepDisplay();
            draw();
        }

        // Run until convergence
        function run() {
            if (running) {
                running = false;
                document.getElementById('runBtn').textContent = 'Run';
                return;
            }

            running = true;
            document.getElementById('runBtn').textContent = 'Stop';

            function iterate() {
                if (!running || converged) {
                    running = false;
                    document.getElementById('runBtn').textContent = 'Run';
                    return;
                }

                step();
                setTimeout(iterate, 300);
            }

            iterate();
        }

        // Reset
        function resetClustering() {
            centroids = [];
            assignments = new Array(points.length).fill(-1);
            iteration = 0;
            converged = false;
            currentStep = 0;
            running = false;
            document.getElementById('runBtn').textContent = 'Run';
            document.getElementById('status').textContent = 'Ready';
            updateStats();
            updateStepDisplay();
            updateLegend();
            draw();
        }

        // Update UI
        function updateStats() {
            document.getElementById('iteration').textContent = iteration;
            const inertia = calculateInertia();
            document.getElementById('inertia').textContent = inertia > 0 ? inertia.toFixed(4) : '-';
        }

        function updateStepDisplay() {
            for (let i = 1; i <= 4; i++) {
                const el = document.getElementById('step' + i);
                el.classList.remove('active', 'completed');

                if (i < currentStep || (converged && i <= 4)) {
                    el.classList.add('completed');
                } else if (i === currentStep) {
                    el.classList.add('active');
                }
            }
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';

            for (let i = 0; i < k; i++) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colors[i]};"></div>
                    <span>Cluster ${i + 1}</span>
                `;
                legend.appendChild(item);
            }
        }

        // Draw
        function draw() {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw Voronoi-like regions (simplified)
            if (centroids.length > 0) {
                const imageData = ctx.createImageData(width, height);
                for (let py = 0; py < height; py += 2) {
                    for (let px = 0; px < width; px += 2) {
                        const x = px / width;
                        const y = py / height;

                        let minDist = Infinity;
                        let nearest = 0;

                        for (let i = 0; i < centroids.length; i++) {
                            const dist = Math.pow(x - centroids[i].x, 2) + Math.pow(y - centroids[i].y, 2);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = i;
                            }
                        }

                        const color = hexToRgb(colors[nearest]);
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                const idx = ((py + dy) * width + (px + dx)) * 4;
                                imageData.data[idx] = color.r;
                                imageData.data[idx + 1] = color.g;
                                imageData.data[idx + 2] = color.b;
                                imageData.data[idx + 3] = 30;
                            }
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }

            // Draw points
            for (let i = 0; i < points.length; i++) {
                const px = points[i].x * width;
                const py = points[i].y * height;
                const cluster = assignments[i];

                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fillStyle = cluster >= 0 ? colors[cluster] : '#6b7280';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw centroids
            for (let i = 0; i < centroids.length; i++) {
                const px = centroids[i].x * width;
                const py = centroids[i].y * height;

                // Cross shape
                ctx.strokeStyle = colors[i];
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(px - 12, py);
                ctx.lineTo(px + 12, py);
                ctx.moveTo(px, py - 12);
                ctx.lineTo(px, py + 12);
                ctx.stroke();

                // White border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(px, py, 10, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            };
        }

        // Event handlers
        document.getElementById('stepBtn').addEventListener('click', step);
        document.getElementById('runBtn').addEventListener('click', run);
        document.getElementById('resetBtn').addEventListener('click', resetClustering);

        document.getElementById('kSlider').addEventListener('input', (e) => {
            k = parseInt(e.target.value);
            document.getElementById('kValue').textContent = k;
            updateLegend();
            resetClustering();
        });

        document.getElementById('pointsSlider').addEventListener('input', (e) => {
            numPoints = parseInt(e.target.value);
            document.getElementById('pointsValue').textContent = numPoints;
            generateData(document.getElementById('patternSelect').value);
        });

        document.getElementById('patternSelect').addEventListener('change', (e) => {
            generateData(e.target.value);
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            points.push({ x, y });
            assignments.push(-1);
            draw();
        });

        // Initialize
        generateData('blobs');
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
