<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prisoner's Dilemma Tournament - Game Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none;
            font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px;
            transition: all 0.3s; z-index: 100;
        }
        .back-link:hover { background: rgba(74, 222, 128, 0.2); transform: translateX(-3px); }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 350px; gap: 20px; }
        .main-panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; }
        .controls { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.9em; line-height: 1.6; }
        .payoff-matrix { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.85em; }
        .payoff-matrix th, .payoff-matrix td { border: 1px solid rgba(255,255,255,0.2); padding: 8px; text-align: center; }
        .payoff-matrix th { background: rgba(74, 222, 128, 0.2); }
        .strategy-list { margin: 15px 0; }
        .strategy-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; margin: 5px 0; }
        .strategy-item.winner { background: rgba(74, 222, 128, 0.2); border: 1px solid #4ade80; }
        .strategy-name { font-weight: 600; }
        .strategy-score { color: #4ade80; font-family: monospace; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-primary:hover { background: #22c55e; transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }
        .round-display { text-align: center; font-size: 1.5em; color: #4ade80; margin: 15px 0; font-family: monospace; }
        .match-display { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; margin: 15px 0; font-family: monospace; font-size: 0.85em; max-height: 200px; overflow-y: auto; }
        .match-line { padding: 2px 0; }
        .cooperate { color: #4ade80; }
        .defect { color: #f87171; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Prisoner's Dilemma Tournament</h1>
    <p class="subtitle">Axelrod-style strategy competition - cooperation vs defection</p>

    <div class="container">
        <div class="main-panel">
            <canvas id="canvas" width="800" height="500"></canvas>
            <div class="round-display">Round: <span id="round">0</span> / <span id="totalRounds">200</span></div>
            <div class="match-display" id="matchLog"></div>
        </div>

        <div class="controls">
            <div class="info-box">
                <strong>Prisoner's Dilemma</strong><br>
                Two players choose to Cooperate (C) or Defect (D). Mutual cooperation yields good payoffs for both,
                but defection tempts with higher individual gain. Classic strategies compete over many rounds.
                <table class="payoff-matrix">
                    <tr><th></th><th>Cooperate</th><th>Defect</th></tr>
                    <tr><th>Cooperate</th><td>3, 3</td><td>0, 5</td></tr>
                    <tr><th>Defect</th><td>5, 0</td><td>1, 1</td></tr>
                </table>
            </div>

            <button class="btn-primary" onclick="runTournament()">Run Tournament</button>
            <button class="btn-secondary" onclick="stepRound()">Step One Round</button>
            <button class="btn-secondary" onclick="resetTournament()">Reset</button>

            <h3 style="margin-top: 20px;">Strategy Rankings</h3>
            <div class="strategy-list" id="rankings"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Payoff matrix: [my_payoff, opponent_payoff]
        const PAYOFFS = {
            'CC': [3, 3],
            'CD': [0, 5],
            'DC': [5, 0],
            'DD': [1, 1]
        };

        // Strategy definitions
        const strategies = {
            'Tit-for-Tat': (myHistory, oppHistory) => oppHistory.length === 0 ? 'C' : oppHistory[oppHistory.length - 1],
            'Always Defect': () => 'D',
            'Always Cooperate': () => 'C',
            'Grudger': (myHistory, oppHistory) => oppHistory.includes('D') ? 'D' : 'C',
            'Random': () => Math.random() < 0.5 ? 'C' : 'D',
            'Tit-for-Two-Tats': (myHistory, oppHistory) => {
                if (oppHistory.length < 2) return 'C';
                return (oppHistory.slice(-2).every(m => m === 'D')) ? 'D' : 'C';
            },
            'Suspicious TFT': (myHistory, oppHistory) => oppHistory.length === 0 ? 'D' : oppHistory[oppHistory.length - 1],
            'Pavlov': (myHistory, oppHistory) => {
                if (oppHistory.length === 0) return 'C';
                const lastMove = myHistory[myHistory.length - 1];
                const lastOpp = oppHistory[oppHistory.length - 1];
                // Win-stay, lose-shift
                if ((lastMove === 'C' && lastOpp === 'C') || (lastMove === 'D' && lastOpp === 'D')) {
                    return lastMove;
                }
                return lastMove === 'C' ? 'D' : 'C';
            }
        };

        let scores = {};
        let histories = {};
        let currentRound = 0;
        let totalRounds = 200;
        let matchHistory = [];
        let running = false;

        function initTournament() {
            scores = {};
            histories = {};
            currentRound = 0;
            matchHistory = [];

            const stratNames = Object.keys(strategies);
            for (const name of stratNames) {
                scores[name] = 0;
                histories[name] = {};
                for (const opp of stratNames) {
                    if (opp !== name) {
                        histories[name][opp] = { my: [], opp: [] };
                    }
                }
            }
            updateDisplay();
        }

        function playRound() {
            const stratNames = Object.keys(strategies);
            const roundLog = [];

            for (let i = 0; i < stratNames.length; i++) {
                for (let j = i + 1; j < stratNames.length; j++) {
                    const name1 = stratNames[i];
                    const name2 = stratNames[j];

                    const hist1 = histories[name1][name2];
                    const hist2 = histories[name2][name1];

                    const move1 = strategies[name1](hist1.my, hist1.opp);
                    const move2 = strategies[name2](hist2.my, hist2.opp);

                    const outcome = move1 + move2;
                    const [pay1, pay2] = PAYOFFS[outcome];

                    scores[name1] += pay1;
                    scores[name2] += pay2;

                    hist1.my.push(move1);
                    hist1.opp.push(move2);
                    hist2.my.push(move2);
                    hist2.opp.push(move1);

                    roundLog.push({ p1: name1, p2: name2, m1: move1, m2: move2, s1: pay1, s2: pay2 });
                }
            }

            currentRound++;
            matchHistory.push(roundLog);
            return roundLog;
        }

        function updateDisplay() {
            document.getElementById('round').textContent = currentRound;

            // Update rankings
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            const rankingsDiv = document.getElementById('rankings');
            rankingsDiv.innerHTML = sorted.map((entry, idx) => {
                const [name, score] = entry;
                const isWinner = idx === 0 && currentRound > 0;
                return `<div class="strategy-item ${isWinner ? 'winner' : ''}">
                    <span class="strategy-name">${idx + 1}. ${name}</span>
                    <span class="strategy-score">${score}</span>
                </div>`;
            }).join('');

            // Draw chart
            drawChart(sorted);
        }

        function drawChart(sorted) {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxScore = Math.max(...sorted.map(s => s[1]), 1);
            const barWidth = (canvas.width - 100) / sorted.length;
            const maxHeight = canvas.height - 80;

            const colors = ['#4ade80', '#22d3ee', '#a78bfa', '#f472b6', '#fb923c', '#facc15', '#94a3b8', '#f87171'];

            sorted.forEach(([name, score], i) => {
                const barHeight = (score / maxScore) * maxHeight;
                const x = 50 + i * barWidth;
                const y = canvas.height - 40 - barHeight;

                ctx.fillStyle = colors[i % colors.length];
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);

                // Score label
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(score, x + barWidth / 2, y - 5);

                // Name label (rotated)
                ctx.save();
                ctx.translate(x + barWidth / 2, canvas.height - 5);
                ctx.rotate(-Math.PI / 4);
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(name.substring(0, 15), 0, 0);
                ctx.restore();
            });

            // Title
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Tournament Scores - Round ${currentRound}`, canvas.width / 2, 25);
        }

        function updateMatchLog(roundLog) {
            const logDiv = document.getElementById('matchLog');
            const logLines = roundLog.map(m => {
                const m1Class = m.m1 === 'C' ? 'cooperate' : 'defect';
                const m2Class = m.m2 === 'C' ? 'cooperate' : 'defect';
                return `<div class="match-line">${m.p1.substring(0,12)} <span class="${m1Class}">${m.m1}</span> vs <span class="${m2Class}">${m.m2}</span> ${m.p2.substring(0,12)} (${m.s1}-${m.s2})</div>`;
            });
            logDiv.innerHTML = logLines.join('');
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function stepRound() {
            if (currentRound >= totalRounds) return;
            const log = playRound();
            updateDisplay();
            updateMatchLog(log);
        }

        async function runTournament() {
            if (running) return;
            running = true;

            while (currentRound < totalRounds && running) {
                const log = playRound();
                updateDisplay();
                if (currentRound % 10 === 0) {
                    updateMatchLog(log);
                    await new Promise(r => setTimeout(r, 50));
                }
            }

            updateMatchLog(matchHistory[matchHistory.length - 1] || []);
            running = false;
        }

        function resetTournament() {
            running = false;
            initTournament();
            document.getElementById('matchLog').innerHTML = '<div class="match-line">Click "Run Tournament" or "Step One Round" to begin</div>';
        }

        initTournament();
        document.getElementById('matchLog').innerHTML = '<div class="match-line">Click "Run Tournament" or "Step One Round" to begin</div>';
    </script>
</body>
</html>
