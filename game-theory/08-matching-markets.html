<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matching Markets - Game Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none;
            font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px;
            z-index: 100;
        }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        .matching-display { display: flex; gap: 30px; justify-content: center; margin: 20px 0; }
        .side { display: flex; flex-direction: column; gap: 10px; }
        .side-title { text-align: center; font-weight: 600; color: #22d3ee; margin-bottom: 10px; }
        .entity { background: rgba(255,255,255,0.1); border-radius: 10px; padding: 12px 20px; min-width: 120px; position: relative; }
        .entity.proposer { background: rgba(74, 222, 128, 0.2); border: 2px solid #4ade80; }
        .entity.matched { background: rgba(250, 204, 21, 0.2); border: 2px solid #facc15; }
        .entity-name { font-weight: 600; }
        .entity-prefs { font-size: 0.75em; opacity: 0.7; margin-top: 5px; }
        .arrows-container { display: flex; flex-direction: column; justify-content: center; gap: 10px; min-width: 150px; }
        .match-line { height: 2px; background: #facc15; position: relative; }
        canvas { width: 100%; height: 300px; border-radius: 8px; background: #0a0a15; margin: 15px 0; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; }
        .value-display { color: #4ade80; font-family: monospace; }
        .step-display { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; margin: 15px 0; font-family: monospace; font-size: 0.85em; max-height: 200px; overflow-y: auto; }
        .step-line { padding: 3px 0; }
        .step-line.proposal { color: #4ade80; }
        .step-line.rejection { color: #f87171; }
        .step-line.tentative { color: #facc15; }
        .stats-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; margin-top: 15px; }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } .matching-display { flex-direction: column; align-items: center; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Matching Markets</h1>
    <p class="subtitle">Gale-Shapley Stable Matching Algorithm</p>

    <div class="container">
        <div class="panel">
            <div class="info-box">
                <strong>Gale-Shapley Algorithm (1962):</strong> Finds a stable matching between two groups (e.g., students & schools, residents & hospitals).
                A matching is stable if no pair would prefer each other over their current matches.
                The algorithm is strategy-proof for the proposing side.
            </div>

            <div class="matching-display">
                <div class="side" id="leftSide">
                    <div class="side-title">Proposers</div>
                </div>
                <canvas id="matchCanvas" width="200" height="300"></canvas>
                <div class="side" id="rightSide">
                    <div class="side-title">Receivers</div>
                </div>
            </div>

            <div class="step-display" id="stepLog">
                <div class="step-line">Click "Run Algorithm" to start the matching process...</div>
            </div>

            <button class="btn-primary" onclick="runAlgorithm()">Run Algorithm</button>
            <button class="btn-secondary" onclick="stepAlgorithm()">Step</button>
            <button class="btn-secondary" onclick="resetMatching()">Reset</button>
        </div>

        <div class="panel">
            <h3>Settings</h3>

            <div class="control-group">
                <label>Number of pairs: <span class="value-display" id="numPairs">4</span></label>
                <input type="range" id="pairsSlider" min="3" max="8" value="4" oninput="updatePairs()">
            </div>

            <div class="control-group">
                <label>Scenario:</label>
                <select id="scenario" onchange="resetMatching()">
                    <option value="random">Random Preferences</option>
                    <option value="students">Students & Schools</option>
                    <option value="residents">Residents & Hospitals</option>
                </select>
            </div>

            <h3 style="margin-top: 20px;">Algorithm Statistics</h3>
            <div class="stats-box">
                <div class="stat-row">
                    <span>Steps taken:</span>
                    <span class="value-display" id="stepCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Proposals made:</span>
                    <span class="value-display" id="proposalCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Rejections:</span>
                    <span class="value-display" id="rejectionCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Stable matching:</span>
                    <span class="value-display" id="isStable">-</span>
                </div>
            </div>

            <div class="info-box" style="margin-top: 20px;">
                <strong>Properties:</strong>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>Always terminates</li>
                    <li>Proposer-optimal result</li>
                    <li>Strategy-proof for proposers</li>
                    <li>O(n²) worst case</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const matchCanvas = document.getElementById('matchCanvas');
        const matchCtx = matchCanvas.getContext('2d');

        let proposers = [];
        let receivers = [];
        let matches = {}; // receiver -> proposer
        let proposerMatches = {}; // proposer -> receiver
        let stepLog = [];
        let stepCount = 0;
        let proposalCount = 0;
        let rejectionCount = 0;
        let running = false;
        let finished = false;

        const names = {
            students: ['Alice', 'Bob', 'Carol', 'David', 'Emma', 'Frank', 'Grace', 'Henry'],
            schools: ['MIT', 'Stanford', 'Harvard', 'Yale', 'Princeton', 'Columbia', 'Berkeley', 'Cornell'],
            residents: ['Dr. A', 'Dr. B', 'Dr. C', 'Dr. D', 'Dr. E', 'Dr. F', 'Dr. G', 'Dr. H'],
            hospitals: ['General', 'Metro', 'City', 'Regional', 'Central', 'Memorial', 'County', 'University']
        };

        function updatePairs() {
            document.getElementById('numPairs').textContent = document.getElementById('pairsSlider').value;
            resetMatching();
        }

        function initEntities() {
            const n = parseInt(document.getElementById('pairsSlider').value);
            const scenario = document.getElementById('scenario').value;

            let leftNames, rightNames;
            if (scenario === 'students') {
                leftNames = names.students;
                rightNames = names.schools;
            } else if (scenario === 'residents') {
                leftNames = names.residents;
                rightNames = names.hospitals;
            } else {
                leftNames = Array.from({ length: n }, (_, i) => `P${i + 1}`);
                rightNames = Array.from({ length: n }, (_, i) => `R${i + 1}`);
            }

            proposers = [];
            receivers = [];

            for (let i = 0; i < n; i++) {
                // Random preference order
                const prefs = shuffle([...Array(n).keys()]);
                proposers.push({
                    id: i,
                    name: leftNames[i],
                    preferences: prefs,
                    nextProposal: 0,
                    matched: null
                });
            }

            for (let i = 0; i < n; i++) {
                const prefs = shuffle([...Array(n).keys()]);
                receivers.push({
                    id: i,
                    name: rightNames[i],
                    preferences: prefs,
                    matched: null
                });
            }

            matches = {};
            proposerMatches = {};
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function updateDisplay() {
            // Update left side (proposers)
            const leftSide = document.getElementById('leftSide');
            leftSide.innerHTML = '<div class="side-title">Proposers</div>';
            proposers.forEach(p => {
                const prefList = p.preferences.map(r => receivers[r].name.substring(0, 3)).join(' > ');
                const isMatched = p.matched !== null;
                leftSide.innerHTML += `<div class="entity ${isMatched ? 'matched' : ''}">
                    <div class="entity-name">${p.name}</div>
                    <div class="entity-prefs">${prefList}</div>
                </div>`;
            });

            // Update right side (receivers)
            const rightSide = document.getElementById('rightSide');
            rightSide.innerHTML = '<div class="side-title">Receivers</div>';
            receivers.forEach(r => {
                const prefList = r.preferences.map(p => proposers[p].name.substring(0, 3)).join(' > ');
                const isMatched = r.matched !== null;
                rightSide.innerHTML += `<div class="entity ${isMatched ? 'matched' : ''}">
                    <div class="entity-name">${r.name}</div>
                    <div class="entity-prefs">${prefList}</div>
                </div>`;
            });

            // Draw match lines
            drawMatches();

            // Update stats
            document.getElementById('stepCount').textContent = stepCount;
            document.getElementById('proposalCount').textContent = proposalCount;
            document.getElementById('rejectionCount').textContent = rejectionCount;
            document.getElementById('isStable').textContent = finished ? 'Yes' : '-';
        }

        function drawMatches() {
            matchCtx.fillStyle = '#0a0a15';
            matchCtx.fillRect(0, 0, matchCanvas.width, matchCanvas.height);

            const n = proposers.length;
            const yStep = matchCanvas.height / (n + 1);

            proposers.forEach((p, i) => {
                if (p.matched !== null) {
                    const y1 = (i + 1) * yStep;
                    const y2 = (p.matched + 1) * yStep;

                    matchCtx.strokeStyle = '#facc15';
                    matchCtx.lineWidth = 3;
                    matchCtx.beginPath();
                    matchCtx.moveTo(0, y1);
                    matchCtx.bezierCurveTo(matchCanvas.width * 0.3, y1, matchCanvas.width * 0.7, y2, matchCanvas.width, y2);
                    matchCtx.stroke();
                }
            });
        }

        function stepAlgorithm() {
            if (finished) return;

            // Find unmatched proposer who hasn't proposed to everyone
            const freeProposer = proposers.find(p => p.matched === null && p.nextProposal < receivers.length);

            if (!freeProposer) {
                finished = true;
                addLog('Algorithm complete! Stable matching found.', 'tentative');
                updateDisplay();
                return;
            }

            stepCount++;
            const targetIdx = freeProposer.preferences[freeProposer.nextProposal];
            const target = receivers[targetIdx];
            freeProposer.nextProposal++;
            proposalCount++;

            addLog(`${freeProposer.name} proposes to ${target.name}`, 'proposal');

            if (target.matched === null) {
                // Accept proposal
                target.matched = freeProposer.id;
                freeProposer.matched = target.id;
                addLog(`${target.name} accepts (was unmatched)`, 'tentative');
            } else {
                // Compare with current match
                const currentMatch = proposers[target.matched];
                const currentRank = target.preferences.indexOf(currentMatch.id);
                const newRank = target.preferences.indexOf(freeProposer.id);

                if (newRank < currentRank) {
                    // Prefer new proposer
                    currentMatch.matched = null;
                    target.matched = freeProposer.id;
                    freeProposer.matched = target.id;
                    addLog(`${target.name} accepts, rejects ${currentMatch.name}`, 'tentative');
                    rejectionCount++;
                } else {
                    // Reject new proposer
                    addLog(`${target.name} rejects (prefers ${currentMatch.name})`, 'rejection');
                    rejectionCount++;
                }
            }

            updateDisplay();
        }

        function addLog(text, type) {
            stepLog.push({ text, type });
            const logDiv = document.getElementById('stepLog');
            logDiv.innerHTML = stepLog.map(l => `<div class="step-line ${l.type}">${l.text}</div>`).join('');
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function runAlgorithm() {
            if (running) return;
            running = true;

            while (!finished && running) {
                stepAlgorithm();
                await new Promise(r => setTimeout(r, 500));
            }

            running = false;
        }

        function resetMatching() {
            running = false;
            finished = false;
            stepLog = [];
            stepCount = 0;
            proposalCount = 0;
            rejectionCount = 0;

            initEntities();
            document.getElementById('stepLog').innerHTML = '<div class="step-line">Click "Run Algorithm" to start...</div>';
            updateDisplay();
        }

        resetMatching();
    </script>
</body>
</html>
