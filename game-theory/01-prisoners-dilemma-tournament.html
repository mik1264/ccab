<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prisoner's Dilemma Tournament - Game Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .back-link {
            display: inline-block;
            color: #64b5f6;
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 16px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #90caf9;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .description {
            color: #b0b0b0;
            margin-bottom: 30px;
            line-height: 1.6;
            max-width: 800px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #151b2b;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #2a3f5f;
        }

        canvas {
            display: block;
            width: 100%;
            background: #0a0e1a;
            border-radius: 5px;
        }

        .controls-panel {
            background: #151b2b;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #2a3f5f;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #64b5f6;
            font-weight: 500;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background 0.3s;
            margin-bottom: 10px;
        }

        button:hover {
            background: #1565c0;
        }

        button:disabled {
            background: #37474f;
            cursor: not-allowed;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #2a3f5f;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
        }

        .slider-value {
            min-width: 40px;
            text-align: right;
            color: #90caf9;
            font-weight: 500;
        }

        .payoff-matrix {
            background: #0f1520;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .payoff-matrix h3 {
            color: #64b5f6;
            margin-bottom: 10px;
            font-size: 14px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
            text-align: center;
            border: 1px solid #2a3f5f;
        }

        th {
            background: #1a2332;
            color: #90caf9;
            font-weight: 600;
        }

        td {
            background: #151b2b;
            color: #e0e0e0;
        }

        .strategies-list {
            background: #0f1520;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .strategies-list h3 {
            color: #64b5f6;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .strategy-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 5px;
            background: #151b2b;
            border-radius: 3px;
            border-left: 3px solid;
        }

        .strategy-name {
            font-weight: 500;
        }

        .strategy-score {
            color: #81c784;
            font-weight: 600;
        }

        .info-box {
            background: #1a2332;
            border-left: 4px solid #64b5f6;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }

        .info-box h3 {
            color: #64b5f6;
            margin-bottom: 10px;
        }

        .info-box p {
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Game Theory</a>

        <h1>Prisoner's Dilemma Tournament</h1>
        <p class="description">
            Robert Axelrod's famous tournament where different strategies compete in iterated Prisoner's Dilemma games.
            Surprisingly, the simple "Tit-for-Tat" strategy often wins by being nice, retaliatory, and forgiving.
        </p>

        <div class="main-grid">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls-panel">
                <div class="payoff-matrix">
                    <h3>Payoff Matrix</h3>
                    <table>
                        <tr>
                            <th></th>
                            <th>Cooperate</th>
                            <th>Defect</th>
                        </tr>
                        <tr>
                            <th>Cooperate</th>
                            <td>3, 3</td>
                            <td>0, 5</td>
                        </tr>
                        <tr>
                            <th>Defect</th>
                            <td>5, 0</td>
                            <td>1, 1</td>
                        </tr>
                    </table>
                </div>

                <div class="control-group">
                    <button id="startBtn">Start Tournament</button>
                    <button id="pauseBtn" disabled>Pause</button>
                    <button id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Rounds per Match: <span id="roundsValue">100</span></label>
                    <div class="slider-container">
                        <input type="range" id="roundsSlider" min="50" max="500" value="100" step="50">
                        <span class="slider-value" id="roundsDisplay">100</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Tournament Speed</label>
                    <div class="slider-container">
                        <input type="range" id="speedSlider" min="1" max="10" value="5">
                        <span class="slider-value" id="speedDisplay">5</span>
                    </div>
                </div>

                <div class="strategies-list">
                    <h3>Strategy Rankings</h3>
                    <div id="rankings"></div>
                </div>
            </div>
        </div>

        <div class="info-box">
            <h3>About the Prisoner's Dilemma</h3>
            <p>Two criminals are arrested and interrogated separately. Each can either cooperate (stay silent) or defect (betray the other).</p>
            <p><strong>Strategies in this tournament:</strong></p>
            <p>• <strong>Tit-for-Tat:</strong> Cooperate first, then copy opponent's last move</p>
            <p>• <strong>Always Cooperate:</strong> Never defect, always cooperate</p>
            <p>• <strong>Always Defect:</strong> Never cooperate, always betray</p>
            <p>• <strong>Grudger:</strong> Cooperate until opponent defects once, then always defect</p>
            <p>• <strong>Random:</strong> Randomly choose to cooperate or defect (50/50)</p>
            <p>• <strong>Tit-for-Two-Tats:</strong> Only retaliate after two consecutive defections</p>
            <p>• <strong>Pavlov:</strong> Repeat move if rewarded (3+ points), switch if punished</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - 40;
            canvas.height = 600;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Payoff matrix
        const PAYOFFS = {
            CC: [3, 3],  // Both cooperate
            CD: [0, 5],  // I cooperate, they defect
            DC: [5, 0],  // I defect, they cooperate
            DD: [1, 1]   // Both defect
        };

        // Strategy definitions
        class Strategy {
            constructor(name, color) {
                this.name = name;
                this.color = color;
                this.score = 0;
                this.history = [];
                this.opponentHistory = [];
            }

            reset() {
                this.score = 0;
                this.history = [];
                this.opponentHistory = [];
            }

            makeMove() {
                return true; // Default: cooperate
            }

            recordMove(myMove, opponentMove) {
                this.history.push(myMove);
                this.opponentHistory.push(opponentMove);
            }
        }

        class TitForTat extends Strategy {
            makeMove() {
                if (this.opponentHistory.length === 0) return true;
                return this.opponentHistory[this.opponentHistory.length - 1];
            }
        }

        class AlwaysCooperate extends Strategy {
            makeMove() {
                return true;
            }
        }

        class AlwaysDefect extends Strategy {
            makeMove() {
                return false;
            }
        }

        class Grudger extends Strategy {
            makeMove() {
                return !this.opponentHistory.includes(false);
            }
        }

        class Random extends Strategy {
            makeMove() {
                return Math.random() > 0.5;
            }
        }

        class TitForTwoTats extends Strategy {
            makeMove() {
                if (this.opponentHistory.length < 2) return true;
                const last = this.opponentHistory[this.opponentHistory.length - 1];
                const secondLast = this.opponentHistory[this.opponentHistory.length - 2];
                return last || secondLast;
            }
        }

        class Pavlov extends Strategy {
            makeMove() {
                if (this.history.length === 0) return true;
                const myLast = this.history[this.history.length - 1];
                const oppLast = this.opponentHistory[this.opponentHistory.length - 1];

                // If we got 3+ points (mutual cooperation or I defected while they cooperated), repeat
                // Otherwise switch
                const lastScore = myLast && oppLast ? 3 : (!myLast && oppLast ? 5 : (myLast && !oppLast ? 0 : 1));
                return lastScore >= 3 ? myLast : !myLast;
            }
        }

        // Create strategies
        let strategies = [
            new TitForTat('Tit-for-Tat', '#4fc3f7'),
            new AlwaysCooperate('Always Cooperate', '#81c784'),
            new AlwaysDefect('Always Defect', '#e57373'),
            new Grudger('Grudger', '#ffb74d'),
            new Random('Random', '#ba68c8'),
            new TitForTwoTats('Tit-for-2-Tats', '#64b5f6'),
            new Pavlov('Pavlov', '#ffd54f')
        ];

        let roundsPerMatch = 100;
        let currentRound = 0;
        let currentMatchup = 0;
        let isRunning = false;
        let speed = 5;
        let scoreHistory = [];

        // Play a single round between two strategies
        function playRound(s1, s2) {
            const move1 = s1.makeMove();
            const move2 = s2.makeMove();

            const key = (move1 ? 'C' : 'D') + (move2 ? 'C' : 'D');
            const payoffs = PAYOFFS[key];

            s1.score += payoffs[0];
            s2.score += payoffs[1];

            s1.recordMove(move1, move2);
            s2.recordMove(move2, move1);
        }

        // Run full tournament
        function runTournament() {
            // Reset all strategies
            strategies.forEach(s => s.reset());
            scoreHistory = [];

            // Each strategy plays against all others
            for (let i = 0; i < strategies.length; i++) {
                for (let j = i + 1; j < strategies.length; j++) {
                    const s1 = strategies[i];
                    const s2 = strategies[j];

                    // Play multiple rounds
                    for (let round = 0; round < roundsPerMatch; round++) {
                        playRound(s1, s2);
                    }

                    // Reset histories for next matchup
                    s1.history = [];
                    s1.opponentHistory = [];
                    s2.history = [];
                    s2.opponentHistory = [];
                }
            }

            // Sort by score
            strategies.sort((a, b) => b.score - a.score);
        }

        // Draw visualization
        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / strategies.length;
            const maxScore = Math.max(...strategies.map(s => s.score), 1);

            strategies.forEach((strategy, i) => {
                const barHeight = (strategy.score / maxScore) * (canvas.height - 100);
                const x = i * barWidth;
                const y = canvas.height - barHeight - 50;

                // Draw bar
                ctx.fillStyle = strategy.color;
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);

                // Draw score
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(strategy.score.toString(), x + barWidth / 2, y - 10);

                // Draw strategy name
                ctx.save();
                ctx.translate(x + barWidth / 2, canvas.height - 20);
                ctx.rotate(-Math.PI / 6);
                ctx.font = '12px Arial';
                ctx.fillText(strategy.name, 0, 0);
                ctx.restore();
            });

            // Draw title
            ctx.fillStyle = '#64b5f6';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Tournament Results', 10, 30);

            // Update rankings display
            updateRankings();
        }

        function updateRankings() {
            const rankingsDiv = document.getElementById('rankings');
            rankingsDiv.innerHTML = strategies.map((s, i) => `
                <div class="strategy-item" style="border-color: ${s.color}">
                    <span class="strategy-name">${i + 1}. ${s.name}</span>
                    <span class="strategy-score">${s.score}</span>
                </div>
            `).join('');
        }

        // Animation loop
        let animationFrame = 0;
        function animate() {
            if (isRunning) {
                animationFrame++;
                if (animationFrame >= (11 - speed)) {
                    runTournament();
                    draw();
                    animationFrame = 0;
                }
                requestAnimationFrame(animate);
            }
        }

        // Controls
        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            strategies.forEach(s => s.reset());
            draw();
        });

        document.getElementById('roundsSlider').addEventListener('input', (e) => {
            roundsPerMatch = parseInt(e.target.value);
            document.getElementById('roundsDisplay').textContent = roundsPerMatch;
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedDisplay').textContent = speed;
        });

        // Initial draw
        runTournament();
        draw();
    </script>
</body>
</html>
