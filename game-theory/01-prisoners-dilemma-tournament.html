<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iterated Prisoner's Dilemma Tournament | Game Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 10px; color: #4fc3f7; }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; }

        .controls {
            display: flex; gap: 15px; flex-wrap: wrap;
            justify-content: center; margin-bottom: 20px;
        }
        button {
            padding: 10px 20px; border: none; border-radius: 8px;
            background: #4fc3f7; color: #1a1a2e; font-weight: bold;
            cursor: pointer; transition: all 0.3s;
        }
        button:hover { background: #81d4fa; transform: translateY(-2px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        select, input {
            padding: 10px; border-radius: 8px; border: 1px solid #4fc3f7;
            background: #1a1a2e; color: #e0e0e0;
        }

        .main-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        }
        @media (max-width: 900px) { .main-grid { grid-template-columns: 1fr; } }

        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 15px; padding: 20px;
            border: 1px solid rgba(79, 195, 247, 0.2);
        }
        .panel h2 { color: #4fc3f7; margin-bottom: 15px; font-size: 1.2em; }

        #tournamentCanvas { width: 100%; border-radius: 10px; background: #0a0a15; }

        .strategy-list {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px; margin-bottom: 15px;
        }
        .strategy-item {
            padding: 8px 12px; border-radius: 6px;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            font-size: 0.85em; cursor: pointer;
            transition: all 0.2s;
        }
        .strategy-item:hover { background: rgba(79, 195, 247, 0.2); }
        .strategy-item.selected { background: rgba(79, 195, 247, 0.4); border-color: #4fc3f7; }

        .results-table {
            width: 100%; border-collapse: collapse;
            font-size: 0.85em;
        }
        .results-table th, .results-table td {
            padding: 8px; text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .results-table th { color: #4fc3f7; }
        .results-table tr:hover { background: rgba(79, 195, 247, 0.1); }

        .score-bar {
            height: 20px; background: linear-gradient(90deg, #4fc3f7, #81d4fa);
            border-radius: 4px; transition: width 0.5s;
        }

        .payoff-matrix {
            display: grid; grid-template-columns: auto 1fr 1fr;
            gap: 2px; margin: 15px 0; font-size: 0.9em;
        }
        .payoff-cell {
            padding: 10px; text-align: center;
            background: rgba(79, 195, 247, 0.1);
        }
        .payoff-cell.header { background: rgba(79, 195, 247, 0.3); font-weight: bold; }

        .match-display {
            display: flex; justify-content: space-between;
            align-items: center; padding: 15px;
            background: rgba(0,0,0,0.3); border-radius: 10px;
            margin-bottom: 15px;
        }
        .player-side { text-align: center; }
        .player-name { font-weight: bold; color: #4fc3f7; }
        .player-move {
            width: 50px; height: 50px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; margin: 10px auto;
        }
        .cooperate { background: #4caf50; }
        .defect { background: #f44336; }
        .vs { font-size: 1.5em; color: #888; }

        .history-display {
            display: flex; gap: 2px; flex-wrap: wrap;
            max-height: 60px; overflow: hidden;
        }
        .history-move {
            width: 12px; height: 12px; border-radius: 2px;
        }

        a.back-link {
            display: inline-block; margin-bottom: 20px;
            color: #4fc3f7; text-decoration: none;
        }
        a.back-link:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Game Theory</a>
        <h1>Iterated Prisoner's Dilemma Tournament</h1>
        <p class="subtitle">Watch strategies compete in Axelrod-style tournaments</p>

        <div class="controls">
            <select id="roundsPerMatch">
                <option value="50">50 rounds/match</option>
                <option value="100" selected>100 rounds/match</option>
                <option value="200">200 rounds/match</option>
            </select>
            <input type="number" id="noiseLevel" min="0" max="20" value="0" style="width:80px" title="Noise %">
            <label style="display:flex;align-items:center;gap:5px;">
                <span>Noise:</span>
                <span id="noiseDisplay">0%</span>
            </label>
            <button id="runTournament">Run Tournament</button>
            <button id="stepMatch">Step Match</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2>Select Strategies (min 2)</h2>
                <div class="strategy-list" id="strategyList"></div>

                <h2>Payoff Matrix</h2>
                <div class="payoff-matrix">
                    <div class="payoff-cell header"></div>
                    <div class="payoff-cell header">Cooperate</div>
                    <div class="payoff-cell header">Defect</div>
                    <div class="payoff-cell header">Cooperate</div>
                    <div class="payoff-cell">3, 3</div>
                    <div class="payoff-cell">0, 5</div>
                    <div class="payoff-cell header">Defect</div>
                    <div class="payoff-cell">5, 0</div>
                    <div class="payoff-cell">1, 1</div>
                </div>

                <h2>Current Match</h2>
                <div class="match-display">
                    <div class="player-side">
                        <div class="player-name" id="player1Name">-</div>
                        <div class="player-move" id="player1Move">?</div>
                        <div id="player1Score">0</div>
                    </div>
                    <div class="vs">VS</div>
                    <div class="player-side">
                        <div class="player-name" id="player2Name">-</div>
                        <div class="player-move" id="player2Move">?</div>
                        <div id="player2Score">0</div>
                    </div>
                </div>
                <div>
                    <strong>History:</strong>
                    <div class="history-display" id="historyDisplay"></div>
                </div>
            </div>

            <div class="panel">
                <h2>Tournament Results</h2>
                <canvas id="tournamentCanvas" height="300"></canvas>
                <table class="results-table" id="resultsTable">
                    <thead>
                        <tr><th>Rank</th><th>Strategy</th><th>Total Score</th><th>Avg/Match</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Strategy definitions
        const strategies = {
            'Tit-for-Tat': {
                description: 'Cooperate first, then copy opponent',
                firstMove: () => 'C',
                nextMove: (myHistory, oppHistory) => oppHistory.length === 0 ? 'C' : oppHistory[oppHistory.length - 1]
            },
            'Always Cooperate': {
                description: 'Always cooperate',
                firstMove: () => 'C',
                nextMove: () => 'C'
            },
            'Always Defect': {
                description: 'Always defect',
                firstMove: () => 'D',
                nextMove: () => 'D'
            },
            'Grim Trigger': {
                description: 'Cooperate until opponent defects, then always defect',
                firstMove: () => 'C',
                nextMove: (myHistory, oppHistory) => oppHistory.includes('D') ? 'D' : 'C'
            },
            'Pavlov': {
                description: 'Win-stay, lose-shift',
                firstMove: () => 'C',
                nextMove: (myHistory, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    const lastMy = myHistory[myHistory.length - 1];
                    const lastOpp = oppHistory[oppHistory.length - 1];
                    // Win (CC or DC) -> repeat, Lose (CD or DD) -> switch
                    if ((lastMy === 'C' && lastOpp === 'C') || (lastMy === 'D' && lastOpp === 'C')) {
                        return lastMy;
                    }
                    return lastMy === 'C' ? 'D' : 'C';
                }
            },
            'Random': {
                description: '50% cooperate, 50% defect',
                firstMove: () => Math.random() < 0.5 ? 'C' : 'D',
                nextMove: () => Math.random() < 0.5 ? 'C' : 'D'
            },
            'Tit-for-Two-Tats': {
                description: 'Defect only after opponent defects twice in a row',
                firstMove: () => 'C',
                nextMove: (myHistory, oppHistory) => {
                    if (oppHistory.length < 2) return 'C';
                    const last2 = oppHistory.slice(-2);
                    return (last2[0] === 'D' && last2[1] === 'D') ? 'D' : 'C';
                }
            },
            'Suspicious TFT': {
                description: 'Tit-for-Tat but defect first',
                firstMove: () => 'D',
                nextMove: (myHistory, oppHistory) => oppHistory.length === 0 ? 'D' : oppHistory[oppHistory.length - 1]
            },
            'Grudger': {
                description: 'Same as Grim Trigger',
                firstMove: () => 'C',
                nextMove: (myHistory, oppHistory) => oppHistory.includes('D') ? 'D' : 'C'
            },
            'Soft Majority': {
                description: 'Cooperate if opponent cooperated >= 50%',
                firstMove: () => 'C',
                nextMove: (myHistory, oppHistory) => {
                    if (oppHistory.length === 0) return 'C';
                    const coops = oppHistory.filter(m => m === 'C').length;
                    return coops >= oppHistory.length / 2 ? 'C' : 'D';
                }
            },
            'Hard Majority': {
                description: 'Cooperate only if opponent cooperated > 50%',
                firstMove: () => 'D',
                nextMove: (myHistory, oppHistory) => {
                    if (oppHistory.length === 0) return 'D';
                    const coops = oppHistory.filter(m => m === 'C').length;
                    return coops > oppHistory.length / 2 ? 'C' : 'D';
                }
            },
            'Prober': {
                description: 'Test opponent with D,C,C then TFT or defect',
                firstMove: () => 'D',
                nextMove: (myHistory, oppHistory) => {
                    if (myHistory.length === 1) return 'C';
                    if (myHistory.length === 2) return 'C';
                    if (myHistory.length === 3) {
                        // If opponent cooperated on rounds 2 and 3, always defect
                        if (oppHistory[1] === 'C' && oppHistory[2] === 'C') return 'D';
                    }
                    if (oppHistory[1] === 'C' && oppHistory[2] === 'C') return 'D';
                    return oppHistory[oppHistory.length - 1];
                }
            }
        };

        // Payoff matrix
        const payoff = {
            'CC': [3, 3],
            'CD': [0, 5],
            'DC': [5, 0],
            'DD': [1, 1]
        };

        let selectedStrategies = ['Tit-for-Tat', 'Always Cooperate', 'Always Defect', 'Grim Trigger', 'Pavlov', 'Random'];
        let tournamentResults = {};
        let currentMatch = null;
        let matchHistory = { p1: [], p2: [] };
        let matchScores = { p1: 0, p2: 0 };
        let isRunning = false;

        const canvas = document.getElementById('tournamentCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize strategy list
        function initStrategies() {
            const list = document.getElementById('strategyList');
            list.innerHTML = '';
            for (const name of Object.keys(strategies)) {
                const item = document.createElement('div');
                item.className = 'strategy-item' + (selectedStrategies.includes(name) ? ' selected' : '');
                item.textContent = name;
                item.title = strategies[name].description;
                item.onclick = () => toggleStrategy(name, item);
                list.appendChild(item);
            }
        }

        function toggleStrategy(name, element) {
            if (selectedStrategies.includes(name)) {
                if (selectedStrategies.length > 2) {
                    selectedStrategies = selectedStrategies.filter(s => s !== name);
                    element.classList.remove('selected');
                }
            } else {
                selectedStrategies.push(name);
                element.classList.add('selected');
            }
        }

        // Run a single match between two strategies
        function runMatch(strat1, strat2, rounds, noise = 0) {
            const s1 = strategies[strat1];
            const s2 = strategies[strat2];
            const h1 = [], h2 = [];
            let score1 = 0, score2 = 0;

            for (let i = 0; i < rounds; i++) {
                let m1 = h1.length === 0 ? s1.firstMove() : s1.nextMove(h1, h2);
                let m2 = h2.length === 0 ? s2.firstMove() : s2.nextMove(h2, h1);

                // Apply noise
                if (noise > 0) {
                    if (Math.random() * 100 < noise) m1 = m1 === 'C' ? 'D' : 'C';
                    if (Math.random() * 100 < noise) m2 = m2 === 'C' ? 'D' : 'C';
                }

                h1.push(m1);
                h2.push(m2);

                const outcome = m1 + m2;
                score1 += payoff[outcome][0];
                score2 += payoff[outcome][1];
            }

            return { score1, score2, history1: h1, history2: h2 };
        }

        // Run full tournament
        async function runTournament() {
            if (isRunning) return;
            isRunning = true;
            document.getElementById('runTournament').disabled = true;

            const rounds = parseInt(document.getElementById('roundsPerMatch').value);
            const noise = parseInt(document.getElementById('noiseLevel').value);

            tournamentResults = {};
            for (const s of selectedStrategies) {
                tournamentResults[s] = { total: 0, matches: 0 };
            }

            const matchups = [];
            for (let i = 0; i < selectedStrategies.length; i++) {
                for (let j = i; j < selectedStrategies.length; j++) {
                    matchups.push([selectedStrategies[i], selectedStrategies[j]]);
                }
            }

            for (const [s1, s2] of matchups) {
                currentMatch = { s1, s2 };
                updateMatchDisplay(s1, s2);

                const result = runMatch(s1, s2, rounds, noise);

                tournamentResults[s1].total += result.score1;
                tournamentResults[s1].matches++;
                tournamentResults[s2].total += result.score2;
                tournamentResults[s2].matches++;

                // Update display
                matchHistory = { p1: result.history1, p2: result.history2 };
                matchScores = { p1: result.score1, p2: result.score2 };
                updateMatchVisual();
                updateResults();

                await new Promise(r => setTimeout(r, 100));
            }

            isRunning = false;
            document.getElementById('runTournament').disabled = false;
        }

        function updateMatchDisplay(s1, s2) {
            document.getElementById('player1Name').textContent = s1;
            document.getElementById('player2Name').textContent = s2;
        }

        function updateMatchVisual() {
            const h = matchHistory;
            if (h.p1.length > 0) {
                const last1 = h.p1[h.p1.length - 1];
                const last2 = h.p2[h.p2.length - 1];

                const m1 = document.getElementById('player1Move');
                const m2 = document.getElementById('player2Move');

                m1.textContent = last1 === 'C' ? 'ü§ù' : 'üëä';
                m1.className = 'player-move ' + (last1 === 'C' ? 'cooperate' : 'defect');

                m2.textContent = last2 === 'C' ? 'ü§ù' : 'üëä';
                m2.className = 'player-move ' + (last2 === 'C' ? 'cooperate' : 'defect');
            }

            document.getElementById('player1Score').textContent = matchScores.p1;
            document.getElementById('player2Score').textContent = matchScores.p2;

            // History display
            const histDiv = document.getElementById('historyDisplay');
            histDiv.innerHTML = '';
            for (let i = 0; i < Math.min(h.p1.length, 100); i++) {
                const div = document.createElement('div');
                div.className = 'history-move';
                div.style.background = h.p1[i] === 'C' ? '#4caf50' : '#f44336';
                histDiv.appendChild(div);
            }
        }

        function updateResults() {
            const sorted = Object.entries(tournamentResults)
                .map(([name, data]) => ({
                    name,
                    total: data.total,
                    avg: data.matches > 0 ? (data.total / data.matches).toFixed(1) : 0
                }))
                .sort((a, b) => b.total - a.total);

            const tbody = document.querySelector('#resultsTable tbody');
            tbody.innerHTML = '';

            const maxScore = sorted[0]?.total || 1;

            sorted.forEach((s, i) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${s.name}</td>
                    <td>
                        <div style="display:flex;align-items:center;gap:10px;">
                            <div class="score-bar" style="width:${(s.total/maxScore)*100}px;"></div>
                            <span>${s.total}</span>
                        </div>
                    </td>
                    <td>${s.avg}</td>
                `;
                tbody.appendChild(tr);
            });

            drawChart(sorted);
        }

        function drawChart(data) {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.offsetWidth * dpr;
            canvas.height = 300 * dpr;
            ctx.scale(dpr, dpr);

            const w = canvas.offsetWidth;
            const h = 300;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, w, h);

            if (data.length === 0) return;

            const maxScore = Math.max(...data.map(d => d.total)) || 1;
            const barWidth = (w - 40) / data.length - 10;

            data.forEach((d, i) => {
                const barHeight = (d.total / maxScore) * (h - 60);
                const x = 30 + i * (barWidth + 10);
                const y = h - 30 - barHeight;

                // Bar
                const gradient = ctx.createLinearGradient(x, y, x, h - 30);
                gradient.addColorStop(0, '#4fc3f7');
                gradient.addColorStop(1, '#0288d1');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);

                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '10px sans-serif';
                ctx.save();
                ctx.translate(x + barWidth/2, h - 25);
                ctx.rotate(-Math.PI/4);
                ctx.textAlign = 'right';
                ctx.fillText(d.name.substring(0, 12), 0, 0);
                ctx.restore();

                // Score on top
                ctx.textAlign = 'center';
                ctx.fillText(d.total, x + barWidth/2, y - 5);
            });
        }

        // Event listeners
        document.getElementById('runTournament').onclick = runTournament;
        document.getElementById('resetBtn').onclick = () => {
            tournamentResults = {};
            matchHistory = { p1: [], p2: [] };
            matchScores = { p1: 0, p2: 0 };
            updateResults();
            document.getElementById('player1Move').textContent = '?';
            document.getElementById('player2Move').textContent = '?';
            document.getElementById('historyDisplay').innerHTML = '';
        };

        document.getElementById('noiseLevel').oninput = (e) => {
            document.getElementById('noiseDisplay').textContent = e.target.value + '%';
        };

        // Initialize
        initStrategies();
        updateResults();
    </script>
</body>
</html>
