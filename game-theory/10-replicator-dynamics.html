<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replicator Dynamics - Game Theory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none;
            font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px;
            z-index: 100;
        }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; margin: 10px 0; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: 500; }
        .control-group input, .control-group select { width: 100%; padding: 8px; border-radius: 6px; }
        .control-group input[type="range"] { padding: 0; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .population-bar { height: 50px; display: flex; border-radius: 8px; overflow: hidden; margin: 15px 0; }
        .pop-segment { display: flex; align-items: center; justify-content: center; font-weight: 600; transition: width 0.3s; font-size: 0.9em; }
        .matrix-input { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin: 10px 0; }
        .matrix-input input { width: 100%; padding: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; background: rgba(0,0,0,0.3); color: #fff; }
        .matrix-label { background: rgba(74, 222, 128, 0.2); padding: 8px; text-align: center; font-weight: 600; border-radius: 4px; }
        .equilibria-list { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; margin-top: 15px; }
        .eq-item { padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .eq-item:last-child { border-bottom: none; }
        .stable { color: #4ade80; }
        .unstable { color: #f87171; }
        @media (max-width: 800px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Replicator Dynamics</h1>
    <p class="subtitle">Evolutionary game dynamics on strategy space</p>

    <div class="container">
        <div class="panel">
            <div class="info-box">
                <strong>Replicator Dynamics:</strong> Strategies that perform better than average grow;
                those below average decline. This models natural selection of strategies in a population.
                Fixed points are Nash equilibria, but only some are evolutionarily stable.
            </div>

            <h3>Phase Portrait (3 Strategies)</h3>
            <canvas id="simplexCanvas" width="500" height="450"></canvas>

            <div class="population-bar" id="popBar">
                <div class="pop-segment" id="seg1" style="width: 33%; background: #4ade80;">A: 33%</div>
                <div class="pop-segment" id="seg2" style="width: 33%; background: #22d3ee;">B: 33%</div>
                <div class="pop-segment" id="seg3" style="width: 34%; background: #f472b6;">C: 34%</div>
            </div>

            <button class="btn-primary" onclick="runDynamics()">Run Dynamics</button>
            <button class="btn-secondary" onclick="stepDynamics()">Step</button>
            <button class="btn-secondary" onclick="resetDynamics()">Reset</button>
        </div>

        <div class="panel">
            <h3>Payoff Matrix</h3>
            <p style="font-size: 0.85em; opacity: 0.7; margin-bottom: 10px;">Row plays against Column</p>

            <div class="control-group">
                <select id="presetGame" onchange="loadPreset()">
                    <option value="custom">Custom</option>
                    <option value="rps">Rock-Paper-Scissors</option>
                    <option value="coordination">Coordination</option>
                    <option value="dominance">Dominated Strategy</option>
                </select>
            </div>

            <div class="matrix-input">
                <div class="matrix-label"></div>
                <div class="matrix-label">A</div>
                <div class="matrix-label">B</div>
                <div class="matrix-label">C</div>

                <div class="matrix-label">A</div>
                <input type="number" id="m00" value="0" onchange="updateMatrix()">
                <input type="number" id="m01" value="-1" onchange="updateMatrix()">
                <input type="number" id="m02" value="1" onchange="updateMatrix()">

                <div class="matrix-label">B</div>
                <input type="number" id="m10" value="1" onchange="updateMatrix()">
                <input type="number" id="m11" value="0" onchange="updateMatrix()">
                <input type="number" id="m12" value="-1" onchange="updateMatrix()">

                <div class="matrix-label">C</div>
                <input type="number" id="m20" value="-1" onchange="updateMatrix()">
                <input type="number" id="m21" value="1" onchange="updateMatrix()">
                <input type="number" id="m22" value="0" onchange="updateMatrix()">
            </div>

            <div class="control-group">
                <label>Initial A: <span class="value-display" id="initA">33%</span></label>
                <input type="range" id="sliderA" min="1" max="98" value="33" oninput="updateInit()">
            </div>

            <div class="control-group">
                <label>Initial B: <span class="value-display" id="initB">33%</span></label>
                <input type="range" id="sliderB" min="1" max="98" value="33" oninput="updateInit()">
            </div>

            <div class="control-group">
                <label>Speed: <span class="value-display" id="speedVal">1x</span></label>
                <input type="range" id="speedSlider" min="1" max="5" value="1" oninput="document.getElementById('speedVal').textContent = this.value + 'x'">
            </div>

            <h3 style="margin-top: 20px;">Equilibria</h3>
            <div class="equilibria-list" id="equilibria">
                <div class="eq-item">Click "Run" to find equilibria...</div>
            </div>

            <h3 style="margin-top: 20px;">Time Series</h3>
            <canvas id="timeCanvas" width="400" height="150"></canvas>
        </div>
    </div>

    <script>
        const simplexCanvas = document.getElementById('simplexCanvas');
        const simplexCtx = simplexCanvas.getContext('2d');
        const timeCanvas = document.getElementById('timeCanvas');
        const timeCtx = timeCanvas.getContext('2d');

        let matrix = [
            [0, -1, 1],
            [1, 0, -1],
            [-1, 1, 0]
        ];

        let population = [0.33, 0.33, 0.34];
        let history = [];
        let running = false;
        let trajectories = [];

        const presets = {
            rps: [[0, -1, 1], [1, 0, -1], [-1, 1, 0]],
            coordination: [[2, 0, 0], [0, 2, 0], [0, 0, 2]],
            dominance: [[1, 1, 1], [0, 2, 0], [0, 0, 3]]
        };

        function loadPreset() {
            const preset = document.getElementById('presetGame').value;
            if (preset === 'custom') return;

            matrix = presets[preset].map(row => [...row]);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    document.getElementById(`m${i}${j}`).value = matrix[i][j];
                }
            }
            resetDynamics();
        }

        function updateMatrix() {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    matrix[i][j] = parseFloat(document.getElementById(`m${i}${j}`).value) || 0;
                }
            }
            document.getElementById('presetGame').value = 'custom';
            resetDynamics();
        }

        function updateInit() {
            const a = parseInt(document.getElementById('sliderA').value);
            let b = parseInt(document.getElementById('sliderB').value);
            b = Math.min(b, 99 - a);
            document.getElementById('sliderB').value = b;

            document.getElementById('initA').textContent = a + '%';
            document.getElementById('initB').textContent = b + '%';

            population = [a / 100, b / 100, (100 - a - b) / 100];
            history = [];
            updateDisplay();
            drawSimplex();
        }

        function fitness(pop) {
            const fit = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    fit[i] += matrix[i][j] * pop[j];
                }
            }
            return fit;
        }

        function stepDynamics() {
            const speed = parseInt(document.getElementById('speedSlider').value);
            const dt = 0.02 * speed;

            const fit = fitness(population);
            const avgFit = fit[0] * population[0] + fit[1] * population[1] + fit[2] * population[2];

            for (let i = 0; i < 3; i++) {
                population[i] += population[i] * (fit[i] - avgFit) * dt;
                population[i] = Math.max(0.001, Math.min(0.998, population[i]));
            }

            // Normalize
            const sum = population.reduce((a, b) => a + b, 0);
            population = population.map(p => p / sum);

            history.push([...population]);
            if (history.length > 500) history.shift();

            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('seg1').style.width = (population[0] * 100) + '%';
            document.getElementById('seg1').textContent = `A: ${Math.round(population[0] * 100)}%`;
            document.getElementById('seg2').style.width = (population[1] * 100) + '%';
            document.getElementById('seg2').textContent = `B: ${Math.round(population[1] * 100)}%`;
            document.getElementById('seg3').style.width = (population[2] * 100) + '%';
            document.getElementById('seg3').textContent = `C: ${Math.round(population[2] * 100)}%`;

            drawSimplex();
            drawTimeSeries();
        }

        function toSimplex(p) {
            // Convert [pA, pB, pC] to 2D simplex coordinates
            const h = simplexCanvas.height - 50;
            const w = simplexCanvas.width;
            const cx = w / 2;
            const cy = 30;

            const x = cx + (p[1] - p[2]) * (h * 0.5);
            const y = cy + (1 - p[0]) * h * 0.866;
            return [x, y];
        }

        function drawSimplex() {
            simplexCtx.fillStyle = '#0a0a15';
            simplexCtx.fillRect(0, 0, simplexCanvas.width, simplexCanvas.height);

            const h = simplexCanvas.height - 50;
            const w = simplexCanvas.width;
            const cx = w / 2;

            // Draw simplex triangle
            simplexCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            simplexCtx.lineWidth = 2;
            simplexCtx.beginPath();
            simplexCtx.moveTo(cx, 30);
            simplexCtx.lineTo(cx - h * 0.5, 30 + h * 0.866);
            simplexCtx.lineTo(cx + h * 0.5, 30 + h * 0.866);
            simplexCtx.closePath();
            simplexCtx.stroke();

            // Labels
            simplexCtx.fillStyle = '#4ade80';
            simplexCtx.font = 'bold 16px sans-serif';
            simplexCtx.textAlign = 'center';
            simplexCtx.fillText('A (100%)', cx, 20);
            simplexCtx.fillStyle = '#22d3ee';
            simplexCtx.fillText('B (100%)', cx - h * 0.5 - 30, 30 + h * 0.866 + 20);
            simplexCtx.fillStyle = '#f472b6';
            simplexCtx.fillText('C (100%)', cx + h * 0.5 + 30, 30 + h * 0.866 + 20);

            // Draw vector field
            simplexCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            simplexCtx.lineWidth = 1;
            for (let a = 0.1; a <= 0.9; a += 0.1) {
                for (let b = 0.1; b <= 0.9 - a; b += 0.1) {
                    const c = 1 - a - b;
                    if (c < 0.1) continue;

                    const p = [a, b, c];
                    const fit = fitness(p);
                    const avg = fit[0] * a + fit[1] * b + fit[2] * c;

                    const da = a * (fit[0] - avg) * 0.3;
                    const db = b * (fit[1] - avg) * 0.3;
                    const dc = c * (fit[2] - avg) * 0.3;

                    const [x1, y1] = toSimplex(p);
                    const [x2, y2] = toSimplex([a + da, b + db, c + dc]);

                    simplexCtx.beginPath();
                    simplexCtx.moveTo(x1, y1);
                    simplexCtx.lineTo(x2, y2);
                    simplexCtx.stroke();
                }
            }

            // Draw trajectory
            if (history.length > 1) {
                simplexCtx.strokeStyle = '#facc15';
                simplexCtx.lineWidth = 2;
                simplexCtx.beginPath();
                history.forEach((p, i) => {
                    const [x, y] = toSimplex(p);
                    if (i === 0) simplexCtx.moveTo(x, y);
                    else simplexCtx.lineTo(x, y);
                });
                simplexCtx.stroke();
            }

            // Draw current position
            const [px, py] = toSimplex(population);
            simplexCtx.fillStyle = '#fff';
            simplexCtx.beginPath();
            simplexCtx.arc(px, py, 8, 0, Math.PI * 2);
            simplexCtx.fill();
        }

        function drawTimeSeries() {
            timeCtx.fillStyle = '#0a0a15';
            timeCtx.fillRect(0, 0, timeCanvas.width, timeCanvas.height);

            if (history.length < 2) return;

            const colors = ['#4ade80', '#22d3ee', '#f472b6'];

            for (let s = 0; s < 3; s++) {
                timeCtx.strokeStyle = colors[s];
                timeCtx.lineWidth = 2;
                timeCtx.beginPath();
                history.forEach((p, i) => {
                    const x = (i / (history.length - 1)) * timeCanvas.width;
                    const y = timeCanvas.height * (1 - p[s]);
                    if (i === 0) timeCtx.moveTo(x, y);
                    else timeCtx.lineTo(x, y);
                });
                timeCtx.stroke();
            }
        }

        function findEquilibria() {
            const eq = [];

            // Pure strategy equilibria (corners)
            for (let i = 0; i < 3; i++) {
                const p = [0, 0, 0];
                p[i] = 1;
                const fit = fitness(p);
                const isStable = fit[i] >= fit[(i + 1) % 3] && fit[i] >= fit[(i + 2) % 3];
                eq.push({ type: 'Pure ' + ['A', 'B', 'C'][i], stable: isStable, p });
            }

            // Interior equilibrium (if exists)
            // For symmetric games, often at (1/3, 1/3, 1/3)
            const interior = [1/3, 1/3, 1/3];
            const fit = fitness(interior);
            if (Math.abs(fit[0] - fit[1]) < 0.01 && Math.abs(fit[1] - fit[2]) < 0.01) {
                eq.push({ type: 'Interior', stable: false, p: interior });
            }

            const eqDiv = document.getElementById('equilibria');
            eqDiv.innerHTML = eq.map(e => {
                const pStr = e.p.map(v => Math.round(v * 100) + '%').join(', ');
                return `<div class="eq-item">
                    <span class="${e.stable ? 'stable' : 'unstable'}">${e.stable ? '●' : '○'}</span>
                    ${e.type}: (${pStr})
                </div>`;
            }).join('');
        }

        async function runDynamics() {
            if (running) {
                running = false;
                return;
            }
            running = true;
            findEquilibria();

            while (running) {
                stepDynamics();
                await new Promise(r => setTimeout(r, 30));
            }
        }

        function resetDynamics() {
            running = false;
            updateInit();
            history = [];
            drawSimplex();
            drawTimeSeries();
        }

        resetDynamics();
    </script>
</body>
</html>
