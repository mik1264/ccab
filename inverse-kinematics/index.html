<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Inverse Kinematics Chain</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
a.back { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #fbbf24; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; font-family: sans-serif; }
a.back:hover { background: rgba(0,0,0,0.9); }
.title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #e2e8f0; font-size: 22px; font-weight: 700; z-index: 999; text-shadow: 0 2px 8px rgba(0,0,0,0.8); pointer-events: none; }
.controls { position: fixed; right: 15px; top: 15px; background: rgba(10,14,26,0.92); border: 1px solid rgba(251,191,36,0.25); border-radius: 12px; padding: 18px; z-index: 999; color: #cbd5e1; font-size: 13px; width: 210px; }
.controls h3 { color: #fbbf24; margin-bottom: 10px; font-size: 15px; }
.slider-group { margin-bottom: 10px; }
.slider-group label { display: flex; justify-content: space-between; margin-bottom: 3px; font-size: 11px; }
.slider-group label span.val { color: #fbbf24; font-weight: 600; }
input[type="range"] { width: 100%; accent-color: #fbbf24; cursor: pointer; }
.btn { display: inline-block; padding: 6px 12px; background: rgba(251,191,36,0.15); border: 1px solid rgba(251,191,36,0.4); border-radius: 6px; color: #fbbf24; cursor: pointer; font-size: 12px; margin: 3px 2px; }
.btn:hover { background: rgba(251,191,36,0.3); }
.info { margin-top: 10px; font-size: 11px; line-height: 1.7; border-top: 1px solid rgba(251,191,36,0.15); padding-top: 8px; }
.info .label { color: #94a3b8; }
.info .value { color: #fbbf24; font-weight: 600; }
.hint { color: #64748b; font-size: 10px; margin-top: 8px; line-height: 1.5; border-top: 1px solid rgba(251,191,36,0.1); padding-top: 6px; }
</style>
</head>
<body>
<a href="../index.html" class="back">&#8592; Back to Gallery</a>
<div class="title">Inverse Kinematics Chain</div>
<div class="controls">
    <h3>FABRIK IK</h3>
    <div class="slider-group">
        <label>Links per Chain <span class="val" id="linksVal">8</span></label>
        <input type="range" id="linksSlider" min="3" max="20" step="1" value="8">
    </div>
    <div class="slider-group">
        <label>Link Length <span class="val" id="lenVal">30</span></label>
        <input type="range" id="lenSlider" min="15" max="60" step="1" value="30">
    </div>
    <div class="slider-group">
        <label>Chains <span class="val" id="chainsVal">5</span></label>
        <input type="range" id="chainsSlider" min="1" max="12" step="1" value="5">
    </div>
    <div class="slider-group">
        <label>Joint Limit <span class="val" id="limitVal">150&deg;</span></label>
        <input type="range" id="limitSlider" min="30" max="180" step="5" value="150">
    </div>
    <div>
        <span class="btn" id="resetBtn">Reset</span>
        <span class="btn" id="autoBtn">Auto Mode</span>
    </div>
    <div class="info">
        <div><span class="label">Mouse: </span><span class="value" id="mouseStat">(0, 0)</span></div>
        <div><span class="label">Iterations: </span><span class="value" id="iterStat">10</span></div>
        <div><span class="label">Total Joints: </span><span class="value" id="jointsStat">0</span></div>
    </div>
    <div class="hint">Move your mouse - chains follow the cursor using FABRIK algorithm. Toggle Auto Mode for autonomous movement.</div>
</div>
<canvas id="canvas"></canvas>
<script>
(function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    let numLinks = 8;
    let linkLength = 30;
    let numChains = 5;
    let jointLimit = 150 * Math.PI / 180;
    let autoMode = false;
    let mouseX = W/2, mouseY = H/2;
    let targetX = W/2, targetY = H/2;
    let time = 0;

    const fabrikIterations = 10;
    let chains = [];

    const colors = [
        {h: 45, s: 90, l: 55},   // Gold
        {h: 200, s: 80, l: 55},  // Blue
        {h: 160, s: 70, l: 50},  // Teal
        {h: 280, s: 70, l: 60},  // Purple
        {h: 20, s: 85, l: 55},   // Orange
        {h: 340, s: 75, l: 55},  // Pink
        {h: 120, s: 60, l: 50},  // Green
        {h: 0, s: 80, l: 55},    // Red
        {h: 60, s: 80, l: 50},   // Yellow-green
        {h: 220, s: 80, l: 60},  // Light blue
        {h: 300, s: 70, l: 55},  // Magenta
        {h: 180, s: 70, l: 50},  // Cyan
    ];

    class Chain {
        constructor(anchorX, anchorY, numLinks, linkLen, colorIdx) {
            this.anchorX = anchorX;
            this.anchorY = anchorY;
            this.numLinks = numLinks;
            this.linkLen = linkLen;
            this.colorIdx = colorIdx;
            this.joints = [];
            this.reset();
        }

        reset() {
            this.joints = [];
            for (let i = 0; i <= this.numLinks; i++) {
                this.joints.push({
                    x: this.anchorX,
                    y: this.anchorY - i * this.linkLen
                });
            }
        }

        // FABRIK (Forward And Backward Reaching Inverse Kinematics)
        solve(targetX, targetY) {
            const joints = this.joints;
            const n = joints.length;

            for (let iter = 0; iter < fabrikIterations; iter++) {
                // Forward reaching: start from end effector
                joints[n-1].x = targetX;
                joints[n-1].y = targetY;

                for (let i = n - 2; i >= 0; i--) {
                    const dx = joints[i].x - joints[i+1].x;
                    const dy = joints[i].y - joints[i+1].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 0.001) continue;

                    let nx = dx / dist;
                    let ny = dy / dist;

                    // Joint angle constraint
                    if (i < n - 2 && jointLimit < Math.PI) {
                        const prevDx = joints[i+2].x - joints[i+1].x;
                        const prevDy = joints[i+2].y - joints[i+1].y;
                        const prevDist = Math.sqrt(prevDx*prevDx + prevDy*prevDy);
                        if (prevDist > 0.001) {
                            const pnx = prevDx / prevDist;
                            const pny = prevDy / prevDist;

                            const dot = nx * pnx + ny * pny;
                            const angle = Math.acos(Math.max(-1, Math.min(1, dot)));

                            if (angle > jointLimit) {
                                // Constrain
                                const cross = nx * pny - ny * pnx;
                                const sign = cross >= 0 ? 1 : -1;
                                const constrainedAngle = jointLimit;
                                const ca = Math.cos(constrainedAngle);
                                const sa = Math.sin(constrainedAngle) * sign;
                                nx = pnx * ca - pny * sa;
                                ny = pnx * sa + pny * ca;
                            }
                        }
                    }

                    joints[i].x = joints[i+1].x + nx * this.linkLen;
                    joints[i].y = joints[i+1].y + ny * this.linkLen;
                }

                // Backward reaching: start from anchor
                joints[0].x = this.anchorX;
                joints[0].y = this.anchorY;

                for (let i = 1; i < n; i++) {
                    const dx = joints[i].x - joints[i-1].x;
                    const dy = joints[i].y - joints[i-1].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 0.001) continue;

                    let nx = dx / dist;
                    let ny = dy / dist;

                    // Joint angle constraint
                    if (i >= 2 && jointLimit < Math.PI) {
                        const prevDx = joints[i-2].x - joints[i-1].x;
                        const prevDy = joints[i-2].y - joints[i-1].y;
                        const prevDist = Math.sqrt(prevDx*prevDx + prevDy*prevDy);
                        if (prevDist > 0.001) {
                            const pnx = prevDx / prevDist;
                            const pny = prevDy / prevDist;

                            const dot = nx * pnx + ny * pny;
                            const angle = Math.acos(Math.max(-1, Math.min(1, dot)));

                            if (angle > jointLimit) {
                                const cross = nx * pny - ny * pnx;
                                const sign = cross >= 0 ? 1 : -1;
                                const ca = Math.cos(jointLimit);
                                const sa = Math.sin(jointLimit) * sign;
                                nx = pnx * ca - pny * sa;
                                ny = pnx * sa + pny * ca;
                            }
                        }
                    }

                    joints[i].x = joints[i-1].x + nx * this.linkLen;
                    joints[i].y = joints[i-1].y + ny * this.linkLen;
                }
            }
        }

        draw() {
            const joints = this.joints;
            const c = colors[this.colorIdx % colors.length];
            const baseColor = `hsl(${c.h}, ${c.s}%, ${c.l}%)`;
            const dimColor = `hsla(${c.h}, ${c.s}%, ${c.l}%, 0.3)`;
            const glowColor = `hsla(${c.h}, ${c.s}%, ${c.l}%, 0.1)`;

            // Links
            for (let i = 0; i < joints.length - 1; i++) {
                const t = i / (joints.length - 1);
                const width = 6 - t * 4; // Taper

                // Glow
                ctx.strokeStyle = glowColor;
                ctx.lineWidth = width + 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(joints[i].x, joints[i].y);
                ctx.lineTo(joints[i+1].x, joints[i+1].y);
                ctx.stroke();

                // Link
                const linkAlpha = 0.4 + t * 0.6;
                ctx.strokeStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${linkAlpha})`;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(joints[i].x, joints[i].y);
                ctx.lineTo(joints[i+1].x, joints[i+1].y);
                ctx.stroke();
            }
            ctx.lineCap = 'butt';

            // Joints
            for (let i = 0; i < joints.length; i++) {
                const t = i / (joints.length - 1);
                const r = 4 - t * 2.5;

                if (i === 0) {
                    // Anchor
                    ctx.fillStyle = 'rgba(15,20,40,0.8)';
                    ctx.strokeStyle = baseColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(joints[i].x, joints[i].y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (i === joints.length - 1) {
                    // End effector
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.arc(joints[i].x, joints[i].y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Glow
                    ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, 0.2)`;
                    ctx.beginPath();
                    ctx.arc(joints[i].x, joints[i].y, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Regular joint
                    ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${0.3 + t * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(joints[i].x, joints[i].y, Math.max(1.5, r), 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    }

    function createChains() {
        chains = [];
        const spacing = W / (numChains + 1);
        for (let i = 0; i < numChains; i++) {
            const x = spacing * (i + 1);
            const y = H * 0.85;
            chains.push(new Chain(x, y, numLinks, linkLength, i));
        }
    }

    // Event listeners
    canvas.addEventListener('mousemove', function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
    }, {passive: false});

    document.getElementById('linksSlider').oninput = function() {
        numLinks = parseInt(this.value);
        document.getElementById('linksVal').textContent = numLinks;
        createChains();
    };
    document.getElementById('lenSlider').oninput = function() {
        linkLength = parseInt(this.value);
        document.getElementById('lenVal').textContent = linkLength;
        createChains();
    };
    document.getElementById('chainsSlider').oninput = function() {
        numChains = parseInt(this.value);
        document.getElementById('chainsVal').textContent = numChains;
        createChains();
    };
    document.getElementById('limitSlider').oninput = function() {
        jointLimit = parseInt(this.value) * Math.PI / 180;
        document.getElementById('limitVal').textContent = parseInt(this.value) + '\u00B0';
    };

    document.getElementById('resetBtn').onclick = function() {
        createChains();
    };

    document.getElementById('autoBtn').onclick = function() {
        autoMode = !autoMode;
        this.textContent = autoMode ? 'Mouse Mode' : 'Auto Mode';
    };

    createChains();

    function drawTarget(x, y) {
        const t = Date.now() / 1000;
        const pulse = 0.5 + 0.3 * Math.sin(t * 3);

        // Outer glow
        ctx.fillStyle = `rgba(251,191,36,${pulse * 0.15})`;
        ctx.beginPath();
        ctx.arc(x, y, 16, 0, Math.PI * 2);
        ctx.fill();

        // Center dot
        ctx.fillStyle = `rgba(251,191,36,${pulse})`;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();

        // Crosshair
        ctx.strokeStyle = `rgba(251,191,36,${pulse * 0.6})`;
        ctx.lineWidth = 1;
        const s = 10;
        ctx.beginPath();
        ctx.moveTo(x - s, y); ctx.lineTo(x - 4, y);
        ctx.moveTo(x + 4, y); ctx.lineTo(x + s, y);
        ctx.moveTo(x, y - s); ctx.lineTo(x, y - 4);
        ctx.moveTo(x, y + 4); ctx.lineTo(x, y + s);
        ctx.stroke();
    }

    function drawAnchors() {
        // Draw base surface
        ctx.fillStyle = 'rgba(30,41,59,0.5)';
        ctx.fillRect(0, H * 0.85 - 3, W, 6);
        ctx.strokeStyle = 'rgba(251,191,36,0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, H * 0.85);
        ctx.lineTo(W, H * 0.85);
        ctx.stroke();

        // Tick marks
        for (let i = 0; i < W; i += 40) {
            ctx.strokeStyle = 'rgba(100,120,180,0.1)';
            ctx.beginPath();
            ctx.moveTo(i, H * 0.85 - 4);
            ctx.lineTo(i, H * 0.85 + 4);
            ctx.stroke();
        }
    }

    function animate() {
        ctx.clearRect(0, 0, W, H);

        const bg = ctx.createRadialGradient(W/2, H/3, 0, W/2, H/2, Math.max(W,H)*0.7);
        bg.addColorStop(0, '#111827');
        bg.addColorStop(1, '#0a0e1a');
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);

        time += 1/60;

        // Auto mode: move target in interesting pattern
        if (autoMode) {
            const cx = W / 2;
            const cy = H * 0.4;
            const rx = W * 0.35;
            const ry = H * 0.25;
            targetX = cx + Math.sin(time * 0.7) * rx * Math.cos(time * 0.3);
            targetY = cy + Math.cos(time * 0.5) * ry + Math.sin(time * 1.1) * ry * 0.3;
        } else {
            // Smooth follow mouse
            targetX += (mouseX - targetX) * 0.15;
            targetY += (mouseY - targetY) * 0.15;
        }

        drawAnchors();

        // Solve and draw all chains
        chains.forEach(chain => {
            chain.solve(targetX, targetY);
        });

        // Draw chains (back to front for layering)
        chains.forEach(chain => {
            chain.draw();
        });

        drawTarget(targetX, targetY);

        // Update stats
        document.getElementById('mouseStat').textContent = `(${Math.round(targetX)}, ${Math.round(targetY)})`;
        document.getElementById('iterStat').textContent = fabrikIterations;
        document.getElementById('jointsStat').textContent = chains.length * (numLinks + 1);

        requestAnimationFrame(animate);
    }

    animate();
})();
</script>
</body>
</html>
