<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metronome Synchronization | Time & Clocks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background: #0a0e1a;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f4a261;
            text-decoration: none;
            font-size: 16px;
            font-weight: 600;
            z-index: 100;
            padding: 10px 20px;
            background: rgba(244, 162, 97, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(244, 162, 97, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(244, 162, 97, 0.2);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 40, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(244, 162, 97, 0.3);
            z-index: 100;
            min-width: 280px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #f4a261;
            font-size: 13px;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .value-display {
            color: #e76f51;
            font-size: 14px;
            font-weight: 600;
        }

        button {
            width: 100%;
            padding: 10px;
            background: rgba(244, 162, 97, 0.2);
            border: 1px solid rgba(244, 162, 97, 0.5);
            color: #f4a261;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(244, 162, 97, 0.3);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 40, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(244, 162, 97, 0.3);
            z-index: 100;
            max-width: 350px;
        }

        .info-title {
            color: #f4a261;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .info-text {
            color: #e0e0e0;
            font-size: 12px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Time & Clocks</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>Platform Coupling: <span class="value-display" id="couplingValue">0.50</span></label>
            <input type="range" id="coupling" min="0" max="100" value="50" step="1">
        </div>
        <div class="control-group">
            <label>Number of Metronomes: <span class="value-display" id="numValue">8</span></label>
            <input type="range" id="numMetronomes" min="3" max="15" value="8" step="1">
        </div>
        <div class="control-group">
            <label>Platform Mass: <span class="value-display" id="massValue">5.0</span></label>
            <input type="range" id="platformMass" min="10" max="200" value="50" step="1">
        </div>
        <div class="control-group">
            <button id="resetBtn">Randomize Phases</button>
        </div>
    </div>

    <div class="info">
        <div class="info-title">Mechanical Synchronization</div>
        <div class="info-text">
            Metronomes on a moving platform synchronize through mechanical coupling.
            Each swing transfers momentum to the platform, which feeds back to all metronomes.
            Watch them transition from chaos to perfect unison!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let metronomes = [];
        let platformX = 0;
        let platformVX = 0;
        let platformMass = 5.0;
        let coupling = 0.5;
        let numMetronomes = 8;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        class Metronome {
            constructor(x, index) {
                this.baseX = x;
                this.index = index;
                this.angle = (Math.random() - 0.5) * Math.PI * 0.7; // Random initial phase
                this.angularVelocity = 0;
                this.length = 120;
                this.mass = 1.0;
                this.gravity = 9.8;
                // Slight frequency variation
                this.frequencyMod = 0.98 + Math.random() * 0.04;
            }

            update(dt, platformAccel) {
                // Pendulum equation with platform coupling
                const omega0 = Math.sqrt(this.gravity / this.length) * this.frequencyMod;
                const damping = 0.05;

                // Platform motion affects pendulum (fictitious force)
                const platformEffect = platformAccel * Math.cos(this.angle) * coupling;

                const angularAccel = -omega0 * omega0 * Math.sin(this.angle)
                                   - damping * this.angularVelocity
                                   + platformEffect;

                this.angularVelocity += angularAccel * dt;
                this.angle += this.angularVelocity * dt;

                // Limit angle
                if(Math.abs(this.angle) > Math.PI * 0.8) {
                    this.angle = Math.sign(this.angle) * Math.PI * 0.8;
                    this.angularVelocity *= -0.8; // Bounce with damping
                }
            }

            getForceToPlatform() {
                // Horizontal force component that metronome exerts on platform
                return this.mass * this.length * this.angularVelocity * this.angularVelocity * Math.sin(this.angle);
            }
        }

        function initMetronomes() {
            metronomes = [];
            const spacing = Math.min(120, (width - 200) / numMetronomes);
            const startX = width / 2 - (numMetronomes - 1) * spacing / 2;

            for(let i = 0; i < numMetronomes; i++) {
                metronomes.push(new Metronome(startX + i * spacing, i));
            }
        }

        function update(dt) {
            // Calculate total force on platform from all metronomes
            let totalForce = 0;
            for(let metro of metronomes) {
                totalForce += metro.getForceToPlatform();
            }

            // Platform physics
            const platformDamping = 0.1;
            const platformAccel = (totalForce * coupling - platformDamping * platformVX) / platformMass;
            platformVX += platformAccel * dt;
            platformX += platformVX * dt;

            // Limit platform motion
            const maxPlatformX = 30;
            if(Math.abs(platformX) > maxPlatformX) {
                platformX = Math.sign(platformX) * maxPlatformX;
                platformVX *= -0.5;
            }

            // Update all metronomes
            for(let metro of metronomes) {
                metro.update(dt, platformAccel);
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            const platformY = height / 2;
            const platformWidth = numMetronomes * 120 + 100;
            const platformHeight = 20;
            const platformDrawX = width / 2 - platformWidth / 2 + platformX;

            // Draw platform
            ctx.fillStyle = '#2a3040';
            ctx.fillRect(platformDrawX, platformY, platformWidth, platformHeight);

            ctx.strokeStyle = '#f4a261';
            ctx.lineWidth = 2;
            ctx.strokeRect(platformDrawX, platformY, platformWidth, platformHeight);

            // Draw support springs
            const numSprings = 8;
            for(let i = 0; i < numSprings; i++) {
                const springX = platformDrawX + (i / (numSprings - 1)) * platformWidth;
                const springY = platformY + platformHeight;
                const springHeight = 40;

                ctx.strokeStyle = 'rgba(244, 162, 97, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(springX, springY);

                // Zigzag spring
                const zigzags = 6;
                const zigWidth = 10;
                for(let j = 0; j <= zigzags; j++) {
                    const x = springX + (j % 2 === 0 ? -zigWidth : zigWidth);
                    const y = springY + (j / zigzags) * springHeight;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw metronomes
            for(let metro of metronomes) {
                const baseX = metro.baseX + platformX;
                const baseY = platformY;

                // Metronome body
                ctx.fillStyle = '#3a4050';
                ctx.fillRect(baseX - 15, baseY - 80, 30, 80);

                ctx.strokeStyle = '#f4a261';
                ctx.lineWidth = 2;
                ctx.strokeRect(baseX - 15, baseY - 80, 30, 80);

                // Pendulum arm
                const armEndX = baseX + Math.sin(metro.angle) * metro.length;
                const armEndY = baseY - Math.cos(metro.angle) * metro.length;

                ctx.strokeStyle = '#e76f51';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY - 40);
                ctx.lineTo(armEndX, armEndY);
                ctx.stroke();

                // Pendulum bob
                const bobRadius = 12;
                const gradient = ctx.createRadialGradient(armEndX, armEndY, 0, armEndX, armEndY, bobRadius);
                gradient.addColorStop(0, '#f4a261');
                gradient.addColorStop(1, '#e76f51');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(armEndX, armEndY, bobRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#d6956f';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw phase diagram at bottom
            const phaseY = height - 80;
            const phaseRadius = 30;
            const phaseSpacing = Math.min(80, (width - 100) / numMetronomes);
            const phaseStartX = width / 2 - (numMetronomes - 1) * phaseSpacing / 2;

            ctx.fillStyle = '#f4a261';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Phase Circles', width / 2, phaseY - 50);

            for(let i = 0; i < metronomes.length; i++) {
                const metro = metronomes[i];
                const x = phaseStartX + i * phaseSpacing;

                // Circle
                ctx.strokeStyle = 'rgba(244, 162, 97, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, phaseY, phaseRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Phase indicator
                const phase = metro.angle;
                const indicatorX = x + Math.sin(phase) * phaseRadius * 0.8;
                const indicatorY = phaseY - Math.cos(phase) * phaseRadius * 0.8;

                ctx.fillStyle = '#e76f51';
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
                ctx.fill();

                // Line from center
                ctx.strokeStyle = '#e76f51';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, phaseY);
                ctx.lineTo(indicatorX, indicatorY);
                ctx.stroke();
            }

            // Calculate and display phase coherence
            let sumSin = 0, sumCos = 0;
            for(let metro of metronomes) {
                sumSin += Math.sin(metro.angle);
                sumCos += Math.cos(metro.angle);
            }
            const coherence = Math.sqrt(sumSin * sumSin + sumCos * sumCos) / metronomes.length;

            ctx.fillStyle = '#f4a261';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Synchronization: ${(coherence * 100).toFixed(1)}%`, 30, height - 30);

            // Platform motion indicator
            ctx.fillStyle = '#e76f51';
            ctx.fillText(`Platform Position: ${platformX.toFixed(1)} px`, 30, height - 10);
        }

        let lastTime = performance.now();
        function animate(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.02);
            lastTime = currentTime;

            update(dt);
            draw();

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('coupling').addEventListener('input', (e) => {
            coupling = parseFloat(e.target.value) / 100;
            document.getElementById('couplingValue').textContent = coupling.toFixed(2);
        });

        document.getElementById('numMetronomes').addEventListener('input', (e) => {
            numMetronomes = parseInt(e.target.value);
            document.getElementById('numValue').textContent = numMetronomes;
            initMetronomes();
        });

        document.getElementById('platformMass').addEventListener('input', (e) => {
            platformMass = parseFloat(e.target.value) / 10;
            document.getElementById('massValue').textContent = platformMass.toFixed(1);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initMetronomes();
            platformX = 0;
            platformVX = 0;
        });

        window.addEventListener('resize', resize);

        resize();
        initMetronomes();
        animate(performance.now());
    </script>
</body>
</html>
