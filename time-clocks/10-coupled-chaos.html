<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coupled Chaos - Lorenz Attractors | Time & Clocks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background: #0a0e1a;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f4a261;
            text-decoration: none;
            font-size: 16px;
            font-weight: 600;
            z-index: 100;
            padding: 10px 20px;
            background: rgba(244, 162, 97, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(244, 162, 97, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(244, 162, 97, 0.2);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 40, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(244, 162, 97, 0.3);
            z-index: 100;
            min-width: 280px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #f4a261;
            font-size: 13px;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .value-display {
            color: #e76f51;
            font-size: 14px;
            font-weight: 600;
        }

        button {
            width: 100%;
            padding: 10px;
            background: rgba(244, 162, 97, 0.2);
            border: 1px solid rgba(244, 162, 97, 0.5);
            color: #f4a261;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(244, 162, 97, 0.3);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 25, 40, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(244, 162, 97, 0.3);
            z-index: 100;
            max-width: 350px;
        }

        .info-title {
            color: #f4a261;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .info-text {
            color: #e0e0e0;
            font-size: 12px;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .sync-status {
            font-size: 18px;
            color: #e76f51;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Time & Clocks</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>Coupling Strength: <span class="value-display" id="couplingValue">0.00</span></label>
            <input type="range" id="coupling" min="0" max="100" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Sigma (σ): <span class="value-display" id="sigmaValue">10.0</span></label>
            <input type="range" id="sigma" min="5" max="20" value="10" step="0.5">
        </div>
        <div class="control-group">
            <label>Rho (ρ): <span class="value-display" id="rhoValue">28.0</span></label>
            <input type="range" id="rho" min="20" max="35" value="28" step="0.5">
        </div>
        <div class="control-group">
            <label>Beta (β): <span class="value-display" id="betaValue">2.67</span></label>
            <input type="range" id="beta" min="1" max="5" value="2.67" step="0.1">
        </div>
        <div class="control-group">
            <button id="resetBtn">Reset Attractors</button>
        </div>
    </div>

    <div class="info">
        <div class="info-title">Chaos Synchronization</div>
        <div class="sync-status" id="syncStatus">Unsynchronized</div>
        <div class="info-text">
            Distance: <span style="color: #e76f51; font-weight: 600;" id="distance">-</span>
        </div>
        <div class="info-text">
            Two chaotic Lorenz attractors with different initial conditions.
            When coupled, they synchronize despite their chaotic behavior - the strange
            attractor becomes a common clock.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // Lorenz system parameters
        let sigma = 10.0;
        let rho = 28.0;
        let beta = 8.0 / 3.0;
        let coupling = 0.0;

        class LorenzAttractor {
            constructor(x0, y0, z0, color) {
                this.x = x0;
                this.y = y0;
                this.z = z0;
                this.color = color;
                this.trail = [];
                this.maxTrail = 1000;
            }

            update(dt, otherX, otherY, otherZ) {
                // Lorenz equations with coupling
                const dx = sigma * (this.y - this.x) + coupling * (otherX - this.x);
                const dy = this.x * (rho - this.z) - this.y + coupling * (otherY - this.y);
                const dz = this.x * this.y - beta * this.z + coupling * (otherZ - this.z);

                // RK4 integration
                const steps = 5;
                const h = dt / steps;

                for(let i = 0; i < steps; i++) {
                    this.x += dx * h;
                    this.y += dy * h;
                    this.z += dz * h;
                }

                // Store trail
                this.trail.push({ x: this.x, y: this.y, z: this.z });
                if(this.trail.length > this.maxTrail) {
                    this.trail.shift();
                }
            }

            reset(x0, y0, z0) {
                this.x = x0;
                this.y = y0;
                this.z = z0;
                this.trail = [];
            }
        }

        let attractor1 = new LorenzAttractor(1, 1, 1, '#f4a261');
        let attractor2 = new LorenzAttractor(1.01, 1.01, 1.01, '#e76f51');

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function update(dt) {
            // Update both attractors with coupling
            const a1x = attractor1.x, a1y = attractor1.y, a1z = attractor1.z;
            const a2x = attractor2.x, a2y = attractor2.y, a2z = attractor2.z;

            attractor1.update(dt, a2x, a2y, a2z);
            attractor2.update(dt, a1x, a1y, a1z);

            // Calculate synchronization error
            const dx = attractor1.x - attractor2.x;
            const dy = attractor1.y - attractor2.y;
            const dz = attractor1.z - attractor2.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            document.getElementById('distance').textContent = distance.toFixed(3);

            const isSynced = distance < 1.0;
            document.getElementById('syncStatus').textContent = isSynced ? 'SYNCHRONIZED' : 'Unsynchronized';
            document.getElementById('syncStatus').style.color = isSynced ? '#4ade80' : '#e76f51';
        }

        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            // Draw 3D attractors
            drawAttractor3D(width / 4, height / 2 - 50, 350, 400, attractor1, 'Attractor 1');
            drawAttractor3D(3 * width / 4, height / 2 - 50, 350, 400, attractor2, 'Attractor 2');

            // Draw phase space projections
            drawProjection(width / 2 - 250, height - 220, 200, 200, 'XY');
            drawProjection(width / 2 - 20, height - 220, 200, 200, 'XZ');
            drawProjection(width / 2 + 210, height - 220, 200, 200, 'YZ');

            // Draw time series
            drawTimeSeries(100, 80, 350, 150);
        }

        function drawAttractor3D(x, y, w, h, attractor, label) {
            ctx.save();
            ctx.translate(x, y);

            // Background
            ctx.fillStyle = 'rgba(20, 25, 40, 0.3)';
            ctx.fillRect(-w / 2, -h / 2, w, h);

            // 3D projection parameters
            const scale = 5;
            const rotationY = performance.now() * 0.0002;

            // Draw trail
            if(attractor.trail.length > 1) {
                for(let i = 0; i < attractor.trail.length - 1; i++) {
                    const p1 = attractor.trail[i];
                    const p2 = attractor.trail[i + 1];

                    // 3D to 2D projection with rotation
                    const p1x = p1.x * Math.cos(rotationY) - p1.z * Math.sin(rotationY);
                    const p1y = p1.y;
                    const p1z = p1.x * Math.sin(rotationY) + p1.z * Math.cos(rotationY);

                    const p2x = p2.x * Math.cos(rotationY) - p2.z * Math.sin(rotationY);
                    const p2y = p2.y;
                    const p2z = p2.x * Math.sin(rotationY) + p2.z * Math.cos(rotationY);

                    const sx1 = p1x * scale;
                    const sy1 = -p1y * scale;
                    const sx2 = p2x * scale;
                    const sy2 = -p2y * scale;

                    const alpha = (i / attractor.trail.length) * 0.8;
                    ctx.strokeStyle = attractor.color.replace(')', `, ${alpha})`);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(sx1, sy1);
                    ctx.lineTo(sx2, sy2);
                    ctx.stroke();
                }

                // Current position
                const current = attractor.trail[attractor.trail.length - 1];
                const cx = (current.x * Math.cos(rotationY) - current.z * Math.sin(rotationY)) * scale;
                const cy = -current.y * scale;

                ctx.fillStyle = attractor.color;
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();

            // Label
            ctx.fillStyle = attractor.color;
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - h / 2 - 15);
        }

        function drawProjection(x, y, w, h, plane) {
            ctx.fillStyle = 'rgba(20, 25, 40, 0.5)';
            ctx.fillRect(x, y, w, h);

            ctx.strokeStyle = 'rgba(244, 162, 97, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);

            // Axes
            ctx.strokeStyle = 'rgba(244, 162, 97, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + w / 2, y);
            ctx.lineTo(x + w / 2, y + h);
            ctx.moveTo(x, y + h / 2);
            ctx.lineTo(x + w, y + h / 2);
            ctx.stroke();

            const scale = 3;
            const centerX = x + w / 2;
            const centerY = y + h / 2;

            // Draw both attractors
            [attractor1, attractor2].forEach(attractor => {
                if(attractor.trail.length > 1) {
                    for(let i = 0; i < attractor.trail.length - 1; i++) {
                        const p1 = attractor.trail[i];
                        const p2 = attractor.trail[i + 1];

                        let px1, py1, px2, py2;

                        if(plane === 'XY') {
                            px1 = centerX + p1.x * scale;
                            py1 = centerY - p1.y * scale;
                            px2 = centerX + p2.x * scale;
                            py2 = centerY - p2.y * scale;
                        } else if(plane === 'XZ') {
                            px1 = centerX + p1.x * scale;
                            py1 = centerY - p1.z * scale;
                            px2 = centerX + p2.x * scale;
                            py2 = centerY - p2.z * scale;
                        } else { // YZ
                            px1 = centerX + p1.y * scale;
                            py1 = centerY - p1.z * scale;
                            px2 = centerX + p2.y * scale;
                            py2 = centerY - p2.z * scale;
                        }

                        const alpha = (i / attractor.trail.length) * 0.3;
                        ctx.strokeStyle = attractor.color.replace(')', `, ${alpha})`);
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(px1, py1);
                        ctx.lineTo(px2, py2);
                        ctx.stroke();
                    }
                }
            });

            // Label
            ctx.fillStyle = '#f4a261';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${plane} Plane`, x + w / 2, y - 5);
        }

        let timeSeriesData = { t: [], diff: [] };
        const maxTimeSeries = 300;

        function drawTimeSeries(x, y, w, h) {
            ctx.fillStyle = 'rgba(20, 25, 40, 0.5)';
            ctx.fillRect(x, y, w, h);

            ctx.strokeStyle = 'rgba(244, 162, 97, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);

            // Calculate difference
            const dx = attractor1.x - attractor2.x;
            const dy = attractor1.y - attractor2.y;
            const dz = attractor1.z - attractor2.z;
            const diff = Math.sqrt(dx * dx + dy * dy + dz * dz);

            timeSeriesData.diff.push(diff);
            if(timeSeriesData.diff.length > maxTimeSeries) {
                timeSeriesData.diff.shift();
            }

            // Grid
            ctx.strokeStyle = 'rgba(244, 162, 97, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i <= 4; i++) {
                const py = y + (i / 4) * h;
                ctx.beginPath();
                ctx.moveTo(x, py);
                ctx.lineTo(x + w, py);
                ctx.stroke();
            }

            // Draw time series
            if(timeSeriesData.diff.length > 1) {
                const maxDiff = Math.max(...timeSeriesData.diff, 10);

                ctx.strokeStyle = '#e76f51';
                ctx.lineWidth = 3;
                ctx.beginPath();

                for(let i = 0; i < timeSeriesData.diff.length; i++) {
                    const px = x + (i / timeSeriesData.diff.length) * w;
                    const py = y + h - (timeSeriesData.diff[i] / maxDiff) * (h - 20);

                    if(i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }

                ctx.stroke();
            }

            // Threshold line
            ctx.strokeStyle = 'rgba(74, 222, 128, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(x, y + h - 20);
            ctx.lineTo(x + w, y + h - 20);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label
            ctx.fillStyle = '#f4a261';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Synchronization Error Over Time', x + w / 2, y - 5);

            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Synced', x + 5, y + h - 25);
        }

        let lastTime = performance.now();
        function animate(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
            lastTime = currentTime;

            update(dt * 0.5); // Slow down for visibility
            draw();

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('coupling').addEventListener('input', (e) => {
            coupling = parseFloat(e.target.value) / 100;
            document.getElementById('couplingValue').textContent = coupling.toFixed(2);
        });

        document.getElementById('sigma').addEventListener('input', (e) => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = sigma.toFixed(1);
        });

        document.getElementById('rho').addEventListener('input', (e) => {
            rho = parseFloat(e.target.value);
            document.getElementById('rhoValue').textContent = rho.toFixed(1);
        });

        document.getElementById('beta').addEventListener('input', (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('betaValue').textContent = beta.toFixed(2);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            attractor1.reset(1, 1, 1);
            attractor2.reset(1.01, 1.01, 1.01);
            timeSeriesData = { t: [], diff: [] };
        });

        window.addEventListener('resize', resize);

        resize();
        animate(performance.now());
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
