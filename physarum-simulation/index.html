<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physarum Slime Mold Simulation - CCAB</title>
    <meta name="description" content="Interactive WebGL simulation of Physarum polycephalum slime mold based on Jeff Jones' research paper. Agent-based particles leave pheromone trails creating organic network patterns.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.7);
            color: #8ecae6;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(142, 202, 230, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(142, 202, 230, 0.2);
            transform: translateX(-4px);
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 18px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(142, 202, 230, 0.2);
        }

        .control-group label {
            color: #8ecae6;
            font-size: 12px;
            display: block;
            margin-bottom: 6px;
        }

        .control-group input[type="range"] {
            width: 120px;
            accent-color: #8ecae6;
        }

        .control-group span {
            color: #fff;
            font-size: 11px;
            margin-left: 8px;
        }

        button {
            background: rgba(142, 202, 230, 0.2);
            border: 1px solid rgba(142, 202, 230, 0.5);
            color: #8ecae6;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(142, 202, 230, 0.4);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: #8ecae6;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(142, 202, 230, 0.2);
            z-index: 1000;
        }

        #info h3 {
            margin-bottom: 8px;
            font-weight: 600;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8ecae6;
            font-size: 18px;
            z-index: 2000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(142, 202, 230, 0.2);
            border-top-color: #8ecae6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200, 50, 50, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 3000;
            max-width: 80vw;
        }

        #preset-buttons {
            position: fixed;
            top: 80px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        #preset-buttons button {
            font-size: 11px;
            padding: 8px 12px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="loading">
        <div class="spinner"></div>
        <p>Initializing Physarum...</p>
    </div>

    <div id="error">
        <h2>WebGL2 Required</h2>
        <p id="error-msg">This simulation requires WebGL2 support.</p>
    </div>

    <div id="info">
        <h3>Physarum Simulation</h3>
        <div>Agents: <span id="agent-count">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div style="margin-top:8px;font-size:10px;opacity:0.7">Click/drag to add agents</div>
    </div>

    <div id="preset-buttons">
        <button onclick="loadPreset('network')">Network</button>
        <button onclick="loadPreset('tendrils')">Tendrils</button>
        <button onclick="loadPreset('coral')">Coral</button>
        <button onclick="loadPreset('veins')">Veins</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Sensor Angle (SA)</label>
            <input type="range" id="sensorAngle" min="5" max="90" value="22.5">
            <span id="sensorAngleVal">22.5°</span>
        </div>
        <div class="control-group">
            <label>Sensor Distance (SO)</label>
            <input type="range" id="sensorDist" min="1" max="50" value="9">
            <span id="sensorDistVal">9</span>
        </div>
        <div class="control-group">
            <label>Rotation Angle (RA)</label>
            <input type="range" id="rotationAngle" min="5" max="90" value="45">
            <span id="rotationAngleVal">45°</span>
        </div>
        <div class="control-group">
            <label>Step Size (SS)</label>
            <input type="range" id="stepSize" min="0.5" max="5" step="0.1" value="1">
            <span id="stepSizeVal">1</span>
        </div>
        <div class="control-group">
            <label>Decay Rate</label>
            <input type="range" id="decayRate" min="0.9" max="0.999" step="0.001" value="0.97">
            <span id="decayRateVal">0.97</span>
        </div>
        <button onclick="resetSimulation()">Reset</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
    // Physarum Polycephalum Slime Mold Simulation
    // Based on Jeff Jones' 2010 paper on Physarum Transport Networks
    // Implementation uses WebGL2 for GPU-accelerated agent simulation

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        throw new Error('WebGL2 not supported');
    }

    // Check for required extensions
    const ext = gl.getExtension('EXT_color_buffer_float');
    if (!ext) {
        console.warn('EXT_color_buffer_float not available, using fallback');
    }

    // Configuration
    let config = {
        numAgents: 500000,
        sensorAngle: 22.5,      // SA - sensor angle in degrees
        sensorDistance: 9,       // SO - sensor offset/distance
        rotationAngle: 45,       // RA - rotation angle in degrees
        stepSize: 1.0,           // SS - movement step size
        decayRate: 0.97,         // Trail decay factor
        diffuseRate: 1.0,        // Trail diffusion
        depositAmount: 5.0       // Trail deposit amount
    };

    // Presets for different visual effects
    const presets = {
        network: { sensorAngle: 22.5, sensorDistance: 9, rotationAngle: 45, stepSize: 1, decayRate: 0.97 },
        tendrils: { sensorAngle: 45, sensorDistance: 20, rotationAngle: 22.5, stepSize: 1.5, decayRate: 0.95 },
        coral: { sensorAngle: 15, sensorDistance: 5, rotationAngle: 60, stepSize: 0.8, decayRate: 0.98 },
        veins: { sensorAngle: 30, sensorDistance: 15, rotationAngle: 30, stepSize: 1.2, decayRate: 0.96 }
    };

    function loadPreset(name) {
        const p = presets[name];
        config.sensorAngle = p.sensorAngle;
        config.sensorDistance = p.sensorDistance;
        config.rotationAngle = p.rotationAngle;
        config.stepSize = p.stepSize;
        config.decayRate = p.decayRate;
        updateControlsUI();
    }

    function updateControlsUI() {
        document.getElementById('sensorAngle').value = config.sensorAngle;
        document.getElementById('sensorAngleVal').textContent = config.sensorAngle + '°';
        document.getElementById('sensorDist').value = config.sensorDistance;
        document.getElementById('sensorDistVal').textContent = config.sensorDistance;
        document.getElementById('rotationAngle').value = config.rotationAngle;
        document.getElementById('rotationAngleVal').textContent = config.rotationAngle + '°';
        document.getElementById('stepSize').value = config.stepSize;
        document.getElementById('stepSizeVal').textContent = config.stepSize;
        document.getElementById('decayRate').value = config.decayRate;
        document.getElementById('decayRateVal').textContent = config.decayRate;
    }

    // Shader sources
    const agentVertexShader = `#version 300 es
        in vec2 a_position;
        void main() {
            gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
            gl_PointSize = 1.0;
        }
    `;

    const agentFragmentShader = `#version 300 es
        precision highp float;
        out vec4 outColor;
        void main() {
            outColor = vec4(1.0);
        }
    `;

    // Agent update compute shader (transform feedback)
    const agentUpdateVertexShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_trailMap;
        uniform vec2 u_resolution;
        uniform float u_sensorAngle;
        uniform float u_sensorDistance;
        uniform float u_rotationAngle;
        uniform float u_stepSize;
        uniform float u_random;

        in vec3 a_agent; // x, y, angle
        out vec3 v_agent;

        // Simple hash for randomness
        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float senseTrail(vec2 pos, float angle) {
            float sensorAngle = u_sensorAngle * 0.0174533; // to radians
            float newAngle = angle + sensorAngle;
            vec2 sensorPos = pos + vec2(cos(newAngle), sin(newAngle)) * u_sensorDistance;
            sensorPos = mod(sensorPos, u_resolution);
            vec2 uv = sensorPos / u_resolution;
            return texture(u_trailMap, uv).r;
        }

        void main() {
            vec2 pos = a_agent.xy;
            float angle = a_agent.z;

            // Sense trails at three directions
            float senseLeft = senseTrail(pos, angle + u_sensorAngle * 0.0174533);
            float senseFront = senseTrail(pos, angle);
            float senseRight = senseTrail(pos, angle - u_sensorAngle * 0.0174533);

            // Determine rotation based on sensor readings
            float rotAngle = u_rotationAngle * 0.0174533;
            float randVal = hash(pos + u_random);

            if (senseFront > senseLeft && senseFront > senseRight) {
                // Keep going straight
            } else if (senseFront < senseLeft && senseFront < senseRight) {
                // Random turn
                angle += (randVal > 0.5 ? rotAngle : -rotAngle);
            } else if (senseLeft < senseRight) {
                // Turn right
                angle -= rotAngle;
            } else if (senseRight < senseLeft) {
                // Turn left
                angle += rotAngle;
            }

            // Move forward
            pos += vec2(cos(angle), sin(angle)) * u_stepSize;

            // Wrap around boundaries
            pos = mod(pos, u_resolution);
            if (pos.x < 0.0) pos.x += u_resolution.x;
            if (pos.y < 0.0) pos.y += u_resolution.y;

            v_agent = vec3(pos, angle);
        }
    `;

    const agentUpdateFragmentShader = `#version 300 es
        precision highp float;
        void main() { discard; }
    `;

    // Trail diffuse/decay shader
    const trailVertexShader = `#version 300 es
        in vec2 a_position;
        out vec2 v_uv;
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    `;

    const trailDiffuseShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_trailMap;
        uniform vec2 u_resolution;
        uniform float u_decayRate;

        in vec2 v_uv;
        out vec4 outColor;

        void main() {
            vec2 texelSize = 1.0 / u_resolution;

            // 3x3 box blur for diffusion
            float sum = 0.0;
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    vec2 offset = vec2(float(dx), float(dy)) * texelSize;
                    sum += texture(u_trailMap, v_uv + offset).r;
                }
            }

            float diffused = sum / 9.0;
            float decayed = diffused * u_decayRate;

            outColor = vec4(decayed, decayed, decayed, 1.0);
        }
    `;

    // Deposit shader - adds agent trails
    const depositVertexShader = `#version 300 es
        uniform vec2 u_resolution;
        in vec3 a_agent;
        void main() {
            vec2 pos = (a_agent.xy / u_resolution) * 2.0 - 1.0;
            gl_Position = vec4(pos, 0.0, 1.0);
            gl_PointSize = 1.0;
        }
    `;

    const depositFragmentShader = `#version 300 es
        precision highp float;
        uniform float u_depositAmount;
        out vec4 outColor;
        void main() {
            outColor = vec4(u_depositAmount / 255.0);
        }
    `;

    // Display shader
    const displayFragmentShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_trailMap;
        in vec2 v_uv;
        out vec4 outColor;

        void main() {
            float trail = texture(u_trailMap, v_uv).r;

            // Color gradient: dark blue -> cyan -> white
            vec3 color;
            if (trail < 0.3) {
                color = mix(vec3(0.02, 0.03, 0.08), vec3(0.1, 0.3, 0.5), trail / 0.3);
            } else if (trail < 0.7) {
                color = mix(vec3(0.1, 0.3, 0.5), vec3(0.4, 0.8, 0.9), (trail - 0.3) / 0.4);
            } else {
                color = mix(vec3(0.4, 0.8, 0.9), vec3(1.0, 1.0, 1.0), (trail - 0.7) / 0.3);
            }

            outColor = vec4(color, 1.0);
        }
    `;

    // Compile shader helper
    function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader error:', gl.getShaderInfoLog(shader));
            throw new Error('Shader compilation failed');
        }
        return shader;
    }

    function createProgram(vs, fs, transformFeedbackVaryings = null) {
        const program = gl.createProgram();
        gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vs));
        gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fs));

        if (transformFeedbackVaryings) {
            gl.transformFeedbackVaryings(program, transformFeedbackVaryings, gl.SEPARATE_ATTRIBS);
        }

        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
            throw new Error('Program linking failed');
        }
        return program;
    }

    // Setup
    let width, height;
    let agentBuffers = [];
    let currentBuffer = 0;
    let trailTextures = [];
    let trailFramebuffers = [];
    let currentTrail = 0;

    let updateProgram, depositProgram, diffuseProgram, displayProgram;
    let quadBuffer;
    let transformFeedback;

    function resize() {
        const dpr = Math.min(window.devicePixelRatio, 2);
        width = Math.floor(window.innerWidth * dpr);
        height = Math.floor(window.innerHeight * dpr);
        canvas.width = width;
        canvas.height = height;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
    }

    function createAgentBuffers() {
        const agents = new Float32Array(config.numAgents * 3);

        // Initialize agents in center with random angles
        const cx = width / 2;
        const cy = height / 2;
        const radius = Math.min(width, height) / 4;

        for (let i = 0; i < config.numAgents; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * radius;
            agents[i * 3] = cx + Math.cos(angle) * r;     // x
            agents[i * 3 + 1] = cy + Math.sin(angle) * r; // y
            agents[i * 3 + 2] = Math.random() * Math.PI * 2; // heading angle
        }

        // Create double buffers for ping-pong
        for (let i = 0; i < 2; i++) {
            if (agentBuffers[i]) gl.deleteBuffer(agentBuffers[i]);
            agentBuffers[i] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, agentBuffers[i]);
            gl.bufferData(gl.ARRAY_BUFFER, agents, gl.DYNAMIC_DRAW);
        }
    }

    function createTrailTextures() {
        for (let i = 0; i < 2; i++) {
            if (trailTextures[i]) gl.deleteTexture(trailTextures[i]);
            if (trailFramebuffers[i]) gl.deleteFramebuffer(trailFramebuffers[i]);

            trailTextures[i] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, trailTextures[i]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

            trailFramebuffers[i] = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffers[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, trailTextures[i], 0);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function init() {
        resize();

        // Create programs
        updateProgram = createProgram(agentUpdateVertexShader, agentUpdateFragmentShader, ['v_agent']);
        depositProgram = createProgram(depositVertexShader, depositFragmentShader);
        diffuseProgram = createProgram(trailVertexShader, trailDiffuseShader);
        displayProgram = createProgram(trailVertexShader, displayFragmentShader);

        // Create quad for full-screen passes
        quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        // Create transform feedback
        transformFeedback = gl.createTransformFeedback();

        createAgentBuffers();
        createTrailTextures();

        // Setup controls
        setupControls();

        document.getElementById('loading').style.display = 'none';
        document.getElementById('agent-count').textContent = config.numAgents.toLocaleString();
    }

    function setupControls() {
        const controls = ['sensorAngle', 'sensorDist', 'rotationAngle', 'stepSize', 'decayRate'];
        const configKeys = ['sensorAngle', 'sensorDistance', 'rotationAngle', 'stepSize', 'decayRate'];

        controls.forEach((id, i) => {
            const input = document.getElementById(id);
            const valSpan = document.getElementById(id + 'Val');
            input.addEventListener('input', () => {
                const val = parseFloat(input.value);
                config[configKeys[i]] = val;
                valSpan.textContent = id.includes('Angle') ? val + '°' : val;
            });
        });
    }

    function resetSimulation() {
        createAgentBuffers();
        // Clear trail textures
        for (let i = 0; i < 2; i++) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffers[i]);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    // Mouse interaction
    let isDrawing = false;
    canvas.addEventListener('mousedown', () => isDrawing = true);
    canvas.addEventListener('mouseup', () => isDrawing = false);
    canvas.addEventListener('mousemove', (e) => {
        if (!isDrawing) return;
        addAgentsAt(e.clientX, e.clientY);
    });
    canvas.addEventListener('click', (e) => addAgentsAt(e.clientX, e.clientY));

    function addAgentsAt(x, y) {
        const dpr = Math.min(window.devicePixelRatio, 2);
        const px = x * dpr;
        const py = (window.innerHeight - y) * dpr;

        // Add 1000 agents at click position
        const newAgents = new Float32Array(1000 * 3);
        for (let i = 0; i < 1000; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * 20;
            newAgents[i * 3] = px + Math.cos(angle) * r;
            newAgents[i * 3 + 1] = py + Math.sin(angle) * r;
            newAgents[i * 3 + 2] = Math.random() * Math.PI * 2;
        }

        // Append to buffer (simplified - in production would manage buffer size)
        gl.bindBuffer(gl.ARRAY_BUFFER, agentBuffers[currentBuffer]);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, newAgents);
    }

    // Animation loop
    let lastTime = 0;
    let frameCount = 0;
    let fpsTime = 0;

    function render(time) {
        // FPS counter
        frameCount++;
        if (time - fpsTime > 1000) {
            document.getElementById('fps').textContent = frameCount;
            frameCount = 0;
            fpsTime = time;
        }

        // Step 1: Update agents (sense, rotate, move) using transform feedback
        gl.useProgram(updateProgram);
        gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_trailMap'), 0);
        gl.uniform2f(gl.getUniformLocation(updateProgram, 'u_resolution'), width, height);
        gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_sensorAngle'), config.sensorAngle);
        gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_sensorDistance'), config.sensorDistance);
        gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_rotationAngle'), config.rotationAngle);
        gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_stepSize'), config.stepSize);
        gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_random'), Math.random());

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, trailTextures[currentTrail]);

        gl.bindBuffer(gl.ARRAY_BUFFER, agentBuffers[currentBuffer]);
        const agentLoc = gl.getAttribLocation(updateProgram, 'a_agent');
        gl.enableVertexAttribArray(agentLoc);
        gl.vertexAttribPointer(agentLoc, 3, gl.FLOAT, false, 0, 0);

        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, agentBuffers[1 - currentBuffer]);

        gl.enable(gl.RASTERIZER_DISCARD);
        gl.beginTransformFeedback(gl.POINTS);
        gl.drawArrays(gl.POINTS, 0, config.numAgents);
        gl.endTransformFeedback();
        gl.disable(gl.RASTERIZER_DISCARD);

        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
        currentBuffer = 1 - currentBuffer;

        // Step 2: Deposit trails
        gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffers[currentTrail]);
        gl.viewport(0, 0, width, height);

        gl.useProgram(depositProgram);
        gl.uniform2f(gl.getUniformLocation(depositProgram, 'u_resolution'), width, height);
        gl.uniform1f(gl.getUniformLocation(depositProgram, 'u_depositAmount'), config.depositAmount);

        gl.bindBuffer(gl.ARRAY_BUFFER, agentBuffers[currentBuffer]);
        const depositLoc = gl.getAttribLocation(depositProgram, 'a_agent');
        gl.enableVertexAttribArray(depositLoc);
        gl.vertexAttribPointer(depositLoc, 3, gl.FLOAT, false, 0, 0);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        gl.drawArrays(gl.POINTS, 0, config.numAgents);
        gl.disable(gl.BLEND);

        // Step 3: Diffuse and decay trails
        const nextTrail = 1 - currentTrail;
        gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffers[nextTrail]);

        gl.useProgram(diffuseProgram);
        gl.uniform1i(gl.getUniformLocation(diffuseProgram, 'u_trailMap'), 0);
        gl.uniform2f(gl.getUniformLocation(diffuseProgram, 'u_resolution'), width, height);
        gl.uniform1f(gl.getUniformLocation(diffuseProgram, 'u_decayRate'), config.decayRate);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, trailTextures[currentTrail]);

        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        const posLoc = gl.getAttribLocation(diffuseProgram, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        currentTrail = nextTrail;

        // Step 4: Display to screen
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, width, height);

        gl.useProgram(displayProgram);
        gl.uniform1i(gl.getUniformLocation(displayProgram, 'u_trailMap'), 0);
        gl.bindTexture(gl.TEXTURE_2D, trailTextures[currentTrail]);

        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        const dispPosLoc = gl.getAttribLocation(displayProgram, 'a_position');
        gl.enableVertexAttribArray(dispPosLoc);
        gl.vertexAttribPointer(dispPosLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
    }

    // Handle resize
    window.addEventListener('resize', () => {
        resize();
        createTrailTextures();
    });

    // Start
    try {
        init();
        requestAnimationFrame(render);
    } catch (e) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        document.getElementById('error-msg').textContent = e.message;
        console.error(e);
    }
    </script>
</body>
</html>
