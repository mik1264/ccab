<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edmonds' Arborescence Algorithm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c9a227, #e0c068);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 20px;
        }

        .visualization-area {
            background: rgba(20, 20, 35, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
        }

        .controls-panel {
            background: rgba(20, 20, 35, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
            height: fit-content;
        }

        .section-title {
            font-size: 0.85rem;
            color: #c9a227;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #b8941f);
            color: #0a0a0f;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(201, 162, 39, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .info-box {
            background: rgba(201, 162, 39, 0.1);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #c9a227;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .step-info {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #3498db;
            margin-bottom: 15px;
            min-height: 60px;
        }

        .phase-indicator {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .phase {
            flex: 1;
            padding: 6px;
            text-align: center;
            font-size: 0.7rem;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: #666;
        }

        .phase.active {
            background: rgba(201, 162, 39, 0.3);
            color: #c9a227;
        }

        .phase.done {
            background: rgba(39, 174, 96, 0.3);
            color: #27ae60;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        select option {
            background: #1a1a2e;
        }

        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Edmonds' Arborescence Algorithm</h1>
        <p class="subtitle">Minimum Spanning Arborescence (Directed MST) via cycle contraction</p>

        <div class="main-layout">
            <div class="visualization-area">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>In Arborescence</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Cycle</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Contracted Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Min Incoming Edge</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #c9a227;"></div>
                        <span>Root</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="info-box">
                    <strong>Edmonds' Algorithm</strong><br>
                    Finds minimum spanning arborescence (directed MST) rooted at a specified vertex.
                    Works by selecting min incoming edges and contracting cycles.
                </div>

                <div class="section-title">Example Graph</div>
                <select id="graphSelect" onchange="loadGraph()">
                    <option value="simple">Simple (no cycles)</option>
                    <option value="oneCycle">One Cycle</option>
                    <option value="nested">Nested Cycles</option>
                    <option value="complex">Complex Graph</option>
                </select>

                <div class="section-title">Algorithm Phase</div>
                <div class="phase-indicator">
                    <div class="phase" id="phase1">Select</div>
                    <div class="phase" id="phase2">Contract</div>
                    <div class="phase" id="phase3">Expand</div>
                </div>

                <div class="section-title">Controls</div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="stepAlgorithm()">Step</button>
                    <button class="btn btn-secondary" onclick="runToCompletion()">Run to Completion</button>
                    <button class="btn btn-secondary" onclick="resetAlgorithm()">Reset</button>
                </div>

                <div class="step-info" id="stepInfo">
                    Click "Step" to begin finding the minimum arborescence
                </div>

                <div class="section-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="totalWeight">0</div>
                        <div class="stat-label">Total Weight</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="contractions">0</div>
                        <div class="stat-label">Contractions</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="edgesSelected">0</div>
                        <div class="stat-label">Edges Selected</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="steps">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Example graphs
        const graphs = {
            simple: {
                nodes: ['A', 'B', 'C', 'D'],
                edges: [
                    { from: 'A', to: 'B', weight: 2 },
                    { from: 'A', to: 'C', weight: 3 },
                    { from: 'B', to: 'D', weight: 1 },
                    { from: 'C', to: 'D', weight: 4 }
                ],
                root: 'A'
            },
            oneCycle: {
                nodes: ['R', 'A', 'B', 'C'],
                edges: [
                    { from: 'R', to: 'A', weight: 1 },
                    { from: 'R', to: 'B', weight: 5 },
                    { from: 'A', to: 'B', weight: 2 },
                    { from: 'B', to: 'C', weight: 1 },
                    { from: 'C', to: 'A', weight: 1 }  // Creates cycle A-B-C
                ],
                root: 'R'
            },
            nested: {
                nodes: ['R', 'A', 'B', 'C', 'D', 'E'],
                edges: [
                    { from: 'R', to: 'A', weight: 10 },
                    { from: 'R', to: 'D', weight: 5 },
                    { from: 'A', to: 'B', weight: 1 },
                    { from: 'B', to: 'C', weight: 1 },
                    { from: 'C', to: 'A', weight: 1 },  // Cycle A-B-C
                    { from: 'D', to: 'E', weight: 2 },
                    { from: 'E', to: 'B', weight: 3 }
                ],
                root: 'R'
            },
            complex: {
                nodes: ['R', 'A', 'B', 'C', 'D', 'E', 'F'],
                edges: [
                    { from: 'R', to: 'A', weight: 4 },
                    { from: 'R', to: 'B', weight: 8 },
                    { from: 'A', to: 'C', weight: 3 },
                    { from: 'A', to: 'D', weight: 7 },
                    { from: 'B', to: 'D', weight: 2 },
                    { from: 'C', to: 'E', weight: 1 },
                    { from: 'D', to: 'E', weight: 5 },
                    { from: 'D', to: 'F', weight: 2 },
                    { from: 'E', to: 'F', weight: 1 },
                    { from: 'F', to: 'C', weight: 2 }   // Creates cycle C-E-F
                ],
                root: 'R'
            }
        };

        let currentGraph = null;
        let state = {
            phase: 'select',
            selectedEdges: new Set(),
            cycleEdges: new Set(),
            arborescenceEdges: new Set(),
            contractions: 0,
            step: 0,
            done: false,
            nodePositions: {},
            contractedNodes: new Map(),
            history: []
        };

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 40) * dpr;
            canvas.height = 500 * dpr;
            canvas.style.height = '500px';
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function loadGraph() {
            const selection = document.getElementById('graphSelect').value;
            currentGraph = JSON.parse(JSON.stringify(graphs[selection]));
            resetAlgorithm();
        }

        function resetAlgorithm() {
            state = {
                phase: 'select',
                selectedEdges: new Set(),
                cycleEdges: new Set(),
                arborescenceEdges: new Set(),
                contractions: 0,
                step: 0,
                done: false,
                nodePositions: {},
                contractedNodes: new Map(),
                minIncomingEdges: new Map(),
                history: []
            };

            // Calculate node positions
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;

            currentGraph.nodes.forEach((node, i) => {
                const angle = (i / currentGraph.nodes.length) * Math.PI * 2 - Math.PI / 2;
                state.nodePositions[node] = {
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                };
            });

            updatePhaseIndicator();
            updateStats();
            draw();
            document.getElementById('stepInfo').textContent = 'Click "Step" to begin finding the minimum arborescence';
        }

        function stepAlgorithm() {
            if (state.done) return;
            state.step++;

            switch (state.phase) {
                case 'select':
                    selectMinIncomingEdges();
                    break;
                case 'checkCycle':
                    checkForCycles();
                    break;
                case 'contract':
                    contractCycle();
                    break;
                case 'expand':
                    expandContraction();
                    break;
            }

            updatePhaseIndicator();
            updateStats();
            draw();
        }

        function selectMinIncomingEdges() {
            state.selectedEdges.clear();
            state.minIncomingEdges.clear();

            // For each non-root node, select minimum incoming edge
            currentGraph.nodes.forEach(node => {
                if (node === currentGraph.root) return;

                const incomingEdges = currentGraph.edges.filter(e => e.to === node);
                if (incomingEdges.length > 0) {
                    const minEdge = incomingEdges.reduce((min, e) =>
                        e.weight < min.weight ? e : min, incomingEdges[0]);
                    state.selectedEdges.add(JSON.stringify(minEdge));
                    state.minIncomingEdges.set(node, minEdge);
                }
            });

            document.getElementById('stepInfo').textContent =
                `Selected minimum incoming edge for each non-root vertex (${state.selectedEdges.size} edges)`;

            state.phase = 'checkCycle';
        }

        function checkForCycles() {
            // Build graph from selected edges
            const adjList = new Map();
            currentGraph.nodes.forEach(n => adjList.set(n, []));

            state.selectedEdges.forEach(edgeStr => {
                const edge = JSON.parse(edgeStr);
                adjList.get(edge.from).push(edge.to);
            });

            // DFS to find cycles
            const visited = new Set();
            const recStack = new Set();
            let cycle = null;

            function dfs(node, path) {
                if (recStack.has(node)) {
                    // Found cycle - extract it
                    const cycleStart = path.indexOf(node);
                    cycle = path.slice(cycleStart);
                    return true;
                }
                if (visited.has(node)) return false;

                visited.add(node);
                recStack.add(node);
                path.push(node);

                for (const neighbor of adjList.get(node) || []) {
                    if (dfs(neighbor, path)) return true;
                }

                recStack.delete(node);
                path.pop();
                return false;
            }

            for (const node of currentGraph.nodes) {
                if (!visited.has(node)) {
                    if (dfs(node, [])) break;
                }
            }

            if (cycle) {
                state.cycleNodes = cycle;
                state.cycleEdges.clear();

                // Mark cycle edges
                for (let i = 0; i < cycle.length; i++) {
                    const from = cycle[i];
                    const to = cycle[(i + 1) % cycle.length];
                    const edge = currentGraph.edges.find(e => e.from === from && e.to === to);
                    if (edge) state.cycleEdges.add(JSON.stringify(edge));
                }

                document.getElementById('stepInfo').innerHTML =
                    `Found cycle: ${cycle.join(' → ')} → ${cycle[0]}. Will contract into supernode.`;
                state.phase = 'contract';
            } else {
                // No cycle - we're done!
                state.arborescenceEdges = new Set(state.selectedEdges);
                state.done = true;
                state.phase = 'done';
                document.getElementById('stepInfo').textContent =
                    'No cycles found! Minimum arborescence complete.';
            }
        }

        function contractCycle() {
            state.contractions++;
            const cycle = state.cycleNodes;
            const superNode = `S${state.contractions}`;

            // Save state for expansion
            state.history.push({
                cycle: [...cycle],
                superNode,
                removedEdges: currentGraph.edges.filter(e =>
                    cycle.includes(e.from) && cycle.includes(e.to)
                ),
                incomingToSuper: []
            });

            // Find min cycle edge weight
            let minCycleWeight = Infinity;
            cycle.forEach(node => {
                const inEdge = state.minIncomingEdges.get(node);
                if (inEdge && cycle.includes(inEdge.from)) {
                    minCycleWeight = Math.min(minCycleWeight, inEdge.weight);
                }
            });

            // Create new edges for supernode
            const newEdges = [];

            currentGraph.edges.forEach(edge => {
                const fromInCycle = cycle.includes(edge.from);
                const toInCycle = cycle.includes(edge.to);

                if (!fromInCycle && !toInCycle) {
                    // Edge not touching cycle - keep as is
                    newEdges.push(edge);
                } else if (!fromInCycle && toInCycle) {
                    // Edge entering cycle - adjust weight
                    const targetMinEdge = state.minIncomingEdges.get(edge.to);
                    const adjustedWeight = edge.weight - (targetMinEdge ? targetMinEdge.weight : 0);
                    newEdges.push({ from: edge.from, to: superNode, weight: adjustedWeight, original: edge });
                    state.history[state.history.length - 1].incomingToSuper.push({ original: edge, adjusted: adjustedWeight });
                } else if (fromInCycle && !toInCycle) {
                    // Edge leaving cycle
                    newEdges.push({ from: superNode, to: edge.to, weight: edge.weight, original: edge });
                }
                // Edges within cycle are removed
            });

            // Update graph
            currentGraph.nodes = currentGraph.nodes.filter(n => !cycle.includes(n));
            currentGraph.nodes.push(superNode);
            currentGraph.edges = newEdges;

            // Position supernode at center of cycle
            let sumX = 0, sumY = 0;
            cycle.forEach(n => {
                sumX += state.nodePositions[n].x;
                sumY += state.nodePositions[n].y;
            });
            state.nodePositions[superNode] = {
                x: sumX / cycle.length,
                y: sumY / cycle.length
            };

            state.contractedNodes.set(superNode, cycle);

            document.getElementById('stepInfo').textContent =
                `Contracted cycle into supernode ${superNode}. Restarting edge selection.`;

            state.cycleEdges.clear();
            state.cycleNodes = null;
            state.phase = 'select';
        }

        function expandContraction() {
            if (state.history.length === 0) {
                state.done = true;
                document.getElementById('stepInfo').textContent = 'Expansion complete! Arborescence found.';
                return;
            }

            const last = state.history.pop();
            // Restore the cycle nodes and find which edge to replace

            document.getElementById('stepInfo').textContent =
                `Expanding supernode ${last.superNode} back to cycle nodes`;

            state.phase = state.history.length > 0 ? 'expand' : 'done';
            if (state.phase === 'done') {
                state.done = true;
            }
        }

        function runToCompletion() {
            while (!state.done) {
                stepAlgorithm();
            }
        }

        function updatePhaseIndicator() {
            ['phase1', 'phase2', 'phase3'].forEach(id => {
                document.getElementById(id).className = 'phase';
            });

            if (state.done) {
                ['phase1', 'phase2', 'phase3'].forEach(id => {
                    document.getElementById(id).className = 'phase done';
                });
            } else if (state.phase === 'select' || state.phase === 'checkCycle') {
                document.getElementById('phase1').className = 'phase active';
            } else if (state.phase === 'contract') {
                document.getElementById('phase2').className = 'phase active';
            } else if (state.phase === 'expand') {
                document.getElementById('phase3').className = 'phase active';
            }
        }

        function updateStats() {
            let totalWeight = 0;
            (state.done ? state.arborescenceEdges : state.selectedEdges).forEach(edgeStr => {
                const edge = JSON.parse(edgeStr);
                totalWeight += edge.weight;
            });

            document.getElementById('totalWeight').textContent = totalWeight;
            document.getElementById('contractions').textContent = state.contractions;
            document.getElementById('edgesSelected').textContent =
                state.done ? state.arborescenceEdges.size : state.selectedEdges.size;
            document.getElementById('steps').textContent = state.step;
        }

        function draw() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            if (!currentGraph) return;

            // Draw edges
            currentGraph.edges.forEach(edge => {
                const from = state.nodePositions[edge.from];
                const to = state.nodePositions[edge.to];
                if (!from || !to) return;

                const edgeStr = JSON.stringify(edge);
                const inArborescence = state.arborescenceEdges.has(edgeStr);
                const selected = state.selectedEdges.has(edgeStr);
                const inCycle = state.cycleEdges.has(edgeStr);

                const color = inArborescence ? '#27ae60' :
                             inCycle ? '#e74c3c' :
                             selected ? '#3498db' :
                             'rgba(255, 255, 255, 0.2)';

                const lineWidth = (inArborescence || selected || inCycle) ? 3 : 1;

                drawArrow(from, to, color, lineWidth, edge.weight);
            });

            // Draw nodes
            currentGraph.nodes.forEach(node => {
                const pos = state.nodePositions[node];
                if (!pos) return;

                const isRoot = node === currentGraph.root;
                const isContracted = node.startsWith('S');
                const inCycle = state.cycleNodes?.includes(node);

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, isContracted ? 30 : 25, 0, Math.PI * 2);

                if (isRoot) {
                    ctx.fillStyle = '#c9a227';
                } else if (isContracted) {
                    ctx.fillStyle = '#f39c12';
                } else if (inCycle) {
                    ctx.fillStyle = '#e74c3c';
                } else {
                    ctx.fillStyle = '#3498db';
                }

                ctx.fill();

                ctx.font = 'bold 14px Segoe UI';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node, pos.x, pos.y);

                if (isRoot) {
                    ctx.font = '10px Segoe UI';
                    ctx.fillText('ROOT', pos.x, pos.y + 35);
                }
            });
        }

        function drawArrow(from, to, color, lineWidth, weight) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / len;
            const ny = dy / len;

            const startX = from.x + nx * 28;
            const startY = from.y + ny * 28;
            const endX = to.x - nx * 28;
            const endY = to.y - ny * 28;

            // Curve offset
            const offset = 15;
            const midX = (startX + endX) / 2 - ny * offset;
            const midY = (startY + endY) / 2 + nx * offset;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.quadraticCurveTo(midX, midY, endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(endY - midY, endX - midX);
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - 10 * Math.cos(angle - 0.4), endY - 10 * Math.sin(angle - 0.4));
            ctx.lineTo(endX - 10 * Math.cos(angle + 0.4), endY - 10 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            // Weight label
            ctx.font = '12px Segoe UI';
            ctx.fillStyle = '#c9a227';
            ctx.textAlign = 'center';
            ctx.fillText(weight, midX, midY - 8);
        }

        // Initialize
        loadGraph();
    </script>
</body>
</html>
