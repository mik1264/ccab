<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Min-Cost Flow with Potentials</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c9a227, #e0c068);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization-area {
            background: rgba(20, 20, 35, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
        }

        .controls-panel {
            background: rgba(20, 20, 35, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
            height: fit-content;
        }

        .section-title {
            font-size: 0.85rem;
            color: #c9a227;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #b8941f);
            color: #0a0a0f;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(201, 162, 39, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .info-box {
            background: rgba(201, 162, 39, 0.1);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #c9a227;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .step-info {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #3498db;
            margin-bottom: 15px;
            min-height: 70px;
        }

        .potentials-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .potential-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .potential-item:last-child {
            border-bottom: none;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        select option {
            background: #1a1a2e;
        }

        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Min-Cost Flow with Potentials</h1>
        <p class="subtitle">Successive shortest path algorithm with reduced costs</p>

        <div class="main-layout">
            <div class="visualization-area">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Shortest Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Flow Sent</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Saturated Edge</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>Residual Edge</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #c9a227;"></div>
                        <span>Source/Sink</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="info-box">
                    <strong>Successive Shortest Path</strong><br>
                    Finds min-cost max-flow by repeatedly sending flow along the shortest (cheapest) path.
                    Node potentials ensure non-negative reduced costs for Dijkstra.
                </div>

                <div class="section-title">Example Network</div>
                <select id="graphSelect" onchange="loadGraph()">
                    <option value="simple">Simple Network</option>
                    <option value="bipartite">Bipartite Matching</option>
                    <option value="negative">With Negative Costs</option>
                    <option value="complex">Complex Network</option>
                </select>

                <div class="section-title">Controls</div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="stepAlgorithm()">Step</button>
                    <button class="btn btn-secondary" onclick="runToCompletion()">Run to Completion</button>
                    <button class="btn btn-secondary" onclick="resetAlgorithm()">Reset</button>
                </div>

                <div class="step-info" id="stepInfo">
                    Click "Step" to find shortest path and send flow
                </div>

                <div class="section-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="totalFlow">0</div>
                        <div class="stat-label">Total Flow</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="totalCost">0</div>
                        <div class="stat-label">Total Cost</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="iterations">0</div>
                        <div class="stat-label">Iterations</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="avgCost">0</div>
                        <div class="stat-label">Avg Cost/Unit</div>
                    </div>
                </div>

                <div class="section-title">Node Potentials</div>
                <div class="potentials-display" id="potentialsDisplay">
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Example graphs with costs and capacities
        const graphs = {
            simple: {
                nodes: ['S', 'A', 'B', 'C', 'T'],
                edges: [
                    { from: 'S', to: 'A', capacity: 4, cost: 1 },
                    { from: 'S', to: 'B', capacity: 2, cost: 3 },
                    { from: 'A', to: 'B', capacity: 2, cost: 2 },
                    { from: 'A', to: 'C', capacity: 3, cost: 4 },
                    { from: 'B', to: 'C', capacity: 3, cost: 1 },
                    { from: 'B', to: 'T', capacity: 1, cost: 2 },
                    { from: 'C', to: 'T', capacity: 5, cost: 2 }
                ],
                source: 'S',
                sink: 'T'
            },
            bipartite: {
                nodes: ['S', 'W1', 'W2', 'W3', 'J1', 'J2', 'J3', 'T'],
                edges: [
                    { from: 'S', to: 'W1', capacity: 1, cost: 0 },
                    { from: 'S', to: 'W2', capacity: 1, cost: 0 },
                    { from: 'S', to: 'W3', capacity: 1, cost: 0 },
                    { from: 'W1', to: 'J1', capacity: 1, cost: 2 },
                    { from: 'W1', to: 'J2', capacity: 1, cost: 5 },
                    { from: 'W2', to: 'J1', capacity: 1, cost: 3 },
                    { from: 'W2', to: 'J3', capacity: 1, cost: 4 },
                    { from: 'W3', to: 'J2', capacity: 1, cost: 1 },
                    { from: 'W3', to: 'J3', capacity: 1, cost: 6 },
                    { from: 'J1', to: 'T', capacity: 1, cost: 0 },
                    { from: 'J2', to: 'T', capacity: 1, cost: 0 },
                    { from: 'J3', to: 'T', capacity: 1, cost: 0 }
                ],
                source: 'S',
                sink: 'T'
            },
            negative: {
                nodes: ['S', 'A', 'B', 'C', 'T'],
                edges: [
                    { from: 'S', to: 'A', capacity: 3, cost: 2 },
                    { from: 'S', to: 'B', capacity: 3, cost: 4 },
                    { from: 'A', to: 'B', capacity: 2, cost: -1 },
                    { from: 'A', to: 'C', capacity: 2, cost: 3 },
                    { from: 'B', to: 'C', capacity: 4, cost: 1 },
                    { from: 'C', to: 'T', capacity: 5, cost: 2 }
                ],
                source: 'S',
                sink: 'T'
            },
            complex: {
                nodes: ['S', 'A', 'B', 'C', 'D', 'E', 'T'],
                edges: [
                    { from: 'S', to: 'A', capacity: 4, cost: 1 },
                    { from: 'S', to: 'B', capacity: 3, cost: 2 },
                    { from: 'A', to: 'C', capacity: 3, cost: 3 },
                    { from: 'A', to: 'D', capacity: 2, cost: 1 },
                    { from: 'B', to: 'C', capacity: 2, cost: 2 },
                    { from: 'B', to: 'D', capacity: 3, cost: 4 },
                    { from: 'C', to: 'E', capacity: 2, cost: 2 },
                    { from: 'C', to: 'T', capacity: 2, cost: 3 },
                    { from: 'D', to: 'E', capacity: 3, cost: 1 },
                    { from: 'D', to: 'T', capacity: 2, cost: 5 },
                    { from: 'E', to: 'T', capacity: 4, cost: 2 }
                ],
                source: 'S',
                sink: 'T'
            }
        };

        let currentGraph = null;
        let state = {
            flow: new Map(),  // edge key -> flow amount
            residual: [],     // residual graph edges
            potentials: new Map(),
            totalFlow: 0,
            totalCost: 0,
            iterations: 0,
            done: false,
            currentPath: [],
            pathFlow: 0,
            nodePositions: {}
        };

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 40) * dpr;
            canvas.height = 500 * dpr;
            canvas.style.height = '500px';
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function edgeKey(from, to) {
            return `${from}->${to}`;
        }

        function loadGraph() {
            const selection = document.getElementById('graphSelect').value;
            currentGraph = JSON.parse(JSON.stringify(graphs[selection]));
            resetAlgorithm();
        }

        function resetAlgorithm() {
            state = {
                flow: new Map(),
                residual: [],
                potentials: new Map(),
                totalFlow: 0,
                totalCost: 0,
                iterations: 0,
                done: false,
                currentPath: [],
                pathFlow: 0,
                nodePositions: {}
            };

            // Initialize flows to 0
            currentGraph.edges.forEach(e => {
                state.flow.set(edgeKey(e.from, e.to), 0);
            });

            // Build initial residual graph
            buildResidualGraph();

            // Initialize potentials using Bellman-Ford
            initializePotentials();

            // Calculate node positions
            layoutNodes();

            updateStats();
            draw();
            document.getElementById('stepInfo').textContent =
                'Click "Step" to find shortest path and send flow';
        }

        function buildResidualGraph() {
            state.residual = [];

            currentGraph.edges.forEach(e => {
                const f = state.flow.get(edgeKey(e.from, e.to)) || 0;

                // Forward edge (remaining capacity)
                if (f < e.capacity) {
                    state.residual.push({
                        from: e.from,
                        to: e.to,
                        capacity: e.capacity - f,
                        cost: e.cost,
                        isResidual: false
                    });
                }

                // Backward edge (can return flow)
                if (f > 0) {
                    state.residual.push({
                        from: e.to,
                        to: e.from,
                        capacity: f,
                        cost: -e.cost,
                        isResidual: true
                    });
                }
            });
        }

        function initializePotentials() {
            // Initialize with 0
            currentGraph.nodes.forEach(n => state.potentials.set(n, 0));

            // Bellman-Ford to handle negative costs
            for (let i = 0; i < currentGraph.nodes.length - 1; i++) {
                state.residual.forEach(e => {
                    const reducedCost = e.cost + state.potentials.get(e.from) - state.potentials.get(e.to);
                    if (reducedCost < 0) {
                        state.potentials.set(e.to, state.potentials.get(e.to) + reducedCost);
                    }
                });
            }

            updatePotentialsDisplay();
        }

        function updatePotentials(distances) {
            // Update potentials: π_new = π_old + d
            currentGraph.nodes.forEach(n => {
                const d = distances.get(n);
                if (d !== Infinity) {
                    state.potentials.set(n, state.potentials.get(n) + d);
                }
            });

            updatePotentialsDisplay();
        }

        function updatePotentialsDisplay() {
            const display = document.getElementById('potentialsDisplay');
            display.innerHTML = currentGraph.nodes.map(n => `
                <div class="potential-item">
                    <span>${n}</span>
                    <span style="color: #c9a227">π = ${state.potentials.get(n).toFixed(2)}</span>
                </div>
            `).join('');
        }

        function findShortestPath() {
            // Dijkstra with reduced costs
            const dist = new Map();
            const prev = new Map();
            const visited = new Set();

            currentGraph.nodes.forEach(n => dist.set(n, Infinity));
            dist.set(currentGraph.source, 0);

            while (true) {
                // Find unvisited node with minimum distance
                let minNode = null;
                let minDist = Infinity;

                currentGraph.nodes.forEach(n => {
                    if (!visited.has(n) && dist.get(n) < minDist) {
                        minDist = dist.get(n);
                        minNode = n;
                    }
                });

                if (minNode === null || minNode === currentGraph.sink) break;

                visited.add(minNode);

                // Relax edges
                state.residual.forEach(e => {
                    if (e.from === minNode && e.capacity > 0) {
                        const reducedCost = e.cost +
                            state.potentials.get(e.from) -
                            state.potentials.get(e.to);

                        const newDist = dist.get(e.from) + reducedCost;
                        if (newDist < dist.get(e.to)) {
                            dist.set(e.to, newDist);
                            prev.set(e.to, { from: e.from, edge: e });
                        }
                    }
                });
            }

            if (dist.get(currentGraph.sink) === Infinity) {
                return { path: [], flow: 0, cost: 0, distances: dist };
            }

            // Reconstruct path
            const path = [];
            let node = currentGraph.sink;
            let minCapacity = Infinity;
            let pathCost = 0;

            while (node !== currentGraph.source) {
                const { from, edge } = prev.get(node);
                path.unshift(edge);
                minCapacity = Math.min(minCapacity, edge.capacity);
                pathCost += edge.cost;
                node = from;
            }

            return { path, flow: minCapacity, cost: pathCost, distances: dist };
        }

        function stepAlgorithm() {
            if (state.done) return;

            const result = findShortestPath();

            if (result.path.length === 0) {
                state.done = true;
                state.currentPath = [];
                document.getElementById('stepInfo').textContent =
                    `Algorithm complete! Max flow: ${state.totalFlow}, Min cost: ${state.totalCost}`;
                draw();
                return;
            }

            state.iterations++;
            state.currentPath = result.path;
            state.pathFlow = result.flow;

            // Send flow along path
            result.path.forEach(e => {
                if (e.isResidual) {
                    // Reduce flow on original edge
                    const key = edgeKey(e.to, e.from);
                    const current = state.flow.get(key) || 0;
                    state.flow.set(key, current - result.flow);
                } else {
                    // Increase flow on original edge
                    const key = edgeKey(e.from, e.to);
                    const current = state.flow.get(key) || 0;
                    state.flow.set(key, current + result.flow);
                }
            });

            state.totalFlow += result.flow;
            state.totalCost += result.flow * result.cost;

            // Update potentials and rebuild residual
            updatePotentials(result.distances);
            buildResidualGraph();

            const pathStr = [currentGraph.source, ...result.path.map(e => e.to)].join(' → ');
            document.getElementById('stepInfo').innerHTML =
                `Path found: ${pathStr}<br>Flow sent: ${result.flow}, Path cost: ${result.cost}`;

            updateStats();
            draw();
        }

        function runToCompletion() {
            while (!state.done) {
                stepAlgorithm();
            }
        }

        function layoutNodes() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            // Layer-based layout
            const layers = new Map();
            const visited = new Set();
            const queue = [{ node: currentGraph.source, layer: 0 }];

            while (queue.length > 0) {
                const { node, layer } = queue.shift();
                if (visited.has(node)) continue;
                visited.add(node);

                if (!layers.has(layer)) layers.set(layer, []);
                layers.get(layer).push(node);

                currentGraph.edges.forEach(e => {
                    if (e.from === node && !visited.has(e.to)) {
                        queue.push({ node: e.to, layer: layer + 1 });
                    }
                });
            }

            const numLayers = layers.size;
            const layerWidth = (width - 100) / Math.max(numLayers - 1, 1);

            layers.forEach((nodes, layer) => {
                const layerHeight = (height - 100) / Math.max(nodes.length + 1, 1);
                nodes.forEach((node, i) => {
                    state.nodePositions[node] = {
                        x: 50 + layer * layerWidth,
                        y: 50 + (i + 1) * layerHeight
                    };
                });
            });
        }

        function updateStats() {
            document.getElementById('totalFlow').textContent = state.totalFlow;
            document.getElementById('totalCost').textContent = state.totalCost;
            document.getElementById('iterations').textContent = state.iterations;
            document.getElementById('avgCost').textContent =
                state.totalFlow > 0 ? (state.totalCost / state.totalFlow).toFixed(2) : '0';
        }

        function draw() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            if (!currentGraph) return;

            const pathEdgeKeys = new Set(state.currentPath.map(e => edgeKey(e.from, e.to)));

            // Draw edges
            currentGraph.edges.forEach(e => {
                const from = state.nodePositions[e.from];
                const to = state.nodePositions[e.to];
                if (!from || !to) return;

                const key = edgeKey(e.from, e.to);
                const flow = state.flow.get(key) || 0;
                const inPath = pathEdgeKeys.has(key);
                const saturated = flow >= e.capacity;

                let color = 'rgba(255, 255, 255, 0.2)';
                let lineWidth = 1.5;

                if (inPath) {
                    color = '#27ae60';
                    lineWidth = 4;
                } else if (saturated) {
                    color = '#e74c3c';
                    lineWidth = 2;
                } else if (flow > 0) {
                    color = '#3498db';
                    lineWidth = 2;
                }

                drawEdge(from, to, color, lineWidth, e.cost, e.capacity, flow);
            });

            // Draw residual edges (faintly)
            state.residual.filter(e => e.isResidual && e.capacity > 0).forEach(e => {
                const from = state.nodePositions[e.from];
                const to = state.nodePositions[e.to];
                if (!from || !to) return;

                drawEdge(from, to, 'rgba(155, 89, 182, 0.3)', 1, '', '', '', true);
            });

            // Draw nodes
            currentGraph.nodes.forEach(node => {
                const pos = state.nodePositions[node];
                if (!pos) return;

                const isSourceSink = node === currentGraph.source || node === currentGraph.sink;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, isSourceSink ? 30 : 25, 0, Math.PI * 2);
                ctx.fillStyle = isSourceSink ? '#c9a227' : '#3498db';
                ctx.fill();

                ctx.font = 'bold 14px Segoe UI';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node, pos.x, pos.y);

                // Show potential
                ctx.font = '10px Segoe UI';
                ctx.fillStyle = '#888';
                ctx.fillText(`π=${state.potentials.get(node).toFixed(1)}`, pos.x, pos.y + 35);
            });
        }

        function drawEdge(from, to, color, lineWidth, cost, capacity, flow, isResidual = false) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / len;
            const ny = dy / len;

            const startX = from.x + nx * 30;
            const startY = from.y + ny * 30;
            const endX = to.x - nx * 30;
            const endY = to.y - ny * 30;

            // Curve for visual separation
            const offset = isResidual ? -20 : 10;
            const midX = (startX + endX) / 2 - ny * offset;
            const midY = (startY + endY) / 2 + nx * offset;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.quadraticCurveTo(midX, midY, endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(endY - midY, endX - midX);
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - 10 * Math.cos(angle - 0.4), endY - 10 * Math.sin(angle - 0.4));
            ctx.lineTo(endX - 10 * Math.cos(angle + 0.4), endY - 10 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            // Labels
            if (!isResidual && capacity !== '') {
                ctx.font = '11px Segoe UI';
                ctx.textAlign = 'center';

                // Cost
                ctx.fillStyle = '#c9a227';
                ctx.fillText(`c:${cost}`, midX, midY - 12);

                // Flow/Capacity
                ctx.fillStyle = flow > 0 ? '#27ae60' : '#666';
                ctx.fillText(`${flow}/${capacity}`, midX, midY + 5);
            }
        }

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = loadGraph;

        // Initialize
        loadGraph();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
