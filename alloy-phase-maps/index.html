<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Binary Alloy Phase Map</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #c084fc; font-size: 20px; font-weight: bold; z-index: 10;
    text-shadow: 0 0 20px rgba(192,132,252,0.5);
    pointer-events: none;
}
#info {
    position: fixed; top: 85px; left: 50%; transform: translateX(-50%);
    color: #d8b4fe; font-size: 14px; z-index: 10; pointer-events: none;
    text-shadow: 0 0 10px rgba(216,180,254,0.3);
}
#instructions {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    color: #64748b; font-size: 13px; z-index: 10;
    background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 8px;
    text-align: center;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title">Binary Alloy Phase Diagram (Cu-Ni System)</div>
<div id="info">T: <span id="tempVal">1200</span> K &nbsp;|&nbsp; Composition: <span id="compVal">50</span>% Ni &nbsp;|&nbsp; Phase: <span id="phaseVal">Liquid</span></div>
<div id="instructions">Click and drag on the phase diagram to explore. Right panel shows real-time microstructure. System: Cu-Ni (complete solid solubility).</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
let diagX, diagY, diagW, diagH;
let vizX, vizY, vizW, vizH;

// Cu-Ni phase diagram (isomorphous system - complete solid solution)
// Liquidus and solidus curves
const Tm_Cu = 1358; // Melting point of pure Cu (K)
const Tm_Ni = 1728; // Melting point of pure Ni (K)

// Simplified liquidus: T_liq(x) where x is mole fraction Ni
function liquidusT(x) {
    // Approximate: linear + slight curvature
    return Tm_Cu + (Tm_Ni - Tm_Cu) * x - 80 * x * (1 - x);
}

// Solidus: slightly lower than liquidus
function solidusT(x) {
    return Tm_Cu + (Tm_Ni - Tm_Cu) * x - 200 * x * (1 - x);
}

// Get composition on liquidus at given temperature
function liquidusComp(T) {
    // Inverse - find x where liquidusT(x) = T
    for (let x = 0; x <= 1; x += 0.001) {
        if (Math.abs(liquidusT(x) - T) < 2) return x;
    }
    return -1;
}

function solidusComp(T) {
    for (let x = 0; x <= 1; x += 0.001) {
        if (Math.abs(solidusT(x) - T) < 2) return x;
    }
    return -1;
}

// State
let stateT = 1500;
let stateX = 0.5; // Ni fraction
let dragging = false;
let microParticles = [];
let microGrains = [];

const Tmin = 1200;
const Tmax = 1800;
const Xmin = 0;
const Xmax = 1;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;

    const margin = 60;
    diagW = Math.min(W * 0.48, W - 350);
    diagH = H - 220;
    diagX = margin + 30;
    diagY = 120;

    vizW = W - diagX - diagW - margin * 2 - 20;
    vizH = diagH;
    vizX = diagX + diagW + margin;
    vizY = diagY;

    generateMicrostructure();
}

function tToY(T) { return diagY + (Tmax - T) / (Tmax - Tmin) * diagH; }
function xToX(x) { return diagX + x * diagW; }
function yToT(y) { return Tmax - (y - diagY) / diagH * (Tmax - Tmin); }
function pixToX(px) { return (px - diagX) / diagW; }

function getPhase(T, x) {
    const Tliq = liquidusT(x);
    const Tsol = solidusT(x);

    if (T >= Tliq) return 'Liquid (L)';
    if (T <= Tsol) return 'Solid (\u03B1)';
    return 'Two-Phase (L + \u03B1)';
}

function generateMicrostructure() {
    microParticles = [];
    microGrains = [];

    const phase = getPhase(stateT, stateX);

    if (phase === 'Liquid (L)') {
        // Random particles moving
        for (let i = 0; i < 200; i++) {
            microParticles.push({
                x: vizX + 10 + Math.random() * (vizW - 20),
                y: vizY + 10 + Math.random() * (vizH - 20),
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                isNi: Math.random() < stateX,
                r: 3 + Math.random() * 2
            });
        }
    } else if (phase.includes('Two-Phase')) {
        // Mix of liquid and solid
        const Tliq = liquidusT(stateX);
        const Tsol = solidusT(stateX);
        const leverLiquid = (stateT - Tsol) / (Tliq - Tsol);

        // Solid grains
        const numGrains = Math.floor((1 - leverLiquid) * 8) + 1;
        for (let i = 0; i < numGrains; i++) {
            const gx = vizX + 30 + Math.random() * (vizW - 60);
            const gy = vizY + 30 + Math.random() * (vizH - 60);
            const gr = 20 + Math.random() * 30 + (1 - leverLiquid) * 20;
            microGrains.push({ x: gx, y: gy, r: gr, hue: 200 + Math.random() * 60 });
        }

        // Liquid particles
        for (let i = 0; i < Math.floor(leverLiquid * 150); i++) {
            microParticles.push({
                x: vizX + 10 + Math.random() * (vizW - 20),
                y: vizY + 10 + Math.random() * (vizH - 20),
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                isNi: Math.random() < stateX,
                r: 2.5 + Math.random() * 1.5
            });
        }
    } else {
        // All solid - polycrystalline grains
        const numGrains = 12 + Math.floor(Math.random() * 8);
        for (let i = 0; i < numGrains; i++) {
            const gx = vizX + 20 + Math.random() * (vizW - 40);
            const gy = vizY + 20 + Math.random() * (vizH - 40);
            const gr = 25 + Math.random() * 40;
            const hue = 200 + (stateX * 100) + Math.random() * 40;
            microGrains.push({ x: gx, y: gy, r: gr, hue: hue });
        }
    }
}

function updateMicro() {
    for (const p of microParticles) {
        p.x += p.vx;
        p.y += p.vy;
        p.vx += (Math.random() - 0.5) * 0.5;
        p.vy += (Math.random() - 0.5) * 0.5;
        p.vx *= 0.95;
        p.vy *= 0.95;

        if (p.x < vizX + 5) { p.x = vizX + 5; p.vx *= -1; }
        if (p.x > vizX + vizW - 5) { p.x = vizX + vizW - 5; p.vx *= -1; }
        if (p.y < vizY + 5) { p.y = vizY + 5; p.vy *= -1; }
        if (p.y > vizY + vizH - 5) { p.y = vizY + vizH - 5; p.vy *= -1; }

        // Keep out of grains
        for (const g of microGrains) {
            const dx = p.x - g.x;
            const dy = p.y - g.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < g.r + p.r) {
                const nx = dx / dist;
                const ny = dy / dist;
                p.x = g.x + nx * (g.r + p.r);
                p.y = g.y + ny * (g.r + p.r);
                p.vx = nx * Math.abs(p.vx);
                p.vy = ny * Math.abs(p.vy);
            }
        }
    }
}

function drawDiagram() {
    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.9)';
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(diagX - 25, diagY - 15, diagW + 50, diagH + 60, 10);
    ctx.fill();
    ctx.stroke();

    // Fill phase regions
    for (let px = 0; px < diagW; px += 2) {
        for (let py = 0; py < diagH; py += 2) {
            const T = yToT(diagY + py);
            const x = px / diagW;
            const phase = getPhase(T, x);
            let color;
            if (phase === 'Liquid (L)') color = 'rgba(239,68,68,0.08)';
            else if (phase.includes('Two-Phase')) color = 'rgba(168,85,247,0.1)';
            else color = 'rgba(59,130,246,0.08)';
            ctx.fillStyle = color;
            ctx.fillRect(diagX + px, diagY + py, 2, 2);
        }
    }

    // Draw liquidus curve
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    for (let x = 0; x <= 1; x += 0.005) {
        const T = liquidusT(x);
        const px = xToX(x);
        const py = tToY(T);
        if (x === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Draw solidus curve
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    for (let x = 0; x <= 1; x += 0.005) {
        const T = solidusT(x);
        const px = xToX(x);
        const py = tToY(T);
        if (x === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Phase labels
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(239,68,68,0.6)';
    ctx.fillText('LIQUID', xToX(0.5), tToY(1720));
    ctx.fillStyle = 'rgba(59,130,246,0.6)';
    ctx.fillText('SOLID (\u03B1)', xToX(0.5), tToY(1280));
    ctx.fillStyle = 'rgba(168,85,247,0.5)';
    ctx.font = '12px sans-serif';
    ctx.fillText('L + \u03B1', xToX(0.5), tToY(1480));

    // Curve labels
    ctx.font = '11px sans-serif';
    ctx.fillStyle = '#ef4444';
    ctx.fillText('Liquidus', xToX(0.85), tToY(liquidusT(0.85)) - 10);
    ctx.fillStyle = '#3b82f6';
    ctx.fillText('Solidus', xToX(0.15), tToY(solidusT(0.15)) + 18);

    // Axes
    ctx.strokeStyle = '#64748b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(diagX, diagY);
    ctx.lineTo(diagX, diagY + diagH);
    ctx.lineTo(diagX + diagW, diagY + diagH);
    ctx.lineTo(diagX + diagW, diagY);
    ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Composition (mol% Ni)', diagX + diagW / 2, diagY + diagH + 40);

    ctx.save();
    ctx.translate(diagX - 45, diagY + diagH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Temperature (K)', 0, 0);
    ctx.restore();

    // Tick marks
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    for (let x = 0; x <= 100; x += 20) {
        const px = xToX(x / 100);
        ctx.beginPath();
        ctx.moveTo(px, diagY + diagH);
        ctx.lineTo(px, diagY + diagH + 5);
        ctx.stroke();
        ctx.fillText(x + '%', px, diagY + diagH + 18);
    }
    ctx.fillText('Cu', diagX, diagY + diagH + 30);
    ctx.fillText('Ni', diagX + diagW, diagY + diagH + 30);

    ctx.textAlign = 'right';
    for (let T = 1200; T <= 1800; T += 100) {
        const py = tToY(T);
        ctx.beginPath();
        ctx.moveTo(diagX - 5, py);
        ctx.lineTo(diagX, py);
        ctx.stroke();
        ctx.fillText(T + '', diagX - 8, py + 4);
    }

    // Tie line for two-phase region
    const phase = getPhase(stateT, stateX);
    if (phase.includes('Two-Phase')) {
        // Find liquidus and solidus compositions at this temperature
        const xL = liquidusComp(stateT);
        const xS = solidusComp(stateT);

        if (xL >= 0 && xS >= 0) {
            ctx.strokeStyle = 'rgba(251,191,36,0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 3]);
            ctx.beginPath();
            ctx.moveTo(xToX(xL), tToY(stateT));
            ctx.lineTo(xToX(xS), tToY(stateT));
            ctx.stroke();
            ctx.setLineDash([]);

            // Lever rule points
            ctx.beginPath();
            ctx.arc(xToX(xL), tToY(stateT), 4, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            ctx.font = '9px sans-serif';
            ctx.fillStyle = '#ef4444';
            ctx.textAlign = 'center';
            ctx.fillText('L: ' + (xL * 100).toFixed(0) + '%', xToX(xL), tToY(stateT) - 10);

            ctx.beginPath();
            ctx.arc(xToX(xS), tToY(stateT), 4, 0, Math.PI * 2);
            ctx.fillStyle = '#3b82f6';
            ctx.fill();
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('\u03B1: ' + (xS * 100).toFixed(0) + '%', xToX(xS), tToY(stateT) - 10);

            // Lever rule fractions
            const totalLen = Math.abs(xS - xL);
            const fLiquid = totalLen > 0 ? Math.abs(xS - stateX) / totalLen : 0;
            const fSolid = 1 - fLiquid;

            ctx.fillStyle = '#fbbf24';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Lever Rule: ${(fLiquid * 100).toFixed(0)}% L, ${(fSolid * 100).toFixed(0)}% \u03B1`,
                diagX + 10, diagY + 20);
        }
    }

    // State point
    const sx = xToX(stateX);
    const sy = tToY(stateT);

    // Crosshairs
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(sx, diagY);
    ctx.lineTo(sx, diagY + diagH);
    ctx.moveTo(diagX, sy);
    ctx.lineTo(diagX + diagW, sy);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath();
    ctx.arc(sx, sy, 7, 0, Math.PI * 2);
    ctx.fillStyle = '#fbbf24';
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawMicrostructure() {
    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.95)';
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(vizX - 5, vizY - 5, vizW + 10, vizH + 10, 8);
    ctx.fill();
    ctx.stroke();

    ctx.save();
    ctx.beginPath();
    ctx.rect(vizX, vizY, vizW, vizH);
    ctx.clip();

    // Background
    const phase = getPhase(stateT, stateX);

    if (phase === 'Liquid (L)') {
        ctx.fillStyle = 'rgba(40,15,15,0.8)';
    } else if (phase.includes('Two-Phase')) {
        ctx.fillStyle = 'rgba(30,15,40,0.8)';
    } else {
        ctx.fillStyle = 'rgba(15,20,50,0.8)';
    }
    ctx.fillRect(vizX, vizY, vizW, vizH);

    // Draw solid grains
    for (const g of microGrains) {
        const gradient = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.r);
        gradient.addColorStop(0, `hsla(${g.hue},50%,45%,0.8)`);
        gradient.addColorStop(0.8, `hsla(${g.hue},50%,35%,0.7)`);
        gradient.addColorStop(1, `hsla(${g.hue},50%,25%,0.5)`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = `hsla(${g.hue},40%,60%,0.3)`;
        ctx.lineWidth = 1;
        ctx.stroke();

        // Crystal pattern inside
        ctx.strokeStyle = `hsla(${g.hue},30%,50%,0.15)`;
        ctx.lineWidth = 0.5;
        const angle = g.hue * 0.1;
        for (let d = -g.r; d < g.r; d += 8) {
            ctx.beginPath();
            ctx.moveTo(g.x + d * Math.cos(angle) - g.r * Math.sin(angle),
                       g.y + d * Math.sin(angle) + g.r * Math.cos(angle));
            ctx.lineTo(g.x + d * Math.cos(angle) + g.r * Math.sin(angle),
                       g.y + d * Math.sin(angle) - g.r * Math.cos(angle));
            ctx.stroke();
        }
    }

    // Draw liquid particles
    for (const p of microParticles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = p.isNi ? 'rgba(96,165,250,0.7)' : 'rgba(251,146,60,0.7)';
        ctx.fill();
    }

    ctx.restore();

    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Microstructure', vizX + vizW / 2, vizY + vizH + 25);

    // Legend
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    if (microParticles.length > 0) {
        ctx.fillStyle = 'rgba(251,146,60,0.7)';
        ctx.fillText('\u25CF Cu atoms', vizX, vizY + vizH + 42);
        ctx.fillStyle = 'rgba(96,165,250,0.7)';
        ctx.fillText('\u25CF Ni atoms', vizX + 80, vizY + vizH + 42);
    }
    if (microGrains.length > 0) {
        ctx.fillStyle = 'rgba(100,130,200,0.7)';
        ctx.fillText('\u25CF \u03B1 grains', vizX + 160, vizY + vizH + 42);
    }
}

let lastPhase = '';

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    updateMicro();
    drawDiagram();
    drawMicrostructure();

    const phase = getPhase(stateT, stateX);
    document.getElementById('tempVal').textContent = stateT.toFixed(0);
    document.getElementById('compVal').textContent = (stateX * 100).toFixed(0);
    document.getElementById('phaseVal').textContent = phase;

    if (phase !== lastPhase) {
        lastPhase = phase;
        generateMicrostructure();
    }

    requestAnimationFrame(draw);
}

canvas.addEventListener('mousedown', (e) => {
    const sx = xToX(stateX);
    const sy = tToY(stateT);
    if ((e.clientX - sx) ** 2 + (e.clientY - sy) ** 2 < 400) {
        dragging = true;
    }
    // Also allow clicking anywhere on the diagram
    if (e.clientX >= diagX && e.clientX <= diagX + diagW &&
        e.clientY >= diagY && e.clientY <= diagY + diagH) {
        dragging = true;
        stateX = Math.max(0, Math.min(1, pixToX(e.clientX)));
        stateT = Math.max(Tmin, Math.min(Tmax, yToT(e.clientY)));
        generateMicrostructure();
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (dragging) {
        stateX = Math.max(0, Math.min(1, pixToX(e.clientX)));
        stateT = Math.max(Tmin, Math.min(Tmax, yToT(e.clientY)));
    }
});

canvas.addEventListener('mouseup', () => { dragging = false; });
canvas.addEventListener('mouseleave', () => { dragging = false; });

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    if (touch.clientX >= diagX && touch.clientX <= diagX + diagW &&
        touch.clientY >= diagY && touch.clientY <= diagY + diagH) {
        dragging = true;
        stateX = Math.max(0, Math.min(1, pixToX(touch.clientX)));
        stateT = Math.max(Tmin, Math.min(Tmax, yToT(touch.clientY)));
        generateMicrostructure();
    }
});
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (dragging) {
        const touch = e.touches[0];
        stateX = Math.max(0, Math.min(1, pixToX(touch.clientX)));
        stateT = Math.max(Tmin, Math.min(Tmax, yToT(touch.clientY)));
    }
});
canvas.addEventListener('touchend', () => { dragging = false; });

window.addEventListener('resize', resize);

resize();
draw();
</script>
</body>
</html>
