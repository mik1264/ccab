<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starfield Warp - Particle Effects</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
        }

        canvas {
            display: block;
            background: #000;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
        }

        .info-panel h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #64B5F6;
        }

        .info-panel p {
            font-size: 14px;
            line-height: 1.6;
            color: #ddd;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ddd;
        }

        .control-group input[type="range"] {
            width: 200px;
        }

        .value-display {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: #64B5F6;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="info-panel">
        <h1>Starfield Warp</h1>
        <p>3D starfield with warp speed effect. Experience the sensation of traveling through space at light speed.</p>
        <p>Move your mouse to steer!</p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>
                Warp Speed: <span class="value-display" id="speedValue">5</span>
            </label>
            <input type="range" id="speed" min="1" max="20" value="5" step="0.5">
        </div>
        <div class="control-group">
            <label>
                Star Count: <span class="value-display" id="countValue">500</span>
            </label>
            <input type="range" id="count" min="100" max="1000" value="500" step="50">
        </div>
        <div class="control-group">
            <label>
                Trail Length: <span class="value-display" id="trailValue">0.3</span>
            </label>
            <input type="range" id="trail" min="0.1" max="0.9" value="0.3" step="0.1">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let centerX = width / 2;
        let centerY = height / 2;

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        });

        let warpSpeed = 5;
        let starCount = 500;
        let trailLength = 0.3;

        document.getElementById('speed').addEventListener('input', (e) => {
            warpSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = warpSpeed.toFixed(1);
        });

        document.getElementById('count').addEventListener('input', (e) => {
            starCount = parseInt(e.target.value);
            document.getElementById('countValue').textContent = starCount;
            initStars();
        });

        document.getElementById('trail').addEventListener('input', (e) => {
            trailLength = parseFloat(e.target.value);
            document.getElementById('trailValue').textContent = trailLength.toFixed(1);
        });

        // Mouse tracking for steering
        let mouseX = centerX;
        let mouseY = centerY;

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        class Star {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = (Math.random() - 0.5) * width * 2;
                this.y = (Math.random() - 0.5) * height * 2;
                this.z = Math.random() * 2000 + 1;
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevZ = this.z;
            }

            update() {
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevZ = this.z;

                // Move towards camera with warp speed
                this.z -= warpSpeed;

                // Steer towards mouse
                const targetOffsetX = (mouseX - centerX) * 0.1;
                const targetOffsetY = (mouseY - centerY) * 0.1;

                this.x += targetOffsetX * 0.1;
                this.y += targetOffsetY * 0.1;

                // Reset if behind camera
                if (this.z <= 1) {
                    this.reset();
                }
            }

            draw() {
                // Project 3D to 2D
                const k = 128 / this.z;
                const px = this.x * k + centerX;
                const py = this.y * k + centerY;

                // Previous position for trail
                const prevK = 128 / this.prevZ;
                const prevPx = this.prevX * prevK + centerX;
                const prevPy = this.prevY * prevK + centerY;

                // Calculate size based on depth
                const size = (1 - this.z / 2000) * 3;

                // Calculate brightness based on speed and depth
                const brightness = Math.min(1, (2000 - this.z) / 2000);

                // Draw trail
                ctx.save();
                ctx.strokeStyle = `rgba(150, 180, 255, ${brightness * 0.8})`;
                ctx.lineWidth = size;
                ctx.beginPath();
                ctx.moveTo(prevPx, prevPy);
                ctx.lineTo(px, py);
                ctx.stroke();
                ctx.restore();

                // Draw star
                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();

                // Add glow for near stars
                if (this.z < 500) {
                    const gradient = ctx.createRadialGradient(px, py, 0, px, py, size * 3);
                    gradient.addColorStop(0, `rgba(150, 200, 255, ${brightness * 0.5})`);
                    gradient.addColorStop(1, 'rgba(150, 200, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(px, py, size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        let stars = [];

        function initStars() {
            stars = [];
            for (let i = 0; i < starCount; i++) {
                stars.push(new Star());
            }
        }

        function drawCrosshair() {
            const offsetX = (mouseX - centerX) * 0.5 + centerX;
            const offsetY = (mouseY - centerY) * 0.5 + centerY;

            ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, 20, 0, Math.PI * 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(offsetX - 25, offsetY);
            ctx.lineTo(offsetX - 10, offsetY);
            ctx.moveTo(offsetX + 10, offsetY);
            ctx.lineTo(offsetX + 25, offsetY);
            ctx.moveTo(offsetX, offsetY - 25);
            ctx.lineTo(offsetX, offsetY - 10);
            ctx.moveTo(offsetX, offsetY + 10);
            ctx.lineTo(offsetX, offsetY + 25);
            ctx.stroke();
        }

        function animate() {
            // Fade previous frame for trail effect
            ctx.fillStyle = `rgba(0, 0, 0, ${trailLength})`;
            ctx.fillRect(0, 0, width, height);

            // Update and draw stars (sorted by depth for correct rendering)
            stars.sort((a, b) => b.z - a.z);

            for (let star of stars) {
                star.update();
                star.draw();
            }

            drawCrosshair();

            requestAnimationFrame(animate);
        }

        initStars();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
