<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waiting Time Paradox - The Bus That's Always Late</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 280px; max-width: 320px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .stats-box {
            margin-top: 12px; padding: 10px; background: rgba(10,14,26,0.6);
            border-radius: 6px; font-size: 11px; line-height: 1.6;
        }
        .stats-box .label { color: #8899aa; }
        .stats-box .value { color: #DDA15E; font-family: monospace; font-weight: 600; }
        .stats-box .highlight { color: #e06060; font-weight: 700; }
        .info-panel {
            position: fixed; bottom: 18px; left: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 16px; color: #c8d0e0;
            max-width: 400px; border: 1px solid rgba(138,154,91,0.3);
        }
        .info-panel h3 { color: #DDA15E; font-size: 14px; margin-bottom: 6px; }
        .info-panel p { font-size: 11px; color: #8899aa; line-height: 1.5; }
        .info-panel .key { color: #8A9A5B; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Probability Paradoxes</a>
    <div class="controls">
        <h2>Waiting Time Paradox</h2>
        <p class="desc">Buses arrive randomly (Poisson process). Your average wait equals the average interval between buses -- not half! Longer gaps "catch" more random passengers.</p>
        <div class="control-row">
            <label>Avg interval (min) <span id="intervalVal">10</span></label>
            <input type="range" id="avgInterval" min="3" max="30" step="1" value="10">
        </div>
        <div class="control-row">
            <label>Speed <span id="speedVal">5x</span></label>
            <input type="range" id="speed" min="1" max="20" step="1" value="5">
        </div>
        <div class="stats-box">
            <div><span class="label">Passengers sampled: </span><span class="value" id="statCount">0</span></div>
            <div><span class="label">Naive expectation: </span><span class="value" id="statNaive">5.0 min</span></div>
            <div><span class="label">Actual avg wait: </span><span class="highlight" id="statActual">--</span></div>
            <div><span class="label">Avg bus interval: </span><span class="value" id="statInterval">--</span></div>
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">Reset</button>
            <button class="btn" id="pauseBtn" onclick="togglePause()">Pause</button>
        </div>
    </div>
    <div class="info-panel">
        <h3>Why Is My Bus Always Late?</h3>
        <p>If buses arrive every 10 minutes on average, you'd expect to wait 5 minutes. But with <span class="key">random arrivals</span>, your average wait equals the full interval: <span class="key">10 minutes</span>!</p>
        <p style="margin-top:6px;">This is the <span class="key">inspection paradox</span>: a random passenger is more likely to land in a <span class="key">long gap</span> than a short one. The gaps you experience are biased toward the longer ones -- so you wait longer than half.</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        let avgInterval = 10;
        let simSpeed = 5;
        let paused = false;

        // Simulation state
        let simTime = 0;
        let busArrivals = [];
        let nextBusTime = 0;
        let passengers = [];
        let waitTimes = [];
        let waitHistogram = new Array(30).fill(0);
        let busIntervals = [];

        // Animated elements
        let busX = -80;
        let busArriving = false;
        let busAnimTime = 0;
        let waitingPeople = [];

        function generateNextBus() {
            // Exponential distribution for Poisson process
            nextBusTime = simTime + (-avgInterval * Math.log(1 - Math.random()));
        }

        function init() {
            simTime = 0;
            busArrivals = [];
            passengers = [];
            waitTimes = [];
            waitHistogram = new Array(30).fill(0);
            busIntervals = [];
            waitingPeople = [];
            busX = -80;
            busArriving = false;
            generateNextBus();
            // Spawn initial waiting people
            for (let i = 0; i < 5; i++) {
                waitingPeople.push({
                    x: 0.15 * W + Math.random() * 0.08 * W,
                    arrivalTime: simTime,
                    bobPhase: Math.random() * Math.PI * 2
                });
            }
        }

        window.reset = function() {
            init();
        };

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        }
        window.togglePause = togglePause;

        // Controls
        document.getElementById('avgInterval').addEventListener('input', function() {
            avgInterval = +this.value;
            document.getElementById('intervalVal').textContent = avgInterval;
            document.getElementById('statNaive').textContent = (avgInterval / 2).toFixed(1) + ' min';
        });
        document.getElementById('speed').addEventListener('input', function() {
            simSpeed = +this.value;
            document.getElementById('speedVal').textContent = simSpeed + 'x';
        });

        // Timeline rendering
        const TIMELINE_Y = 0.45;
        const TIMELINE_LEFT = 0.08;
        const TIMELINE_RIGHT = 0.92;
        const BUS_STOP_X = 0.18;

        function drawBusStop() {
            const sx = BUS_STOP_X * W;
            const sy = TIMELINE_Y * H + 20;

            // Road
            ctx.fillStyle = '#1a1f30';
            ctx.fillRect(0, sy - 40, W, 80);
            ctx.strokeStyle = '#2a3050';
            ctx.setLineDash([20, 15]);
            ctx.beginPath();
            ctx.moveTo(0, sy);
            ctx.lineTo(W, sy);
            ctx.stroke();
            ctx.setLineDash([]);

            // Bus stop sign
            ctx.fillStyle = '#334';
            ctx.fillRect(sx - 3, sy - 100, 6, 100);
            ctx.fillStyle = '#DDA15E';
            ctx.beginPath();
            ctx.arc(sx, sy - 105, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0e1a';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('BUS', sx, sy - 101);

            // Waiting people
            for (let p of waitingPeople) {
                const bob = Math.sin(p.bobPhase + simTime * 0.5) * 3;
                drawPerson(p.x, sy - 55 + bob, '#8A9A5B');
            }
        }

        function drawPerson(x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y - 12, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(x - 3, y - 6, 6, 16);
            ctx.fillRect(x - 6, y - 2, 4, 2);
            ctx.fillRect(x + 2, y - 2, 4, 2);
        }

        function drawBus(x, y) {
            const bw = 70, bh = 40;
            // Body
            ctx.fillStyle = '#2266aa';
            ctx.beginPath();
            ctx.roundRect(x - bw / 2, y - bh, bw, bh, 6);
            ctx.fill();
            // Windows
            ctx.fillStyle = '#aaddff';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(x - 25 + i * 20, y - bh + 8, 14, 14);
            }
            // Wheels
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(x - 20, y, 6, 0, Math.PI * 2);
            ctx.arc(x + 20, y, 6, 0, Math.PI * 2);
            ctx.fill();
            // BUS text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BUS', x, y - 5);
        }

        function drawTimeline() {
            const y = 0.7 * H;
            const left = TIMELINE_LEFT * W;
            const right = TIMELINE_RIGHT * W;
            const timeWidth = right - left;
            const windowSize = Math.max(60, simTime * 0.8);
            const tStart = Math.max(0, simTime - windowSize);
            const tEnd = simTime;

            // Timeline axis
            ctx.strokeStyle = '#334466';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(right, y);
            ctx.stroke();

            // "Now" marker
            ctx.fillStyle = '#DDA15E';
            ctx.beginPath();
            ctx.moveTo(right, y - 8);
            ctx.lineTo(right + 8, y);
            ctx.lineTo(right, y + 8);
            ctx.fill();
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('now', right, y + 22);

            // Bus arrivals on timeline
            for (let t of busArrivals) {
                if (t < tStart || t > tEnd) continue;
                const x = left + (t - tStart) / (tEnd - tStart) * timeWidth;
                ctx.strokeStyle = '#2266aa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - 15);
                ctx.lineTo(x, y + 15);
                ctx.stroke();
                ctx.fillStyle = '#2266aa';
                ctx.font = '9px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(t.toFixed(0) + 'm', x, y + 28);
            }

            // Show gaps between buses
            for (let i = 1; i < busArrivals.length; i++) {
                const t1 = busArrivals[i - 1];
                const t2 = busArrivals[i];
                if (t2 < tStart || t1 > tEnd) continue;
                const x1 = left + Math.max(0, (t1 - tStart) / (tEnd - tStart)) * timeWidth;
                const x2 = left + Math.min(1, (t2 - tStart) / (tEnd - tStart)) * timeWidth;
                const gap = t2 - t1;
                const intensity = Math.min(1, gap / (avgInterval * 2));
                ctx.fillStyle = `rgba(${Math.floor(100 + 155 * intensity)}, ${Math.floor(100 - 60 * intensity)}, ${Math.floor(100 - 60 * intensity)}, 0.15)`;
                ctx.fillRect(x1, y - 12, x2 - x1, 24);
                if (x2 - x1 > 30) {
                    ctx.fillStyle = `rgba(200,200,200,0.5)`;
                    ctx.font = '9px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(gap.toFixed(1) + 'm', (x1 + x2) / 2, y - 16);
                }
            }

            // Labels
            ctx.fillStyle = '#667788';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Bus Arrival Timeline', left, y - 30);
            ctx.fillText('Longer gaps (red) catch more passengers', left, y + 45);
        }

        function drawHistogram() {
            const hx = 0.55 * W;
            const hy = 0.12 * H;
            const hw = 0.35 * W;
            const hh = 0.22 * H;

            // Background
            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(hx - 10, hy - 30, hw + 20, hh + 50, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Wait Time Distribution', hx, hy - 12);

            if (waitTimes.length < 2) {
                ctx.fillStyle = '#556677';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Collecting data...', hx + hw / 2, hy + hh / 2);
                return;
            }

            const maxBin = Math.max(1, ...waitHistogram);
            const binW = hw / waitHistogram.length;

            for (let i = 0; i < waitHistogram.length; i++) {
                const barH = (waitHistogram[i] / maxBin) * hh * 0.85;
                const x = hx + i * binW;
                const y = hy + hh - barH;
                ctx.fillStyle = `hsl(${200 - i * 5}, 60%, ${50 + waitHistogram[i] / maxBin * 20}%)`;
                ctx.fillRect(x + 1, y, binW - 2, barH);
            }

            // Naive expectation line
            const naiveBin = avgInterval / 2;
            if (naiveBin < waitHistogram.length) {
                const nx = hx + naiveBin * binW;
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(nx, hy);
                ctx.lineTo(nx, hy + hh);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#4CAF50';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Naive avg', nx, hy + hh + 14);
            }

            // Actual mean line
            if (waitTimes.length > 0) {
                const mean = waitTimes.reduce((a, b) => a + b, 0) / waitTimes.length;
                if (mean < waitHistogram.length) {
                    const mx = hx + mean * binW;
                    ctx.strokeStyle = '#e06060';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(mx, hy);
                    ctx.lineTo(mx, hy + hh);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#e06060';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Actual avg', mx, hy + hh + 14);
                }
            }

            // X axis labels
            ctx.fillStyle = '#667788';
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            for (let i = 0; i < waitHistogram.length; i += 5) {
                ctx.fillText(i + 'm', hx + i * binW + binW / 2, hy + hh + 26);
            }
        }

        function updateStats() {
            document.getElementById('statCount').textContent = waitTimes.length;
            if (waitTimes.length > 0) {
                const mean = waitTimes.reduce((a, b) => a + b, 0) / waitTimes.length;
                document.getElementById('statActual').textContent = mean.toFixed(2) + ' min';
            }
            if (busIntervals.length > 0) {
                const meanInt = busIntervals.reduce((a, b) => a + b, 0) / busIntervals.length;
                document.getElementById('statInterval').textContent = meanInt.toFixed(2) + ' min';
            }
        }

        let lastTime = 0;
        function animate(ts) {
            const dt = lastTime ? (ts - lastTime) / 1000 : 0;
            lastTime = ts;

            if (!paused) {
                const simDt = dt * simSpeed;
                simTime += simDt;

                // Check if bus arrives
                if (simTime >= nextBusTime) {
                    busArrivals.push(nextBusTime);
                    if (busArrivals.length > 1) {
                        busIntervals.push(nextBusTime - busArrivals[busArrivals.length - 2]);
                    }

                    // Record wait times for waiting people
                    for (let p of waitingPeople) {
                        const wait = nextBusTime - p.arrivalTime;
                        waitTimes.push(wait);
                        const bin = Math.min(waitHistogram.length - 1, Math.floor(wait));
                        waitHistogram[bin]++;
                    }

                    busArriving = true;
                    busAnimTime = 0;
                    waitingPeople = [];

                    generateNextBus();
                }

                // Bus animation
                if (busArriving) {
                    busAnimTime += simDt;
                    busX = W + 80 - busAnimTime * 120;
                    if (busX < -80) {
                        busArriving = false;
                    }
                }

                // Spawn random passengers
                if (Math.random() < simDt * 0.3) {
                    waitingPeople.push({
                        x: BUS_STOP_X * W + (Math.random() - 0.5) * 0.06 * W,
                        arrivalTime: simTime,
                        bobPhase: Math.random() * Math.PI * 2
                    });
                    if (waitingPeople.length > 12) waitingPeople.shift();
                }

                updateStats();
            }

            // Draw
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Title
            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('The Waiting Time Paradox', W / 2, 40);
            ctx.fillStyle = '#667788';
            ctx.font = '13px sans-serif';
            ctx.fillText('Why your bus is always late', W / 2, 60);

            // Sim time
            ctx.fillStyle = '#556677';
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('Sim time: ' + simTime.toFixed(1) + ' min', 20, H - 10);

            drawBusStop();
            if (busArriving) {
                drawBus(busX, TIMELINE_Y * H + 20);
            }
            drawTimeline();
            drawHistogram();

            requestAnimationFrame(animate);
        }

        init();
        requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
