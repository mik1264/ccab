<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>German Tank Problem - Estimating Population Size</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.1em; }
a.back:hover { color: #bdf; }

#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 240px; max-width: 280px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn {
  background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3);
  color: #8af; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px;
}
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
.btn.reveal { background: rgba(255,140,60,0.2); border-color: rgba(255,140,60,0.4); color: #fa8; }
.btn.reveal:hover { background: rgba(255,140,60,0.35); }

#info {
  position: fixed; bottom: 20px; left: 20px; z-index: 100; max-width: 380px;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.1); border-radius: 12px;
  padding: 14px 18px; font-size: 0.82em; line-height: 1.5; color: #8ab;
}
#info h4 { color: #8af; margin-bottom: 6px; }
#info .formula { color: #f8a; font-family: 'Courier New', monospace; font-size: 0.95em; }
#info .history { color: #6c8; font-style: italic; margin-top: 6px; }

#estimate {
  position: fixed; bottom: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); border: 1px solid rgba(120,160,255,0.1);
  border-radius: 12px; padding: 14px 18px; min-width: 200px; text-align: center;
}
#estimate h4 { color: #8af; margin-bottom: 8px; font-size: 0.85em; text-transform: uppercase; letter-spacing: 1px; }
#estimate .est-row { margin: 6px 0; }
#estimate .est-label { font-size: 0.75em; color: #6a8; }
#estimate .est-val { font-size: 1.4em; font-weight: bold; color: #8cf; }
#estimate .truth { font-size: 1.4em; font-weight: bold; color: #f84; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="c"></canvas>

<div id="controls">
  <h3>German Tank Problem</h3>
  <div class="ctrl-row">
    <label>True Tank Count (N) <span class="val" id="vN">200</span></label>
    <input type="range" id="sN" min="20" max="500" step="10" value="200">
  </div>
  <div class="ctrl-row">
    <label>Tanks Captured (k) <span class="val" id="vK">5</span></label>
    <input type="range" id="sK" min="2" max="20" step="1" value="5">
  </div>
  <div style="margin-top:10px;">
    <button class="btn" onclick="newScenario()">New Scenario</button>
    <button class="btn reveal" id="bReveal" onclick="reveal()">Reveal N</button>
  </div>
  <div style="margin-top:8px; border-top: 1px solid rgba(120,160,255,0.1); padding-top: 8px;">
    <button class="btn" onclick="runSimulations()">Run 1000 Simulations</button>
    <div id="simResult" style="font-size:0.78em; color:#6c8; margin-top:6px;"></div>
  </div>
</div>

<div id="info">
  <h4>The Paradox</h4>
  During WWII, the Allies estimated German tank production from captured serial numbers.
  With k captured tanks and maximum serial m:<br>
  <span class="formula">N&#x0302; = m + m/k - 1</span><br>
  This frequentist estimator beats naive guessing. The Bayesian posterior is even more informative.
  <div class="history">Historical: Statisticians estimated ~256 tanks/month. The true number was 271. Military intelligence guessed 1,400!</div>
</div>

<div id="estimate">
  <h4>Estimates</h4>
  <div class="est-row">
    <div class="est-label">Max Serial Seen</div>
    <div class="est-val" id="maxSerial">--</div>
  </div>
  <div class="est-row">
    <div class="est-label">MLE Estimate</div>
    <div class="est-val" id="mleEst">--</div>
  </div>
  <div class="est-row" id="truthRow" style="display:none;">
    <div class="est-label">True N</div>
    <div class="truth" id="trueN">--</div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let N = 200;
let k = 5;
let serials = [];
let captured = [];
let revealed = false;
let tankPositions = [];
let posteriorData = [];
let simRunning = false;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  layoutTanks();
  draw();
}

function layoutTanks() {
  tankPositions = [];
  const gridArea = { x: W * 0.08, y: H * 0.08, w: W * 0.55, h: H * 0.52 };
  const cols = Math.ceil(Math.sqrt(N * gridArea.w / gridArea.h));
  const rows = Math.ceil(N / cols);
  const cellW = gridArea.w / cols;
  const cellH = gridArea.h / rows;
  for (let i = 0; i < N; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    tankPositions.push({
      x: gridArea.x + col * cellW + cellW / 2,
      y: gridArea.y + row * cellH + cellH / 2,
      serial: i + 1,
      size: Math.min(cellW, cellH) * 0.35
    });
  }
}

function drawTank(x, y, size, serial, isCaptured) {
  ctx.save();
  ctx.translate(x, y);

  // Tank body
  if (isCaptured) {
    ctx.fillStyle = 'rgba(255,140,60,0.7)';
    ctx.strokeStyle = 'rgba(255,180,100,0.9)';
  } else if (revealed) {
    ctx.fillStyle = 'rgba(60,80,120,0.3)';
    ctx.strokeStyle = 'rgba(80,100,140,0.4)';
  } else {
    ctx.fillStyle = 'rgba(60,80,120,0.15)';
    ctx.strokeStyle = 'rgba(80,100,140,0.2)';
  }

  // Body rectangle
  ctx.lineWidth = 1;
  const bw = size * 2;
  const bh = size * 1.2;
  ctx.beginPath();
  ctx.roundRect(-bw/2, -bh/2, bw, bh, 3);
  ctx.fill();
  ctx.stroke();

  // Turret
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Barrel
  ctx.beginPath();
  ctx.moveTo(size * 0.3, 0);
  ctx.lineTo(size * 1.1, 0);
  ctx.lineWidth = size * 0.15;
  ctx.stroke();

  // Serial number on captured tanks
  if (isCaptured) {
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.max(8, size * 0.7)}px Courier New, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('#' + serial, 0, bh / 2 + size * 0.8);
  }

  ctx.restore();
}

function computePosterior() {
  const m = Math.max(...captured);
  posteriorData = [];
  let totalProb = 0;
  const maxN = Math.max(m, N) * 2;
  for (let n = m; n <= maxN; n++) {
    // Probability P(data | N=n) = C(n-1, k-1) / C(n, k) ... simplified
    // Using the uniform prior: P(serials | N=n) = 1/C(n,k) for n >= m
    let logProb = 0;
    for (let j = 0; j < k; j++) {
      logProb += Math.log(n - j);
      logProb -= Math.log(j + 1);
    }
    logProb = -logProb;
    const prob = Math.exp(logProb);
    posteriorData.push({ n, prob });
    totalProb += prob;
  }
  // Normalize
  for (const d of posteriorData) d.prob /= totalProb;
}

function newScenario() {
  N = parseInt(document.getElementById('sN').value);
  k = parseInt(document.getElementById('sK').value);
  revealed = false;
  document.getElementById('truthRow').style.display = 'none';

  // Pick k random serials from 1..N
  const all = [];
  for (let i = 1; i <= N; i++) all.push(i);
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  captured = all.slice(0, k).sort((a, b) => a - b);

  const m = Math.max(...captured);
  const mle = Math.round(m + m / k - 1);
  document.getElementById('maxSerial').textContent = m;
  document.getElementById('mleEst').textContent = mle;

  computePosterior();
  layoutTanks();
  draw();
}

function reveal() {
  revealed = true;
  document.getElementById('trueN').textContent = N;
  document.getElementById('truthRow').style.display = '';
  draw();
}

function runSimulations() {
  const simN = N;
  const simK = k;
  const trials = 1000;
  let totalError = 0;
  let within10 = 0;

  for (let t = 0; t < trials; t++) {
    const all = [];
    for (let i = 1; i <= simN; i++) all.push(i);
    for (let i = all.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [all[i], all[j]] = [all[j], all[i]];
    }
    const samp = all.slice(0, simK);
    const m = Math.max(...samp);
    const est = m + m / simK - 1;
    const err = Math.abs(est - simN) / simN;
    totalError += err;
    if (err < 0.1) within10++;
  }

  const avgErr = (totalError / trials * 100).toFixed(1);
  const pct10 = (within10 / trials * 100).toFixed(0);
  document.getElementById('simResult').innerHTML =
    `Avg error: <b style="color:#8cf">${avgErr}%</b><br>Within 10%: <b style="color:#4f8">${pct10}%</b> of trials`;
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  // Draw tanks grid
  for (const tp of tankPositions) {
    const isCap = captured.includes(tp.serial);
    const s = tp.pulse || 1;
    drawTank(tp.x, tp.y, tp.size * s, tp.serial, isCap);
  }

  // Draw posterior distribution
  if (posteriorData.length > 0) {
    const pLeft = W * 0.55;
    const pRight = W * 0.92;
    const pTop = H * 0.62;
    const pBottom = H * 0.92;
    const pW = pRight - pLeft;
    const pH = pBottom - pTop;

    // Background
    ctx.fillStyle = 'rgba(15,20,40,0.6)';
    ctx.beginPath();
    ctx.roundRect(pLeft - 10, pTop - 30, pW + 20, pH + 50, 8);
    ctx.fill();

    ctx.fillStyle = '#8af';
    ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Bayesian Posterior P(N | data)', (pLeft + pRight) / 2, pTop - 12);

    const maxProb = Math.max(...posteriorData.map(d => d.prob));
    const minN = posteriorData[0].n;
    const maxN = posteriorData[posteriorData.length - 1].n;
    const rangeN = maxN - minN || 1;

    // Only draw first portion that has meaningful probability
    let drawEnd = posteriorData.length;
    for (let i = posteriorData.length - 1; i >= 0; i--) {
      if (posteriorData[i].prob > maxProb * 0.001) { drawEnd = i + 1; break; }
    }
    const drawData = posteriorData.slice(0, Math.min(drawEnd + 10, posteriorData.length));
    const drawRange = drawData[drawData.length - 1].n - drawData[0].n || 1;

    // Axes
    ctx.strokeStyle = 'rgba(120,160,255,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pLeft, pTop);
    ctx.lineTo(pLeft, pBottom);
    ctx.lineTo(pRight, pBottom);
    ctx.stroke();

    // Draw distribution
    ctx.beginPath();
    ctx.moveTo(pLeft, pBottom);
    for (const d of drawData) {
      const x = pLeft + ((d.n - drawData[0].n) / drawRange) * pW;
      const y = pBottom - (d.prob / maxProb) * pH * 0.9;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(pLeft + pW, pBottom);
    ctx.closePath();
    const grad = ctx.createLinearGradient(0, pTop, 0, pBottom);
    grad.addColorStop(0, 'rgba(100,180,255,0.4)');
    grad.addColorStop(1, 'rgba(60,100,200,0.05)');
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(100,180,255,0.8)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pLeft, pBottom);
    for (const d of drawData) {
      const x = pLeft + ((d.n - drawData[0].n) / drawRange) * pW;
      const y = pBottom - (d.prob / maxProb) * pH * 0.9;
      ctx.lineTo(x, y);
    }
    ctx.stroke();

    // True N line
    if (revealed) {
      const nx = pLeft + ((N - drawData[0].n) / drawRange) * pW;
      if (nx >= pLeft && nx <= pRight) {
        ctx.strokeStyle = '#f84';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(nx, pTop);
        ctx.lineTo(nx, pBottom);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#f84';
        ctx.font = '11px Segoe UI, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('True N=' + N, nx, pTop - 2);
      }
    }

    // MLE line
    const m = Math.max(...captured);
    const mle = m + m / k - 1;
    const mleX = pLeft + ((mle - drawData[0].n) / drawRange) * pW;
    if (mleX >= pLeft && mleX <= pRight) {
      ctx.strokeStyle = '#4f8';
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(mleX, pTop + 20);
      ctx.lineTo(mleX, pBottom);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#4f8';
      ctx.font = '11px Segoe UI, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('MLE=' + Math.round(mle), mleX, pTop + 16);
    }

    // X axis labels
    ctx.fillStyle = '#6a8';
    ctx.font = '10px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    const step = Math.max(1, Math.round(drawRange / 6));
    for (let n = drawData[0].n; n <= drawData[drawData.length - 1].n; n += step) {
      const x = pLeft + ((n - drawData[0].n) / drawRange) * pW;
      ctx.fillText(n, x, pBottom + 14);
    }
  }

  // Captured serials display
  const serialY = H * 0.57;
  ctx.fillStyle = '#8af';
  ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Captured Serial Numbers:', W * 0.08, serialY);
  ctx.font = 'bold 16px Courier New, monospace';
  ctx.fillStyle = '#fa8';
  ctx.fillText(captured.map(s => '#' + s).join('  '), W * 0.08, serialY + 22);
}

// Event listeners
document.getElementById('sN').addEventListener('input', function() {
  document.getElementById('vN').textContent = this.value;
});
document.getElementById('sK').addEventListener('input', function() {
  document.getElementById('vK').textContent = this.value;
});
document.getElementById('sN').addEventListener('change', newScenario);
document.getElementById('sK').addEventListener('change', newScenario);

window.addEventListener('resize', resize);

window.reset = function() {
  revealed = false;
  document.getElementById('truthRow').style.display = 'none';
  document.getElementById('simResult').innerHTML = '';
  newScenario();
};

let animTime = 0;
function animate() {
  animTime += 0.02;
  // Pulse captured tanks gently
  for (const tp of tankPositions) {
    if (captured.includes(tp.serial)) {
      tp.pulse = 1 + 0.08 * Math.sin(animTime * 2 + tp.serial);
    } else {
      tp.pulse = 1;
    }
  }
  draw();
  requestAnimationFrame(animate);
}

resize();
newScenario();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
