<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>St. Petersburg Paradox - Infinite Expectations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 280px; max-width: 330px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .stats-box {
            margin-top: 12px; padding: 10px; background: rgba(10,14,26,0.6);
            border-radius: 6px; font-size: 11px; line-height: 1.7;
        }
        .stats-box .label { color: #8899aa; }
        .stats-box .value { color: #DDA15E; font-family: monospace; font-weight: 600; }
        .stats-box .highlight { color: #e06060; font-weight: 700; }
        .stats-box .green { color: #8A9A5B; font-weight: 700; }
        .info-panel {
            position: fixed; bottom: 18px; left: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 16px; color: #c8d0e0;
            max-width: 400px; border: 1px solid rgba(138,154,91,0.3);
        }
        .info-panel h3 { color: #DDA15E; font-size: 14px; margin-bottom: 6px; }
        .info-panel p { font-size: 11px; color: #8899aa; line-height: 1.5; }
        .info-panel .key { color: #8A9A5B; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Probability Paradoxes</a>
    <div class="controls">
        <h2>St. Petersburg Paradox</h2>
        <p class="desc">Flip a coin until tails. Win $2^n where n = heads count. Expected value is infinite, but would you pay $100 to play?</p>
        <div class="control-row">
            <label>Your entry fee <span id="feeVal">$10</span></label>
            <input type="range" id="entryFee" min="1" max="1000" step="1" value="10">
        </div>
        <div class="control-row">
            <label>Sim games/batch <span id="batchVal">1000</span></label>
            <input type="range" id="batchSize" min="100" max="10000" step="100" value="1000">
        </div>
        <div class="stats-box">
            <div><span class="label">Games played: </span><span class="value" id="statGames">0</span></div>
            <div><span class="label">Total payout: </span><span class="value" id="statTotal">$0</span></div>
            <div><span class="label">Mean payout: </span><span class="highlight" id="statMean">--</span></div>
            <div><span class="label">Median payout: </span><span class="green" id="statMedian">--</span></div>
            <div><span class="label">Max single win: </span><span class="value" id="statMax">$0</span></div>
            <div><span class="label">Net profit (at entry fee): </span><span class="value" id="statProfit">--</span></div>
        </div>
        <div class="btn-row">
            <button class="btn" onclick="playOne()">Play 1 Game</button>
            <button class="btn" onclick="playBatch()">Play Batch</button>
            <button class="btn" onclick="window.reset()">Reset</button>
        </div>
    </div>
    <div class="info-panel">
        <h3>The Infinite Expectation</h3>
        <p>Expected value = <span class="key">$1 + $1 + $1 + ... = infinity</span>. Each term contributes $1: P(n heads) = 1/2^n, payout = $2^n, so each term = $1.</p>
        <p style="margin-top:6px;">Yet the <span class="key">median payout is just $2</span>! Half the time you flip tails immediately. The "infinite" expected value comes from astronomically rare but massive payouts.</p>
        <p style="margin-top:6px;">Resolution: use <span class="key">log utility</span> (Daniel Bernoulli, 1738). A rational agent values $1M much less than 1000x $1K.</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        let entryFee = 10;
        let batchSize = 1000;

        // State
        let allPayouts = [];
        let totalPayout = 0;
        let maxPayout = 0;
        let payoutDistribution = {}; // payout -> count
        let recentGame = null; // { flips: [{heads:bool}], payout }
        let animPhase = 0;
        let flipAnimProgress = 0;
        let currentFlipIdx = 0;

        // EV buildup animation
        let evTerms = [];

        function playOneGame() {
            let heads = 0;
            const flips = [];
            while (true) {
                const isHeads = Math.random() < 0.5;
                flips.push({ heads: isHeads });
                if (isHeads) {
                    heads++;
                } else {
                    break;
                }
                if (heads > 30) break; // safety cap
            }
            const payout = Math.pow(2, heads);
            return { flips, payout, heads };
        }

        function recordGame(result) {
            allPayouts.push(result.payout);
            totalPayout += result.payout;
            maxPayout = Math.max(maxPayout, result.payout);
            const key = result.payout;
            payoutDistribution[key] = (payoutDistribution[key] || 0) + 1;
        }

        function playOne() {
            const result = playOneGame();
            recordGame(result);
            recentGame = result;
            flipAnimProgress = 0;
            currentFlipIdx = 0;
            updateStats();
        }
        window.playOne = playOne;

        function playBatch() {
            for (let i = 0; i < batchSize; i++) {
                const result = playOneGame();
                recordGame(result);
            }
            recentGame = null;
            updateStats();
        }
        window.playBatch = playBatch;

        window.reset = function() {
            allPayouts = [];
            totalPayout = 0;
            maxPayout = 0;
            payoutDistribution = {};
            recentGame = null;
            flipAnimProgress = 0;
            updateStats();
        };

        function updateStats() {
            const n = allPayouts.length;
            document.getElementById('statGames').textContent = n.toLocaleString();
            document.getElementById('statTotal').textContent = '$' + totalPayout.toLocaleString();
            document.getElementById('statMean').textContent = n > 0 ? '$' + (totalPayout / n).toFixed(2) : '--';
            if (n > 0) {
                const sorted = [...allPayouts].sort((a, b) => a - b);
                const median = sorted[Math.floor(n / 2)];
                document.getElementById('statMedian').textContent = '$' + median;
            } else {
                document.getElementById('statMedian').textContent = '--';
            }
            document.getElementById('statMax').textContent = '$' + maxPayout.toLocaleString();
            if (n > 0) {
                const profit = totalPayout - n * entryFee;
                document.getElementById('statProfit').textContent = (profit >= 0 ? '+$' : '-$') + Math.abs(profit).toLocaleString();
                document.getElementById('statProfit').style.color = profit >= 0 ? '#8A9A5B' : '#e06060';
            } else {
                document.getElementById('statProfit').textContent = '--';
            }
        }

        document.getElementById('entryFee').addEventListener('input', function() {
            entryFee = +this.value;
            document.getElementById('feeVal').textContent = '$' + entryFee;
            updateStats();
        });
        document.getElementById('batchSize').addEventListener('input', function() {
            batchSize = +this.value;
            document.getElementById('batchVal').textContent = batchSize;
        });

        function drawCoinFlipSequence() {
            if (!recentGame) return;

            const sx = 0.05 * W;
            const sy = 0.12 * H;
            const game = recentGame;

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Last Game:', sx, sy - 10);

            const coinSize = Math.min(30, (0.5 * W) / (game.flips.length + 2));
            const showCount = Math.min(game.flips.length, Math.floor(flipAnimProgress * 3) + 1);

            for (let i = 0; i < game.flips.length; i++) {
                const x = sx + i * (coinSize + 8) + coinSize / 2;
                const y = sy + coinSize / 2 + 10;
                const visible = i < showCount;

                if (!visible) {
                    ctx.fillStyle = '#1a2035';
                    ctx.beginPath();
                    ctx.arc(x, y, coinSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    continue;
                }

                const isHeads = game.flips[i].heads;
                const gradient = ctx.createRadialGradient(x - 4, y - 4, 0, x, y, coinSize / 2);
                if (isHeads) {
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(1, '#B8860B');
                } else {
                    gradient.addColorStop(0, '#C0C0C0');
                    gradient.addColorStop(1, '#707070');
                }
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, coinSize / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = isHeads ? '#6B4F00' : '#333';
                ctx.font = `bold ${coinSize * 0.45}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(isHeads ? 'H' : 'T', x, y);
            }
            ctx.textBaseline = 'alphabetic';

            // Payout
            if (showCount >= game.flips.length) {
                const px = sx + game.flips.length * (coinSize + 8) + 20;
                ctx.fillStyle = '#DDA15E';
                ctx.font = 'bold 18px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('= $' + game.payout.toLocaleString(), px, sy + coinSize / 2 + 16);
                ctx.fillStyle = '#667788';
                ctx.font = '11px sans-serif';
                ctx.fillText('(' + game.heads + ' heads before tails)', px, sy + coinSize / 2 + 34);
            }
        }

        function drawEVExplanation() {
            const ex = 0.05 * W;
            const ey = 0.3 * H;
            const ew = 0.5 * W;

            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(ex - 10, ey - 20, ew + 20, 120, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Why Expected Value = Infinity', ex, ey);

            const terms = [
                { n: 0, prob: '1/2', pay: '$1', ev: '$0.50' },
                { n: 1, prob: '1/4', pay: '$2', ev: '$0.50' },
                { n: 2, prob: '1/8', pay: '$4', ev: '$0.50' },
                { n: 3, prob: '1/16', pay: '$8', ev: '$0.50' },
                { n: 4, prob: '1/32', pay: '$16', ev: '$0.50' },
            ];

            // Header
            ctx.fillStyle = '#8899aa';
            ctx.font = '10px monospace';
            const cols = [ex, ex + 70, ex + 150, ex + 240, ex + 330];
            ctx.fillText('Heads', cols[0], ey + 20);
            ctx.fillText('P(n heads)', cols[1], ey + 20);
            ctx.fillText('Payout', cols[2], ey + 20);
            ctx.fillText('Contribution', cols[3], ey + 20);

            terms.forEach((t, i) => {
                const ty = ey + 36 + i * 14;
                ctx.fillStyle = '#aabbcc';
                ctx.fillText(t.n.toString(), cols[0], ty);
                ctx.fillText(t.prob, cols[1], ty);
                ctx.fillText(t.pay, cols[2], ty);
                ctx.fillStyle = '#DDA15E';
                ctx.fillText(t.ev, cols[3], ty);
            });

            // Dots and sum
            const lastY = ey + 36 + terms.length * 14;
            ctx.fillStyle = '#aabbcc';
            ctx.fillText('...', cols[0], lastY);
            ctx.fillText('...', cols[1], lastY);
            ctx.fillText('...', cols[2], lastY);
            ctx.fillStyle = '#DDA15E';
            ctx.fillText('$0.50', cols[3], lastY);

            ctx.fillStyle = '#e06060';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText('E[X] = $0.50 + $0.50 + $0.50 + ... = INFINITY', ex, lastY + 18);
        }

        function drawPayoutDistribution() {
            const dx = 0.05 * W;
            const dy = 0.56 * H;
            const dw = 0.52 * W;
            const dh = 0.35 * H;

            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(dx - 10, dy - 25, dw + 20, dh + 45, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Payout Distribution (log scale)', dx, dy - 8);

            if (allPayouts.length < 2) {
                ctx.fillStyle = '#556677';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Play some games to see the distribution', dx + dw / 2, dy + dh / 2);
                return;
            }

            // Payouts are powers of 2: 1, 2, 4, 8, 16, ...
            const maxPow = Math.max(1, Math.ceil(Math.log2(maxPayout)));
            const bins = maxPow + 1;
            const counts = new Array(bins).fill(0);
            for (const p of allPayouts) {
                const bin = Math.round(Math.log2(p));
                if (bin >= 0 && bin < bins) counts[bin]++;
            }

            const maxCount = Math.max(1, ...counts);
            const barW = Math.min(60, dw / bins);
            const chartLeft = dx + (dw - bins * barW) / 2;

            for (let i = 0; i < bins; i++) {
                if (counts[i] === 0) continue;
                // Log scale for height
                const logH = Math.log10(counts[i] + 1) / Math.log10(maxCount + 1);
                const barH = logH * dh * 0.8;
                const x = chartLeft + i * barW;
                const y = dy + dh - barH;

                const hue = 200 - i * 15;
                ctx.fillStyle = `hsl(${hue}, 60%, ${50 + i * 3}%)`;
                ctx.beginPath();
                ctx.roundRect(x + 2, y, barW - 4, barH, [3, 3, 0, 0]);
                ctx.fill();

                // Count label
                ctx.fillStyle = '#aabbcc';
                ctx.font = '9px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(counts[i].toLocaleString(), x + barW / 2, y - 4);

                // Payout label
                ctx.fillStyle = '#667788';
                ctx.fillText('$' + Math.pow(2, i), x + barW / 2, dy + dh + 14);
            }

            // Highlight median ($2 bar)
            if (counts[1] > 0) {
                const x = chartLeft + 1 * barW;
                ctx.strokeStyle = '#8A9A5B';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                const logH = Math.log10(counts[1] + 1) / Math.log10(maxCount + 1);
                const barH = logH * dh * 0.8;
                ctx.strokeRect(x, dy + dh - barH, barW, barH);
                ctx.setLineDash([]);
                ctx.fillStyle = '#8A9A5B';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Median', x + barW / 2, dy + dh + 28);
            }

            // Percentage annotations
            const total = allPayouts.length;
            let cumBelow4 = 0;
            for (let i = 0; i <= 2; i++) cumBelow4 += counts[i] || 0;
            ctx.fillStyle = '#8899aa';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText((cumBelow4 / total * 100).toFixed(1) + '% of games pay $4 or less', dx, dy + dh + 36);

            // Mean vs Median comparison
            const mean = totalPayout / total;
            const sorted = [...allPayouts].sort((a, b) => a - b);
            const median = sorted[Math.floor(total / 2)];
            ctx.fillStyle = '#e06060';
            ctx.font = '11px sans-serif';
            ctx.fillText('Mean: $' + mean.toFixed(2) + '  |  Median: $' + median, dx + dw - 200, dy + dh + 36);
        }

        function drawUtilityComparison() {
            const ux = 0.62 * W;
            const uy = 0.4 * H;
            const uw = 0.28 * W;
            const uh = 0.25 * H;

            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(ux - 10, uy - 25, uw + 20, uh + 45, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Bernoulli\'s Resolution: Log Utility', ux, uy - 8);

            // Draw utility curves
            const chartLeft = ux;
            const chartRight = ux + uw;
            const chartTop = uy + 10;
            const chartBottom = uy + uh;
            const chartW = chartRight - chartLeft;
            const chartH = chartBottom - chartTop;

            // Axes
            ctx.strokeStyle = '#2a3050';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(chartLeft, chartBottom);
            ctx.lineTo(chartRight, chartBottom);
            ctx.lineTo(chartRight, chartTop);
            ctx.stroke();

            // Linear utility (raw money)
            ctx.strokeStyle = '#e06060';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = chartLeft + (i / 100) * chartW;
                const y = chartBottom - (i / 100) * chartH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Log utility
            ctx.strokeStyle = '#8A9A5B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 1; i <= 100; i++) {
                const x = chartLeft + (i / 100) * chartW;
                const logVal = Math.log(i) / Math.log(100);
                const y = chartBottom - logVal * chartH;
                if (i === 1) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Legend
            ctx.fillStyle = '#e06060';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Linear: E[X] = infinity', ux, uy + uh + 14);
            ctx.fillStyle = '#8A9A5B';
            ctx.fillText('Log: E[ln(X)] = ln(2) = $2', ux, uy + uh + 28);
            ctx.fillStyle = '#667788';
            ctx.fillText('Fair price with log utility: ~$2', ux, uy + uh + 42);
        }

        function drawWouldYouPay() {
            const px = 0.62 * W;
            const py = 0.12 * H;
            const pw = 0.28 * W;

            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(px - 10, py - 20, pw + 20, 80, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Would you pay $' + entryFee + ' to play?', px + pw / 2, py);

            if (allPayouts.length > 0) {
                const total = allPayouts.length;
                const totalCost = total * entryFee;
                const profit = totalPayout - totalCost;
                const pctWin = allPayouts.filter(p => p >= entryFee).length / total * 100;

                ctx.fillStyle = profit >= 0 ? '#8A9A5B' : '#e06060';
                ctx.font = 'bold 16px monospace';
                ctx.fillText((profit >= 0 ? 'Profit: +$' : 'Loss: -$') + Math.abs(profit).toLocaleString(), px + pw / 2, py + 24);

                ctx.fillStyle = '#8899aa';
                ctx.font = '11px sans-serif';
                ctx.fillText(pctWin.toFixed(1) + '% of games beat the entry fee', px + pw / 2, py + 44);
            } else {
                ctx.fillStyle = '#556677';
                ctx.font = '12px sans-serif';
                ctx.fillText('Play to find out!', px + pw / 2, py + 24);
            }
        }

        let lastTime = 0;
        function animate(ts) {
            const dt = lastTime ? (ts - lastTime) / 1000 : 0;
            lastTime = ts;
            animPhase += dt;
            flipAnimProgress += dt;

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Title
            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('The St. Petersburg Paradox', W * 0.35, 40);
            ctx.fillStyle = '#667788';
            ctx.font = '13px sans-serif';
            ctx.fillText('Infinite expected value, but would you bet $10?', W * 0.35, 60);

            drawCoinFlipSequence();
            drawEVExplanation();
            drawPayoutDistribution();
            drawUtilityComparison();
            drawWouldYouPay();

            requestAnimationFrame(animate);
        }

        window.reset();
        requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
