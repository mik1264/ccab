<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Berkson's Paradox - Phantom Correlations</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.1em; }
a.back:hover { color: #bdf; }

#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 240px; max-width: 280px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn {
  background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3);
  color: #8af; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px;
}
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }

#info {
  position: fixed; bottom: 20px; left: 20px; z-index: 100; max-width: 380px;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.1); border-radius: 12px;
  padding: 14px 18px; font-size: 0.82em; line-height: 1.5; color: #8ab;
}
#info h4 { color: #8af; margin-bottom: 6px; }
#info .highlight { color: #f8a; font-weight: bold; }

#corr {
  position: fixed; bottom: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); border: 1px solid rgba(120,160,255,0.1);
  border-radius: 12px; padding: 14px 18px; min-width: 200px; text-align: center;
}
#corr h4 { color: #8af; margin-bottom: 8px; font-size: 0.85em; text-transform: uppercase; letter-spacing: 1px; }
.corr-row { margin: 8px 0; }
.corr-label { font-size: 0.78em; color: #6a8; }
.corr-val { font-size: 1.6em; font-weight: bold; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="c"></canvas>

<div id="controls">
  <h3>Berkson's Paradox</h3>
  <div class="ctrl-row">
    <label>Disease A Prevalence <span class="val" id="vA">30%</span></label>
    <input type="range" id="sA" min="5" max="60" step="1" value="30">
  </div>
  <div class="ctrl-row">
    <label>Disease B Prevalence <span class="val" id="vB">25%</span></label>
    <input type="range" id="sB" min="5" max="60" step="1" value="25">
  </div>
  <div class="ctrl-row">
    <label>Population Size <span class="val" id="vN">400</span></label>
    <input type="range" id="sN" min="100" max="800" step="50" value="400">
  </div>
  <div style="margin-top:8px;">
    <button class="btn active" id="bAll" onclick="setView('all')">Full Population</button>
    <button class="btn" id="bHosp" onclick="setView('hospital')">Hospital Only</button>
  </div>
  <div style="margin-top:6px;">
    <button class="btn" onclick="generate()">Regenerate</button>
  </div>
</div>

<div id="info">
  <h4>The Paradox</h4>
  Diseases A and B are <span class="highlight">completely independent</span> in the population
  (like two separate coin flips). But if you only look at hospitalized people (those with at
  least one disease), A and B appear <span class="highlight">negatively correlated</span>.
  <br><br>
  Why? If someone is in the hospital and does NOT have Disease A, they probably have Disease B
  (otherwise why are they there?). This selection bias creates a phantom negative correlation.
</div>

<div id="corr">
  <h4>Correlation (r)</h4>
  <div class="corr-row">
    <div class="corr-label">Population</div>
    <div class="corr-val" id="corrPop" style="color:#4f8;">--</div>
  </div>
  <div class="corr-row">
    <div class="corr-label">Hospital Sample</div>
    <div class="corr-val" id="corrHosp" style="color:#f55;">--</div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let people = [];
let view = 'all';
let pA = 0.3, pB = 0.25, popSize = 400;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  layoutPeople();
  draw();
}

function generate() {
  pA = parseInt(document.getElementById('sA').value) / 100;
  pB = parseInt(document.getElementById('sB').value) / 100;
  popSize = parseInt(document.getElementById('sN').value);

  people = [];
  for (let i = 0; i < popSize; i++) {
    const hasA = Math.random() < pA;
    const hasB = Math.random() < pB;
    const hospitalized = hasA || hasB;
    people.push({
      hasA, hasB, hospitalized,
      x: 0, y: 0, targetX: 0, targetY: 0
    });
  }

  computeCorrelations();
  layoutPeople();
  draw();
}

function layoutPeople() {
  // Grid layout for population view
  const visible = view === 'all' ? people : people.filter(p => p.hospitalized);
  const n = visible.length;
  if (n === 0) return;

  const gridArea = { x: W * 0.06, y: H * 0.08, w: W * 0.48, h: H * 0.82 };
  const cols = Math.ceil(Math.sqrt(n * gridArea.w / gridArea.h));
  const rows = Math.ceil(n / cols);
  const cellW = gridArea.w / cols;
  const cellH = gridArea.h / rows;

  let idx = 0;
  for (const p of people) {
    const isVisible = view === 'all' || p.hospitalized;
    if (isVisible) {
      const col = idx % cols;
      const row = Math.floor(idx / cols);
      p.targetX = gridArea.x + col * cellW + cellW / 2;
      p.targetY = gridArea.y + row * cellH + cellH / 2;
      p.size = Math.min(cellW, cellH) * 0.35;
      p.visible = true;
      idx++;
    } else {
      p.visible = false;
    }
  }
}

function correlation(data, keyA, keyB) {
  const n = data.length;
  if (n < 3) return 0;
  let sumA = 0, sumB = 0, sumA2 = 0, sumB2 = 0, sumAB = 0;
  for (const d of data) {
    const a = d[keyA] ? 1 : 0;
    const b = d[keyB] ? 1 : 0;
    sumA += a; sumB += b;
    sumA2 += a * a; sumB2 += b * b;
    sumAB += a * b;
  }
  const num = n * sumAB - sumA * sumB;
  const den = Math.sqrt((n * sumA2 - sumA * sumA) * (n * sumB2 - sumB * sumB));
  return den === 0 ? 0 : num / den;
}

function computeCorrelations() {
  const rPop = correlation(people, 'hasA', 'hasB');
  const hospitalized = people.filter(p => p.hospitalized);
  const rHosp = correlation(hospitalized, 'hasA', 'hasB');

  document.getElementById('corrPop').textContent = rPop.toFixed(3);
  document.getElementById('corrPop').style.color = Math.abs(rPop) < 0.1 ? '#4f8' : '#fa8';

  document.getElementById('corrHosp').textContent = rHosp.toFixed(3);
  document.getElementById('corrHosp').style.color = rHosp < -0.1 ? '#f55' : '#fa8';
}

function setView(v) {
  view = v;
  document.getElementById('bAll').classList.toggle('active', v === 'all');
  document.getElementById('bHosp').classList.toggle('active', v === 'hospital');
  layoutPeople();
  draw();
}

function drawPerson(x, y, size, hasA, hasB) {
  // Color coding
  let color;
  if (hasA && hasB) color = { fill: 'rgba(200,100,255,0.7)', stroke: 'rgba(200,100,255,1)' };       // Both: purple
  else if (hasA) color = { fill: 'rgba(255,100,80,0.6)', stroke: 'rgba(255,100,80,0.9)' };           // A only: red
  else if (hasB) color = { fill: 'rgba(80,160,255,0.6)', stroke: 'rgba(80,160,255,0.9)' };           // B only: blue
  else color = { fill: 'rgba(80,100,120,0.2)', stroke: 'rgba(80,100,120,0.3)' };                     // None: gray

  // Person icon (simple)
  ctx.beginPath();
  ctx.arc(x, y - size * 0.3, size * 0.4, 0, Math.PI * 2);
  ctx.fillStyle = color.fill;
  ctx.fill();
  ctx.strokeStyle = color.stroke;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Body
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.1);
  ctx.lineTo(x, y + size * 0.5);
  ctx.moveTo(x - size * 0.3, y + size * 0.1);
  ctx.lineTo(x + size * 0.3, y + size * 0.1);
  ctx.strokeStyle = color.stroke;
  ctx.lineWidth = Math.max(1, size * 0.12);
  ctx.stroke();
}

function drawScatterPlot() {
  const sLeft = W * 0.58;
  const sRight = W * 0.88;
  const sTop = H * 0.1;
  const sBottom = H * 0.5;
  const sW = sRight - sLeft;
  const sH = sBottom - sTop;

  // Background
  ctx.fillStyle = 'rgba(15,20,40,0.5)';
  ctx.beginPath();
  ctx.roundRect(sLeft - 15, sTop - 35, sW + 30, sH + 55, 8);
  ctx.fill();

  ctx.fillStyle = '#8af';
  ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(view === 'all' ? 'Population Scatter' : 'Hospital-Only Scatter', (sLeft + sRight) / 2, sTop - 15);

  // Axes
  ctx.strokeStyle = 'rgba(120,160,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sLeft, sTop);
  ctx.lineTo(sLeft, sBottom);
  ctx.lineTo(sRight, sBottom);
  ctx.stroke();

  ctx.fillStyle = '#6a8';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Disease A', (sLeft + sRight) / 2, sBottom + 18);
  ctx.save();
  ctx.translate(sLeft - 14, (sTop + sBottom) / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Disease B', 0, 0);
  ctx.restore();

  // Labels on axes
  ctx.fillStyle = '#6a8';
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('No', sLeft + sW * 0.25, sBottom + 8);
  ctx.fillText('Yes', sLeft + sW * 0.75, sBottom + 8);
  ctx.textAlign = 'right';
  ctx.fillText('No', sLeft - 4, sTop + sH * 0.75 + 4);
  ctx.fillText('Yes', sLeft - 4, sTop + sH * 0.25 + 4);

  // Count each quadrant
  const source = view === 'all' ? people : people.filter(p => p.hospitalized);
  const counts = { nn: 0, ny: 0, yn: 0, yy: 0 };
  for (const p of source) {
    if (!p.hasA && !p.hasB) counts.nn++;
    else if (!p.hasA && p.hasB) counts.ny++;
    else if (p.hasA && !p.hasB) counts.yn++;
    else counts.yy++;
  }

  // Draw quadrant fills
  const qw = sW / 2;
  const qh = sH / 2;

  // No A, No B (bottom-left)
  ctx.fillStyle = `rgba(80,100,120,${Math.min(0.4, counts.nn / source.length)})`;
  ctx.fillRect(sLeft, sTop + qh, qw, qh);

  // Yes A, No B (bottom-right)
  ctx.fillStyle = `rgba(255,100,80,${Math.min(0.5, counts.yn / source.length * 1.5)})`;
  ctx.fillRect(sLeft + qw, sTop + qh, qw, qh);

  // No A, Yes B (top-left)
  ctx.fillStyle = `rgba(80,160,255,${Math.min(0.5, counts.ny / source.length * 1.5)})`;
  ctx.fillRect(sLeft, sTop, qw, qh);

  // Yes A, Yes B (top-right)
  ctx.fillStyle = `rgba(200,100,255,${Math.min(0.5, counts.yy / source.length * 1.5)})`;
  ctx.fillRect(sLeft + qw, sTop, qw, qh);

  // Dividers
  ctx.strokeStyle = 'rgba(120,160,255,0.2)';
  ctx.beginPath();
  ctx.moveTo(sLeft + qw, sTop); ctx.lineTo(sLeft + qw, sBottom);
  ctx.moveTo(sLeft, sTop + qh); ctx.lineTo(sRight, sTop + qh);
  ctx.stroke();

  // Counts
  ctx.font = 'bold 20px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(80,100,120,0.8)';
  ctx.fillText(counts.nn, sLeft + qw * 0.5, sTop + qh * 1.5 + 7);
  ctx.fillStyle = 'rgba(255,100,80,0.9)';
  ctx.fillText(counts.yn, sLeft + qw * 1.5, sTop + qh * 1.5 + 7);
  ctx.fillStyle = 'rgba(80,160,255,0.9)';
  ctx.fillText(counts.ny, sLeft + qw * 0.5, sTop + qh * 0.5 + 7);
  ctx.fillStyle = 'rgba(200,100,255,0.9)';
  ctx.fillText(counts.yy, sLeft + qw * 1.5, sTop + qh * 0.5 + 7);

  // Scatter dots with jitter
  for (const p of source) {
    const bx = p.hasA ? sLeft + qw * 1.25 : sLeft + qw * 0.25;
    const by = p.hasB ? sTop + qh * 0.25 : sTop + qh * 1.25;
    const jx = (Math.random() - 0.5) * qw * 0.6;
    const jy = (Math.random() - 0.5) * qh * 0.6;
    let col;
    if (p.hasA && p.hasB) col = 'rgba(200,100,255,0.3)';
    else if (p.hasA) col = 'rgba(255,100,80,0.3)';
    else if (p.hasB) col = 'rgba(80,160,255,0.3)';
    else col = 'rgba(80,100,120,0.2)';
    ctx.beginPath();
    ctx.arc(bx + jx, by + jy, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = col;
    ctx.fill();
  }
}

function drawBarChart() {
  const bLeft = W * 0.58;
  const bRight = W * 0.88;
  const bTop = H * 0.56;
  const bBottom = H * 0.88;
  const bW = bRight - bLeft;
  const bH = bBottom - bTop;

  ctx.fillStyle = 'rgba(15,20,40,0.5)';
  ctx.beginPath();
  ctx.roundRect(bLeft - 15, bTop - 30, bW + 30, bH + 50, 8);
  ctx.fill();

  ctx.fillStyle = '#8af';
  ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('P(Disease B | Disease A status)', (bLeft + bRight) / 2, bTop - 12);

  const source = view === 'all' ? people : people.filter(p => p.hospitalized);
  const withA = source.filter(p => p.hasA);
  const withoutA = source.filter(p => !p.hasA);
  const pBgivenA = withA.length > 0 ? withA.filter(p => p.hasB).length / withA.length : 0;
  const pBgivenNotA = withoutA.length > 0 ? withoutA.filter(p => p.hasB).length / withoutA.length : 0;

  const barWidth = bW * 0.25;
  const maxH = bH * 0.85;

  // Bar: Has A
  const x1 = bLeft + bW * 0.2;
  const h1 = pBgivenA * maxH;
  const grad1 = ctx.createLinearGradient(x1, bBottom - h1, x1, bBottom);
  grad1.addColorStop(0, 'rgba(255,100,80,0.8)');
  grad1.addColorStop(1, 'rgba(255,100,80,0.3)');
  ctx.fillStyle = grad1;
  ctx.fillRect(x1, bBottom - h1, barWidth, h1);
  ctx.fillStyle = '#fa8';
  ctx.font = 'bold 14px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText((pBgivenA * 100).toFixed(0) + '%', x1 + barWidth / 2, bBottom - h1 - 8);
  ctx.fillStyle = '#8ab';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  ctx.fillText('Has A', x1 + barWidth / 2, bBottom + 16);

  // Bar: No A
  const x2 = bLeft + bW * 0.55;
  const h2 = pBgivenNotA * maxH;
  const grad2 = ctx.createLinearGradient(x2, bBottom - h2, x2, bBottom);
  grad2.addColorStop(0, 'rgba(80,160,255,0.8)');
  grad2.addColorStop(1, 'rgba(80,160,255,0.3)');
  ctx.fillStyle = grad2;
  ctx.fillRect(x2, bBottom - h2, barWidth, h2);
  ctx.fillStyle = '#8cf';
  ctx.font = 'bold 14px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText((pBgivenNotA * 100).toFixed(0) + '%', x2 + barWidth / 2, bBottom - h2 - 8);
  ctx.fillStyle = '#8ab';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  ctx.fillText('No A', x2 + barWidth / 2, bBottom + 16);

  // Y axis
  ctx.strokeStyle = 'rgba(120,160,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(bLeft, bTop + 5);
  ctx.lineTo(bLeft, bBottom);
  ctx.lineTo(bRight, bBottom);
  ctx.stroke();

  // Axis label
  ctx.save();
  ctx.translate(bLeft - 12, (bTop + bBottom) / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = '#6a8';
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('P(B)', 0, 0);
  ctx.restore();

  // Direction arrow showing paradox
  if (view === 'hospital' && pBgivenNotA > pBgivenA * 1.1) {
    ctx.fillStyle = '#f55';
    ctx.font = 'bold 12px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Negative correlation appears!', (bLeft + bRight) / 2, bTop + 4);
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  // Title
  ctx.fillStyle = '#c8d8e8';
  ctx.font = 'bold 16px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(view === 'all' ? 'Full Population' : 'Hospital Only (at least one disease)', W * 0.06, H * 0.04);

  // Legend
  const lx = W * 0.06;
  const ly = H * 0.93;
  ctx.font = '11px Segoe UI, Arial, sans-serif';

  ctx.fillStyle = 'rgba(255,100,80,0.7)';
  ctx.fillRect(lx, ly - 5, 12, 12);
  ctx.fillStyle = '#c8d8e8';
  ctx.fillText('Disease A only', lx + 16, ly + 5);

  ctx.fillStyle = 'rgba(80,160,255,0.7)';
  ctx.fillRect(lx + 120, ly - 5, 12, 12);
  ctx.fillStyle = '#c8d8e8';
  ctx.fillText('Disease B only', lx + 136, ly + 5);

  ctx.fillStyle = 'rgba(200,100,255,0.7)';
  ctx.fillRect(lx + 240, ly - 5, 12, 12);
  ctx.fillStyle = '#c8d8e8';
  ctx.fillText('Both', lx + 256, ly + 5);

  ctx.fillStyle = 'rgba(80,100,120,0.4)';
  ctx.fillRect(lx + 310, ly - 5, 12, 12);
  ctx.fillStyle = '#c8d8e8';
  ctx.fillText('Neither', lx + 326, ly + 5);

  // Population grid
  for (const p of people) {
    if (!p.visible) continue;
    drawPerson(p.drawX || p.targetX, p.drawY || p.targetY, p.size, p.hasA, p.hasB);
  }

  drawScatterPlot();
  drawBarChart();
}

// Event listeners
document.getElementById('sA').addEventListener('input', function() {
  document.getElementById('vA').textContent = this.value + '%';
});
document.getElementById('sB').addEventListener('input', function() {
  document.getElementById('vB').textContent = this.value + '%';
});
document.getElementById('sN').addEventListener('input', function() {
  document.getElementById('vN').textContent = this.value;
});
document.getElementById('sA').addEventListener('change', generate);
document.getElementById('sB').addEventListener('change', generate);
document.getElementById('sN').addEventListener('change', generate);

window.addEventListener('resize', resize);

window.reset = function() {
  view = 'all';
  document.getElementById('bAll').classList.add('active');
  document.getElementById('bHosp').classList.remove('active');
  document.getElementById('sA').value = 30;
  document.getElementById('sB').value = 25;
  document.getElementById('sN').value = 400;
  document.getElementById('vA').textContent = '30%';
  document.getElementById('vB').textContent = '25%';
  document.getElementById('vN').textContent = '400';
  generate();
};

let animTime = 0;
function animate() {
  animTime += 0.015;
  // Gentle floating motion for people
  for (const p of people) {
    if (p.visible) {
      p.drawX = p.targetX + Math.sin(animTime * 1.5 + p.targetX * 0.01) * 1.5;
      p.drawY = p.targetY + Math.cos(animTime * 1.2 + p.targetY * 0.01) * 1.5;
    }
  }
  draw();
  requestAnimationFrame(animate);
}

resize();
generate();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
