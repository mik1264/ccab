<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gambler's Fallacy - Streaks Don't Change the Odds</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 280px; max-width: 320px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn.active { background: rgba(138,154,91,0.5); border-color: #8A9A5B; }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .stats-box {
            margin-top: 12px; padding: 10px; background: rgba(10,14,26,0.6);
            border-radius: 6px; font-size: 11px; line-height: 1.7;
        }
        .stats-box .label { color: #8899aa; }
        .stats-box .value { color: #DDA15E; font-family: monospace; font-weight: 600; }
        .strategy-row { display: flex; align-items: center; gap: 8px; margin: 3px 0; }
        .strategy-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .info-panel {
            position: fixed; bottom: 18px; left: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 16px; color: #c8d0e0;
            max-width: 380px; border: 1px solid rgba(138,154,91,0.3);
        }
        .info-panel h3 { color: #DDA15E; font-size: 14px; margin-bottom: 6px; }
        .info-panel p { font-size: 11px; color: #8899aa; line-height: 1.5; }
        .info-panel .key { color: #8A9A5B; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Probability Paradoxes</a>
    <div class="controls">
        <h2>Gambler's Fallacy</h2>
        <p class="desc">After 10 heads in a row, is tails "due"? No! Each flip is independent. Three betting strategies all converge to the same result.</p>
        <div class="control-row">
            <label>Flips per second <span id="speedVal">10</span></label>
            <input type="range" id="speed" min="1" max="100" step="1" value="10">
        </div>
        <div class="stats-box">
            <div><span class="label">Total flips: </span><span class="value" id="statFlips">0</span></div>
            <div><span class="label">Heads: </span><span class="value" id="statHeads">0</span> <span class="label">Tails: </span><span class="value" id="statTails">0</span></div>
            <div><span class="label">Current streak: </span><span class="value" id="statStreak">--</span></div>
            <div><span class="label">Longest streak: </span><span class="value" id="statLongest">0</span></div>
            <div style="margin-top: 8px; font-size: 11px; color: #aabbcc; font-weight: 600;">Strategies (bankroll):</div>
            <div class="strategy-row"><span class="strategy-dot" style="background:#e06060"></span><span class="label">Bet against streak: </span><span class="value" id="stratAnti">$1000</span></div>
            <div class="strategy-row"><span class="strategy-dot" style="background:#60a0e0"></span><span class="label">Bet with streak: </span><span class="value" id="stratWith">$1000</span></div>
            <div class="strategy-row"><span class="strategy-dot" style="background:#8A9A5B"></span><span class="label">Random bet: </span><span class="value" id="stratRandom">$1000</span></div>
        </div>
        <div class="btn-row">
            <button class="btn" onclick="window.reset()">Reset</button>
            <button class="btn" id="pauseBtn" onclick="togglePause()">Pause</button>
            <button class="btn" onclick="flipOnce()">Flip 1</button>
            <button class="btn" onclick="flip100()">Flip 100</button>
        </div>
    </div>
    <div class="info-panel">
        <h3>The Fallacy</h3>
        <p>The <span class="key">gambler's fallacy</span> is the belief that past results affect future independent events. After 10 heads, the next flip is still <span class="key">exactly 50/50</span>.</p>
        <p style="margin-top:6px;">Three strategies are tested: <span style="color:#e06060">bet against streaks</span> ("tails is due"), <span style="color:#60a0e0">bet with streaks</span> ("hot hand"), and <span style="color:#8A9A5B">random bets</span>. All converge to the <span class="key">same expected value</span>.</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        let flipsPerSecond = 10;
        let paused = false;
        let flipAccum = 0;

        // State
        let results = []; // 0=heads, 1=tails
        let heads = 0, tails = 0;
        let currentStreak = 0;
        let currentStreakType = -1;
        let longestStreak = 0;
        let streakLengths = [];

        // Strategies: bankroll
        let bankAnti = 1000;
        let bankWith = 1000;
        let bankRandom = 1000;
        let bankHistory = { anti: [1000], with: [1000], random: [1000] };

        // Coin animation
        let coinAngle = 0;
        let coinResult = -1;
        let coinFlipping = false;
        let coinFlipTimer = 0;
        let lastFlipResult = -1;

        // After-streak tracking
        let afterStreakData = []; // { streakLen, streakType, nextResult }

        function doFlip() {
            const result = Math.random() < 0.5 ? 0 : 1;
            results.push(result);
            if (result === 0) heads++; else tails++;

            // Streak tracking
            if (results.length === 1 || result === currentStreakType) {
                currentStreak++;
            } else {
                if (currentStreak >= 3 && results.length > 1) {
                    afterStreakData.push({ len: currentStreak, type: currentStreakType, next: result });
                }
                streakLengths.push(currentStreak);
                currentStreak = 1;
            }
            currentStreakType = result;
            longestStreak = Math.max(longestStreak, currentStreak);

            // Strategy bets (bet $10 each flip)
            const bet = 10;
            // Anti-streak: after 2+ same, bet opposite
            let antiBet;
            if (currentStreak >= 2 && results.length > 1) {
                antiBet = 1 - currentStreakType; // bet opposite
            } else {
                antiBet = Math.random() < 0.5 ? 0 : 1;
            }
            bankAnti += (antiBet === result) ? bet : -bet;

            // With-streak: after 2+ same, bet same
            let withBet;
            if (currentStreak >= 2 && results.length > 1) {
                withBet = currentStreakType;
            } else {
                withBet = Math.random() < 0.5 ? 0 : 1;
            }
            bankWith += (withBet === result) ? bet : -bet;

            // Random
            const randBet = Math.random() < 0.5 ? 0 : 1;
            bankRandom += (randBet === result) ? bet : -bet;

            if (results.length % 5 === 0 || results.length < 20) {
                bankHistory.anti.push(bankAnti);
                bankHistory.with.push(bankWith);
                bankHistory.random.push(bankRandom);
                // Keep history manageable
                if (bankHistory.anti.length > 600) {
                    bankHistory.anti = bankHistory.anti.filter((_, i) => i % 2 === 0);
                    bankHistory.with = bankHistory.with.filter((_, i) => i % 2 === 0);
                    bankHistory.random = bankHistory.random.filter((_, i) => i % 2 === 0);
                }
            }

            lastFlipResult = result;
            coinResult = result;
            coinFlipping = true;
            coinFlipTimer = 0.3;
        }

        window.flipOnce = function() { doFlip(); updateStats(); };
        window.flip100 = function() { for (let i = 0; i < 100; i++) doFlip(); updateStats(); };

        window.reset = function() {
            results = [];
            heads = 0; tails = 0;
            currentStreak = 0; currentStreakType = -1; longestStreak = 0;
            streakLengths = [];
            bankAnti = 1000; bankWith = 1000; bankRandom = 1000;
            bankHistory = { anti: [1000], with: [1000], random: [1000] };
            afterStreakData = [];
            coinResult = -1;
            coinFlipping = false;
            flipAccum = 0;
        };

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        }
        window.togglePause = togglePause;

        document.getElementById('speed').addEventListener('input', function() {
            flipsPerSecond = +this.value;
            document.getElementById('speedVal').textContent = flipsPerSecond;
        });

        function updateStats() {
            document.getElementById('statFlips').textContent = results.length;
            document.getElementById('statHeads').textContent = heads;
            document.getElementById('statTails').textContent = tails;
            const streakName = currentStreakType === 0 ? 'H' : currentStreakType === 1 ? 'T' : '-';
            document.getElementById('statStreak').textContent = currentStreak + 'x ' + streakName;
            document.getElementById('statLongest').textContent = longestStreak;
            document.getElementById('stratAnti').textContent = '$' + bankAnti.toFixed(0);
            document.getElementById('stratWith').textContent = '$' + bankWith.toFixed(0);
            document.getElementById('stratRandom').textContent = '$' + bankRandom.toFixed(0);
        }

        function drawCoin(cx, cy, radius) {
            const flipProgress = coinFlipping ? Math.max(0, coinFlipTimer / 0.3) : 0;
            const scaleX = coinFlipping ? Math.abs(Math.cos(flipProgress * Math.PI * 4)) : 1;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(scaleX, 1);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(4, 6, radius, radius * 0.95, 0, 0, Math.PI * 2);
            ctx.fill();

            // Coin body
            const isHeads = coinResult === 0 || coinResult === -1;
            const gradient = ctx.createRadialGradient(-radius * 0.3, -radius * 0.3, 0, 0, 0, radius);
            if (isHeads) {
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#B8860B');
            } else {
                gradient.addColorStop(0, '#C0C0C0');
                gradient.addColorStop(1, '#808080');
            }
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            // Edge
            ctx.strokeStyle = isHeads ? '#8B6914' : '#606060';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, radius - 1, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring
            ctx.strokeStyle = isHeads ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            ctx.stroke();

            // Text
            ctx.fillStyle = isHeads ? '#8B6914' : '#404040';
            ctx.font = `bold ${radius * 0.5}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(isHeads ? 'H' : 'T', 0, 0);

            ctx.restore();
        }

        function drawRecentResults() {
            const rx = 0.05 * W;
            const ry = 0.15 * H;
            const showCount = Math.min(results.length, 40);

            ctx.fillStyle = '#667788';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Recent Flips:', rx, ry - 8);

            for (let i = 0; i < showCount; i++) {
                const idx = results.length - showCount + i;
                const r = results[idx];
                const col = Math.floor(i / 10);
                const row = i % 10;
                const x = rx + col * 42;
                const y = ry + row * 20;

                ctx.fillStyle = r === 0 ? '#FFD700' : '#A0A0A0';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(r === 0 ? 'H' : 'T', x, y + 12);
            }
        }

        function drawBankrollChart() {
            const cx = 0.06 * W;
            const cy = 0.58 * H;
            const cw = 0.4 * W;
            const ch = 0.32 * H;

            // Background
            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(cx - 10, cy - 25, cw + 20, ch + 45, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Bankroll Over Time', cx, cy - 8);

            const hist = bankHistory;
            if (hist.anti.length < 2) return;

            const allVals = [...hist.anti, ...hist.with, ...hist.random];
            const minV = Math.min(...allVals);
            const maxV = Math.max(...allVals);
            const range = Math.max(1, maxV - minV);
            const len = hist.anti.length;

            function drawLine(data, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = cx + (i / (len - 1)) * cw;
                    const y = cy + ch - ((data[i] - minV) / range) * ch;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            drawLine(hist.anti, '#e06060');
            drawLine(hist.with, '#60a0e0');
            drawLine(hist.random, '#8A9A5B');

            // Baseline
            if (minV <= 1000 && maxV >= 1000) {
                const baseY = cy + ch - ((1000 - minV) / range) * ch;
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(cx, baseY);
                ctx.lineTo(cx + cw, baseY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#556677';
                ctx.font = '9px monospace';
                ctx.textAlign = 'right';
                ctx.fillText('$1000', cx - 4, baseY + 3);
            }

            // Legend
            const ly = cy + ch + 18;
            ctx.font = '10px sans-serif';
            [['#e06060', 'Anti-streak'], ['#60a0e0', 'With-streak'], ['#8A9A5B', 'Random']].forEach(([c, l], i) => {
                const lx = cx + i * 100;
                ctx.fillStyle = c;
                ctx.fillRect(lx, ly - 4, 12, 4);
                ctx.fillStyle = '#8899aa';
                ctx.textAlign = 'left';
                ctx.fillText(l, lx + 16, ly);
            });
        }

        function drawStreakHistogram() {
            const sx = 0.52 * W;
            const sy = 0.58 * H;
            const sw = 0.35 * W;
            const sh = 0.32 * H;

            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(sx - 10, sy - 25, sw + 20, sh + 45, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Streak Length Distribution', sx, sy - 8);

            if (streakLengths.length < 5) {
                ctx.fillStyle = '#556677';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Collecting data...', sx + sw / 2, sy + sh / 2);
                return;
            }

            // Count streak lengths
            const maxStreak = Math.min(15, Math.max(...streakLengths));
            const counts = new Array(maxStreak + 1).fill(0);
            for (const s of streakLengths) {
                const bin = Math.min(maxStreak, s);
                counts[bin]++;
            }
            const maxCount = Math.max(1, ...counts);
            const barW = sw / (maxStreak + 1);

            for (let i = 1; i <= maxStreak; i++) {
                const barH = (counts[i] / maxCount) * sh * 0.85;
                const x = sx + (i - 1) * barW;
                const y = sy + sh - barH;
                ctx.fillStyle = `hsl(${40 + i * 15}, 60%, 55%)`;
                ctx.fillRect(x + 2, y, barW - 4, barH);
                ctx.fillStyle = '#8899aa';
                ctx.font = '9px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x + barW / 2, sy + sh + 14);
            }

            // Theoretical (geometric) overlay
            if (streakLengths.length > 20) {
                ctx.strokeStyle = 'rgba(221,161,94,0.7)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                const total = streakLengths.length;
                for (let i = 1; i <= maxStreak; i++) {
                    const expected = total * Math.pow(0.5, i);
                    const h = (expected / maxCount) * sh * 0.85;
                    const x = sx + (i - 1) * barW + barW / 2;
                    const y = sy + sh - h;
                    if (i === 1) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#DDA15E';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('-- Expected (geometric)', sx, sy + sh + 30);
            }

            ctx.fillStyle = '#667788';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Streak Length', sx + sw / 2, sy + sh + 30);
        }

        let lastTime = 0;
        function animate(ts) {
            const dt = lastTime ? (ts - lastTime) / 1000 : 0;
            lastTime = ts;

            if (!paused) {
                flipAccum += dt * flipsPerSecond;
                while (flipAccum >= 1) {
                    doFlip();
                    flipAccum -= 1;
                }
                if (coinFlipping) {
                    coinFlipTimer -= dt;
                    if (coinFlipTimer <= 0) coinFlipping = false;
                }
                if (results.length % 10 === 0) updateStats();
            }

            // Draw
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Big coin
            const coinCX = 0.3 * W;
            const coinCY = 0.28 * H;
            drawCoin(coinCX, coinCY, Math.min(80, W * 0.08));

            // "After N heads, P(heads) = ?" display
            if (results.length > 0) {
                ctx.fillStyle = '#aabbcc';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                if (currentStreak >= 3) {
                    const sym = currentStreakType === 0 ? 'HEADS' : 'TAILS';
                    ctx.fillText(`After ${currentStreak} ${sym} in a row:`, coinCX, coinCY + 100);
                    ctx.fillStyle = '#DDA15E';
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillText('Next flip is still 50/50', coinCX, coinCY + 125);
                }
            }

            drawRecentResults();
            drawBankrollChart();
            drawStreakHistogram();

            // Title
            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("The Gambler's Fallacy", W / 2, 40);
            ctx.fillStyle = '#667788';
            ctx.font = '13px sans-serif';
            ctx.fillText('Past results do not affect future independent events', W / 2, 60);

            updateStats();
            requestAnimationFrame(animate);
        }

        window.reset();
        requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
