<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sleeping Beauty Problem - Halfer vs Thirder</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.1em; }
a.back:hover { color: #bdf; }

#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 240px; max-width: 280px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.8em; color: #8ab; margin-bottom: 3px; }
.ctrl-row input[type=range] { width: 100%; accent-color: #6af; }
.ctrl-row .val { float: right; font-size: 0.8em; color: #adf; }
.btn {
  background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3);
  color: #8af; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px;
}
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }

#info {
  position: fixed; bottom: 20px; left: 20px; z-index: 100; max-width: 400px;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.1); border-radius: 12px;
  padding: 14px 18px; font-size: 0.82em; line-height: 1.5; color: #8ab;
}
#info h4 { color: #8af; margin-bottom: 6px; }
#info .highlight { color: #f8a; font-weight: bold; }

#simStats {
  position: fixed; bottom: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); border: 1px solid rgba(120,160,255,0.1);
  border-radius: 12px; padding: 14px 18px; min-width: 220px;
}
#simStats h4 { color: #8af; margin-bottom: 8px; font-size: 0.85em; text-transform: uppercase; letter-spacing: 1px; }
.sim-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 0.85em; }
.sim-label { color: #6a8; }
.sim-val { font-weight: bold; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="c"></canvas>

<div id="controls">
  <h3>Sleeping Beauty</h3>
  <div class="ctrl-row">
    <label>Extra Tails Wakings <span class="val" id="vExtra">1</span></label>
    <input type="range" id="sExtra" min="1" max="10" step="1" value="1">
  </div>
  <div style="margin-top:8px;">
    <button class="btn" onclick="flipCoin()">Flip Coin</button>
    <button class="btn" id="bSim" onclick="toggleSim()">Run Simulation</button>
    <button class="btn" onclick="resetSim()">Reset Stats</button>
  </div>
  <div style="margin-top:10px; border-top: 1px solid rgba(120,160,255,0.1); padding-top:8px;">
    <div style="font-size:0.78em; color:#6a8; margin-bottom:5px;">Philosophy:</div>
    <button class="btn" id="bThird" onclick="setPhil('thirder')">Thirder (1/3)</button>
    <button class="btn" id="bHalf" onclick="setPhil('halfer')">Halfer (1/2)</button>
  </div>
</div>

<div id="info">
  <h4>The Paradox</h4>
  Sleeping Beauty is put to sleep on Sunday. A fair coin is flipped.
  <span class="highlight">Heads</span>: she wakes Monday only.
  <span class="highlight">Tails</span>: she wakes Monday AND Tuesday (memory erased between).
  <br><br>
  When she wakes, what should her credence in Heads be?<br>
  <span class="highlight">Thirders</span>: 3 possible awakenings, only 1 is Heads, so P(H) = 1/3.<br>
  <span class="highlight">Halfers</span>: The coin is fair, nothing changes that, so P(H) = 1/2.<br>
  <br>This is one of the most debated problems in modern philosophy of probability.
</div>

<div id="simStats">
  <h4>Simulation Results</h4>
  <div class="sim-row">
    <span class="sim-label">Total experiments:</span>
    <span class="sim-val" id="totalExp">0</span>
  </div>
  <div class="sim-row">
    <span class="sim-label">Heads flips:</span>
    <span class="sim-val" id="headsFlips" style="color:#f84;">0</span>
  </div>
  <div class="sim-row">
    <span class="sim-label">Tails flips:</span>
    <span class="sim-val" id="tailsFlips" style="color:#4af;">0</span>
  </div>
  <div style="border-top: 1px solid rgba(120,160,255,0.1); margin-top:6px; padding-top:6px;">
    <div class="sim-row">
      <span class="sim-label">Total awakenings:</span>
      <span class="sim-val" id="totalWake">0</span>
    </div>
    <div class="sim-row">
      <span class="sim-label">Heads awakenings:</span>
      <span class="sim-val" id="headsWake" style="color:#f84;">0</span>
    </div>
    <div class="sim-row">
      <span class="sim-label">Tails awakenings:</span>
      <span class="sim-val" id="tailsWake" style="color:#4af;">0</span>
    </div>
  </div>
  <div style="border-top: 1px solid rgba(120,160,255,0.1); margin-top:6px; padding-top:6px;">
    <div class="sim-row">
      <span class="sim-label">P(H) per flip:</span>
      <span class="sim-val" id="pFlip" style="color:#fa8;">--</span>
    </div>
    <div class="sim-row">
      <span class="sim-label">P(H) per waking:</span>
      <span class="sim-val" id="pWake" style="color:#fa8;">--</span>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let extraWakings = 1;
let currentResult = null; // { coin: 'heads'|'tails', day: 'sunday'|'monday'|'tuesday', phase: 0..1 }
let simRunning = false;
let simFrame = null;
let stats = { experiments: 0, heads: 0, tails: 0, headsWake: 0, tailsWake: 0 };
let philosophy = null;
let coinAnim = null; // { progress: 0..1, result: 'heads'|'tails' }
let trialHistory = []; // last N trials for visualization

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  draw();
}

function flipCoin() {
  if (coinAnim) return;
  const coin = Math.random() < 0.5 ? 'heads' : 'tails';
  coinAnim = { progress: 0, result: coin };
  currentResult = { coin, phase: 0 };

  stats.experiments++;
  if (coin === 'heads') {
    stats.heads++;
    stats.headsWake += 1;
  } else {
    stats.tails++;
    stats.tailsWake += (1 + extraWakings);
  }

  trialHistory.push(coin);
  if (trialHistory.length > 50) trialHistory.shift();

  updateSimStats();
  animateCoin();
}

function animateCoin() {
  if (!coinAnim) return;
  coinAnim.progress += 0.02;
  if (coinAnim.progress >= 1) {
    coinAnim.progress = 1;
    draw();
    setTimeout(() => { coinAnim = null; draw(); }, 500);
    return;
  }
  draw();
  requestAnimationFrame(animateCoin);
}

function toggleSim() {
  if (simRunning) {
    simRunning = false;
    document.getElementById('bSim').classList.remove('active');
    if (simFrame) cancelAnimationFrame(simFrame);
    return;
  }
  simRunning = true;
  document.getElementById('bSim').classList.add('active');
  runSimStep();
}

function runSimStep() {
  if (!simRunning) return;
  // Run batch
  for (let i = 0; i < 10; i++) {
    const coin = Math.random() < 0.5 ? 'heads' : 'tails';
    stats.experiments++;
    if (coin === 'heads') {
      stats.heads++;
      stats.headsWake += 1;
    } else {
      stats.tails++;
      stats.tailsWake += (1 + extraWakings);
    }
    trialHistory.push(coin);
    if (trialHistory.length > 50) trialHistory.shift();
  }
  updateSimStats();
  draw();
  simFrame = requestAnimationFrame(runSimStep);
}

function resetSim() {
  simRunning = false;
  document.getElementById('bSim').classList.remove('active');
  if (simFrame) cancelAnimationFrame(simFrame);
  stats = { experiments: 0, heads: 0, tails: 0, headsWake: 0, tailsWake: 0 };
  trialHistory = [];
  currentResult = null;
  coinAnim = null;
  updateSimStats();
  draw();
}

function updateSimStats() {
  document.getElementById('totalExp').textContent = stats.experiments;
  document.getElementById('headsFlips').textContent = stats.heads;
  document.getElementById('tailsFlips').textContent = stats.tails;

  const totalWake = stats.headsWake + stats.tailsWake;
  document.getElementById('totalWake').textContent = totalWake;
  document.getElementById('headsWake').textContent = stats.headsWake;
  document.getElementById('tailsWake').textContent = stats.tailsWake;

  document.getElementById('pFlip').textContent = stats.experiments > 0
    ? (stats.heads / stats.experiments * 100).toFixed(1) + '%'
    : '--';
  document.getElementById('pWake').textContent = totalWake > 0
    ? (stats.headsWake / totalWake * 100).toFixed(1) + '%'
    : '--';
}

function setPhil(p) {
  philosophy = p;
  document.getElementById('bThird').classList.toggle('active', p === 'thirder');
  document.getElementById('bHalf').classList.toggle('active', p === 'halfer');
  draw();
}

function drawTimeline() {
  const tlLeft = W * 0.06;
  const tlRight = W * 0.55;
  const tlY = H * 0.18;
  const tlW = tlRight - tlLeft;

  // Title
  ctx.fillStyle = '#c8d8e8';
  ctx.font = 'bold 16px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Experiment Timeline', tlLeft, tlY - 30);

  // Timeline line
  ctx.strokeStyle = 'rgba(120,160,255,0.3)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(tlLeft, tlY);
  ctx.lineTo(tlRight, tlY);
  ctx.stroke();

  // Day markers
  const days = ['Sunday', 'Monday', 'Tuesday'];
  const dayX = [tlLeft, tlLeft + tlW * 0.4, tlLeft + tlW * 0.8];

  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(dayX[i], tlY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#0a0e1a';
    ctx.fill();
    ctx.strokeStyle = '#8af';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = '#8af';
    ctx.font = 'bold 12px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(days[i], dayX[i], tlY - 16);
  }

  // Coin flip on Sunday
  ctx.fillStyle = '#fa8';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Coin Flip', dayX[0], tlY + 20);

  // Branching paths
  const branchY1 = tlY + 50; // Heads path
  const branchY2 = tlY + 110; // Tails path
  const tailsExtraY = tlY + 145;

  // Heads path
  ctx.strokeStyle = 'rgba(255,136,68,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(dayX[0], tlY + 6);
  ctx.quadraticCurveTo(dayX[0] + 40, branchY1, dayX[1], branchY1);
  ctx.stroke();

  // Heads: Monday wake
  ctx.beginPath();
  ctx.arc(dayX[1], branchY1, 18, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,136,68,0.15)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,136,68,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = '#f84';
  ctx.font = 'bold 11px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('WAKE', dayX[1], branchY1 + 4);

  ctx.fillStyle = '#f84';
  ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('HEADS', dayX[0] + 20, branchY1 - 2);

  // Arrow to end
  ctx.strokeStyle = 'rgba(255,136,68,0.3)';
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(dayX[1] + 18, branchY1);
  ctx.lineTo(dayX[2], branchY1);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(255,136,68,0.5)';
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('(stays asleep)', dayX[2], branchY1 + 4);

  // Tails path
  ctx.strokeStyle = 'rgba(80,170,255,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(dayX[0], tlY + 6);
  ctx.quadraticCurveTo(dayX[0] + 40, branchY2, dayX[1], branchY2);
  ctx.stroke();

  // Tails: Monday wake
  ctx.beginPath();
  ctx.arc(dayX[1], branchY2, 18, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(80,170,255,0.15)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(80,170,255,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = '#4af';
  ctx.font = 'bold 11px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('WAKE', dayX[1], branchY2 + 4);

  // Memory erase
  ctx.strokeStyle = 'rgba(80,170,255,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(dayX[1] + 18, branchY2);
  ctx.lineTo(dayX[2], branchY2);
  ctx.stroke();
  ctx.fillStyle = 'rgba(200,100,255,0.6)';
  ctx.font = '9px Segoe UI, Arial, sans-serif';
  const midX = (dayX[1] + dayX[2]) / 2;
  ctx.fillText('memory erased', midX, branchY2 - 8);

  // Tails: Tuesday wake
  ctx.beginPath();
  ctx.arc(dayX[2], branchY2, 18, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(80,170,255,0.15)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(80,170,255,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = '#4af';
  ctx.font = 'bold 11px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('WAKE', dayX[2], branchY2 + 4);

  ctx.fillStyle = '#4af';
  ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('TAILS', dayX[0] + 20, branchY2 - 2);

  // Extra wakings indicator
  if (extraWakings > 1) {
    ctx.fillStyle = 'rgba(80,170,255,0.4)';
    ctx.font = '10px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`(+ ${extraWakings - 1} more wakings for Tails)`, dayX[2], branchY2 + 30);
  }

  // Current coin animation
  if (coinAnim) {
    const cx = dayX[0];
    const cy = tlY - 50;
    const p = coinAnim.progress;
    const bounces = 6;
    const flipAngle = p * bounces * Math.PI;
    const scaleY = Math.abs(Math.cos(flipAngle));
    const landedY = cy + p * 20;

    ctx.save();
    ctx.translate(cx, landedY);
    ctx.scale(1, Math.max(0.05, scaleY));

    ctx.beginPath();
    ctx.arc(0, 0, 22, 0, Math.PI * 2);
    ctx.fillStyle = coinAnim.result === 'heads' ? '#fa8' : '#4af';
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    if (scaleY > 0.3) {
      ctx.fillStyle = '#0a0e1a';
      ctx.font = 'bold 12px Segoe UI, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(coinAnim.result === 'heads' ? 'H' : 'T', 0, 0);
    }
    ctx.restore();
  }

  // Highlight current awakening if we have a result
  if (currentResult && !coinAnim) {
    const glowColor = currentResult.coin === 'heads' ? 'rgba(255,136,68,0.3)' : 'rgba(80,170,255,0.3)';
    const glowY = currentResult.coin === 'heads' ? branchY1 : branchY2;
    const glowX = dayX[1];
    ctx.beginPath();
    ctx.arc(glowX, glowY, 28, 0, Math.PI * 2);
    ctx.fillStyle = glowColor;
    ctx.fill();
  }
}

function drawArguments() {
  const argLeft = W * 0.06;
  const argRight = W * 0.55;
  const argTop = H * 0.55;
  const argW = (argRight - argLeft) / 2 - 10;
  const argH = H * 0.38;

  // Thirder box
  const tx = argLeft;
  const ty = argTop;
  const isThirder = philosophy === 'thirder';
  ctx.fillStyle = isThirder ? 'rgba(100,200,150,0.08)' : 'rgba(15,20,40,0.4)';
  ctx.strokeStyle = isThirder ? 'rgba(100,200,150,0.4)' : 'rgba(120,160,255,0.1)';
  ctx.lineWidth = isThirder ? 2 : 1;
  ctx.beginPath();
  ctx.roundRect(tx, ty, argW, argH, 8);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = isThirder ? '#4f8' : '#8af';
  ctx.font = 'bold 14px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Thirder: P(Heads) = 1/3', tx + 12, ty + 22);

  ctx.fillStyle = '#8ab';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  const thirderLines = [
    'Three possible awakenings:',
    '',
    '  1. Heads + Monday',
    '  2. Tails + Monday',
    '  3. Tails + Tuesday',
    '',
    'Each equally likely from',
    'Beauty\'s perspective.',
    '',
    'Only 1 of 3 follows Heads,',
    'so P(H) = 1/3.',
  ];
  if (extraWakings > 1) {
    thirderLines.push('', `With ${1 + extraWakings} tails wakings:`,
      `P(H) = 1/${2 + extraWakings}`);
  }
  for (let i = 0; i < thirderLines.length; i++) {
    ctx.fillText(thirderLines[i], tx + 12, ty + 42 + i * 16);
  }

  // Halfer box
  const hx = argLeft + argW + 20;
  const hy = argTop;
  const isHalfer = philosophy === 'halfer';
  ctx.fillStyle = isHalfer ? 'rgba(100,200,150,0.08)' : 'rgba(15,20,40,0.4)';
  ctx.strokeStyle = isHalfer ? 'rgba(100,200,150,0.4)' : 'rgba(120,160,255,0.1)';
  ctx.lineWidth = isHalfer ? 2 : 1;
  ctx.beginPath();
  ctx.roundRect(hx, hy, argW, argH, 8);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = isHalfer ? '#4f8' : '#8af';
  ctx.font = 'bold 14px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Halfer: P(Heads) = 1/2', hx + 12, hy + 22);

  ctx.fillStyle = '#8ab';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  const halferLines = [
    'The coin is fair.',
    '',
    'Beauty learns nothing new',
    'upon waking -- she knew',
    'she would be woken.',
    '',
    'No new evidence means no',
    'update from the prior.',
    '',
    'P(H) = 1/2 regardless of',
    'the waking protocol.',
  ];
  for (let i = 0; i < halferLines.length; i++) {
    ctx.fillText(halferLines[i], hx + 12, hy + 42 + i * 16);
  }
}

function drawSimChart() {
  if (trialHistory.length === 0) return;

  const cLeft = W * 0.6;
  const cRight = W * 0.88;
  const cTop = H * 0.08;
  const cBottom = H * 0.42;
  const cW = cRight - cLeft;
  const cH = cBottom - cTop;

  ctx.fillStyle = 'rgba(15,20,40,0.5)';
  ctx.beginPath();
  ctx.roundRect(cLeft - 10, cTop - 25, cW + 20, cH + 40, 8);
  ctx.fill();

  ctx.fillStyle = '#8af';
  ctx.font = 'bold 13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Fraction of Heads Awakenings Over Time', (cLeft + cRight) / 2, cTop - 8);

  // Axes
  ctx.strokeStyle = 'rgba(120,160,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cLeft, cTop);
  ctx.lineTo(cLeft, cBottom);
  ctx.lineTo(cRight, cBottom);
  ctx.stroke();

  // Y axis: 0 to 1
  ctx.fillStyle = '#6a8';
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'right';
  for (let p = 0; p <= 1; p += 0.25) {
    const y = cBottom - p * cH;
    ctx.fillText((p * 100).toFixed(0) + '%', cLeft - 6, y + 4);
    ctx.strokeStyle = 'rgba(120,160,255,0.07)';
    ctx.beginPath(); ctx.moveTo(cLeft, y); ctx.lineTo(cRight, y); ctx.stroke();
  }

  // Reference lines
  // 1/2 line (halfer)
  const halfY = cBottom - 0.5 * cH;
  ctx.strokeStyle = 'rgba(255,136,68,0.4)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(cLeft, halfY); ctx.lineTo(cRight, halfY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#f84';
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('1/2 (halfer)', cRight + 4, halfY + 4);

  // 1/(1+extraWakings+1)... wait, 1/(2+extraWakings) is wrong. It's 1/(1+1+extraWakings) = 1/(2+extraWakings)
  // Actually standard: heads=1 waking, tails=1+extraWakings wakings.
  // Thirder fraction = 1 / (1 + 1 + extraWakings) ... no.
  // P(H awakening) = 1 / (1 + (1+extraWakings)) = 1/(2+extraWakings)
  const thirderFrac = 1 / (1 + 1 + extraWakings - 1);
  // Standard: heads gives 1, tails gives (1+extraWakings). Total = 1 + 1 + extraWakings... no.
  // Per experiment: P(heads) = 0.5 → 1 waking. P(tails)=0.5 → (1+extra) wakings.
  // Fraction of heads awakenings = 0.5 * 1 / (0.5 * 1 + 0.5 * (1+extra)) = 1/(2+extra)
  const thirderTarget = 1 / (2 + extraWakings);

  const thirdY = cBottom - thirderTarget * cH;
  ctx.strokeStyle = 'rgba(80,170,255,0.4)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(cLeft, thirdY); ctx.lineTo(cRight, thirdY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#4af';
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(`1/${2 + extraWakings} (thirder)`, cRight + 4, thirdY + 4);

  // Running fraction line
  if (stats.experiments > 0) {
    let runH = 0, runTotal = 0;
    const points = [];
    const startIdx = Math.max(0, trialHistory.length - 50);
    // Compute cumulative from all stats for last point
    // But for the chart, recompute incrementally
    let cumH = 0, cumT = 0;
    for (let i = 0; i < trialHistory.length; i++) {
      if (trialHistory[i] === 'heads') {
        cumH += 1;
        cumT += 0;
      } else {
        cumH += 0;
        cumT += 1 + extraWakings;
      }
      if (i >= startIdx) {
        const frac = cumH / (cumH + cumT);
        const x = cLeft + ((i - startIdx) / Math.max(1, trialHistory.length - 1 - startIdx)) * cW;
        const y = cBottom - frac * cH;
        points.push({ x, y });
      }
    }

    if (points.length > 1) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      ctx.stroke();

      // Current value dot
      const last = points[points.length - 1];
      ctx.beginPath();
      ctx.arc(last.x, last.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
  }
}

function drawTrialDots() {
  if (trialHistory.length === 0) return;

  const dLeft = W * 0.6;
  const dTop = H * 0.48;
  const dW = W * 0.28;

  ctx.fillStyle = '#6a8';
  ctx.font = '11px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Recent trials (H=heads, T=tails):', dLeft, dTop);

  const dotSize = 8;
  const gap = 3;
  const perRow = Math.floor(dW / (dotSize * 2 + gap));

  for (let i = 0; i < trialHistory.length; i++) {
    const row = Math.floor(i / perRow);
    const col = i % perRow;
    const x = dLeft + col * (dotSize * 2 + gap) + dotSize;
    const y = dTop + 16 + row * (dotSize * 2 + gap) + dotSize;

    ctx.beginPath();
    ctx.arc(x, y, dotSize, 0, Math.PI * 2);
    ctx.fillStyle = trialHistory[i] === 'heads' ? 'rgba(255,136,68,0.6)' : 'rgba(80,170,255,0.6)';
    ctx.fill();
    ctx.strokeStyle = trialHistory[i] === 'heads' ? 'rgba(255,136,68,0.9)' : 'rgba(80,170,255,0.9)';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 8px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(trialHistory[i] === 'heads' ? 'H' : 'T', x, y);
    ctx.textBaseline = 'alphabetic';
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  drawTimeline();
  drawArguments();
  drawSimChart();
  drawTrialDots();
}

// Event listeners
document.getElementById('sExtra').addEventListener('input', function() {
  extraWakings = parseInt(this.value);
  document.getElementById('vExtra').textContent = this.value;
  // Recompute stats with new extra wakings
  if (trialHistory.length > 0) {
    stats.headsWake = 0;
    stats.tailsWake = 0;
    for (const t of trialHistory) {
      if (t === 'heads') stats.headsWake++;
      else stats.tailsWake += 1 + extraWakings;
    }
    updateSimStats();
  }
  draw();
});

window.addEventListener('resize', resize);

window.reset = function() {
  resetSim();
  extraWakings = 1;
  document.getElementById('sExtra').value = 1;
  document.getElementById('vExtra').textContent = '1';
  philosophy = null;
  document.getElementById('bThird').classList.remove('active');
  document.getElementById('bHalf').classList.remove('active');
  draw();
};

resize();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
