<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Will Rogers Phenomenon - Both Averages Rise</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; color: #c8d8e8; }
canvas { display: block; cursor: default; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.1em; }
a.back:hover { color: #bdf; }

#controls {
  position: fixed; top: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.15); border-radius: 12px;
  padding: 16px 20px; min-width: 220px; max-width: 260px;
}
#controls h3 { color: #8af; margin-bottom: 10px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.btn {
  background: rgba(100,160,255,0.15); border: 1px solid rgba(100,160,255,0.3);
  color: #8af; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8em; margin: 2px;
  display: inline-block;
}
.btn:hover { background: rgba(100,160,255,0.3); }
.btn.active { background: rgba(100,200,150,0.25); border-color: rgba(100,200,150,0.5); color: #8fa; }
.instruction { font-size: 0.78em; color: #6a8; margin-top: 8px; line-height: 1.4; }

#info {
  position: fixed; bottom: 20px; left: 20px; z-index: 100; max-width: 380px;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(120,160,255,0.1); border-radius: 12px;
  padding: 14px 18px; font-size: 0.82em; line-height: 1.5; color: #8ab;
}
#info h4 { color: #8af; margin-bottom: 6px; }
#info .highlight { color: #f8a; font-weight: bold; }

#stats {
  position: fixed; bottom: 20px; right: 20px; z-index: 100;
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px); border: 1px solid rgba(120,160,255,0.1);
  border-radius: 12px; padding: 14px 18px; min-width: 200px;
}
#stats h4 { color: #8af; margin-bottom: 8px; font-size: 0.85em; text-transform: uppercase; letter-spacing: 1px; }
.stat-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 0.85em; }
.stat-label { color: #6a8; }
.stat-val { font-weight: bold; }
.stat-change { font-size: 0.8em; margin-left: 4px; }
.up { color: #4f8; }
.down { color: #f55; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="c"></canvas>

<div id="controls">
  <h3>Will Rogers Phenomenon</h3>
  <div>
    <button class="btn" onclick="resetDemo()">Reset</button>
    <button class="btn" onclick="addDots()">Add More Dots</button>
    <button class="btn" onclick="autoDemo()">Auto Demo</button>
  </div>
  <div class="instruction">
    Click a dot near the boundary of Group A (left) to move it to Group B (right).
    Watch both means increase!
  </div>
  <div style="margin-top: 8px;">
    <button class="btn" onclick="showCancer()">Cancer Staging Example</button>
  </div>
</div>

<div id="info">
  <h4>The Paradox</h4>
  Named after Will Rogers' joke: "When the Okies left Oklahoma for California, they raised the
  average intelligence of both states." Moving an element that is <span class="highlight">below Group A's mean
  but above Group B's mean</span> raises both averages simultaneously.
  <br><br>
  Real-world: Improved cancer diagnostics reclassify mild Stage I patients to Stage II.
  Both stages show improved survival rates -- with zero actual medical improvement.
</div>

<div id="stats">
  <h4>Group Statistics</h4>
  <div class="stat-row">
    <span class="stat-label">Group A mean:</span>
    <span class="stat-val" id="meanA" style="color:#6af;">--</span>
  </div>
  <div class="stat-row">
    <span class="stat-label">Group A count:</span>
    <span class="stat-val" id="countA" style="color:#6af;">--</span>
  </div>
  <div class="stat-row" style="margin-top:8px;">
    <span class="stat-label">Group B mean:</span>
    <span class="stat-val" id="meanB" style="color:#f84;">--</span>
  </div>
  <div class="stat-row">
    <span class="stat-label">Group B count:</span>
    <span class="stat-val" id="countB" style="color:#f84;">--</span>
  </div>
  <div id="changeLog" style="margin-top:10px; border-top: 1px solid rgba(120,160,255,0.1); padding-top:8px; font-size:0.8em; max-height:100px; overflow-y:auto;"></div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let groupA = [];
let groupB = [];
let movingDot = null; // { value, fromGroup, progress, startX, startY, endX, endY }
let prevMeanA = 0, prevMeanB = 0;
let hovered = null;
let dragging = false;
let changeHistory = [];
let cancerMode = false;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  draw();
}

function mean(arr) {
  if (arr.length === 0) return 0;
  return arr.reduce((s, v) => s + v, 0) / arr.length;
}

function initData() {
  groupA = [];
  groupB = [];
  changeHistory = [];
  cancerMode = false;

  // Group A: higher values (e.g. 40-80)
  for (let i = 0; i < 15; i++) {
    groupA.push(40 + Math.random() * 40);
  }
  // Add a few lower values near boundary
  groupA.push(28 + Math.random() * 5);
  groupA.push(30 + Math.random() * 4);
  groupA.push(32 + Math.random() * 3);

  // Group B: lower values (e.g. 5-30)
  for (let i = 0; i < 12; i++) {
    groupB.push(5 + Math.random() * 22);
  }

  prevMeanA = mean(groupA);
  prevMeanB = mean(groupB);
  updateStats();
}

function addDots() {
  for (let i = 0; i < 5; i++) {
    groupA.push(35 + Math.random() * 45);
  }
  for (let i = 0; i < 4; i++) {
    groupB.push(5 + Math.random() * 25);
  }
  // Add boundary elements
  groupA.push(28 + Math.random() * 6);
  prevMeanA = mean(groupA);
  prevMeanB = mean(groupB);
  updateStats();
  draw();
}

function showCancer() {
  groupA = [];
  groupB = [];
  changeHistory = [];
  cancerMode = true;

  // Stage II (Group A): higher severity 50-90
  for (let i = 0; i < 14; i++) groupA.push(50 + Math.random() * 40);
  // Some mild Stage II near boundary
  groupA.push(42 + Math.random() * 4);
  groupA.push(44 + Math.random() * 3);
  groupA.push(40 + Math.random() * 5);

  // Stage I (Group B): lower severity 10-45
  for (let i = 0; i < 12; i++) groupB.push(10 + Math.random() * 30);

  prevMeanA = mean(groupA);
  prevMeanB = mean(groupB);
  updateStats();
  draw();
}

function getGroupLabel(group) {
  if (cancerMode) return group === 'A' ? 'Stage II' : 'Stage I';
  return 'Group ' + group;
}

function updateStats() {
  const mA = mean(groupA);
  const mB = mean(groupB);
  document.getElementById('meanA').textContent = mA.toFixed(1);
  document.getElementById('countA').textContent = groupA.length;
  document.getElementById('meanB').textContent = mB.toFixed(1);
  document.getElementById('countB').textContent = groupB.length;
}

function valueToX(val, group) {
  const centerA = W * 0.28;
  const centerB = W * 0.65;
  const spread = W * 0.15;
  const center = group === 'A' ? centerA : centerB;
  // Jitter x based on hash of value
  const hash = (val * 1000) % 100;
  return center + (hash / 100 - 0.5) * spread;
}

function valueToY(val) {
  const top = H * 0.15;
  const bottom = H * 0.85;
  return bottom - ((val) / 100) * (bottom - top);
}

function dotAtPos(mx, my) {
  const r = 8;
  for (let i = 0; i < groupA.length; i++) {
    const x = valueToX(groupA[i], 'A');
    const y = valueToY(groupA[i]);
    if (Math.hypot(mx - x, my - y) < r + 4) return { group: 'A', index: i, value: groupA[i] };
  }
  for (let i = 0; i < groupB.length; i++) {
    const x = valueToX(groupB[i], 'B');
    const y = valueToY(groupB[i]);
    if (Math.hypot(mx - x, my - y) < r + 4) return { group: 'B', index: i, value: groupB[i] };
  }
  return null;
}

function moveDot(dot) {
  if (movingDot) return;

  const oldMeanA = mean(groupA);
  const oldMeanB = mean(groupB);

  let fromX, fromY, toX, toY;

  if (dot.group === 'A') {
    fromX = valueToX(dot.value, 'A');
    fromY = valueToY(dot.value);
    toX = valueToX(dot.value, 'B');
    toY = valueToY(dot.value);
    groupA.splice(dot.index, 1);
    groupB.push(dot.value);
  } else {
    fromX = valueToX(dot.value, 'B');
    fromY = valueToY(dot.value);
    toX = valueToX(dot.value, 'A');
    toY = valueToY(dot.value);
    groupB.splice(dot.index, 1);
    groupA.push(dot.value);
  }

  movingDot = {
    value: dot.value,
    fromGroup: dot.group,
    progress: 0,
    startX: fromX, startY: fromY,
    endX: toX, endY: toY
  };

  const newMeanA = mean(groupA);
  const newMeanB = mean(groupB);

  const labelA = getGroupLabel('A');
  const labelB = getGroupLabel('B');
  const dA = newMeanA - oldMeanA;
  const dB = newMeanB - oldMeanB;
  const entry = `Moved ${dot.value.toFixed(1)} from ${dot.group === 'A' ? labelA : labelB} to ${dot.group === 'A' ? labelB : labelA}: ` +
    `${labelA} ${dA >= 0 ? '+' : ''}${dA.toFixed(1)}, ${labelB} ${dB >= 0 ? '+' : ''}${dB.toFixed(1)}`;
  const isBothUp = dA > 0 && dB > 0;
  changeHistory.unshift({ text: entry, bothUp: isBothUp });
  if (changeHistory.length > 10) changeHistory.pop();

  const log = document.getElementById('changeLog');
  log.innerHTML = changeHistory.map(c =>
    `<div style="color:${c.bothUp ? '#4f8' : '#fa8'}; margin-bottom:3px;">${c.text}</div>`
  ).join('');

  prevMeanA = oldMeanA;
  prevMeanB = oldMeanB;
  updateStats();
  animateMove();
}

function animateMove() {
  if (!movingDot) return;
  movingDot.progress += 0.025;
  if (movingDot.progress >= 1) {
    movingDot = null;
    draw();
    return;
  }
  draw();
  requestAnimationFrame(animateMove);
}

function autoDemo() {
  // Find a dot in group A that is below A's mean but above B's mean
  const mA = mean(groupA);
  const mB = mean(groupB);
  let bestIdx = -1;
  let bestDist = Infinity;

  for (let i = 0; i < groupA.length; i++) {
    if (groupA[i] < mA && groupA[i] > mB) {
      const dist = Math.abs(groupA[i] - (mA + mB) / 2);
      if (dist < bestDist) { bestDist = dist; bestIdx = i; }
    }
  }

  if (bestIdx >= 0) {
    moveDot({ group: 'A', index: bestIdx, value: groupA[bestIdx] });
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  const centerA = W * 0.28;
  const centerB = W * 0.65;
  const mA = mean(groupA);
  const mB = mean(groupB);

  // Group labels
  ctx.textAlign = 'center';
  ctx.font = 'bold 18px Segoe UI, Arial, sans-serif';
  ctx.fillStyle = '#6af';
  ctx.fillText(cancerMode ? 'Stage II (Higher Severity)' : 'Group A', centerA, H * 0.07);
  ctx.fillStyle = '#f84';
  ctx.fillText(cancerMode ? 'Stage I (Lower Severity)' : 'Group B', centerB, H * 0.07);

  // Y axis
  ctx.font = '10px Segoe UI, Arial, sans-serif';
  ctx.fillStyle = '#6a8';
  ctx.textAlign = 'right';
  for (let v = 0; v <= 100; v += 20) {
    const y = valueToY(v);
    ctx.fillText(v, W * 0.08, y + 4);
    ctx.strokeStyle = 'rgba(120,160,255,0.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(W * 0.09, y);
    ctx.lineTo(W * 0.85, y);
    ctx.stroke();
  }
  ctx.textAlign = 'left';
  ctx.save();
  ctx.translate(W * 0.03, H * 0.5);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.font = '12px Segoe UI, Arial, sans-serif';
  ctx.fillText(cancerMode ? 'Severity Score' : 'Value', 0, 0);
  ctx.restore();

  // Separator
  ctx.strokeStyle = 'rgba(120,160,255,0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(W * 0.47, H * 0.05);
  ctx.lineTo(W * 0.47, H * 0.95);
  ctx.stroke();
  ctx.setLineDash([]);

  // Mean lines
  if (groupA.length > 0) {
    const yA = valueToY(mA);
    ctx.strokeStyle = 'rgba(100,170,255,0.6)';
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(centerA - W * 0.12, yA);
    ctx.lineTo(centerA + W * 0.12, yA);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#6af';
    ctx.font = 'bold 12px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Mean: ' + mA.toFixed(1), centerA + W * 0.1, yA - 6);
  }

  if (groupB.length > 0) {
    const yB = valueToY(mB);
    ctx.strokeStyle = 'rgba(255,136,68,0.6)';
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(centerB - W * 0.12, yB);
    ctx.lineTo(centerB + W * 0.12, yB);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#f84';
    ctx.font = 'bold 12px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Mean: ' + mB.toFixed(1), centerB + W * 0.1, yB - 6);
  }

  // Highlight zone: below A mean, above B mean
  if (groupA.length > 0 && groupB.length > 0) {
    const yTop = valueToY(mA);
    const yBot = valueToY(mB);
    if (yTop > yBot) {
      ctx.fillStyle = 'rgba(100,255,150,0.04)';
      ctx.fillRect(centerA - W * 0.12, yBot, W * 0.24, yTop - yBot);
      ctx.fillStyle = 'rgba(100,255,150,0.15)';
      ctx.font = '10px Segoe UI, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Sweet spot: move these to raise both means', centerA, (yTop + yBot) / 2);
    }
  }

  // Draw dots - Group A
  for (let i = 0; i < groupA.length; i++) {
    const x = valueToX(groupA[i], 'A');
    const y = valueToY(groupA[i]);
    const isCandidate = groupA[i] < mA && groupA[i] > mB;
    ctx.beginPath();
    ctx.arc(x, y, isCandidate ? 9 : 7, 0, Math.PI * 2);
    if (isCandidate) {
      ctx.fillStyle = 'rgba(100,255,150,0.6)';
      ctx.strokeStyle = 'rgba(100,255,150,0.9)';
    } else {
      ctx.fillStyle = 'rgba(100,170,255,0.5)';
      ctx.strokeStyle = 'rgba(100,170,255,0.8)';
    }
    ctx.fill();
    ctx.lineWidth = isCandidate ? 2 : 1;
    ctx.stroke();

    if (hovered && hovered.group === 'A' && hovered.index === i) {
      ctx.beginPath();
      ctx.arc(x, y, 12, 0, Math.PI * 2);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = '11px Courier New, monospace';
      ctx.textAlign = 'center';
      ctx.fillText(groupA[i].toFixed(1), x, y - 16);
    }
  }

  // Draw dots - Group B
  for (let i = 0; i < groupB.length; i++) {
    const x = valueToX(groupB[i], 'B');
    const y = valueToY(groupB[i]);
    ctx.beginPath();
    ctx.arc(x, y, 7, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,136,68,0.5)';
    ctx.strokeStyle = 'rgba(255,136,68,0.8)';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.stroke();

    if (hovered && hovered.group === 'B' && hovered.index === i) {
      ctx.beginPath();
      ctx.arc(x, y, 12, 0, Math.PI * 2);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = '11px Courier New, monospace';
      ctx.textAlign = 'center';
      ctx.fillText(groupB[i].toFixed(1), x, y - 16);
    }
  }

  // Moving dot
  if (movingDot) {
    const t = movingDot.progress;
    const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const x = movingDot.startX + (movingDot.endX - movingDot.startX) * ease;
    const arcY = -100 * Math.sin(t * Math.PI);
    const y = movingDot.startY + (movingDot.endY - movingDot.startY) * ease + arcY;

    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 15;
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px Courier New, monospace';
    ctx.textAlign = 'center';
    ctx.fillText(movingDot.value.toFixed(1), x, y - 16);
  }

  // Explanation text
  ctx.fillStyle = '#6a8';
  ctx.font = '13px Segoe UI, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Click green dots (below A mean, above B mean) to move them and watch both means rise!', W * 0.47, H * 0.97);
}

canvas.addEventListener('mousemove', function(e) {
  hovered = dotAtPos(e.clientX, e.clientY);
  canvas.style.cursor = hovered ? 'pointer' : 'default';
  if (!movingDot) draw();
});

canvas.addEventListener('click', function(e) {
  const dot = dotAtPos(e.clientX, e.clientY);
  if (dot && !movingDot) moveDot(dot);
});

function resetDemo() {
  movingDot = null;
  document.getElementById('changeLog').innerHTML = '';
  initData();
  draw();
}

window.addEventListener('resize', resize);

window.reset = function() {
  resetDemo();
};

resize();
initData();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
