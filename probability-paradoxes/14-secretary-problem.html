<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secretary Problem - Optimal Stopping</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 18px; left: 18px; z-index: 100;
            color: #8A9A5B; text-decoration: none; font-size: 14px; font-weight: 600;
            background: rgba(10,14,26,0.8); padding: 8px 18px; border-radius: 25px;
            border: 2px solid #8A9A5B; transition: all 0.3s ease;
        }
        .back-link:hover { background: #8A9A5B; color: #0a0e1a; }
        .controls {
            position: fixed; top: 18px; right: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 18px; color: #c8d0e0;
            min-width: 280px; max-width: 340px; border: 1px solid rgba(138,154,91,0.3);
        }
        .controls h2 { color: #DDA15E; font-size: 16px; margin-bottom: 4px; }
        .controls p.desc { font-size: 11px; color: #8899aa; margin-bottom: 12px; line-height: 1.4; }
        .control-row { margin-bottom: 10px; }
        .control-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px; color: #a0b0c0; }
        .control-row label span { color: #DDA15E; font-family: monospace; }
        input[type="range"] {
            width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
            background: #1a2035; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
            background: #8A9A5B; cursor: pointer;
        }
        .btn {
            background: rgba(138,154,91,0.2); color: #8A9A5B; border: 1px solid rgba(138,154,91,0.4);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(138,154,91,0.4); }
        .btn.accept { background: rgba(100,200,100,0.2); color: #6c6; border-color: rgba(100,200,100,0.4); }
        .btn.accept:hover { background: rgba(100,200,100,0.4); }
        .btn.reject { background: rgba(200,100,100,0.2); color: #c66; border-color: rgba(200,100,100,0.4); }
        .btn.reject:hover { background: rgba(200,100,100,0.4); }
        .btn-row { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .stats-box {
            margin-top: 12px; padding: 10px; background: rgba(10,14,26,0.6);
            border-radius: 6px; font-size: 11px; line-height: 1.7;
        }
        .stats-box .label { color: #8899aa; }
        .stats-box .value { color: #DDA15E; font-family: monospace; font-weight: 600; }
        .stats-box .highlight { color: #e06060; font-weight: 700; }
        .game-status {
            margin-top: 8px; padding: 8px; background: rgba(138,154,91,0.1);
            border: 1px solid rgba(138,154,91,0.3); border-radius: 6px;
            font-size: 12px; text-align: center;
        }
        .info-panel {
            position: fixed; bottom: 18px; left: 18px; z-index: 100;
            background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
            border-radius: 10px; padding: 16px; color: #c8d0e0;
            max-width: 380px; border: 1px solid rgba(138,154,91,0.3);
        }
        .info-panel h3 { color: #DDA15E; font-size: 14px; margin-bottom: 6px; }
        .info-panel p { font-size: 11px; color: #8899aa; line-height: 1.5; }
        .info-panel .key { color: #8A9A5B; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Probability Paradoxes</a>
    <div class="controls">
        <h2>Secretary Problem</h2>
        <p class="desc">N candidates arrive one by one. You can accept or reject each -- but you can't go back! What's the optimal strategy?</p>
        <div class="control-row">
            <label>Candidates (N) <span id="nVal">20</span></label>
            <input type="range" id="nCandidates" min="5" max="50" step="1" value="20">
        </div>
        <div class="game-status" id="gameStatus">Click "New Game" to play!</div>
        <div class="btn-row">
            <button class="btn accept" id="acceptBtn" onclick="acceptCandidate()">Accept</button>
            <button class="btn reject" id="rejectBtn" onclick="rejectCandidate()">Reject</button>
        </div>
        <div class="btn-row">
            <button class="btn" onclick="newGame()">New Game</button>
            <button class="btn" onclick="window.reset()">Reset All</button>
            <button class="btn" onclick="runSimulation()">Run 10K Sims</button>
        </div>
        <div class="stats-box">
            <div style="font-weight:600; color:#aabbcc; margin-bottom:4px;">Win Rates (simulation):</div>
            <div><span class="label">Always first: </span><span class="value" id="winFirst">--</span></div>
            <div><span class="label">Random stop: </span><span class="value" id="winRandom">--</span></div>
            <div><span class="label">37% rule: </span><span class="highlight" id="winOptimal">--</span></div>
            <div><span class="label">Your manual: </span><span class="value" id="winManual">--</span></div>
            <div style="margin-top:6px;"><span class="label">Games played: </span><span class="value" id="gamesPlayed">0</span></div>
            <div><span class="label">Your wins: </span><span class="value" id="yourWins">0</span></div>
        </div>
    </div>
    <div class="info-panel">
        <h3>The 37% Rule</h3>
        <p>The <span class="key">optimal strategy</span>: reject the first <span class="key">N/e (~37%)</span> of candidates, then accept the first one better than all you've seen.</p>
        <p style="margin-top:6px;">This gives a <span class="key">~37% chance</span> of picking the absolute best -- far better than random guessing (~5% for 20 candidates). The same math applies to house-hunting, dating, and hiring!</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        let N = 20;
        let candidates = [];
        let currentIdx = -1;
        let gameActive = false;
        let gameResult = null; // { accepted, score, isBest }
        let bestSeenScore = -1;
        let rejectedScores = [];
        let acceptedScore = -1;

        // Stats
        let gamesPlayed = 0;
        let playerWins = 0;
        let simResults = { first: 0, random: 0, optimal: 0, manual: 0 };
        let simCount = 0;

        // Animation
        let cardRevealProgress = 0;
        let animPhase = 0;

        function generateCandidates(n) {
            const c = [];
            for (let i = 0; i < n; i++) {
                c.push({
                    score: Math.random() * 100,
                    name: 'Candidate ' + (i + 1),
                    color: `hsl(${(i / n) * 360}, 50%, 55%)`
                });
            }
            return c;
        }

        function newGame() {
            N = +document.getElementById('nCandidates').value;
            candidates = generateCandidates(N);
            currentIdx = 0;
            gameActive = true;
            gameResult = null;
            bestSeenScore = -1;
            rejectedScores = [];
            acceptedScore = -1;
            cardRevealProgress = 0;
            updateGameStatus('Candidate 1 of ' + N + ' -- Accept or Reject?');
        }
        window.newGame = newGame;

        function acceptCandidate() {
            if (!gameActive || currentIdx < 0 || currentIdx >= N) return;
            const score = candidates[currentIdx].score;
            acceptedScore = score;
            const isBest = score === Math.max(...candidates.map(c => c.score));
            gameResult = { idx: currentIdx, score, isBest };
            gameActive = false;
            gamesPlayed++;
            if (isBest) playerWins++;
            updateGameStatus(isBest ?
                'You picked the BEST candidate! Score: ' + score.toFixed(1) :
                'Not the best. Score: ' + score.toFixed(1) + ' (Best was ' + Math.max(...candidates.map(c => c.score)).toFixed(1) + ')');
            document.getElementById('gamesPlayed').textContent = gamesPlayed;
            document.getElementById('yourWins').textContent = playerWins;
            document.getElementById('winManual').textContent = (playerWins / gamesPlayed * 100).toFixed(1) + '%';
        }
        window.acceptCandidate = acceptCandidate;

        function rejectCandidate() {
            if (!gameActive || currentIdx < 0) return;
            const score = candidates[currentIdx].score;
            rejectedScores.push(score);
            bestSeenScore = Math.max(bestSeenScore, score);
            currentIdx++;
            cardRevealProgress = 0;
            if (currentIdx >= N) {
                // Must take last one -- but we rejected all, so we get the last rejected
                gameActive = false;
                gamesPlayed++;
                gameResult = { idx: N - 1, score: candidates[N - 1].score, isBest: false };
                updateGameStatus('Ran out of candidates! You rejected everyone.');
                document.getElementById('gamesPlayed').textContent = gamesPlayed;
                document.getElementById('yourWins').textContent = playerWins;
                document.getElementById('winManual').textContent = gamesPlayed > 0 ? (playerWins / gamesPlayed * 100).toFixed(1) + '%' : '--';
            } else {
                updateGameStatus('Candidate ' + (currentIdx + 1) + ' of ' + N + ' -- Accept or Reject?');
            }
        }
        window.rejectCandidate = rejectCandidate;

        function updateGameStatus(msg) {
            document.getElementById('gameStatus').textContent = msg;
        }

        function simulateStrategy(candidates, strategy) {
            const n = candidates.length;
            const best = Math.max(...candidates.map(c => c.score));
            let chosen = -1;

            if (strategy === 'first') {
                chosen = candidates[0].score;
            } else if (strategy === 'random') {
                const stop = Math.floor(Math.random() * n);
                chosen = candidates[stop].score;
            } else if (strategy === 'optimal') {
                const skip = Math.floor(n / Math.E);
                let bestSeen = -1;
                for (let i = 0; i < skip; i++) {
                    bestSeen = Math.max(bestSeen, candidates[i].score);
                }
                chosen = candidates[n - 1].score; // default: last
                for (let i = skip; i < n; i++) {
                    if (candidates[i].score > bestSeen) {
                        chosen = candidates[i].score;
                        break;
                    }
                }
            }
            return chosen === best;
        }

        function runSimulation() {
            const runs = 10000;
            let wFirst = 0, wRandom = 0, wOptimal = 0;
            for (let r = 0; r < runs; r++) {
                const c = generateCandidates(N);
                if (simulateStrategy(c, 'first')) wFirst++;
                if (simulateStrategy(c, 'random')) wRandom++;
                if (simulateStrategy(c, 'optimal')) wOptimal++;
            }
            simCount = runs;
            simResults.first = wFirst;
            simResults.random = wRandom;
            simResults.optimal = wOptimal;

            document.getElementById('winFirst').textContent = (wFirst / runs * 100).toFixed(1) + '%';
            document.getElementById('winRandom').textContent = (wRandom / runs * 100).toFixed(1) + '%';
            document.getElementById('winOptimal').textContent = (wOptimal / runs * 100).toFixed(1) + '%';
        }
        window.runSimulation = runSimulation;

        window.reset = function() {
            gamesPlayed = 0;
            playerWins = 0;
            simResults = { first: 0, random: 0, optimal: 0, manual: 0 };
            simCount = 0;
            gameActive = false;
            gameResult = null;
            candidates = [];
            currentIdx = -1;
            document.getElementById('gamesPlayed').textContent = '0';
            document.getElementById('yourWins').textContent = '0';
            document.getElementById('winFirst').textContent = '--';
            document.getElementById('winRandom').textContent = '--';
            document.getElementById('winOptimal').textContent = '--';
            document.getElementById('winManual').textContent = '--';
            updateGameStatus('Click "New Game" to play!');
        };

        document.getElementById('nCandidates').addEventListener('input', function() {
            N = +this.value;
            document.getElementById('nVal').textContent = N;
        });

        function drawCandidateCard(x, y, w, h, candidate, idx, state) {
            // state: 'current', 'rejected', 'accepted', 'hidden', 'best'
            let bgColor, borderColor, textColor;
            if (state === 'current') {
                bgColor = 'rgba(221,161,94,0.15)';
                borderColor = '#DDA15E';
                textColor = '#DDA15E';
            } else if (state === 'rejected') {
                bgColor = 'rgba(100,100,100,0.1)';
                borderColor = '#334';
                textColor = '#556';
            } else if (state === 'accepted') {
                bgColor = 'rgba(100,200,100,0.15)';
                borderColor = '#6c6';
                textColor = '#6c6';
            } else if (state === 'best') {
                bgColor = 'rgba(224,96,96,0.15)';
                borderColor = '#e06060';
                textColor = '#e06060';
            } else {
                bgColor = 'rgba(30,35,50,0.5)';
                borderColor = '#2a3050';
                textColor = '#445';
            }

            ctx.fillStyle = bgColor;
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = state === 'current' ? 2 : 1;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 6);
            ctx.fill();
            ctx.stroke();

            // Number
            ctx.fillStyle = textColor;
            ctx.font = 'bold 11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('#' + (idx + 1), x + w / 2, y + 14);

            // Score (hidden for future candidates)
            if (state !== 'hidden') {
                // Score bar
                const barW = w - 10;
                const barH = 6;
                const barY = y + h - 14;
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(x + 5, barY, barW, barH);
                const filled = (candidate.score / 100) * barW;
                ctx.fillStyle = state === 'current' ? '#DDA15E' :
                               state === 'accepted' ? '#6c6' :
                               state === 'best' ? '#e06060' : '#556';
                ctx.fillRect(x + 5, barY, filled, barH);

                ctx.fillStyle = textColor;
                ctx.font = '10px monospace';
                ctx.fillText(candidate.score.toFixed(0), x + w / 2, y + 28);
            } else {
                ctx.fillStyle = '#334';
                ctx.font = '16px sans-serif';
                ctx.fillText('?', x + w / 2, y + 28);
            }
        }

        function drawCandidateGrid() {
            if (candidates.length === 0) return;

            const gridLeft = 0.05 * W;
            const gridTop = 0.12 * H;
            const gridRight = 0.58 * W;
            const gridBottom = 0.55 * H;
            const cols = Math.min(10, Math.ceil(Math.sqrt(N)));
            const rows = Math.ceil(N / cols);
            const cardW = Math.min(55, (gridRight - gridLeft) / cols - 4);
            const cardH = Math.min(45, (gridBottom - gridTop) / rows - 4);

            const bestScore = Math.max(...candidates.map(c => c.score));
            const skipThreshold = Math.floor(N / Math.E);

            // "Explore zone" indicator
            if (gameActive || gameResult) {
                const exploreEndCol = Math.min(cols, skipThreshold);
                const exploreEndRow = Math.floor(skipThreshold / cols);
                ctx.fillStyle = 'rgba(100,100,200,0.05)';
                ctx.strokeStyle = 'rgba(100,100,200,0.2)';
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 1;
                const ew = Math.min(skipThreshold, cols) * (cardW + 4);
                const eh = (Math.floor((skipThreshold - 1) / cols) + 1) * (cardH + 4);
                ctx.fillRect(gridLeft - 2, gridTop - 2, ew + 4, eh + 4);
                ctx.strokeRect(gridLeft - 2, gridTop - 2, ew + 4, eh + 4);
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(100,100,200,0.6)';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Explore zone (37%)', gridLeft, gridTop - 8);
            }

            for (let i = 0; i < N; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = gridLeft + col * (cardW + 4);
                const y = gridTop + row * (cardH + 4);

                let state = 'hidden';
                if (gameResult) {
                    if (i < currentIdx || i < rejectedScores.length) state = 'rejected';
                    else if (i === gameResult.idx) state = gameResult.isBest ? 'accepted' : 'accepted';
                    else if (candidates[i].score === bestScore && !gameResult.isBest) state = 'best';
                    else if (i <= gameResult.idx) state = 'rejected';
                } else if (gameActive) {
                    if (i < currentIdx) state = 'rejected';
                    else if (i === currentIdx) state = 'current';
                }

                drawCandidateCard(x, y, cardW, cardH, candidates[i], i, state);
            }
        }

        function drawWinRateChart() {
            const cx = 0.06 * W;
            const cy = 0.6 * H;
            const cw = 0.52 * W;
            const ch = 0.32 * H;

            ctx.fillStyle = 'rgba(15,18,30,0.7)';
            ctx.beginPath();
            ctx.roundRect(cx - 10, cy - 25, cw + 20, ch + 40, 8);
            ctx.fill();

            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Strategy Win Rates (10,000 simulations)', cx, cy - 8);

            if (simCount === 0) {
                ctx.fillStyle = '#556677';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click "Run 10K Sims" to compare strategies', cx + cw / 2, cy + ch / 2);
                return;
            }

            const data = [
                { label: 'Always Take First', rate: simResults.first / simCount, color: '#667788' },
                { label: 'Random Stop', rate: simResults.random / simCount, color: '#60a0e0' },
                { label: '37% Rule (Optimal)', rate: simResults.optimal / simCount, color: '#DDA15E' },
            ];
            if (gamesPlayed > 0) {
                data.push({ label: 'Your Strategy', rate: playerWins / gamesPlayed, color: '#8A9A5B' });
            }

            const barH = 30;
            const gap = 15;
            const maxRate = Math.max(...data.map(d => d.rate), 0.01);

            data.forEach((d, i) => {
                const by = cy + 20 + i * (barH + gap);
                ctx.fillStyle = '#8899aa';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(d.label, cx, by - 3);

                const bw = (d.rate / maxRate) * (cw - 40);
                ctx.fillStyle = d.color;
                ctx.beginPath();
                ctx.roundRect(cx, by, Math.max(4, bw), barH, 4);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 13px monospace';
                ctx.textAlign = 'left';
                ctx.fillText((d.rate * 100).toFixed(1) + '%', cx + Math.max(4, bw) + 8, by + barH / 2 + 5);
            });

            // 1/N reference line
            const theoreticalRandom = 1 / N;
            const refX = cx + (theoreticalRandom / maxRate) * (cw - 40);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(refX, cy + 15);
            ctx.lineTo(refX, cy + 20 + data.length * (barH + gap));
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#556677';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('1/N = ' + (theoreticalRandom * 100).toFixed(1) + '%', refX, cy + 20 + data.length * (barH + gap) + 14);
        }

        let lastTime = 0;
        function animate(ts) {
            const dt = lastTime ? (ts - lastTime) / 1000 : 0;
            lastTime = ts;
            animPhase += dt;

            if (gameActive) {
                cardRevealProgress = Math.min(1, cardRevealProgress + dt * 3);
            }

            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, W, H);

            // Title
            ctx.fillStyle = '#DDA15E';
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('The Secretary Problem', W * 0.35, 40);
            ctx.fillStyle = '#667788';
            ctx.font = '13px sans-serif';
            ctx.fillText('Optimal stopping: when to commit', W * 0.35, 60);

            drawCandidateGrid();
            drawWinRateChart();

            requestAnimationFrame(animate);
        }

        window.reset();
        requestAnimationFrame(animate);
    })();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
