<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Contact Tracing Network</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; cursor: pointer; }
#title-overlay { position: fixed; top: 18px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 22px; font-weight: 700; text-shadow: 0 2px 10px rgba(0,0,0,0.7); z-index: 10; pointer-events: none; }
#legend { position: fixed; top: 60px; right: 20px; background: rgba(0,0,0,0.85); padding: 14px 18px; border-radius: 10px; color: #e0e0e0; font-size: 13px; z-index: 10; border: 1px solid rgba(251,191,36,0.2); }
.legend-item { display: flex; align-items: center; gap: 8px; margin: 5px 0; }
.legend-dot { width: 12px; height: 12px; border-radius: 50%; }
#controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); padding: 16px 24px; border-radius: 14px; color: #e0e0e0; z-index: 10; display: flex; gap: 20px; align-items: center; border: 1px solid rgba(251,191,36,0.3); font-size: 13px; }
#controls button { padding: 8px 18px; background: #fbbf24; color: #0a0e1a; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 13px; }
#controls button:hover { background: #f59e0b; }
#controls label { display: flex; align-items: center; gap: 8px; }
#controls input[type=checkbox] { accent-color: #fbbf24; width: 16px; height: 16px; }
#info { position: fixed; top: 60px; left: 20px; background: rgba(0,0,0,0.85); padding: 14px 18px; border-radius: 10px; color: #e0e0e0; font-size: 13px; z-index: 10; border: 1px solid rgba(251,191,36,0.2); max-width: 200px; }
#stats-box { position: fixed; bottom: 100px; right: 20px; background: rgba(0,0,0,0.85); padding: 14px 18px; border-radius: 10px; color: #e0e0e0; font-size: 13px; z-index: 10; border: 1px solid rgba(251,191,36,0.2); }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title-overlay">Contact Tracing Network</div>
<div id="legend">
    <div class="legend-item"><div class="legend-dot" style="background:#4a9eff;"></div> Healthy</div>
    <div class="legend-item"><div class="legend-dot" style="background:#ff4a4a;"></div> Infected</div>
    <div class="legend-item"><div class="legend-dot" style="background:#4aff88;"></div> Recovered</div>
    <div class="legend-item"><div class="legend-dot" style="background:#ff8c00;"></div> Quarantined</div>
    <div class="legend-item"><div class="legend-dot" style="background:#888;"></div> Traced</div>
</div>
<div id="info">Click a node to infect it. Watch contact tracing illuminate connections and quarantine contacts.</div>
<div id="stats-box">
    <div>Healthy: <span id="sH" style="color:#4a9eff;">0</span></div>
    <div>Infected: <span id="sI" style="color:#ff4a4a;">0</span></div>
    <div>Recovered: <span id="sR" style="color:#4aff88;">0</span></div>
    <div>Quarantined: <span id="sQ" style="color:#ff8c00;">0</span></div>
    <div style="margin-top:6px;">Prevented: <span id="sP" style="color:#fbbf24;">0</span></div>
</div>
<div id="controls">
    <label><input type="checkbox" id="tracingOn" checked> Contact Tracing</label>
    <label>Trace Speed <input type="range" id="traceSpeed" min="1" max="10" value="5" style="width:100px;accent-color:#fbbf24;"></label>
    <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

const NUM_NODES = 80;
const HEALTHY = 0, INFECTED = 1, RECOVERED = 2, QUARANTINED = 3, TRACED = 4;
const NODE_COLORS = ['#4a9eff', '#ff4a4a', '#4aff88', '#ff8c00', '#aaaaaa'];
const RECOVERY_TIME = 400;
const SPREAD_PROB = 0.008;
const TRACE_DELAY = 60;

let nodes = [], edges = [], tracePulses = [], prevented = 0;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }

function init() {
    nodes = [];
    edges = [];
    tracePulses = [];
    prevented = 0;
    const cx = W / 2, cy = H / 2;

    // Create nodes in clustered layout
    for (let i = 0; i < NUM_NODES; i++) {
        const angle = (i / NUM_NODES) * Math.PI * 2 + Math.random() * 0.5;
        const r = 100 + Math.random() * Math.min(W, H) * 0.3;
        nodes.push({
            x: cx + Math.cos(angle) * r + (Math.random() - 0.5) * 80,
            y: cy + Math.sin(angle) * r + (Math.random() - 0.5) * 80,
            vx: 0, vy: 0,
            state: HEALTHY,
            infectedTime: 0,
            traceTimer: -1,
            radius: 8 + Math.random() * 5,
            connections: []
        });
    }

    // Create edges based on proximity
    for (let i = 0; i < nodes.length; i++) {
        let nearby = [];
        for (let j = 0; j < nodes.length; j++) {
            if (i === j) continue;
            nearby.push({ idx: j, d: dist(nodes[i], nodes[j]) });
        }
        nearby.sort((a, b) => a.d - b.d);
        const numConn = 2 + Math.floor(Math.random() * 3);
        for (let k = 0; k < Math.min(numConn, nearby.length); k++) {
            const j = nearby[k].idx;
            if (!edges.some(e => (e[0] === i && e[1] === j) || (e[0] === j && e[1] === i))) {
                edges.push([i, j]);
                nodes[i].connections.push(j);
                nodes[j].connections.push(i);
            }
        }
    }

    // Force-directed relaxation
    for (let iter = 0; iter < 100; iter++) {
        for (let i = 0; i < nodes.length; i++) {
            let fx = 0, fy = 0;
            for (let j = 0; j < nodes.length; j++) {
                if (i === j) continue;
                const dx = nodes[i].x - nodes[j].x;
                const dy = nodes[i].y - nodes[j].y;
                const d = Math.max(dist(nodes[i], nodes[j]), 1);
                const repulse = 5000 / (d * d);
                fx += (dx / d) * repulse;
                fy += (dy / d) * repulse;
            }
            for (let j of nodes[i].connections) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const d = dist(nodes[i], nodes[j]);
                const attract = (d - 120) * 0.01;
                fx += (dx / Math.max(d, 1)) * attract;
                fy += (dy / Math.max(d, 1)) * attract;
            }
            // Center gravity
            fx += (cx - nodes[i].x) * 0.001;
            fy += (cy - nodes[i].y) * 0.001;
            nodes[i].vx = (nodes[i].vx + fx) * 0.5;
            nodes[i].vy = (nodes[i].vy + fy) * 0.5;
            nodes[i].x += nodes[i].vx;
            nodes[i].y += nodes[i].vy;
            nodes[i].x = Math.max(60, Math.min(W - 60, nodes[i].x));
            nodes[i].y = Math.max(80, Math.min(H - 80, nodes[i].y));
        }
    }
}

function infectNode(idx) {
    if (nodes[idx].state === HEALTHY) {
        nodes[idx].state = INFECTED;
        nodes[idx].infectedTime = 0;
    }
}

function update() {
    const tracingOn = document.getElementById('tracingOn').checked;
    const traceSpeed = parseInt(document.getElementById('traceSpeed').value);

    for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        if (n.state === INFECTED) {
            n.infectedTime++;
            if (n.infectedTime > RECOVERY_TIME) {
                n.state = RECOVERED;
                // Start tracing contacts
                if (tracingOn) {
                    for (let j of n.connections) {
                        if (nodes[j].state === HEALTHY || nodes[j].state === INFECTED) {
                            nodes[j].traceTimer = TRACE_DELAY / traceSpeed;
                            tracePulses.push({ from: i, to: j, progress: 0, speed: 0.02 * traceSpeed });
                        }
                    }
                }
            }
            // Spread to connected healthy nodes
            for (let j of n.connections) {
                if (nodes[j].state === HEALTHY && Math.random() < SPREAD_PROB) {
                    nodes[j].state = INFECTED;
                    nodes[j].infectedTime = 0;
                }
            }
        }
        if (n.traceTimer > 0) {
            n.traceTimer--;
            if (n.traceTimer <= 0 && n.state !== RECOVERED) {
                if (n.state === INFECTED) prevented++;
                if (n.state === HEALTHY || n.state === INFECTED) {
                    n.state = QUARANTINED;
                }
            }
        }
    }

    // Update trace pulses
    for (let i = tracePulses.length - 1; i >= 0; i--) {
        tracePulses[i].progress += tracePulses[i].speed;
        if (tracePulses[i].progress >= 1) tracePulses.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Draw edges
    for (let [i, j] of edges) {
        ctx.beginPath();
        ctx.moveTo(nodes[i].x, nodes[i].y);
        ctx.lineTo(nodes[j].x, nodes[j].y);
        const aInf = nodes[i].state === INFECTED || nodes[j].state === INFECTED;
        ctx.strokeStyle = aInf ? 'rgba(255,74,74,0.25)' : 'rgba(255,255,255,0.06)';
        ctx.lineWidth = aInf ? 1.5 : 0.8;
        ctx.stroke();
    }

    // Draw trace pulses
    for (let p of tracePulses) {
        const a = nodes[p.from], b = nodes[p.to];
        const x = a.x + (b.x - a.x) * p.progress;
        const y = a.y + (b.y - a.y) * p.progress;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fbbf24';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#fbbf24';
        ctx.fill();
        ctx.shadowBlur = 0;

        // Trace line
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(x, y);
        ctx.strokeStyle = 'rgba(251,191,36,0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Draw nodes
    for (let n of nodes) {
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
        ctx.fillStyle = NODE_COLORS[n.state];
        if (n.state === INFECTED) {
            ctx.shadowBlur = 18;
            ctx.shadowColor = '#ff4a4a';
        } else if (n.state === QUARANTINED) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff8c00';
        } else {
            ctx.shadowBlur = 4;
            ctx.shadowColor = NODE_COLORS[n.state];
        }
        ctx.fill();
        ctx.shadowBlur = 0;

        if (n.traceTimer > 0) {
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.radius + 6, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(251,191,36,0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        if (n.state === QUARANTINED) {
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.radius + 5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,140,0,0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    // Stats
    let counts = [0, 0, 0, 0, 0];
    for (let n of nodes) counts[n.state]++;
    document.getElementById('sH').textContent = counts[0];
    document.getElementById('sI').textContent = counts[1];
    document.getElementById('sR').textContent = counts[2];
    document.getElementById('sQ').textContent = counts[3];
    document.getElementById('sP').textContent = prevented;
}

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    let closest = -1, closestD = Infinity;
    for (let i = 0; i < nodes.length; i++) {
        const d = dist({ x: mx, y: my }, nodes[i]);
        if (d < closestD && d < 30) { closestD = d; closest = i; }
    }
    if (closest >= 0) infectNode(closest);
});

document.getElementById('resetBtn').onclick = init;
window.addEventListener('resize', () => { resize(); init(); });

function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
}

resize();
init();
animate();
</script>
</body>
</html>
