<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flat Torus Geometry</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; }
    #controls {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: rgba(10, 14, 30, 0.85);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 160, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        color: #c8d8f0;
        min-width: 260px;
        max-height: calc(100vh - 60px);
        overflow-y: auto;
    }
    #controls h3 { color: #8af; margin-bottom: 12px; font-size: 1.1em; }
    .control-group { margin: 8px 0; }
    .control-group label { display: block; font-size: 0.82em; color: #8a9ab0; margin-bottom: 3px; }
    .control-group input[type="range"] { width: 100%; accent-color: #8af; }
    .control-group .value { float: right; color: #adf; font-family: monospace; font-size: 0.82em; }
    .btn {
        background: rgba(100, 160, 255, 0.15);
        border: 1px solid rgba(100, 160, 255, 0.3);
        color: #8af; padding: 6px 14px; border-radius: 6px;
        cursor: pointer; font-size: 0.82em; transition: all 0.2s;
    }
    .btn:hover { background: rgba(100, 160, 255, 0.3); }
    .btn.active { background: rgba(100, 160, 255, 0.4); border-color: #8af; }
    .btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px; }
    .info-text { font-size: 0.78em; color: #6a7a90; margin-top: 12px; line-height: 1.5; border-top: 1px solid rgba(100,160,255,0.15); padding-top: 10px; }
    .info-highlight { color: #ffcc44; font-weight: bold; }
    .slope-info { margin-top: 8px; padding: 8px; border-radius: 6px; background: rgba(100,200,255,0.08); font-size: 0.82em; }
    .slope-info .label { color: #8a9ab0; }
    .slope-info .val { color: #adf; font-family: monospace; }
    .section-label { color: #6a8ac0; font-size: 0.75em; text-transform: uppercase; letter-spacing: 1px; margin-top: 12px; margin-bottom: 4px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>

<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Flat Torus Geometry</h3>
    <div class="control-group">
        <label>Slope Angle <span id="slopeVal" class="value">37&deg;</span></label>
        <input type="range" id="slope" min="1" max="89" step="0.5" value="37">
    </div>
    <div class="control-group">
        <label>Speed <span id="speedVal" class="value">1.0</span></label>
        <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
    </div>
    <div class="control-group">
        <label>Trail Length <span id="trailVal" class="value">800</span></label>
        <input type="range" id="trail" min="100" max="3000" step="100" value="800">
    </div>
    <div class="section-label">View Mode</div>
    <div class="btn-row">
        <button class="btn active" id="viewSingle">Domain</button>
        <button class="btn" id="viewTiled">Tiled</button>
        <button class="btn" id="viewTorus">3D Torus</button>
    </div>
    <div class="slope-info">
        <div><span class="label">Slope: </span><span class="val" id="slopeRatio">tan(37&deg;) &asymp; 0.754</span></div>
        <div><span class="label">Type: </span><span class="val" id="slopeType">Irrational &mdash; ergodic</span></div>
    </div>
    <div class="btn-row">
        <button class="btn" id="presetRational">Rational (45&deg;)</button>
        <button class="btn" id="presetIrrational">Irrational (arctan &phi;)</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="info-text">
        A <strong style="color:#adf">flat torus</strong> is Pac-Man's world: a rectangle where opposite edges are identified.
        <span class="info-highlight">Rational slopes</span> create closed periodic paths.
        <span class="info-highlight">Irrational slopes</span> fill the entire space &mdash; the path never exactly repeats!
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

// State
let viewMode = 'single'; // single, tiled, torus
let slopeAngle = 37;
let particleSpeed = 1;
let maxTrail = 800;

// Particle position on the unit square [0,1] x [0,1]
let px = 0.5, py = 0.5;
let trail = [];

// View mode buttons
const views = { single: document.getElementById('viewSingle'), tiled: document.getElementById('viewTiled'), torus: document.getElementById('viewTorus') };
function setView(mode) {
    viewMode = mode;
    Object.values(views).forEach(b => b.classList.remove('active'));
    views[mode].classList.add('active');
}
views.single.onclick = () => setView('single');
views.tiled.onclick = () => setView('tiled');
views.torus.onclick = () => setView('torus');

// Sliders
const slopeSlider = document.getElementById('slope');
const speedSlider = document.getElementById('speed');
const trailSlider = document.getElementById('trail');

slopeSlider.oninput = () => {
    slopeAngle = parseFloat(slopeSlider.value);
    document.getElementById('slopeVal').textContent = slopeAngle + '\u00B0';
    updateSlopeInfo();
};
speedSlider.oninput = () => {
    particleSpeed = parseFloat(speedSlider.value);
    document.getElementById('speedVal').textContent = particleSpeed.toFixed(1);
};
trailSlider.oninput = () => {
    maxTrail = parseInt(trailSlider.value);
    document.getElementById('trailVal').textContent = maxTrail;
};

function updateSlopeInfo() {
    const tanVal = Math.tan(slopeAngle * Math.PI / 180);
    document.getElementById('slopeRatio').textContent = `tan(${slopeAngle}\u00B0) \u2248 ${tanVal.toFixed(4)}`;
    // Check if close to a rational number
    const isRational = isCloseToRational(tanVal, 50);
    document.getElementById('slopeType').textContent = isRational
        ? 'Rational \u2014 periodic (closed geodesic)'
        : 'Irrational \u2014 ergodic (never repeats!)';
}

function isCloseToRational(x, maxDenom) {
    for (let d = 1; d <= maxDenom; d++) {
        const n = Math.round(x * d);
        if (Math.abs(x - n / d) < 0.005) return true;
    }
    return false;
}

// Presets
document.getElementById('presetRational').onclick = () => {
    slopeSlider.value = 45; slopeAngle = 45;
    document.getElementById('slopeVal').textContent = '45\u00B0';
    updateSlopeInfo(); resetTrail();
};
document.getElementById('presetIrrational').onclick = () => {
    // arctan(golden ratio) ~= 58.28 degrees
    const angle = Math.atan((1 + Math.sqrt(5)) / 2) * 180 / Math.PI;
    slopeSlider.value = angle; slopeAngle = angle;
    document.getElementById('slopeVal').textContent = angle.toFixed(1) + '\u00B0';
    updateSlopeInfo(); resetTrail();
};

function resetTrail() {
    px = 0.5; py = 0.5; trail = [];
}

document.getElementById('resetBtn').onclick = () => {
    slopeSlider.value = 37; slopeAngle = 37;
    speedSlider.value = 1; particleSpeed = 1;
    trailSlider.value = 800; maxTrail = 800;
    document.getElementById('slopeVal').textContent = '37\u00B0';
    document.getElementById('speedVal').textContent = '1.0';
    document.getElementById('trailVal').textContent = '800';
    updateSlopeInfo();
    resetTrail();
    setView('single');
    torusRotX = 0.5; torusRotY = 0;
};

// Torus view rotation
let torusRotX = 0.5, torusRotY = 0;
let dragging = false, lastMX = 0, lastMY = 0;
canvas.addEventListener('mousedown', e => { if (viewMode === 'torus') { dragging = true; lastMX = e.clientX; lastMY = e.clientY; }});
canvas.addEventListener('mousemove', e => { if (!dragging) return; torusRotY += (e.clientX - lastMX)*0.005; torusRotX += (e.clientY - lastMY)*0.005; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { if (viewMode === 'torus') { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }}, {passive:false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!dragging) return; torusRotY += (e.touches[0].clientX - lastMX)*0.005; torusRotX += (e.touches[0].clientY - lastMY)*0.005; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, {passive:false});
canvas.addEventListener('touchend', () => dragging = false);

let lastTime = performance.now();
let autoRotT = 0;

function animate(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    autoRotT += dt;

    // Move particle
    const rad = slopeAngle * Math.PI / 180;
    const dx = Math.cos(rad) * particleSpeed * dt * 0.3;
    const dy = Math.sin(rad) * particleSpeed * dt * 0.3;
    px += dx; py += dy;
    // Wrap
    px = ((px % 1) + 1) % 1;
    py = ((py % 1) + 1) % 1;
    trail.push({ x: px, y: py });
    if (trail.length > maxTrail) trail.shift();

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    if (viewMode === 'single') drawSingleDomain();
    else if (viewMode === 'tiled') drawTiled();
    else drawTorus3D();

    // Label
    ctx.font = '14px monospace';
    ctx.fillStyle = 'rgba(138, 170, 255, 0.4)';
    ctx.fillText('Flat Torus - Geodesics on identified rectangle', 20, H - 20);

    requestAnimationFrame(animate);
}

function drawSingleDomain() {
    const size = Math.min(W, H) * 0.65;
    const ox = (W - size) / 2;
    const oy = (H - size) / 2;

    // Border
    ctx.strokeStyle = 'rgba(100, 160, 255, 0.4)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ox, oy, size, size);

    // Edge identification arrows
    drawIdArrows(ox, oy, size);

    // Grid lines
    ctx.strokeStyle = 'rgba(100, 160, 255, 0.08)';
    ctx.lineWidth = 1;
    for (let i = 1; i < 10; i++) {
        const p = ox + size * i / 10;
        ctx.beginPath(); ctx.moveTo(p, oy); ctx.lineTo(p, oy + size); ctx.stroke();
        const q = oy + size * i / 10;
        ctx.beginPath(); ctx.moveTo(ox, q); ctx.lineTo(ox + size, q); ctx.stroke();
    }

    // Trail
    drawTrailOnDomain(ox, oy, size);

    // Particle
    const ppx = ox + px * size;
    const ppy = oy + py * size;
    ctx.beginPath();
    ctx.arc(ppx, ppy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    const grad = ctx.createRadialGradient(ppx, ppy, 0, ppx, ppy, 15);
    grad.addColorStop(0, 'rgba(255, 200, 80, 0.6)');
    grad.addColorStop(1, 'rgba(255, 200, 80, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ppx, ppy, 15, 0, Math.PI * 2);
    ctx.fill();
}

function drawIdArrows(ox, oy, size) {
    // Top/bottom edges (horizontal, same color = identified)
    ctx.strokeStyle = '#ff6688';
    ctx.lineWidth = 3;
    // Top
    const aw = size * 0.15;
    const midx = ox + size / 2;
    ctx.beginPath(); ctx.moveTo(midx - aw, oy); ctx.lineTo(midx + aw, oy); ctx.stroke();
    drawArrowHead(midx + aw, oy, 0, '#ff6688');
    // Bottom
    ctx.beginPath(); ctx.moveTo(midx - aw, oy + size); ctx.lineTo(midx + aw, oy + size); ctx.stroke();
    drawArrowHead(midx + aw, oy + size, 0, '#ff6688');

    // Left/right edges
    ctx.strokeStyle = '#66ff88';
    const midy = oy + size / 2;
    ctx.beginPath(); ctx.moveTo(ox, midy - aw); ctx.lineTo(ox, midy + aw); ctx.stroke();
    drawArrowHead(ox, midy + aw, Math.PI / 2, '#66ff88');
    ctx.beginPath(); ctx.moveTo(ox + size, midy - aw); ctx.lineTo(ox + size, midy + aw); ctx.stroke();
    drawArrowHead(ox + size, midy + aw, Math.PI / 2, '#66ff88');
}

function drawArrowHead(x, y, angle, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(8, 0);
    ctx.lineTo(-4, -5);
    ctx.lineTo(-4, 5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawTrailOnDomain(ox, oy, size) {
    if (trail.length < 2) return;
    for (let i = 1; i < trail.length; i++) {
        const t0 = trail[i - 1], t1 = trail[i];
        // Skip if wrapping (distance > 0.5 means wrap occurred)
        if (Math.abs(t1.x - t0.x) > 0.5 || Math.abs(t1.y - t0.y) > 0.5) continue;
        const alpha = (i / trail.length) * 0.8;
        const hue = (i / trail.length) * 300 + 180;
        ctx.beginPath();
        ctx.moveTo(ox + t0.x * size, oy + t0.y * size);
        ctx.lineTo(ox + t1.x * size, oy + t1.y * size);
        ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
    }
}

function drawTiled() {
    const tiles = 5;
    const tileSize = Math.min(W, H) * 0.16;
    const totalW = tiles * tileSize;
    const totalH = tiles * tileSize;
    const ox = (W - totalW) / 2;
    const oy = (H - totalH) / 2;

    for (let tx = 0; tx < tiles; tx++) {
        for (let ty = 0; ty < tiles; ty++) {
            const bx = ox + tx * tileSize;
            const by = oy + ty * tileSize;
            const isCentral = (tx === Math.floor(tiles / 2) && ty === Math.floor(tiles / 2));

            // Border
            ctx.strokeStyle = isCentral ? 'rgba(100, 160, 255, 0.5)' : 'rgba(100, 160, 255, 0.15)';
            ctx.lineWidth = isCentral ? 2 : 1;
            ctx.strokeRect(bx, by, tileSize, tileSize);

            // Draw trail in this copy
            drawTrailOnDomain(bx, by, tileSize);

            // Particle
            const ppx = bx + px * tileSize;
            const ppy = by + py * tileSize;
            ctx.beginPath();
            ctx.arc(ppx, ppy, isCentral ? 4 : 2, 0, Math.PI * 2);
            ctx.fillStyle = isCentral ? '#fff' : 'rgba(255,255,255,0.4)';
            ctx.fill();
        }
    }
}

function drawTorus3D() {
    const R = 2.5, r = 1.0; // Major and minor radii
    const segs = 40;
    const cx = W / 2, cy = H / 2;
    const scale = Math.min(W, H) * 0.2;

    if (!dragging) {
        torusRotY += 0.003;
    }

    // Generate torus mesh and draw
    const points = [];
    for (let i = 0; i <= segs; i++) {
        for (let j = 0; j <= segs; j++) {
            const u = (i / segs) * Math.PI * 2;
            const v = (j / segs) * Math.PI * 2;
            const x = (R + r * Math.cos(v)) * Math.cos(u);
            const y = (R + r * Math.cos(v)) * Math.sin(u);
            const z = r * Math.sin(v);
            // Rotate
            const [rx, ry, rz] = rotate3Dpt(x, y, z, torusRotX, torusRotY);
            points.push({ x: rx, y: ry, z: rz, u: i / segs, v: j / segs });
        }
    }

    // Draw wireframe
    ctx.strokeStyle = 'rgba(100, 160, 255, 0.12)';
    ctx.lineWidth = 0.5;
    for (let i = 0; i < segs; i++) {
        for (let j = 0; j < segs; j++) {
            const idx = i * (segs + 1) + j;
            const p1 = points[idx], p2 = points[idx + 1];
            const p3 = points[idx + segs + 1];
            const s1 = proj3D(p1, scale, cx, cy);
            const s2 = proj3D(p2, scale, cx, cy);
            const s3 = proj3D(p3, scale, cx, cy);
            ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s3.x, s3.y); ctx.stroke();
        }
    }

    // Draw trail on torus
    if (trail.length > 1) {
        for (let i = 1; i < trail.length; i++) {
            const t0 = trail[i - 1], t1 = trail[i];
            if (Math.abs(t1.x - t0.x) > 0.5 || Math.abs(t1.y - t0.y) > 0.5) continue;
            const u1 = t1.x * Math.PI * 2, v1 = t1.y * Math.PI * 2;
            const x1 = (R + r * Math.cos(v1)) * Math.cos(u1);
            const y1 = (R + r * Math.cos(v1)) * Math.sin(u1);
            const z1 = r * Math.sin(v1);
            const [rx1, ry1, rz1] = rotate3Dpt(x1, y1, z1, torusRotX, torusRotY);
            const s1 = proj3D({ x: rx1, y: ry1, z: rz1 }, scale, cx, cy);

            const u0 = t0.x * Math.PI * 2, v0 = t0.y * Math.PI * 2;
            const x0 = (R + r * Math.cos(v0)) * Math.cos(u0);
            const y0 = (R + r * Math.cos(v0)) * Math.sin(u0);
            const z0 = r * Math.sin(v0);
            const [rx0, ry0, rz0] = rotate3Dpt(x0, y0, z0, torusRotX, torusRotY);
            const s0 = proj3D({ x: rx0, y: ry0, z: rz0 }, scale, cx, cy);

            const alpha = (i / trail.length) * 0.9;
            const hue = (i / trail.length) * 300 + 180;
            ctx.beginPath();
            ctx.moveTo(s0.x, s0.y);
            ctx.lineTo(s1.x, s1.y);
            ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    // Particle on torus
    const pu = px * Math.PI * 2, pv = py * Math.PI * 2;
    const ptx = (R + r * Math.cos(pv)) * Math.cos(pu);
    const pty = (R + r * Math.cos(pv)) * Math.sin(pu);
    const ptz = r * Math.sin(pv);
    const [rpx, rpy, rpz] = rotate3Dpt(ptx, pty, ptz, torusRotX, torusRotY);
    const sp = proj3D({ x: rpx, y: rpy, z: rpz }, scale, cx, cy);
    ctx.beginPath();
    ctx.arc(sp.x, sp.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
}

function rotate3Dpt(x, y, z, ax, ay) {
    let y1 = y * Math.cos(ax) - z * Math.sin(ax);
    let z1 = y * Math.sin(ax) + z * Math.cos(ax);
    let x1 = x * Math.cos(ay) + z1 * Math.sin(ay);
    let z2 = -x * Math.sin(ay) + z1 * Math.cos(ay);
    return [x1, y1, z2];
}

function proj3D(p, scale, cx, cy) {
    const d = 6;
    const s = scale * d / (d + p.z);
    return { x: cx + p.x * s, y: cy + p.y * s };
}

updateSlopeInfo();
window.reset = () => { document.getElementById('resetBtn').onclick(); };
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>