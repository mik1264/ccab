<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hyperbolic Triangle Playground</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    #controls {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: rgba(10, 14, 30, 0.85);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 160, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        color: #c8d8f0;
        min-width: 280px;
    }
    #controls h3 { color: #8af; margin-bottom: 10px; font-size: 1.1em; }
    .angle-display {
        background: rgba(20, 30, 50, 0.6);
        border-radius: 8px; padding: 12px; margin: 10px 0;
    }
    .angle-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 0.9em; }
    .angle-label { color: #8a9ab0; }
    .angle-value { font-family: monospace; font-weight: bold; }
    .sum-row {
        border-top: 1px solid rgba(100, 160, 255, 0.2);
        margin-top: 8px; padding-top: 8px;
        font-size: 1em;
    }
    .defect-row { margin-top: 6px; font-size: 0.85em; }
    .comparison {
        background: rgba(100, 160, 255, 0.08);
        border-radius: 6px; padding: 10px; margin: 10px 0;
        font-size: 0.85em; line-height: 1.5;
    }
    .btn {
        background: rgba(100, 160, 255, 0.15); border: 1px solid rgba(100, 160, 255, 0.3);
        color: #8af; padding: 6px 12px; border-radius: 6px; cursor: pointer;
        font-size: 0.82em; transition: all 0.2s; margin: 3px;
    }
    .btn:hover { background: rgba(100, 160, 255, 0.3); }
    .btn.active { background: rgba(100, 160, 255, 0.35); border-color: #8af; }
    .btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 2px; }
    .preset-label { font-size: 0.78em; color: #6a7a9a; margin-top: 8px; }
    .info { font-size: 0.78em; color: #6a7a9a; margin-top: 8px; line-height: 1.4; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>

<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Hyperbolic Triangle Playground</h3>
    <div class="info">Click 3 points inside the disk to form a triangle, or drag vertices to explore.</div>

    <div class="angle-display" id="angleDisplay">
        <div class="angle-row">
            <span class="angle-label">Angle A:</span>
            <span class="angle-value" id="angleA" style="color:#ff6b9d">--</span>
        </div>
        <div class="angle-row">
            <span class="angle-label">Angle B:</span>
            <span class="angle-value" id="angleB" style="color:#60a5fa">--</span>
        </div>
        <div class="angle-row">
            <span class="angle-label">Angle C:</span>
            <span class="angle-value" id="angleC" style="color:#4ade80">--</span>
        </div>
        <div class="angle-row sum-row">
            <span class="angle-label" style="font-weight:bold;">Angle Sum:</span>
            <span class="angle-value" id="angleSum" style="color:#fbbf24;font-size:1.1em;">--</span>
        </div>
        <div class="defect-row">
            <span class="angle-label">Defect (= Area):</span>
            <span class="angle-value" id="defect" style="color:#c084fc;">--</span>
        </div>
    </div>

    <div class="comparison" id="comparison">
        <div>Euclidean (flat): <b>180.0&deg;</b></div>
        <div>Hyperbolic (here): <b id="hereAngle">--</b></div>
        <div style="margin-top:4px;color:#fbbf24;" id="lessText">Angle sum is always &lt; 180&deg; in hyperbolic space!</div>
    </div>

    <div class="preset-label">Presets:</div>
    <div class="btn-row">
        <button class="btn" id="presetTiny">Tiny (&#8776;180&deg;)</button>
        <button class="btn" id="presetMedium">Medium</button>
        <button class="btn" id="presetLarge">Large (&#8776;0&deg;)</button>
        <button class="btn" id="clearBtn">Clear</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H, cx, cy, diskR;
let vertices = [];
let dragging = -1;
let hoverVertex = -1;

const vertexColors = ['#ff6b9d', '#60a5fa', '#4ade80'];
const vertexLabels = ['A', 'B', 'C'];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
    cy = H / 2;
    diskR = Math.min(W, H) * 0.38;
}
resize();
window.addEventListener('resize', resize);

function toDisk(px, py) { return { x: (px - cx) / diskR, y: (py - cy) / diskR }; }
function toCanvas(dx, dy) { return { x: cx + dx * diskR, y: cy + dy * diskR }; }
function norm2(z) { return z.x * z.x + z.y * z.y; }
function dist2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }

function mobiusTransform(z, a) {
    const num = { x: z.x - a.x, y: z.y - a.y };
    const ca = { x: a.x, y: -a.y };
    const den = { x: 1 - (ca.x * z.x - ca.y * z.y), y: -(ca.x * z.y + ca.y * z.x) };
    const d2 = den.x * den.x + den.y * den.y;
    if (d2 < 1e-15) return { x: 0, y: 0 };
    return { x: (num.x * den.x + num.y * den.y) / d2, y: (num.y * den.x - num.x * den.y) / d2 };
}

function hyperbolicAngle(vertex, p1, p2) {
    // Angle at vertex between geodesics to p1 and p2
    // Move vertex to origin via MÃ¶bius, then angle is Euclidean angle at origin
    const w1 = mobiusTransform(p1, vertex);
    const w2 = mobiusTransform(p2, vertex);
    const a1 = Math.atan2(w1.y, w1.x);
    const a2 = Math.atan2(w2.y, w2.x);
    let diff = Math.abs(a2 - a1);
    if (diff > Math.PI) diff = 2 * Math.PI - diff;
    return diff;
}

function geodesicPoints(p1, p2, n) {
    n = n || 40;
    const cross = p1.x * p2.y - p1.y * p2.x;
    const pts = [];
    if (Math.abs(cross) < 1e-7 && Math.abs(p1.x * p2.x + p1.y * p2.y - norm2(p1)) < 1e-5) {
        // Points nearly collinear through origin
        for (let i = 0; i <= n; i++) {
            const t = i / n;
            pts.push({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });
        }
        return pts;
    }
    const n1 = norm2(p1);
    if (n1 < 1e-12) {
        for (let i = 0; i <= n; i++) {
            const t = i / n;
            pts.push({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });
        }
        return pts;
    }
    const p1inv = { x: p1.x / n1, y: -p1.y / n1 };
    const ax = p2.x - p1.x, ay = p2.y - p1.y;
    const bx = p1inv.x - p1.x, by = p1inv.y - p1.y;
    const mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2;
    const mx2 = (p1.x + p1inv.x) / 2, my2 = (p1.y + p1inv.y) / 2;
    const d1x = -ay, d1y = ax, d2x = -by, d2y = bx;
    const det = d1x * d2y - d1y * d2x;
    if (Math.abs(det) < 1e-12) {
        for (let i = 0; i <= n; i++) {
            const t = i / n;
            pts.push({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });
        }
        return pts;
    }
    const dx = mx2 - mx1, dy = my2 - my1;
    const t = (dx * d2y - dy * d2x) / det;
    const ccx = mx1 + t * d1x, ccy = my1 + t * d1y;
    const rad = Math.sqrt((p1.x - ccx) ** 2 + (p1.y - ccy) ** 2);
    let a1 = Math.atan2(p1.y - ccy, p1.x - ccx);
    let a2 = Math.atan2(p2.y - ccy, p2.x - ccx);
    let diff = a2 - a1;
    if (diff > Math.PI) diff -= 2 * Math.PI;
    if (diff < -Math.PI) diff += 2 * Math.PI;
    for (let i = 0; i <= n; i++) {
        const tt = i / n;
        const a = a1 + diff * tt;
        pts.push({ x: ccx + rad * Math.cos(a), y: ccy + rad * Math.sin(a) });
    }
    return pts;
}

function updateAngleDisplay() {
    if (vertices.length < 3) {
        ['angleA', 'angleB', 'angleC', 'angleSum', 'defect', 'hereAngle'].forEach(id => {
            document.getElementById(id).textContent = '--';
        });
        document.getElementById('lessText').textContent = 'Angle sum is always < 180\u00B0 in hyperbolic space!';
        return;
    }
    const [A, B, C] = vertices;
    const angA = hyperbolicAngle(A, B, C);
    const angB = hyperbolicAngle(B, A, C);
    const angC = hyperbolicAngle(C, A, B);
    const sum = angA + angB + angC;
    const sumDeg = sum * 180 / Math.PI;
    const defect = Math.PI - sum;
    const defectDeg = defect * 180 / Math.PI;

    document.getElementById('angleA').textContent = (angA * 180 / Math.PI).toFixed(2) + '\u00B0';
    document.getElementById('angleB').textContent = (angB * 180 / Math.PI).toFixed(2) + '\u00B0';
    document.getElementById('angleC').textContent = (angC * 180 / Math.PI).toFixed(2) + '\u00B0';
    document.getElementById('angleSum').textContent = sumDeg.toFixed(2) + '\u00B0';
    document.getElementById('defect').textContent = defectDeg.toFixed(2) + '\u00B0';
    document.getElementById('hereAngle').textContent = sumDeg.toFixed(2) + '\u00B0';
    document.getElementById('lessText').textContent =
        `${(180 - sumDeg).toFixed(1)}\u00B0 less than Euclidean! Defect = hyperbolic area.`;
}

function drawDisk() {
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, diskR);
    gradient.addColorStop(0, 'rgba(15, 20, 40, 1)');
    gradient.addColorStop(0.7, 'rgba(10, 15, 35, 1)');
    gradient.addColorStop(0.95, 'rgba(20, 30, 60, 1)');
    gradient.addColorStop(1, 'rgba(40, 60, 120, 0.3)');
    ctx.beginPath();
    ctx.arc(cx, cy, diskR, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    // Glow ring
    ctx.shadowColor = '#4488ff';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(cx, cy, diskR, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(80, 140, 255, 0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Concentric reference circles
    for (const r of [0.3, 0.5, 0.7, 0.85]) {
        ctx.beginPath();
        ctx.arc(cx, cy, r * diskR, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(60, 90, 140, 0.12)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
    }
}

function drawTriangle() {
    if (vertices.length < 2) return;

    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, diskR - 1, 0, Math.PI * 2);
    ctx.clip();

    // Draw filled triangle
    if (vertices.length === 3) {
        const [A, B, C] = vertices;
        const defect = Math.PI - (hyperbolicAngle(A, B, C) + hyperbolicAngle(B, A, C) + hyperbolicAngle(C, A, B));
        const defectNorm = Math.min(1, defect / Math.PI);

        // Fill
        const sides = [
            geodesicPoints(A, B, 30),
            geodesicPoints(B, C, 30),
            geodesicPoints(C, A, 30)
        ];

        ctx.beginPath();
        sides.forEach((pts, si) => {
            pts.forEach((pt, i) => {
                const cp = toCanvas(pt.x, pt.y);
                if (si === 0 && i === 0) ctx.moveTo(cp.x, cp.y);
                else ctx.lineTo(cp.x, cp.y);
            });
        });
        ctx.closePath();

        const r = Math.floor(40 + defectNorm * 150);
        const g = Math.floor(20 + (1 - defectNorm) * 80);
        const b = Math.floor(100 + (1 - defectNorm) * 100);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.25)`;
        ctx.fill();
    }

    // Draw edges
    const edges = [];
    if (vertices.length >= 2) edges.push([0, 1]);
    if (vertices.length >= 3) { edges.push([1, 2]); edges.push([2, 0]); }

    edges.forEach(([i, j]) => {
        const pts = geodesicPoints(vertices[i], vertices[j], 40);
        ctx.beginPath();
        pts.forEach((pt, k) => {
            const cp = toCanvas(pt.x, pt.y);
            if (k === 0) ctx.moveTo(cp.x, cp.y);
            else ctx.lineTo(cp.x, cp.y);
        });
        ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
    });

    // Draw angle arcs at each vertex
    if (vertices.length === 3) {
        for (let i = 0; i < 3; i++) {
            const v = vertices[i];
            const p1 = vertices[(i + 1) % 3];
            const p2 = vertices[(i + 2) % 3];

            // Get tangent directions at vertex
            const w1 = mobiusTransform(p1, v);
            const w2 = mobiusTransform(p2, v);
            const a1 = Math.atan2(w1.y, w1.x);
            const a2 = Math.atan2(w2.y, w2.x);

            // Determine shorter arc
            let start = a1, end = a2;
            let diff = end - start;
            if (diff > Math.PI) diff -= 2 * Math.PI;
            if (diff < -Math.PI) diff += 2 * Math.PI;

            const cv = toCanvas(v.x, v.y);
            const arcR = 18;
            ctx.beginPath();
            ctx.arc(cv.x, cv.y, arcR, start, start + diff, diff < 0);
            ctx.strokeStyle = vertexColors[i];
            ctx.lineWidth = 2;
            ctx.stroke();

            // Angle label
            const midA = start + diff / 2;
            const labelR = arcR + 14;
            ctx.font = 'bold 12px monospace';
            ctx.fillStyle = vertexColors[i];
            const ang = hyperbolicAngle(v, p1, p2) * 180 / Math.PI;
            ctx.fillText(ang.toFixed(1) + '\u00B0', cv.x + labelR * Math.cos(midA) - 15, cv.y + labelR * Math.sin(midA) + 4);
        }
    }

    ctx.restore();

    // Draw vertices
    vertices.forEach((v, i) => {
        const cp = toCanvas(v.x, v.y);
        const isHover = (i === hoverVertex);
        const r = isHover ? 8 : 6;

        ctx.shadowColor = vertexColors[i];
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(cp.x, cp.y, r, 0, Math.PI * 2);
        ctx.fillStyle = vertexColors[i];
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.beginPath();
        ctx.arc(cp.x, cp.y, r + 3, 0, Math.PI * 2);
        ctx.strokeStyle = vertexColors[i].replace(')', ', 0.3)').replace('rgb', 'rgba');
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Label
        ctx.font = 'bold 14px sans-serif';
        ctx.fillStyle = vertexColors[i];
        ctx.fillText(vertexLabels[i], cp.x + 12, cp.y - 10);
    });
}

function render() {
    ctx.clearRect(0, 0, W, H);
    drawDisk();
    drawTriangle();
    requestAnimationFrame(render);
}

function findVertex(mx, my) {
    const d = toDisk(mx, my);
    for (let i = 0; i < vertices.length; i++) {
        if (dist2(d, vertices[i]) < 0.002) return i;
    }
    return -1;
}

canvas.addEventListener('mousedown', (e) => {
    const idx = findVertex(e.clientX, e.clientY);
    if (idx >= 0) {
        dragging = idx;
        canvas.classList.add('dragging');
    } else {
        const d = toDisk(e.clientX, e.clientY);
        if (norm2(d) < 0.95 && vertices.length < 3) {
            vertices.push(d);
            updateAngleDisplay();
        }
    }
});

canvas.addEventListener('mousemove', (e) => {
    const d = toDisk(e.clientX, e.clientY);
    if (dragging >= 0 && norm2(d) < 0.95) {
        vertices[dragging] = d;
        updateAngleDisplay();
    }
    hoverVertex = findVertex(e.clientX, e.clientY);
});

canvas.addEventListener('mouseup', () => {
    dragging = -1;
    canvas.classList.remove('dragging');
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    const idx = findVertex(t.clientX, t.clientY);
    if (idx >= 0) {
        dragging = idx;
    } else {
        const d = toDisk(t.clientX, t.clientY);
        if (norm2(d) < 0.95 && vertices.length < 3) {
            vertices.push(d);
            updateAngleDisplay();
        }
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (dragging >= 0) {
        const t = e.touches[0];
        const d = toDisk(t.clientX, t.clientY);
        if (norm2(d) < 0.95) {
            vertices[dragging] = d;
            updateAngleDisplay();
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', () => { dragging = -1; });

// Presets
document.getElementById('presetTiny').addEventListener('click', () => {
    vertices = [
        { x: -0.03, y: -0.02 },
        { x: 0.03, y: -0.02 },
        { x: 0, y: 0.03 }
    ];
    updateAngleDisplay();
});

document.getElementById('presetMedium').addEventListener('click', () => {
    vertices = [
        { x: -0.4, y: -0.3 },
        { x: 0.4, y: -0.3 },
        { x: 0, y: 0.4 }
    ];
    updateAngleDisplay();
});

document.getElementById('presetLarge').addEventListener('click', () => {
    vertices = [
        { x: -0.9, y: -0.3 },
        { x: 0.9, y: -0.3 },
        { x: 0, y: 0.9 }
    ];
    updateAngleDisplay();
});

document.getElementById('clearBtn').addEventListener('click', () => {
    vertices = [];
    updateAngleDisplay();
});

window.reset = function() {
    vertices = [];
    dragging = -1;
    updateAngleDisplay();
};

render();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
