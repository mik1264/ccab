<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hyperbolic Isometries - Non-Euclidean Geometry</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }

.panel {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.8); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px; color: #ccd; width: 260px;
}
.panel h3 { color: #8af; margin-bottom: 12px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.panel label { display: block; margin-bottom: 4px; font-size: 0.82em; color: #99a; }
.panel input[type="range"] { width: 100%; margin-bottom: 10px; accent-color: #8af; }
.btn { display: inline-block; padding: 7px 14px; margin: 3px; background: rgba(138,170,255,0.12); border: 1px solid rgba(138,170,255,0.25); color: #8af; border-radius: 6px; cursor: pointer; font-size: 0.82em; transition: all 0.2s; }
.btn:hover { background: rgba(138,170,255,0.25); }
.btn.active { background: rgba(138,170,255,0.3); border-color: #8af; color: #fff; }
.val { color: #8af; float: right; font-size: 0.82em; }
.toggle-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.toggle-row input { accent-color: #8af; }
.toggle-row label { margin: 0; cursor: pointer; font-size: 0.82em; }
.matrix-display {
    background: rgba(0,0,0,0.3); border-radius: 6px; padding: 10px;
    font-family: 'Courier New', monospace; font-size: 0.72em; color: #8cf;
    margin-top: 10px; line-height: 1.6;
}
.section-label { color: #6a8; font-size: 0.78em; margin-top: 10px; margin-bottom: 6px; font-weight: bold; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>

<div class="panel">
    <h3>Hyperbolic Isometries</h3>
    <div class="section-label">Isometry Type</div>
    <div style="margin-bottom:10px">
        <span class="btn active" id="btnTranslation" data-type="translation">Translation</span>
        <span class="btn" id="btnRotation" data-type="rotation">Rotation</span>
        <span class="btn" id="btnHorolation" data-type="horolation">Horolation</span>
    </div>
    <label>Speed <span class="val" id="speedVal">1.0</span></label>
    <input type="range" id="speed" min="1" max="30" value="10">
    <div class="toggle-row"><input type="checkbox" id="showTrail" checked><label for="showTrail">Show Trail / Ghosts</label></div>
    <div class="toggle-row"><input type="checkbox" id="showOrbit"><label for="showOrbit">Show Orbit Path</label></div>
    <div class="toggle-row"><input type="checkbox" id="showEuclidean" checked><label for="showEuclidean">Compare Euclidean</label></div>
    <div class="matrix-display" id="matrixDisp">
        T(z) = (z - a) / (1 - conj(a)z)<br>
        a = 0.000 + 0.000i
    </div>
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
let animId;
let time = 0;
let isometryType = 'translation';
let speed = 1.0;
let showTrail = true;
let showOrbit = false;
let showEuclidean = true;

// Disk parameters - separate for hyperbolic and Euclidean views
let hDisk = { cx: 0, cy: 0, R: 0 };
let eDisk = { cx: 0, cy: 0, R: 0 };

// Shape: a small hyperbolic pentagon
const shapeVerts = [];
const shapeCenter = [0.3, 0];
const shapeRadius = 0.08;
const shapeSides = 5;
for (let i = 0; i < shapeSides; i++) {
    const a = (i / shapeSides) * Math.PI * 2 - Math.PI / 2;
    shapeVerts.push([
        shapeCenter[0] + shapeRadius * Math.cos(a),
        shapeCenter[1] + shapeRadius * Math.sin(a)
    ]);
}

// Trail history
const trailHistory = [];
const maxTrail = 30;

// Euclidean shape for comparison
const eucCenter = [0.3, 0];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;

    if (showEuclidean) {
        const diskR = Math.min(W * 0.35, H * 0.42);
        hDisk = { cx: W * 0.32, cy: H / 2, R: diskR };
        eDisk = { cx: W * 0.68, cy: H / 2, R: diskR };
    } else {
        const diskR = Math.min(W, H) * 0.42;
        hDisk = { cx: W / 2, cy: H / 2, R: diskR };
        eDisk = { cx: -1000, cy: -1000, R: 0 }; // offscreen
    }
}
resize();
window.addEventListener('resize', resize);

// Complex arithmetic
function cMul(a, b) { return [a[0]*b[0]-a[1]*b[1], a[0]*b[1]+a[1]*b[0]]; }
function cDiv(a, b) { const d=b[0]*b[0]+b[1]*b[1]; return [(a[0]*b[0]+a[1]*b[1])/d, (a[1]*b[0]-a[0]*b[1])/d]; }
function cConj(a) { return [a[0],-a[1]]; }
function cSub(a, b) { return [a[0]-b[0],a[1]-b[1]]; }
function cAdd(a, b) { return [a[0]+b[0],a[1]+b[1]]; }
function cAbs(a) { return Math.sqrt(a[0]*a[0]+a[1]*a[1]); }

// Mobius transform: T(z) = (z - a) / (1 - conj(a)*z)
function mobiusTranslate(z, a) {
    const num = cSub(z, a);
    const den = cSub([1, 0], cMul(cConj(a), z));
    return cDiv(num, den);
}

// Rotation by angle theta around origin
function mobiusRotate(z, theta) {
    return [z[0]*Math.cos(theta) - z[1]*Math.sin(theta),
            z[0]*Math.sin(theta) + z[1]*Math.cos(theta)];
}

// Rotation around a point p by angle theta
function mobiusRotateAround(z, p, theta) {
    // Translate p to origin, rotate, translate back
    const z1 = mobiusTranslate(z, p);
    const z2 = mobiusRotate(z1, theta);
    const negP = [-p[0], -p[1]];
    return mobiusTranslate(z2, negP);
}

// Horolation: parabolic isometry (limit rotation around boundary point)
// Uses the Mobius transform T(z) = (z(1+t*w) + t*w) / (-t*conj(w)*z + (1 - t*conj(w)*... ))
// Simpler: map to upper half-plane, translate, map back
function mobiusHorolation(z, idealAngle, t) {
    // Ideal point on boundary
    const w = [Math.cos(idealAngle), Math.sin(idealAngle)];

    // Cayley transform approach: map ideal point to infinity
    // Use T(z) = (z - w)/(z*conj(w) - 1) to map w to 0
    // Then translate and map back

    // Simpler approach: conjugate translation by a rotation
    // Rotate so ideal point is at z=1, apply standard horolation, rotate back
    const rotAngle = -idealAngle;
    const z1 = mobiusRotate(z, rotAngle);

    // Standard horolation with ideal point at z=1:
    // In the upper half-plane model, horolation is z -> z + t
    // Converting: use Cayley transform between disk and UHP
    // Disk to UHP: w = i(1+z)/(1-z)
    // UHP to Disk: z = (w-i)/(w+i)

    const oneMinusZ = cSub([1,0], z1);
    const onePlusZ = cAdd([1,0], z1);
    if (cAbs(oneMinusZ) < 1e-10) return z; // at the ideal point

    const uhp = cMul([0,1], cDiv(onePlusZ, oneMinusZ));
    const shifted = cAdd(uhp, [t, 0]);
    const disk = cDiv(cSub(shifted, [0,1]), cAdd(shifted, [0,1]));

    return mobiusRotate(disk, -rotAngle);
}

// Get current transform parameter
function getCurrentTransformParam() {
    const t = time * speed * 0.05;

    if (isometryType === 'translation') {
        // Translation along x-axis
        const dist = 0.3 * Math.sin(t * 0.5);
        return { a: [dist, 0] };
    } else if (isometryType === 'rotation') {
        return { angle: t, center: [0.2, 0.1] };
    } else {
        return { idealAngle: 0, t: t * 2 };
    }
}

// Transform a point according to current isometry
function transformPoint(z) {
    const param = getCurrentTransformParam();

    if (isometryType === 'translation') {
        return mobiusTranslate(z, param.a);
    } else if (isometryType === 'rotation') {
        return mobiusRotateAround(z, param.center, param.angle);
    } else {
        return mobiusHorolation(z, param.idealAngle, param.t);
    }
}

// Euclidean equivalent transform
function euclideanTransform(z) {
    const t = time * speed * 0.05;

    if (isometryType === 'translation') {
        const dist = 0.3 * Math.sin(t * 0.5);
        return [z[0] + dist, z[1]];
    } else if (isometryType === 'rotation') {
        const cx = 0.2, cy = 0.1;
        const dx = z[0]-cx, dy = z[1]-cy;
        return [cx + dx*Math.cos(t) - dy*Math.sin(t), cy + dx*Math.sin(t) + dy*Math.cos(t)];
    } else {
        // Euclidean "horolation" equivalent: just translation
        return [z[0] + t * 0.15, z[1]];
    }
}

function diskToScreenH(x, y) { return [hDisk.cx + x*hDisk.R, hDisk.cy + y*hDisk.R]; }
function diskToScreenE(x, y) { return [eDisk.cx + x*eDisk.R, eDisk.cy + y*eDisk.R]; }

function drawDisk(disk, label) {
    // Glow
    const grad = ctx.createRadialGradient(disk.cx, disk.cy, disk.R-6, disk.cx, disk.cy, disk.R+6);
    grad.addColorStop(0, 'rgba(138,170,255,0.1)');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(disk.cx, disk.cy, disk.R+6, 0, Math.PI*2);
    ctx.fill();

    // Boundary
    ctx.strokeStyle = 'rgba(138,170,255,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(disk.cx, disk.cy, disk.R, 0, Math.PI*2);
    ctx.stroke();

    // Label
    ctx.fillStyle = 'rgba(138,170,255,0.5)';
    ctx.font = '14px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(label, disk.cx, disk.cy + disk.R + 25);
}

function drawShape(verts, toScreen, color, alpha, fill) {
    if (verts.length < 2) return;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    const [sx, sy] = toScreen(verts[0][0], verts[0][1]);
    ctx.moveTo(sx, sy);
    for (let i = 1; i < verts.length; i++) {
        const [px, py] = toScreen(verts[i][0], verts[i][1]);
        ctx.lineTo(px, py);
    }
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = color;
        ctx.fill();
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;
}

function drawOrbitPath(disk, toScreen, transformFn) {
    ctx.strokeStyle = 'rgba(255,200,100,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();

    const center = shapeCenter;
    let started = false;
    const savedTime = time;

    for (let i = 0; i <= 200; i++) {
        time = i * 0.3;
        const pt = transformFn(center);
        const r = Math.sqrt(pt[0]*pt[0]+pt[1]*pt[1]);
        if (r < 0.98) {
            const [sx, sy] = toScreen(pt[0], pt[1]);
            if (!started) { ctx.moveTo(sx, sy); started = true; }
            else ctx.lineTo(sx, sy);
        }
    }
    time = savedTime;
    ctx.stroke();
    ctx.setLineDash([]);
}

function updateMatrixDisplay() {
    const param = getCurrentTransformParam();
    const disp = document.getElementById('matrixDisp');

    if (isometryType === 'translation') {
        const a = param.a;
        disp.innerHTML = `T(z) = (z - a) / (1 - <span style="text-decoration:overline">a</span>z)<br>` +
            `a = ${a[0].toFixed(3)} + ${a[1].toFixed(3)}i<br>` +
            `<span style="color:#6a8">Type: Hyperbolic translation</span>`;
    } else if (isometryType === 'rotation') {
        const deg = ((param.angle * 180 / Math.PI) % 360).toFixed(1);
        disp.innerHTML = `T(z) = e<sup>i&theta;</sup>(z - p)/(1 - <span style="text-decoration:overline">p</span>z)<br>` +
            `&theta; = ${deg}&deg;<br>` +
            `p = (${param.center[0].toFixed(2)}, ${param.center[1].toFixed(2)})<br>` +
            `<span style="color:#6a8">Type: Elliptic isometry</span>`;
    } else {
        disp.innerHTML = `Parabolic transform<br>` +
            `Ideal point: (1, 0)<br>` +
            `t = ${param.t.toFixed(2)}<br>` +
            `<span style="color:#6a8">Type: Parabolic (horolation)</span>`;
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Draw disks
    drawDisk(hDisk, 'Hyperbolic (Poincare Disk)');
    if (showEuclidean) drawDisk(eDisk, 'Euclidean');

    // --- Hyperbolic side ---
    ctx.save();
    ctx.beginPath();
    ctx.arc(hDisk.cx, hDisk.cy, hDisk.R, 0, Math.PI*2);
    ctx.clip();

    // Draw orbit path
    if (showOrbit) drawOrbitPath(hDisk, diskToScreenH, transformPoint);

    // Draw rotation center or translation axis
    if (isometryType === 'rotation') {
        const [pcx, pcy] = diskToScreenH(0.2, 0.1);
        ctx.fillStyle = 'rgba(255,200,100,0.6)';
        ctx.beginPath();
        ctx.arc(pcx, pcy, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,200,100,0.3)';
        ctx.font = '11px sans-serif';
        ctx.fillText('center', pcx+8, pcy+4);
    } else if (isometryType === 'translation') {
        // Draw the translation geodesic (x-axis)
        const [sx, sy] = diskToScreenH(-0.99, 0);
        const [ex, ey] = diskToScreenH(0.99, 0);
        ctx.strokeStyle = 'rgba(255,200,100,0.2)';
        ctx.lineWidth = 1;
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.setLineDash([]);
    } else {
        // Mark ideal point
        const [ix, iy] = diskToScreenH(1, 0);
        ctx.fillStyle = 'rgba(255,100,100,0.7)';
        ctx.beginPath();
        ctx.arc(ix, iy, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,100,100,0.4)';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText('ideal pt', ix-8, iy+4);
        ctx.textAlign = 'left';
    }

    // Draw ghost trail
    if (showTrail) {
        for (let i = 0; i < trailHistory.length; i++) {
            const alpha = (i / trailHistory.length) * 0.4;
            drawShape(trailHistory[i], diskToScreenH, `rgba(100,180,255,${alpha})`, 1, true);
        }
    }

    // Draw current transformed shape
    const transformedVerts = shapeVerts.map(v => transformPoint(v));
    const valid = transformedVerts.every(v => cAbs(v) < 0.99);
    if (valid) {
        drawShape(transformedVerts, diskToScreenH, '#4af', 0.8, true);
        drawShape(transformedVerts, diskToScreenH, '#8cf', 1, false);
    }

    // Draw original shape faintly
    drawShape(shapeVerts, diskToScreenH, 'rgba(138,170,255,0.15)', 1, true);

    ctx.restore();

    // --- Euclidean side ---
    if (showEuclidean) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(eDisk.cx, eDisk.cy, eDisk.R, 0, Math.PI*2);
        ctx.clip();

        if (showOrbit) drawOrbitPath(eDisk, diskToScreenE, euclideanTransform);

        // Draw rotation center for euclidean
        if (isometryType === 'rotation') {
            const [pcx, pcy] = diskToScreenE(0.2, 0.1);
            ctx.fillStyle = 'rgba(255,200,100,0.6)';
            ctx.beginPath();
            ctx.arc(pcx, pcy, 4, 0, Math.PI*2);
            ctx.fill();
        }

        // Euclidean ghost trail
        if (showTrail) {
            const savedT = time;
            for (let i = 0; i < trailHistory.length; i++) {
                const alpha = (i / trailHistory.length) * 0.4;
                // Reconstruct euclidean trail
                const trailTime = savedT - (trailHistory.length - i) * 0.3;
                const origTime = time;
                time = trailTime;
                const eVerts = shapeVerts.map(v => euclideanTransform(v));
                time = origTime;
                drawShape(eVerts, diskToScreenE, `rgba(100,255,150,${alpha})`, 1, true);
            }
        }

        // Current euclidean shape
        const eVerts = shapeVerts.map(v => euclideanTransform(v));
        drawShape(eVerts, diskToScreenE, '#4fa', 0.8, true);
        drawShape(eVerts, diskToScreenE, '#8fc', 1, false);

        // Original
        drawShape(shapeVerts, diskToScreenE, 'rgba(100,255,150,0.15)', 1, true);

        ctx.restore();
    }

    // Divider line
    if (showEuclidean) {
        ctx.strokeStyle = 'rgba(138,170,255,0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([6,6]);
        ctx.beginPath();
        ctx.moveTo(W/2, 30);
        ctx.lineTo(W/2, H-30);
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

function update() {
    time += 0.016;

    // Record trail
    if (showTrail) {
        const transformed = shapeVerts.map(v => transformPoint(v));
        if (transformed.every(v => cAbs(v) < 0.99)) {
            trailHistory.push(transformed);
            if (trailHistory.length > maxTrail) trailHistory.shift();
        }
    }

    updateMatrixDisplay();
}

function animate() {
    update();
    draw();
    animId = requestAnimationFrame(animate);
}

// Button handlers
document.querySelectorAll('.btn[data-type]').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.btn[data-type]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        isometryType = this.dataset.type;
        trailHistory.length = 0;
        time = 0;
    });
});

document.getElementById('speed').addEventListener('input', function() {
    speed = this.value / 10;
    document.getElementById('speedVal').textContent = speed.toFixed(1);
});

document.getElementById('showTrail').addEventListener('change', function() {
    showTrail = this.checked;
    if (!showTrail) trailHistory.length = 0;
});
document.getElementById('showOrbit').addEventListener('change', function() { showOrbit = this.checked; });
document.getElementById('showEuclidean').addEventListener('change', function() {
    showEuclidean = this.checked;
    resize();
});

window.reset = function() {
    time = 0;
    isometryType = 'translation';
    trailHistory.length = 0;
    document.querySelectorAll('.btn[data-type]').forEach(b => b.classList.remove('active'));
    document.getElementById('btnTranslation').classList.add('active');
    resize();
};

resize();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>