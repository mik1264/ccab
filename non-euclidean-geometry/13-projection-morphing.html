<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Projection Morphing Gallery</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,30,0.75);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 12px;
  padding: 18px; color: #cde; z-index: 100; min-width: 240px;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1em; }
.btn {
  display: block; width: 100%; margin: 4px 0; padding: 7px 12px;
  background: rgba(138,170,255,0.1); border: 1px solid rgba(138,170,255,0.25);
  border-radius: 6px; color: #cde; cursor: pointer; font-size: 0.85em; text-align: left;
}
.btn:hover { background: rgba(138,170,255,0.2); }
.btn.active { background: rgba(138,170,255,0.3); border-color: #8af; color: #fff; }
label { display: block; margin-top: 10px; font-size: 0.8em; color: #89a; }
input[type=range] { width: 100%; margin-top: 4px; accent-color: #8af; }
#projLabel {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(10,14,30,0.8); backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 10px;
  padding: 12px 24px; color: #cde; font-size: 1em; text-align: center; z-index: 100;
}
#projLabel .prop { color: #8af; font-size: 0.8em; margin-top: 4px; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Projection Morphing</h3>
  <button class="btn active" data-proj="0">Equirectangular</button>
  <button class="btn" data-proj="1">Mercator</button>
  <button class="btn" data-proj="2">Sinusoidal</button>
  <button class="btn" data-proj="3">Orthographic</button>
  <label style="margin-top:12px">
    <input type="checkbox" id="autoMorph" checked> Auto-cycle projections
  </label>
  <label>
    <input type="checkbox" id="showDistortion"> Show distortion heatmap
  </label>
  <label>Transition Speed</label>
  <input type="range" id="transSpeed" min="0.5" max="3" value="1.5" step="0.1">
</div>
<div id="projLabel">
  <div id="projName">Equirectangular</div>
  <div class="prop" id="projProp">Equidistant along meridians</div>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
}
resize();
window.addEventListener('resize', resize);

const projNames = ['Equirectangular', 'Mercator', 'Sinusoidal', 'Orthographic'];
const projProps = [
  'Equidistant along meridians',
  'Conformal (preserves angles)',
  'Equal-area (preserves area)',
  'Perspective (view from space)'
];

// Simplified continent outlines (lat, lon pairs in degrees)
const continents = [
  // North America
  [[-10,70],[-20,60],[-30,55],[-50,55],[-65,45],[-80,30],[-95,30],[-105,25],[-120,35],[-125,50],[-140,60],[-165,65],[-165,72],[-100,72],[-80,70],[-60,65],[-55,70],[-10,70]],
  // South America
  [[-35,-5],[-40,-20],[-50,-25],[-55,-20],[-70,-15],[-80,-5],[-75,5],[-60,10],[-55,5],[-35,-5]],
  // Europe
  [[0,40],[5,45],[10,50],[15,55],[25,60],[30,70],[20,70],[5,60],[-5,50],[0,45],[0,40]],
  // Africa
  [[10,35],[15,30],[35,30],[50,12],[50,0],[40,-15],[30,-25],[20,-35],[15,-30],[5,-10],[-15,5],[-15,15],[0,30],[10,35]],
  // Asia
  [[30,70],[40,60],[50,50],[60,40],[70,30],[80,20],[90,25],[100,20],[110,22],[120,30],[130,35],[140,45],[155,55],[175,65],[180,68],[170,70],[140,55],[120,55],[105,50],[80,55],[60,60],[40,65],[30,70]],
  // Australia
  [[115,-15],[130,-12],[145,-15],[153,-25],[150,-35],[140,-38],[130,-35],[115,-25],[115,-15]]
];

// Convert to radians
const continentsRad = continents.map(c => c.map(([lon, lat]) => [lon * Math.PI / 180, lat * Math.PI / 180]));

// Projection functions: map (lon, lat) in radians to normalized coords [-1,1] range roughly
function equirect(lon, lat) {
  return [lon / Math.PI, lat / (Math.PI/2)];
}

function mercator(lon, lat) {
  const clampLat = Math.max(-1.4, Math.min(1.4, lat));
  return [lon / Math.PI, Math.log(Math.tan(Math.PI/4 + clampLat/2)) / Math.PI];
}

function sinusoidal(lon, lat) {
  return [lon * Math.cos(lat) / Math.PI, lat / (Math.PI/2)];
}

function orthographic(lon, lat) {
  const x = Math.cos(lat) * Math.sin(lon);
  const y = Math.sin(lat);
  const z = Math.cos(lat) * Math.cos(lon);
  if (z < -0.05) return null; // behind globe
  return [x, y];
}

const projFuncs = [equirect, mercator, sinusoidal, orthographic];

let currentProj = 0, targetProj = 0;
let morphT = 1; // 0 = transitioning, 1 = arrived
let autoMorph = true;
let showDistortion = false;
let transSpeed = 1.5;
let cycleTimer = 0;

function lerpProj(lon, lat, from, to, t) {
  const p1 = projFuncs[from](lon, lat);
  const p2 = projFuncs[to](lon, lat);
  if (!p1 || !p2) return null;
  const ease = t * t * (3 - 2 * t); // smoothstep
  return [p1[0] * (1-ease) + p2[0] * ease, p1[1] * (1-ease) + p2[1] * ease];
}

function toScreen(nx, ny) {
  const scale = Math.min(W, H) * 0.38;
  return [W/2 + nx * scale, H/2 - ny * scale];
}

function draw(time) {
  const dt = 1/60;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Auto-morph timer
  if (autoMorph && morphT >= 1) {
    cycleTimer += dt;
    if (cycleTimer > 3) {
      cycleTimer = 0;
      currentProj = targetProj;
      targetProj = (targetProj + 1) % 4;
      morphT = 0;
    }
  }

  if (morphT < 1) {
    morphT = Math.min(1, morphT + dt * transSpeed * 0.5);
  }

  const fromP = currentProj;
  const toP = targetProj;
  const t = morphT;

  // Update label
  if (t >= 1) {
    document.getElementById('projName').textContent = projNames[toP];
    document.getElementById('projProp').textContent = projProps[toP];
    // Update active button
    document.querySelectorAll('.btn[data-proj]').forEach(b => b.classList.remove('active'));
    const ab = document.querySelector(`[data-proj="${toP}"]`);
    if (ab) ab.classList.add('active');
  } else {
    document.getElementById('projName').textContent = projNames[fromP] + ' \u2192 ' + projNames[toP];
    document.getElementById('projProp').textContent = `Morphing... ${Math.round(t*100)}%`;
  }

  // Distortion heatmap
  if (showDistortion) {
    const step = 8;
    for (let px = 0; px < W; px += step) {
      for (let py = 0; py < H; py += step) {
        // Reverse map approximate
        const scale = Math.min(W, H) * 0.38;
        const nx = (px - W/2) / scale;
        const ny = -(py - H/2) / scale;
        if (Math.abs(nx) > 1.2 || Math.abs(ny) > 1.2) continue;

        const activeProj = t >= 1 ? toP : fromP;
        // Compute area distortion for active projection
        let distortion = 0;
        if (activeProj === 1) { // Mercator
          const lat = Math.atan(Math.sinh(ny * Math.PI));
          distortion = 1 / Math.cos(lat);
        } else if (activeProj === 2) { // Sinusoidal
          distortion = 0.2;
        } else if (activeProj === 3) { // Orthographic
          const r = Math.sqrt(nx*nx + ny*ny);
          distortion = r < 1 ? r * 0.5 : 0;
        } else {
          // Equirectangular
          const lat = ny * Math.PI/2;
          distortion = Math.abs(Math.cos(lat)) < 0.01 ? 2 : 1/Math.cos(lat) - 1;
        }

        const d = Math.min(1, Math.max(0, (distortion - 0.2) / 3));
        if (d > 0.01) {
          const r = Math.round(50 + d * 200);
          const g = Math.round(50 * (1-d));
          const b = Math.round(50 * (1-d));
          ctx.fillStyle = `rgba(${r},${g},${b},${d * 0.25})`;
          ctx.fillRect(px, py, step, step);
        }
      }
    }
  }

  // Draw graticule (lat/lon grid)
  ctx.lineWidth = 1;

  // Latitude lines
  for (let lat = -80; lat <= 80; lat += 20) {
    const latR = lat * Math.PI / 180;
    ctx.strokeStyle = lat === 0 ? 'rgba(138,170,255,0.35)' : 'rgba(138,170,255,0.12)';
    ctx.beginPath();
    let started = false;
    for (let lon = -180; lon <= 180; lon += 3) {
      const lonR = lon * Math.PI / 180;
      const p = lerpProj(lonR, latR, fromP, toP, t);
      if (!p) { started = false; continue; }
      const [sx, sy] = toScreen(p[0], p[1]);
      if (!started) { ctx.moveTo(sx, sy); started = true; }
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
  }

  // Longitude lines
  for (let lon = -180; lon <= 180; lon += 30) {
    const lonR = lon * Math.PI / 180;
    ctx.strokeStyle = lon === 0 ? 'rgba(138,170,255,0.35)' : 'rgba(138,170,255,0.12)';
    ctx.beginPath();
    let started = false;
    for (let lat = -85; lat <= 85; lat += 3) {
      const latR = lat * Math.PI / 180;
      const p = lerpProj(lonR, latR, fromP, toP, t);
      if (!p) { started = false; continue; }
      const [sx, sy] = toScreen(p[0], p[1]);
      if (!started) { ctx.moveTo(sx, sy); started = true; }
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
  }

  // Draw continents
  for (const cont of continentsRad) {
    ctx.strokeStyle = 'rgba(100,220,160,0.7)';
    ctx.fillStyle = 'rgba(40,120,80,0.25)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let started = false;
    for (const [lon, lat] of cont) {
      const p = lerpProj(lon, lat, fromP, toP, t);
      if (!p) { started = false; continue; }
      const [sx, sy] = toScreen(p[0], p[1]);
      if (!started) { ctx.moveTo(sx, sy); started = true; }
      else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  requestAnimationFrame(draw);
}

// Controls
document.querySelectorAll('.btn[data-proj]').forEach(btn => {
  btn.addEventListener('click', () => {
    const target = parseInt(btn.dataset.proj);
    if (target !== targetProj) {
      currentProj = targetProj;
      targetProj = target;
      morphT = 0;
      cycleTimer = 0;
      autoMorph = false;
      document.getElementById('autoMorph').checked = false;
    }
  });
});

document.getElementById('autoMorph').addEventListener('change', function() {
  autoMorph = this.checked;
  cycleTimer = 0;
});

document.getElementById('showDistortion').addEventListener('change', function() {
  showDistortion = this.checked;
});

document.getElementById('transSpeed').addEventListener('input', function() {
  transSpeed = parseFloat(this.value);
});

window.reset = function() {
  currentProj = 0; targetProj = 0; morphT = 1; cycleTimer = 0;
  autoMorph = true; showDistortion = false; transSpeed = 1.5;
  document.getElementById('autoMorph').checked = true;
  document.getElementById('showDistortion').checked = false;
  document.getElementById('transSpeed').value = 1.5;
  document.querySelectorAll('.btn[data-proj]').forEach(b => b.classList.remove('active'));
  document.querySelector('[data-proj="0"]').classList.add('active');
};

requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
