<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Parallel Lines Divergence</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    #controls {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: rgba(10, 14, 30, 0.85);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 160, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        color: #c8d8f0;
        min-width: 280px;
    }
    #controls h3 { color: #8af; margin-bottom: 8px; font-size: 1.1em; }
    .info-text { font-size: 0.82em; color: #8a9ab0; line-height: 1.4; margin: 6px 0; }
    .highlight { color: #fbbf24; font-weight: bold; }
    .metric-box {
        background: rgba(20, 30, 50, 0.6);
        border-radius: 8px; padding: 12px; margin: 10px 0;
    }
    .metric-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 0.88em; }
    .metric-label { color: #8a9ab0; }
    .metric-value { font-family: monospace; font-weight: bold; color: #adf; }
    .ctrl-row { margin: 8px 0; display: flex; align-items: center; gap: 10px; font-size: 0.85em; }
    .ctrl-row label { min-width: 80px; color: #8a9ab0; }
    input[type="range"] { flex: 1; accent-color: #8af; }
    .val { color: #adf; font-family: monospace; min-width: 30px; text-align: right; }
    .btn {
        background: rgba(100, 160, 255, 0.15); border: 1px solid rgba(100, 160, 255, 0.3);
        color: #8af; padding: 6px 14px; border-radius: 6px; cursor: pointer;
        font-size: 0.85em; transition: all 0.2s;
    }
    .btn:hover { background: rgba(100, 160, 255, 0.3); }
    .btn-row { margin-top: 10px; display: flex; gap: 6px; justify-content: center; }
    .legend { margin-top: 10px; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.8em; margin: 3px 0; }
    .legend-swatch { width: 20px; height: 3px; border-radius: 2px; }
    label.check { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.85em; margin: 4px 0; }
    input[type="checkbox"] { accent-color: #8af; }
    .euclid-box {
        background: rgba(255, 100, 100, 0.08);
        border: 1px solid rgba(255, 100, 100, 0.2);
        border-radius: 6px; padding: 8px; margin: 8px 0;
        font-size: 0.8em; color: #f88;
    }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>

<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Parallel Lines Divergence</h3>
    <div class="info-text">
        In hyperbolic geometry, through a point P not on line L,
        there are <span class="highlight">infinitely many</span> parallel lines!
    </div>

    <div class="euclid-box">
        <b>Euclid's 5th Postulate fails here!</b><br>
        Euclidean: exactly 1 parallel through P<br>
        Hyperbolic: infinitely many parallels through P
    </div>

    <div class="metric-box">
        <div class="metric-row">
            <span class="metric-label">Angle of Parallelism:</span>
            <span class="metric-value" id="paraAngle">--</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Distance P to L:</span>
            <span class="metric-value" id="distPL">--</span>
        </div>
        <div class="metric-row" style="font-size:0.78em;color:#6a7a9a;margin-top:4px;">
            <span>Formula: &Pi;(d) = 2 arctan(e<sup>-d</sup>)</span>
        </div>
    </div>

    <div class="ctrl-row">
        <label>Parallels:</label>
        <input type="range" id="numParallels" min="3" max="20" value="9">
        <span class="val" id="numParVal">9</span>
    </div>
    <div class="ctrl-row">
        <label>Sweep:</label>
        <input type="range" id="sweepSpeed" min="0" max="100" value="30">
        <span class="val" id="sweepVal">30</span>
    </div>
    <label class="check"><input type="checkbox" id="showSweep" checked> Animate sweep</label>
    <label class="check"><input type="checkbox" id="showLabels" checked> Show labels</label>

    <div class="legend">
        <div class="legend-item"><div class="legend-swatch" style="background:#fbbf24;"></div> Line L (base geodesic)</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#60a5fa;"></div> Limiting parallels</div>
        <div class="legend-item"><div class="legend-swatch" style="background:linear-gradient(90deg,#60a5fa,#f87171);"></div> Ultra-parallels (diverging)</div>
    </div>

    <div class="btn-row">
        <button class="btn" id="resetBtn">Reset</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H, cx, cy, diskR;
let numParallels = 9;
let sweepSpeed = 0.003;
let sweepAngle = 0;
let animateSweep = true;
let showLabels = true;

// Line L defined by two points on the boundary - a horizontal geodesic (diameter)
let lineL = { p1: { x: -0.95, y: 0 }, p2: { x: 0.95, y: 0 } };
// Point P not on L
let pointP = { x: 0, y: -0.4 };

let draggingP = false;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
    cy = H / 2;
    diskR = Math.min(W, H) * 0.38;
}
resize();
window.addEventListener('resize', resize);

function toDisk(px, py) { return { x: (px - cx) / diskR, y: (py - cy) / diskR }; }
function toCanvas(dx, dy) { return { x: cx + dx * diskR, y: cy + dy * diskR }; }
function norm2(z) { return z.x * z.x + z.y * z.y; }
function norm(z) { return Math.sqrt(norm2(z)); }
function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }

function mobiusTransform(z, a) {
    const num = { x: z.x - a.x, y: z.y - a.y };
    const ca = { x: a.x, y: -a.y };
    const den = { x: 1 - (ca.x * z.x - ca.y * z.y), y: -(ca.x * z.y + ca.y * z.x) };
    const d2 = den.x * den.x + den.y * den.y;
    if (d2 < 1e-15) return { x: 0, y: 0 };
    return { x: (num.x * den.x + num.y * den.y) / d2, y: (num.y * den.x - num.x * den.y) / d2 };
}

function mobiusInverse(w, a) {
    const num = { x: w.x + a.x, y: w.y + a.y };
    const ca = { x: a.x, y: -a.y };
    const den = { x: 1 + (ca.x * w.x - ca.y * w.y), y: ca.x * w.y + ca.y * w.x };
    const d2 = den.x * den.x + den.y * den.y;
    if (d2 < 1e-15) return { x: 0, y: 0 };
    return { x: (num.x * den.x + num.y * den.y) / d2, y: (num.y * den.x - num.x * den.y) / d2 };
}

function hyperbolicDistance(z1, z2) {
    const n1 = norm2(z1), n2 = norm2(z2);
    if (n1 >= 1 || n2 >= 1) return Infinity;
    const d2 = (z1.x - z2.x) ** 2 + (z1.y - z2.y) ** 2;
    const val = 1 + 2 * d2 / ((1 - n1) * (1 - n2));
    return Math.acosh(Math.max(1, val));
}

function geodesicPoints(p1, p2, n) {
    n = n || 60;
    const cross = p1.x * p2.y - p1.y * p2.x;
    const pts = [];
    if (Math.abs(cross) < 1e-6) {
        for (let i = 0; i <= n; i++) {
            const t = i / n;
            pts.push({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });
        }
        return pts;
    }
    const n1 = norm2(p1);
    if (n1 < 1e-12) {
        for (let i = 0; i <= n; i++) {
            const t = i / n;
            pts.push({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });
        }
        return pts;
    }
    const p1inv = { x: p1.x / n1, y: -p1.y / n1 };
    const ax = p2.x - p1.x, ay = p2.y - p1.y;
    const bx = p1inv.x - p1.x, by = p1inv.y - p1.y;
    const mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2;
    const mx2 = (p1.x + p1inv.x) / 2, my2 = (p1.y + p1inv.y) / 2;
    const d1x = -ay, d1y = ax, d2x = -by, d2y = bx;
    const det = d1x * d2y - d1y * d2x;
    if (Math.abs(det) < 1e-12) {
        for (let i = 0; i <= n; i++) {
            const t = i / n;
            pts.push({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });
        }
        return pts;
    }
    const dx = mx2 - mx1, dy = my2 - my1;
    const t = (dx * d2y - dy * d2x) / det;
    const ccx = mx1 + t * d1x, ccy = my1 + t * d1y;
    const rad = Math.sqrt((p1.x - ccx) ** 2 + (p1.y - ccy) ** 2);
    let a1 = Math.atan2(p1.y - ccy, p1.x - ccx);
    let a2 = Math.atan2(p2.y - ccy, p2.x - ccx);
    let diff = a2 - a1;
    if (diff > Math.PI) diff -= 2 * Math.PI;
    if (diff < -Math.PI) diff += 2 * Math.PI;
    for (let i = 0; i <= n; i++) {
        const tt = i / n;
        const a = a1 + diff * tt;
        pts.push({ x: ccx + rad * Math.cos(a), y: ccy + rad * Math.sin(a) });
    }
    return pts;
}

function drawGeodesicLine(p1, p2, color, width) {
    const pts = geodesicPoints(p1, p2, 60);
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const cp = toCanvas(pts[i].x, pts[i].y);
        if (i === 0) ctx.moveTo(cp.x, cp.y);
        else ctx.lineTo(cp.x, cp.y);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = width || 2;
    ctx.stroke();
}

// Find hyperbolic perpendicular foot from P to line L
function perpFoot(P, L1, L2) {
    // Move L1 to origin
    const wP = mobiusTransform(P, L1);
    const wL2 = mobiusTransform(L2, L1);
    // L through origin is a diameter in direction of wL2
    const angle = Math.atan2(wL2.y, wL2.x);
    // Rotate so L is along x-axis
    const c = Math.cos(-angle), s = Math.sin(-angle);
    const rotP = { x: wP.x * c - wP.y * s, y: wP.x * s + wP.y * c };
    // Perpendicular foot on x-axis in the rotated frame
    // In the Poincare disk with L along x-axis, the perpendicular from (a,b) meets x-axis at...
    // Using the formula for the foot: it's the point on x-axis closest in hyperbolic metric
    // For a horizontal diameter, the foot is at (x, 0) where:
    // x = (rotP.x * (1 + rotP.x^2 + rotP.y^2)) / (something...)
    // Simpler: reflect and use the perpendicular bisector
    // For a diameter through origin, perpendicular geodesic from point p is:
    // The geodesic from p to its reflection across the diameter
    const reflected = { x: rotP.x, y: -rotP.y };
    // The midpoint of the geodesic from rotP to reflected is the foot
    // For perpendicular to diameter (x-axis): foot.y = 0
    // Use Mobius midpoint: transform rotP to origin, the image of reflected gives us the geodesic
    // Actually for a diameter, the foot has a known formula:
    const a = rotP.x, b = rotP.y;
    const r2 = a * a + b * b;
    // The perpendicular foot on the x-axis:
    const footX = a * (1 - b * b + a * a) / ((1 + a) * (1 + a) + b * b - a * ((1 - a) * (1 - a) + b * b) / ((1 + a) * (1 + a) + b * b) * ((1 + a) * (1 + a) + b * b));
    // Simpler approach: numerically minimize distance
    let bestX = 0, bestD = Infinity;
    for (let t = -0.99; t <= 0.99; t += 0.005) {
        const fp = { x: t, y: 0 };
        const d = hyperbolicDistance(rotP, fp);
        if (d < bestD) { bestD = d; bestX = t; }
    }
    // Refine
    for (let t = bestX - 0.005; t <= bestX + 0.005; t += 0.0002) {
        if (Math.abs(t) >= 1) continue;
        const fp = { x: t, y: 0 };
        const d = hyperbolicDistance(rotP, fp);
        if (d < bestD) { bestD = d; bestX = t; }
    }
    const footRotated = { x: bestX, y: 0 };
    // Rotate back
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const footW = { x: footRotated.x * c2 - footRotated.y * s2, y: footRotated.x * s2 + footRotated.y * c2 };
    // Mobius inverse back
    return mobiusInverse(footW, L1);
}

function computeParallels() {
    // Transform so P is at origin and L is mapped accordingly
    const wL1 = mobiusTransform(lineL.p1, pointP);
    const wL2 = mobiusTransform(lineL.p2, pointP);

    // Direction of L endpoints from origin
    const aL1 = Math.atan2(wL1.y, wL1.x);
    const aL2 = Math.atan2(wL2.y, wL2.x);

    // The limiting parallels go from P (origin in transformed space) toward the ideal endpoints of L
    // L's ideal endpoints are where the geodesic meets the unit circle
    // Since wL1 and wL2 are near the boundary (if original points were near boundary),
    // we need to find the actual ideal endpoints of the geodesic through wL1 and wL2

    // Find the geodesic circle through wL1, wL2 perpendicular to unit circle
    // then find where it intersects the unit circle
    const cross = wL1.x * wL2.y - wL1.y * wL2.x;
    let idealA, idealB;

    if (Math.abs(cross) < 1e-6) {
        // Diameter
        const ang = Math.atan2(wL2.y - wL1.y, wL2.x - wL1.x);
        idealA = { x: Math.cos(ang), y: Math.sin(ang) };
        idealB = { x: -Math.cos(ang), y: -Math.sin(ang) };
    } else {
        const n1 = norm2(wL1);
        const wL1inv = { x: wL1.x / n1, y: -wL1.y / n1 };
        const ax = wL2.x - wL1.x, ay = wL2.y - wL1.y;
        const bx = wL1inv.x - wL1.x, by = wL1inv.y - wL1.y;
        const mx1 = (wL1.x + wL2.x) / 2, my1 = (wL1.y + wL2.y) / 2;
        const mx2 = (wL1.x + wL1inv.x) / 2, my2 = (wL1.y + wL1inv.y) / 2;
        const d1x = -ay, d1y = ax, d2x = -by, d2y = bx;
        const det = d1x * d2y - d1y * d2x;
        if (Math.abs(det) > 1e-12) {
            const dx = mx2 - mx1, dy = my2 - my1;
            const t = (dx * d2y - dy * d2x) / det;
            const ccx = mx1 + t * d1x, ccy = my1 + t * d1y;
            const rad = Math.sqrt((wL1.x - ccx) ** 2 + (wL1.y - ccy) ** 2);
            // Intersect with unit circle: |P - C|^2 = r^2 and |P|^2 = 1
            // (x-ccx)^2 + (y-ccy)^2 = rad^2 and x^2 + y^2 = 1
            // Expand: 1 - 2*ccx*x - 2*ccy*y + ccx^2 + ccy^2 = rad^2
            // 2*ccx*x + 2*ccy*y = 1 + ccx^2 + ccy^2 - rad^2
            const k = (1 + ccx * ccx + ccy * ccy - rad * rad) / 2;
            // ccx*x + ccy*y = k
            const cNorm2 = ccx * ccx + ccy * ccy;
            if (Math.abs(ccy) > 1e-10) {
                // y = (k - ccx*x) / ccy
                // x^2 + ((k-ccx*x)/ccy)^2 = 1
                const A = 1 + (ccx * ccx) / (ccy * ccy);
                const B = -2 * ccx * k / (ccy * ccy);
                const C = (k * k) / (ccy * ccy) - 1;
                const disc = B * B - 4 * A * C;
                if (disc >= 0) {
                    const x1 = (-B + Math.sqrt(disc)) / (2 * A);
                    const x2 = (-B - Math.sqrt(disc)) / (2 * A);
                    const y1 = (k - ccx * x1) / ccy;
                    const y2 = (k - ccx * x2) / ccy;
                    idealA = { x: x1, y: y1 };
                    idealB = { x: x2, y: y2 };
                }
            } else if (Math.abs(ccx) > 1e-10) {
                const xk = k / ccx;
                const yy = Math.sqrt(Math.max(0, 1 - xk * xk));
                idealA = { x: xk, y: yy };
                idealB = { x: xk, y: -yy };
            }
        }
    }

    if (!idealA || !idealB) {
        idealA = { x: 1, y: 0 };
        idealB = { x: -1, y: 0 };
    }

    // Angles of the two ideal endpoints as seen from origin (= P in transformed space)
    const angA = Math.atan2(idealA.y, idealA.x);
    const angB = Math.atan2(idealB.y, idealB.x);

    // Limiting parallels: geodesics from origin toward idealA and idealB
    // In the original disk, these go from P toward the inverse-transformed ideal points
    const limA_orig = mobiusInverse({ x: idealA.x * 0.98, y: idealA.y * 0.98 }, pointP);
    const limB_orig = mobiusInverse({ x: idealB.x * 0.98, y: idealB.y * 0.98 }, pointP);

    // Ultra-parallels: lines through P at angles between the limiting parallels
    let angMin = angA, angMax = angB;
    let diff = angMax - angMin;
    if (diff > Math.PI) { diff -= 2 * Math.PI; angMax = angMin + diff; }
    if (diff < -Math.PI) { diff += 2 * Math.PI; angMax = angMin + diff; }

    // Make sure we're sweeping through the side away from L
    // Test: midpoint angle should be in the "parallel" zone (not crossing L)
    const midAng = angMin + diff / 2;
    const testPt = { x: 0.5 * Math.cos(midAng), y: 0.5 * Math.sin(midAng) };
    const testOrig = mobiusInverse(testPt, pointP);
    // Check if testOrig is on the same side as P relative to L
    // If the line L is roughly horizontal and P is above, we want the upper parallels
    // Simple test: check the geodesic from test to some point on L - if it crosses L, we have the wrong sweep
    // Just use sign of cross product for a heuristic
    const Lmid = { x: (lineL.p1.x + lineL.p2.x) / 2, y: (lineL.p1.y + lineL.p2.y) / 2 };
    const toP = { x: pointP.x - Lmid.x, y: pointP.y - Lmid.y };
    const toTest = { x: testOrig.x - Lmid.x, y: testOrig.y - Lmid.y };
    const sameSign = toP.x * toTest.x + toP.y * toTest.y;

    if (sameSign < 0) {
        // Swap: use the other arc
        const tmp = angMin;
        angMin = angMax;
        diff = (2 * Math.PI - Math.abs(diff)) * (diff > 0 ? -1 : 1);
        angMax = angMin + diff;
    }

    return { idealA, idealB, limA_orig, limB_orig, angMin, diff };
}

function drawDisk() {
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, diskR);
    gradient.addColorStop(0, 'rgba(15, 20, 40, 1)');
    gradient.addColorStop(0.7, 'rgba(10, 15, 35, 1)');
    gradient.addColorStop(0.95, 'rgba(20, 30, 60, 1)');
    gradient.addColorStop(1, 'rgba(40, 60, 120, 0.3)');
    ctx.beginPath();
    ctx.arc(cx, cy, diskR, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.shadowColor = '#4488ff';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(cx, cy, diskR, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(80, 140, 255, 0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function drawScene() {
    const info = computeParallels();

    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, diskR - 1, 0, Math.PI * 2);
    ctx.clip();

    // Draw line L (the base geodesic) - bright gold
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 8;
    drawGeodesicLine(lineL.p1, lineL.p2, '#fbbf24', 3);
    ctx.shadowBlur = 0;

    // Label L
    if (showLabels) {
        const lMid = toCanvas((lineL.p1.x + lineL.p2.x) / 2 + 0.05, (lineL.p1.y + lineL.p2.y) / 2 + 0.06);
        ctx.font = 'bold 16px sans-serif';
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('L', lMid.x, lMid.y);
    }

    // Draw ultra-parallels
    const { angMin, diff } = info;
    const nPar = numParallels;
    for (let i = 1; i < nPar; i++) {
        const frac = i / nPar;
        const ang = angMin + diff * frac;
        const farPt = { x: 0.98 * Math.cos(ang), y: 0.98 * Math.sin(ang) };
        const farOrig = mobiusInverse(farPt, pointP);

        // Color gradient: blue near limiting -> red in middle
        const distFromEdge = Math.min(frac, 1 - frac) * 2; // 0 at edges, 1 at middle
        const r = Math.floor(96 + distFromEdge * 152);
        const g = Math.floor(165 - distFromEdge * 100);
        const b = Math.floor(250 - distFromEdge * 150);
        const alpha = 0.4 + distFromEdge * 0.3;

        drawGeodesicLine(pointP, farOrig, `rgba(${r},${g},${b},${alpha})`, 1.5);
    }

    // Animated sweep line
    if (animateSweep) {
        const sweepFrac = (Math.sin(sweepAngle) + 1) / 2;
        const ang = angMin + diff * (0.05 + sweepFrac * 0.9);
        const farPt = { x: 0.98 * Math.cos(ang), y: 0.98 * Math.sin(ang) };
        const farOrig = mobiusInverse(farPt, pointP);
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 6;
        drawGeodesicLine(pointP, farOrig, 'rgba(255, 255, 255, 0.7)', 2);
        ctx.shadowBlur = 0;
    }

    // Draw limiting parallels (blue, bright)
    ctx.shadowColor = '#60a5fa';
    ctx.shadowBlur = 10;
    drawGeodesicLine(pointP, info.limA_orig, '#60a5fa', 2.5);
    drawGeodesicLine(pointP, info.limB_orig, '#60a5fa', 2.5);
    ctx.shadowBlur = 0;

    // Label limiting parallels
    if (showLabels) {
        const la = toCanvas(info.limA_orig.x * 0.6 + pointP.x * 0.4, info.limA_orig.y * 0.6 + pointP.y * 0.4);
        const lb = toCanvas(info.limB_orig.x * 0.6 + pointP.x * 0.4, info.limB_orig.y * 0.6 + pointP.y * 0.4);
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#60a5fa';
        ctx.fillText('limiting', la.x + 8, la.y - 6);
        ctx.fillText('limiting', lb.x + 8, lb.y - 6);
    }

    // Draw perpendicular from P to L
    const foot = perpFoot(pointP, lineL.p1, lineL.p2);
    drawGeodesicLine(pointP, foot, 'rgba(200, 130, 255, 0.4)', 1);

    // Foot marker
    const footC = toCanvas(foot.x, foot.y);
    ctx.beginPath();
    ctx.arc(footC.x, footC.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#c084fc';
    ctx.fill();

    // Draw angle of parallelism arc at P
    const w1 = mobiusTransform(info.limA_orig, pointP);
    const w2 = mobiusTransform(info.limB_orig, pointP);
    const a1 = Math.atan2(w1.y, w1.x);
    const a2 = Math.atan2(w2.y, w2.x);
    let aDiff = a2 - a1;
    if (aDiff > Math.PI) aDiff -= 2 * Math.PI;
    if (aDiff < -Math.PI) aDiff += 2 * Math.PI;

    const pC = toCanvas(pointP.x, pointP.y);
    ctx.beginPath();
    ctx.arc(pC.x, pC.y, 25, a1, a1 + aDiff, aDiff < 0);
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();

    // Draw point P
    ctx.shadowColor = '#ffffff';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(pC.x, pC.y, 7, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(pC.x, pC.y, 10, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    if (showLabels) {
        ctx.font = 'bold 16px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText('P', pC.x + 14, pC.y - 10);
    }

    // Update metrics
    const hDist = hyperbolicDistance(pointP, foot);
    const paraAngle = 2 * Math.atan(Math.exp(-hDist)) * 180 / Math.PI;
    document.getElementById('paraAngle').textContent = paraAngle.toFixed(2) + '\u00B0';
    document.getElementById('distPL').textContent = hDist.toFixed(3);
}

function render() {
    ctx.clearRect(0, 0, W, H);
    drawDisk();
    drawScene();
    if (animateSweep) sweepAngle += sweepSpeed;
    requestAnimationFrame(render);
}

// Dragging P
canvas.addEventListener('mousedown', (e) => {
    const d = toDisk(e.clientX, e.clientY);
    if ((d.x - pointP.x) ** 2 + (d.y - pointP.y) ** 2 < 0.003) {
        draggingP = true;
        canvas.classList.add('dragging');
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (draggingP) {
        const d = toDisk(e.clientX, e.clientY);
        if (norm2(d) < 0.92) {
            // Keep P away from L (not too close to y=0 line)
            pointP = d;
        }
    }
});

canvas.addEventListener('mouseup', () => {
    draggingP = false;
    canvas.classList.remove('dragging');
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    const d = toDisk(t.clientX, t.clientY);
    if ((d.x - pointP.x) ** 2 + (d.y - pointP.y) ** 2 < 0.005) {
        draggingP = true;
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (draggingP) {
        const t = e.touches[0];
        const d = toDisk(t.clientX, t.clientY);
        if (norm2(d) < 0.92) pointP = d;
    }
}, { passive: false });

canvas.addEventListener('touchend', () => { draggingP = false; });

// Controls
document.getElementById('numParallels').addEventListener('input', (e) => {
    numParallels = parseInt(e.target.value);
    document.getElementById('numParVal').textContent = numParallels;
});

document.getElementById('sweepSpeed').addEventListener('input', (e) => {
    sweepSpeed = parseInt(e.target.value) * 0.0001;
    document.getElementById('sweepVal').textContent = e.target.value;
});

document.getElementById('showSweep').addEventListener('change', (e) => {
    animateSweep = e.target.checked;
});

document.getElementById('showLabels').addEventListener('change', (e) => {
    showLabels = e.target.checked;
});

document.getElementById('resetBtn').addEventListener('click', () => {
    window.reset();
});

window.reset = function() {
    pointP = { x: 0, y: -0.4 };
    lineL = { p1: { x: -0.95, y: 0 }, p2: { x: 0.95, y: 0 } };
    numParallels = 9;
    sweepSpeed = 0.003;
    sweepAngle = 0;
    animateSweep = true;
    showLabels = true;
    document.getElementById('numParallels').value = 9;
    document.getElementById('numParVal').textContent = '9';
    document.getElementById('sweepSpeed').value = 30;
    document.getElementById('sweepVal').textContent = '30';
    document.getElementById('showSweep').checked = true;
    document.getElementById('showLabels').checked = true;
};

render();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
