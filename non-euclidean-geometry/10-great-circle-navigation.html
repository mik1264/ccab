<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Great Circle Navigation - Non-Euclidean Geometry</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }

.panel {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.8); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px; color: #ccd; width: 270px; max-height: calc(100vh - 40px); overflow-y: auto;
}
.panel h3 { color: #8af; margin-bottom: 12px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.panel label { display: block; margin-bottom: 4px; font-size: 0.82em; color: #99a; }
.data-row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.82em; }
.data-row .label { color: #99a; }
.data-row .value { color: #8cf; font-family: 'Courier New', monospace; }
.savings { color: #4f8 !important; font-weight: bold; }
.btn { display: inline-block; padding: 5px 10px; margin: 2px; background: rgba(138,170,255,0.12); border: 1px solid rgba(138,170,255,0.25); color: #8af; border-radius: 6px; cursor: pointer; font-size: 0.75em; transition: all 0.2s; }
.btn:hover { background: rgba(138,170,255,0.25); }
.btn.active { background: rgba(138,170,255,0.3); border-color: #8af; }
.section-label { color: #6a8; font-size: 0.78em; margin-top: 10px; margin-bottom: 6px; font-weight: bold; border-top: 1px solid rgba(138,170,255,0.1); padding-top: 8px; }
.legend { display: flex; gap: 12px; margin-top: 8px; font-size: 0.78em; }
.legend-item { display: flex; align-items: center; gap: 4px; }
.legend-dot { width: 10px; height: 3px; border-radius: 2px; }
.toggle-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
.toggle-row input { accent-color: #8af; }
.toggle-row label { margin: 0; cursor: pointer; font-size: 0.82em; }
.info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(138,170,255,0.5); font-size: 0.8em; z-index: 100; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>

<div class="panel">
    <h3>Great Circle Navigation</h3>
    <div class="section-label">Route</div>
    <div class="data-row"><span class="label">From:</span><span class="value" id="fromCity">Click map</span></div>
    <div class="data-row"><span class="label">To:</span><span class="value" id="toCity">Click map</span></div>
    <div class="data-row"><span class="label">Great Circle:</span><span class="value" id="gcDist">--</span></div>
    <div class="data-row"><span class="label">Rhumb Line:</span><span class="value" id="rlDist">--</span></div>
    <div class="data-row savings"><span class="label">Savings:</span><span class="value" id="saveDist">--</span></div>

    <div class="section-label">Preset Routes</div>
    <div>
        <span class="btn" data-route="nyc-tokyo">NYC - Tokyo</span>
        <span class="btn" data-route="london-la">London - LA</span>
        <span class="btn" data-route="sydney-santiago">Sydney - Santiago</span>
        <span class="btn" data-route="dubai-sf">Dubai - SF</span>
        <span class="btn" data-route="moscow-miami">Moscow - Miami</span>
        <span class="btn" data-route="cape-perth">Cape Town - Perth</span>
    </div>

    <div class="section-label">Options</div>
    <div class="toggle-row"><input type="checkbox" id="showPlane" checked><label for="showPlane">Animate Plane</label></div>
    <div class="toggle-row"><input type="checkbox" id="showGlobe" checked><label for="showGlobe">Show Globe Inset</label></div>

    <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#ff6644"></div>Rhumb</div>
        <div class="legend-item"><div class="legend-dot" style="background:#44ff88"></div>Great Circle</div>
    </div>
</div>

<div class="info">Click two points on the map to set a route</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
let animId;
let time = 0;

// Map projection parameters
let mapX, mapY, mapW, mapH;

// Globe inset parameters
let globeX, globeY, globeR;
let globeRotY = 0;

// Points selection
let pointA = null; // {lat, lon}
let pointB = null;
let selectingPoint = 0; // 0 = selecting A, 1 = selecting B

let showPlane = true;
let showGlobe = true;
let planeT = 0;

// Earth radius in km
const EARTH_R = 6371;

// Simplified world coastline data (lon, lat pairs for each continent outline)
// These are very simplified polygons for visual effect
const continents = [
    // North America
    [[-130,50],[-125,50],[-120,38],[-117,33],[-105,25],[-97,26],[-97,30],[-90,30],[-82,25],[-80,32],[-75,36],[-70,43],[-67,45],[-65,48],[-60,47],[-55,50],[-58,55],[-65,60],[-70,62],[-75,65],[-80,68],[-85,70],[-95,72],[-105,73],[-120,72],[-130,70],[-140,62],[-165,62],[-168,55],[-150,58],[-140,55],[-135,55],[-130,50]],
    // South America
    [[-80,10],[-75,12],[-70,12],[-60,10],[-50,5],[-45,0],[-35,-5],[-35,-10],[-38,-15],[-40,-23],[-48,-28],[-53,-33],[-58,-38],[-67,-55],[-72,-50],[-75,-45],[-72,-38],[-70,-30],[-70,-20],[-75,-15],[-80,-5],[-80,0],[-77,5],[-80,10]],
    // Europe
    [[-10,36],[-5,36],[0,38],[3,43],[0,46],[-5,48],[-3,52],[2,51],[5,52],[7,54],[10,55],[12,56],[14,55],[18,55],[22,55],[25,55],[30,60],[28,65],[25,70],[22,70],[18,68],[12,64],[8,58],[5,54],[3,52],[2,51],[5,52],[10,54],[12,56],[18,60],[25,60],[30,56],[32,50],[35,42],[30,36],[25,38],[22,40],[20,40],[15,38],[13,40],[10,44],[5,43],[3,43],[0,38],[-5,36],[-10,36]],
    // Africa
    [[-15,12],[-17,15],[-15,28],[0,35],[10,37],[12,35],[25,32],[30,31],[35,30],[40,12],[50,12],[42,0],[40,-10],[35,-25],[30,-33],[25,-34],[20,-34],[18,-30],[15,-25],[12,-15],[10,-5],[5,5],[0,5],[-5,5],[-10,8],[-15,12]],
    // Asia
    [[30,36],[35,37],[40,38],[45,40],[50,40],[55,38],[60,38],[65,40],[70,38],[75,35],[80,30],[85,28],[90,22],[95,16],[100,15],[105,10],[110,20],[115,22],[120,23],[125,30],[130,35],[135,35],[140,40],[143,45],[142,50],[140,55],[135,55],[130,48],[125,45],[120,50],[110,50],[100,52],[90,50],[80,55],[70,55],[65,55],[60,55],[55,55],[50,52],[45,48],[40,45],[35,42],[30,36]],
    // Australia
    [[115,-35],[115,-25],[120,-18],[130,-12],[140,-12],[145,-15],[150,-22],[152,-28],[150,-35],[140,-38],[130,-33],[120,-35],[115,-35]],
    // Greenland
    [[-55,60],[-45,60],[-40,65],[-20,70],[-18,76],[-20,80],[-30,82],[-40,83],[-50,82],[-55,78],[-53,70],[-55,60]],
    // Antarctica approx
    [[-180,-70],[-150,-75],[-120,-70],[-90,-75],[-60,-70],[-30,-72],[0,-70],[30,-68],[60,-70],[90,-67],[120,-68],[150,-72],[180,-70]]
];

// Cities database
const cities = {
    'nyc': { name: 'New York', lat: 40.7, lon: -74.0 },
    'tokyo': { name: 'Tokyo', lat: 35.7, lon: 139.7 },
    'london': { name: 'London', lat: 51.5, lon: -0.1 },
    'la': { name: 'Los Angeles', lat: 34.0, lon: -118.2 },
    'sydney': { name: 'Sydney', lat: -33.9, lon: 151.2 },
    'santiago': { name: 'Santiago', lat: -33.4, lon: -70.7 },
    'dubai': { name: 'Dubai', lat: 25.2, lon: 55.3 },
    'sf': { name: 'San Francisco', lat: 37.8, lon: -122.4 },
    'moscow': { name: 'Moscow', lat: 55.8, lon: 37.6 },
    'miami': { name: 'Miami', lat: 25.8, lon: -80.2 },
    'cape': { name: 'Cape Town', lat: -33.9, lon: 18.4 },
    'perth': { name: 'Perth', lat: -31.9, lon: 115.9 }
};

const routes = {
    'nyc-tokyo': ['nyc', 'tokyo'],
    'london-la': ['london', 'la'],
    'sydney-santiago': ['sydney', 'santiago'],
    'dubai-sf': ['dubai', 'sf'],
    'moscow-miami': ['moscow', 'miami'],
    'cape-perth': ['cape', 'perth']
};

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;

    // Map covers most of the screen
    mapW = W * 0.85;
    mapH = mapW * 0.5; // equirectangular aspect ratio
    if (mapH > H * 0.85) {
        mapH = H * 0.85;
        mapW = mapH * 2;
    }
    mapX = (W - mapW) / 2;
    mapY = (H - mapH) / 2;

    // Globe inset
    globeR = Math.min(W, H) * 0.12;
    globeX = mapX + 20 + globeR;
    globeY = mapY + mapH - 20 - globeR;
}
resize();
window.addEventListener('resize', resize);

// Map projection: equirectangular
function latLonToMap(lat, lon) {
    const x = mapX + ((lon + 180) / 360) * mapW;
    const y = mapY + ((90 - lat) / 180) * mapH;
    return [x, y];
}

function mapToLatLon(mx, my) {
    const lon = ((mx - mapX) / mapW) * 360 - 180;
    const lat = 90 - ((my - mapY) / mapH) * 180;
    return { lat, lon };
}

// Haversine distance
function haversineDistance(lat1, lon1, lat2, lon2) {
    const toRad = Math.PI / 180;
    const dLat = (lat2 - lat1) * toRad;
    const dLon = (lon2 - lon1) * toRad;
    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return EARTH_R * c;
}

// Rhumb line distance
function rhumbDistance(lat1, lon1, lat2, lon2) {
    const toRad = Math.PI / 180;
    const phi1 = lat1 * toRad, phi2 = lat2 * toRad;
    const dPhi = phi2 - phi1;
    let dLon = (lon2 - lon1) * toRad;

    // Ensure shortest path
    if (Math.abs(dLon) > Math.PI) {
        dLon = dLon > 0 ? -(2*Math.PI - dLon) : (2*Math.PI + dLon);
    }

    const dPsi = Math.log(Math.tan(Math.PI/4 + phi2/2) / Math.tan(Math.PI/4 + phi1/2));
    const q = Math.abs(dPsi) > 1e-12 ? dPhi/dPsi : Math.cos(phi1);

    const dist = Math.sqrt(dPhi*dPhi + q*q*dLon*dLon) * EARTH_R;
    return dist;
}

// Great circle intermediate point (slerp on sphere)
function greatCirclePoint(lat1, lon1, lat2, lon2, t) {
    const toRad = Math.PI / 180;
    const p1 = lat1*toRad, l1 = lon1*toRad;
    const p2 = lat2*toRad, l2 = lon2*toRad;

    const x1 = Math.cos(p1)*Math.cos(l1), y1 = Math.cos(p1)*Math.sin(l1), z1 = Math.sin(p1);
    const x2 = Math.cos(p2)*Math.cos(l2), y2 = Math.cos(p2)*Math.sin(l2), z2 = Math.sin(p2);

    const dot = x1*x2 + y1*y2 + z1*z2;
    const omega = Math.acos(Math.max(-1, Math.min(1, dot)));

    if (Math.abs(omega) < 1e-6) return { lat: lat1, lon: lon1 };

    const sinO = Math.sin(omega);
    const a = Math.sin((1-t)*omega) / sinO;
    const b = Math.sin(t*omega) / sinO;

    const x = a*x1 + b*x2;
    const y = a*y1 + b*y2;
    const z = a*z1 + b*z2;

    const lat = Math.atan2(z, Math.sqrt(x*x+y*y)) / toRad;
    const lon = Math.atan2(y, x) / toRad;
    return { lat, lon };
}

// Globe projection
function latLonToGlobe(lat, lon) {
    const toRad = Math.PI / 180;
    const p = lat * toRad, l = (lon * toRad) - globeRotY;

    const x = Math.cos(p) * Math.sin(l);
    const y = Math.sin(p);
    const z = Math.cos(p) * Math.cos(l);

    return { x: globeX + x * globeR, y: globeY - y * globeR, visible: z > 0 };
}

function drawMap() {
    // Map background
    ctx.fillStyle = '#0d1525';
    ctx.fillRect(mapX, mapY, mapW, mapH);

    // Grid lines
    ctx.strokeStyle = 'rgba(138,170,255,0.06)';
    ctx.lineWidth = 0.5;
    for (let lon = -180; lon <= 180; lon += 30) {
        const [x] = latLonToMap(0, lon);
        ctx.beginPath();
        ctx.moveTo(x, mapY);
        ctx.lineTo(x, mapY + mapH);
        ctx.stroke();
    }
    for (let lat = -90; lat <= 90; lat += 30) {
        const [, y] = latLonToMap(lat, 0);
        ctx.beginPath();
        ctx.moveTo(mapX, y);
        ctx.lineTo(mapX + mapW, y);
        ctx.stroke();
    }

    // Draw continents
    ctx.fillStyle = 'rgba(60, 80, 50, 0.4)';
    ctx.strokeStyle = 'rgba(100, 140, 80, 0.5)';
    ctx.lineWidth = 1;

    for (const cont of continents) {
        ctx.beginPath();
        for (let i = 0; i < cont.length; i++) {
            const [x, y] = latLonToMap(cont[i][1], cont[i][0]);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    // Map border
    ctx.strokeStyle = 'rgba(138,170,255,0.2)';
    ctx.lineWidth = 1;
    ctx.strokeRect(mapX, mapY, mapW, mapH);
}

function drawRoutes() {
    if (!pointA || !pointB) return;

    // Draw rhumb line (straight on Mercator, approximately straight on equirectangular)
    ctx.strokeStyle = '#ff6644';
    ctx.lineWidth = 2.5;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    const [ax, ay] = latLonToMap(pointA.lat, pointA.lon);
    const [bx, by] = latLonToMap(pointB.lat, pointB.lon);

    // Handle wrapping
    let dLon = pointB.lon - pointA.lon;
    if (Math.abs(dLon) > 180) {
        // Draw in two segments
        if (dLon > 0) dLon -= 360; else dLon += 360;
        const midLat = pointA.lat + (pointB.lat - pointA.lat) * (-pointA.lon / (dLon)) || pointA.lat;
        // Just draw straight for simplicity
    }

    ctx.moveTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.stroke();
    ctx.setLineDash([]);

    // Label
    const rmx = (ax+bx)/2, rmy = (ay+by)/2 + 15;
    ctx.fillStyle = 'rgba(255,100,70,0.6)';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Rhumb Line', rmx, rmy);

    // Draw great circle
    ctx.strokeStyle = '#44ff88';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#44ff88';
    ctx.shadowBlur = 6;
    ctx.beginPath();

    const steps = 100;
    let prevX = null, prevY = null;
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const pt = greatCirclePoint(pointA.lat, pointA.lon, pointB.lat, pointB.lon, t);
        const [px, py] = latLonToMap(pt.lat, pt.lon);

        if (prevX !== null) {
            // Check for wrapping (large jump in x)
            if (Math.abs(px - prevX) > mapW * 0.5) {
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(px, py);
            } else {
                ctx.lineTo(px, py);
            }
        } else {
            ctx.moveTo(px, py);
        }
        prevX = px;
        prevY = py;
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Great circle label at peak
    const peakPt = greatCirclePoint(pointA.lat, pointA.lon, pointB.lat, pointB.lon, 0.5);
    const [plx, ply] = latLonToMap(peakPt.lat, peakPt.lon);
    ctx.fillStyle = 'rgba(68,255,136,0.7)';
    ctx.fillText('Great Circle (shortest)', plx, ply - 10);
    ctx.textAlign = 'left';

    // Draw points
    drawCityMarker(pointA.lat, pointA.lon, pointA.name || 'A', '#ff8866');
    drawCityMarker(pointB.lat, pointB.lon, pointB.name || 'B', '#66aaff');

    // Animate plane
    if (showPlane) {
        planeT += 0.003;
        if (planeT > 1) planeT = 0;
        const planePt = greatCirclePoint(pointA.lat, pointA.lon, pointB.lat, pointB.lon, planeT);
        const [ppx, ppy] = latLonToMap(planePt.lat, planePt.lon);

        // Plane direction
        const nextPt = greatCirclePoint(pointA.lat, pointA.lon, pointB.lat, pointB.lon, Math.min(1, planeT + 0.02));
        const [npx, npy] = latLonToMap(nextPt.lat, nextPt.lon);
        const angle = Math.atan2(npy - ppy, npx - ppx);

        // Draw plane icon
        ctx.save();
        ctx.translate(ppx, ppy);
        ctx.rotate(angle);

        // Glow
        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
        glow.addColorStop(0, 'rgba(255,255,255,0.5)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();

        // Simple plane shape
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -5);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-5, 5);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    // Update info
    const gcDist = haversineDistance(pointA.lat, pointA.lon, pointB.lat, pointB.lon);
    const rlDist = rhumbDistance(pointA.lat, pointA.lon, pointB.lat, pointB.lon);
    const savings = rlDist - gcDist;
    const savePct = (savings / rlDist * 100);

    document.getElementById('fromCity').textContent = pointA.name || `${pointA.lat.toFixed(1)}, ${pointA.lon.toFixed(1)}`;
    document.getElementById('toCity').textContent = pointB.name || `${pointB.lat.toFixed(1)}, ${pointB.lon.toFixed(1)}`;
    document.getElementById('gcDist').textContent = Math.round(gcDist) + ' km';
    document.getElementById('rlDist').textContent = Math.round(rlDist) + ' km';
    document.getElementById('saveDist').textContent = Math.round(savings) + ' km (' + savePct.toFixed(1) + '%)';
}

function drawCityMarker(lat, lon, name, color) {
    const [x, y] = latLonToMap(lat, lon);

    const glow = ctx.createRadialGradient(x, y, 0, x, y, 12);
    glow.addColorStop(0, color);
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x, y, 12, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = color;
    ctx.font = 'bold 12px "Segoe UI", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(name, x + 10, y - 8);
}

function drawGlobe() {
    if (!showGlobe) return;

    // Background
    ctx.fillStyle = 'rgba(10, 14, 26, 0.85)';
    ctx.beginPath();
    ctx.arc(globeX, globeY, globeR + 5, 0, Math.PI*2);
    ctx.fill();

    // Globe circle
    ctx.strokeStyle = 'rgba(138,170,255,0.3)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(globeX, globeY, globeR, 0, Math.PI*2);
    ctx.stroke();

    // Shading
    const grad = ctx.createRadialGradient(globeX - globeR*0.2, globeY - globeR*0.2, 0, globeX, globeY, globeR);
    grad.addColorStop(0, 'rgba(40,60,80,0.1)');
    grad.addColorStop(1, 'rgba(10,14,26,0.2)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(globeX, globeY, globeR, 0, Math.PI*2);
    ctx.fill();

    // Auto-rotate globe to center on midpoint of route
    if (pointA && pointB) {
        const midPt = greatCirclePoint(pointA.lat, pointA.lon, pointB.lat, pointB.lon, 0.5);
        globeRotY = midPt.lon * Math.PI / 180;
    }

    // Clip to globe
    ctx.save();
    ctx.beginPath();
    ctx.arc(globeX, globeY, globeR, 0, Math.PI*2);
    ctx.clip();

    // Draw simplified continents on globe
    ctx.fillStyle = 'rgba(60, 80, 50, 0.5)';
    ctx.strokeStyle = 'rgba(100, 140, 80, 0.4)';
    ctx.lineWidth = 0.5;

    for (const cont of continents) {
        ctx.beginPath();
        let started = false;
        let anyVisible = false;
        for (let i = 0; i < cont.length; i++) {
            const proj = latLonToGlobe(cont[i][1], cont[i][0]);
            if (proj.visible) {
                anyVisible = true;
                if (!started) { ctx.moveTo(proj.x, proj.y); started = true; }
                else ctx.lineTo(proj.x, proj.y);
            }
        }
        if (anyVisible) {
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }

    // Draw great circle on globe (this appears STRAIGHT!)
    if (pointA && pointB) {
        ctx.strokeStyle = '#44ff88';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let started = false;
        for (let i = 0; i <= 80; i++) {
            const t = i / 80;
            const pt = greatCirclePoint(pointA.lat, pointA.lon, pointB.lat, pointB.lon, t);
            const proj = latLonToGlobe(pt.lat, pt.lon);
            if (proj.visible) {
                if (!started) { ctx.moveTo(proj.x, proj.y); started = true; }
                else ctx.lineTo(proj.x, proj.y);
            } else {
                if (started) ctx.stroke();
                ctx.beginPath();
                started = false;
            }
        }
        ctx.stroke();

        // Points on globe
        const projA = latLonToGlobe(pointA.lat, pointA.lon);
        const projB = latLonToGlobe(pointB.lat, pointB.lon);
        if (projA.visible) {
            ctx.fillStyle = '#ff8866';
            ctx.beginPath();
            ctx.arc(projA.x, projA.y, 3, 0, Math.PI*2);
            ctx.fill();
        }
        if (projB.visible) {
            ctx.fillStyle = '#66aaff';
            ctx.beginPath();
            ctx.arc(projB.x, projB.y, 3, 0, Math.PI*2);
            ctx.fill();
        }
    }

    ctx.restore();

    // Globe label
    ctx.fillStyle = 'rgba(138,170,255,0.4)';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Great circle is straight', globeX, globeY + globeR + 14);
    ctx.fillText('on the globe!', globeX, globeY + globeR + 26);
    ctx.textAlign = 'left';
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    drawMap();
    drawRoutes();
    drawGlobe();

    // Title
    ctx.fillStyle = 'rgba(138,170,255,0.3)';
    ctx.font = '13px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Why flights curve on flat maps: the Great Circle is the shortest path on a sphere', W/2, mapY - 10);
    ctx.textAlign = 'left';
}

function animate() {
    time += 0.016;
    draw();
    animId = requestAnimationFrame(animate);
}

// Click to set points
canvas.addEventListener('click', (e) => {
    const mx = e.clientX, my = e.clientY;
    if (mx >= mapX && mx <= mapX + mapW && my >= mapY && my <= mapY + mapH) {
        const ll = mapToLatLon(mx, my);
        if (selectingPoint === 0) {
            pointA = { lat: ll.lat, lon: ll.lon };
            selectingPoint = 1;
        } else {
            pointB = { lat: ll.lat, lon: ll.lon };
            selectingPoint = 0;
            planeT = 0;
        }
    }
});

// Preset routes
document.querySelectorAll('.btn[data-route]').forEach(btn => {
    btn.addEventListener('click', function() {
        const [fromKey, toKey] = routes[this.dataset.route];
        const from = cities[fromKey];
        const to = cities[toKey];
        pointA = { lat: from.lat, lon: from.lon, name: from.name };
        pointB = { lat: to.lat, lon: to.lon, name: to.name };
        planeT = 0;
        selectingPoint = 0;

        document.querySelectorAll('.btn[data-route]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
    });
});

document.getElementById('showPlane').addEventListener('change', function() { showPlane = this.checked; });
document.getElementById('showGlobe').addEventListener('change', function() { showGlobe = this.checked; });

window.reset = function() {
    pointA = null;
    pointB = null;
    selectingPoint = 0;
    planeT = 0;
    time = 0;
    document.getElementById('fromCity').textContent = 'Click map';
    document.getElementById('toCity').textContent = 'Click map';
    document.getElementById('gcDist').textContent = '--';
    document.getElementById('rlDist').textContent = '--';
    document.getElementById('saveDist').textContent = '--';
};

// Start with NYC-Tokyo preset
pointA = { lat: cities.nyc.lat, lon: cities.nyc.lon, name: cities.nyc.name };
pointB = { lat: cities.tokyo.lat, lon: cities.tokyo.lon, name: cities.tokyo.name };

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>