<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stereographic Projection</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,30,0.75);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 12px;
  padding: 18px; color: #cde; z-index: 100; min-width: 220px;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1em; }
label { display: block; margin-top: 10px; font-size: 0.8em; color: #89a; }
input[type=range] { width: 100%; margin-top: 4px; accent-color: #8af; }
.btn {
  display: block; width: 100%; margin: 4px 0; padding: 7px 12px;
  background: rgba(138,170,255,0.1); border: 1px solid rgba(138,170,255,0.25);
  border-radius: 6px; color: #cde; cursor: pointer; font-size: 0.85em; text-align: left;
}
.btn:hover { background: rgba(138,170,255,0.2); }
.btn.active { background: rgba(138,170,255,0.3); border-color: #8af; color: #fff; }
.info-box {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(10,14,30,0.8); backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 10px;
  padding: 12px 22px; color: #89a; font-size: 0.8em; text-align: center; z-index: 100;
  max-width: 620px; line-height: 1.4;
}
.info-box strong { color: #8af; }
.divider { width: 2px; background: rgba(138,170,255,0.1); position: fixed; top: 0; bottom: 0; left: 50%; z-index: 50; }
.panel-label {
  position: fixed; top: auto; bottom: 55px; z-index: 100; color: rgba(138,170,255,0.4);
  font-size: 0.75em; text-transform: uppercase; letter-spacing: 2px;
}
#lbl-sphere { left: 25%; transform: translateX(-50%); }
#lbl-plane { left: 75%; transform: translateX(-50%); }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div class="divider"></div>
<span class="panel-label" id="lbl-sphere">3D Sphere</span>
<span class="panel-label" id="lbl-plane">Projected Plane</span>
<div id="controls">
  <h3>Stereographic Projection</h3>
  <button class="btn active" data-pattern="grid">Lat/Lon Grid</button>
  <button class="btn" data-pattern="circles">Circles</button>
  <button class="btn" data-pattern="checker">Checkerboard</button>
  <label>Sphere Rotation: <span id="rotVal">0</span>&deg;</label>
  <input type="range" id="rotSlider" min="-180" max="180" value="0" step="1">
  <label>Sphere Tilt: <span id="tiltVal">25</span>&deg;</label>
  <input type="range" id="tiltSlider" min="-60" max="60" value="25" step="1">
  <label style="margin-top:8px">
    <input type="checkbox" id="showRays"> Show projection rays
  </label>
  <label>
    <input type="checkbox" id="autoRotate" checked> Auto-rotate
  </label>
</div>
<div class="info-box">
  <strong>Stereographic projection</strong> maps a sphere to a plane from a single pole.
  It is <strong>conformal</strong> (preserves angles) and maps circles to circles &mdash; the only projection with both properties.
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
}
resize();
window.addEventListener('resize', resize);

let sphereRotY = 0, sphereTilt = 25;
let autoRot = true, showRays = false;
let currentPattern = 'grid';
let dragging = false, lastMX, lastMY;
let time = 0;

// Drag on left half rotates sphere
canvas.addEventListener('mousedown', e => {
  if (e.clientX < W/2) { dragging = true; lastMX = e.clientX; lastMY = e.clientY; }
});
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  sphereRotY += (e.clientX - lastMX) * 0.3;
  sphereTilt += (e.clientY - lastMY) * 0.3;
  sphereTilt = Math.max(-60, Math.min(60, sphereTilt));
  document.getElementById('rotSlider').value = Math.round(sphereRotY % 360);
  document.getElementById('rotVal').textContent = Math.round(sphereRotY % 360);
  document.getElementById('tiltSlider').value = Math.round(sphereTilt);
  document.getElementById('tiltVal').textContent = Math.round(sphereTilt);
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => {
  if (e.touches[0].clientX < W/2) { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; e.preventDefault(); }
}, {passive:false});
canvas.addEventListener('touchmove', e => {
  if (!dragging) return;
  sphereRotY += (e.touches[0].clientX - lastMX) * 0.3;
  sphereTilt += (e.touches[0].clientY - lastMY) * 0.3;
  sphereTilt = Math.max(-60, Math.min(60, sphereTilt));
  lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', () => dragging = false);

function rotX3(v, a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c];
}
function rotY3(v, a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [v[0]*c + v[2]*s, v[1], -v[0]*s + v[2]*c];
}

// Stereographic projection: project point on unit sphere from north pole (0,1,0) onto y=0 plane
function stereoProject(p) {
  // p = [x, y, z] on unit sphere, pole at [0, 1, 0]
  const denom = 1 - p[1];
  if (Math.abs(denom) < 0.001) return null; // near pole
  return [p[0] / denom, p[2] / denom];
}

function spherePoint(theta, phi) {
  return [Math.sin(theta)*Math.cos(phi), Math.cos(theta), Math.sin(theta)*Math.sin(phi)];
}

function draw(ts) {
  time += 1/60;
  if (autoRot && !dragging) sphereRotY += 0.3;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Subtle background difference for the two halves
  ctx.fillStyle = 'rgba(15,20,45,0.3)';
  ctx.fillRect(0, 0, W/2, H);

  const leftCx = W * 0.25, leftCy = H * 0.45;
  const rightCx = W * 0.75, rightCy = H * 0.45;
  const sR = Math.min(W * 0.2, H * 0.35); // sphere radius on screen
  const pScale = sR * 0.35; // plane scale factor

  const rotYR = sphereRotY * Math.PI / 180;
  const tiltR = sphereTilt * Math.PI / 180;

  // Generate grid lines on sphere
  const lines = [];
  const gridStep = 15;

  if (currentPattern === 'grid' || currentPattern === 'checker') {
    // Latitude lines
    for (let lat = -75; lat <= 75; lat += gridStep) {
      const theta = (90 - lat) * Math.PI / 180;
      const pts = [];
      for (let lon = 0; lon <= 360; lon += 5) {
        const phi = lon * Math.PI / 180;
        pts.push(spherePoint(theta, phi));
      }
      lines.push({ pts, color: lat === 0 ? 'rgba(138,170,255,0.5)' : 'rgba(80,140,220,0.35)' });
    }
    // Longitude lines
    for (let lon = 0; lon < 360; lon += gridStep) {
      const phi = lon * Math.PI / 180;
      const pts = [];
      for (let lat = -85; lat <= 85; lat += 5) {
        const theta = (90 - lat) * Math.PI / 180;
        pts.push(spherePoint(theta, phi));
      }
      lines.push({ pts, color: lon === 0 ? 'rgba(138,170,255,0.5)' : 'rgba(80,140,220,0.35)' });
    }
  }

  if (currentPattern === 'circles') {
    // Several small circles at various positions
    const circleConfigs = [
      { cTheta: 60, cPhi: 0, r: 20 },
      { cTheta: 60, cPhi: 90, r: 20 },
      { cTheta: 60, cPhi: 180, r: 20 },
      { cTheta: 60, cPhi: 270, r: 20 },
      { cTheta: 120, cPhi: 45, r: 15 },
      { cTheta: 120, cPhi: 135, r: 15 },
      { cTheta: 120, cPhi: 225, r: 15 },
      { cTheta: 120, cPhi: 315, r: 15 },
      { cTheta: 90, cPhi: 0, r: 25 },
      { cTheta: 30, cPhi: 0, r: 12 },
    ];
    const colors = ['rgba(255,120,120,0.6)','rgba(120,255,150,0.6)','rgba(120,150,255,0.6)','rgba(255,200,80,0.6)',
                    'rgba(200,120,255,0.6)','rgba(80,220,220,0.6)','rgba(255,150,200,0.6)','rgba(150,255,100,0.6)',
                    'rgba(255,180,100,0.6)','rgba(100,200,255,0.6)'];
    circleConfigs.forEach((cc, ci) => {
      const pts = [];
      const cThetaR = cc.cTheta * Math.PI / 180;
      const cPhiR = cc.cPhi * Math.PI / 180;
      const rR = cc.r * Math.PI / 180;
      for (let a = 0; a <= 360; a += 5) {
        const aR = a * Math.PI / 180;
        // Point on sphere at angular distance rR from center
        const lat = (90 - cc.cTheta) + cc.r * Math.cos(aR);
        const lon = cc.cPhi + cc.r * Math.sin(aR) / Math.max(0.1, Math.sin(cThetaR));
        const theta = (90 - lat) * Math.PI / 180;
        const phi = lon * Math.PI / 180;
        pts.push(spherePoint(theta, phi));
      }
      lines.push({ pts, color: colors[ci % colors.length], thick: 2 });
    });
  }

  // === LEFT SIDE: 3D Sphere ===
  // Draw sphere outline
  ctx.strokeStyle = 'rgba(138,170,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(leftCx, leftCy, sR, 0, Math.PI*2);
  ctx.stroke();

  // Sphere shading
  const sg = ctx.createRadialGradient(leftCx - sR*0.25, leftCy - sR*0.25, sR*0.1, leftCx, leftCy, sR);
  sg.addColorStop(0, 'rgba(40,60,120,0.1)');
  sg.addColorStop(1, 'rgba(5,8,20,0.2)');
  ctx.fillStyle = sg;
  ctx.beginPath();
  ctx.arc(leftCx, leftCy, sR, 0, Math.PI*2);
  ctx.fill();

  // North pole marker
  let pole = [0, 1, 0];
  pole = rotX3(pole, tiltR);
  pole = rotY3(pole, rotYR);
  if (pole[2] > -0.1) {
    const px = leftCx + pole[0] * sR;
    const py = leftCy - pole[1] * sR;
    ctx.fillStyle = 'rgba(255,200,60,0.9)';
    ctx.beginPath();
    ctx.arc(px, py, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,200,60,0.7)';
    ctx.font = '11px "Segoe UI", Arial';
    ctx.fillText('N (projection pole)', px + 8, py - 4);
  }

  // Draw lines on sphere (and collect projection data)
  const projectedLines = [];

  for (const line of lines) {
    // 3D sphere side
    ctx.strokeStyle = line.color;
    ctx.lineWidth = line.thick || 1;
    ctx.beginPath();
    let started = false;

    const projPts = [];
    const rayData = [];

    for (const p of line.pts) {
      let tp = rotX3(p, tiltR);
      tp = rotY3(tp, rotYR);

      if (tp[2] > -0.05) {
        const sx = leftCx + tp[0] * sR;
        const sy = leftCy - tp[1] * sR;
        if (!started) { ctx.moveTo(sx, sy); started = true; }
        else ctx.lineTo(sx, sy);
      } else {
        started = false;
      }

      // Stereographic projection of rotated point
      const sp = stereoProject(tp);
      if (sp && Math.abs(sp[0]) < 8 && Math.abs(sp[1]) < 8) {
        projPts.push(sp);
        if (showRays) {
          rayData.push({ sphere: tp, proj: sp });
        }
      } else {
        projPts.push(null);
      }
    }
    ctx.stroke();

    projectedLines.push({ pts: projPts, color: line.color, thick: line.thick, rayData });
  }

  // Draw projection rays (from pole through sphere to plane)
  if (showRays) {
    ctx.strokeStyle = 'rgba(255,200,60,0.08)';
    ctx.lineWidth = 0.5;
    let rayCount = 0;
    for (const pl of projectedLines) {
      for (const rd of pl.rayData) {
        if (rayCount++ % 3 !== 0) continue; // thin out rays
        const poleSx = leftCx + pole[0] * sR;
        const poleSy = leftCy - pole[1] * sR;
        // Point on sphere
        const spSx = leftCx + rd.sphere[0] * sR;
        const spSy = leftCy - rd.sphere[1] * sR;
        // Point on plane (show at bottom of sphere area)
        const plSx = rightCx + rd.proj[0] * pScale;
        const plSy = rightCy - rd.proj[1] * pScale;

        ctx.beginPath();
        ctx.moveTo(poleSx, poleSy);
        ctx.lineTo(spSx, spSy);
        ctx.stroke();
      }
    }
  }

  // === RIGHT SIDE: Projected Plane ===
  // Draw plane boundary circle (equator projects to unit circle)
  ctx.strokeStyle = 'rgba(138,170,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(rightCx, rightCy, pScale, 0, Math.PI*2);
  ctx.stroke();

  // A larger reference circle
  ctx.strokeStyle = 'rgba(138,170,255,0.06)';
  ctx.beginPath();
  ctx.arc(rightCx, rightCy, pScale * 3, 0, Math.PI*2);
  ctx.stroke();

  // Draw projected lines
  for (const pl of projectedLines) {
    ctx.strokeStyle = pl.color;
    ctx.lineWidth = pl.thick || 1;
    ctx.beginPath();
    let started = false;
    for (const sp of pl.pts) {
      if (!sp) { started = false; continue; }
      const sx = rightCx + sp[0] * pScale;
      const sy = rightCy - sp[1] * pScale;
      // Clip to reasonable area
      if (Math.abs(sx - rightCx) > W * 0.24 || Math.abs(sy - rightCy) > H * 0.44) {
        started = false; continue;
      }
      if (!started) { ctx.moveTo(sx, sy); started = true; }
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
  }

  // Center dot on plane
  ctx.fillStyle = 'rgba(138,170,255,0.4)';
  ctx.beginPath();
  ctx.arc(rightCx, rightCy, 3, 0, Math.PI*2);
  ctx.fill();

  // Labels
  ctx.fillStyle = 'rgba(138,170,255,0.3)';
  ctx.font = '11px "Segoe UI", Arial';
  ctx.fillText('Equator circle', rightCx + pScale + 6, rightCy + 4);

  requestAnimationFrame(draw);
}

// Controls
document.querySelectorAll('.btn[data-pattern]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.btn[data-pattern]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentPattern = btn.dataset.pattern;
  });
});

document.getElementById('rotSlider').addEventListener('input', function() {
  sphereRotY = parseInt(this.value);
  document.getElementById('rotVal').textContent = this.value;
});

document.getElementById('tiltSlider').addEventListener('input', function() {
  sphereTilt = parseInt(this.value);
  document.getElementById('tiltVal').textContent = this.value;
});

document.getElementById('showRays').addEventListener('change', function() {
  showRays = this.checked;
});

document.getElementById('autoRotate').addEventListener('change', function() {
  autoRot = this.checked;
});

window.reset = function() {
  sphereRotY = 0; sphereTilt = 25; autoRot = true; showRays = false;
  currentPattern = 'grid'; time = 0;
  document.getElementById('rotSlider').value = 0;
  document.getElementById('rotVal').textContent = '0';
  document.getElementById('tiltSlider').value = 25;
  document.getElementById('tiltVal').textContent = '25';
  document.getElementById('showRays').checked = false;
  document.getElementById('autoRotate').checked = true;
  document.querySelectorAll('.btn[data-pattern]').forEach(b => b.classList.remove('active'));
  document.querySelector('[data-pattern="grid"]').classList.add('active');
};

requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
