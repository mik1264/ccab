<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tesseract Rotation</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; cursor: crosshair; }
    #controls {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: rgba(10, 14, 30, 0.85);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 160, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        color: #c8d8f0;
        min-width: 270px;
        max-height: calc(100vh - 60px);
        overflow-y: auto;
    }
    #controls h3 { color: #8af; margin-bottom: 12px; font-size: 1.1em; }
    .control-group { margin: 8px 0; }
    .control-group label { display: block; font-size: 0.82em; color: #8a9ab0; margin-bottom: 3px; }
    .control-group input[type="range"] { width: 100%; accent-color: #8af; }
    .control-group .value { float: right; color: #adf; font-family: monospace; font-size: 0.82em; }
    .btn {
        background: rgba(100, 160, 255, 0.15);
        border: 1px solid rgba(100, 160, 255, 0.3);
        color: #8af; padding: 6px 14px; border-radius: 6px;
        cursor: pointer; font-size: 0.82em; transition: all 0.2s;
    }
    .btn:hover { background: rgba(100, 160, 255, 0.3); }
    .btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px; }
    label.check { display: flex; align-items: center; gap: 8px; margin: 5px 0; font-size: 0.82em; cursor: pointer; color: #8a9ab0; }
    input[type="checkbox"] { accent-color: #8af; }
    .section-label { color: #6a8ac0; font-size: 0.75em; text-transform: uppercase; letter-spacing: 1px; margin-top: 12px; margin-bottom: 4px; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>

<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Tesseract Rotation</h3>
    <div class="section-label">4D Rotation Planes</div>
    <div class="control-group">
        <label>XW Plane <span id="xwVal" class="value">0.50</span></label>
        <input type="range" id="xwSpeed" min="0" max="2" step="0.05" value="0.5">
    </div>
    <div class="control-group">
        <label>YZ Plane <span id="yzVal" class="value">0.30</span></label>
        <input type="range" id="yzSpeed" min="0" max="2" step="0.05" value="0.3">
    </div>
    <div class="control-group">
        <label>XY Plane <span id="xyVal" class="value">0.00</span></label>
        <input type="range" id="xySpeed" min="0" max="2" step="0.05" value="0">
    </div>
    <div class="control-group">
        <label>ZW Plane <span id="zwVal" class="value">0.00</span></label>
        <input type="range" id="zwSpeed" min="0" max="2" step="0.05" value="0">
    </div>
    <div class="section-label">Projection</div>
    <div class="control-group">
        <label>4D Distance <span id="distVal" class="value">3.0</span></label>
        <input type="range" id="dist4d" min="1.5" max="6" step="0.1" value="3">
    </div>
    <div class="control-group">
        <label>3D FOV <span id="fovVal" class="value">400</span></label>
        <input type="range" id="fov3d" min="150" max="800" step="10" value="400">
    </div>
    <div class="section-label">Display</div>
    <label class="check"><input type="checkbox" id="showFaces"> Show colored faces</label>
    <label class="check"><input type="checkbox" id="showGlow" checked> Vertex glow</label>
    <div class="btn-row">
        <button class="btn" id="resetBtn">Reset</button>
        <button class="btn" id="presetBtn">Classic Morph</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

// Sliders
const sliders = {
    xw: document.getElementById('xwSpeed'),
    yz: document.getElementById('yzSpeed'),
    xy: document.getElementById('xySpeed'),
    zw: document.getElementById('zwSpeed'),
    dist: document.getElementById('dist4d'),
    fov: document.getElementById('fov3d')
};

function updateLabels() {
    document.getElementById('xwVal').textContent = parseFloat(sliders.xw.value).toFixed(2);
    document.getElementById('yzVal').textContent = parseFloat(sliders.yz.value).toFixed(2);
    document.getElementById('xyVal').textContent = parseFloat(sliders.xy.value).toFixed(2);
    document.getElementById('zwVal').textContent = parseFloat(sliders.zw.value).toFixed(2);
    document.getElementById('distVal').textContent = parseFloat(sliders.dist.value).toFixed(1);
    document.getElementById('fovVal').textContent = sliders.fov.value;
}
Object.values(sliders).forEach(s => s.oninput = updateLabels);

const showFacesCheck = document.getElementById('showFaces');
const showGlowCheck = document.getElementById('showGlow');

// Tesseract: 16 vertices
const vertices4D = [];
for (let i = 0; i < 16; i++) {
    vertices4D.push([
        (i & 1) ? 1 : -1,
        (i & 2) ? 1 : -1,
        (i & 4) ? 1 : -1,
        (i & 8) ? 1 : -1
    ]);
}

// 32 edges: connect vertices differing in exactly 1 coordinate
const edges = [];
for (let i = 0; i < 16; i++) {
    for (let j = i + 1; j < 16; j++) {
        let diff = 0;
        for (let k = 0; k < 4; k++) {
            if (vertices4D[i][k] !== vertices4D[j][k]) diff++;
        }
        if (diff === 1) edges.push([i, j]);
    }
}

// 24 faces (squares): groups of 4 vertices forming a face
const faces = [];
for (let i = 0; i < 16; i++) {
    for (let j = i + 1; j < 16; j++) {
        for (let k = j + 1; k < 16; k++) {
            for (let l = k + 1; l < 16; l++) {
                const quad = [i, j, k, l];
                // Check if they form a face: each pair differs in at most 2 coords, and they share 2 coords
                let isface = true;
                let fixedCoords = [];
                for (let c = 0; c < 4; c++) {
                    const vals = new Set(quad.map(vi => vertices4D[vi][c]));
                    if (vals.size === 1) fixedCoords.push(c);
                }
                if (fixedCoords.length === 2) {
                    // Verify all 4 combinations of free coords exist
                    const freeCoords = [0,1,2,3].filter(c => !fixedCoords.includes(c));
                    const combos = new Set();
                    for (const vi of quad) {
                        combos.add(vertices4D[vi][freeCoords[0]] + ',' + vertices4D[vi][freeCoords[1]]);
                    }
                    if (combos.size === 4) faces.push(quad);
                }
            }
        }
    }
}

// Edge colors: categorize by which dimension differs
function edgeColor(i, j) {
    for (let k = 0; k < 4; k++) {
        if (vertices4D[i][k] !== vertices4D[j][k]) {
            const colors = ['#ff6688', '#66ff88', '#6688ff', '#ffcc44'];
            return colors[k];
        }
    }
    return '#fff';
}

// 4D rotation
function rotate4D(v, angles) {
    let [x, y, z, w] = v;
    // XW rotation
    if (angles.xw) {
        const c = Math.cos(angles.xw), s = Math.sin(angles.xw);
        const nx = x * c - w * s, nw = x * s + w * c;
        x = nx; w = nw;
    }
    // YZ rotation
    if (angles.yz) {
        const c = Math.cos(angles.yz), s = Math.sin(angles.yz);
        const ny = y * c - z * s, nz = y * s + z * c;
        y = ny; z = nz;
    }
    // XY rotation
    if (angles.xy) {
        const c = Math.cos(angles.xy), s = Math.sin(angles.xy);
        const nx = x * c - y * s, ny = x * s + y * c;
        x = nx; y = ny;
    }
    // ZW rotation
    if (angles.zw) {
        const c = Math.cos(angles.zw), s = Math.sin(angles.zw);
        const nz = z * c - w * s, nw = z * s + w * c;
        z = nz; w = nw;
    }
    return [x, y, z, w];
}

// Project 4D -> 2D
function projectVertex(v4, dist4d, fov) {
    const [x, y, z, w] = v4;
    const s4 = dist4d / (dist4d + w);
    const x3 = x * s4, y3 = y * s4, z3 = z * s4;
    const viewDist = 5;
    const s3 = fov / (viewDist + z3);
    return { x: W / 2 + x3 * s3, y: H / 2 + y3 * s3, z: z3, w: w, s4: s4 };
}

let angles = { xw: 0, yz: 0, xy: 0, zw: 0 };
let time = 0;
let lastTime = performance.now();

// 3D rotation from mouse
let rotA = 0.3, rotB = 0;
let dragging = false, lastMX = 0, lastMY = 0;
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    rotB += (e.clientX - lastMX) * 0.005;
    rotA += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, {passive:false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!dragging) return; rotB += (e.touches[0].clientX - lastMX)*0.005; rotA += (e.touches[0].clientY - lastMY)*0.005; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, {passive:false});
canvas.addEventListener('touchend', () => dragging = false);

function rotate3D(x, y, z) {
    // Rotate around X
    let y1 = y * Math.cos(rotA) - z * Math.sin(rotA);
    let z1 = y * Math.sin(rotA) + z * Math.cos(rotA);
    // Rotate around Y
    let x1 = x * Math.cos(rotB) + z1 * Math.sin(rotB);
    let z2 = -x * Math.sin(rotB) + z1 * Math.cos(rotB);
    return [x1, y1, z2];
}

function animate(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    time += dt;

    // Update 4D angles
    angles.xw += dt * parseFloat(sliders.xw.value);
    angles.yz += dt * parseFloat(sliders.yz.value);
    angles.xy += dt * parseFloat(sliders.xy.value);
    angles.zw += dt * parseFloat(sliders.zw.value);

    const dist4d = parseFloat(sliders.dist.value);
    const fov = parseFloat(sliders.fov.value);

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Subtle grid background
    ctx.strokeStyle = 'rgba(100, 160, 255, 0.03)';
    ctx.lineWidth = 1;
    const gs = 60;
    for (let x = gs; x < W; x += gs) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = gs; y < H; y += gs) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

    // Transform all vertices
    const projected = vertices4D.map(v => {
        const r4 = rotate4D(v, angles);
        const [rx, ry, rz] = rotate3D(r4[0] * r4[3 < dist4d ? 1 : 1], r4[1], r4[2]);
        const r4rot = [rx, ry, rz, r4[3]];
        return projectVertex(r4rot, dist4d, fov);
    });

    // Draw faces
    if (showFacesCheck.checked) {
        const faceData = faces.map(f => {
            const pts = f.map(i => projected[i]);
            const avgZ = pts.reduce((s, p) => s + p.z + p.w, 0) / 4;
            return { pts, avgZ, indices: f };
        });
        faceData.sort((a, b) => a.avgZ - b.avgZ);

        for (const fd of faceData) {
            // Order points for proper quad rendering
            const cx = fd.pts.reduce((s, p) => s + p.x, 0) / 4;
            const cy = fd.pts.reduce((s, p) => s + p.y, 0) / 4;
            const sorted = [...fd.pts].sort((a, b) => Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx));

            const hue = ((fd.avgZ + 4) / 8) * 360;
            ctx.beginPath();
            ctx.moveTo(sorted[0].x, sorted[0].y);
            for (let k = 1; k < sorted.length; k++) ctx.lineTo(sorted[k].x, sorted[k].y);
            ctx.closePath();
            ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.08)`;
            ctx.fill();
        }
    }

    // Draw edges with glow
    for (const [i, j] of edges) {
        const p1 = projected[i], p2 = projected[j];
        const color = edgeColor(i, j);
        const avgW = (p1.w + p2.w) / 2;
        const brightness = 0.4 + 0.4 * ((2 - avgW) / 4);

        // Glow pass
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color.replace(')', `, ${brightness * 0.3})`).replace('rgb', 'rgba').replace('#', '');
        // Use hex with alpha
        ctx.globalAlpha = brightness * 0.3;
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.stroke();

        // Main line
        ctx.globalAlpha = brightness;
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.globalAlpha = 1;
    }

    // Draw vertices
    for (let i = 0; i < projected.length; i++) {
        const p = projected[i];
        const facing = (2 - p.w) / 4; // 0 to 1, higher when facing viewer
        const radius = 2 + facing * 4;

        if (showGlowCheck.checked && facing > 0.4) {
            const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 4);
            grad.addColorStop(0, `rgba(200, 220, 255, ${facing * 0.5})`);
            grad.addColorStop(1, 'rgba(200, 220, 255, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius * 4, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + facing * 0.6})`;
        ctx.fill();
    }

    // Label
    ctx.font = '14px monospace';
    ctx.fillStyle = 'rgba(138, 170, 255, 0.4)';
    ctx.fillText('4D Hypercube (Tesseract) - 16 vertices, 32 edges, 24 faces, 8 cells', 20, H - 20);

    requestAnimationFrame(animate);
}

function resetAll() {
    angles = { xw: 0, yz: 0, xy: 0, zw: 0 };
    rotA = 0.3; rotB = 0;
    sliders.xw.value = 0.5; sliders.yz.value = 0.3;
    sliders.xy.value = 0; sliders.zw.value = 0;
    sliders.dist.value = 3; sliders.fov.value = 400;
    updateLabels();
}

document.getElementById('resetBtn').onclick = resetAll;
document.getElementById('presetBtn').onclick = () => {
    sliders.xw.value = 0.5; sliders.yz.value = 0.3;
    sliders.xy.value = 0.15; sliders.zw.value = 0.1;
    sliders.dist.value = 3; sliders.fov.value = 400;
    updateLabels();
};

window.reset = resetAll;
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>