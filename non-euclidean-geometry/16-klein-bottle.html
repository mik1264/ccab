<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Klein Bottle</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }
    #controls {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: rgba(10, 14, 30, 0.85);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 160, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        color: #c8d8f0;
        min-width: 260px;
        max-height: calc(100vh - 60px);
        overflow-y: auto;
    }
    #controls h3 { color: #8af; margin-bottom: 12px; font-size: 1.1em; }
    .control-group { margin: 10px 0; }
    .control-group label { display: block; font-size: 0.82em; color: #8a9ab0; margin-bottom: 4px; }
    .control-group input[type="range"] { width: 100%; accent-color: #8af; }
    .control-group .value { float: right; color: #adf; font-family: monospace; font-size: 0.82em; }
    .btn {
        background: rgba(100, 160, 255, 0.15);
        border: 1px solid rgba(100, 160, 255, 0.3);
        color: #8af; padding: 6px 14px; border-radius: 6px;
        cursor: pointer; font-size: 0.82em; transition: all 0.2s;
    }
    .btn:hover { background: rgba(100, 160, 255, 0.3); }
    .btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px; }
    .info-text { font-size: 0.78em; color: #6a7a90; margin-top: 12px; line-height: 1.5; border-top: 1px solid rgba(100,160,255,0.15); padding-top: 10px; }
    label.check { display: flex; align-items: center; gap: 8px; margin: 6px 0; font-size: 0.82em; cursor: pointer; color: #8a9ab0; }
    input[type="checkbox"] { accent-color: #8af; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>

<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Klein Bottle</h3>
    <div class="control-group">
        <label>Rotation Speed <span id="speedVal" class="value">1.0</span></label>
        <input type="range" id="speed" min="0" max="3" step="0.1" value="1">
    </div>
    <div class="control-group">
        <label>Mesh Density <span id="densityVal" class="value">40</span></label>
        <input type="range" id="density" min="12" max="60" step="2" value="40">
    </div>
    <label class="check"><input type="checkbox" id="showAnt" checked> Show ant &amp; trail</label>
    <label class="check"><input type="checkbox" id="showFill" checked> Filled surface</label>
    <label class="check"><input type="checkbox" id="showWire"> Wireframe overlay</label>
    <div class="btn-row">
        <button class="btn" id="resetBtn">Reset View</button>
        <button class="btn" id="clearTrail">Clear Trail</button>
    </div>
    <div class="info-text">
        A <strong style="color:#adf">Klein bottle</strong> is a non-orientable surface with no inside or outside.
        Watch the ant crawl continuously &mdash; it transitions between what appears to be the "inside" and "outside"
        without ever crossing an edge. Drag to rotate.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Controls
const speedSlider = document.getElementById('speed');
const densitySlider = document.getElementById('density');
const showAntCheck = document.getElementById('showAnt');
const showFillCheck = document.getElementById('showFill');
const showWireCheck = document.getElementById('showWire');

speedSlider.oninput = () => document.getElementById('speedVal').textContent = parseFloat(speedSlider.value).toFixed(1);
densitySlider.oninput = () => { document.getElementById('densityVal').textContent = densitySlider.value; buildMesh(); };

// Mouse drag rotation
let rotX = 0.3, rotY = 0, rotZ = 0;
let dragging = false, lastMX = 0, lastMY = 0;

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);

// Touch support
canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, {passive:false});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!dragging) return;
    rotY += (e.touches[0].clientX - lastMX) * 0.005;
    rotX += (e.touches[0].clientY - lastMY) * 0.005;
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
}, {passive:false});
canvas.addEventListener('touchend', () => dragging = false);

// Klein bottle parametrization (figure-8 immersion)
function kleinPoint(u, v) {
    const a = 2.5, r = 1.0;
    const cosU = Math.cos(u), sinU = Math.sin(u);
    const cosV = Math.cos(v), sinV = Math.sin(v);
    const cosHalfU = Math.cos(u / 2), sinHalfU = Math.sin(u / 2);
    const x = (a + r * cosV * cosHalfU + r * sinV * sinHalfU) * cosU;
    const y = (a + r * cosV * cosHalfU + r * sinV * sinHalfU) * sinU;
    const z = -r * sinV * cosHalfU + r * cosV * sinHalfU;
    return [x, y, z];
}

// Rotation matrices
function rotateXYZ(p, ax, ay, az) {
    let [x, y, z] = p;
    // Rotate X
    let y1 = y * Math.cos(ax) - z * Math.sin(ax);
    let z1 = y * Math.sin(ax) + z * Math.cos(ax);
    y = y1; z = z1;
    // Rotate Y
    let x1 = x * Math.cos(ay) + z * Math.sin(ay);
    z1 = -x * Math.sin(ay) + z * Math.cos(ay);
    x = x1; z = z1;
    // Rotate Z
    x1 = x * Math.cos(az) - y * Math.sin(az);
    y1 = x * Math.sin(az) + y * Math.cos(az);
    return [x1, y1, z];
}

function project(p) {
    const fov = 300;
    const dist = 8;
    const scale = fov / (dist + p[2]);
    return [W / 2 + p[0] * scale, H / 2 + p[1] * scale, p[2]];
}

// Mesh
let faces = [];
function buildMesh() {
    faces = [];
    const n = parseInt(densitySlider.value);
    const du = (2 * Math.PI) / n;
    const dv = (2 * Math.PI) / n;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const u0 = i * du, u1 = (i + 1) * du;
            const v0 = j * dv, v1 = (j + 1) * dv;
            const p00 = kleinPoint(u0, v0);
            const p10 = kleinPoint(u1, v0);
            const p11 = kleinPoint(u1, v1);
            const p01 = kleinPoint(u0, v1);
            faces.push({ pts: [p00, p10, p11, p01], u: (u0 + u1) / 2, v: (v0 + v1) / 2 });
        }
    }
}
buildMesh();

// Ant
let antU = 0, antV = 0;
let antTrail = [];
const maxTrail = 2000;

document.getElementById('clearTrail').onclick = () => { antTrail = []; };

// Color from u,v
function uvColor(u, v, alpha) {
    const h = (u / (2 * Math.PI)) * 360;
    const s = 60 + 30 * Math.sin(v);
    const l = 40 + 15 * Math.cos(v * 2);
    return `hsla(${h}, ${s}%, ${l}%, ${alpha})`;
}

let autoRotY = 0;
let time = 0;
let lastTime = performance.now();

function animate(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    time += dt;

    const speed = parseFloat(speedSlider.value);
    if (!dragging) {
        autoRotY += dt * 0.3 * speed;
    }

    // Update ant
    if (showAntCheck.checked) {
        antU += dt * 0.8 * speed;
        antV += dt * 1.3 * speed;
        if (antU > 2 * Math.PI) antU -= 2 * Math.PI;
        if (antV > 2 * Math.PI) antV -= 2 * Math.PI;
        const ap = kleinPoint(antU, antV);
        antTrail.push({ p: ap, u: antU, v: antV });
        if (antTrail.length > maxTrail) antTrail.shift();
    }

    // Clear
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const rX = rotX;
    const rY = rotY + autoRotY;
    const rZ = rotZ;

    // Transform and sort faces
    const showFill = showFillCheck.checked;
    const showWire = showWireCheck.checked;

    if (showFill || showWire) {
        const transformed = faces.map(f => {
            const tpts = f.pts.map(p => {
                const r = rotateXYZ(p, rX, rY, rZ);
                return project(r);
            });
            const avgZ = tpts.reduce((s, p) => s + p[2], 0) / 4;
            return { tpts, avgZ, u: f.u, v: f.v };
        });

        // Painter's algorithm
        transformed.sort((a, b) => a.avgZ - b.avgZ);

        for (const f of transformed) {
            const pts = f.tpts;
            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);
            for (let k = 1; k < 4; k++) ctx.lineTo(pts[k][0], pts[k][1]);
            ctx.closePath();

            if (showFill) {
                const brightness = 0.4 + 0.3 * ((f.avgZ + 4) / 8);
                ctx.fillStyle = uvColor(f.u, f.v, brightness);
                ctx.fill();
            }
            if (showWire) {
                ctx.strokeStyle = uvColor(f.u, f.v, 0.5);
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        }
    }

    // Draw ant trail
    if (showAntCheck.checked && antTrail.length > 1) {
        for (let i = 1; i < antTrail.length; i++) {
            const t0 = antTrail[i - 1];
            const t1 = antTrail[i];
            const p0 = project(rotateXYZ(t0.p, rX, rY, rZ));
            const p1 = project(rotateXYZ(t1.p, rX, rY, rZ));
            const alpha = (i / antTrail.length) * 0.9;
            ctx.beginPath();
            ctx.moveTo(p0[0], p0[1]);
            ctx.lineTo(p1[0], p1[1]);
            ctx.strokeStyle = `rgba(255, 200, 80, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Draw ant head
        if (antTrail.length > 0) {
            const last = antTrail[antTrail.length - 1];
            const ap = project(rotateXYZ(last.p, rX, rY, rZ));
            ctx.beginPath();
            ctx.arc(ap[0], ap[1], 5, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ap[0], ap[1], 8, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 200, 80, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Glow
            const grad = ctx.createRadialGradient(ap[0], ap[1], 0, ap[0], ap[1], 20);
            grad.addColorStop(0, 'rgba(255, 200, 80, 0.4)');
            grad.addColorStop(1, 'rgba(255, 200, 80, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(ap[0] - 20, ap[1] - 20, 40, 40);
        }
    }

    // Title
    ctx.font = '14px monospace';
    ctx.fillStyle = 'rgba(138, 170, 255, 0.4)';
    ctx.fillText('Klein Bottle - Non-orientable surface', 20, H - 20);

    requestAnimationFrame(animate);
}

// Reset
function resetView() {
    rotX = 0.3; rotY = 0; rotZ = 0; autoRotY = 0;
    antU = 0; antV = 0; antTrail = [];
    speedSlider.value = 1; speedSlider.oninput();
    densitySlider.value = 40; densitySlider.oninput();
    buildMesh();
}

document.getElementById('resetBtn').onclick = resetView;
window.reset = resetView;

requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>