<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hairy Ball Theorem</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,30,0.75);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 12px;
  padding: 18px; color: #cde; z-index: 100; min-width: 220px;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1em; }
.btn {
  display: block; width: 100%; margin: 4px 0; padding: 7px 12px;
  background: rgba(138,170,255,0.1); border: 1px solid rgba(138,170,255,0.25);
  border-radius: 6px; color: #cde; cursor: pointer; font-size: 0.85em; text-align: left;
}
.btn:hover { background: rgba(138,170,255,0.2); }
.btn.active { background: rgba(138,170,255,0.3); border-color: #8af; color: #fff; }
label { display: block; margin-top: 10px; font-size: 0.8em; color: #89a; }
input[type=range] { width: 100%; margin-top: 4px; accent-color: #8af; }
.info-box {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(10,14,30,0.8); backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 10px;
  padding: 12px 22px; color: #89a; font-size: 0.8em; text-align: center; z-index: 100;
  max-width: 600px; line-height: 1.4;
}
.info-box strong { color: #8af; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Hairy Ball Theorem</h3>
  <button class="btn active" data-field="dipole">Dipole (Source + Sink)</button>
  <button class="btn" data-field="vortex">Vortex (Two Rotations)</button>
  <button class="btn" data-field="combed">Combed Attempt</button>
  <button class="btn" data-field="wind">Wind Pattern</button>
  <label>Arrow Density: <span id="denVal">12</span></label>
  <input type="range" id="density" min="6" max="20" value="12" step="2">
  <label>Animation Speed: <span id="spdVal">1.0</span></label>
  <input type="range" id="speed" min="0" max="2" value="1" step="0.1">
  <label style="margin-top:8px">
    <input type="checkbox" id="autoRotate" checked> Auto-rotate
  </label>
</div>
<div class="info-box">
  <strong>Hairy Ball Theorem:</strong> Any continuous tangent vector field on a sphere must have at least one zero.
  There is always a point on Earth with no wind. Sum of singularity indices = 2 (Euler characteristic).
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  cx = W / 2; cy = H / 2;
  R = Math.min(W, H) * 0.32;
}
resize();
window.addEventListener('resize', resize);

let rotX = 0.3, rotY = 0, autoRot = true;
let dragging = false, lastMX, lastMY;
let animTime = 0, animSpeed = 1;
let currentField = 'dipole';
let arrowDensity = 12;

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  rotY += (e.clientX - lastMX) * 0.005;
  rotX += (e.clientY - lastMY) * 0.005;
  rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchmove', e => {
  if (!dragging) return;
  rotY += (e.touches[0].clientX - lastMX) * 0.005;
  rotX += (e.touches[0].clientY - lastMY) * 0.005;
  rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
  lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', () => dragging = false);

function rotateXM(v, a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c];
}
function rotateYM(v, a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [v[0]*c + v[2]*s, v[1], -v[0]*s + v[2]*c];
}

function sphereToCart(theta, phi) {
  return [Math.sin(theta)*Math.cos(phi), Math.cos(theta), Math.sin(theta)*Math.sin(phi)];
}

// Vector field functions: return tangent vector at (theta, phi) on the sphere
function getField(theta, phi, t) {
  // Tangent basis at (theta, phi)
  const eTheta = [Math.cos(theta)*Math.cos(phi), -Math.sin(theta), Math.cos(theta)*Math.sin(phi)];
  const ePhi = [-Math.sin(phi), 0, Math.cos(phi)];

  let vt = 0, vp = 0;

  switch(currentField) {
    case 'dipole': {
      // Source at north pole, sink at south pole
      vt = Math.sin(theta);
      vp = 0;
      // Add gentle time animation
      const wave = Math.sin(t * 0.5) * 0.15;
      vp = wave * Math.sin(theta);
      break;
    }
    case 'vortex': {
      // Two vortex centers
      vt = Math.sin(2 * phi) * Math.sin(theta);
      vp = Math.cos(theta) + 0.3 * Math.sin(t * 0.3);
      break;
    }
    case 'combed': {
      // Try to comb along longitude - fails at poles
      vp = Math.sin(theta);
      vt = 0.1 * Math.sin(t * 0.4);
      break;
    }
    case 'wind': {
      // Atmospheric-like pattern
      vp = Math.sin(theta) * Math.cos(theta) * 2;
      vt = Math.sin(3 * phi + t * 0.2) * Math.sin(theta) * 0.5;
      break;
    }
  }

  return [
    eTheta[0]*vt + ePhi[0]*vp,
    eTheta[1]*vt + ePhi[1]*vp,
    eTheta[2]*vt + ePhi[2]*vp
  ];
}

function getSingularities() {
  switch(currentField) {
    case 'dipole': return [
      { theta: 0.01, phi: 0, index: +1, label: 'Source (+1)' },
      { theta: Math.PI-0.01, phi: 0, index: +1, label: 'Sink (+1)' }
    ];
    case 'vortex': return [
      { theta: Math.PI*0.5, phi: 0, index: +1, label: 'Vortex (+1)' },
      { theta: Math.PI*0.5, phi: Math.PI, index: +1, label: 'Vortex (+1)' }
    ];
    case 'combed': return [
      { theta: 0.01, phi: 0, index: +1, label: 'Cowlick (+1)' },
      { theta: Math.PI-0.01, phi: 0, index: +1, label: 'Cowlick (+1)' }
    ];
    case 'wind': return [
      { theta: 0.01, phi: 0, index: +1, label: 'Pole (+1)' },
      { theta: Math.PI-0.01, phi: 0, index: +1, label: 'Pole (+1)' }
    ];
  }
}

function project(v) {
  return [cx + v[0] * R, cy - v[1] * R];
}

function draw(time) {
  const dt = 1/60;
  animTime += dt * animSpeed;

  ctx.clearRect(0, 0, W, H);

  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*1.6);
  grad.addColorStop(0, '#101830');
  grad.addColorStop(1, '#0a0e1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  if (autoRot && !dragging) rotY += 0.003;

  // Sphere outline
  ctx.strokeStyle = 'rgba(138,170,255,0.12)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.stroke();

  // Subtle sphere shading
  const shadeGrad = ctx.createRadialGradient(cx - R*0.3, cy - R*0.3, R*0.1, cx, cy, R);
  shadeGrad.addColorStop(0, 'rgba(60,80,140,0.08)');
  shadeGrad.addColorStop(1, 'rgba(10,14,26,0.15)');
  ctx.fillStyle = shadeGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.fill();

  // Generate arrow grid points on sphere
  const N = arrowDensity;
  const arrows = [];
  for (let i = 1; i < N; i++) {
    const theta = (i / N) * Math.PI;
    const nPhi = Math.max(4, Math.round(N * Math.sin(theta)));
    for (let j = 0; j < nPhi; j++) {
      const phi = (j / nPhi) * 2 * Math.PI;
      const pos = sphereToCart(theta, phi);
      const field = getField(theta, phi, animTime);

      // Transform
      let tp = rotateXM(pos, rotX);
      tp = rotateYM(tp, rotY);

      if (tp[2] < -0.1) continue; // back face

      // Transform field vector too
      let tf = rotateXM(field, rotX);
      tf = rotateYM(tf, rotY);

      const mag = Math.sqrt(tf[0]*tf[0]+tf[1]*tf[1]+tf[2]*tf[2]);
      arrows.push({ pos: tp, field: tf, mag, depth: tp[2] });
    }
  }

  // Sort by depth
  arrows.sort((a,b) => a.depth - b.depth);

  // Draw arrows
  const arrowLen = R * 0.08;
  for (const arr of arrows) {
    const [sx, sy] = project(arr.pos);
    const mag = arr.mag;
    if (mag < 0.001) continue;

    const scale = Math.min(1, mag) * arrowLen;
    const ex = sx + (arr.field[0] / mag) * scale;
    const ey = sy - (arr.field[1] / mag) * scale;

    const alpha = 0.3 + arr.depth * 0.5;

    // Color by magnitude
    const hue = (1 - Math.min(1, mag)) * 120; // green=low, red=high
    ctx.strokeStyle = `hsla(${200 + hue * 0.5}, 80%, 65%, ${alpha.toFixed(2)})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    // Arrowhead
    const angle = Math.atan2(-(ey - sy), ex - sx);
    const headLen = 4;
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex - headLen * Math.cos(angle - 0.4), ey + headLen * Math.sin(angle - 0.4));
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex - headLen * Math.cos(angle + 0.4), ey + headLen * Math.sin(angle + 0.4));
    ctx.stroke();
  }

  // Draw singularities
  const sings = getSingularities();
  for (const s of sings) {
    const pos = sphereToCart(s.theta, s.phi);
    let tp = rotateXM(pos, rotX);
    tp = rotateYM(tp, rotY);

    if (tp[2] < 0) continue; // behind sphere

    const [sx, sy] = project(tp);

    // Red glow
    const glowR = R * 0.06;
    const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
    sg.addColorStop(0, 'rgba(255,60,60,0.8)');
    sg.addColorStop(0.5, 'rgba(255,40,40,0.3)');
    sg.addColorStop(1, 'rgba(255,30,30,0)');
    ctx.fillStyle = sg;
    ctx.beginPath();
    ctx.arc(sx, sy, glowR, 0, Math.PI*2);
    ctx.fill();

    // Pulsing ring
    const pulse = 1 + 0.2 * Math.sin(animTime * 3);
    ctx.strokeStyle = 'rgba(255,80,80,0.6)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(sx, sy, glowR * 0.6 * pulse, 0, Math.PI*2);
    ctx.stroke();

    // Label
    ctx.fillStyle = 'rgba(255,140,140,0.9)';
    ctx.font = '11px "Segoe UI", Arial, sans-serif';
    ctx.fillText(s.label, sx + glowR + 4, sy + 4);
  }

  // Index sum label
  const totalIndex = sings.reduce((s, x) => s + x.index, 0);
  ctx.fillStyle = 'rgba(138,170,255,0.6)';
  ctx.font = '13px "Segoe UI", Arial, sans-serif';
  ctx.fillText(`Sum of indices = ${totalIndex} (Euler characteristic)`, cx - 120, cy + R + 30);

  requestAnimationFrame(draw);
}

// Controls
document.querySelectorAll('.btn[data-field]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.btn[data-field]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentField = btn.dataset.field;
  });
});

document.getElementById('density').addEventListener('input', function() {
  arrowDensity = parseInt(this.value);
  document.getElementById('denVal').textContent = this.value;
});

document.getElementById('speed').addEventListener('input', function() {
  animSpeed = parseFloat(this.value);
  document.getElementById('spdVal').textContent = parseFloat(this.value).toFixed(1);
});

document.getElementById('autoRotate').addEventListener('change', function() {
  autoRot = this.checked;
});

window.reset = function() {
  rotX = 0.3; rotY = 0; animTime = 0; animSpeed = 1; autoRot = true;
  currentField = 'dipole'; arrowDensity = 12;
  document.getElementById('autoRotate').checked = true;
  document.getElementById('density').value = 12;
  document.getElementById('denVal').textContent = '12';
  document.getElementById('speed').value = 1;
  document.getElementById('spdVal').textContent = '1.0';
  document.querySelectorAll('.btn[data-field]').forEach(b => b.classList.remove('active'));
  document.querySelector('[data-field="dipole"]').classList.add('active');
};

requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
