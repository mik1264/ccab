<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spherical Triangle Explorer - Non-Euclidean Geometry</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }

.panel {
    position: fixed; top: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 26, 0.8); backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px; color: #ccd; width: 260px;
}
.panel h3 { color: #8af; margin-bottom: 12px; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.panel label { display: block; margin-bottom: 4px; font-size: 0.82em; color: #99a; }
.panel .data-row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em; }
.panel .data-row .label { color: #99a; }
.panel .data-row .value { color: #8cf; font-family: 'Courier New', monospace; }
.highlight { color: #ffa !important; font-weight: bold; font-size: 1.1em !important; }
.btn { display: inline-block; padding: 6px 11px; margin: 3px; background: rgba(138,170,255,0.12); border: 1px solid rgba(138,170,255,0.25); color: #8af; border-radius: 6px; cursor: pointer; font-size: 0.78em; transition: all 0.2s; }
.btn:hover { background: rgba(138,170,255,0.25); }
.section-label { color: #6a8; font-size: 0.78em; margin-top: 12px; margin-bottom: 6px; font-weight: bold; border-top: 1px solid rgba(138,170,255,0.1); padding-top: 8px; }
.info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(138,170,255,0.5); font-size: 0.8em; z-index: 100; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>

<div class="panel">
    <h3>Spherical Triangle</h3>
    <div class="data-row"><span class="label">Angle A:</span><span class="value" id="angleA">--</span></div>
    <div class="data-row"><span class="label">Angle B:</span><span class="value" id="angleB">--</span></div>
    <div class="data-row"><span class="label">Angle C:</span><span class="value" id="angleC">--</span></div>
    <div class="data-row highlight"><span class="label">Angle Sum:</span><span class="value" id="angleSum">--</span></div>
    <div class="data-row"><span class="label">Excess:</span><span class="value" id="excess">--</span></div>
    <div class="data-row"><span class="label">Area (sr):</span><span class="value" id="area">--</span></div>

    <div class="section-label">vs. Flat Triangle</div>
    <div class="data-row"><span class="label">Flat sum:</span><span class="value">180.0&deg;</span></div>
    <div class="data-row"><span class="label">Curved sum:</span><span class="value" id="curvedSum">--</span></div>

    <div class="section-label">Presets</div>
    <div>
        <span class="btn" id="preSmall">Small (~181&deg;)</span>
        <span class="btn" id="preMedium">Medium (~220&deg;)</span>
        <span class="btn" id="preLarge">Large (~360&deg;+)</span>
        <span class="btn" id="preEquilateral">Equilateral</span>
    </div>
</div>

<div class="info">Click to place 3 vertices, drag to move them, drag background to rotate sphere</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H, cx, cy, R;
let animId;

// Sphere rotation
let rotX = 0.3, rotY = 0.5;
let isDragging = false;
let dragTarget = -1; // -1 = sphere rotation, 0-2 = vertex drag
let lastMx, lastMy;

// Triangle vertices in spherical coords (theta=longitude, phi=latitude from pole)
let vertices = [
    { theta: -0.5, phi: 1.0 },
    { theta: 0.6, phi: 0.9 },
    { theta: 0.1, phi: 1.8 }
];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
    cy = H / 2;
    R = Math.min(W, H) * 0.38;
}
resize();
window.addEventListener('resize', resize);

// Convert spherical to 3D cartesian
function sphericalToCart(theta, phi) {
    return [
        Math.sin(phi) * Math.cos(theta),
        Math.cos(phi),
        Math.sin(phi) * Math.sin(theta)
    ];
}

// Convert 3D cartesian to spherical
function cartToSpherical(x, y, z) {
    const r = Math.sqrt(x*x + y*y + z*z);
    const phi = Math.acos(Math.max(-1, Math.min(1, y / r)));
    const theta = Math.atan2(z, x);
    return { theta, phi };
}

// Rotate point by sphere rotation
function rotatePoint(p) {
    // Rotate around Y axis by rotY
    let x = p[0]*Math.cos(rotY) + p[2]*Math.sin(rotY);
    let z = -p[0]*Math.sin(rotY) + p[2]*Math.cos(rotY);
    let y = p[1];

    // Rotate around X axis by rotX
    const y2 = y*Math.cos(rotX) - z*Math.sin(rotX);
    const z2 = y*Math.sin(rotX) + z*Math.cos(rotX);

    return [x, y2, z2];
}

// Inverse rotation
function inverseRotate(p) {
    let [x, y, z] = p;
    // Undo X rotation
    const y2 = y*Math.cos(-rotX) - z*Math.sin(-rotX);
    const z2 = y*Math.sin(-rotX) + z*Math.cos(-rotX);
    y = y2; z = z2;
    // Undo Y rotation
    const x2 = x*Math.cos(-rotY) + z*Math.sin(-rotY);
    const z3 = -x*Math.sin(-rotY) + z*Math.cos(-rotY);
    return [x2, y, z3];
}

// Project 3D to 2D (orthographic)
function project(p) {
    const rp = rotatePoint(p);
    return { x: cx + rp[0] * R, y: cy - rp[1] * R, z: rp[2], visible: rp[2] > -0.01 };
}

// Get vertex as 3D point
function getVertex3D(i) {
    return sphericalToCart(vertices[i].theta, vertices[i].phi);
}

// Great circle arc points between two 3D points on unit sphere
function greatCircleArc(p1, p2, numSteps) {
    const points = [];
    // Use slerp
    const dot = p1[0]*p2[0] + p1[1]*p2[1] + p1[2]*p2[2];
    const omega = Math.acos(Math.max(-1, Math.min(1, dot)));

    if (Math.abs(omega) < 1e-6) {
        points.push(p1);
        return points;
    }

    const sinOmega = Math.sin(omega);

    for (let i = 0; i <= numSteps; i++) {
        const t = i / numSteps;
        const s1 = Math.sin((1-t)*omega) / sinOmega;
        const s2 = Math.sin(t*omega) / sinOmega;
        points.push([
            s1*p1[0] + s2*p2[0],
            s1*p1[1] + s2*p2[1],
            s1*p1[2] + s2*p2[2]
        ]);
    }
    return points;
}

// Spherical angle at vertex B in triangle ABC
function sphericalAngle(a, b, c) {
    // Vectors from B to A and B to C on tangent plane at B
    const ba = [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
    const bc = [c[0]-b[0], c[1]-b[1], c[2]-b[2]];

    // Project onto tangent plane at B (subtract normal component)
    const dotBA = ba[0]*b[0] + ba[1]*b[1] + ba[2]*b[2];
    const dotBC = bc[0]*b[0] + bc[1]*b[1] + bc[2]*b[2];

    const ta = [ba[0]-dotBA*b[0], ba[1]-dotBA*b[1], ba[2]-dotBA*b[2]];
    const tc = [bc[0]-dotBC*b[0], bc[1]-dotBC*b[1], bc[2]-dotBC*b[2]];

    const lenA = Math.sqrt(ta[0]*ta[0]+ta[1]*ta[1]+ta[2]*ta[2]);
    const lenC = Math.sqrt(tc[0]*tc[0]+tc[1]*tc[1]+tc[2]*tc[2]);

    if (lenA < 1e-10 || lenC < 1e-10) return 0;

    const dot2 = (ta[0]*tc[0]+ta[1]*tc[1]+ta[2]*tc[2]) / (lenA*lenC);
    return Math.acos(Math.max(-1, Math.min(1, dot2)));
}

// Draw the sphere wireframe
function drawSphere() {
    ctx.strokeStyle = 'rgba(138,170,255,0.06)';
    ctx.lineWidth = 0.5;

    // Latitude lines
    for (let lat = -80; lat <= 80; lat += 20) {
        const phi = (90 - lat) * Math.PI / 180;
        ctx.beginPath();
        let started = false;
        for (let lon = 0; lon <= 360; lon += 3) {
            const theta = lon * Math.PI / 180;
            const p = sphericalToCart(theta, phi);
            const proj = project(p);
            if (proj.visible) {
                if (!started) { ctx.moveTo(proj.x, proj.y); started = true; }
                else ctx.lineTo(proj.x, proj.y);
            } else {
                started = false;
            }
        }
        ctx.stroke();
    }

    // Longitude lines
    for (let lon = 0; lon < 360; lon += 20) {
        const theta = lon * Math.PI / 180;
        ctx.beginPath();
        let started = false;
        for (let lat = -90; lat <= 90; lat += 3) {
            const phi = (90 - lat) * Math.PI / 180;
            const p = sphericalToCart(theta, phi);
            const proj = project(p);
            if (proj.visible) {
                if (!started) { ctx.moveTo(proj.x, proj.y); started = true; }
                else ctx.lineTo(proj.x, proj.y);
            } else {
                started = false;
            }
        }
        ctx.stroke();
    }

    // Sphere outline
    ctx.strokeStyle = 'rgba(138,170,255,0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.stroke();

    // Subtle sphere shading
    const grad = ctx.createRadialGradient(cx - R*0.2, cy - R*0.2, 0, cx, cy, R);
    grad.addColorStop(0, 'rgba(60,80,120,0.08)');
    grad.addColorStop(1, 'rgba(10,14,26,0.05)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.fill();
}

function drawTriangle() {
    const verts3D = [getVertex3D(0), getVertex3D(1), getVertex3D(2)];
    const colors = ['#ff6666', '#66ff88', '#6688ff'];
    const labels = ['A', 'B', 'C'];

    // Draw filled triangle (approximate with many small triangles)
    // First collect visible arc points
    const edges = [
        greatCircleArc(verts3D[0], verts3D[1], 60),
        greatCircleArc(verts3D[1], verts3D[2], 60),
        greatCircleArc(verts3D[2], verts3D[0], 60)
    ];

    // Fill the triangle on the visible side
    // Use polygon approximation from projected edge points
    const allBoundary = [];
    for (const edge of edges) {
        for (const p of edge) {
            const proj = project(p);
            if (proj.visible) allBoundary.push(proj);
        }
    }

    if (allBoundary.length > 2) {
        ctx.fillStyle = 'rgba(100, 160, 255, 0.12)';
        ctx.beginPath();
        ctx.moveTo(allBoundary[0].x, allBoundary[0].y);
        for (let i = 1; i < allBoundary.length; i++) {
            ctx.lineTo(allBoundary[i].x, allBoundary[i].y);
        }
        ctx.closePath();
        ctx.fill();
    }

    // Draw edges as great circle arcs
    const edgeColors = ['rgba(255,130,130,0.8)', 'rgba(130,255,160,0.8)', 'rgba(130,160,255,0.8)'];
    for (let e = 0; e < 3; e++) {
        ctx.strokeStyle = edgeColors[e];
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        let started = false;
        for (const p of edges[e]) {
            const proj = project(p);
            if (proj.visible) {
                if (!started) { ctx.moveTo(proj.x, proj.y); started = true; }
                else ctx.lineTo(proj.x, proj.y);
            } else {
                if (started) ctx.stroke();
                ctx.beginPath();
                started = false;
            }
        }
        ctx.stroke();

        // Draw back-side edges dashed
        ctx.strokeStyle = edgeColors[e].replace('0.8', '0.15');
        ctx.lineWidth = 1;
        ctx.setLineDash([4,4]);
        ctx.beginPath();
        started = false;
        for (const p of edges[e]) {
            const proj = project(p);
            if (!proj.visible) {
                if (!started) { ctx.moveTo(proj.x, proj.y); started = true; }
                else ctx.lineTo(proj.x, proj.y);
            } else {
                if (started) ctx.stroke();
                ctx.beginPath();
                started = false;
            }
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Draw vertices
    for (let i = 0; i < 3; i++) {
        const proj = project(verts3D[i]);
        const size = proj.visible ? 7 : 4;
        const alpha = proj.visible ? 1 : 0.3;

        ctx.globalAlpha = alpha;

        // Glow
        const glow = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, 15);
        glow.addColorStop(0, colors[i]);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 15, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = colors[i];
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, size, 0, Math.PI*2);
        ctx.fill();

        // Label
        ctx.font = 'bold 16px "Segoe UI", sans-serif';
        ctx.fillStyle = colors[i];
        ctx.fillText(labels[i], proj.x + 12, proj.y - 12);

        // Draw angle arc at vertex
        if (proj.visible) {
            const next = (i+1)%3, prev = (i+2)%3;
            const angle = sphericalAngle(verts3D[prev], verts3D[i], verts3D[next]);

            // Draw small arc showing the angle
            const tangentA = [verts3D[prev][0]-verts3D[i][0], verts3D[prev][1]-verts3D[i][1], verts3D[prev][2]-verts3D[i][2]];
            const tangentB = [verts3D[next][0]-verts3D[i][0], verts3D[next][1]-verts3D[i][1], verts3D[next][2]-verts3D[i][2]];

            ctx.strokeStyle = colors[i];
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            const arcR = 20;
            const startA = Math.atan2(
                -(project(verts3D[prev]).y - proj.y),
                project(verts3D[prev]).x - proj.x
            );
            const endA = Math.atan2(
                -(project(verts3D[next]).y - proj.y),
                project(verts3D[next]).x - proj.x
            );
            ctx.arc(proj.x, proj.y, arcR, -startA, -endA, true);
            ctx.stroke();
        }

        ctx.globalAlpha = 1;
    }

    // Calculate and display angles
    const angA = sphericalAngle(verts3D[2], verts3D[0], verts3D[1]);
    const angB = sphericalAngle(verts3D[0], verts3D[1], verts3D[2]);
    const angC = sphericalAngle(verts3D[1], verts3D[2], verts3D[0]);
    const sum = angA + angB + angC;
    const excessRad = sum - Math.PI;

    document.getElementById('angleA').textContent = (angA * 180 / Math.PI).toFixed(1) + '\u00B0';
    document.getElementById('angleB').textContent = (angB * 180 / Math.PI).toFixed(1) + '\u00B0';
    document.getElementById('angleC').textContent = (angC * 180 / Math.PI).toFixed(1) + '\u00B0';
    document.getElementById('angleSum').textContent = (sum * 180 / Math.PI).toFixed(1) + '\u00B0';
    document.getElementById('excess').textContent = (excessRad * 180 / Math.PI).toFixed(1) + '\u00B0';
    document.getElementById('area').textContent = excessRad.toFixed(3);
    document.getElementById('curvedSum').textContent = (sum * 180 / Math.PI).toFixed(1) + '\u00B0';
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    drawSphere();
    drawTriangle();
}

function animate() {
    draw();
    animId = requestAnimationFrame(animate);
}

// Mouse interaction
function screenToSphere(sx, sy) {
    const dx = (sx - cx) / R;
    const dy = -(sy - cy) / R;
    const r2 = dx*dx + dy*dy;
    if (r2 > 1) return null;
    const dz = Math.sqrt(1 - r2);
    return inverseRotate([dx, dy, dz]);
}

function findNearestVertex(sx, sy) {
    let minDist = 30;
    let nearest = -1;
    for (let i = 0; i < 3; i++) {
        const proj = project(getVertex3D(i));
        const d = Math.sqrt((sx-proj.x)**2 + (sy-proj.y)**2);
        if (d < minDist) { minDist = d; nearest = i; }
    }
    return nearest;
}

canvas.addEventListener('mousedown', (e) => {
    lastMx = e.clientX;
    lastMy = e.clientY;

    dragTarget = findNearestVertex(e.clientX, e.clientY);
    isDragging = true;
});

canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    if (dragTarget >= 0) {
        // Drag vertex on sphere surface
        const sp = screenToSphere(e.clientX, e.clientY);
        if (sp) {
            const sph = cartToSpherical(sp[0], sp[1], sp[2]);
            vertices[dragTarget] = sph;
        }
    } else {
        // Rotate sphere
        const dx = e.clientX - lastMx;
        const dy = e.clientY - lastMy;
        rotY += dx * 0.005;
        rotX += dy * 0.005;
        rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
    }

    lastMx = e.clientX;
    lastMy = e.clientY;
});

canvas.addEventListener('mouseup', () => { isDragging = false; dragTarget = -1; });

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    lastMx = t.clientX; lastMy = t.clientY;
    dragTarget = findNearestVertex(t.clientX, t.clientY);
    isDragging = true;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!isDragging) return;
    const t = e.touches[0];
    if (dragTarget >= 0) {
        const sp = screenToSphere(t.clientX, t.clientY);
        if (sp) vertices[dragTarget] = cartToSpherical(sp[0], sp[1], sp[2]);
    } else {
        rotY += (t.clientX - lastMx) * 0.005;
        rotX += (t.clientY - lastMy) * 0.005;
        rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
    }
    lastMx = t.clientX; lastMy = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', () => { isDragging = false; dragTarget = -1; });

// Presets
document.getElementById('preSmall').addEventListener('click', () => {
    vertices = [
        { theta: -0.1, phi: 1.4 },
        { theta: 0.15, phi: 1.35 },
        { theta: 0.05, phi: 1.6 }
    ];
});

document.getElementById('preMedium').addEventListener('click', () => {
    vertices = [
        { theta: -0.6, phi: 0.8 },
        { theta: 0.7, phi: 0.9 },
        { theta: 0.0, phi: 2.0 }
    ];
});

document.getElementById('preLarge').addEventListener('click', () => {
    vertices = [
        { theta: 0, phi: 0.2 },
        { theta: 2.1, phi: 1.5 },
        { theta: -2.1, phi: 1.5 }
    ];
});

document.getElementById('preEquilateral').addEventListener('click', () => {
    const lat = 0.7;
    vertices = [
        { theta: 0, phi: lat },
        { theta: 2*Math.PI/3, phi: lat },
        { theta: 4*Math.PI/3, phi: lat }
    ];
});

window.reset = function() {
    rotX = 0.3; rotY = 0.5;
    vertices = [
        { theta: -0.5, phi: 1.0 },
        { theta: 0.6, phi: 0.9 },
        { theta: 0.1, phi: 1.8 }
    ];
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>