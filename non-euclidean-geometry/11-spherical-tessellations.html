<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spherical Tessellations</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a:hover { color: #bdf; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,30,0.75);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 12px;
  padding: 18px; color: #cde; z-index: 100; min-width: 220px;
}
#controls h3 { margin-bottom: 10px; color: #8af; font-size: 1em; }
.btn {
  display: block; width: 100%; margin: 4px 0; padding: 7px 12px;
  background: rgba(138,170,255,0.1); border: 1px solid rgba(138,170,255,0.25);
  border-radius: 6px; color: #cde; cursor: pointer; font-size: 0.85em; text-align: left;
}
.btn:hover { background: rgba(138,170,255,0.2); }
.btn.active { background: rgba(138,170,255,0.3); border-color: #8af; color: #fff; }
label { display: block; margin-top: 10px; font-size: 0.8em; color: #89a; }
input[type=range] { width: 100%; margin-top: 4px; accent-color: #8af; }
#info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(10,14,30,0.75); backdrop-filter: blur(10px);
  border: 1px solid rgba(138,170,255,0.15); border-radius: 10px;
  padding: 10px 20px; color: #89a; font-size: 0.8em; text-align: center; z-index: 100;
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Spherical Tessellations</h3>
  <button class="btn active" data-solid="tetra">Tetrahedron (4 faces)</button>
  <button class="btn" data-solid="octa">Octahedron (8 faces)</button>
  <button class="btn" data-solid="icosa">Icosahedron (20 faces)</button>
  <button class="btn" data-solid="dodeca">Dodecahedron (12 faces)</button>
  <label>Geodesic Subdivision: <span id="subVal">1</span></label>
  <input type="range" id="subSlider" min="1" max="4" value="1" step="1">
  <label style="margin-top:8px">
    <input type="checkbox" id="autoRotate" checked> Auto-rotate
  </label>
</div>
<div id="info">Only 5 regular tessellations of the sphere exist &mdash; the Platonic solids. Drag to rotate.</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  cx = W / 2; cy = H / 2;
  R = Math.min(W, H) * 0.35;
}
resize();
window.addEventListener('resize', resize);

// Rotation state
let rotX = 0.4, rotY = 0, autoRot = true;
let dragging = false, lastMX, lastMY;

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  rotY += (e.clientX - lastMX) * 0.005;
  rotX += (e.clientY - lastMY) * 0.005;
  rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchmove', e => {
  if (!dragging) return;
  rotY += (e.touches[0].clientX - lastMX) * 0.005;
  rotX += (e.touches[0].clientY - lastMY) * 0.005;
  rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
  lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', () => dragging = false);

// Platonic solid vertex/face data (unit sphere)
const phi = (1 + Math.sqrt(5)) / 2;

function normalize(v) {
  const l = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  return [v[0]/l, v[1]/l, v[2]/l];
}

const solids = {
  tetra: {
    verts: [[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]].map(normalize),
    faces: [[0,1,2],[0,1,3],[0,2,3],[1,2,3]]
  },
  octa: {
    verts: [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],
    faces: [[0,2,4],[2,1,4],[1,3,4],[3,0,4],[0,2,5],[2,1,5],[1,3,5],[3,0,5]]
  },
  icosa: (() => {
    const vs = [];
    for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) vs.push(normalize([0, (i?1:-1), (j?phi:-phi)]));
    for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) vs.push(normalize([(i?1:-1), (j?phi:-phi), 0]));
    for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) vs.push(normalize([(i?phi:-phi), 0, (j?1:-1)]));
    const fs = [];
    // Build faces by finding groups of 3 vertices that are mutually close
    const dists = [];
    for (let i = 0; i < 12; i++) for (let j = i+1; j < 12; j++) {
      const dx = vs[i][0]-vs[j][0], dy = vs[i][1]-vs[j][1], dz = vs[i][2]-vs[j][2];
      dists.push({i,j,d: Math.sqrt(dx*dx+dy*dy+dz*dz)});
    }
    const edgeLen = dists.reduce((m,e) => Math.min(m,e.d), 99);
    const edges = dists.filter(e => e.d < edgeLen * 1.1);
    const adj = Array.from({length:12}, () => []);
    edges.forEach(e => { adj[e.i].push(e.j); adj[e.j].push(e.i); });
    for (let i = 0; i < 12; i++) {
      for (const j of adj[i]) {
        if (j <= i) continue;
        for (const k of adj[j]) {
          if (k <= j) continue;
          if (adj[i].includes(k)) fs.push([i,j,k]);
        }
      }
    }
    return { verts: vs, faces: fs };
  })(),
  dodeca: (() => {
    // Dual of icosahedron: face centers become vertices
    const icoVs = [];
    for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) icoVs.push(normalize([0, (i?1:-1), (j?phi:-phi)]));
    for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) icoVs.push(normalize([(i?1:-1), (j?phi:-phi), 0]));
    for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) icoVs.push(normalize([(i?phi:-phi), 0, (j?1:-1)]));
    // Build icosahedron faces
    const dists = [];
    for (let i = 0; i < 12; i++) for (let j = i+1; j < 12; j++) {
      const dx = icoVs[i][0]-icoVs[j][0], dy = icoVs[i][1]-icoVs[j][1], dz = icoVs[i][2]-icoVs[j][2];
      dists.push({i,j,d: Math.sqrt(dx*dx+dy*dy+dz*dz)});
    }
    const edgeLen = dists.reduce((m,e) => Math.min(m,e.d), 99);
    const edges = dists.filter(e => e.d < edgeLen * 1.1);
    const adj = Array.from({length:12}, () => []);
    edges.forEach(e => { adj[e.i].push(e.j); adj[e.j].push(e.i); });
    const icoFs = [];
    for (let i = 0; i < 12; i++) for (const j of adj[i]) { if (j <= i) continue; for (const k of adj[j]) { if (k <= j) continue; if (adj[i].includes(k)) icoFs.push([i,j,k]); } }

    // Dodecahedron vertices = centroids of icosahedron faces projected to sphere
    const dVerts = icoFs.map(f => {
      const c = [0,0,0];
      f.forEach(vi => { c[0]+=icoVs[vi][0]; c[1]+=icoVs[vi][1]; c[2]+=icoVs[vi][2]; });
      return normalize(c);
    });
    // Dodecahedron faces: each icosahedron vertex is surrounded by 5 faces forming a pentagon
    const dFaces = [];
    for (let v = 0; v < 12; v++) {
      const ring = [];
      icoFs.forEach((f, fi) => { if (f.includes(v)) ring.push(fi); });
      // Sort ring by angle around the vertex
      const center = icoVs[v];
      const up = normalize([center[1]-center[2], center[2]-center[0], center[0]-center[1]]);
      const right = normalize([
        center[1]*up[2]-center[2]*up[1],
        center[2]*up[0]-center[0]*up[2],
        center[0]*up[1]-center[1]*up[0]
      ]);
      ring.sort((a,b) => {
        const da = dVerts[a], db = dVerts[b];
        const angA = Math.atan2(da[0]*up[0]+da[1]*up[1]+da[2]*up[2], da[0]*right[0]+da[1]*right[1]+da[2]*right[2]);
        const angB = Math.atan2(db[0]*up[0]+db[1]*up[1]+db[2]*up[2], db[0]*right[0]+db[1]*right[1]+db[2]*right[2]);
        return angA - angB;
      });
      dFaces.push(ring);
    }
    return { verts: dVerts, faces: dFaces };
  })()
};

let currentSolid = 'tetra';
let subdivLevel = 1;

function subdivide(verts, faces, level) {
  let vs = verts.slice();
  let fs = faces.slice();
  for (let l = 1; l < level; l++) {
    const newFs = [];
    const midCache = {};
    function getMid(a, b) {
      const key = Math.min(a,b) + '_' + Math.max(a,b);
      if (midCache[key] !== undefined) return midCache[key];
      const m = normalize([(vs[a][0]+vs[b][0])/2, (vs[a][1]+vs[b][1])/2, (vs[a][2]+vs[b][2])/2]);
      vs.push(m);
      midCache[key] = vs.length - 1;
      return midCache[key];
    }
    for (const f of fs) {
      if (f.length === 3) {
        const a = f[0], b = f[1], c = f[2];
        const ab = getMid(a,b), bc = getMid(b,c), ca = getMid(c,a);
        newFs.push([a,ab,ca],[ab,b,bc],[ca,bc,c],[ab,bc,ca]);
      } else {
        // For non-triangle faces, just keep them
        newFs.push(f);
      }
    }
    fs = newFs;
  }
  return { verts: vs, faces: fs };
}

// Rotation matrices
function rotateX(v, a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c];
}
function rotateY(v, a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [v[0]*c + v[2]*s, v[1], -v[0]*s + v[2]*c];
}
function project(v) {
  return [cx + v[0] * R, cy - v[1] * R];
}

const faceColors = [
  '#e06070','#e08050','#d0a040','#80b040','#40a080',
  '#4090b0','#5070c0','#7060c0','#a050b0','#c05090',
  '#e07080','#c09040','#60b060','#4080c0','#8050d0',
  '#d06060','#b0a030','#50c070','#3090d0','#9040c0'
];

function drawGreatCircleArc(p1, p2, steps) {
  // Slerp between two unit vectors
  const pts = [];
  const dot = p1[0]*p2[0]+p1[1]*p2[1]+p1[2]*p2[2];
  const omega = Math.acos(Math.max(-1, Math.min(1, dot)));
  if (omega < 0.001) {
    pts.push(p1, p2);
  } else {
    const sinO = Math.sin(omega);
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const a = Math.sin((1-t)*omega)/sinO;
      const b = Math.sin(t*omega)/sinO;
      pts.push([p1[0]*a+p2[0]*b, p1[1]*a+p2[1]*b, p1[2]*a+p2[2]*b]);
    }
  }
  return pts;
}

function draw(time) {
  ctx.clearRect(0, 0, W, H);

  // Background gradient
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*1.5);
  grad.addColorStop(0, '#0f1528');
  grad.addColorStop(1, '#0a0e1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  if (autoRot && !dragging) rotY += 0.004;

  const solid = solids[currentSolid];
  const { verts, faces } = (currentSolid === 'icosa' || currentSolid === 'tetra' || currentSolid === 'octa')
    ? subdivide(solid.verts, solid.faces, subdivLevel)
    : { verts: solid.verts, faces: solid.faces };

  // Transform vertices
  const transformed = verts.map(v => {
    let r = rotateX(v, rotX);
    r = rotateY(r, rotY);
    return r;
  });

  // Draw sphere outline
  ctx.strokeStyle = 'rgba(138,170,255,0.1)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI * 2);
  ctx.stroke();

  // Sort faces by depth
  const faceDepths = faces.map((f, i) => {
    const cz = f.reduce((s, vi) => s + transformed[vi][2], 0) / f.length;
    return { face: f, idx: i, depth: cz };
  });
  faceDepths.sort((a, b) => a.depth - b.depth);

  // Draw faces
  const arcSteps = 8;
  for (const { face, idx, depth } of faceDepths) {
    if (depth < -0.05) continue; // skip back faces mostly

    const alpha = 0.15 + depth * 0.45;
    const colorIdx = idx % faceColors.length;

    // Draw filled face via great circle arcs
    ctx.beginPath();
    for (let i = 0; i < face.length; i++) {
      const v1 = verts[face[i]];
      const v2 = verts[face[(i+1) % face.length]];
      const arcPts = drawGreatCircleArc(v1, v2, arcSteps);
      for (let j = 0; j < arcPts.length; j++) {
        let p = rotateX(arcPts[j], rotX);
        p = rotateY(p, rotY);
        const [sx, sy] = project(p);
        if (i === 0 && j === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
    }
    ctx.closePath();
    ctx.fillStyle = faceColors[colorIdx] + Math.round(Math.max(0.1, alpha) * 255).toString(16).padStart(2,'0');
    ctx.fill();
    ctx.strokeStyle = `rgba(255,255,255,${Math.max(0.1, alpha * 0.8).toFixed(2)})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // Sphere subtle glow
  const glow = ctx.createRadialGradient(cx - R*0.3, cy - R*0.3, 0, cx, cy, R);
  glow.addColorStop(0, 'rgba(138,170,255,0.04)');
  glow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.fill();

  requestAnimationFrame(draw);
}

// Controls
document.querySelectorAll('.btn[data-solid]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.btn[data-solid]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentSolid = btn.dataset.solid;
  });
});

const subSlider = document.getElementById('subSlider');
const subVal = document.getElementById('subVal');
subSlider.addEventListener('input', () => {
  subdivLevel = parseInt(subSlider.value);
  subVal.textContent = subdivLevel;
});

document.getElementById('autoRotate').addEventListener('change', function() {
  autoRot = this.checked;
});

window.reset = function() {
  rotX = 0.4; rotY = 0;
  currentSolid = 'tetra';
  subdivLevel = 1;
  subSlider.value = 1;
  subVal.textContent = '1';
  autoRot = true;
  document.getElementById('autoRotate').checked = true;
  document.querySelectorAll('.btn[data-solid]').forEach(b => b.classList.remove('active'));
  document.querySelector('[data-solid="tetra"]').classList.add('active');
};

requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
