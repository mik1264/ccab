<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Curvature Morphing</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; }
    #controls {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: rgba(10, 14, 30, 0.85);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 160, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        color: #c8d8f0;
        min-width: 280px;
        max-height: calc(100vh - 60px);
        overflow-y: auto;
    }
    #controls h3 { color: #8af; margin-bottom: 12px; font-size: 1.1em; }
    .control-group { margin: 8px 0; }
    .control-group label { display: block; font-size: 0.82em; color: #8a9ab0; margin-bottom: 3px; }
    .control-group input[type="range"] { width: 100%; accent-color: #8af; }
    .control-group .value { float: right; color: #adf; font-family: monospace; font-size: 0.82em; }
    .btn {
        background: rgba(100, 160, 255, 0.15);
        border: 1px solid rgba(100, 160, 255, 0.3);
        color: #8af; padding: 6px 14px; border-radius: 6px;
        cursor: pointer; font-size: 0.82em; transition: all 0.2s;
    }
    .btn:hover { background: rgba(100, 160, 255, 0.3); }
    .btn.active { background: rgba(100, 160, 255, 0.4); border-color: #8af; }
    .btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px; }
    .metric-panel {
        margin-top: 12px; padding: 10px; border-radius: 8px;
        background: rgba(100, 200, 255, 0.06);
        border: 1px solid rgba(100, 160, 255, 0.1);
    }
    .metric-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 0.82em; }
    .metric-row .label { color: #8a9ab0; }
    .metric-row .val { color: #adf; font-family: monospace; font-weight: bold; }
    .curvature-label {
        text-align: center; font-size: 1.2em; margin: 8px 0;
        font-weight: bold; font-family: monospace;
    }
    .section-label { color: #6a8ac0; font-size: 0.75em; text-transform: uppercase; letter-spacing: 1px; margin-top: 12px; margin-bottom: 4px; }
    label.check { display: flex; align-items: center; gap: 8px; margin: 5px 0; font-size: 0.82em; cursor: pointer; color: #8a9ab0; }
    input[type="checkbox"] { accent-color: #8af; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>

<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Curvature Morphing</h3>
    <div class="curvature-label" id="curvLabel" style="color:#66ff88">K = 0.00 (Flat)</div>
    <div class="control-group">
        <label>Curvature K <span id="kVal" class="value">0.00</span></label>
        <input type="range" id="curvature" min="-1" max="1" step="0.01" value="0">
    </div>
    <label class="check"><input type="checkbox" id="autoAnimate" checked> Auto-oscillate</label>
    <div class="section-label">Show</div>
    <label class="check"><input type="checkbox" id="showTiling" checked> Tessellation</label>
    <label class="check"><input type="checkbox" id="showTriangle" checked> Triangle (angle sum)</label>
    <label class="check"><input type="checkbox" id="showParallel" checked> Parallel lines</label>
    <label class="check"><input type="checkbox" id="showCircle" checked> Circle ratio</label>
    <div class="metric-panel">
        <div class="metric-row">
            <span class="label">Triangle angle sum:</span>
            <span class="val" id="angleSum">180&deg;</span>
        </div>
        <div class="metric-row">
            <span class="label">Parallel lines:</span>
            <span class="val" id="parallelType">Stay parallel</span>
        </div>
        <div class="metric-row">
            <span class="label">C / d ratio:</span>
            <span class="val" id="circleRatio">&pi;</span>
        </div>
        <div class="metric-row">
            <span class="label">Geometry:</span>
            <span class="val" id="geoType">Euclidean</span>
        </div>
    </div>
    <div class="btn-row">
        <button class="btn" id="setNeg">K = -1</button>
        <button class="btn" id="setZero">K = 0</button>
        <button class="btn" id="setPos">K = +1</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

let K = 0; // Curvature parameter
let autoAnimate = true;
let time = 0;
let lastTime = performance.now();

const curvSlider = document.getElementById('curvature');
const autoCheck = document.getElementById('autoAnimate');
const showTiling = document.getElementById('showTiling');
const showTriangle = document.getElementById('showTriangle');
const showParallel = document.getElementById('showParallel');
const showCircle = document.getElementById('showCircle');

curvSlider.oninput = () => {
    K = parseFloat(curvSlider.value);
    autoAnimate = false;
    autoCheck.checked = false;
    updateDisplay();
};
autoCheck.onchange = () => { autoAnimate = autoCheck.checked; };

document.getElementById('setNeg').onclick = () => { curvSlider.value = -1; K = -1; autoAnimate = false; autoCheck.checked = false; updateDisplay(); };
document.getElementById('setZero').onclick = () => { curvSlider.value = 0; K = 0; autoAnimate = false; autoCheck.checked = false; updateDisplay(); };
document.getElementById('setPos').onclick = () => { curvSlider.value = 1; K = 1; autoAnimate = false; autoCheck.checked = false; updateDisplay(); };

function updateDisplay() {
    document.getElementById('kVal').textContent = K.toFixed(2);

    let label, color;
    if (K > 0.01) { label = `K = ${K.toFixed(2)} (Spherical)`; color = '#ff8866'; }
    else if (K < -0.01) { label = `K = ${K.toFixed(2)} (Hyperbolic)`; color = '#66aaff'; }
    else { label = `K = ${K.toFixed(2)} (Flat)`; color = '#66ff88'; }
    document.getElementById('curvLabel').textContent = label;
    document.getElementById('curvLabel').style.color = color;

    // Triangle angle sum: 180 + K * area (for a small triangle, excess ~ K)
    const angleSum = 180 + K * 60; // Rough: excess proportional to curvature
    document.getElementById('angleSum').textContent = angleSum.toFixed(1) + '\u00B0';

    // Parallel lines
    if (K > 0.01) document.getElementById('parallelType').textContent = 'Converge (meet)';
    else if (K < -0.01) document.getElementById('parallelType').textContent = 'Diverge (spread)';
    else document.getElementById('parallelType').textContent = 'Stay parallel';

    // Circle ratio
    const ratio = K > 0 ? Math.PI * (1 - K * 0.15) : (K < 0 ? Math.PI * (1 - K * 0.15) : Math.PI);
    document.getElementById('circleRatio').textContent = ratio.toFixed(4);

    // Geometry type
    if (K > 0.01) document.getElementById('geoType').textContent = 'Spherical (Riemannian)';
    else if (K < -0.01) document.getElementById('geoType').textContent = 'Hyperbolic (Lobachevsky)';
    else document.getElementById('geoType').textContent = 'Euclidean (Flat)';
}

// Drawing functions
function getCurvatureColor(k) {
    if (k > 0) return { r: 255, g: 100 + 56 * (1 - k), b: 80 + 20 * (1 - k) };
    if (k < 0) return { r: 80 + 20 * (1 + k), g: 140 + 60 * (1 + k), b: 255 };
    return { r: 100, g: 255, b: 140 };
}

function drawTessellation(cx, cy, radius) {
    // Draw a tessellation that morphs with curvature
    // At K=0: regular square grid {4,4}
    // At K>0: tiles curve inward (spherical), fewer fit
    // At K<0: tiles curve outward (hyperbolic), more fit in Poincare disk style

    const n = 5; // Grid extent
    const tileSize = radius / (n + 1);
    const col = getCurvatureColor(K);

    if (K >= -0.01) {
        // Euclidean or spherical: draw a grid that curves with K
        for (let i = -n; i <= n; i++) {
            for (let j = -n; j <= n; j++) {
                const bx = cx + i * tileSize;
                const by = cy + j * tileSize;

                // Apply curvature distortion
                const dx = i * tileSize;
                const dy = j * tileSize;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > radius) continue;

                // Spherical: compress toward center (tiles appear smaller at edges)
                // This simulates stereographic projection of a sphere
                let scale = 1;
                if (K > 0) {
                    const normDist = dist / radius;
                    scale = 1 / (1 + K * normDist * normDist * 0.5);
                }

                const px = cx + dx * scale;
                const py = cy + dy * scale;
                const s = tileSize * scale * 0.45;

                ctx.strokeStyle = `rgba(${col.r}, ${col.g}, ${col.b}, ${0.3 * (1 - dist / radius)})`;
                ctx.lineWidth = 1;

                if (K > 0.3) {
                    // Draw curved tiles for spherical
                    const bulge = K * s * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(px - s, py - s);
                    ctx.quadraticCurveTo(px, py - s - bulge, px + s, py - s);
                    ctx.quadraticCurveTo(px + s + bulge, py, px + s, py + s);
                    ctx.quadraticCurveTo(px, py + s + bulge, px - s, py + s);
                    ctx.quadraticCurveTo(px - s - bulge, py, px - s, py - s);
                    ctx.stroke();
                } else {
                    ctx.strokeRect(px - s, py - s, s * 2, s * 2);
                }
            }
        }
    }

    if (K < 0.01) {
        // Hyperbolic: Poincare disk-style tessellation
        // Tiles grow exponentially from center
        const absK = Math.abs(K);
        const blend = Math.min(1, absK * 5); // Transition factor

        // Draw concentric rings of tiles that get exponentially denser
        const rings = 6;
        for (let ring = 0; ring < rings; ring++) {
            const r = radius * (ring + 1) / (rings + 1);
            const nTiles = Math.floor(4 + ring * (2 + absK * 4)); // More tiles in outer rings

            for (let t = 0; t < nTiles; t++) {
                const angle = (t / nTiles) * Math.PI * 2;
                const nextAngle = ((t + 1) / nTiles) * Math.PI * 2;

                const innerR = ring === 0 ? 0 : radius * ring / (rings + 1);
                const outerR = r;

                // Scale inner tiles based on curvature
                const effectiveInner = innerR * (1 - absK * 0.1 * blend);

                const x1 = cx + Math.cos(angle) * effectiveInner;
                const y1 = cy + Math.sin(angle) * effectiveInner;
                const x2 = cx + Math.cos(nextAngle) * effectiveInner;
                const y2 = cy + Math.sin(nextAngle) * effectiveInner;
                const x3 = cx + Math.cos(nextAngle) * outerR;
                const y3 = cy + Math.sin(nextAngle) * outerR;
                const x4 = cx + Math.cos(angle) * outerR;
                const y4 = cy + Math.sin(angle) * outerR;

                const alpha = blend * 0.3 * (1 - ring / rings);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                if (ring === 0) {
                    ctx.lineTo(x3, y3);
                    ctx.lineTo(x4, y4);
                } else {
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.lineTo(x4, y4);
                }
                ctx.closePath();
                ctx.strokeStyle = `rgba(${col.r}, ${col.g}, ${col.b}, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Poincare disk boundary
        if (absK > 0.1) {
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${col.r}, ${col.g}, ${col.b}, ${blend * 0.5})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

function drawTriangle(cx, cy, size) {
    // Draw a triangle whose angles change with curvature
    const excess = K * 0.4; // How much angles deviate

    // Base triangle vertices
    const p1x = cx, p1y = cy - size * 0.6;
    const p2x = cx - size * 0.5, p2y = cy + size * 0.35;
    const p3x = cx + size * 0.5, p3y = cy + size * 0.35;

    // Curvature deforms the edges
    const bulge = excess * size * 0.4;

    ctx.beginPath();
    ctx.moveTo(p1x, p1y);
    // Edge 1->2: curve outward for positive K, inward for negative
    const mid12x = (p1x + p2x) / 2 - bulge * 0.5;
    const mid12y = (p1y + p2y) / 2 - bulge * 0.3;
    ctx.quadraticCurveTo(mid12x, mid12y, p2x, p2y);
    // Edge 2->3
    const mid23x = (p2x + p3x) / 2;
    const mid23y = (p2y + p3y) / 2 + bulge;
    ctx.quadraticCurveTo(mid23x, mid23y, p3x, p3y);
    // Edge 3->1
    const mid31x = (p3x + p1x) / 2 + bulge * 0.5;
    const mid31y = (p3y + p1y) / 2 - bulge * 0.3;
    ctx.quadraticCurveTo(mid31x, mid31y, p1x, p1y);

    const col = getCurvatureColor(K);
    ctx.strokeStyle = `rgb(${col.r}, ${col.g}, ${col.b})`;
    ctx.lineWidth = 2.5;
    ctx.stroke();

    ctx.fillStyle = `rgba(${col.r}, ${col.g}, ${col.b}, 0.08)`;
    ctx.fill();

    // Draw angle arcs at vertices
    const angleSum = 180 + K * 60;
    const eachAngle = angleSum / 3;
    drawAngleArc(p1x, p1y, eachAngle, Math.PI / 2 + 0.5, 15, col);
    drawAngleArc(p2x, p2y, eachAngle, -0.3, 15, col);
    drawAngleArc(p3x, p3y, eachAngle, Math.PI - 0.2, 15, col);

    // Label
    ctx.font = 'bold 13px monospace';
    ctx.fillStyle = `rgb(${col.r}, ${col.g}, ${col.b})`;
    ctx.textAlign = 'center';
    ctx.fillText(`\u2211 = ${angleSum.toFixed(0)}\u00B0`, cx, cy + size * 0.55);
}

function drawAngleArc(x, y, degrees, startAngle, radius, col) {
    const radians = degrees * Math.PI / 180;
    ctx.beginPath();
    ctx.arc(x, y, radius, startAngle, startAngle + radians * 0.02 * Math.PI);
    ctx.strokeStyle = `rgba(${col.r}, ${col.g}, ${col.b}, 0.6)`;
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawParallelLines(cx, cy, width, height) {
    const col = getCurvatureColor(K);
    const nLines = 5;
    const spacing = height / (nLines + 1);

    for (let i = 0; i < nLines; i++) {
        const baseY = cy - height / 2 + spacing * (i + 1);
        const deviation = (i - (nLines - 1) / 2) * K * width * 0.15;

        ctx.beginPath();
        const steps = 40;
        for (let s = 0; s <= steps; s++) {
            const t = s / steps;
            const x = cx - width / 2 + t * width;
            // Lines curve based on curvature and distance from center line
            const distFromCenter = (i - (nLines - 1) / 2) / ((nLines - 1) / 2);
            const curve = K * distFromCenter * Math.sin(t * Math.PI) * height * 0.3;
            const y = baseY + curve;
            if (s === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = `rgba(${col.r}, ${col.g}, ${col.b}, 0.6)`;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Label
    ctx.font = 'bold 13px monospace';
    ctx.fillStyle = `rgb(${col.r}, ${col.g}, ${col.b})`;
    ctx.textAlign = 'center';
    if (K > 0.01) ctx.fillText('Lines converge', cx, cy + height / 2 + 20);
    else if (K < -0.01) ctx.fillText('Lines diverge', cx, cy + height / 2 + 20);
    else ctx.fillText('Lines stay parallel', cx, cy + height / 2 + 20);
}

function drawCircleComparison(cx, cy, size) {
    const col = getCurvatureColor(K);

    // Draw a circle and show C/d ratio
    const r = size * 0.35;
    const ratio = Math.PI * (1 - K * 0.15);

    // The circle itself (distorted by curvature)
    ctx.beginPath();
    const steps = 60;
    for (let i = 0; i <= steps; i++) {
        const angle = (i / steps) * Math.PI * 2;
        // In curved space, circles are distorted
        const distortion = 1 + K * 0.1 * Math.sin(angle * 2);
        const x = cx + r * Math.cos(angle) * distortion;
        const y = cy + r * Math.sin(angle) * distortion;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.strokeStyle = `rgb(${col.r}, ${col.g}, ${col.b})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = `rgba(${col.r}, ${col.g}, ${col.b}, 0.06)`;
    ctx.fill();

    // Diameter line
    ctx.beginPath();
    ctx.moveTo(cx - r, cy);
    ctx.lineTo(cx + r, cy);
    ctx.strokeStyle = `rgba(${col.r}, ${col.g}, ${col.b}, 0.4)`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Label
    ctx.font = 'bold 13px monospace';
    ctx.fillStyle = `rgb(${col.r}, ${col.g}, ${col.b})`;
    ctx.textAlign = 'center';
    const symbol = K > 0 ? '< \u03C0' : (K < 0 ? '> \u03C0' : '= \u03C0');
    ctx.fillText(`C/d ${symbol} (${ratio.toFixed(3)})`, cx, cy + r + 25);
}

function animate(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    time += dt;

    if (autoAnimate) {
        K = Math.sin(time * 0.4) * Math.sin(time * 0.17); // Smooth oscillation
        curvSlider.value = K;
        updateDisplay();
    }

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Subtle background glow based on curvature
    const col = getCurvatureColor(K);
    const bgGrad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.6);
    bgGrad.addColorStop(0, `rgba(${col.r}, ${col.g}, ${col.b}, 0.04)`);
    bgGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // Layout: tessellation in center, three smaller panels around it
    const mainR = Math.min(W, H) * 0.3;
    const panelSize = Math.min(W, H) * 0.18;

    // Tessellation (center)
    if (showTiling.checked) {
        drawTessellation(W * 0.4, H * 0.45, mainR);
    }

    // Triangle (top-right area)
    if (showTriangle.checked) {
        const tx = W * 0.78, ty = H * 0.25;
        drawTriangle(tx, ty, panelSize);
    }

    // Parallel lines (middle-right)
    if (showParallel.checked) {
        const px = W * 0.78, py = H * 0.55;
        drawParallelLines(px, py, panelSize * 1.5, panelSize * 0.8);
    }

    // Circle ratio (bottom-right)
    if (showCircle.checked) {
        const crx = W * 0.78, cry = H * 0.82;
        drawCircleComparison(crx, cry, panelSize);
    }

    // Curvature indicator bar at bottom
    const barW = W * 0.4;
    const barH = 6;
    const barX = (W - barW) / 2;
    const barY = H - 40;

    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(barX, barY, barW, barH);

    // K position marker
    const markerX = barX + (K + 1) / 2 * barW;
    ctx.fillStyle = `rgb(${col.r}, ${col.g}, ${col.b})`;
    ctx.beginPath();
    ctx.arc(markerX, barY + barH / 2, 6, 0, Math.PI * 2);
    ctx.fill();

    // Labels on bar
    ctx.font = '11px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(100, 160, 255, 0.5)';
    ctx.fillText('Hyperbolic', barX + barW * 0.1, barY - 8);
    ctx.fillText('Flat', barX + barW * 0.5, barY - 8);
    ctx.fillText('Spherical', barX + barW * 0.9, barY - 8);

    // Tick marks
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    for (let v = -1; v <= 1; v += 0.5) {
        const tx = barX + (v + 1) / 2 * barW;
        ctx.beginPath(); ctx.moveTo(tx, barY - 3); ctx.lineTo(tx, barY + barH + 3); ctx.stroke();
    }

    requestAnimationFrame(animate);
}

function resetAll() {
    K = 0; curvSlider.value = 0;
    autoAnimate = true; autoCheck.checked = true;
    time = 0;
    showTiling.checked = true;
    showTriangle.checked = true;
    showParallel.checked = true;
    showCircle.checked = true;
    updateDisplay();
}

document.getElementById('resetBtn').onclick = resetAll;
window.reset = resetAll;

updateDisplay();
requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>