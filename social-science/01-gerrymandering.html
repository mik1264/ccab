<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerrymandering Simulator - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); min-height: 100vh; font-family: system-ui, sans-serif; color: #e2e8f0; overflow: hidden; }
        .back-link { position: fixed; top: 15px; left: 15px; padding: 10px 18px; background: rgba(0,0,0,0.6); color: #38bdf8; text-decoration: none; border-radius: 8px; font-size: 14px; z-index: 1000; border: 1px solid rgba(56,189,248,0.3); transition: all 0.2s; }
        .back-link:hover { background: rgba(56,189,248,0.2); transform: translateX(-2px); }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #panel { position: fixed; right: 0; top: 0; width: 320px; height: 100%; background: rgba(15, 23, 42, 0.95); padding: 70px 20px 20px; border-left: 1px solid rgba(56,189,248,0.2); overflow-y: auto; backdrop-filter: blur(10px); }
        
        h1 { font-size: 1.4rem; margin-bottom: 10px; color: #38bdf8; font-weight: 600; }
        .desc { font-size: 0.9rem; line-height: 1.6; color: #94a3b8; margin-bottom: 20px; border-bottom: 1px solid rgba(56,189,248,0.1); padding-bottom: 15px; }
        
        .stat-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 20px 0; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; }
        .stat { text-align: center; }
        .stat-value { font-size: 1.2rem; color: #38bdf8; font-weight: 700; }
        .stat-label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; margin-top: 4px; }
        
        .info-box { background: rgba(56,189,248,0.05); border: 1px solid rgba(56,189,248,0.1); border-radius: 8px; padding: 15px; font-size: 0.85rem; line-height: 1.6; color: #cbd5e1; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <canvas id="canvas"></canvas>
    <div id="panel">
        <h1>Gerrymandering</h1>
        <p class="desc">Draw district lines to change the election outcome. Try to make the Blue party win despite having fewer votes.</p>
        
        <div class="controls">
            <button onclick="resetGrid()" style="width:100%; padding:10px; background:#3b82f6; color:white; border:none; border-radius:6px; cursor:pointer;">Reset Grid</button>
        </div>

        <div class="stat-row">
            <div class="stat"><div class="stat-value" id="blueWins">0</div><div class="stat-label">Blue Districts</div></div>
            <div class="stat"><div class="stat-value" id="redWins">0</div><div class="stat-label">Red Districts</div></div>
        </div>
        
        <div class="info-box">
            <b>Strategies:</b><br>
            • <i>Packing:</i> Concentrate opponents into a few districts.<br>
            • <i>Cracking:</i> Spread opponents thinly across many districts.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        const GRID_SIZE = 10;
        const CELL_SIZE = 40;
        let grid = []; // 0 = Blue, 1 = Red
        let districts = []; // Array of {cells: [], winner: 0/1}
        let isDrawing = false;
        let currentDistrict = [];

        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            resetGrid();
        }

        function resetGrid() {
            grid = [];
            // Create a 60% Red, 40% Blue population
            for(let y=0; y<GRID_SIZE; y++) {
                let row = [];
                for(let x=0; x<GRID_SIZE; x++) {
                    row.push(Math.random() > 0.4 ? 1 : 0);
                }
                grid.push(row);
            }
            districts = [];
            currentDistrict = [];
            draw();
        }

        function getCell(x, y) {
            const offsetX = (width - GRID_SIZE * CELL_SIZE) / 2;
            const offsetY = (height - GRID_SIZE * CELL_SIZE) / 2;
            const gx = Math.floor((x - offsetX) / CELL_SIZE);
            const gy = Math.floor((y - offsetY) / CELL_SIZE);
            if(gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) return {x: gx, y: gy};
            return null;
        }

        function draw() {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            const offsetX = (width - GRID_SIZE * CELL_SIZE) / 2;
            const offsetY = (height - GRID_SIZE * CELL_SIZE) / 2;

            // Draw Grid
            for(let y=0; y<GRID_SIZE; y++) {
                for(let x=0; x<GRID_SIZE; x++) {
                    const type = grid[y][x];
                    ctx.fillStyle = type === 0 ? '#3b82f6' : '#ef4444';
                    
                    // Check if in a district
                    let inDistrict = districts.find(d => d.cells.some(c => c.x === x && c.y === y));
                    let inCurrent = currentDistrict.some(c => c.x === x && c.y === y);
                    
                    if(inDistrict) ctx.globalAlpha = 0.3;
                    else if(inCurrent) ctx.globalAlpha = 0.8;
                    else ctx.globalAlpha = 1.0;

                    ctx.beginPath();
                    ctx.roundRect(offsetX + x*CELL_SIZE + 2, offsetY + y*CELL_SIZE + 2, CELL_SIZE-4, CELL_SIZE-4, 4);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Population dot
                    ctx.fillStyle = type === 0 ? '#93c5fd' : '#fca5a5';
                    ctx.beginPath();
                    ctx.arc(offsetX + x*CELL_SIZE + CELL_SIZE/2, offsetY + y*CELL_SIZE + CELL_SIZE/2, 6, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // Draw District Borders
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            [...districts, {cells: currentDistrict}].forEach(d => {
                if(d.cells.length === 0) return;
                // Simple hull drawing (just connections for now)
                ctx.beginPath();
                d.cells.forEach(c => {
                    ctx.rect(offsetX + c.x*CELL_SIZE, offsetY + c.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
                ctx.stroke();
            });
            
            updateStats();
        }

        function updateStats() {
            let blue = 0, red = 0;
            districts.forEach(d => {
                let bCount = d.cells.filter(c => grid[c.y][c.x] === 0).length;
                let rCount = d.cells.filter(c => grid[c.y][c.x] === 1).length;
                if(bCount > rCount) blue++;
                else if(rCount > bCount) red++;
            });
            document.getElementById('blueWins').textContent = blue;
            document.getElementById('redWins').textContent = red;
        }

        // Interaction
        canvas.addEventListener('mousedown', e => {
            isDrawing = true;
            const c = getCell(e.clientX, e.clientY);
            if(c) handleInput(c);
        });
        
        canvas.addEventListener('mousemove', e => {
            if(!isDrawing) return;
            const c = getCell(e.clientX, e.clientY);
            if(c) handleInput(c);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            if(currentDistrict.length > 0) {
                districts.push({cells: [...currentDistrict]});
                currentDistrict = [];
                draw();
            }
        });

        function handleInput(cell) {
            // Remove from existing districts if needed
            districts = districts.filter(d => {
                d.cells = d.cells.filter(c => c.x !== cell.x || c.y !== cell.y);
                return d.cells.length > 0;
            });
            
            // Add to current if not present
            if(!currentDistrict.some(c => c.x === cell.x && c.y === cell.y)) {
                currentDistrict.push(cell);
                draw();
            }
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
