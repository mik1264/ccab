<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain - Voronoi Biomes</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #333; cursor: pointer; }
        .info { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; font-family: Arial; }
    </style>
</head>
<body>
    <div class="info">Click to regenerate terrain</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        const BIOMES = {
            OCEAN: { color: [30, 60, 120], name: 'Ocean' },
            BEACH: { color: [194, 178, 128], name: 'Beach' },
            DESERT: { color: [210, 180, 140], name: 'Desert' },
            GRASSLAND: { color: [80, 160, 80], name: 'Grassland' },
            FOREST: { color: [34, 100, 34], name: 'Forest' },
            RAINFOREST: { color: [20, 80, 20], name: 'Rainforest' },
            TUNDRA: { color: [150, 150, 170], name: 'Tundra' },
            SNOW: { color: [240, 240, 255], name: 'Snow' },
            MOUNTAIN: { color: [100, 100, 100], name: 'Mountain' }
        };

        function generatePoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    elevation: Math.random(),
                    moisture: Math.random(),
                    temperature: Math.random()
                });
            }
            return points;
        }

        function getBiome(elevation, moisture, temperature) {
            if (elevation < 0.25) return BIOMES.OCEAN;
            if (elevation < 0.28) return BIOMES.BEACH;

            if (elevation > 0.75) {
                if (temperature < 0.3) return BIOMES.SNOW;
                return BIOMES.MOUNTAIN;
            }

            if (temperature < 0.2) return BIOMES.TUNDRA;
            if (temperature > 0.8 && moisture > 0.7) return BIOMES.RAINFOREST;
            if (temperature > 0.7 && moisture < 0.3) return BIOMES.DESERT;
            if (moisture > 0.5) return BIOMES.FOREST;
            return BIOMES.GRASSLAND;
        }

        function distance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function render(points) {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    let closestDist = Infinity;
                    let secondClosestDist = Infinity;
                    let closestPoint = null;

                    for (const point of points) {
                        const dist = distance(x, y, point.x, point.y);
                        if (dist < closestDist) {
                            secondClosestDist = closestDist;
                            closestDist = dist;
                            closestPoint = point;
                        } else if (dist < secondClosestDist) {
                            secondClosestDist = dist;
                        }
                    }

                    // Edge detection for borders
                    const edgeFactor = (secondClosestDist - closestDist) < 3 ? 0.5 : 1.0;

                    const biome = getBiome(closestPoint.elevation, closestPoint.moisture, closestPoint.temperature);
                    const idx = (y * canvas.width + x) * 4;

                    data[idx] = biome.color[0] * edgeFactor;
                    data[idx + 1] = biome.color[1] * edgeFactor;
                    data[idx + 2] = biome.color[2] * edgeFactor;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw rivers
            ctx.strokeStyle = 'rgba(50, 100, 200, 0.6)';
            ctx.lineWidth = 2;
            for (const point of points) {
                if (point.elevation > 0.5 && point.moisture > 0.7) {
                    let currentPoint = point;
                    ctx.beginPath();
                    ctx.moveTo(currentPoint.x, currentPoint.y);

                    for (let i = 0; i < 20; i++) {
                        let lowestNeighbor = null;
                        let lowestElevation = currentPoint.elevation;

                        for (const neighbor of points) {
                            if (neighbor === currentPoint) continue;
                            const dist = distance(currentPoint.x, currentPoint.y, neighbor.x, neighbor.y);
                            if (dist < 50 && neighbor.elevation < lowestElevation) {
                                lowestElevation = neighbor.elevation;
                                lowestNeighbor = neighbor;
                            }
                        }

                        if (lowestNeighbor && lowestNeighbor.elevation > 0.25) {
                            ctx.lineTo(lowestNeighbor.x, lowestNeighbor.y);
                            currentPoint = lowestNeighbor;
                        } else {
                            break;
                        }
                    }
                    ctx.stroke();
                }
            }
        }

        let points = generatePoints(150);
        render(points);

        canvas.addEventListener('click', () => {
            points = generatePoints(150);
            render(points);
        });
    </script>
</body>
</html>
