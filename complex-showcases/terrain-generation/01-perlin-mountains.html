<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Generation - Perlin Noise Mountains</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #333; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        canvas.width = 800;
        canvas.height = 600;

        class PerlinNoise {
            constructor() {
                this.perm = [];
                for (let i = 0; i < 256; i++) this.perm[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                this.perm = this.perm.concat(this.perm);
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                const A = this.perm[X] + Y;
                const AA = this.perm[A] + Z;
                const AB = this.perm[A + 1] + Z;
                const B = this.perm[X + 1] + Y;
                const BA = this.perm[B] + Z;
                const BB = this.perm[B + 1] + Z;

                return this.lerp(w,
                    this.lerp(v, this.lerp(u, this.grad(this.perm[AA], x, y, z), this.grad(this.perm[BA], x - 1, y, z)),
                             this.lerp(u, this.grad(this.perm[AB], x, y - 1, z), this.grad(this.perm[BB], x - 1, y - 1, z))),
                    this.lerp(v, this.lerp(u, this.grad(this.perm[AA + 1], x, y, z - 1), this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
                             this.lerp(u, this.grad(this.perm[AB + 1], x, y - 1, z - 1), this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1))));
            }
        }

        const perlin = new PerlinNoise();
        const SIZE = 128;
        const vertices = [];
        const indices = [];
        const colors = [];

        for (let z = 0; z < SIZE; z++) {
            for (let x = 0; x < SIZE; x++) {
                let height = 0;
                let amplitude = 1;
                let frequency = 1;
                for (let i = 0; i < 6; i++) {
                    height += perlin.noise(x * 0.01 * frequency, z * 0.01 * frequency, 0) * amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                height *= 30;

                vertices.push((x - SIZE / 2) / 10, height / 10, (z - SIZE / 2) / 10);

                const normHeight = (height + 30) / 60;
                if (normHeight < 0.3) colors.push(0.2, 0.4, 0.8); // Water
                else if (normHeight < 0.4) colors.push(0.8, 0.7, 0.4); // Beach
                else if (normHeight < 0.7) colors.push(0.3, 0.6, 0.3); // Grass
                else if (normHeight < 0.8) colors.push(0.5, 0.5, 0.5); // Rock
                else colors.push(1.0, 1.0, 1.0); // Snow
            }
        }

        for (let z = 0; z < SIZE - 1; z++) {
            for (let x = 0; x < SIZE - 1; x++) {
                const topLeft = z * SIZE + x;
                const topRight = topLeft + 1;
                const bottomLeft = (z + 1) * SIZE + x;
                const bottomRight = bottomLeft + 1;
                indices.push(topLeft, bottomLeft, topRight, topRight, bottomLeft, bottomRight);
            }
        }

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `
            attribute vec3 position;
            attribute vec3 color;
            uniform mat4 projection;
            uniform mat4 view;
            varying vec3 vColor;
            void main() {
                gl_Position = projection * view * vec4(position, 1.0);
                vColor = color;
            }
        `);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        const colorLoc = gl.getAttribLocation(program, 'color');
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        const projectionLoc = gl.getUniformLocation(program, 'projection');
        const viewLoc = gl.getUniformLocation(program, 'view');

        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return [f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) / (near - far), -1, 0, 0, (2 * far * near) / (near - far), 0];
        }

        function lookAt(eye, center, up) {
            const z = [eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]];
            const zLen = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
            z[0] /= zLen; z[1] /= zLen; z[2] /= zLen;
            const x = [up[1] * z[2] - up[2] * z[1], up[2] * z[0] - up[0] * z[2], up[0] * z[1] - up[1] * z[0]];
            const xLen = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
            x[0] /= xLen; x[1] /= xLen; x[2] /= xLen;
            const y = [z[1] * x[2] - z[2] * x[1], z[2] * x[0] - z[0] * x[2], z[0] * x[1] - z[1] * x[0]];
            return [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -x[0] * eye[0] - x[1] * eye[1] - x[2] * eye[2], -y[0] * eye[0] - y[1] * eye[1] - y[2] * eye[2], -z[0] * eye[0] - z[1] * eye[1] - z[2] * eye[2], 1];
        }

        gl.enable(gl.DEPTH_TEST);

        function render() {
            const time = Date.now() * 0.0003;
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const projection = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
            const eye = [Math.cos(time) * 20, 15, Math.sin(time) * 20];
            const view = lookAt(eye, [0, 0, 0], [0, 1, 0]);

            gl.uniformMatrix4fv(projectionLoc, false, projection);
            gl.uniformMatrix4fv(viewLoc, false, view);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
