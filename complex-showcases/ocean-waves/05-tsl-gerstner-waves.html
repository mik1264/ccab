<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Waves - TSL Enhanced Gerstner Waves</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(#001122, #003355);
            font-family: Arial, sans-serif;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
        }
        .info h3 {
            margin: 0 0 10px 0;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>TSL Gerstner Waves</h3>
        <p>GPU-accelerated realistic ocean simulation</p>
        <p style="font-size: 11px; opacity: 0.8;">Multiple wave frequencies • Procedural foam • Real-time TSL shading</p>
    </div>
    <div class="tech-badge">Three.js TSL • Gerstner Waves • PBR Materials</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            color,
            positionLocal,
            normalLocal,
            timerLocal,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            dot,
            normalize,
            vec2,
            vec3,
            vec4,
            float,
            length,
            fract,
            abs,
            pow
        } from 'three/nodes';
        import { mx_fractal_noise_float } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 25, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 200;
        controls.maxPolarAngle = Math.PI / 2.1;

        // Create ocean plane
        const oceanGeometry = new THREE.PlaneGeometry(400, 400, 512, 512);

        // TSL-based ocean material
        const oceanMaterial = new THREE.MeshStandardNodeMaterial({
            roughness: 0.1,
            metalness: 0.1
        });

        const time = timerLocal();
        const pos = positionLocal;
        const norm = normalLocal;

        // Gerstner wave function in TSL
        // Wave parameters: wavelength, amplitude, direction (angle)
        const PI = float(Math.PI);
        const TWO_PI = float(Math.PI * 2);

        // Wave 1: Large swells
        const wavelength1 = float(60);
        const amplitude1 = float(3);
        const direction1 = float(0);
        const k1 = mul(TWO_PI, float(1.0 / 60));
        const speed1 = mul(float(2), k1);

        const dirVec1 = vec2(cos(direction1), sin(direction1));
        const phase1 = add(mul(dot(vec2(pos.x, pos.z), dirVec1), k1), mul(time, speed1));
        const wave1X = mul(amplitude1, mul(dirVec1.x, sin(phase1)));
        const wave1Y = mul(amplitude1, cos(phase1));
        const wave1Z = mul(amplitude1, mul(dirVec1.y, sin(phase1)));

        // Wave 2: Medium waves
        const wavelength2 = float(35);
        const amplitude2 = float(1.5);
        const direction2 = float(1.2);
        const k2 = mul(TWO_PI, float(1.0 / 35));
        const speed2 = mul(float(2.5), k2);

        const dirVec2 = vec2(cos(direction2), sin(direction2));
        const phase2 = add(mul(dot(vec2(pos.x, pos.z), dirVec2), k2), mul(time, speed2));
        const wave2X = mul(amplitude2, mul(dirVec2.x, sin(phase2)));
        const wave2Y = mul(amplitude2, cos(phase2));
        const wave2Z = mul(amplitude2, mul(dirVec2.y, sin(phase2)));

        // Wave 3: Small ripples
        const wavelength3 = float(20);
        const amplitude3 = float(0.8);
        const direction3 = float(2.8);
        const k3 = mul(TWO_PI, float(1.0 / 20));
        const speed3 = mul(float(3), k3);

        const dirVec3 = vec2(cos(direction3), sin(direction3));
        const phase3 = add(mul(dot(vec2(pos.x, pos.z), dirVec3), k3), mul(time, speed3));
        const wave3X = mul(amplitude3, mul(dirVec3.x, sin(phase3)));
        const wave3Y = mul(amplitude3, cos(phase3));
        const wave3Z = mul(amplitude3, mul(dirVec3.y, sin(phase3)));

        // Wave 4: Tiny details
        const wavelength4 = float(12);
        const amplitude4 = float(0.4);
        const direction4 = float(4.5);
        const k4 = mul(TWO_PI, float(1.0 / 12));
        const speed4 = mul(float(3.5), k4);

        const dirVec4 = vec2(cos(direction4), sin(direction4));
        const phase4 = add(mul(dot(vec2(pos.x, pos.z), dirVec4), k4), mul(time, speed4));
        const wave4X = mul(amplitude4, mul(dirVec4.x, sin(phase4)));
        const wave4Y = mul(amplitude4, cos(phase4));
        const wave4Z = mul(amplitude4, mul(dirVec4.y, sin(phase4)));

        // Combine all waves
        const totalX = add(wave1X, wave2X, wave3X, wave4X);
        const totalY = add(wave1Y, wave2Y, wave3Y, wave4Y);
        const totalZ = add(wave1Z, wave2Z, wave3Z, wave4Z);

        const finalPos = vec3(add(pos.x, totalX), totalY, add(pos.z, totalZ));
        oceanMaterial.positionNode = finalPos;

        // Dynamic ocean color
        const deepWater = vec3(float(0.0), float(0.15), float(0.4));
        const shallowWater = vec3(float(0.0), float(0.5), float(0.8));

        // Height-based color mixing
        const heightFactor = smoothstep(float(-3), float(3), totalY);
        let oceanColor = mix(deepWater, shallowWater, heightFactor);

        // Add foam on wave peaks
        const foamThreshold = smoothstep(float(2), float(3.5), totalY);
        const foamColor = vec3(float(0.9), float(0.95), float(1.0));
        oceanColor = mix(oceanColor, foamColor, foamThreshold);

        // Add noise-based detail
        const noisePos = mul(vec3(pos.x, pos.z, time), float(0.02));
        const detailNoise = mx_fractal_noise_float(noisePos, float(3), float(2.0), float(0.5));
        const noiseTint = mul(detailNoise, float(0.1));
        oceanColor = add(oceanColor, vec3(noiseTint, noiseTint, noiseTint));

        oceanMaterial.colorNode = oceanColor;

        // Transparency based on depth
        const transparency = smoothstep(float(-2), float(1), totalY);
        oceanMaterial.transparent = true;
        oceanMaterial.opacity = 0.95;

        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        scene.add(ocean);

        // Add sky
        const skyGeometry = new THREE.SphereGeometry(450, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide,
            fog: false
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Add sun
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 100, 50);
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.6);
        scene.add(ambientLight);

        // Add sun sphere
        const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffcc });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.copy(sunLight.position);
        scene.add(sun);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
