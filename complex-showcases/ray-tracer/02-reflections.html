<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Tracer - Reflections & Refractions</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        canvas.width = 800;
        canvas.height = 600;

        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_uv;

            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;

            in vec2 v_uv;
            out vec4 fragColor;

            uniform float u_time;
            uniform vec2 u_resolution;

            const int MAX_BOUNCES = 4;

            struct Ray {
                vec3 origin;
                vec3 direction;
            };

            struct Material {
                vec3 color;
                float metallic;
                float roughness;
                float ior;
            };

            struct Sphere {
                vec3 center;
                float radius;
                Material material;
            };

            struct HitRecord {
                bool hit;
                float t;
                vec3 point;
                vec3 normal;
                Material material;
            };

            float intersectSphere(Ray ray, Sphere sphere) {
                vec3 oc = ray.origin - sphere.center;
                float a = dot(ray.direction, ray.direction);
                float b = 2.0 * dot(oc, ray.direction);
                float c = dot(oc, oc) - sphere.radius * sphere.radius;
                float discriminant = b * b - 4.0 * a * c;

                if (discriminant < 0.0) return -1.0;

                float temp = (-b - sqrt(discriminant)) / (2.0 * a);
                if (temp > 0.001) return temp;

                temp = (-b + sqrt(discriminant)) / (2.0 * a);
                if (temp > 0.001) return temp;

                return -1.0;
            }

            HitRecord trace(Ray ray, Sphere[6] spheres) {
                HitRecord closest;
                closest.hit = false;
                closest.t = 1e10;

                for (int i = 0; i < 6; i++) {
                    float t = intersectSphere(ray, spheres[i]);
                    if (t > 0.0 && t < closest.t) {
                        closest.hit = true;
                        closest.t = t;
                        closest.point = ray.origin + ray.direction * t;
                        closest.normal = normalize(closest.point - spheres[i].center);
                        closest.material = spheres[i].material;
                    }
                }

                return closest;
            }

            vec3 reflect(vec3 v, vec3 n) {
                return v - 2.0 * dot(v, n) * n;
            }

            vec3 refract(vec3 uv, vec3 n, float etai_over_etat) {
                float cos_theta = min(dot(-uv, n), 1.0);
                vec3 r_out_perp = etai_over_etat * (uv + cos_theta * n);
                vec3 r_out_parallel = -sqrt(abs(1.0 - dot(r_out_perp, r_out_perp))) * n;
                return r_out_perp + r_out_parallel;
            }

            float schlick(float cosine, float ior) {
                float r0 = (1.0 - ior) / (1.0 + ior);
                r0 = r0 * r0;
                return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
            }

            vec3 rayColor(Ray initialRay, Sphere[6] spheres, vec3 lightPos) {
                vec3 color = vec3(1.0);
                Ray ray = initialRay;

                for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
                    HitRecord hit = trace(ray, spheres);

                    if (!hit.hit) {
                        // Sky gradient
                        float t = 0.5 * (ray.direction.y + 1.0);
                        vec3 skyColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
                        return color * skyColor * 0.5;
                    }

                    // Lighting
                    vec3 lightDir = normalize(lightPos - hit.point);
                    float diff = max(dot(hit.normal, lightDir), 0.0);

                    vec3 viewDir = normalize(-ray.direction);
                    vec3 halfDir = normalize(lightDir + viewDir);
                    float spec = pow(max(dot(hit.normal, halfDir), 0.0), 32.0);

                    vec3 ambient = 0.1 * hit.material.color;
                    vec3 diffuse = diff * hit.material.color;
                    vec3 specular = spec * vec3(1.0);

                    color *= mix(ambient + diffuse, specular, hit.material.metallic);

                    // Reflection
                    if (hit.material.metallic > 0.5) {
                        ray.origin = hit.point + hit.normal * 0.001;
                        ray.direction = reflect(ray.direction, hit.normal);
                    } else {
                        break;
                    }
                }

                return color;
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

                // Camera
                float angle = u_time * 0.3;
                vec3 cameraPos = vec3(6.0 * cos(angle), 2.0, 6.0 * sin(angle));
                vec3 cameraTarget = vec3(0.0, 0.0, 0.0);
                vec3 cameraUp = vec3(0.0, 1.0, 0.0);

                vec3 cameraDir = normalize(cameraTarget - cameraPos);
                vec3 cameraRight = normalize(cross(cameraDir, cameraUp));
                vec3 cameraActualUp = cross(cameraRight, cameraDir);

                Ray ray;
                ray.origin = cameraPos;
                ray.direction = normalize(cameraDir + uv.x * cameraRight + uv.y * cameraActualUp);

                // Scene
                float t = u_time;
                Sphere spheres[6];

                // Center metallic sphere
                spheres[0].center = vec3(0.0, 0.0, 0.0);
                spheres[0].radius = 1.0;
                spheres[0].material.color = vec3(0.9, 0.9, 0.95);
                spheres[0].material.metallic = 0.95;
                spheres[0].material.roughness = 0.05;

                // Orbiting spheres
                spheres[1].center = vec3(2.5 * cos(t), 0.0, 2.5 * sin(t));
                spheres[1].radius = 0.5;
                spheres[1].material.color = vec3(1.0, 0.3, 0.3);
                spheres[1].material.metallic = 0.8;

                spheres[2].center = vec3(2.5 * cos(t + 2.094), 0.0, 2.5 * sin(t + 2.094));
                spheres[2].radius = 0.5;
                spheres[2].material.color = vec3(0.3, 1.0, 0.3);
                spheres[2].material.metallic = 0.8;

                spheres[3].center = vec3(2.5 * cos(t + 4.189), 0.0, 2.5 * sin(t + 4.189));
                spheres[3].radius = 0.5;
                spheres[3].material.color = vec3(0.3, 0.3, 1.0);
                spheres[3].material.metallic = 0.8;

                // Small gold sphere
                spheres[4].center = vec3(0.0, 1.5, 0.0);
                spheres[4].radius = 0.4;
                spheres[4].material.color = vec3(1.0, 0.84, 0.0);
                spheres[4].material.metallic = 1.0;

                // Ground plane (large sphere)
                spheres[5].center = vec3(0.0, -1001.0, 0.0);
                spheres[5].radius = 1000.0;
                spheres[5].material.color = vec3(0.4, 0.4, 0.45);
                spheres[5].material.metallic = 0.3;

                vec3 lightPos = vec3(10.0, 10.0, 10.0);
                vec3 color = rayColor(ray, spheres, lightPos);

                // Tone mapping
                color = color / (color + vec3(1.0));

                // Gamma correction
                color = pow(color, vec3(1.0 / 2.2));

                fragColor = vec4(color, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }

            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
        const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        function render(time) {
            time *= 0.001;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform1f(timeUniformLocation, time);
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
