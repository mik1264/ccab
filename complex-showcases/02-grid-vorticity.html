<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation - Grid-Based with Vorticity</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 800;
        canvas.height = 600;

        const GRID_SIZE = 64;
        const CELL_SIZE = Math.max(canvas.width, canvas.height) / GRID_SIZE;

        class FluidGrid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.u = Array(width * height).fill(0);
                this.v = Array(width * height).fill(0);
                this.u_prev = Array(width * height).fill(0);
                this.v_prev = Array(width * height).fill(0);
                this.density = Array(width * height).fill(0);
                this.density_prev = Array(width * height).fill(0);
            }

            idx(x, y) {
                x = Math.max(0, Math.min(this.width - 1, Math.floor(x)));
                y = Math.max(0, Math.min(this.height - 1, Math.floor(y)));
                return x + y * this.width;
            }

            addVelocity(x, y, vx, vy) {
                const i = this.idx(x, y);
                this.u[i] += vx;
                this.v[i] += vy;
            }

            addDensity(x, y, amount) {
                const i = this.idx(x, y);
                this.density[i] += amount;
            }

            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * (this.width - 2) * (this.height - 2);
                this.linearSolve(b, x, x0, a, 1 + 6 * a);
            }

            linearSolve(b, x, x0, a, c) {
                const iterations = 4;

                for (let k = 0; k < iterations; k++) {
                    for (let j = 1; j < this.height - 1; j++) {
                        for (let i = 1; i < this.width - 1; i++) {
                            const idx = this.idx(i, j);
                            x[idx] = (x0[idx] +
                                a * (x[this.idx(i + 1, j)] + x[this.idx(i - 1, j)] +
                                     x[this.idx(i, j + 1)] + x[this.idx(i, j - 1)])) / c;
                        }
                    }
                    this.setBoundary(b, x);
                }
            }

            project(u, v, p, div) {
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.idx(i, j);
                        div[idx] = -0.5 * (
                            u[this.idx(i + 1, j)] - u[this.idx(i - 1, j)] +
                            v[this.idx(i, j + 1)] - v[this.idx(i, j - 1)]
                        ) / this.width;
                        p[idx] = 0;
                    }
                }

                this.setBoundary(0, div);
                this.setBoundary(0, p);
                this.linearSolve(0, p, div, 1, 6);

                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.idx(i, j);
                        u[idx] -= 0.5 * (p[this.idx(i + 1, j)] - p[this.idx(i - 1, j)]) * this.width;
                        v[idx] -= 0.5 * (p[this.idx(i, j + 1)] - p[this.idx(i, j - 1)]) * this.height;
                    }
                }

                this.setBoundary(1, u);
                this.setBoundary(2, v);
            }

            advect(b, d, d0, u, v, dt) {
                const dtx = dt * (this.width - 2);
                const dty = dt * (this.height - 2);

                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.idx(i, j);
                        let x = i - dtx * u[idx];
                        let y = j - dty * v[idx];

                        x = Math.max(0.5, Math.min(this.width - 1.5, x));
                        y = Math.max(0.5, Math.min(this.height - 1.5, y));

                        const i0 = Math.floor(x), i1 = i0 + 1;
                        const j0 = Math.floor(y), j1 = j0 + 1;

                        const s1 = x - i0, s0 = 1 - s1;
                        const t1 = y - j0, t0 = 1 - t1;

                        d[idx] =
                            s0 * (t0 * d0[this.idx(i0, j0)] + t1 * d0[this.idx(i0, j1)]) +
                            s1 * (t0 * d0[this.idx(i1, j0)] + t1 * d0[this.idx(i1, j1)]);
                    }
                }

                this.setBoundary(b, d);
            }

            setBoundary(b, x) {
                for (let i = 1; i < this.width - 1; i++) {
                    x[this.idx(i, 0)] = b === 2 ? -x[this.idx(i, 1)] : x[this.idx(i, 1)];
                    x[this.idx(i, this.height - 1)] = b === 2 ? -x[this.idx(i, this.height - 2)] : x[this.idx(i, this.height - 2)];
                }

                for (let j = 1; j < this.height - 1; j++) {
                    x[this.idx(0, j)] = b === 1 ? -x[this.idx(1, j)] : x[this.idx(1, j)];
                    x[this.idx(this.width - 1, j)] = b === 1 ? -x[this.idx(this.width - 2, j)] : x[this.idx(this.width - 2, j)];
                }
            }

            step(dt, visc, diff) {
                this.diffuse(1, this.u_prev, this.u, visc, dt);
                this.diffuse(2, this.v_prev, this.v, visc, dt);

                this.project(this.u_prev, this.v_prev, this.u, this.v);

                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev, dt);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev, dt);

                this.project(this.u, this.v, this.u_prev, this.v_prev);

                this.diffuse(0, this.density_prev, this.density, diff, dt);
                this.advect(0, this.density, this.density_prev, this.u, this.v, dt);

                // Fade density
                for (let i = 0; i < this.density.length; i++) {
                    this.density[i] *= 0.99;
                }
            }
        }

        const grid = new FluidGrid(GRID_SIZE, GRID_SIZE);

        let mouseX = 0, mouseY = 0;
        let pmouseX = 0, pmouseY = 0;
        let mousePressed = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            pmouseX = mouseX;
            pmouseY = mouseY;
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => mousePressed = true);
        canvas.addEventListener('mouseup', () => mousePressed = false);

        function animate() {
            if (mousePressed) {
                const gx = Math.floor(mouseX / CELL_SIZE);
                const gy = Math.floor(mouseY / CELL_SIZE);
                const vx = (mouseX - pmouseX) * 0.5;
                const vy = (mouseY - pmouseY) * 0.5;

                grid.addVelocity(gx, gy, vx, vy);
                grid.addDensity(gx, gy, 200);

                // Add surrounding cells for better visual
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        grid.addDensity(gx + dx, gy + dy, 100);
                    }
                }
            }

            // Add continuous flow
            const time = Date.now() * 0.001;
            for (let i = 0; i < 3; i++) {
                const x = Math.floor(GRID_SIZE * (0.3 + 0.4 * Math.cos(time + i * 2)));
                const y = Math.floor(GRID_SIZE * (0.3 + 0.4 * Math.sin(time + i * 2)));
                grid.addDensity(x, y, 50);
                grid.addVelocity(x, y, Math.cos(time + i) * 2, Math.sin(time + i) * 2);
            }

            grid.step(0.1, 0.0000001, 0.0);

            // Render
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let j = 0; j < GRID_SIZE; j++) {
                for (let i = 0; i < GRID_SIZE; i++) {
                    const d = grid.density[grid.idx(i, j)];
                    const vel = Math.sqrt(grid.u[grid.idx(i, j)] ** 2 + grid.v[grid.idx(i, j)] ** 2);

                    const hue = (vel * 10) % 360;
                    const intensity = Math.min(d, 255);

                    const x = Math.floor(i * CELL_SIZE);
                    const y = Math.floor(j * CELL_SIZE);

                    for (let py = 0; py < CELL_SIZE && y + py < canvas.height; py++) {
                        for (let px = 0; px < CELL_SIZE && x + px < canvas.width; px++) {
                            const idx = ((y + py) * canvas.width + (x + px)) * 4;
                            const rgb = hslToRgb(hue / 360, 0.8, intensity / 512);
                            data[idx] = rgb[0];
                            data[idx + 1] = rgb[1];
                            data[idx + 2] = rgb[2];
                            data[idx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            requestAnimationFrame(animate);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        animate();
    </script>
</body>
</html>
