<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction-Diffusion - Turing Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #simCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            touch-action: none;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s;
        }

        .controls:hover {
            opacity: 1;
            background: rgba(20, 20, 30, 0.95);
        }

        .controls h2 {
            margin-bottom: 5px;
            font-size: 24px;
            background: linear-gradient(135deg, #00f260 0%, #0575e6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls .description {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #ccc;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            margin-bottom: 5px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00f260 0%, #0575e6 100%);
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 0 10px rgba(5, 117, 230, 0.5);
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
        }

        .control-group select:hover {
            border-color: #0575e6;
        }

        .control-group span {
            display: inline-block;
            float: right;
            color: #00f260;
            font-family: monospace;
            font-size: 12px;
        }

        #clearBtn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #00f260 0%, #0575e6 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #clearBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(5, 117, 230, 0.6);
        }

        #clearBtn:active {
            transform: translateY(0);
        }

        .info {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: #888;
            line-height: 1.5;
        }

        .info ul {
            list-style: none;
            padding-left: 0;
            margin-top: 5px;
        }

        .info li {
            padding: 2px 0;
            padding-left: 15px;
            position: relative;
        }

        .info li:before {
            content: "â€º";
            position: absolute;
            left: 0;
            color: #00f260;
            font-weight: bold;
        }

        /* Scrollbar styling */
        .controls::-webkit-scrollbar {
            width: 6px;
        }

        .controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
        }

        .controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .controls::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .controls {
                top: auto;
                bottom: 0;
                right: 0;
                left: 0;
                width: 100%;
                max-height: 40vh;
                border-radius: 12px 12px 0 0;
                padding: 15px;
            }

            .controls h2 {
                font-size: 20px;
            }
        }
    </style>
</head>

<body>
    <canvas id="simCanvas"></canvas>

    <div class="controls">
        <h2>Turing Patterns</h2>
        <p class="description">Gray-Scott Reaction-Diffusion Model</p>

        <div class="control-group">
            <label for="presetSelect">Pattern Preset:</label>
            <select id="presetSelect">
                <option value="coral" selected>Coral Growth</option>
                <option value="mitosis">Cell Mitosis</option>
                <option value="stripes">Zebra Stripes</option>
                <option value="spots">Leopard Spots</option>
                <option value="chaos">Chaotic Waves</option>
                <option value="waves">Traveling Waves</option>
            </select>
        </div>

        <div class="control-group">
            <label for="feedRate">Feed Rate (f):</label>
            <input type="range" id="feedRate" min="0.01" max="0.1" step="0.0001" value="0.0545">
            <span id="feedValue">0.0545</span>
        </div>

        <div class="control-group">
            <label for="killRate">Kill Rate (k):</label>
            <input type="range" id="killRate" min="0.01" max="0.1" step="0.0001" value="0.0620">
            <span id="killValue">0.0620</span>
        </div>

        <div class="control-group">
            <label for="diffA">Diffusion A:</label>
            <input type="range" id="diffA" min="0.1" max="1.5" step="0.01" value="1.0">
            <span id="diffAValue">1.0</span>
        </div>

        <div class="control-group">
            <label for="diffB">Diffusion B:</label>
            <input type="range" id="diffB" min="0.1" max="1.0" step="0.01" value="0.5">
            <span id="diffBValue">0.5</span>
        </div>

        <div class="control-group">
            <label for="iterations">Speed (Iterations/Frame):</label>
            <input type="range" id="iterations" min="1" max="20" step="1" value="8">
            <span id="iterValue">8</span>
        </div>

        <div class="control-group">
            <label for="brushSize">Brush Size:</label>
            <input type="range" id="brushSize" min="0.01" max="0.2" step="0.01" value="0.05">
            <span id="brushValue">0.05</span>
        </div>

        <button id="clearBtn">Reset Simulation</button>

        <div class="info">
            <p><strong>How it works:</strong></p>
            <ul>
                <li>Simulates two chemicals reacting and diffusing</li>
                <li>Click/Touch to add Chemical B</li>
                <li>Different Feed/Kill rates create different patterns</li>
            </ul>
        </div>
    </div>

    <script>
        // SHADERS
        const shaders = {
            vertex: `
                precision highp float;
                attribute vec2 aPosition;
                varying vec2 vUv;
                
                void main() {
                    vUv = aPosition * 0.5 + 0.5;
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                }
            `,
            update: `
                precision highp float;
                varying vec2 vUv;
                uniform sampler2D uTexture;
                uniform vec2 uTexelSize;
                uniform float uFeed;
                uniform float uKill;
                uniform float uDiffA;
                uniform float uDiffB;
                uniform float uDt;
                
                void main() {
                    vec4 uv = texture2D(uTexture, vUv);
                    float a = uv.r;
                    float b = uv.g;
                    
                    // Laplacian
                    vec4 uv_L = texture2D(uTexture, vUv - vec2(uTexelSize.x, 0.0));
                    vec4 uv_R = texture2D(uTexture, vUv + vec2(uTexelSize.x, 0.0));
                    vec4 uv_T = texture2D(uTexture, vUv + vec2(0.0, uTexelSize.y));
                    vec4 uv_B = texture2D(uTexture, vUv - vec2(0.0, uTexelSize.y));
                    
                    // Diagonal neighbors for better isotropy
                    vec4 uv_LT = texture2D(uTexture, vUv + vec2(-uTexelSize.x, uTexelSize.y));
                    vec4 uv_RT = texture2D(uTexture, vUv + vec2(uTexelSize.x, uTexelSize.y));
                    vec4 uv_LB = texture2D(uTexture, vUv + vec2(-uTexelSize.x, -uTexelSize.y));
                    vec4 uv_RB = texture2D(uTexture, vUv + vec2(uTexelSize.x, -uTexelSize.y));
                    
                    // Convolution weights
                    float lapA = -1.0 * a + 
                                 0.2 * (uv_L.r + uv_R.r + uv_T.r + uv_B.r) + 
                                 0.05 * (uv_LT.r + uv_RT.r + uv_LB.r + uv_RB.r);
                                 
                    float lapB = -1.0 * b + 
                                 0.2 * (uv_L.g + uv_R.g + uv_T.g + uv_B.g) + 
                                 0.05 * (uv_LT.g + uv_RT.g + uv_LB.g + uv_RB.g);
                    
                    // Reaction-Diffusion formula
                    float reaction = a * b * b;
                    float da = uDiffA * lapA - reaction + uFeed * (1.0 - a);
                    float db = uDiffB * lapB + reaction - (uKill + uFeed) * b;
                    
                    a += da * uDt;
                    b += db * uDt;
                    
                    a = clamp(a, 0.0, 1.0);
                    b = clamp(b, 0.0, 1.0);
                    
                    gl_FragColor = vec4(a, b, 0.0, 1.0);
                }
            `,
            brush: `
                precision highp float;
                varying vec2 vUv;
                uniform sampler2D uTexture;
                uniform vec2 uPoint;
                uniform float uRadius;
                uniform float uAspectRatio;
                uniform float uValue;
                
                void main() {
                    vec4 color = texture2D(uTexture, vUv);
                    
                    vec2 p = vUv - uPoint;
                    p.x *= uAspectRatio;
                    
                    float dist = length(p);
                    float brush = smoothstep(uRadius, uRadius * 0.8, dist);
                    
                    if (uValue > 0.0) {
                        color.g = clamp(color.g + brush * 0.5, 0.0, 1.0);
                        color.r = clamp(color.r - brush * 0.5, 0.0, 1.0);
                    } else {
                        color.g = clamp(color.g - brush * 0.5, 0.0, 1.0);
                        color.r = clamp(color.r + brush * 0.5, 0.0, 1.0);
                    }
                    
                    gl_FragColor = color;
                }
            `,
            display: `
                precision highp float;
                varying vec2 vUv;
                uniform sampler2D uTexture;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;
                uniform vec3 uColor4;
                uniform vec3 uColor5;
                
                void main() {
                    vec4 uv = texture2D(uTexture, vUv);
                    float a = uv.r;
                    float b = uv.g;
                    
                    float t = clamp(b * 3.0, 0.0, 1.0);
                    
                    vec3 color;
                    if (t < 0.25) {
                        color = mix(uColor1, uColor2, t * 4.0);
                    } else if (t < 0.5) {
                        color = mix(uColor2, uColor3, (t - 0.25) * 4.0);
                    } else if (t < 0.75) {
                        color = mix(uColor3, uColor4, (t - 0.5) * 4.0);
                    } else {
                        color = mix(uColor4, uColor5, (t - 0.75) * 4.0);
                    }
                    
                    float d = 1.0/512.0;
                    float h = b;
                    float h_r = texture2D(uTexture, vUv + vec2(d, 0.0)).g;
                    float h_u = texture2D(uTexture, vUv + vec2(0.0, d)).g;
                    
                    vec3 normal = normalize(vec3(h - h_r, h - h_u, 0.05));
                    vec3 light = normalize(vec3(0.5, 0.5, 1.0));
                    float diffuse = max(dot(normal, light), 0.0);
                    float specular = pow(max(dot(reflect(-light, normal), vec3(0.0, 0.0, 1.0)), 0.0), 10.0);
                    
                    color = color * (0.5 + 0.5 * diffuse) + specular * 0.2;
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };

        // SIMULATION CLASS
        class ReactionDiffusion {
            constructor(canvas) {
                this.canvas = canvas;
                this.config = {
                    feed: 0.055,
                    kill: 0.062,
                    diffA: 1.0,
                    diffB: 0.5,
                    dt: 1.0,
                    iterations: 8,
                    resolution: 512,
                    brushRadius: 0.05,
                    colors: [
                        [0.0, 0.0, 0.0],    // Background
                        [0.2, 0.0, 0.4],    // Deep Purple
                        [0.0, 0.5, 0.8],    // Blue
                        [0.0, 1.0, 0.6],    // Teal
                        [1.0, 1.0, 1.0]     // White highlights
                    ]
                };

                this.presets = {
                    'coral': { feed: 0.0545, kill: 0.062, diffA: 1.0, diffB: 0.5, seedType: 'center' },
                    'mitosis': { feed: 0.0367, kill: 0.0649, diffA: 1.0, diffB: 0.5, seedType: 'center' },
                    'stripes': { feed: 0.029, kill: 0.057, diffA: 1.0, diffB: 0.5, seedType: 'fill' },
                    'spots': { feed: 0.025, kill: 0.060, diffA: 1.0, diffB: 0.5, seedType: 'fill' },
                    'chaos': { feed: 0.026, kill: 0.051, diffA: 1.0, diffB: 0.5, seedType: 'fill' },
                    'waves': { feed: 0.014, kill: 0.045, diffA: 1.0, diffB: 0.5, seedType: 'center' }
                };

                this.pointers = [];
                this.gl = null;
                this.programs = {};
                this.frameBuffers = {};
                this.frameCount = 0;

                this.init();
            }

            init() {
                // Try WebGL2 first
                this.gl = this.canvas.getContext('webgl2', {
                    alpha: false,
                    depth: false,
                    stencil: false,
                    antialias: false,
                    preserveDrawingBuffer: false
                });

                const isWebGL2 = !!this.gl;

                if (!this.gl) {
                    // Fallback to WebGL1
                    this.gl = this.canvas.getContext('webgl', {
                        alpha: false,
                        depth: false,
                        stencil: false,
                        antialias: false,
                        preserveDrawingBuffer: false
                    });
                }

                if (!this.gl) {
                    alert('WebGL not supported!');
                    return;
                }

                const gl = this.gl;

                // Enable float textures
                let ext;
                if (isWebGL2) {
                    ext = gl.getExtension('EXT_color_buffer_float');
                    if (!ext) {
                        console.warn('EXT_color_buffer_float not supported, trying OES_texture_float_linear');
                    }
                    gl.getExtension('OES_texture_float_linear');
                } else {
                    ext = gl.getExtension('OES_texture_float');
                    gl.getExtension('OES_texture_float_linear');
                }

                if (!ext && !isWebGL2) {
                    alert('Float textures not supported!');
                    return;
                }

                console.log('WebGL Version:', isWebGL2 ? '2.0' : '1.0');
                console.log('Float Extension:', ext ? 'Supported' : 'Not Supported (might work in WebGL2 core)');

                // Compile shaders
                this.programs.update = this.createProgram(shaders.vertex, shaders.update);
                this.programs.brush = this.createProgram(shaders.vertex, shaders.brush);
                this.programs.display = this.createProgram(shaders.vertex, shaders.display);

                // Create full-screen quad
                this.createQuad();

                // Initialize framebuffers
                this.initFramebuffers();

                // Initial seed
                this.seed();

                // Setup interaction
                this.setupInteraction();

                // Start animation loop
                this.update();
            }

            createProgram(vertexShader, fragmentShader) {
                const gl = this.gl;

                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vertexShader);
                gl.compileShader(vs);

                if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                    console.error('Vertex shader error:', gl.getShaderInfoLog(vs));
                    return null;
                }

                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fragmentShader);
                gl.compileShader(fs);

                if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                    console.error('Fragment shader error:', gl.getShaderInfoLog(fs));
                    return null;
                }

                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(program));
                    return null;
                }

                // Cache uniform locations
                const uniforms = {};
                const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    const uniformName = gl.getActiveUniform(program, i).name;
                    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
                }

                return { program, uniforms };
            }

            createQuad() {
                const gl = this.gl;
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                this.quadBuffer = buffer;
            }

            createFBO(w, h, type = this.gl.FLOAT) {
                const gl = this.gl;
                const isWebGL2 = gl instanceof WebGL2RenderingContext;

                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                if (isWebGL2) {
                    // WebGL2 requires specific internal formats for float textures
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, w, h, 0, gl.RGBA, gl.FLOAT, null);
                } else {
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, type, null);
                }

                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    console.error('Framebuffer not complete:', status);
                }

                gl.viewport(0, 0, w, h);
                gl.clearColor(1.0, 0.0, 0.0, 1.0); // Initialize with A=1, B=0
                gl.clear(gl.COLOR_BUFFER_BIT);

                return {
                    texture,
                    fbo,
                    width: w,
                    height: h,
                    attach(id) {
                        gl.activeTexture(gl.TEXTURE0 + id);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        return id;
                    }
                };
            }

            createDoubleFBO(w, h) {
                let fbo1 = this.createFBO(w, h);
                let fbo2 = this.createFBO(w, h);

                return {
                    width: w,
                    height: h,
                    read: fbo1,
                    write: fbo2,
                    swap() {
                        let temp = fbo1;
                        fbo1 = fbo2;
                        fbo2 = temp;
                        this.read = fbo1;
                        this.write = fbo2;
                    }
                };
            }

            initFramebuffers() {
                const res = this.config.resolution;
                this.frameBuffers.state = this.createDoubleFBO(res, res);
            }

            seed() {
                const gl = this.gl;
                const prog = this.programs.brush;
                const type = this.config.seedType || 'center';

                gl.useProgram(prog.program);
                gl.uniform1i(prog.uniforms.uTexture, this.frameBuffers.state.read.attach(0));
                gl.uniform1f(prog.uniforms.uAspectRatio, 1.0);
                gl.uniform1f(prog.uniforms.uValue, 1.0);

                if (type === 'fill') {
                    // Fill with random noise
                    for (let i = 0; i < 100; i++) {
                        gl.uniform2f(prog.uniforms.uPoint, Math.random(), Math.random());
                        gl.uniform1f(prog.uniforms.uRadius, Math.random() * 0.1);
                        this.blit(this.frameBuffers.state.write.fbo);
                        this.frameBuffers.state.swap();
                    }
                } else {
                    // Center start (Coral, Mitosis, Waves)
                    gl.uniform2f(prog.uniforms.uPoint, 0.5, 0.5);
                    gl.uniform1f(prog.uniforms.uRadius, 0.05);
                    this.blit(this.frameBuffers.state.write.fbo);
                    this.frameBuffers.state.swap();

                    // Add a few random spots to break symmetry
                    for (let i = 0; i < 10; i++) {
                        gl.uniform2f(prog.uniforms.uPoint, Math.random(), Math.random());
                        gl.uniform1f(prog.uniforms.uRadius, 0.02 + Math.random() * 0.02);
                        this.blit(this.frameBuffers.state.write.fbo);
                        this.frameBuffers.state.swap();
                    }
                }
            }

            setupInteraction() {
                this.canvas.addEventListener('mousedown', e => {
                    const pointer = {
                        id: -1,
                        x: e.offsetX,
                        y: e.offsetY,
                        down: true
                    };
                    this.pointers.push(pointer);
                });

                this.canvas.addEventListener('mousemove', e => {
                    const pointer = this.pointers.find(p => p.id === -1);
                    if (pointer && pointer.down) {
                        pointer.x = e.offsetX;
                        pointer.y = e.offsetY;
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.pointers = this.pointers.filter(p => p.id !== -1);
                });

                // Touch support
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touches = e.targetTouches;
                    for (let i = 0; i < touches.length; i++) {
                        const touch = touches[i];
                        const pointer = {
                            id: touch.identifier,
                            x: touch.pageX,
                            y: touch.pageY,
                            down: true
                        };
                        this.pointers.push(pointer);
                    }
                });

                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const touches = e.targetTouches;
                    for (let i = 0; i < touches.length; i++) {
                        const touch = touches[i];
                        const pointer = this.pointers.find(p => p.id === touch.identifier);
                        if (pointer && pointer.down) {
                            pointer.x = touch.pageX;
                            pointer.y = touch.pageY;
                        }
                    }
                });

                this.canvas.addEventListener('touchend', e => {
                    const touches = e.changedTouches;
                    for (let i = 0; i < touches.length; i++) {
                        const touch = touches[i];
                        this.pointers = this.pointers.filter(p => p.id !== touch.identifier);
                    }
                });
            }

            update() {
                this.resizeCanvas();
                this.applyInputs();

                // Multiple steps per frame for faster simulation
                for (let i = 0; i < this.config.iterations; i++) {
                    this.step();
                }

                this.render();
                this.frameCount++;

                requestAnimationFrame(() => this.update());
            }

            resizeCanvas() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }
            }

            applyInputs() {
                const gl = this.gl;
                const prog = this.programs.brush;

                if (this.pointers.length > 0) {
                    gl.useProgram(prog.program);
                    gl.uniform1f(prog.uniforms.uRadius, this.config.brushRadius);
                    gl.uniform1f(prog.uniforms.uAspectRatio, this.canvas.width / this.canvas.height);
                    gl.uniform1f(prog.uniforms.uValue, 1.0);

                    this.pointers.forEach(pointer => {
                        gl.uniform1i(prog.uniforms.uTexture, this.frameBuffers.state.read.attach(0));
                        gl.uniform2f(prog.uniforms.uPoint, pointer.x / this.canvas.width, 1.0 - pointer.y / this.canvas.height);
                        this.blit(this.frameBuffers.state.write.fbo);
                        this.frameBuffers.state.swap();
                    });
                }
            }

            step() {
                const gl = this.gl;
                const prog = this.programs.update;

                gl.useProgram(prog.program);
                gl.viewport(0, 0, this.frameBuffers.state.width, this.frameBuffers.state.height);

                gl.uniform1i(prog.uniforms.uTexture, this.frameBuffers.state.read.attach(0));
                gl.uniform2f(prog.uniforms.uTexelSize, 1.0 / this.frameBuffers.state.width, 1.0 / this.frameBuffers.state.height);
                gl.uniform1f(prog.uniforms.uFeed, this.config.feed);
                gl.uniform1f(prog.uniforms.uKill, this.config.kill);
                gl.uniform1f(prog.uniforms.uDiffA, this.config.diffA);
                gl.uniform1f(prog.uniforms.uDiffB, this.config.diffB);
                gl.uniform1f(prog.uniforms.uDt, this.config.dt);

                this.blit(this.frameBuffers.state.write.fbo);
                this.frameBuffers.state.swap();
            }

            render() {
                const gl = this.gl;
                const prog = this.programs.display;

                gl.useProgram(prog.program);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.uniform1i(prog.uniforms.uTexture, this.frameBuffers.state.read.attach(0));

                // Set colors
                gl.uniform3fv(prog.uniforms.uColor1, this.config.colors[0]);
                gl.uniform3fv(prog.uniforms.uColor2, this.config.colors[1]);
                gl.uniform3fv(prog.uniforms.uColor3, this.config.colors[2]);
                gl.uniform3fv(prog.uniforms.uColor4, this.config.colors[3]);
                gl.uniform3fv(prog.uniforms.uColor5, this.config.colors[4]);

                this.blit(null);
            }

            blit(destination) {
                const gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(0);
                gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            }

            loadPreset(name) {
                if (this.presets[name]) {
                    Object.assign(this.config, this.presets[name]);
                    return true;
                }
                return false;
            }

            clear() {
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffers.state.read.fbo);
                gl.clearColor(1.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffers.state.write.fbo);
                gl.clearColor(1.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                this.seed();
            }
        }

        // INITIALIZATION
        const canvas = document.getElementById('simCanvas');
        const sim = new ReactionDiffusion(canvas);
        window.sim = sim; // Expose for debugging

        // Setup controls
        const controls = {
            preset: document.getElementById('presetSelect'),
            feed: document.getElementById('feedRate'),
            kill: document.getElementById('killRate'),
            diffA: document.getElementById('diffA'),
            diffB: document.getElementById('diffB'),
            iterations: document.getElementById('iterations'),
            brush: document.getElementById('brushSize'),
            clear: document.getElementById('clearBtn')
        };

        // Update display values
        controls.preset.addEventListener('change', e => {
            sim.loadPreset(e.target.value);
            // Update sliders to match preset
            controls.feed.value = sim.config.feed;
            document.getElementById('feedValue').textContent = sim.config.feed;
            controls.kill.value = sim.config.kill;
            document.getElementById('killValue').textContent = sim.config.kill;
            controls.diffA.value = sim.config.diffA;
            document.getElementById('diffAValue').textContent = sim.config.diffA;
            controls.diffB.value = sim.config.diffB;
            document.getElementById('diffBValue').textContent = sim.config.diffB;
            // Clear screen on preset change to allow new pattern to form
            sim.clear();
        });

        controls.feed.addEventListener('input', e => {
            document.getElementById('feedValue').textContent = e.target.value;
            sim.config.feed = parseFloat(e.target.value);
        });

        controls.kill.addEventListener('input', e => {
            document.getElementById('killValue').textContent = e.target.value;
            sim.config.kill = parseFloat(e.target.value);
        });

        controls.diffA.addEventListener('input', e => {
            document.getElementById('diffAValue').textContent = e.target.value;
            sim.config.diffA = parseFloat(e.target.value);
        });

        controls.diffB.addEventListener('input', e => {
            document.getElementById('diffBValue').textContent = e.target.value;
            sim.config.diffB = parseFloat(e.target.value);
        });

        controls.iterations.addEventListener('input', e => {
            document.getElementById('iterValue').textContent = e.target.value;
            sim.config.iterations = parseInt(e.target.value);
        });

        controls.brush.addEventListener('input', e => {
            document.getElementById('brushValue').textContent = e.target.value;
            sim.config.brushRadius = parseFloat(e.target.value);
        });

        controls.clear.addEventListener('click', () => {
            sim.clear();
        });
    </script>
</body>

</html>