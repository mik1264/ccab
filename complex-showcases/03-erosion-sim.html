<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain - Hydraulic Erosion Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Arial; }
        canvas { border: 2px solid #333; }
        .controls { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; }
        button { background: #4CAF50; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 4px; cursor: pointer; }
        button:hover { background: #45a049; }
    </style>
</head>
<body>
    <div class="controls">
        <div>Erosion Steps: <span id="steps">0</span></div>
        <button onclick="toggleErosion()"><span id="toggle">Start</span> Erosion</button>
        <button onclick="reset()">Reset</button>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        const SIZE = 200;
        let heightMap = [];
        let waterMap = [];
        let sedimentMap = [];
        let running = false;
        let steps = 0;

        function init() {
            heightMap = Array(SIZE).fill(0).map(() => Array(SIZE).fill(0));
            waterMap = Array(SIZE).fill(0).map(() => Array(SIZE).fill(0));
            sedimentMap = Array(SIZE).fill(0).map(() => Array(SIZE).fill(0));

            // Create initial terrain
            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    let h = 0;
                    let amp = 1;
                    let freq = 0.02;
                    for (let i = 0; i < 4; i++) {
                        h += Math.sin(x * freq) * Math.cos(y * freq) * amp;
                        freq *= 2;
                        amp *= 0.5;
                    }
                    heightMap[y][x] = (h + 1) * 0.5;
                }
            }
            steps = 0;
            document.getElementById('steps').textContent = steps;
        }

        function erosionStep() {
            const RAIN_AMOUNT = 0.01;
            const EVAPORATION = 0.5;
            const SEDIMENT_CAPACITY = 0.1;
            const DISSOLVING_RATE = 0.1;
            const DEPOSITION_RATE = 0.1;

            const newHeightMap = heightMap.map(row => [...row]);
            const newWaterMap = waterMap.map(row => [...row]);
            const newSedimentMap = sedimentMap.map(row => [...row]);

            // Add rain
            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    if (Math.random() < 0.1) {
                        waterMap[y][x] += RAIN_AMOUNT;
                    }
                }
            }

            // Water flow and erosion
            for (let y = 1; y < SIZE - 1; y++) {
                for (let x = 1; x < SIZE - 1; x++) {
                    if (waterMap[y][x] < 0.001) continue;

                    const currentHeight = heightMap[y][x] + waterMap[y][x];
                    let lowestNeighbor = { x: x, y: y, height: currentHeight };

                    // Find lowest neighbor
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            const nh = heightMap[ny][nx] + waterMap[ny][nx];
                            if (nh < lowestNeighbor.height) {
                                lowestNeighbor = { x: nx, y: ny, height: nh };
                            }
                        }
                    }

                    if (lowestNeighbor.x !== x || lowestNeighbor.y !== y) {
                        const heightDiff = currentHeight - lowestNeighbor.height;
                        const waterMove = Math.min(waterMap[y][x], heightDiff * 0.5);

                        newWaterMap[y][x] -= waterMove;
                        newWaterMap[lowestNeighbor.y][lowestNeighbor.x] += waterMove;

                        // Erosion and deposition
                        const velocity = Math.sqrt(heightDiff);
                        const sedimentCapacity = velocity * waterMove * SEDIMENT_CAPACITY;

                        if (sedimentMap[y][x] < sedimentCapacity) {
                            const erosionAmount = DISSOLVING_RATE * (sedimentCapacity - sedimentMap[y][x]);
                            newHeightMap[y][x] -= erosionAmount;
                            newSedimentMap[y][x] += erosionAmount;
                        } else {
                            const depositionAmount = DEPOSITION_RATE * (sedimentMap[y][x] - sedimentCapacity);
                            newHeightMap[y][x] += depositionAmount;
                            newSedimentMap[y][x] -= depositionAmount;
                        }

                        // Move sediment with water
                        const sedimentMove = sedimentMap[y][x] * (waterMove / waterMap[y][x]);
                        newSedimentMap[y][x] -= sedimentMove;
                        newSedimentMap[lowestNeighbor.y][lowestNeighbor.x] += sedimentMove;
                    }

                    // Evaporation
                    newWaterMap[y][x] *= (1 - EVAPORATION * 0.01);
                }
            }

            heightMap = newHeightMap;
            waterMap = newWaterMap;
            sedimentMap = newSedimentMap;
            steps++;
            document.getElementById('steps').textContent = steps;
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const mx = Math.floor(x / canvas.width * SIZE);
                    const my = Math.floor(y / canvas.height * SIZE);
                    const height = heightMap[my][mx];
                    const water = waterMap[my][mx];

                    let r, g, b;
                    if (water > 0.01) {
                        r = 50; g = 100; b = 200;
                    } else if (height < 0.3) {
                        r = 34; g = 139; b = 34;
                    } else if (height < 0.6) {
                        r = 139; g = 90; b = 43;
                    } else {
                        r = 200; g = 200; b = 200;
                    }

                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            if (running) {
                for (let i = 0; i < 5; i++) erosionStep();
            }
            render();
            requestAnimationFrame(animate);
        }

        function toggleErosion() {
            running = !running;
            document.getElementById('toggle').textContent = running ? 'Stop' : 'Start';
        }

        function reset() {
            running = false;
            init();
            document.getElementById('toggle').textContent = 'Start';
        }

        init();
        animate();
    </script>
</body>
</html>
