<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation - Navier-Stokes Solver</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">
        Click and drag to add fluid<br>
        Press R to reset
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        canvas.width = 800;
        canvas.height = 600;

        const N = 128; // Grid resolution
        const ITERATIONS = 20;

        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;

            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Advection shader
        const advectionShaderSource = `#version 300 es
            precision highp float;

            uniform sampler2D u_velocity;
            uniform sampler2D u_source;
            uniform vec2 u_texelSize;
            uniform float u_dt;
            uniform float u_dissipation;

            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                vec2 velocity = texture(u_velocity, v_texCoord).xy;
                vec2 pos = v_texCoord - velocity * u_dt * u_texelSize;
                fragColor = u_dissipation * texture(u_source, pos);
            }
        `;

        // Divergence shader
        const divergenceShaderSource = `#version 300 es
            precision highp float;

            uniform sampler2D u_velocity;
            uniform vec2 u_texelSize;

            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                float L = texture(u_velocity, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
                float R = texture(u_velocity, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
                float T = texture(u_velocity, v_texCoord + vec2(0.0, u_texelSize.y)).y;
                float B = texture(u_velocity, v_texCoord - vec2(0.0, u_texelSize.y)).y;

                float div = 0.5 * (R - L + T - B);
                fragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `;

        // Pressure shader
        const pressureShaderSource = `#version 300 es
            precision highp float;

            uniform sampler2D u_pressure;
            uniform sampler2D u_divergence;
            uniform vec2 u_texelSize;

            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                float L = texture(u_pressure, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
                float R = texture(u_pressure, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
                float T = texture(u_pressure, v_texCoord + vec2(0.0, u_texelSize.y)).x;
                float B = texture(u_pressure, v_texCoord - vec2(0.0, u_texelSize.y)).x;
                float C = texture(u_divergence, v_texCoord).x;

                fragColor = vec4((L + R + B + T - C) * 0.25, 0.0, 0.0, 1.0);
            }
        `;

        // Gradient subtract shader
        const gradientSubtractShaderSource = `#version 300 es
            precision highp float;

            uniform sampler2D u_pressure;
            uniform sampler2D u_velocity;
            uniform vec2 u_texelSize;

            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                float L = texture(u_pressure, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
                float R = texture(u_pressure, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
                float T = texture(u_pressure, v_texCoord + vec2(0.0, u_texelSize.y)).x;
                float B = texture(u_pressure, v_texCoord - vec2(0.0, u_texelSize.y)).x;

                vec2 velocity = texture(u_velocity, v_texCoord).xy;
                velocity -= vec2(R - L, T - B) * 0.5;

                fragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        // Display shader
        const displayShaderSource = `#version 300 es
            precision highp float;

            uniform sampler2D u_texture;
            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                vec3 color = texture(u_texture, v_texCoord).rgb;
                fragColor = vec4(color, 1.0);
            }
        `;

        // Splat shader
        const splatShaderSource = `#version 300 es
            precision highp float;

            uniform sampler2D u_target;
            uniform vec2 u_point;
            uniform vec3 u_color;
            uniform float u_radius;

            in vec2 v_texCoord;
            out vec4 fragColor;

            void main() {
                vec2 p = v_texCoord - u_point;
                float splat = exp(-dot(p, p) / u_radius);
                vec3 base = texture(u_target, v_texCoord).rgb;
                fragColor = vec4(base + u_color * splat, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vertSource, fragSource) {
            const vertShader = createShader(gl.VERTEX_SHADER, vertSource);
            const fragShader = createShader(gl.FRAGMENT_SHADER, fragSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const programs = {
            advection: createProgram(vertexShaderSource, advectionShaderSource),
            divergence: createProgram(vertexShaderSource, divergenceShaderSource),
            pressure: createProgram(vertexShaderSource, pressureShaderSource),
            gradientSubtract: createProgram(vertexShaderSource, gradientSubtractShaderSource),
            display: createProgram(vertexShaderSource, displayShaderSource),
            splat: createProgram(vertexShaderSource, splatShaderSource)
        };

        // Create buffers
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        function createFBO(width, height) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            return { fbo, texture };
        }

        const velocity = [createFBO(N, N), createFBO(N, N)];
        const density = [createFBO(N, N), createFBO(N, N)];
        const pressure = [createFBO(N, N), createFBO(N, N)];
        const divergence = createFBO(N, N);

        let mouse = { x: 0, y: 0, px: 0, py: 0, down: false };

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.px = mouse.x;
            mouse.py = mouse.y;
            mouse.x = (e.clientX - rect.left) / canvas.width;
            mouse.y = 1.0 - (e.clientY - rect.top) / canvas.height;
        });

        canvas.addEventListener('mousedown', () => mouse.down = true);
        canvas.addEventListener('mouseup', () => mouse.down = false);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                // Reset simulation
                gl.bindFramebuffer(gl.FRAMEBUFFER, density[0].fbo);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, velocity[0].fbo);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
        });

        function render() {
            const dt = 0.016;

            if (mouse.down) {
                splatVelocity(velocity[0], mouse.x, mouse.y, (mouse.x - mouse.px) * 50, (mouse.y - mouse.py) * 50);
                splatDensity(density[0], mouse.x, mouse.y);
            }

            // Advect velocity
            advect(velocity[0], velocity[0], velocity[1], dt, 0.998);
            [velocity[0], velocity[1]] = [velocity[1], velocity[0]];

            // Advect density
            advect(velocity[0], density[0], density[1], dt, 0.98);
            [density[0], density[1]] = [density[1], density[0]];

            // Compute divergence
            computeDivergence(velocity[0], divergence);

            // Solve pressure
            gl.bindFramebuffer(gl.FRAMEBUFFER, pressure[0].fbo);
            gl.clear(gl.COLOR_BUFFER_BIT);

            for (let i = 0; i < ITERATIONS; i++) {
                solvePressure(pressure[0], divergence, pressure[1]);
                [pressure[0], pressure[1]] = [pressure[1], pressure[0]];
            }

            // Subtract pressure gradient
            subtractGradient(pressure[0], velocity[0], velocity[1]);
            [velocity[0], velocity[1]] = [velocity[1], velocity[0]];

            // Display
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            displayTexture(density[0]);

            requestAnimationFrame(render);
        }

        function advect(velocityField, source, target, dt, dissipation) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            const program = programs.advection;
            gl.useProgram(program);

            gl.uniform1i(gl.getUniformLocation(program, 'u_velocity'), 0);
            gl.uniform1i(gl.getUniformLocation(program, 'u_source'), 1);
            gl.uniform2f(gl.getUniformLocation(program, 'u_texelSize'), 1.0 / N, 1.0 / N);
            gl.uniform1f(gl.getUniformLocation(program, 'u_dt'), dt);
            gl.uniform1f(gl.getUniformLocation(program, 'u_dissipation'), dissipation);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocityField.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, source.texture);

            drawQuad(program);
        }

        function splatVelocity(target, x, y, dx, dy) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            const program = programs.splat;
            gl.useProgram(program);

            gl.uniform1i(gl.getUniformLocation(program, 'u_target'), 0);
            gl.uniform2f(gl.getUniformLocation(program, 'u_point'), x, y);
            gl.uniform3f(gl.getUniformLocation(program, 'u_color'), dx, dy, 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_radius'), 0.0005);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, target.texture);

            drawQuad(program);
        }

        function splatDensity(target, x, y) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            const program = programs.splat;
            gl.useProgram(program);

            const hue = Date.now() * 0.001 % 1.0;
            const rgb = hslToRgb(hue, 1.0, 0.5);

            gl.uniform1i(gl.getUniformLocation(program, 'u_target'), 0);
            gl.uniform2f(gl.getUniformLocation(program, 'u_point'), x, y);
            gl.uniform3f(gl.getUniformLocation(program, 'u_color'), rgb[0], rgb[1], rgb[2]);
            gl.uniform1f(gl.getUniformLocation(program, 'u_radius'), 0.001);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, target.texture);

            drawQuad(program);
        }

        function computeDivergence(velocity, target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            const program = programs.divergence;
            gl.useProgram(program);

            gl.uniform1i(gl.getUniformLocation(program, 'u_velocity'), 0);
            gl.uniform2f(gl.getUniformLocation(program, 'u_texelSize'), 1.0 / N, 1.0 / N);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.texture);

            drawQuad(program);
        }

        function solvePressure(pressureField, divergenceField, target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            const program = programs.pressure;
            gl.useProgram(program);

            gl.uniform1i(gl.getUniformLocation(program, 'u_pressure'), 0);
            gl.uniform1i(gl.getUniformLocation(program, 'u_divergence'), 1);
            gl.uniform2f(gl.getUniformLocation(program, 'u_texelSize'), 1.0 / N, 1.0 / N);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressureField.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, divergenceField.texture);

            drawQuad(program);
        }

        function subtractGradient(pressureField, velocityField, target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            const program = programs.gradientSubtract;
            gl.useProgram(program);

            gl.uniform1i(gl.getUniformLocation(program, 'u_pressure'), 0);
            gl.uniform1i(gl.getUniformLocation(program, 'u_velocity'), 1);
            gl.uniform2f(gl.getUniformLocation(program, 'u_texelSize'), 1.0 / N, 1.0 / N);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressureField.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocityField.texture);

            drawQuad(program);
        }

        function displayTexture(texture) {
            const program = programs.display;
            gl.useProgram(program);

            gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture.texture);

            drawQuad(program);
        }

        function drawQuad(program) {
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            const posLoc = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [r, g, b];
        }

        render();
    </script>
</body>
</html>
