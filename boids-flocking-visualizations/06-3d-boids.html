<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Boids - Three.js</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>3D Boids Flocking</h2>
        <p>Drag to rotate â€¢ Scroll to zoom</p>
        <p>150 boids in 3D space</p>
    </div>
    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.150.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.FogExp2(0x000510, 0.0008);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 200, 500);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Boundary box
        const boxGeometry = new THREE.BoxGeometry(800, 800, 800);
        const boxEdges = new THREE.EdgesGeometry(boxGeometry);
        const boxLine = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.3 }));
        scene.add(boxLine);

        class Boid3D {
            constructor() {
                const geometry = new THREE.ConeGeometry(4, 15, 8);
                geometry.rotateX(Math.PI / 2);
                const material = new THREE.MeshBasicMaterial({ color: 0x00aaff });
                this.mesh = new THREE.Mesh(geometry, material);

                this.position = new THREE.Vector3(
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300
                );
                this.velocity = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize().multiplyScalar(2);

                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            update(boids) {
                const separationDist = 25;
                const alignmentDist = 80;
                const cohesionDist = 80;

                let separation = new THREE.Vector3();
                let alignment = new THREE.Vector3();
                let cohesion = new THREE.Vector3();
                let neighbors = 0;

                for (const other of boids) {
                    if (other === this) continue;
                    const dist = this.position.distanceTo(other.position);

                    if (dist < separationDist) {
                        const diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize().divideScalar(dist);
                        separation.add(diff);
                    }

                    if (dist < alignmentDist) {
                        alignment.add(other.velocity);
                        neighbors++;
                    }

                    if (dist < cohesionDist) {
                        cohesion.add(other.position);
                    }
                }

                if (neighbors > 0) {
                    alignment.divideScalar(neighbors).normalize().multiplyScalar(0.05);
                    cohesion.divideScalar(neighbors).sub(this.position).normalize().multiplyScalar(0.03);
                }

                separation.normalize().multiplyScalar(0.015);

                this.velocity.add(separation).add(alignment).add(cohesion);

                // Speed limit
                const speed = this.velocity.length();
                if (speed > 3) {
                    this.velocity.normalize().multiplyScalar(3);
                }

                this.position.add(this.velocity);

                // Boundary wrapping
                if (this.position.x < -400) this.position.x = 400;
                if (this.position.x > 400) this.position.x = -400;
                if (this.position.y < -400) this.position.y = 400;
                if (this.position.y > 400) this.position.y = -400;
                if (this.position.z < -400) this.position.z = 400;
                if (this.position.z > 400) this.position.z = -400;

                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.position.clone().add(this.velocity));
            }
        }

        const boids = [];
        for (let i = 0; i < 150; i++) {
            boids.push(new Boid3D());
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            boids.forEach(boid => boid.update(boids));

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
