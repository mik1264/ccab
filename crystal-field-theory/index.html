<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crystal Field Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: 600; z-index: 998;
    text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none;
}
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 12px; align-items: center; z-index: 999;
    background: rgba(0,0,0,0.7); padding: 12px 24px; border-radius: 12px;
    border: 1px solid rgba(251,191,36,0.3); flex-wrap: wrap; justify-content: center;
}
.controls button {
    background: rgba(251,191,36,0.15); color: #fbbf24; border: 1px solid rgba(251,191,36,0.4);
    padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 13px;
    transition: all 0.2s;
}
.controls button:hover, .controls button.active {
    background: rgba(251,191,36,0.4); border-color: #fbbf24;
}
.controls label { color: #ccc; font-size: 13px; white-space: nowrap; }
.controls input[type=range] { width: 100px; accent-color: #fbbf24; }
.controls span { color: #fbbf24; font-size: 13px; }
.info-panel {
    position: fixed; top: 80px; left: 20px; z-index: 998;
    background: rgba(0,0,0,0.7); padding: 14px 18px; border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 12px;
    line-height: 1.7; max-width: 260px;
}
.info-panel h3 { color: #fbbf24; margin-bottom: 6px; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">← Back to Gallery</a>
<div class="title-overlay">Crystal Field Theory</div>
<div class="info-panel" id="infoPanel"></div>
<div class="controls">
    <button id="octBtn" class="active">Octahedral</button>
    <button id="tetBtn">Tetrahedral</button>
    <button id="sqpBtn">Square Planar</button>
    <span style="color:#555;">|</span>
    <label>d-electrons: <input type="range" id="electronSlider" min="0" max="10" value="6"> <span id="electronVal">6</span></label>
    <label>Field Strength: <input type="range" id="fieldSlider" min="1" max="10" value="5"> <span id="fieldVal">5</span></label>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let geometry = 'octahedral'; // octahedral, tetrahedral, square_planar
let dElectrons = 6;
let fieldStrength = 5;
let animTime = 0;

const geoButtons = { octBtn: 'octahedral', tetBtn: 'tetrahedral', sqpBtn: 'square_planar' };
for (let [id, geo] of Object.entries(geoButtons)) {
    document.getElementById(id).addEventListener('click', function() {
        geometry = geo;
        document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
    });
}

document.getElementById('electronSlider').addEventListener('input', function() {
    dElectrons = +this.value;
    document.getElementById('electronVal').textContent = this.value;
});
document.getElementById('fieldSlider').addEventListener('input', function() {
    fieldStrength = +this.value;
    document.getElementById('fieldVal').textContent = this.value;
});

function getOrbitalConfig() {
    const delta = fieldStrength * 15;
    let config;

    if (geometry === 'octahedral') {
        // t2g (dxy, dxz, dyz) lower; eg (dz2, dx2-y2) higher
        config = {
            lower: { name: 't₂g', orbitals: ['dxy', 'dxz', 'dyz'], energy: -2 * delta / 5 },
            upper: { name: 'eg', orbitals: ['dz²', 'dx²-y²'], energy: 3 * delta / 5 },
            delta: delta,
            label: 'Δ_oct'
        };
    } else if (geometry === 'tetrahedral') {
        // e (dz2, dx2-y2) lower; t2 (dxy, dxz, dyz) higher (inverted, smaller)
        const tetDelta = delta * 4 / 9;
        config = {
            lower: { name: 'e', orbitals: ['dz²', 'dx²-y²'], energy: -3 * tetDelta / 5 },
            upper: { name: 't₂', orbitals: ['dxy', 'dxz', 'dyz'], energy: 2 * tetDelta / 5 },
            delta: tetDelta,
            label: 'Δ_tet'
        };
    } else {
        // Square planar: dx2-y2 highest, dxy middle-high, dz2 middle, dxz/dyz lowest
        config = {
            levels: [
                { name: 'dxz, dyz', orbitals: ['dxz', 'dyz'], energy: -2 * delta / 5 },
                { name: 'dz²', orbitals: ['dz²'], energy: -delta / 10 },
                { name: 'dxy', orbitals: ['dxy'], energy: delta / 5 },
                { name: 'dx²-y²', orbitals: ['dx²-y²'], energy: delta / 2 }
            ],
            delta: delta,
            label: 'Δ_sp'
        };
    }
    return config;
}

function fillElectrons(config) {
    let electrons = dElectrons;
    let filling = [];
    const isHighSpin = fieldStrength <= 5;

    if (geometry === 'square_planar') {
        for (let level of config.levels) {
            const maxE = level.orbitals.length * 2;
            const fill = Math.min(electrons, maxE);
            filling.push({ ...level, filled: fill });
            electrons -= fill;
        }
    } else {
        const lowerMax = config.lower.orbitals.length * 2;
        const upperMax = config.upper.orbitals.length * 2;

        if (isHighSpin) {
            // Fill one electron per orbital first (Hund's rule)
            const lowerOrbs = config.lower.orbitals.length;
            const upperOrbs = config.upper.orbitals.length;
            let lowerFill = 0, upperFill = 0;

            // Phase 1: one per lower orbital
            const phase1 = Math.min(electrons, lowerOrbs);
            lowerFill += phase1;
            electrons -= phase1;

            // Phase 2: one per upper orbital
            const phase2 = Math.min(electrons, upperOrbs);
            upperFill += phase2;
            electrons -= phase2;

            // Phase 3: second electron in lower
            const phase3 = Math.min(electrons, lowerOrbs);
            lowerFill += phase3;
            electrons -= phase3;

            // Phase 4: second electron in upper
            const phase4 = Math.min(electrons, upperOrbs);
            upperFill += phase4;
            electrons -= phase4;

            filling = [
                { ...config.lower, filled: lowerFill },
                { ...config.upper, filled: upperFill }
            ];
        } else {
            // Low spin: fill lower completely first
            const lowerFill = Math.min(electrons, lowerMax);
            electrons -= lowerFill;
            const upperFill = Math.min(electrons, upperMax);

            filling = [
                { ...config.lower, filled: lowerFill },
                { ...config.upper, filled: upperFill }
            ];
        }
    }

    return filling;
}

function drawLigandGeometry(cx, cy) {
    const r = 120;
    const ligandR = 20;
    let positions = [];

    ctx.save();

    if (geometry === 'octahedral') {
        positions = [
            { x: cx + r, y: cy, label: 'L' },
            { x: cx - r, y: cy, label: 'L' },
            { x: cx, y: cy - r, label: 'L' },
            { x: cx, y: cy + r, label: 'L' },
            { x: cx + r * 0.5, y: cy - r * 0.5, label: 'L' },
            { x: cx - r * 0.5, y: cy + r * 0.5, label: 'L' }
        ];
    } else if (geometry === 'tetrahedral') {
        const a = r * 0.9;
        positions = [
            { x: cx + a * 0.8, y: cy - a * 0.5, label: 'L' },
            { x: cx - a * 0.8, y: cy - a * 0.5, label: 'L' },
            { x: cx + a * 0.5, y: cy + a * 0.8, label: 'L' },
            { x: cx - a * 0.5, y: cy + a * 0.8, label: 'L' }
        ];
    } else {
        positions = [
            { x: cx + r, y: cy, label: 'L' },
            { x: cx - r, y: cy, label: 'L' },
            { x: cx, y: cy - r, label: 'L' },
            { x: cx, y: cy + r, label: 'L' }
        ];
    }

    // Bonds
    for (let p of positions) {
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Central metal ion
    const pulse = 1 + Math.sin(animTime * 2) * 0.1;
    const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 28 * pulse);
    grd.addColorStop(0, '#fbbf24');
    grd.addColorStop(0.6, 'rgba(251,191,36,0.5)');
    grd.addColorStop(1, 'rgba(251,191,36,0.1)');
    ctx.beginPath();
    ctx.arc(cx, cy, 28 * pulse, 0, Math.PI * 2);
    ctx.fillStyle = grd;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx, cy, 16, 0, Math.PI * 2);
    ctx.fillStyle = '#fbbf24';
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('M', cx, cy);

    // Ligands
    for (let p of positions) {
        const bob = Math.sin(animTime * 1.5 + p.x * 0.01) * 3;
        ctx.beginPath();
        ctx.arc(p.x, p.y + bob, ligandR, 0, Math.PI * 2);
        const lgrd = ctx.createRadialGradient(p.x, p.y + bob, 0, p.x, p.y + bob, ligandR);
        lgrd.addColorStop(0, '#4a9eff');
        lgrd.addColorStop(1, 'rgba(74,158,255,0.3)');
        ctx.fillStyle = lgrd;
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('L', p.x, p.y + bob);
    }

    ctx.restore();
}

function drawEnergyDiagram(dx, dy, dw, dh) {
    const config = getOrbitalConfig();
    const filling = fillElectrons(config);

    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.beginPath();
    ctx.roundRect(dx, dy, dw, dh, 12);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.stroke();

    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Energy Level Diagram', dx + dw / 2, dy + 22);

    const centerX = dx + dw / 2;
    const baseY = dy + dh - 50;
    const topY = dy + 60;
    const energyRange = topY - baseY;
    const lineW = 50;

    // Reference line (unsplit d)
    const refY = baseY + energyRange * 0.4;
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.setLineDash([3, 6]);
    ctx.beginPath();
    ctx.moveTo(dx + 20, refY);
    ctx.lineTo(dx + dw - 20, refY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#555';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('d (unsplit)', dx + 25, refY - 5);

    if (geometry === 'square_planar') {
        // Four levels
        const maxE = config.delta / 2;
        const minE = -2 * config.delta / 5;

        for (let i = 0; i < filling.length; i++) {
            const level = filling[i];
            const normE = (level.energy - minE) / (maxE - minE);
            const y = baseY + normE * energyRange * 0.8;
            const numOrbs = level.orbitals.length;
            const totalW = numOrbs * lineW + (numOrbs - 1) * 10;
            const startX = centerX - totalW / 2;

            for (let j = 0; j < numOrbs; j++) {
                const lx = startX + j * (lineW + 10);
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lx, y);
                ctx.lineTo(lx + lineW, y);
                ctx.stroke();

                // Electrons
                const ePerOrb = Math.ceil(level.filled / numOrbs);
                const orbElec = Math.min(j < level.filled % numOrbs || level.filled >= numOrbs * 2 ? 2 : Math.min(ePerOrb, 2), 2);
                const remaining = level.filled - j * 2;
                const thisOrbE = Math.max(0, Math.min(2, remaining));

                drawElectronArrows(lx + lineW / 2, y, thisOrbE);
            }

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(level.name, startX - 10, y + 4);
        }
    } else {
        // Two-level system
        for (let i = 0; i < filling.length; i++) {
            const level = filling[i];
            const normE = i === 0 ? 0.2 : 0.7;
            const y = baseY + normE * energyRange;
            const numOrbs = level.orbitals.length;
            const totalW = numOrbs * lineW + (numOrbs - 1) * 15;
            const startX = centerX - totalW / 2;

            for (let j = 0; j < numOrbs; j++) {
                const lx = startX + j * (lineW + 15);
                ctx.strokeStyle = i === 0 ? '#4a9eff' : '#ff4a6a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lx, y);
                ctx.lineTo(lx + lineW, y);
                ctx.stroke();

                // Fill electrons per orbital
                const remaining = level.filled - j * 2;
                const thisOrbE = Math.max(0, Math.min(2, remaining));
                drawElectronArrows(lx + lineW / 2, y, thisOrbE);

                // Orbital label
                ctx.fillStyle = '#666';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(level.orbitals[j], lx + lineW / 2, y + 16);
            }

            ctx.fillStyle = i === 0 ? '#4a9eff' : '#ff4a6a';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(level.name, startX - 10, y + 4);
        }

        // Delta arrow
        const y1 = baseY + 0.2 * energyRange;
        const y2 = baseY + 0.7 * energyRange;
        const arrowX = dx + dw - 40;
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(arrowX, y1);
        ctx.lineTo(arrowX, y2);
        ctx.stroke();
        // Arrowheads
        ctx.beginPath();
        ctx.moveTo(arrowX - 4, y1 + 8);
        ctx.lineTo(arrowX, y1);
        ctx.lineTo(arrowX + 4, y1 + 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(arrowX - 4, y2 - 8);
        ctx.lineTo(arrowX, y2);
        ctx.lineTo(arrowX + 4, y2 - 8);
        ctx.stroke();

        ctx.fillStyle = '#fbbf24';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(config.label, arrowX, (y1 + y2) / 2 + 4);
    }
}

function drawElectronArrows(x, y, count) {
    if (count <= 0) return;
    const arrowH = 14;
    const spacing = 8;

    // Up arrow
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - (count > 1 ? spacing : 0), y - 2);
    ctx.lineTo(x - (count > 1 ? spacing : 0), y - arrowH);
    ctx.stroke();
    // Arrowhead up
    ctx.beginPath();
    ctx.moveTo(x - (count > 1 ? spacing : 0) - 3, y - arrowH + 4);
    ctx.lineTo(x - (count > 1 ? spacing : 0), y - arrowH);
    ctx.lineTo(x - (count > 1 ? spacing : 0) + 3, y - arrowH + 4);
    ctx.fillStyle = '#22c55e';
    ctx.fill();

    if (count > 1) {
        // Down arrow
        ctx.beginPath();
        ctx.moveTo(x + spacing, y - arrowH);
        ctx.lineTo(x + spacing, y - 2);
        ctx.stroke();
        // Arrowhead down
        ctx.beginPath();
        ctx.moveTo(x + spacing - 3, y - 6);
        ctx.lineTo(x + spacing, y - 2);
        ctx.lineTo(x + spacing + 3, y - 6);
        ctx.fill();
    }
}

function updateInfo() {
    const config = getOrbitalConfig();
    const isHighSpin = fieldStrength <= 5;
    const geoNames = { octahedral: 'Octahedral', tetrahedral: 'Tetrahedral', square_planar: 'Square Planar' };

    let unpairedCount = 0;
    const filling = fillElectrons(config);
    // Count unpaired: for each level, unpaired = filled - 2*(filled - orbitals) if filled > orbitals else filled
    for (let level of filling) {
        const orbs = level.orbitals.length;
        if (level.filled <= orbs) {
            unpairedCount += level.filled;
        } else {
            unpairedCount += orbs * 2 - level.filled;
        }
    }

    document.getElementById('infoPanel').innerHTML = `
        <h3>${geoNames[geometry]} Field</h3>
        <div>d-electrons: ${dElectrons}</div>
        <div>Spin state: ${isHighSpin && geometry !== 'square_planar' ? 'High Spin' : 'Low Spin'}</div>
        <div>Unpaired e⁻: ${unpairedCount}</div>
        <div>Δ = ${config.delta.toFixed(0)} (arb. units)</div>
        ${geometry === 'octahedral' ? '<div style="margin-top:6px;font-size:11px;color:#888;">Ligands on ±x, ±y, ±z axes<br>eg points toward ligands<br>t₂g points between ligands</div>' : ''}
        ${geometry === 'tetrahedral' ? '<div style="margin-top:6px;font-size:11px;color:#888;">Δ_tet ≈ 4/9 Δ_oct<br>Usually high spin<br>t₂ points toward ligands</div>' : ''}
        ${geometry === 'square_planar' ? '<div style="margin-top:6px;font-size:11px;color:#888;">Ligands in xy-plane<br>dx²-y² highest energy<br>Favored for d⁸ complexes</div>' : ''}
    `;
}

function draw() {
    animTime += 0.02;
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Draw geometry on left side
    const geoCX = W * 0.3;
    const geoCY = H * 0.45;
    drawLigandGeometry(geoCX, geoCY);

    // Geometry label
    const geoNames = { octahedral: 'Octahedral (Oh)', tetrahedral: 'Tetrahedral (Td)', square_planar: 'Square Planar (D4h)' };
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(geoNames[geometry], geoCX, geoCY + 170);

    // Energy diagram on right side
    const dw = Math.min(400, W * 0.45);
    const dh = H - 200;
    const dx = W - dw - 30;
    const dy = 80;
    drawEnergyDiagram(dx, dy, dw, dh);

    updateInfo();
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
