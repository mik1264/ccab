<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Pack - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let circles = [];
        const MAX_CIRCLES = 500;
        const MAX_ATTEMPTS = 100;
        let minRadius, maxRadius;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initCircles();
        }

        function initCircles() {
            circles = [];
            minRadius = 5;
            maxRadius = min(width, height) * 0.1;
        }

        function addCircle() {
            for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
                const x = random(maxRadius, width - maxRadius);
                const y = random(maxRadius, height - maxRadius);

                // Find maximum possible radius
                let maxPossibleRadius = maxRadius;

                // Check distance to edges
                maxPossibleRadius = min(maxPossibleRadius, x, y, width - x, height - y);

                // Check distance to other circles
                for (let c of circles) {
                    const d = dist(x, y, c.x, c.y) - c.radius;
                    maxPossibleRadius = min(maxPossibleRadius, d);
                }

                if (maxPossibleRadius >= minRadius) {
                    // Found valid position
                    circles.push({
                        x: x,
                        y: y,
                        radius: 0,
                        targetRadius: maxPossibleRadius * random(0.8, 1),
                        hue: random(360),
                        growSpeed: random(0.5, 2),
                        birthTime: millis()
                    });
                    return true;
                }
            }
            return false;
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();

            // Try to add new circles
            if (circles.length < MAX_CIRCLES) {
                for (let i = 0; i < 5; i++) {
                    if (!addCircle()) break;
                }
            }

            // Reset periodically
            if (circles.length >= MAX_CIRCLES - 10 || (circles.length > 100 && frameCount % 600 === 0)) {
                initCircles();
            }

            // Update and draw circles
            for (let c of circles) {
                // Grow toward target
                if (c.radius < c.targetRadius) {
                    c.radius += c.growSpeed;
                    c.radius = min(c.radius, c.targetRadius);
                }

                const age = time - c.birthTime;
                const alpha = min(100, age / 5);

                // Pulse
                const pulse = 1 + sin(time * 0.002 + c.birthTime * 0.01) * 0.02;
                const displayRadius = c.radius * pulse;

                // Outer glow
                noStroke();
                for (let r = displayRadius * 1.3; r > displayRadius; r -= 3) {
                    fill(c.hue, 50, 70, map(r, displayRadius * 1.3, displayRadius, 5, 0));
                    ellipse(c.x, c.y, r * 2);
                }

                // Main circle
                fill(c.hue, 55, 70, alpha);
                stroke(c.hue, 65, 50, alpha);
                strokeWeight(1);
                ellipse(c.x, c.y, displayRadius * 2);

                // Inner gradient
                noStroke();
                for (let r = displayRadius * 0.8; r > 0; r -= displayRadius * 0.2) {
                    const innerAlpha = map(r, displayRadius * 0.8, 0, 5, 20);
                    fill(c.hue, 40, 85, innerAlpha);
                    ellipse(c.x - displayRadius * 0.1, c.y - displayRadius * 0.1, r * 2);
                }

                // Highlight
                fill(0, 0, 100, alpha * 0.4);
                ellipse(c.x - displayRadius * 0.3, c.y - displayRadius * 0.3, displayRadius * 0.3);
            }

            // Info
            fill(60, 30, 60);
            noStroke();
            textSize(14);
            textAlign(LEFT, TOP);
            text(`Circles: ${circles.length}`, 20, height - 40);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initCircles();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
