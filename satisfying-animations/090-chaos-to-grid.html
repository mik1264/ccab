<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos to Grid - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let dots = [];
        const GRID_SIZE = 12;
        let spacing;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateDots();
        }

        function generateDots() {
            dots = [];
            spacing = min(width, height) * 0.6 / GRID_SIZE;

            const offsetX = (width - spacing * (GRID_SIZE - 1)) / 2;
            const offsetY = (height - spacing * (GRID_SIZE - 1)) / 2;

            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const targetX = offsetX + col * spacing;
                    const targetY = offsetY + row * spacing;

                    dots.push({
                        targetX: targetX,
                        targetY: targetY,
                        x: random(width),
                        y: random(height),
                        vx: random(-3, 3),
                        vy: random(-3, 3),
                        hue: (row * 15 + col * 15 + 180) % 360,
                        size: spacing * 0.3
                    });
                }
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 10000;
            const cycleTime = time % cycleDuration;

            // Animation phases
            let phase, progress;

            if (cycleTime < 3000) {
                phase = 'chaos';
                progress = 0;
            } else if (cycleTime < 7000) {
                phase = 'forming';
                progress = easeOutBack((cycleTime - 3000) / 4000);
            } else if (cycleTime < 9000) {
                phase = 'grid';
                progress = 1;
            } else {
                phase = 'scatter';
                progress = 1 - easeInOutCubic((cycleTime - 9000) / 1000);
            }

            // Draw connecting lines when forming grid
            if (progress > 0.5) {
                const lineAlpha = (progress - 0.5) * 2 * 30;
                stroke(230, 30, 40, lineAlpha);
                strokeWeight(1);

                // Horizontal lines
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE - 1; col++) {
                        const i1 = row * GRID_SIZE + col;
                        const i2 = row * GRID_SIZE + col + 1;
                        line(dots[i1].x, dots[i1].y, dots[i2].x, dots[i2].y);
                    }
                }

                // Vertical lines
                for (let row = 0; row < GRID_SIZE - 1; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const i1 = row * GRID_SIZE + col;
                        const i2 = (row + 1) * GRID_SIZE + col;
                        line(dots[i1].x, dots[i1].y, dots[i2].x, dots[i2].y);
                    }
                }
            }

            // Update and draw dots
            for (let dot of dots) {
                if (phase === 'chaos') {
                    // Random motion
                    dot.x += dot.vx;
                    dot.y += dot.vy;

                    // Bounce
                    if (dot.x < dot.size || dot.x > width - dot.size) dot.vx *= -1;
                    if (dot.y < dot.size || dot.y > height - dot.size) dot.vy *= -1;

                    dot.x = constrain(dot.x, dot.size, width - dot.size);
                    dot.y = constrain(dot.y, dot.size, height - dot.size);

                    // Store chaos position for interpolation
                    dot.chaosX = dot.x;
                    dot.chaosY = dot.y;
                } else if (phase === 'forming' || phase === 'grid') {
                    // Interpolate to grid
                    if (dot.chaosX !== undefined) {
                        dot.x = lerp(dot.chaosX, dot.targetX, progress);
                        dot.y = lerp(dot.chaosY, dot.targetY, progress);
                    }
                } else if (phase === 'scatter') {
                    // Interpolate back to chaos
                    dot.x = lerp(dot.chaosX, dot.targetX, progress);
                    dot.y = lerp(dot.chaosY, dot.targetY, progress);
                }

                // Pulse when in grid
                let displaySize = dot.size;
                if (phase === 'grid') {
                    displaySize *= 1 + sin(time * 0.005 + dot.hue * 0.1) * 0.1;
                }

                // Draw dot
                // Glow
                fill(dot.hue, 50, 70, 20);
                noStroke();
                ellipse(dot.x, dot.y, displaySize * 2);

                // Main dot
                fill(dot.hue, 60, 80);
                stroke(dot.hue, 70, 60);
                strokeWeight(1);
                ellipse(dot.x, dot.y, displaySize);

                // Highlight
                fill(dot.hue, 30, 95, 50);
                noStroke();
                ellipse(dot.x - displaySize * 0.15, dot.y - displaySize * 0.15, displaySize * 0.25);
            }

            // Reset chaos positions at cycle end
            if (phase === 'scatter' && cycleTime > 9900) {
                for (let dot of dots) {
                    dot.chaosX = random(width);
                    dot.chaosY = random(height);
                    dot.x = dot.chaosX;
                    dot.y = dot.chaosY;
                    dot.vx = random(-3, 3);
                    dot.vy = random(-3, 3);
                }
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateDots();
        }
    </script>
</body>
</html>
