<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scattered Letters - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let letters = [];
        const words = ['SATISFYING', 'BEAUTIFUL', 'MESMERIZE', 'HYPNOTIC'];
        let currentWord = 0;
        let fontSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            textFont('Georgia');
            generateLetters();
        }

        function generateLetters() {
            letters = [];
            fontSize = min(width, height) * 0.12;

            const word = words[currentWord];
            textSize(fontSize);

            // Calculate total width for centering
            let totalWidth = 0;
            for (let char of word) {
                totalWidth += textWidth(char);
            }

            const startX = (width - totalWidth) / 2;
            const centerY = height / 2;

            let currentX = startX;
            for (let i = 0; i < word.length; i++) {
                const char = word[i];
                const charWidth = textWidth(char);

                letters.push({
                    char: char,
                    targetX: currentX + charWidth / 2,
                    targetY: centerY,
                    x: random(width),
                    y: random(height),
                    rotation: random(-PI, PI),
                    targetRotation: 0,
                    hue: (i / word.length * 60 + 30) % 360,
                    delay: i * 150,
                    scale: 1
                });

                currentX += charWidth;
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 6000;
            const cycleTime = time % cycleDuration;

            // Switch words
            const wordIndex = floor(time / cycleDuration) % words.length;
            if (wordIndex !== currentWord) {
                currentWord = wordIndex;
                generateLetters();
            }

            // Animation phases
            let phase;

            if (cycleTime < 3000) {
                phase = 'forming';
            } else if (cycleTime < 5000) {
                phase = 'complete';
            } else {
                phase = 'scatter';
            }

            for (let letter of letters) {
                let progress;

                if (phase === 'forming') {
                    const letterTime = max(0, cycleTime - letter.delay);
                    progress = min(1, letterTime / 1500);
                    progress = easeOutBack(progress);
                } else if (phase === 'complete') {
                    progress = 1;
                } else {
                    const scatterTime = cycleTime - 5000;
                    progress = 1 - min(1, scatterTime / 800);
                }

                // Interpolate position and rotation
                const x = lerp(letter.x, letter.targetX, progress);
                const y = lerp(letter.y, letter.targetY, progress);
                const rotation = lerp(letter.rotation, letter.targetRotation, progress);

                // Scale bounce
                let scale = 1;
                if (phase === 'complete') {
                    scale = 1 + sin(time * 0.005 + letter.delay) * 0.05;
                }

                push();
                translate(x, y);
                rotate(rotation);
                scale(scale);

                // Shadow
                fill(0, 0, 0, 30);
                noStroke();
                textSize(fontSize);
                textAlign(CENTER, CENTER);
                text(letter.char, 3, 3);

                // Main letter
                fill(letter.hue, 60, 80);
                stroke(letter.hue, 70, 60);
                strokeWeight(2);
                text(letter.char, 0, 0);

                pop();
            }

            // Glow behind word when complete
            if (phase === 'complete') {
                const glowAlpha = 20 + sin(time * 0.003) * 10;
                const word = words[currentWord];
                textSize(fontSize);

                let totalWidth = 0;
                for (let char of word) {
                    totalWidth += textWidth(char);
                }

                fill(45, 40, 60, glowAlpha);
                noStroke();
                rectMode(CENTER);
                rect(width / 2, height / 2, totalWidth + 40, fontSize + 30, 20);
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateLetters();
        }
    </script>
</body>
</html>
