<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Sort - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let balls = [];
        const NUM_COLS = 15;
        let colWidth, ballSize;
        let slots = [];

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateBalls();
        }

        function generateBalls() {
            balls = [];
            slots = [];

            colWidth = width * 0.8 / NUM_COLS;
            ballSize = colWidth * 0.8;

            const startX = width * 0.1 + colWidth / 2;
            const bottomY = height * 0.85;

            // Initialize slots (how many balls in each column)
            for (let i = 0; i < NUM_COLS; i++) {
                slots[i] = 0;
            }

            // Create balls with different weights (sizes)
            for (let col = 0; col < NUM_COLS; col++) {
                const numBalls = floor(random(3, 8));

                for (let row = 0; row < numBalls; row++) {
                    // Random size representing weight (larger = heavier)
                    const weight = random(0.4, 1);

                    balls.push({
                        col: col,
                        weight: weight,
                        size: ballSize * weight,
                        x: startX + col * colWidth,
                        y: random(-height * 0.5, -50),
                        vy: 0,
                        targetY: 0,
                        landed: false,
                        settling: false,
                        hue: weight * 60 + 180 // Blue to cyan based on weight
                    });
                }
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 12000;
            const cycleTime = time % cycleDuration;

            const gravity = 0.4;
            const bounce = 0.3;
            const startX = width * 0.1 + colWidth / 2;
            const bottomY = height * 0.85;

            // Reset at cycle start
            if (cycleTime < 50) {
                generateBalls();
            }

            // Draw column guides
            stroke(230, 30, 25);
            strokeWeight(1);
            for (let i = 0; i <= NUM_COLS; i++) {
                const x = width * 0.1 + i * colWidth;
                line(x, height * 0.1, x, bottomY + 20);
            }

            // Draw bottom
            fill(230, 40, 20);
            noStroke();
            rect(width * 0.1 - 10, bottomY + 10, width * 0.8 + 20, 20, 5);

            // Sort balls by column for slot calculation
            const ballsByCol = [];
            for (let i = 0; i < NUM_COLS; i++) {
                ballsByCol[i] = balls.filter(b => b.col === i).sort((a, b) => b.weight - a.weight);
            }

            // Calculate target positions (heaviest at bottom)
            for (let col = 0; col < NUM_COLS; col++) {
                const colBalls = ballsByCol[col];
                let currentY = bottomY;

                for (let i = 0; i < colBalls.length; i++) {
                    const ball = colBalls[i];
                    ball.targetY = currentY - ball.size / 2;
                    currentY -= ball.size + 2;
                }
            }

            // Physics update
            for (let ball of balls) {
                if (!ball.landed) {
                    ball.vy += gravity;
                    ball.y += ball.vy;

                    // Check if reached target
                    if (ball.y >= ball.targetY) {
                        ball.y = ball.targetY;

                        if (ball.vy > 1) {
                            ball.vy *= -bounce;
                            // Squash effect
                            ball.squash = 0.7;
                        } else {
                            ball.vy = 0;
                            ball.landed = true;
                            ball.squash = 1;
                        }
                    }
                } else {
                    // Settle toward target
                    const diff = ball.targetY - ball.y;
                    ball.y += diff * 0.1;
                }

                // Recover from squash
                if (ball.squash !== undefined && ball.squash < 1) {
                    ball.squash += 0.05;
                    ball.squash = min(1, ball.squash);
                }
            }

            // Draw balls (sorted by y for proper overlap)
            balls.sort((a, b) => a.y - b.y);

            for (let ball of balls) {
                const squash = ball.squash || 1;
                const stretch = 2 - squash;

                push();
                translate(ball.x, ball.y);
                scale(stretch, squash);

                // Shadow
                fill(0, 0, 0, 25);
                noStroke();
                ellipse(2, 2, ball.size);

                // Main ball
                fill(ball.hue, 55, 70);
                stroke(ball.hue, 65, 50);
                strokeWeight(1.5);
                ellipse(0, 0, ball.size);

                // Highlight
                fill(ball.hue, 35, 90, 50);
                noStroke();
                ellipse(-ball.size * 0.2, -ball.size * 0.2, ball.size * 0.3);

                pop();
            }

            // Legend
            fill(0, 0, 100, 50);
            noStroke();
            textSize(12);
            textAlign(LEFT, TOP);
            text('Heavier balls sink to bottom', width * 0.1, height * 0.05);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateBalls();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
