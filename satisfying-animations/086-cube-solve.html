<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Solve - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);
        const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(4, 4, 6);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x404040, 0.6));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);

        // Rubik's cube colors
        const COLORS = {
            white: 0xffffff,
            yellow: 0xffff00,
            red: 0xff0000,
            orange: 0xff8000,
            blue: 0x0000ff,
            green: 0x00ff00,
            black: 0x111111
        };

        const cubies = [];
        const cubeSize = 0.95;
        const gap = 0.05;

        // Create 27 cubies
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const group = new THREE.Group();

                    // Create faces with appropriate colors
                    const materials = [
                        new THREE.MeshLambertMaterial({ color: x === 1 ? COLORS.red : COLORS.black }),
                        new THREE.MeshLambertMaterial({ color: x === -1 ? COLORS.orange : COLORS.black }),
                        new THREE.MeshLambertMaterial({ color: y === 1 ? COLORS.white : COLORS.black }),
                        new THREE.MeshLambertMaterial({ color: y === -1 ? COLORS.yellow : COLORS.black }),
                        new THREE.MeshLambertMaterial({ color: z === 1 ? COLORS.blue : COLORS.black }),
                        new THREE.MeshLambertMaterial({ color: z === -1 ? COLORS.green : COLORS.black })
                    ];

                    const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                    const cubie = new THREE.Mesh(geometry, materials);

                    // Add black edges
                    const edges = new THREE.LineSegments(
                        new THREE.EdgesGeometry(geometry),
                        new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
                    );
                    cubie.add(edges);

                    group.add(cubie);
                    group.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));

                    group.userData = {
                        homeX: x,
                        homeY: y,
                        homeZ: z,
                        currentX: x,
                        currentY: y,
                        currentZ: z
                    };

                    scene.add(group);
                    cubies.push(group);
                }
            }
        }

        // Generate solve sequence (random moves then reverse)
        let moves = [];
        const moveTypes = ['R', 'L', 'U', 'D', 'F', 'B'];
        const numScrambleMoves = 8;

        function generateMoves() {
            moves = [];
            // Scramble moves
            for (let i = 0; i < numScrambleMoves; i++) {
                const type = moveTypes[Math.floor(Math.random() * moveTypes.length)];
                const dir = Math.random() > 0.5 ? 1 : -1;
                moves.push({ type, dir, phase: 'scramble' });
            }
            // Solve moves (reverse)
            for (let i = numScrambleMoves - 1; i >= 0; i--) {
                moves.push({ type: moves[i].type, dir: -moves[i].dir, phase: 'solve' });
            }
        }

        generateMoves();

        let currentMove = -1;
        let moveProgress = 0;
        let rotatingGroup = null;
        let rotationAxis = null;
        let rotationDir = 0;

        function getCubiesForMove(move) {
            return cubies.filter(c => {
                const d = c.userData;
                switch (move.type) {
                    case 'R': return d.currentX === 1;
                    case 'L': return d.currentX === -1;
                    case 'U': return d.currentY === 1;
                    case 'D': return d.currentY === -1;
                    case 'F': return d.currentZ === 1;
                    case 'B': return d.currentZ === -1;
                }
            });
        }

        function getAxisForMove(move) {
            switch (move.type) {
                case 'R': case 'L': return new THREE.Vector3(1, 0, 0);
                case 'U': case 'D': return new THREE.Vector3(0, 1, 0);
                case 'F': case 'B': return new THREE.Vector3(0, 0, 1);
            }
        }

        function updatePositions(move) {
            const affected = getCubiesForMove(move);
            for (const c of affected) {
                const d = c.userData;
                let { currentX: x, currentY: y, currentZ: z } = d;

                // Rotate coordinates
                switch (move.type) {
                    case 'R': case 'L':
                        [d.currentY, d.currentZ] = move.dir > 0 ?
                            (move.type === 'R' ? [-z, y] : [z, -y]) :
                            (move.type === 'R' ? [z, -y] : [-z, y]);
                        break;
                    case 'U': case 'D':
                        [d.currentX, d.currentZ] = move.dir > 0 ?
                            (move.type === 'U' ? [z, -x] : [-z, x]) :
                            (move.type === 'U' ? [-z, x] : [z, -x]);
                        break;
                    case 'F': case 'B':
                        [d.currentX, d.currentY] = move.dir > 0 ?
                            (move.type === 'F' ? [-y, x] : [y, -x]) :
                            (move.type === 'F' ? [y, -x] : [-y, x]);
                        break;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const t = performance.now() * 0.001;
            const cycleDuration = 12;
            const cycleTime = t % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 0.1 && currentMove !== -1) {
                currentMove = -1;
                moveProgress = 0;
                generateMoves();

                // Reset cube positions
                for (const c of cubies) {
                    c.rotation.set(0, 0, 0);
                    c.userData.currentX = c.userData.homeX;
                    c.userData.currentY = c.userData.homeY;
                    c.userData.currentZ = c.userData.homeZ;
                }
            }

            // Calculate which move we're on
            const moveTime = 0.4;
            const pauseAfterScramble = 1;
            const pauseAfterSolve = 2;

            let elapsed = cycleTime;
            let targetMove = -1;
            let targetProgress = 0;

            // Scramble phase
            for (let i = 0; i < numScrambleMoves; i++) {
                if (elapsed < moveTime) {
                    targetMove = i;
                    targetProgress = elapsed / moveTime;
                    break;
                }
                elapsed -= moveTime;
            }

            if (targetMove === -1 && elapsed < pauseAfterScramble) {
                targetMove = numScrambleMoves - 1;
                targetProgress = 1;
            } else if (targetMove === -1) {
                elapsed -= pauseAfterScramble;

                // Solve phase
                for (let i = numScrambleMoves; i < moves.length; i++) {
                    if (elapsed < moveTime) {
                        targetMove = i;
                        targetProgress = elapsed / moveTime;
                        break;
                    }
                    elapsed -= moveTime;
                }
            }

            // Apply moves
            if (targetMove >= 0 && targetMove !== currentMove) {
                // Complete previous move
                if (currentMove >= 0 && currentMove < moves.length) {
                    updatePositions(moves[currentMove]);
                }
                currentMove = targetMove;
            }

            // Animate current move
            if (currentMove >= 0 && currentMove < moves.length) {
                const move = moves[currentMove];
                const axis = getAxisForMove(move);
                const affected = getCubiesForMove(move);
                const angle = (Math.PI / 2) * move.dir * easeInOutCubic(targetProgress);

                for (const c of affected) {
                    c.rotation.set(0, 0, 0);
                    if (axis.x) c.rotation.x = angle * (move.type === 'L' ? -1 : 1);
                    if (axis.y) c.rotation.y = angle * (move.type === 'D' ? -1 : 1);
                    if (axis.z) c.rotation.z = angle * (move.type === 'B' ? -1 : 1);
                }
            }

            // Gentle overall rotation
            scene.rotation.y = t * 0.2;

            renderer.render(scene, camera);
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        animate();

        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
