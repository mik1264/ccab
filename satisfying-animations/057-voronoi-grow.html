<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Grow - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let seeds = [];
        const NUM_SEEDS = 30;
        let growthRadius = 0;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initSeeds();
        }

        function initSeeds() {
            seeds = [];
            for (let i = 0; i < NUM_SEEDS; i++) {
                seeds.push({
                    x: random(50, width - 50),
                    y: random(50, height - 50),
                    hue: random(360),
                    spawnTime: random(0, 2000)
                });
            }
            growthRadius = 0;
        }

        function draw() {
            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Growth animation
            growthRadius = (cycleTime / cycleDuration) * max(width, height) * 0.8;

            // Draw voronoi using distance-based pixel coloring
            loadPixels();

            const resolution = 4; // Sample every 4 pixels for performance

            for (let y = 0; y < height; y += resolution) {
                for (let x = 0; x < width; x += resolution) {
                    // Find closest seed
                    let minDist = Infinity;
                    let secondDist = Infinity;
                    let closestSeed = null;

                    for (let seed of seeds) {
                        // Check if seed has spawned
                        if (cycleTime < seed.spawnTime) continue;

                        // Distance with growth factor
                        const seedAge = cycleTime - seed.spawnTime;
                        const seedRadius = min(seedAge * 0.1, growthRadius);

                        const d = dist(x, y, seed.x, seed.y) - seedRadius;

                        if (d < minDist) {
                            secondDist = minDist;
                            minDist = d;
                            closestSeed = seed;
                        } else if (d < secondDist) {
                            secondDist = d;
                        }
                    }

                    // Color based on closest seed
                    let col;
                    if (closestSeed && minDist < 0) {
                        // Inside a cell
                        const edgeDist = secondDist - minDist;
                        const isEdge = edgeDist < 8;

                        if (isEdge) {
                            col = color(closestSeed.hue, 70, 40);
                        } else {
                            // Gradient from center
                            const distFromCenter = dist(x, y, closestSeed.x, closestSeed.y);
                            const brightness = map(distFromCenter, 0, 100, 80, 60);
                            col = color(closestSeed.hue, 55, brightness);
                        }
                    } else {
                        col = color(230, 30, 10);
                    }

                    // Fill block
                    for (let dy = 0; dy < resolution && y + dy < height; dy++) {
                        for (let dx = 0; dx < resolution && x + dx < width; dx++) {
                            const idx = 4 * ((y + dy) * width + (x + dx));
                            pixels[idx] = red(col);
                            pixels[idx + 1] = green(col);
                            pixels[idx + 2] = blue(col);
                            pixels[idx + 3] = 255;
                        }
                    }
                }
            }

            updatePixels();

            // Draw seed points
            for (let seed of seeds) {
                if (cycleTime >= seed.spawnTime) {
                    const age = cycleTime - seed.spawnTime;
                    const size = min(age * 0.01, 8);

                    // Glow
                    noStroke();
                    for (let r = size * 3; r > size; r -= 2) {
                        fill(seed.hue, 60, 90, map(r, size * 3, size, 10, 0));
                        ellipse(seed.x, seed.y, r * 2);
                    }

                    // Center dot
                    fill(0, 0, 100);
                    ellipse(seed.x, seed.y, size * 2);
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initSeeds();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
