<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apollonian Gasket - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let circles = [];
        let queue = [];
        let baseRadius;
        const minRadius = 3;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            noFill();
            generateGasket();
        }

        function generateGasket() {
            circles = [];
            queue = [];
            baseRadius = min(width, height) * 0.4;

            // Start with outer circle and two tangent circles
            const c1 = { x: 0, y: 0, r: baseRadius, curvature: -1 / baseRadius, depth: 0 };

            // Two circles tangent to outer and each other
            const r2 = baseRadius / 2;
            const c2 = { x: -r2, y: 0, r: r2, curvature: 1 / r2, depth: 0 };
            const c3 = { x: r2, y: 0, r: r2, curvature: 1 / r2, depth: 0 };

            circles.push(c1, c2, c3);

            // Find fourth circle using Descartes' theorem
            const c4 = findFourthCircle(c1, c2, c3);
            if (c4) {
                circles.push(c4);
                queue.push([c1, c2, c4]);
                queue.push([c1, c3, c4]);
                queue.push([c2, c3, c4]);
            }

            // Generate more circles
            let iterations = 0;
            while (queue.length > 0 && iterations < 500) {
                const [a, b, c] = queue.shift();
                const newCircles = findTangentCircles(a, b, c);

                for (const nc of newCircles) {
                    if (nc.r > minRadius && !isDuplicate(nc)) {
                        nc.depth = Math.max(a.depth, b.depth, c.depth) + 1;
                        circles.push(nc);
                        queue.push([a, b, nc]);
                        queue.push([a, c, nc]);
                        queue.push([b, c, nc]);
                    }
                }
                iterations++;
            }

            // Sort by depth for animation order
            circles.sort((a, b) => a.depth - b.depth);

            // Assign appearance time
            circles.forEach((c, i) => {
                c.appearTime = c.depth * 200 + i * 5;
            });
        }

        function findFourthCircle(c1, c2, c3) {
            // Descartes' Circle Theorem: (k1+k2+k3+k4)^2 = 2(k1^2+k2^2+k3^2+k4^2)
            const k1 = c1.curvature, k2 = c2.curvature, k3 = c3.curvature;

            // Two solutions for k4
            const sum = k1 + k2 + k3;
            const product = 2 * Math.sqrt(k1 * k2 + k2 * k3 + k3 * k1);

            const k4 = sum + product;
            if (k4 <= 0) return null;

            const r4 = 1 / k4;

            // Find center using complex number method
            const z1 = { re: c1.x * k1, im: c1.y * k1 };
            const z2 = { re: c2.x * k2, im: c2.y * k2 };
            const z3 = { re: c3.x * k3, im: c3.y * k3 };

            const sumZ = {
                re: z1.re + z2.re + z3.re,
                im: z1.im + z2.im + z3.im
            };

            // Approximate center
            const x4 = sumZ.re / k4;
            const y4 = (baseRadius - r4);

            return { x: 0, y: y4, r: r4, curvature: k4, depth: 1 };
        }

        function findTangentCircles(c1, c2, c3) {
            const k1 = c1.curvature, k2 = c2.curvature, k3 = c3.curvature;
            const sum = k1 + k2 + k3;
            const disc = Math.sqrt(Math.abs(k1 * k2 + k2 * k3 + k3 * k1));

            const results = [];

            for (const sign of [1, -1]) {
                const k4 = sum + sign * 2 * disc;

                if (k4 > 0 && 1 / k4 > minRadius) {
                    // Estimate center position
                    const r4 = 1 / k4;

                    // Find point tangent to all three
                    const candidates = estimateCenter(c1, c2, c3, r4);

                    for (const pos of candidates) {
                        if (isValidCircle(pos.x, pos.y, r4, c1, c2, c3)) {
                            results.push({ x: pos.x, y: pos.y, r: r4, curvature: k4, depth: 0 });
                        }
                    }
                }
            }

            return results;
        }

        function estimateCenter(c1, c2, c3, r) {
            const candidates = [];

            // Try weighted average of circle centers
            const weights = [1 / c1.r, 1 / c2.r, 1 / c3.r];
            const totalWeight = weights[0] + weights[1] + weights[2];

            const cx = (c1.x * weights[0] + c2.x * weights[1] + c3.x * weights[2]) / totalWeight;
            const cy = (c1.y * weights[0] + c2.y * weights[1] + c3.y * weights[2]) / totalWeight;

            // Adjust position iteratively
            for (let i = 0; i < 10; i++) {
                const offsets = [
                    { x: 0, y: 0 },
                    { x: r * 0.5, y: 0 },
                    { x: -r * 0.5, y: 0 },
                    { x: 0, y: r * 0.5 },
                    { x: 0, y: -r * 0.5 }
                ];

                for (const off of offsets) {
                    candidates.push({ x: cx + off.x, y: cy + off.y });
                }
            }

            return candidates;
        }

        function isValidCircle(x, y, r, c1, c2, c3) {
            const tolerance = 2;

            for (const c of [c1, c2, c3]) {
                const d = dist(x, y, c.x, c.y);
                const expectedDist = c.curvature < 0 ? c.r - r : c.r + r;

                if (Math.abs(d - Math.abs(expectedDist)) > tolerance) {
                    return false;
                }
            }

            return true;
        }

        function isDuplicate(nc) {
            for (const c of circles) {
                if (Math.abs(c.x - nc.x) < 1 && Math.abs(c.y - nc.y) < 1 && Math.abs(c.r - nc.r) < 1) {
                    return true;
                }
            }
            return false;
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 10000;
            const cycleTime = time % cycleDuration;

            translate(width / 2, height / 2);

            // Animation phases
            let showProgress;
            if (cycleTime < 7000) {
                showProgress = cycleTime;
            } else if (cycleTime < 8500) {
                showProgress = 7000;
            } else {
                showProgress = 7000 * (1 - (cycleTime - 8500) / 1500);
            }

            for (const c of circles) {
                if (c.appearTime > showProgress) continue;

                const age = showProgress - c.appearTime;
                const scale = min(1, age / 300);
                const alpha = scale * (60 + 30 * (1 - c.depth / 10));

                // Color based on depth
                const hue = (c.depth * 35 + 180) % 360;

                stroke(hue, 55, 70, alpha);
                strokeWeight(1.5);
                noFill();

                const displayR = c.r * easeOutBack(scale);

                if (c.curvature < 0) {
                    // Outer circle
                    ellipse(c.x, c.y, displayR * 2);
                } else {
                    ellipse(c.x, c.y, displayR * 2);

                    // Inner glow for small circles
                    if (c.r < 30 && scale >= 1) {
                        fill(hue, 40, 80, 20);
                        noStroke();
                        ellipse(c.x, c.y, c.r);
                    }
                }
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateGasket();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
