<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Stack - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);
        const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(3, 4, 6);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x404040, 0.6));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        light.castShadow = true;
        scene.add(light);

        // Floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.MeshLambertMaterial({ color: 0x1a1a2e })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Books
        const books = [];
        const NUM_BOOKS = 8;
        const bookColors = [0xB85450, 0x4A90A4, 0x6B8E23, 0x9B59B6, 0xE67E22, 0x1ABC9C, 0x8B4513, 0x2C3E50];

        for (let i = 0; i < NUM_BOOKS; i++) {
            const width = 1.5 + Math.random() * 0.5;
            const height = 0.15 + Math.random() * 0.1;
            const depth = 2 + Math.random() * 0.3;

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color: bookColors[i] });
            const book = new THREE.Mesh(geometry, material);
            book.castShadow = true;

            book.userData = {
                width, height, depth,
                targetY: 0,
                startY: 8 + i * 0.5,
                startRotX: (Math.random() - 0.5) * 0.5,
                startRotZ: (Math.random() - 0.5) * 0.5,
                delay: i * 300,
                landed: false,
                squash: 1
            };

            scene.add(book);
            books.push(book);
        }

        // Calculate target positions (stacked)
        let currentY = 0;
        for (let book of books) {
            book.userData.targetY = currentY + book.userData.height / 2;
            currentY += book.userData.height;
        }

        function animate() {
            requestAnimationFrame(animate);

            const t = performance.now() * 0.001;
            const cycleDuration = 10;
            const cycleTime = t % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 0.05) {
                for (let book of books) {
                    book.userData.landed = false;
                    book.userData.squash = 1;
                }
            }

            // Update books
            for (let i = 0; i < books.length; i++) {
                const book = books[i];
                const d = book.userData;

                const bookTime = cycleTime * 1000 - d.delay;

                if (bookTime < 0) {
                    // Not started
                    book.position.y = d.startY;
                    book.rotation.x = d.startRotX;
                    book.rotation.z = d.startRotZ;
                } else if (bookTime < 800) {
                    // Falling
                    const progress = bookTime / 800;
                    const eased = easeOutBounce(progress);

                    book.position.y = d.startY + (d.targetY - d.startY) * eased;
                    book.rotation.x = d.startRotX * (1 - eased);
                    book.rotation.z = d.startRotZ * (1 - eased);

                    // Squash on impact
                    if (progress > 0.7 && !d.landed) {
                        d.squash = 0.8;
                        d.landed = true;
                    }
                } else {
                    // Landed
                    book.position.y = d.targetY;
                    book.rotation.x = 0;
                    book.rotation.z = 0;
                }

                // Recover from squash
                if (d.squash < 1) {
                    d.squash += 0.05;
                    d.squash = Math.min(1, d.squash);
                }

                book.scale.y = d.squash;
                book.scale.x = 1 + (1 - d.squash) * 0.2;
                book.scale.z = 1 + (1 - d.squash) * 0.2;

                book.position.x = 0;
                book.position.z = 0;
            }

            // Gentle camera movement
            camera.position.x = 3 + Math.sin(t * 0.3) * 0.5;
            camera.position.z = 6 + Math.cos(t * 0.2) * 0.5;
            camera.lookAt(0, currentY / 2, 0);

            renderer.render(scene, camera);
        }

        function easeOutBounce(x) {
            const n1 = 7.5625;
            const d1 = 2.75;

            if (x < 1 / d1) {
                return n1 * x * x;
            } else if (x < 2 / d1) {
                return n1 * (x -= 1.5 / d1) * x + 0.75;
            } else if (x < 2.5 / d1) {
                return n1 * (x -= 2.25 / d1) * x + 0.9375;
            } else {
                return n1 * (x -= 2.625 / d1) * x + 0.984375;
            }
        }

        animate();

        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
