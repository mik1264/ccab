<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation Connect - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let stars = [];
        let connections = [];
        let bgStars = [];
        const constellations = [
            // Big Dipper-like pattern
            [[0.3, 0.3], [0.4, 0.35], [0.5, 0.4], [0.55, 0.5], [0.65, 0.55], [0.7, 0.5], [0.65, 0.45]],
            // Orion-like pattern
            [[0.4, 0.25], [0.5, 0.3], [0.6, 0.25], [0.45, 0.45], [0.5, 0.5], [0.55, 0.45], [0.5, 0.7]],
            // Simple triangle
            [[0.3, 0.6], [0.5, 0.3], [0.7, 0.6], [0.5, 0.5]],
            // W shape (Cassiopeia-like)
            [[0.25, 0.4], [0.35, 0.55], [0.45, 0.4], [0.55, 0.55], [0.65, 0.4]]
        ];
        let currentConstellation = 0;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);

            // Background stars
            for (let i = 0; i < 200; i++) {
                bgStars.push({
                    x: random(width),
                    y: random(height),
                    size: random(0.5, 2),
                    twinkle: random(1000)
                });
            }

            generateConstellation();
        }

        function generateConstellation() {
            stars = [];
            connections = [];

            const pattern = constellations[currentConstellation];

            // Create stars from pattern
            for (let i = 0; i < pattern.length; i++) {
                const [px, py] = pattern[i];
                stars.push({
                    x: px * width,
                    y: py * height,
                    size: random(4, 8),
                    brightness: random(0.7, 1),
                    delay: i * 300
                });
            }

            // Create connections (sequential)
            for (let i = 0; i < stars.length - 1; i++) {
                connections.push({
                    from: i,
                    to: i + 1,
                    delay: (i + 1) * 300 + 200
                });
            }
        }

        function draw() {
            background(230, 60, 8);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Switch constellation
            const newConstellation = floor(time / cycleDuration) % constellations.length;
            if (newConstellation !== currentConstellation) {
                currentConstellation = newConstellation;
                generateConstellation();
            }

            // Draw background stars
            noStroke();
            for (let star of bgStars) {
                const twinkle = 0.5 + 0.5 * sin(time * 0.003 + star.twinkle);
                fill(45, 10, 80, 50 * twinkle);
                ellipse(star.x, star.y, star.size);
            }

            // Animation progress
            let animProgress;
            if (cycleTime < 5000) {
                animProgress = cycleTime;
            } else if (cycleTime < 7000) {
                animProgress = 10000; // All visible
            } else {
                animProgress = 10000 - (cycleTime - 7000) * 10;
            }

            // Draw connections
            for (let conn of connections) {
                const connProgress = constrain((animProgress - conn.delay) / 500, 0, 1);

                if (connProgress > 0) {
                    const from = stars[conn.from];
                    const to = stars[conn.to];

                    const eased = easeOutCubic(connProgress);

                    const currentX = lerp(from.x, to.x, eased);
                    const currentY = lerp(from.y, to.y, eased);

                    // Line glow
                    stroke(45, 30, 70, 30);
                    strokeWeight(4);
                    line(from.x, from.y, currentX, currentY);

                    // Main line
                    stroke(45, 20, 90, 60);
                    strokeWeight(1.5);
                    line(from.x, from.y, currentX, currentY);
                }
            }

            // Draw stars
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                const starProgress = constrain((animProgress - star.delay) / 400, 0, 1);

                if (starProgress > 0) {
                    const eased = easeOutBack(starProgress);
                    const size = star.size * eased;

                    // Twinkle
                    const twinkle = 0.8 + 0.2 * sin(time * 0.005 + i);

                    // Star glow
                    for (let g = 3; g > 0; g--) {
                        fill(45, 20, 90 * star.brightness * twinkle, 30 / g);
                        noStroke();
                        ellipse(star.x, star.y, size * (1 + g));
                    }

                    // Star core
                    fill(45, 10, 100 * star.brightness * twinkle);
                    ellipse(star.x, star.y, size);

                    // Star points (4-point star shape)
                    stroke(45, 10, 100 * star.brightness * twinkle, 60);
                    strokeWeight(1);
                    const pointLength = size * 1.5;
                    line(star.x - pointLength, star.y, star.x + pointLength, star.y);
                    line(star.x, star.y - pointLength, star.x, star.y + pointLength);
                }
            }

            // Satisfaction glow when complete
            if (cycleTime > 5000 && cycleTime < 7000) {
                const glowProgress = (cycleTime - 5000) / 2000;
                const alpha = sin(glowProgress * PI) * 20;

                fill(45, 30, 80, alpha);
                noStroke();
                beginShape();
                for (let star of stars) {
                    vertex(star.x, star.y);
                }
                endShape(CLOSE);
            }
        }

        function easeOutCubic(x) {
            return 1 - pow(1 - x, 3);
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);

            // Regenerate background stars
            bgStars = [];
            for (let i = 0; i < 200; i++) {
                bgStars.push({
                    x: random(width),
                    y: random(height),
                    size: random(0.5, 2),
                    twinkle: random(1000)
                });
            }

            generateConstellation();
        }
    </script>
</body>
</html>
