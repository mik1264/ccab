<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Origami Fold - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);
        const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x404040, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
        light2.position.set(-5, 5, -5);
        scene.add(light2);

        // Paper material (both sides)
        const paperFront = new THREE.MeshStandardMaterial({
            color: 0xBC6C25,
            side: THREE.FrontSide,
            roughness: 0.8,
            metalness: 0.1
        });

        const paperBack = new THREE.MeshStandardMaterial({
            color: 0xFEFAE0,
            side: THREE.BackSide,
            roughness: 0.9,
            metalness: 0
        });

        // Create paper panels that fold
        const panels = [];
        const panelSize = 1;

        // Main body (4 panels that fold up)
        const positions = [
            {x: 0, z: -panelSize, rotAxis: 'x', rotDir: 1},   // Back
            {x: 0, z: panelSize, rotAxis: 'x', rotDir: -1},   // Front
            {x: -panelSize, z: 0, rotAxis: 'z', rotDir: -1},  // Left
            {x: panelSize, z: 0, rotAxis: 'z', rotDir: 1}     // Right
        ];

        // Center panel (base)
        const centerGeo = new THREE.PlaneGeometry(panelSize * 2, panelSize * 2);
        const centerFront = new THREE.Mesh(centerGeo, paperFront);
        const centerBack = new THREE.Mesh(centerGeo, paperBack);
        centerFront.rotation.x = -Math.PI / 2;
        centerBack.rotation.x = -Math.PI / 2;
        scene.add(centerFront);
        scene.add(centerBack);

        // Folding panels
        positions.forEach((pos, i) => {
            const group = new THREE.Group();

            const geo = new THREE.PlaneGeometry(panelSize * 2, panelSize * 2);
            const front = new THREE.Mesh(geo, paperFront.clone());
            const back = new THREE.Mesh(geo, paperBack.clone());

            front.rotation.x = -Math.PI / 2;
            back.rotation.x = -Math.PI / 2;

            // Offset pivot point
            if (pos.rotAxis === 'x') {
                front.position.z = pos.rotDir * panelSize;
                back.position.z = pos.rotDir * panelSize;
            } else {
                front.position.x = pos.rotDir * panelSize;
                back.position.x = pos.rotDir * panelSize;
            }

            group.add(front);
            group.add(back);

            // Position group at fold line
            group.position.x = pos.x;
            group.position.z = pos.z;

            panels.push({
                group: group,
                rotAxis: pos.rotAxis,
                rotDir: pos.rotDir,
                delay: i * 0.15
            });

            scene.add(group);
        });

        // Top flaps (fold after sides)
        const topFlaps = [];
        const flapPositions = [
            {parent: 0, offset: {x: 0, y: 0, z: -panelSize * 2}},
            {parent: 1, offset: {x: 0, y: 0, z: panelSize * 2}}
        ];

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now() * 0.001;

            // Fold cycle
            const cycleDuration = 6;
            const cycleTime = t % cycleDuration;

            let foldProgress;
            if (cycleTime < 2) {
                // Folding up
                foldProgress = easeInOutCubic(cycleTime / 2);
            } else if (cycleTime < 4) {
                // Holding folded
                foldProgress = 1;
            } else {
                // Unfolding
                foldProgress = 1 - easeInOutCubic((cycleTime - 4) / 2);
            }

            // Animate each panel
            panels.forEach((panel, i) => {
                const delayedProgress = Math.max(0, Math.min(1, (foldProgress - panel.delay) / (1 - panel.delay * panels.length / (panels.length - 1))));
                const angle = delayedProgress * Math.PI / 2;

                if (panel.rotAxis === 'x') {
                    panel.group.rotation.x = angle * panel.rotDir;
                } else {
                    panel.group.rotation.z = angle * panel.rotDir;
                }
            });

            // Gentle scene rotation
            scene.rotation.y = Math.sin(t * 0.3) * 0.3;

            renderer.render(scene, camera);
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        animate();

        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
