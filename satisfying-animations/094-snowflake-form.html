<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowflake Form - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let branches = [];
        let crystals = [];
        let baseLength;
        const SYMMETRY = 6;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateSnowflake();
        }

        function generateSnowflake() {
            branches = [];
            crystals = [];
            baseLength = min(width, height) * 0.35;

            // Generate one arm, will be reflected 6 times
            generateArm(0, baseLength, 0, 0);
        }

        function generateArm(startDist, length, depth, delay) {
            if (length < 5 || depth > 5) return;

            branches.push({
                startDist: startDist,
                length: length,
                depth: depth,
                delay: delay,
                thickness: map(depth, 0, 5, 4, 1)
            });

            // Add crystal at end
            if (depth > 1 && random() > 0.5) {
                crystals.push({
                    dist: startDist + length,
                    size: random(5, 12),
                    delay: delay + 200
                });
            }

            // Sub-branches
            const numSub = depth < 2 ? 3 : 2;
            const subLength = length * random(0.4, 0.6);
            const subDelay = 200;

            for (let i = 0; i < numSub; i++) {
                const subStart = startDist + length * (0.3 + i * 0.25);
                generateArm(subStart, subLength, depth + 1, delay + subDelay * (i + 1));
            }

            // Continue main arm
            if (depth < 3) {
                generateArm(startDist + length, length * 0.6, depth + 1, delay + subDelay);
            }
        }

        function draw() {
            background(220, 40, 15);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 50) {
                generateSnowflake();
            }

            // Calculate growth progress
            let growProgress;
            if (cycleTime < 5000) {
                growProgress = cycleTime;
            } else if (cycleTime < 6500) {
                growProgress = 5000;
            } else {
                growProgress = 5000 - (cycleTime - 6500) * 4;
            }

            translate(width / 2, height / 2);

            // Slow rotation
            rotate(time * 0.0002);

            // Draw snowflake with 6-fold symmetry
            for (let s = 0; s < SYMMETRY; s++) {
                push();
                rotate(s * TWO_PI / SYMMETRY);

                // Draw branches
                for (let branch of branches) {
                    const branchProgress = constrain((growProgress - branch.delay) / 400, 0, 1);

                    if (branchProgress > 0) {
                        const eased = easeOutCubic(branchProgress);
                        const currentLength = branch.length * eased;

                        // Ice blue color
                        stroke(200, 30, 90, 80);
                        strokeWeight(branch.thickness);

                        const startX = branch.startDist;
                        const endX = branch.startDist + currentLength;

                        line(startX, 0, endX, 0);

                        // Mirror on other side of arm
                        if (branch.depth > 0) {
                            push();
                            scale(1, -1);
                            line(startX, 0, endX, 0);
                            pop();
                        }

                        // Side branches
                        if (branch.depth > 0 && branchProgress > 0.5) {
                            const sideProgress = (branchProgress - 0.5) * 2;
                            const sideLength = branch.length * 0.3 * easeOutCubic(sideProgress);

                            strokeWeight(branch.thickness * 0.6);

                            push();
                            translate(branch.startDist + branch.length * 0.5, 0);
                            rotate(PI / 3);
                            line(0, 0, sideLength, 0);
                            pop();

                            push();
                            translate(branch.startDist + branch.length * 0.5, 0);
                            rotate(-PI / 3);
                            line(0, 0, sideLength, 0);
                            pop();
                        }
                    }
                }

                // Draw crystals
                for (let crystal of crystals) {
                    const crystalProgress = constrain((growProgress - crystal.delay) / 300, 0, 1);

                    if (crystalProgress > 0) {
                        const eased = easeOutBack(crystalProgress);
                        const size = crystal.size * eased;

                        fill(200, 20, 95, 70);
                        stroke(200, 30, 80);
                        strokeWeight(1);

                        push();
                        translate(crystal.dist, 0);

                        // Hexagonal crystal
                        beginShape();
                        for (let i = 0; i < 6; i++) {
                            const angle = i * PI / 3;
                            vertex(cos(angle) * size, sin(angle) * size);
                        }
                        endShape(CLOSE);

                        pop();
                    }
                }

                pop();
            }

            // Center crystal
            const centerProgress = constrain(growProgress / 500, 0, 1);
            if (centerProgress > 0) {
                const size = 15 * easeOutBack(centerProgress);

                fill(200, 15, 98, 80);
                stroke(200, 25, 85);
                strokeWeight(2);

                beginShape();
                for (let i = 0; i < 6; i++) {
                    const angle = i * PI / 3;
                    vertex(cos(angle) * size, sin(angle) * size);
                }
                endShape(CLOSE);
            }

            // Sparkle effect when complete
            if (cycleTime > 5000 && cycleTime < 6500) {
                const sparkleAlpha = sin((cycleTime - 5000) / 1500 * PI) * 100;
                fill(200, 10, 100, sparkleAlpha);
                noStroke();
                for (let i = 0; i < 20; i++) {
                    const angle = random(TWO_PI);
                    const dist = random(baseLength * 0.8);
                    const size = random(2, 5);
                    ellipse(cos(angle) * dist, sin(angle) * dist, size);
                }
            }
        }

        function easeOutCubic(x) {
            return 1 - pow(1 - x, 3);
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateSnowflake();
        }
    </script>
</body>
</html>
