<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storm Clouds - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        const vertexShader = `#version 300 es
            in vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShader = `#version 300 es
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            out vec4 fragColor;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            float fbm(vec2 p) {
                float sum = 0.0;
                float amp = 0.5;
                for(int i = 0; i < 7; i++) {
                    sum += noise(p) * amp;
                    p *= 2.0;
                    amp *= 0.5;
                }
                return sum;
            }

            // Turbulent fbm for storm clouds
            float turbulentFbm(vec2 p, float t) {
                float sum = 0.0;
                float amp = 0.5;
                float freq = 1.0;

                for(int i = 0; i < 6; i++) {
                    float n = noise(p * freq + t * float(i + 1) * 0.1);
                    sum += abs(n * 2.0 - 1.0) * amp;
                    freq *= 2.0;
                    amp *= 0.5;
                }

                return sum;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution;
                float t = time * 0.3;

                // Moving cloud base
                vec2 cloudUV = uv;
                cloudUV.x += t * 0.1;

                // Multiple cloud layers
                float clouds1 = fbm(cloudUV * 2.0 + t * 0.05);
                float clouds2 = fbm(cloudUV * 3.0 - t * 0.08);
                float clouds3 = turbulentFbm(cloudUV * 4.0, t * 0.5);

                // Combine layers
                float clouds = clouds1 * 0.5 + clouds2 * 0.3 + clouds3 * 0.4;

                // Storm intensity varies
                float stormIntensity = sin(t * 0.2) * 0.3 + 0.7;
                clouds = pow(clouds, 1.0 - stormIntensity * 0.3);

                // Dark storm colors
                vec3 darkCloud = vec3(0.1, 0.12, 0.15);
                vec3 midCloud = vec3(0.25, 0.28, 0.35);
                vec3 lightCloud = vec3(0.4, 0.45, 0.55);

                // Sky gradient (ominous)
                vec3 skyTop = vec3(0.15, 0.18, 0.25);
                vec3 skyBottom = vec3(0.2, 0.22, 0.28);
                vec3 sky = mix(skyBottom, skyTop, uv.y);

                // Cloud color based on density
                vec3 cloudColor = mix(lightCloud, midCloud, clouds);
                cloudColor = mix(cloudColor, darkCloud, pow(clouds, 2.0));

                // Lightning flash
                float lightningTime = mod(t * 2.0, 4.0);
                float flash = 0.0;
                if(lightningTime < 0.1) {
                    flash = 1.0 - lightningTime * 10.0;
                } else if(lightningTime > 1.5 && lightningTime < 1.6) {
                    flash = (lightningTime - 1.5) * 10.0;
                    flash = 1.0 - flash;
                }
                flash = pow(flash, 2.0);

                // Lightning bolt
                float bolt = 0.0;
                if(flash > 0.1) {
                    vec2 boltUV = uv;
                    boltUV.x += sin(boltUV.y * 30.0 + t * 50.0) * 0.02;
                    boltUV.x += sin(boltUV.y * 10.0) * 0.05;

                    float boltX = 0.5 + sin(floor(t * 0.5) * 12.34) * 0.3;
                    float boltDist = abs(boltUV.x - boltX);

                    // Main bolt
                    bolt = smoothstep(0.02, 0.0, boltDist) * smoothstep(0.3, 0.8, boltUV.y);

                    // Branches
                    for(int i = 0; i < 3; i++) {
                        float fi = float(i);
                        float branchY = 0.5 + fi * 0.1;
                        float branchDir = hash(vec2(fi, floor(t))) > 0.5 ? 1.0 : -1.0;

                        vec2 branchStart = vec2(boltX, branchY);
                        vec2 branchEnd = branchStart + vec2(branchDir * 0.1, -0.1);

                        if(boltUV.y < branchY && boltUV.y > branchY - 0.1) {
                            float branchProgress = (branchY - boltUV.y) / 0.1;
                            float branchX = mix(boltX, branchEnd.x, branchProgress);
                            branchX += sin(boltUV.y * 40.0) * 0.01;
                            float branchDist = abs(boltUV.x - branchX);
                            bolt += smoothstep(0.01, 0.0, branchDist) * (1.0 - branchProgress);
                        }
                    }
                }

                // Combine
                vec3 color = sky;

                // Apply clouds
                float cloudMask = smoothstep(0.3, 0.6, clouds);
                color = mix(color, cloudColor, cloudMask);

                // Underlight from lightning
                float underlight = clouds * flash * 0.5;
                color += vec3(0.5, 0.5, 0.7) * underlight;

                // Lightning bolt
                color += vec3(0.9, 0.9, 1.0) * bolt * flash;

                // Flash illumination
                color += vec3(0.2, 0.2, 0.3) * flash * (1.0 - uv.y);

                // Rain hint (vertical streaks)
                float rain = noise(vec2(uv.x * 100.0, uv.y * 20.0 - t * 10.0));
                rain = pow(rain, 8.0) * 0.1;
                color += vec3(0.3, 0.35, 0.4) * rain * (1.0 - uv.y);

                // Vignette
                float vignette = 1.0 - length((uv - 0.5) * 1.5);
                color *= smoothstep(0.0, 0.7, vignette);

                fragColor = vec4(color, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertexShader));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragmentShader));
        gl.linkProgram(program);
        gl.useProgram(program);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        const resolutionLoc = gl.getUniformLocation(program, 'resolution');
        const timeLoc = gl.getUniformLocation(program, 'time');

        function animate(time) {
            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }
        animate(0);
    </script>
</body>
</html>
