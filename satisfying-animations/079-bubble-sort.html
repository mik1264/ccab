<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Sort - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            overflow: hidden;
        }
        canvas { display: block; }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(254, 250, 224, 0.9);
            color: #606C38;
            text-decoration: none;
            border-radius: 25px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 2px solid rgba(138, 154, 91, 0.3);
        }
        .back-link:hover {
            background: #FEFAE0;
            transform: translateX(-5px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // Bubble Sort Visualization - Watch bars sort themselves satisfyingly

        const NUM_BARS = 50;
        const SWAP_DURATION = 150; // ms per swap animation
        const PAUSE_BETWEEN_SORTS = 2000; // ms pause when sorted

        let bars = [];
        let sortedBars = [];
        let i = 0, j = 0;
        let sorting = true;
        let swapping = false;
        let swapStartTime = 0;
        let swapFrom = -1, swapTo = -1;
        let sorted = false;
        let pauseStart = 0;

        class Bar {
            constructor(value, index, total) {
                this.value = value;
                this.targetX = 0;
                this.currentX = 0;
                this.hue = map(value, 0, total, 180, 320);
            }

            setPosition(index, total, barWidth) {
                this.targetX = index * barWidth + barWidth / 2;
            }

            update() {
                // Smooth interpolation to target position
                this.currentX = lerp(this.currentX, this.targetX, 0.2);
            }

            draw(barWidth, maxHeight, baseY) {
                const barHeight = map(this.value, 0, NUM_BARS, 20, maxHeight);

                // Glow effect
                noStroke();
                for (let r = 20; r > 0; r -= 5) {
                    fill(this.hue, 70, 80, map(r, 20, 0, 5, 0));
                    rect(this.currentX - barWidth/2 - r/2, baseY - barHeight, barWidth + r, barHeight, 4);
                }

                // Main bar
                fill(this.hue, 60, 85);
                rect(this.currentX - barWidth/2 + 2, baseY - barHeight, barWidth - 4, barHeight, 4);

                // Highlight
                fill(0, 0, 100, 30);
                rect(this.currentX - barWidth/2 + 4, baseY - barHeight + 4, (barWidth - 8) * 0.3, barHeight - 8, 2);
            }

            isActive(swapFrom, swapTo, currentI, currentJ) {
                return this === bars[swapFrom] || this === bars[swapTo] ||
                       this === bars[currentI] || this === bars[currentJ];
            }
        }

        function shuffleArray() {
            bars = [];
            for (let k = 0; k < NUM_BARS; k++) {
                bars.push(new Bar(k + 1, k, NUM_BARS));
            }

            // Fisher-Yates shuffle
            for (let k = bars.length - 1; k > 0; k--) {
                const randIdx = floor(random(k + 1));
                [bars[k], bars[randIdx]] = [bars[randIdx], bars[k]];
            }

            updateBarPositions();
            sortedBars = [...bars].sort((a, b) => a.value - b.value);
        }

        function updateBarPositions() {
            const barWidth = width / NUM_BARS;
            for (let k = 0; k < bars.length; k++) {
                bars[k].setPosition(k, NUM_BARS, barWidth);
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            shuffleArray();

            // Initialize positions immediately
            const barWidth = width / NUM_BARS;
            for (let k = 0; k < bars.length; k++) {
                bars[k].currentX = bars[k].targetX;
            }

            i = 0;
            j = 0;
        }

        function draw() {
            background(230, 40, 8);

            const barWidth = width / NUM_BARS;
            const maxHeight = height * 0.7;
            const baseY = height * 0.9;

            // Handle sorting logic
            if (sorted) {
                // Pause before reshuffling
                if (millis() - pauseStart > PAUSE_BETWEEN_SORTS) {
                    shuffleArray();
                    i = 0;
                    j = 0;
                    sorted = false;
                    sorting = true;
                }
            } else if (sorting && !swapping) {
                // Bubble sort step
                if (i < bars.length - 1) {
                    if (j < bars.length - i - 1) {
                        if (bars[j].value > bars[j + 1].value) {
                            // Start swap animation
                            swapping = true;
                            swapStartTime = millis();
                            swapFrom = j;
                            swapTo = j + 1;
                        } else {
                            j++;
                        }
                    } else {
                        j = 0;
                        i++;
                    }
                } else {
                    // Sort complete
                    sorted = true;
                    pauseStart = millis();
                }
            }

            // Handle swap animation
            if (swapping) {
                const elapsed = millis() - swapStartTime;
                const progress = constrain(elapsed / SWAP_DURATION, 0, 1);

                if (progress >= 1) {
                    // Complete swap
                    [bars[swapFrom], bars[swapTo]] = [bars[swapTo], bars[swapFrom]];
                    updateBarPositions();
                    swapping = false;
                    j++;
                } else {
                    // Animate swap - bars cross paths
                    const eased = 0.5 - 0.5 * cos(progress * PI);
                    const bar1 = bars[swapFrom];
                    const bar2 = bars[swapTo];
                    const x1 = swapFrom * barWidth + barWidth / 2;
                    const x2 = swapTo * barWidth + barWidth / 2;
                    bar1.currentX = lerp(x1, x2, eased);
                    bar2.currentX = lerp(x2, x1, eased);
                }
            }

            // Update and draw all bars
            for (let k = 0; k < bars.length; k++) {
                if (!swapping || (k !== swapFrom && k !== swapTo)) {
                    bars[k].update();
                }
                bars[k].draw(barWidth, maxHeight, baseY);
            }

            // Draw comparison indicator
            if (!sorted && !swapping && j < bars.length - 1) {
                noFill();
                stroke(60, 80, 100, 50);
                strokeWeight(2);
                const indicatorY = baseY + 20;
                line(j * barWidth + barWidth/2, indicatorY, (j+1) * barWidth + barWidth/2, indicatorY);

                fill(60, 80, 100);
                noStroke();
                triangle(
                    j * barWidth + barWidth/2, indicatorY - 5,
                    j * barWidth + barWidth/2 - 5, indicatorY + 5,
                    j * barWidth + barWidth/2 + 5, indicatorY + 5
                );
                triangle(
                    (j+1) * barWidth + barWidth/2, indicatorY - 5,
                    (j+1) * barWidth + barWidth/2 - 5, indicatorY + 5,
                    (j+1) * barWidth + barWidth/2 + 5, indicatorY + 5
                );
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            updateBarPositions();
            for (let k = 0; k < bars.length; k++) {
                bars[k].currentX = bars[k].targetX;
            }
        }
    </script>
</body>
</html>
