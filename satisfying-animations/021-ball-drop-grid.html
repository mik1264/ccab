<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Drop Grid - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        const ROWS = 12;
        const COLS = 15;
        let pegs = [];
        let balls = [];
        let pegRadius, ballRadius, spacing;
        let buckets = [];

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initGrid();
        }

        function initGrid() {
            pegs = [];
            balls = [];
            buckets = [];

            spacing = min(width / (COLS + 2), height / (ROWS + 4));
            pegRadius = spacing * 0.08;
            ballRadius = spacing * 0.15;

            const offsetX = (width - spacing * (COLS - 1)) / 2;
            const offsetY = spacing * 2;

            // Create pegs in offset grid pattern
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const offset = row % 2 === 0 ? 0 : spacing / 2;
                    const maxCol = row % 2 === 0 ? COLS : COLS - 1;
                    if (col < maxCol) {
                        pegs.push({
                            x: offsetX + col * spacing + offset,
                            y: offsetY + row * spacing * 0.8
                        });
                    }
                }
            }

            // Create buckets at bottom
            const bucketY = offsetY + ROWS * spacing * 0.8 + spacing;
            for (let i = 0; i < COLS; i++) {
                buckets.push({
                    x: offsetX + i * spacing,
                    count: 0,
                    hue: map(i, 0, COLS - 1, 100, 280)
                });
            }
        }

        function spawnBall() {
            const centerX = width / 2 + random(-spacing, spacing);
            balls.push({
                x: centerX,
                y: spacing * 0.5,
                vx: 0,
                vy: 0,
                hue: random(360)
            });
        }

        function draw() {
            background(230, 30, 10);

            // Spawn balls periodically
            if (frameCount % 15 === 0 && balls.length < 50) {
                spawnBall();
            }

            // Draw pegs
            fill(60, 20, 50);
            noStroke();
            for (let peg of pegs) {
                ellipse(peg.x, peg.y, pegRadius * 2);
            }

            // Draw buckets
            const bucketWidth = spacing * 0.8;
            const bucketHeight = spacing * 1.5;
            const bucketY = height - spacing;

            for (let i = 0; i < buckets.length; i++) {
                const b = buckets[i];
                fill(b.hue, 40, 30);
                rect(b.x - bucketWidth / 2, bucketY - bucketHeight, bucketWidth, bucketHeight, 5);

                // Ball count visualization
                const fillHeight = min(b.count * 5, bucketHeight - 10);
                fill(b.hue, 60, 70);
                rect(b.x - bucketWidth / 2 + 3, bucketY - fillHeight - 3, bucketWidth - 6, fillHeight, 3);
            }

            // Update and draw balls
            const gravity = 0.3;
            const friction = 0.98;
            const bounce = 0.7;

            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];

                // Apply gravity
                ball.vy += gravity;
                ball.vx *= friction;

                // Move
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Collision with pegs
                for (let peg of pegs) {
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const dist = sqrt(dx * dx + dy * dy);
                    const minDist = pegRadius + ballRadius;

                    if (dist < minDist) {
                        // Push ball away from peg
                        const angle = atan2(dy, dx);
                        ball.x = peg.x + cos(angle) * minDist;
                        ball.y = peg.y + sin(angle) * minDist;

                        // Reflect velocity
                        const normalX = dx / dist;
                        const normalY = dy / dist;
                        const dotProduct = ball.vx * normalX + ball.vy * normalY;

                        ball.vx = (ball.vx - 2 * dotProduct * normalX) * bounce;
                        ball.vy = (ball.vy - 2 * dotProduct * normalY) * bounce;

                        // Add some randomness
                        ball.vx += random(-0.5, 0.5);
                    }
                }

                // Wall bounds
                if (ball.x < ballRadius) {
                    ball.x = ballRadius;
                    ball.vx *= -bounce;
                }
                if (ball.x > width - ballRadius) {
                    ball.x = width - ballRadius;
                    ball.vx *= -bounce;
                }

                // Check if ball reached bucket
                if (ball.y > height - spacing * 2) {
                    // Find nearest bucket
                    let nearestBucket = 0;
                    let minDist = Infinity;
                    for (let j = 0; j < buckets.length; j++) {
                        const d = abs(ball.x - buckets[j].x);
                        if (d < minDist) {
                            minDist = d;
                            nearestBucket = j;
                        }
                    }
                    buckets[nearestBucket].count++;
                    balls.splice(i, 1);
                    continue;
                }

                // Draw ball with glow
                for (let r = ballRadius * 2; r > ballRadius; r -= 2) {
                    fill(ball.hue, 60, 80, map(r, ballRadius * 2, ballRadius, 10, 0));
                    ellipse(ball.x, ball.y, r * 2);
                }

                fill(ball.hue, 55, 85);
                stroke(ball.hue, 45, 70);
                strokeWeight(1);
                ellipse(ball.x, ball.y, ballRadius * 2);
            }

            // Reset buckets periodically
            if (frameCount % 600 === 0) {
                for (let b of buckets) {
                    b.count = 0;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initGrid();
        }
    </script>
</body>
</html>
