<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coin Stack - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);
        const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(2, 3, 5);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x606060, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);
        const light2 = new THREE.PointLight(0xffd700, 0.5);
        light2.position.set(-3, 5, 3);
        scene.add(light2);

        // Coin material
        const coinMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            metalness: 0.8,
            roughness: 0.2
        });

        // Coins
        const coins = [];
        const NUM_COINS = 15;
        const coinRadius = 0.4;
        const coinThickness = 0.05;

        for (let i = 0; i < NUM_COINS; i++) {
            const geometry = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 32);
            const coin = new THREE.Mesh(geometry, coinMaterial.clone());

            // Add edge detail
            const edgeGeo = new THREE.TorusGeometry(coinRadius, 0.01, 8, 32);
            const edge = new THREE.Mesh(edgeGeo, new THREE.MeshStandardMaterial({
                color: 0xdaa520,
                metalness: 0.9,
                roughness: 0.1
            }));
            edge.rotation.x = Math.PI / 2;
            coin.add(edge);

            coin.userData = {
                targetY: i * coinThickness,
                startY: 5 + i * 0.3,
                startX: (Math.random() - 0.5) * 2,
                startZ: (Math.random() - 0.5) * 2,
                rotation: Math.random() * Math.PI * 2,
                delay: i * 150,
                wobble: Math.random() * Math.PI * 2
            };

            scene.add(coin);
            coins.push(coin);
        }

        // Surface
        const surface = new THREE.Mesh(
            new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32),
            new THREE.MeshStandardMaterial({ color: 0x2d2d3d, metalness: 0.3, roughness: 0.7 })
        );
        surface.position.y = -0.05;
        scene.add(surface);

        function animate() {
            requestAnimationFrame(animate);

            const t = performance.now() * 0.001;
            const cycleDuration = 8;
            const cycleTime = t % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 0.05) {
                for (let coin of coins) {
                    coin.userData.startX = (Math.random() - 0.5) * 2;
                    coin.userData.startZ = (Math.random() - 0.5) * 2;
                }
            }

            // Update coins
            for (let i = 0; i < coins.length; i++) {
                const coin = coins[i];
                const d = coin.userData;

                const coinTime = cycleTime * 1000 - d.delay;

                if (coinTime < 0) {
                    coin.position.y = d.startY;
                    coin.position.x = d.startX;
                    coin.position.z = d.startZ;
                    coin.rotation.x = Math.PI / 4;
                    coin.rotation.z = Math.sin(t * 10 + d.wobble) * 0.3;
                } else if (coinTime < 600) {
                    const progress = coinTime / 600;
                    const eased = easeOutBounce(progress);

                    coin.position.y = d.startY + (d.targetY - d.startY) * eased;
                    coin.position.x = d.startX * (1 - eased);
                    coin.position.z = d.startZ * (1 - eased);
                    coin.rotation.x = (Math.PI / 4) * (1 - eased);
                    coin.rotation.z = Math.sin(t * 10 + d.wobble) * 0.3 * (1 - eased);
                } else {
                    coin.position.y = d.targetY;
                    coin.position.x = 0;
                    coin.position.z = 0;
                    coin.rotation.x = 0;
                    coin.rotation.z = 0;

                    // Subtle wobble when stacked
                    if (cycleTime > 5 && cycleTime < 7) {
                        const wobblePhase = (cycleTime - 5) / 2;
                        coin.position.x = Math.sin(t * 3 + i * 0.2) * 0.01 * Math.sin(wobblePhase * Math.PI);
                        coin.position.z = Math.cos(t * 3 + i * 0.2) * 0.01 * Math.sin(wobblePhase * Math.PI);
                    }
                }

                coin.rotation.y = d.rotation + t * 0.1;
            }

            // Camera orbit
            camera.position.x = Math.sin(t * 0.3) * 4;
            camera.position.z = Math.cos(t * 0.3) * 4;
            camera.lookAt(0, NUM_COINS * coinThickness / 2, 0);

            renderer.render(scene, camera);
        }

        function easeOutBounce(x) {
            const n1 = 7.5625;
            const d1 = 2.75;

            if (x < 1 / d1) {
                return n1 * x * x;
            } else if (x < 2 / d1) {
                return n1 * (x -= 1.5 / d1) * x + 0.75;
            } else if (x < 2.5 / d1) {
                return n1 * (x -= 2.25 / d1) * x + 0.9375;
            } else {
                return n1 * (x -= 2.625 / d1) * x + 0.984375;
            }
        }

        animate();

        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
