<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elastic Collision - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let balls = [];
        const NUM_BALLS = 12;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initBalls();
        }

        function initBalls() {
            balls = [];
            const baseRadius = min(width, height) * 0.04;

            for (let i = 0; i < NUM_BALLS; i++) {
                const angle = (i / NUM_BALLS) * TWO_PI;
                const dist = min(width, height) * 0.25;
                balls.push({
                    x: width / 2 + cos(angle) * dist,
                    y: height / 2 + sin(angle) * dist,
                    vx: cos(angle + PI / 2) * 3,
                    vy: sin(angle + PI / 2) * 3,
                    radius: baseRadius * (0.7 + random(0.6)),
                    mass: 1,
                    hue: map(i, 0, NUM_BALLS, 0, 360),
                    trail: []
                });
            }

            // Set mass proportional to radius squared
            for (let ball of balls) {
                ball.mass = ball.radius * ball.radius * 0.01;
            }
        }

        function draw() {
            background(230, 30, 10, 30);

            // Update ball positions
            for (let ball of balls) {
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Add to trail
                ball.trail.push({x: ball.x, y: ball.y});
                if (ball.trail.length > 20) {
                    ball.trail.shift();
                }

                // Wall collisions
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius;
                    ball.vx *= -1;
                }
                if (ball.x + ball.radius > width) {
                    ball.x = width - ball.radius;
                    ball.vx *= -1;
                }
                if (ball.y - ball.radius < 0) {
                    ball.y = ball.radius;
                    ball.vy *= -1;
                }
                if (ball.y + ball.radius > height) {
                    ball.y = height - ball.radius;
                    ball.vy *= -1;
                }
            }

            // Ball-to-ball collisions (elastic)
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const b1 = balls[i];
                    const b2 = balls[j];

                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const dist = sqrt(dx * dx + dy * dy);
                    const minDist = b1.radius + b2.radius;

                    if (dist < minDist) {
                        // Collision detected - elastic collision formula
                        const nx = dx / dist;
                        const ny = dy / dist;

                        // Relative velocity
                        const dvx = b1.vx - b2.vx;
                        const dvy = b1.vy - b2.vy;
                        const dvn = dvx * nx + dvy * ny;

                        // Only collide if approaching
                        if (dvn > 0) {
                            const m1 = b1.mass;
                            const m2 = b2.mass;
                            const totalMass = m1 + m2;

                            // Update velocities (elastic collision)
                            const impulse = 2 * dvn / totalMass;

                            b1.vx -= impulse * m2 * nx;
                            b1.vy -= impulse * m2 * ny;
                            b2.vx += impulse * m1 * nx;
                            b2.vy += impulse * m1 * ny;

                            // Separate balls
                            const overlap = minDist - dist;
                            const separationX = overlap * nx * 0.5;
                            const separationY = overlap * ny * 0.5;
                            b1.x -= separationX;
                            b1.y -= separationY;
                            b2.x += separationX;
                            b2.y += separationY;
                        }
                    }
                }
            }

            // Draw trails
            for (let ball of balls) {
                noFill();
                stroke(ball.hue, 50, 60, 30);
                strokeWeight(ball.radius * 0.3);
                beginShape();
                for (let i = 0; i < ball.trail.length; i++) {
                    const t = ball.trail[i];
                    vertex(t.x, t.y);
                }
                endShape();
            }

            // Draw balls
            for (let ball of balls) {
                // Glow
                noStroke();
                for (let r = ball.radius * 1.8; r > ball.radius; r -= 3) {
                    fill(ball.hue, 60, 80, map(r, ball.radius * 1.8, ball.radius, 15, 0));
                    ellipse(ball.x, ball.y, r * 2);
                }

                // Ball body
                fill(ball.hue, 55, 85);
                stroke(ball.hue, 45, 70);
                strokeWeight(2);
                ellipse(ball.x, ball.y, ball.radius * 2);

                // Highlight
                fill(0, 0, 100, 40);
                noStroke();
                ellipse(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.4);
            }

            // Reset if energy gets too low
            let totalEnergy = 0;
            for (let ball of balls) {
                totalEnergy += ball.vx * ball.vx + ball.vy * ball.vy;
            }
            if (totalEnergy < 10) {
                initBalls();
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initBalls();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
