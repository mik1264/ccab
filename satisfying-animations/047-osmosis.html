<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Osmosis - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let particles = [];
        let membraneX;
        const NUM_PARTICLES = 200;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            membraneX = width / 2;
            initParticles();
        }

        function initParticles() {
            particles = [];

            // Left side (high concentration)
            for (let i = 0; i < NUM_PARTICLES * 0.7; i++) {
                particles.push(createParticle(random(50, membraneX - 50)));
            }

            // Right side (low concentration)
            for (let i = 0; i < NUM_PARTICLES * 0.3; i++) {
                particles.push(createParticle(random(membraneX + 50, width - 50)));
            }
        }

        function createParticle(x) {
            return {
                x: x,
                y: random(100, height - 100),
                vx: random(-1, 1),
                vy: random(-1, 1),
                size: random(8, 15),
                hue: random(180, 220),
                passingMembrane: false,
                passProgress: 0
            };
        }

        function draw() {
            background(230, 30, 10);

            // Draw container
            noFill();
            stroke(60, 30, 40);
            strokeWeight(4);
            rect(40, 80, width - 80, height - 160, 10);

            // Draw membrane
            drawMembrane();

            // Update and draw particles
            for (let p of particles) {
                updateParticle(p);
                drawParticle(p);
            }

            // Labels
            fill(60, 30, 60);
            noStroke();
            textSize(16);
            textAlign(CENTER);
            text("High Concentration", width * 0.25, 60);
            text("Low Concentration", width * 0.75, 60);

            // Count particles on each side
            let leftCount = particles.filter(p => p.x < membraneX).length;
            let rightCount = particles.length - leftCount;
            textSize(14);
            text(`${leftCount} particles`, width * 0.25, height - 40);
            text(`${rightCount} particles`, width * 0.75, height - 40);
        }

        function drawMembrane() {
            // Semi-permeable membrane with pores
            stroke(50, 40, 50);
            strokeWeight(3);

            const poreSpacing = 30;
            const poreSize = 12;

            for (let y = 100; y < height - 100; y += poreSpacing) {
                // Solid parts
                line(membraneX, y, membraneX, y + poreSpacing - poreSize);

                // Pore (gap)
                // Draw pore edges
                noFill();
                stroke(50, 30, 60);
                strokeWeight(2);
                arc(membraneX, y + poreSpacing - poreSize, poreSize, poreSize, -HALF_PI, HALF_PI);
                arc(membraneX, y + poreSpacing, poreSize, poreSize, HALF_PI, -HALF_PI);
            }
        }

        function updateParticle(p) {
            // Random Brownian motion
            p.vx += random(-0.2, 0.2);
            p.vy += random(-0.2, 0.2);

            // Damping
            p.vx *= 0.98;
            p.vy *= 0.98;

            // Concentration gradient - slight bias toward equilibrium
            let leftCount = particles.filter(pt => pt.x < membraneX).length;
            let rightCount = particles.length - leftCount;

            if (p.x < membraneX && leftCount > rightCount) {
                p.vx += 0.01; // Slight push right
            } else if (p.x > membraneX && rightCount > leftCount) {
                p.vx -= 0.01; // Slight push left
            }

            // Check membrane crossing
            if (!p.passingMembrane) {
                // Approaching membrane
                if (abs(p.x - membraneX) < 20 && abs(p.vx) > 0.3) {
                    // Check if near a pore (every 30 pixels)
                    let nearPore = false;
                    for (let poreY = 100; poreY < height - 100; poreY += 30) {
                        if (abs(p.y - (poreY + 24)) < 8) {
                            nearPore = true;
                            break;
                        }
                    }

                    if (nearPore && random() < 0.3) {
                        p.passingMembrane = true;
                        p.passProgress = 0;
                    }
                }
            } else {
                // Passing through membrane
                p.passProgress += 0.05;

                if (p.passProgress >= 1) {
                    p.passingMembrane = false;
                    // Ensure particle is on the other side
                    if (p.vx > 0) {
                        p.x = membraneX + 25;
                    } else {
                        p.x = membraneX - 25;
                    }
                } else {
                    // Slow down while passing
                    p.vx *= 0.5;
                }
            }

            // Move
            if (!p.passingMembrane) {
                p.x += p.vx;
                p.y += p.vy;

                // Membrane collision (if not passing)
                if (p.x > membraneX - p.size / 2 && p.x < membraneX + p.size / 2) {
                    if (p.vx > 0) {
                        p.x = membraneX - p.size / 2;
                    } else {
                        p.x = membraneX + p.size / 2;
                    }
                    p.vx *= -0.5;
                }
            } else {
                p.y += p.vy * 0.3;
            }

            // Wall collisions
            if (p.x < 50 + p.size / 2) {
                p.x = 50 + p.size / 2;
                p.vx *= -0.8;
            }
            if (p.x > width - 50 - p.size / 2) {
                p.x = width - 50 - p.size / 2;
                p.vx *= -0.8;
            }
            if (p.y < 90 + p.size / 2) {
                p.y = 90 + p.size / 2;
                p.vy *= -0.8;
            }
            if (p.y > height - 90 - p.size / 2) {
                p.y = height - 90 - p.size / 2;
                p.vy *= -0.8;
            }
        }

        function drawParticle(p) {
            // Glow
            noStroke();
            for (let r = p.size * 1.5; r > p.size; r -= 2) {
                fill(p.hue, 50, 80, map(r, p.size * 1.5, p.size, 10, 0));
                ellipse(p.x, p.y, r * 2);
            }

            // Main particle
            if (p.passingMembrane) {
                // Squeeze effect while passing through pore
                let squeeze = sin(p.passProgress * PI);
                let w = p.size * (1 - squeeze * 0.5);
                let h = p.size * (1 + squeeze * 0.3);
                fill(p.hue, 60, 90);
                stroke(p.hue, 50, 70);
                strokeWeight(1);
                ellipse(p.x, p.y, w * 2, h * 2);
            } else {
                fill(p.hue, 55, 85);
                stroke(p.hue, 45, 70);
                strokeWeight(1);
                ellipse(p.x, p.y, p.size * 2);
            }

            // Highlight
            fill(0, 0, 100, 40);
            noStroke();
            ellipse(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.4);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            membraneX = width / 2;
            initParticles();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
