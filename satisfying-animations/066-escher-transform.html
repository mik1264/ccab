<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escher Transform - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let cellSize;
        const GRID = 8;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
        }

        function draw() {
            background(230, 30, 10);

            const time = millis() * 0.001;
            cellSize = min(width, height) / (GRID + 2);

            const offsetX = (width - cellSize * GRID) / 2;
            const offsetY = (height - cellSize * GRID) / 2;

            // Morphing parameter (0 = squares, 1 = fish-like shapes)
            const morphProgress = (sin(time * 0.5) + 1) / 2;

            for (let row = 0; row < GRID; row++) {
                for (let col = 0; col < GRID; col++) {
                    const x = offsetX + col * cellSize;
                    const y = offsetY + row * cellSize;

                    // Checkerboard pattern
                    const isLight = (row + col) % 2 === 0;

                    push();
                    translate(x + cellSize / 2, y + cellSize / 2);

                    // Draw morphing tile
                    drawMorphingTile(cellSize * 0.45, morphProgress, isLight, row, col, time);

                    pop();
                }
            }
        }

        function drawMorphingTile(size, morph, isLight, row, col, time) {
            const hue = isLight ? 200 : 30;
            const brightness = isLight ? 75 : 65;

            // Create vertices for morphing shape
            const points = [];
            const numPoints = 12;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * TWO_PI - HALF_PI;
                let r = size;

                // Base square corners
                const cornerAngle = floor(i / (numPoints / 4)) * HALF_PI + PI / 4;
                const isCorner = i % (numPoints / 4) === 0;

                if (isCorner) {
                    r = size * 1.2;
                }

                // Add fish-like undulation when morphed
                const undulation = sin(angle * 2 + time * 2) * size * 0.3 * morph;
                r += undulation;

                // Add organic wobble
                const wobble = sin(angle * 4 + time + row + col) * size * 0.1 * morph;
                r += wobble;

                // Head/tail extension for fish form
                if (i === 0 || i === numPoints / 2) {
                    r += size * 0.3 * morph;
                }

                // Fin protrusions
                if (i === numPoints / 4 || i === 3 * numPoints / 4) {
                    r += size * 0.2 * morph * sin(time * 3);
                }

                points.push({
                    x: cos(angle) * r,
                    y: sin(angle) * r
                });
            }

            // Glow
            noStroke();
            for (let g = size * 0.3; g > 0; g -= 5) {
                fill(hue, 40, brightness, map(g, size * 0.3, 0, 2, 0));
                beginShape();
                for (let p of points) {
                    curveVertex(p.x * (1 + g / size * 0.1), p.y * (1 + g / size * 0.1));
                }
                // Close curve properly
                for (let i = 0; i < 3; i++) {
                    curveVertex(points[i].x * (1 + g / size * 0.1), points[i].y * (1 + g / size * 0.1));
                }
                endShape(CLOSE);
            }

            // Main shape
            fill(hue, 55, brightness);
            stroke(hue, 65, brightness - 20);
            strokeWeight(1);
            beginShape();
            for (let p of points) {
                curveVertex(p.x, p.y);
            }
            for (let i = 0; i < 3; i++) {
                curveVertex(points[i].x, points[i].y);
            }
            endShape(CLOSE);

            // Eye for fish form
            if (morph > 0.3) {
                const eyeX = size * 0.3 * (isLight ? 1 : -1);
                const eyeY = -size * 0.1;
                const eyeSize = size * 0.15 * morph;

                fill(0, 0, 10);
                noStroke();
                ellipse(eyeX, eyeY, eyeSize);

                fill(0, 0, 100);
                ellipse(eyeX + eyeSize * 0.2, eyeY - eyeSize * 0.1, eyeSize * 0.4);
            }

            // Highlight
            fill(hue, 30, brightness + 15, 40);
            noStroke();
            ellipse(-size * 0.2, -size * 0.2, size * 0.4, size * 0.3);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
