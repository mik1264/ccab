<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honey Drip - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        const vertexShader = `#version 300 es
            in vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShader = `#version 300 es
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            out vec4 fragColor;

            float smin(float a, float b, float k) {
                float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }

            // Honey dipper (top)
            float dipper(vec2 uv, float t) {
                // Position oscillates slightly
                float dipperX = 0.5 + sin(t * 0.3) * 0.05;
                float dipperY = 0.85;

                // Dipper handle
                float handle = length(vec2(uv.x - dipperX, (uv.y - 0.95) * 0.3)) - 0.02;

                // Dipper grooves
                float grooveY = dipperY - 0.05;
                float grooves = length(vec2(uv.x - dipperX, uv.y - grooveY)) - 0.06;
                grooves = max(grooves, -length(vec2(uv.x - dipperX, uv.y - grooveY)) + 0.04);

                return min(handle, grooves);
            }

            // Viscous drip shape
            float honeyDrip(vec2 uv, float t) {
                float dipperX = 0.5 + sin(t * 0.3) * 0.05;
                float dripStart = 0.75;

                // Drip cycle
                float cycle = mod(t * 0.4, 1.0);

                // Stretching phase
                float stretchLength = cycle * 0.6;
                float dripY = dripStart - stretchLength;

                // Drip shape (teardrop that forms and falls)
                float dx = uv.x - dipperX;

                // Narrow at top, bulge at bottom
                float taper = mix(0.015, 0.04, smoothstep(dripStart, dripY, uv.y));

                // Add necking before drop breaks
                if (cycle > 0.7) {
                    float neckPos = dripStart - 0.15;
                    float neckFactor = smoothstep(0.7, 0.85, cycle);
                    float distFromNeck = abs(uv.y - neckPos);
                    taper *= 1.0 - neckFactor * 0.7 * exp(-distFromNeck * 20.0);
                }

                float drip = abs(dx) - taper;

                // Only draw in drip region
                if (uv.y > dripStart || uv.y < dripY) drip = 1.0;

                // Bulging droplet at bottom
                float bulge = length(vec2(dx, uv.y - dripY)) - 0.05 * (1.0 + cycle * 0.5);
                drip = smin(drip, bulge, 0.02);

                return drip;
            }

            // Falling drops
            float fallingDrop(vec2 uv, float t, float offset) {
                float dipperX = 0.5 + sin((t - offset) * 0.3) * 0.05;
                float cycle = mod((t - offset) * 0.4, 1.0);

                if (cycle < 0.85) return 1.0;

                float fallProgress = (cycle - 0.85) / 0.15;
                float dropY = 0.4 - fallProgress * 0.8;
                float dropX = dipperX;

                // Elongated falling drop
                float dx = uv.x - dropX;
                float dy = uv.y - dropY;
                float elongation = 1.0 + fallProgress * 2.0;

                return length(vec2(dx, dy * elongation)) - 0.04;
            }

            // Pool of honey
            float honeyPool(vec2 uv, float t) {
                float poolY = 0.15;
                float poolHeight = 0.1 + sin(t * 0.5) * 0.01;

                // Wavy surface
                float wave = sin(uv.x * 10.0 + t * 0.5) * 0.005;
                wave += sin(uv.x * 20.0 - t) * 0.003;

                return uv.y - poolY - wave;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution;
                float t = time;

                // Background
                vec3 bg = mix(vec3(0.15, 0.1, 0.05), vec3(0.08, 0.05, 0.02), uv.y);

                // Honey colors
                vec3 honeyDark = vec3(0.7, 0.4, 0.1);
                vec3 honeyLight = vec3(0.95, 0.75, 0.25);
                vec3 honeyColor = mix(honeyDark, honeyLight, 0.5);

                // Dipper
                float dipperDist = dipper(uv, t);
                float dipperMask = 1.0 - smoothstep(0.0, 0.01, dipperDist);
                vec3 dipperColor = vec3(0.5, 0.35, 0.2);

                // Main drip
                float dripDist = honeyDrip(uv, t);
                float dripMask = 1.0 - smoothstep(0.0, 0.01, dripDist);

                // Multiple falling drops (staggered)
                float drop1 = fallingDrop(uv, t, 0.0);
                float drop2 = fallingDrop(uv, t, 1.25);
                float drop3 = fallingDrop(uv, t, 2.5);
                float dropMask = 1.0 - smoothstep(0.0, 0.01, min(min(drop1, drop2), drop3));

                // Pool
                float poolDist = honeyPool(uv, t);
                float poolMask = 1.0 - smoothstep(0.0, 0.02, poolDist);

                // Combine honey elements
                float allHoney = max(max(dripMask, dropMask), poolMask);

                // Subsurface scattering
                vec3 honeyFinal = mix(honeyDark, honeyLight, 0.5 + uv.y * 0.3);

                // Edge glow
                float edge = smoothstep(0.01, 0.0, abs(dripDist)) * 0.3;
                float poolEdge = smoothstep(0.02, 0.0, abs(poolDist)) * 0.3;

                // Specular
                float spec = pow(max(0.0, 1.0 - abs(uv.x - 0.5) * 10.0), 4.0) * dripMask * 0.4;

                // Combine
                vec3 color = bg;
                color = mix(color, dipperColor, dipperMask);
                color = mix(color, honeyFinal, allHoney);
                color += vec3(1.0, 0.9, 0.6) * edge;
                color += vec3(1.0, 0.9, 0.6) * poolEdge;
                color += vec3(1.0, 0.95, 0.8) * spec;

                // Warm glow
                color += vec3(0.1, 0.05, 0.0) * allHoney;

                fragColor = vec4(color, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertexShader));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragmentShader));
        gl.linkProgram(program);
        gl.useProgram(program);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        const resolutionLoc = gl.getUniformLocation(program, 'resolution');
        const timeLoc = gl.getUniformLocation(program, 'time');

        function animate(time) {
            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }
        animate(0);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
