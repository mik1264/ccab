<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jelly Wobble - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let jellies = [];
        const NUM_JELLIES = 5;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initJellies();
        }

        function initJellies() {
            jellies = [];
            const baseSize = min(width, height) * 0.15;

            for (let i = 0; i < NUM_JELLIES; i++) {
                jellies.push({
                    x: width * (0.2 + i * 0.15),
                    y: height * 0.5,
                    baseSize: baseSize * (0.6 + random(0.8)),
                    hue: map(i, 0, NUM_JELLIES, 0, 280),
                    wobblePhase: random(TWO_PI),
                    wobbleSpeed: 0.03 + random(0.02),
                    points: []
                });

                // Initialize surface points for blob shape
                const numPoints = 32;
                for (let j = 0; j < numPoints; j++) {
                    jellies[i].points.push({
                        angle: (j / numPoints) * TWO_PI,
                        radiusOffset: 0,
                        velocity: 0
                    });
                }
            }
        }

        function draw() {
            // Gradient background
            for (let y = 0; y < height; y++) {
                const inter = map(y, 0, height, 0, 1);
                stroke(lerpColor(color(240, 20, 15), color(260, 30, 8), inter));
                line(0, y, width, y);
            }

            const time = frameCount;

            // Update and draw each jelly
            for (let jelly of jellies) {
                updateJelly(jelly, time);
                drawJelly(jelly, time);
            }
        }

        function updateJelly(jelly, time) {
            const springK = 0.1; // Spring constant
            const damping = 0.85;

            // Apply wobble forces
            for (let i = 0; i < jelly.points.length; i++) {
                const p = jelly.points[i];

                // External wobble force (simulates being poked)
                const wobbleForce = sin(time * jelly.wobbleSpeed + p.angle * 3 + jelly.wobblePhase) * 0.5;
                const secondaryWobble = sin(time * jelly.wobbleSpeed * 1.7 + p.angle * 5) * 0.3;

                // Spring force (pull back to rest)
                const springForce = -p.radiusOffset * springK;

                // Apply forces
                p.velocity += springForce + wobbleForce * 0.02 + secondaryWobble * 0.01;
                p.velocity *= damping;
                p.radiusOffset += p.velocity;

                // Limit deformation
                p.radiusOffset = constrain(p.radiusOffset, -0.3, 0.3);
            }
        }

        function drawJelly(jelly, time) {
            push();
            translate(jelly.x, jelly.y);

            // Squash and stretch based on overall wobble
            const overallWobble = sin(time * jelly.wobbleSpeed + jelly.wobblePhase);
            const scaleX = 1 + overallWobble * 0.05;
            const scaleY = 1 - overallWobble * 0.05;
            scale(scaleX, scaleY);

            // Shadow
            noStroke();
            fill(0, 0, 0, 15);
            ellipse(jelly.baseSize * 0.1, jelly.baseSize * 0.5, jelly.baseSize * 1.8, jelly.baseSize * 0.3);

            // Build blob shape from points
            const points = [];
            for (let p of jelly.points) {
                const radius = jelly.baseSize * (1 + p.radiusOffset);
                points.push({
                    x: cos(p.angle) * radius,
                    y: sin(p.angle) * radius
                });
            }

            // Draw layered jelly
            // Outer glow
            for (let r = 1.3; r > 1.0; r -= 0.1) {
                fill(jelly.hue, 60, 70, map(r, 1.3, 1.0, 5, 0));
                beginShape();
                for (let p of points) {
                    curveVertex(p.x * r, p.y * r);
                }
                // Close the shape properly
                for (let i = 0; i < 3; i++) {
                    curveVertex(points[i].x * r, points[i].y * r);
                }
                endShape(CLOSE);
            }

            // Main body
            fill(jelly.hue, 55, 75, 70);
            stroke(jelly.hue, 60, 65, 50);
            strokeWeight(2);
            beginShape();
            for (let p of points) {
                curveVertex(p.x, p.y);
            }
            for (let i = 0; i < 3; i++) {
                curveVertex(points[i].x, points[i].y);
            }
            endShape(CLOSE);

            // Inner highlight layers
            noStroke();
            for (let layer = 0.8; layer > 0.3; layer -= 0.15) {
                const alpha = map(layer, 0.8, 0.3, 20, 40);
                fill(jelly.hue - 10, 40, 90, alpha);
                beginShape();
                for (let p of points) {
                    curveVertex(p.x * layer - jelly.baseSize * 0.1, p.y * layer - jelly.baseSize * 0.1);
                }
                for (let i = 0; i < 3; i++) {
                    curveVertex(points[i].x * layer - jelly.baseSize * 0.1, points[i].y * layer - jelly.baseSize * 0.1);
                }
                endShape(CLOSE);
            }

            // Specular highlight
            fill(0, 0, 100, 50);
            ellipse(-jelly.baseSize * 0.3, -jelly.baseSize * 0.25, jelly.baseSize * 0.25, jelly.baseSize * 0.15);

            // Small secondary highlight
            fill(0, 0, 100, 35);
            ellipse(-jelly.baseSize * 0.15, -jelly.baseSize * 0.4, jelly.baseSize * 0.1, jelly.baseSize * 0.08);

            pop();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initJellies();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
