<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Cradle - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            overflow: hidden;
        }
        canvas { display: block; }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(254, 250, 224, 0.9);
            color: #606C38;
            text-decoration: none;
            border-radius: 25px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 2px solid rgba(138, 154, 91, 0.3);
        }
        .back-link:hover {
            background: #FEFAE0;
            transform: translateX(-5px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // Newton's Cradle - Classic momentum transfer demonstration

        const NUM_BALLS = 5;
        const LOOP_DURATION = 3000; // 3 seconds per swing cycle

        let balls = [];
        let stringLength;
        let ballRadius;
        let pivotY;
        let startTime;

        class Ball {
            constructor(index, total) {
                this.index = index;
                this.angle = 0;
                this.targetAngle = 0;
                this.angularVelocity = 0;
                this.swinging = false;

                // Metallic gradient colors
                this.baseColor = color(200, 200, 210);
                this.highlightColor = color(255, 255, 255);
                this.shadowColor = color(80, 85, 95);
            }

            update(time) {
                // Simple animation: left ball swings out, hits, right ball swings out, hits
                const t = (time % LOOP_DURATION) / LOOP_DURATION;
                const phase = t * TWO_PI;

                // First half: left ball swings
                // Second half: right ball swings
                const maxAngle = PI / 4;

                if (this.index === 0) {
                    // Left ball
                    if (t < 0.5) {
                        // Swinging out and back
                        this.angle = -maxAngle * sin(phase);
                        if (this.angle > 0) this.angle = 0;
                    } else {
                        this.angle = 0;
                    }
                } else if (this.index === NUM_BALLS - 1) {
                    // Right ball
                    if (t >= 0.5) {
                        // Swinging out and back
                        this.angle = maxAngle * sin(phase);
                        if (this.angle < 0) this.angle = 0;
                    } else {
                        this.angle = 0;
                    }
                } else {
                    // Middle balls stay still
                    this.angle = 0;
                }
            }

            draw(pivotX) {
                const bobX = pivotX + sin(this.angle) * stringLength;
                const bobY = pivotY + cos(this.angle) * stringLength;

                // Draw string
                stroke(150, 150, 160);
                strokeWeight(2);
                line(pivotX, pivotY, bobX, bobY);

                // Ball shadow (on ground plane)
                noStroke();
                fill(0, 0, 0, 40);
                const groundY = pivotY + stringLength + ballRadius + 50;
                const shadowX = bobX;
                const shadowScale = map(bobY, pivotY, pivotY + stringLength, 0.3, 1);
                ellipse(shadowX, groundY, ballRadius * 2 * shadowScale, ballRadius * 0.3 * shadowScale);

                // Draw metallic ball with gradient effect
                push();
                translate(bobX, bobY);

                // Outer glow when moving
                if (abs(this.angle) > 0.01) {
                    for (let r = ballRadius + 15; r > ballRadius; r -= 3) {
                        fill(180, 200, 220, map(r, ballRadius + 15, ballRadius, 0, 30));
                        ellipse(0, 0, r * 2);
                    }
                }

                // Ball gradient (simulate metallic sphere)
                for (let r = ballRadius; r > 0; r -= 2) {
                    const t = r / ballRadius;
                    const c = lerpColor(this.shadowColor, this.baseColor, t);
                    fill(c);
                    noStroke();
                    ellipse(-ballRadius * 0.15 * (1 - t), -ballRadius * 0.15 * (1 - t), r * 2);
                }

                // Highlight
                fill(255, 255, 255, 180);
                ellipse(-ballRadius * 0.3, -ballRadius * 0.3, ballRadius * 0.5);

                // Secondary highlight
                fill(255, 255, 255, 80);
                ellipse(-ballRadius * 0.15, -ballRadius * 0.5, ballRadius * 0.25);

                pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            startTime = millis();

            // Calculate dimensions based on screen size
            stringLength = min(width, height) * 0.35;
            ballRadius = min(width, height) * 0.04;
            pivotY = height * 0.2;

            // Create balls
            for (let i = 0; i < NUM_BALLS; i++) {
                balls.push(new Ball(i, NUM_BALLS));
            }
        }

        function draw() {
            // Gradient background
            background(15, 18, 30);

            const time = millis() - startTime;

            // Calculate ball spacing
            const totalWidth = (NUM_BALLS - 1) * ballRadius * 2.1;
            const startX = width / 2 - totalWidth / 2;

            // Draw frame
            stroke(80, 85, 100);
            strokeWeight(6);
            // Top bar
            line(startX - ballRadius * 2, pivotY - 5, startX + totalWidth + ballRadius * 2, pivotY - 5);
            // Side supports
            line(startX - ballRadius * 2, pivotY - 5, startX - ballRadius * 3, height * 0.8);
            line(startX + totalWidth + ballRadius * 2, pivotY - 5, startX + totalWidth + ballRadius * 3, height * 0.8);
            // Base
            strokeWeight(8);
            line(startX - ballRadius * 4, height * 0.8, startX + totalWidth + ballRadius * 4, height * 0.8);

            // Update and draw balls
            for (let i = 0; i < NUM_BALLS; i++) {
                const pivotX = startX + i * ballRadius * 2.1;
                balls[i].update(time);
                balls[i].draw(pivotX);
            }

            // Subtle floor reflection
            noStroke();
            for (let i = 0; i < NUM_BALLS; i++) {
                const pivotX = startX + i * ballRadius * 2.1;
                const bobX = pivotX + sin(balls[i].angle) * stringLength;
                fill(100, 110, 130, 15);
                ellipse(bobX, height * 0.82, ballRadius * 1.5, 5);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            stringLength = min(width, height) * 0.35;
            ballRadius = min(width, height) * 0.04;
            pivotY = height * 0.2;
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
