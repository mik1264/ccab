<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Fill - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let fillPixels = [];
        let fillQueue = [];
        let shapeCanvas;
        let fillCanvas;
        const shapes = ['circle', 'star', 'heart', 'hexagon'];
        let currentShape = 0;
        let cellSize;
        let gridW, gridH;
        let hue;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initFill();
        }

        function initFill() {
            cellSize = min(width, height) * 0.015;
            gridW = ceil(width / cellSize);
            gridH = ceil(height / cellSize);

            // Create shape mask
            shapeCanvas = createGraphics(gridW, gridH);
            shapeCanvas.pixelDensity(1);
            shapeCanvas.background(0);
            shapeCanvas.fill(255);
            shapeCanvas.noStroke();

            const cx = gridW / 2;
            const cy = gridH / 2;
            const size = min(gridW, gridH) * 0.35;

            const shape = shapes[currentShape];

            if (shape === 'circle') {
                shapeCanvas.ellipse(cx, cy, size * 2);
            } else if (shape === 'star') {
                drawStar(shapeCanvas, cx, cy, size * 0.5, size, 5);
            } else if (shape === 'heart') {
                drawHeart(shapeCanvas, cx, cy, size);
            } else if (shape === 'hexagon') {
                drawPolygon(shapeCanvas, cx, cy, size, 6);
            }

            shapeCanvas.loadPixels();

            // Initialize fill state
            fillPixels = [];
            for (let y = 0; y < gridH; y++) {
                fillPixels[y] = [];
                for (let x = 0; x < gridW; x++) {
                    const i = (y * gridW + x) * 4;
                    const inShape = shapeCanvas.pixels[i] > 128;
                    fillPixels[y][x] = {
                        inShape: inShape,
                        filled: false,
                        fillTime: -1
                    };
                }
            }

            // Start fill from center
            fillQueue = [[floor(cx), floor(cy)]];
            if (fillPixels[floor(cy)] && fillPixels[floor(cy)][floor(cx)]) {
                fillPixels[floor(cy)][floor(cx)].filled = true;
                fillPixels[floor(cy)][floor(cx)].fillTime = 0;
            }

            hue = random(360);
        }

        function drawStar(g, cx, cy, r1, r2, points) {
            g.beginShape();
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * PI / points) - HALF_PI;
                const r = i % 2 === 0 ? r2 : r1;
                g.vertex(cx + cos(angle) * r, cy + sin(angle) * r);
            }
            g.endShape(CLOSE);
        }

        function drawHeart(g, cx, cy, size) {
            g.beginShape();
            for (let t = 0; t < TWO_PI; t += 0.1) {
                const x = 16 * pow(sin(t), 3);
                const y = -(13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t));
                g.vertex(cx + x * size / 20, cy + y * size / 20);
            }
            g.endShape(CLOSE);
        }

        function drawPolygon(g, cx, cy, r, sides) {
            g.beginShape();
            for (let i = 0; i < sides; i++) {
                const angle = (i * TWO_PI / sides) - HALF_PI;
                g.vertex(cx + cos(angle) * r, cy + sin(angle) * r);
            }
            g.endShape(CLOSE);
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 6000;
            const cycleTime = time % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 50 && fillQueue.length === 0) {
                currentShape = (currentShape + 1) % shapes.length;
                initFill();
            }

            // Flood fill step
            const fillsPerFrame = 30;
            for (let i = 0; i < fillsPerFrame && fillQueue.length > 0; i++) {
                const [x, y] = fillQueue.shift();

                // Add neighbors
                const neighbors = [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]];
                for (const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                        const pixel = fillPixels[ny][nx];
                        if (pixel.inShape && !pixel.filled) {
                            pixel.filled = true;
                            pixel.fillTime = time;
                            fillQueue.push([nx, ny]);
                        }
                    }
                }
            }

            // Draw shape outline
            stroke(230, 30, 30);
            strokeWeight(2);
            noFill();

            const cx = width / 2;
            const cy = height / 2;
            const size = min(width, height) * 0.35;
            const shape = shapes[currentShape];

            if (shape === 'circle') {
                ellipse(cx, cy, size * 2);
            } else if (shape === 'star') {
                beginShape();
                for (let i = 0; i < 10; i++) {
                    const angle = (i * PI / 5) - HALF_PI;
                    const r = i % 2 === 0 ? size : size * 0.5;
                    vertex(cx + cos(angle) * r, cy + sin(angle) * r);
                }
                endShape(CLOSE);
            } else if (shape === 'heart') {
                beginShape();
                for (let t = 0; t < TWO_PI; t += 0.1) {
                    const x = 16 * pow(sin(t), 3);
                    const y = -(13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t));
                    vertex(cx + x * size / 20, cy + y * size / 20);
                }
                endShape(CLOSE);
            } else if (shape === 'hexagon') {
                beginShape();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * TWO_PI / 6) - HALF_PI;
                    vertex(cx + cos(angle) * size, cy + sin(angle) * size);
                }
                endShape(CLOSE);
            }

            // Draw filled pixels
            noStroke();
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const pixel = fillPixels[y][x];
                    if (pixel.filled) {
                        const age = time - pixel.fillTime;
                        const scale = min(1, age / 100);

                        const pixelHue = (hue + (x + y) * 0.5) % 360;
                        fill(pixelHue, 60, 70);

                        const s = cellSize * easeOutBack(scale);
                        rect(x * cellSize + (cellSize - s) / 2,
                             y * cellSize + (cellSize - s) / 2,
                             s - 1, s - 1);
                    }
                }
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initFill();
        }
    </script>
</body>
</html>
