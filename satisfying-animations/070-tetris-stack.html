<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Stack - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // Tetromino shapes
        const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
        };

        const COLORS = {
            I: 180, O: 50, T: 280, S: 120, Z: 0, J: 220, L: 30
        };

        let pieces = [];
        let cellSize;
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateSequence();
        }

        function generateSequence() {
            pieces = [];
            cellSize = min(width / (BOARD_WIDTH + 6), height / (BOARD_HEIGHT + 4));

            // Generate a sequence that perfectly fills rows
            const shapeKeys = Object.keys(SHAPES);
            let currentY = BOARD_HEIGHT;
            let delay = 0;

            // Fill board with pieces
            for (let i = 0; i < 15; i++) {
                const shapeKey = shapeKeys[floor(random(shapeKeys.length))];
                const shape = SHAPES[shapeKey];

                pieces.push({
                    shape: shape,
                    shapeKey: shapeKey,
                    hue: COLORS[shapeKey],
                    x: floor(random(BOARD_WIDTH - shape[0].length + 1)),
                    targetY: currentY - shape.length,
                    currentY: -5,
                    delay: delay,
                    landed: false
                });

                currentY -= 2;
                if (currentY < 5) currentY = BOARD_HEIGHT;
                delay += 400;
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = pieces.length * 400 + 3000;
            const cycleTime = time % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 50) {
                for (let p of pieces) {
                    p.currentY = -5;
                    p.landed = false;
                }
            }

            const boardX = (width - BOARD_WIDTH * cellSize) / 2;
            const boardY = (height - BOARD_HEIGHT * cellSize) / 2;

            // Draw board background
            fill(230, 40, 15);
            stroke(230, 30, 25);
            strokeWeight(2);
            rect(boardX - 5, boardY - 5, BOARD_WIDTH * cellSize + 10, BOARD_HEIGHT * cellSize + 10, 5);

            // Draw grid
            stroke(230, 30, 20);
            strokeWeight(1);
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                line(boardX + x * cellSize, boardY, boardX + x * cellSize, boardY + BOARD_HEIGHT * cellSize);
            }
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                line(boardX, boardY + y * cellSize, boardX + BOARD_WIDTH * cellSize, boardY + y * cellSize);
            }

            // Update and draw pieces
            for (let piece of pieces) {
                if (cycleTime < piece.delay) continue;

                const dropTime = cycleTime - piece.delay;

                if (!piece.landed) {
                    // Falling animation
                    const fallDuration = 500;
                    const fallProgress = min(1, dropTime / fallDuration);
                    piece.currentY = lerp(-5, piece.targetY, easeOutBounce(fallProgress));

                    if (fallProgress >= 1) {
                        piece.landed = true;
                    }
                }

                // Wobble after landing
                let wobble = 0;
                if (piece.landed) {
                    const wobbleTime = dropTime - 500;
                    if (wobbleTime > 0 && wobbleTime < 500) {
                        wobble = sin(wobbleTime * 0.05) * exp(-wobbleTime * 0.01) * 0.1;
                    }
                }

                // Draw piece
                for (let py = 0; py < piece.shape.length; py++) {
                    for (let px = 0; px < piece.shape[py].length; px++) {
                        if (piece.shape[py][px]) {
                            const cellX = boardX + (piece.x + px) * cellSize;
                            const cellY = boardY + (piece.currentY + py) * cellSize;

                            push();
                            translate(cellX + cellSize / 2, cellY + cellSize / 2);
                            rotate(wobble);

                            // Shadow
                            fill(0, 0, 0, 30);
                            noStroke();
                            rect(-cellSize / 2 + 2, -cellSize / 2 + 2, cellSize - 2, cellSize - 2, 3);

                            // Main block
                            fill(piece.hue, 55, 70);
                            stroke(piece.hue, 65, 50);
                            strokeWeight(1);
                            rect(-cellSize / 2, -cellSize / 2, cellSize - 2, cellSize - 2, 3);

                            // Highlight
                            fill(piece.hue, 35, 90, 60);
                            noStroke();
                            rect(-cellSize / 2 + 3, -cellSize / 2 + 3, cellSize * 0.4, cellSize * 0.4, 2);

                            pop();
                        }
                    }
                }
            }
        }

        function easeOutBounce(x) {
            const n1 = 7.5625;
            const d1 = 2.75;

            if (x < 1 / d1) {
                return n1 * x * x;
            } else if (x < 2 / d1) {
                return n1 * (x -= 1.5 / d1) * x + 0.75;
            } else if (x < 2.5 / d1) {
                return n1 * (x -= 2.25 / d1) * x + 0.9375;
            } else {
                return n1 * (x -= 2.625 / d1) * x + 0.984375;
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateSequence();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
