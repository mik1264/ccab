<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metronomes Sync - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link {
            position: fixed; top: 20px; left: 20px; padding: 10px 20px;
            background: rgba(254, 250, 224, 0.9); color: #606C38;
            text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif;
            font-weight: 600; font-size: 14px; z-index: 1000;
        }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        const NUM_METRONOMES = 7;
        const SYNC_DURATION = 15000;
        let metronomes = [];
        let startTime;

        class Metronome {
            constructor(index, total) {
                this.index = index;
                this.initialPhase = random(TWO_PI);
                this.frequency = 2;
                this.angle = 0;
                this.hue = map(index, 0, total - 1, 20, 50);
            }

            update(time) {
                const syncProgress = min(time / SYNC_DURATION, 1);
                const currentPhase = lerp(this.initialPhase, 0, syncProgress * syncProgress);
                this.angle = sin(time * 0.003 * this.frequency + currentPhase) * PI / 4;
            }

            draw(x, baseY, mWidth, mHeight) {
                push();
                translate(x, baseY);

                // Base
                fill(this.hue, 40, 25);
                stroke(this.hue, 30, 35);
                strokeWeight(2);
                rect(-mWidth/2, -mHeight * 0.15, mWidth, mHeight * 0.15, 5);

                // Body
                fill(this.hue, 30, 35);
                beginShape();
                vertex(-mWidth/2, -mHeight * 0.15);
                vertex(-mWidth * 0.35, -mHeight);
                vertex(mWidth * 0.35, -mHeight);
                vertex(mWidth/2, -mHeight * 0.15);
                endShape(CLOSE);

                // Pendulum pivot
                const pivotY = -mHeight * 0.85;
                fill(this.hue, 20, 50);
                ellipse(0, pivotY, mWidth * 0.1);

                // Pendulum arm
                push();
                translate(0, pivotY);
                rotate(this.angle);

                stroke(this.hue, 20, 60);
                strokeWeight(3);
                line(0, 0, 0, mHeight * 0.6);

                // Weight
                fill(this.hue, 50, 70);
                noStroke();
                rect(-mWidth * 0.12, mHeight * 0.35, mWidth * 0.24, mHeight * 0.2, 3);

                // Top weight
                fill(this.hue, 60, 80);
                ellipse(0, -mHeight * 0.1, mWidth * 0.15);

                pop();

                pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            startTime = millis();

            for (let i = 0; i < NUM_METRONOMES; i++) {
                metronomes.push(new Metronome(i, NUM_METRONOMES));
            }
        }

        function draw() {
            background(230, 30, 10);
            const time = millis() - startTime;

            // Platform
            fill(30, 30, 20);
            noStroke();
            rect(width * 0.1, height * 0.7, width * 0.8, height * 0.05, 5);

            const mWidth = width / (NUM_METRONOMES * 1.8);
            const mHeight = height * 0.45;
            const spacing = width / (NUM_METRONOMES + 1);

            for (let i = 0; i < NUM_METRONOMES; i++) {
                metronomes[i].update(time);
                metronomes[i].draw(spacing * (i + 1), height * 0.7, mWidth, mHeight);
            }

            // Restart cycle
            if (time > SYNC_DURATION + 3000) {
                startTime = millis();
                for (let m of metronomes) {
                    m.initialPhase = random(TWO_PI);
                }
            }
        }

        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
