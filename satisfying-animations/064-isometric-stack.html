<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Stack - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let cubes = [];
        let cubeSize;
        const GRID_SIZE = 6;
        const MAX_HEIGHT = 5;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateCubes();
        }

        function generateCubes() {
            cubes = [];
            cubeSize = min(width, height) / 15;

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    // Random height for each column
                    const maxZ = floor(random(1, MAX_HEIGHT + 1));

                    for (let z = 0; z < maxZ; z++) {
                        cubes.push({
                            gridX: x,
                            gridY: y,
                            gridZ: z,
                            hue: (x * 30 + y * 40 + z * 50) % 360,
                            delay: (x + y) * 100 + z * 150,
                            visible: false,
                            animProgress: 0
                        });
                    }
                }
            }

            // Sort for proper draw order (back to front, bottom to top)
            cubes.sort((a, b) => {
                const depthA = a.gridX + a.gridY - a.gridZ;
                const depthB = b.gridX + b.gridY - b.gridZ;
                return depthA - depthB;
            });
        }

        function isoProject(gridX, gridY, gridZ) {
            // Isometric projection
            const isoX = (gridX - gridY) * cubeSize * 0.866;
            const isoY = (gridX + gridY) * cubeSize * 0.5 - gridZ * cubeSize;
            return {x: isoX, y: isoY};
        }

        function drawIsoCube(pos, size, hue, alpha) {
            const h = size;
            const w = size * 0.866;

            // Top face (brightest)
            fill(hue, 50, 85, alpha);
            stroke(hue, 60, 70, alpha);
            strokeWeight(1);
            beginShape();
            vertex(pos.x, pos.y - h);
            vertex(pos.x + w, pos.y - h * 0.5);
            vertex(pos.x, pos.y);
            vertex(pos.x - w, pos.y - h * 0.5);
            endShape(CLOSE);

            // Left face (medium)
            fill(hue, 55, 65, alpha);
            stroke(hue, 65, 55, alpha);
            beginShape();
            vertex(pos.x - w, pos.y - h * 0.5);
            vertex(pos.x, pos.y);
            vertex(pos.x, pos.y + h);
            vertex(pos.x - w, pos.y + h * 0.5);
            endShape(CLOSE);

            // Right face (darkest)
            fill(hue, 60, 50, alpha);
            stroke(hue, 70, 40, alpha);
            beginShape();
            vertex(pos.x + w, pos.y - h * 0.5);
            vertex(pos.x + w, pos.y + h * 0.5);
            vertex(pos.x, pos.y + h);
            vertex(pos.x, pos.y);
            endShape(CLOSE);
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 50) {
                for (let c of cubes) {
                    c.visible = false;
                    c.animProgress = 0;
                }
            }

            translate(width / 2, height / 2 + cubeSize * 2);

            // Update and draw cubes
            for (let c of cubes) {
                // Check if should start appearing
                if (cycleTime > c.delay && !c.visible) {
                    c.visible = true;
                }

                if (c.visible) {
                    // Animate in
                    c.animProgress = min(1, c.animProgress + 0.05);

                    // Eased progress
                    const eased = easeOutBounce(c.animProgress);

                    // Start position (falling from above)
                    const startZ = c.gridZ + 10;
                    const currentZ = lerp(startZ, c.gridZ, eased);

                    // Scale
                    const scale = eased;

                    // Position
                    const pos = isoProject(
                        c.gridX - GRID_SIZE / 2,
                        c.gridY - GRID_SIZE / 2,
                        currentZ
                    );

                    // Wobble after landing
                    const wobble = c.animProgress >= 1 ?
                        sin(time * 0.003 + c.gridX + c.gridY + c.gridZ) * 2 : 0;
                    pos.y += wobble;

                    const alpha = 50 + eased * 50;

                    drawIsoCube(pos, cubeSize * scale, c.hue, alpha);
                }
            }
        }

        function easeOutBounce(x) {
            const n1 = 7.5625;
            const d1 = 2.75;

            if (x < 1 / d1) {
                return n1 * x * x;
            } else if (x < 2 / d1) {
                return n1 * (x -= 1.5 / d1) * x + 0.75;
            } else if (x < 2.5 / d1) {
                return n1 * (x -= 2.25 / d1) * x + 0.9375;
            } else {
                return n1 * (x -= 2.625 / d1) * x + 0.984375;
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateCubes();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
