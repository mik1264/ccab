<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangram Solve - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let pieces = [];
        let baseSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateTangram();
        }

        function generateTangram() {
            pieces = [];
            baseSize = min(width, height) * 0.35;

            // Standard tangram pieces (7 pieces)
            // Large triangles (2)
            pieces.push({
                type: 'triangle',
                vertices: [[0, 0], [1, 0], [0.5, 0.5]],
                targetX: 0, targetY: 0,
                targetRotation: 0,
                hue: 0, delay: 0
            });

            pieces.push({
                type: 'triangle',
                vertices: [[0, 0], [1, 0], [0.5, 0.5]],
                targetX: 0.5, targetY: 0.5,
                targetRotation: PI,
                hue: 30, delay: 200
            });

            // Medium triangle (1)
            pieces.push({
                type: 'triangle',
                vertices: [[0, 0], [0.5, 0], [0.25, 0.25]],
                targetX: 0.5, targetY: 0,
                targetRotation: PI / 2,
                hue: 60, delay: 400
            });

            // Small triangles (2)
            pieces.push({
                type: 'triangle',
                vertices: [[0, 0], [0.5, 0], [0.25, 0.25]],
                targetX: 0.25, targetY: 0.75,
                targetRotation: -PI / 2,
                hue: 120, delay: 600
            });

            pieces.push({
                type: 'triangle',
                vertices: [[0, 0], [0.5, 0], [0.25, 0.25]],
                targetX: 0.75, targetY: 0.75,
                targetRotation: PI,
                hue: 180, delay: 800
            });

            // Square (1)
            pieces.push({
                type: 'square',
                vertices: [[0, 0], [0.25, 0], [0.25, 0.25], [0, 0.25]],
                targetX: 0.25, targetY: 0.5,
                targetRotation: PI / 4,
                hue: 240, delay: 1000
            });

            // Parallelogram (1)
            pieces.push({
                type: 'parallelogram',
                vertices: [[0, 0], [0.5, 0], [0.375, 0.25], [-0.125, 0.25]],
                targetX: 0.5, targetY: 0.75,
                targetRotation: 0,
                hue: 300, delay: 1200
            });

            // Initialize random starting positions
            for (let piece of pieces) {
                const angle = random(TWO_PI);
                const dist = baseSize * 1.5;
                piece.startX = cos(angle) * dist;
                piece.startY = sin(angle) * dist;
                piece.startRotation = random(-PI, PI);
                piece.x = piece.startX;
                piece.y = piece.startY;
                piece.rotation = piece.startRotation;
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 6000;
            const cycleTime = time % cycleDuration;

            translate(width / 2, height / 2);

            // Draw target outline
            stroke(60, 30, 30);
            strokeWeight(2);
            noFill();
            beginShape();
            vertex(-baseSize / 2, -baseSize / 2);
            vertex(baseSize / 2, -baseSize / 2);
            vertex(baseSize / 2, baseSize / 2);
            vertex(-baseSize / 2, baseSize / 2);
            endShape(CLOSE);

            for (let piece of pieces) {
                let progress;

                if (cycleTime < 3000) {
                    // Assembling
                    const pieceTime = max(0, cycleTime - piece.delay);
                    progress = min(1, pieceTime / 1500);
                    progress = easeOutBack(progress);
                } else if (cycleTime < 4500) {
                    // Complete
                    progress = 1;
                } else {
                    // Scattering
                    const scatterTime = cycleTime - 4500;
                    progress = 1 - min(1, scatterTime / 1000);
                }

                // Interpolate
                piece.x = lerp(piece.startX, piece.targetX * baseSize - baseSize / 2, progress);
                piece.y = lerp(piece.startY, piece.targetY * baseSize - baseSize / 2, progress);
                piece.rotation = lerp(piece.startRotation, piece.targetRotation, progress);

                // Wobble when complete
                let wobble = 0;
                if (progress >= 1) {
                    wobble = sin(time * 0.003 + piece.delay) * 0.02;
                }

                push();
                translate(piece.x, piece.y);
                rotate(piece.rotation + wobble);

                // Draw piece
                const alpha = 50 + progress * 50;

                // Shadow
                fill(0, 0, 0, 20);
                noStroke();
                beginShape();
                for (let v of piece.vertices) {
                    vertex(v[0] * baseSize + 3, v[1] * baseSize + 3);
                }
                endShape(CLOSE);

                // Main shape
                fill(piece.hue, 55, 70, alpha);
                stroke(piece.hue, 65, 50, alpha);
                strokeWeight(2);
                beginShape();
                for (let v of piece.vertices) {
                    vertex(v[0] * baseSize, v[1] * baseSize);
                }
                endShape(CLOSE);

                // Highlight
                fill(piece.hue, 35, 85, alpha * 0.5);
                noStroke();
                const centerX = piece.vertices.reduce((s, v) => s + v[0], 0) / piece.vertices.length * baseSize;
                const centerY = piece.vertices.reduce((s, v) => s + v[1], 0) / piece.vertices.length * baseSize;
                ellipse(centerX - 5, centerY - 5, baseSize * 0.08);

                pop();
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateTangram();
        }
    </script>
</body>
</html>
