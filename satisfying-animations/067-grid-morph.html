<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Morph - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        const GRID = 10;
        let points = [];
        let cellSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initGrid();
        }

        function initGrid() {
            points = [];
            cellSize = min(width, height) / (GRID + 2);

            const offsetX = (width - cellSize * GRID) / 2;
            const offsetY = (height - cellSize * GRID) / 2;

            for (let row = 0; row <= GRID; row++) {
                points[row] = [];
                for (let col = 0; col <= GRID; col++) {
                    points[row][col] = {
                        baseX: offsetX + col * cellSize,
                        baseY: offsetY + row * cellSize,
                        x: offsetX + col * cellSize,
                        y: offsetY + row * cellSize
                    };
                }
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis() * 0.001;

            // Update point positions with wave distortion
            for (let row = 0; row <= GRID; row++) {
                for (let col = 0; col <= GRID; col++) {
                    const p = points[row][col];

                    // Multiple wave effects
                    const wave1 = sin(time + col * 0.5) * sin(time * 0.7 + row * 0.5);
                    const wave2 = sin(time * 1.3 + (row + col) * 0.3);
                    const radialWave = sin(time * 0.5 + sqrt(pow(col - GRID/2, 2) + pow(row - GRID/2, 2)) * 0.5);

                    const distortion = cellSize * 0.3;

                    p.x = p.baseX + wave1 * distortion + radialWave * distortion * 0.5;
                    p.y = p.baseY + wave2 * distortion + radialWave * distortion * 0.3;
                }
            }

            // Draw cells
            for (let row = 0; row < GRID; row++) {
                for (let col = 0; col < GRID; col++) {
                    const p00 = points[row][col];
                    const p10 = points[row][col + 1];
                    const p01 = points[row + 1][col];
                    const p11 = points[row + 1][col + 1];

                    // Calculate cell distortion for color
                    const dx = (p10.x - p00.x + p11.x - p01.x) / 2 - cellSize;
                    const dy = (p01.y - p00.y + p11.y - p10.y) / 2 - cellSize;
                    const distortionAmount = sqrt(dx * dx + dy * dy);

                    const hue = (row * 25 + col * 20 + time * 20) % 360;
                    const brightness = 60 + distortionAmount * 0.5;

                    // Fill
                    fill(hue, 50, brightness, 80);
                    stroke(hue, 60, brightness - 20);
                    strokeWeight(1);

                    beginShape();
                    vertex(p00.x, p00.y);
                    vertex(p10.x, p10.y);
                    vertex(p11.x, p11.y);
                    vertex(p01.x, p01.y);
                    endShape(CLOSE);
                }
            }

            // Draw grid points
            for (let row = 0; row <= GRID; row++) {
                for (let col = 0; col <= GRID; col++) {
                    const p = points[row][col];
                    const hue = (row * 30 + col * 25) % 360;

                    // Glow
                    noStroke();
                    for (let r = 8; r > 3; r--) {
                        fill(hue, 60, 80, map(r, 8, 3, 10, 0));
                        ellipse(p.x, p.y, r * 2);
                    }

                    // Point
                    fill(hue, 50, 90);
                    ellipse(p.x, p.y, 6);
                }
            }

            // Draw grid lines
            stroke(0, 0, 100, 30);
            strokeWeight(1);

            // Horizontal lines
            for (let row = 0; row <= GRID; row++) {
                noFill();
                beginShape();
                for (let col = 0; col <= GRID; col++) {
                    const p = points[row][col];
                    curveVertex(p.x, p.y);
                }
                endShape();
            }

            // Vertical lines
            for (let col = 0; col <= GRID; col++) {
                noFill();
                beginShape();
                for (let row = 0; row <= GRID; row++) {
                    const p = points[row][col];
                    curveVertex(p.x, p.y);
                }
                endShape();
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initGrid();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
