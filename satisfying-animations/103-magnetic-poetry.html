<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Poetry - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let words = [];
        let poems = [
            ['the', 'moon', 'whispers', 'to', 'the', 'sea'],
            ['dreams', 'dance', 'through', 'silent', 'stars'],
            ['love', 'flows', 'like', 'endless', 'rivers'],
            ['time', 'melts', 'into', 'golden', 'light']
        ];
        let currentPoem = 0;
        let fontSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            textFont('Georgia');
            generateWords();
        }

        function generateWords() {
            words = [];
            fontSize = min(width, height) * 0.04;
            textSize(fontSize);

            const poem = poems[currentPoem];

            // Calculate total width for centered layout
            let totalWidth = 0;
            const wordWidths = [];
            for (let word of poem) {
                const w = textWidth(word) + 20;
                wordWidths.push(w);
                totalWidth += w + 10;
            }

            let currentX = (width - totalWidth) / 2;
            const targetY = height / 2;

            for (let i = 0; i < poem.length; i++) {
                const word = poem[i];
                const wordWidth = wordWidths[i];

                // Random scattered position
                const scatterX = random(width * 0.1, width * 0.9);
                const scatterY = random(height * 0.2, height * 0.8);

                words.push({
                    text: word,
                    width: wordWidth,
                    height: fontSize + 15,
                    x: scatterX,
                    y: scatterY,
                    targetX: currentX + wordWidth / 2,
                    targetY: targetY,
                    rotation: random(-0.5, 0.5),
                    targetRotation: random(-0.05, 0.05),
                    delay: i * 300,
                    vx: random(-2, 2),
                    vy: random(-2, 2),
                    hue: random(180, 240)
                });

                currentX += wordWidth + 10;
            }
        }

        function draw() {
            // Refrigerator background
            background(0, 0, 95);

            // Subtle texture
            noStroke();
            for (let i = 0; i < 100; i++) {
                fill(0, 0, random(90, 98), 50);
                ellipse(random(width), random(height), random(1, 3));
            }

            const time = millis();
            const cycleDuration = 10000;
            const cycleTime = time % cycleDuration;

            // Switch poems
            const newPoem = floor(time / cycleDuration) % poems.length;
            if (newPoem !== currentPoem) {
                currentPoem = newPoem;
                generateWords();
            }

            // Animation phases
            let phase, progress;

            if (cycleTime < 3000) {
                phase = 'scattered';
                progress = 0;
            } else if (cycleTime < 7000) {
                phase = 'forming';
                progress = easeOutBack((cycleTime - 3000) / 4000);
            } else if (cycleTime < 9000) {
                phase = 'complete';
                progress = 1;
            } else {
                phase = 'scatter';
                progress = 1 - easeInOutCubic((cycleTime - 9000) / 1000);
            }

            // Update and draw words
            for (let word of words) {
                if (phase === 'scattered') {
                    // Gentle floating
                    word.x += word.vx * 0.3;
                    word.y += word.vy * 0.3;

                    // Bounce off walls
                    if (word.x < word.width / 2 || word.x > width - word.width / 2) word.vx *= -1;
                    if (word.y < word.height / 2 || word.y > height - word.height / 2) word.vy *= -1;

                    word.x = constrain(word.x, word.width / 2, width - word.width / 2);
                    word.y = constrain(word.y, word.height / 2, height - word.height / 2);

                    word.scatterX = word.x;
                    word.scatterY = word.y;
                } else if (phase === 'forming' || phase === 'complete') {
                    // Move to target
                    if (word.scatterX !== undefined) {
                        word.x = lerp(word.scatterX, word.targetX, progress);
                        word.y = lerp(word.scatterY, word.targetY, progress);
                        word.rotation = lerp(word.rotation, word.targetRotation, progress);
                    }
                } else if (phase === 'scatter') {
                    word.x = lerp(word.scatterX, word.targetX, progress);
                    word.y = lerp(word.scatterY, word.targetY, progress);
                }

                // Magnetic wobble when complete
                let wobbleX = 0, wobbleY = 0;
                if (phase === 'complete') {
                    wobbleX = sin(time * 0.003 + words.indexOf(word)) * 2;
                    wobbleY = cos(time * 0.004 + words.indexOf(word)) * 1;
                }

                push();
                translate(word.x + wobbleX, word.y + wobbleY);
                rotate(word.rotation);

                // Magnet shadow
                fill(0, 0, 0, 30);
                noStroke();
                rect(-word.width / 2 + 3, -word.height / 2 + 3, word.width, word.height, 3);

                // Magnet background (white)
                fill(0, 0, 100);
                stroke(0, 0, 70);
                strokeWeight(1);
                rect(-word.width / 2, -word.height / 2, word.width, word.height, 3);

                // Word text
                fill(0, 0, 20);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(fontSize);
                text(word.text, 0, 0);

                pop();
            }

            // Satisfaction indicator when poem is formed
            if (phase === 'complete') {
                const alpha = 30 + sin(time * 0.003) * 15;
                fill(45, 40, 90, alpha);
                noStroke();
                rectMode(CENTER);
                rect(width / 2, height / 2, width * 0.8, fontSize * 3, 10);
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateWords();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
