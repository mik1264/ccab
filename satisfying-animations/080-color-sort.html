<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Sort - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            overflow: hidden;
        }
        canvas { display: block; }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(254, 250, 224, 0.9);
            color: #606C38;
            text-decoration: none;
            border-radius: 25px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 2px solid rgba(138, 154, 91, 0.3);
        }
        .back-link:hover {
            background: #FEFAE0;
            transform: translateX(-5px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // Color Sort - Watch colors arrange themselves into a beautiful rainbow

        const NUM_COLORS = 80;
        const SWAP_DURATION = 80;
        const PAUSE_BETWEEN_SORTS = 3000;

        let colors = [];
        let i = 0, j = 0;
        let sorting = true;
        let swapping = false;
        let swapStartTime = 0;
        let swapFrom = -1, swapTo = -1;
        let sorted = false;
        let pauseStart = 0;

        class ColorBlock {
            constructor(hue, index, total) {
                this.hue = hue;
                this.targetX = 0;
                this.targetY = 0;
                this.currentX = 0;
                this.currentY = 0;
                this.size = 0;
            }

            setPosition(index, cols, blockSize) {
                const row = floor(index / cols);
                const col = index % cols;
                this.targetX = col * blockSize + blockSize / 2;
                this.targetY = row * blockSize + blockSize / 2;
                this.size = blockSize;
            }

            update() {
                this.currentX = lerp(this.currentX, this.targetX, 0.15);
                this.currentY = lerp(this.currentY, this.targetY, 0.15);
            }

            draw() {
                // Glow effect
                noStroke();
                for (let r = this.size * 0.6; r > this.size * 0.4; r -= 3) {
                    fill(this.hue, 70, 80, map(r, this.size * 0.6, this.size * 0.4, 0, 20));
                    rectMode(CENTER);
                    rect(this.currentX, this.currentY, r, r, 4);
                }

                // Main block
                fill(this.hue, 70, 85);
                rectMode(CENTER);
                rect(this.currentX, this.currentY, this.size * 0.85, this.size * 0.85, 6);

                // Inner highlight
                fill(this.hue, 50, 95, 60);
                rect(this.currentX, this.currentY, this.size * 0.5, this.size * 0.5, 4);

                // Shine
                fill(0, 0, 100, 40);
                rect(this.currentX - this.size * 0.15, this.currentY - this.size * 0.15, this.size * 0.2, this.size * 0.2, 2);
            }
        }

        function shuffleColors() {
            colors = [];
            for (let k = 0; k < NUM_COLORS; k++) {
                const hue = map(k, 0, NUM_COLORS, 0, 360);
                colors.push(new ColorBlock(hue, k, NUM_COLORS));
            }

            // Fisher-Yates shuffle
            for (let k = colors.length - 1; k > 0; k--) {
                const randIdx = floor(random(k + 1));
                [colors[k], colors[randIdx]] = [colors[randIdx], colors[k]];
            }

            updatePositions();
        }

        function updatePositions() {
            const cols = ceil(sqrt(NUM_COLORS * (width / height)));
            const rows = ceil(NUM_COLORS / cols);
            const blockSize = min(width / cols, height / rows);
            const offsetX = (width - cols * blockSize) / 2;
            const offsetY = (height - rows * blockSize) / 2;

            for (let k = 0; k < colors.length; k++) {
                colors[k].setPosition(k, cols, blockSize);
                colors[k].targetX += offsetX;
                colors[k].targetY += offsetY;
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            shuffleColors();

            // Initialize positions
            for (let k = 0; k < colors.length; k++) {
                colors[k].currentX = colors[k].targetX;
                colors[k].currentY = colors[k].targetY;
            }

            i = 0;
            j = 0;
        }

        function draw() {
            background(230, 30, 10);

            // Sorting logic (sorting by hue)
            if (sorted) {
                if (millis() - pauseStart > PAUSE_BETWEEN_SORTS) {
                    shuffleColors();
                    i = 0;
                    j = 0;
                    sorted = false;
                    sorting = true;
                }
            } else if (sorting && !swapping) {
                // Bubble sort by hue
                if (i < colors.length - 1) {
                    if (j < colors.length - i - 1) {
                        if (colors[j].hue > colors[j + 1].hue) {
                            swapping = true;
                            swapStartTime = millis();
                            swapFrom = j;
                            swapTo = j + 1;
                        } else {
                            j++;
                        }
                    } else {
                        j = 0;
                        i++;
                    }
                } else {
                    sorted = true;
                    pauseStart = millis();
                }
            }

            // Swap animation
            if (swapping) {
                const elapsed = millis() - swapStartTime;
                const progress = constrain(elapsed / SWAP_DURATION, 0, 1);

                if (progress >= 1) {
                    [colors[swapFrom], colors[swapTo]] = [colors[swapTo], colors[swapFrom]];
                    updatePositions();
                    swapping = false;
                    j++;
                } else {
                    // Animate swap
                    const eased = 0.5 - 0.5 * cos(progress * PI);
                    const block1 = colors[swapFrom];
                    const block2 = colors[swapTo];

                    // Store original targets
                    const cols = ceil(sqrt(NUM_COLORS * (width / height)));
                    const blockSize = min(width / cols, height / ceil(NUM_COLORS / cols));
                    const offsetX = (width - cols * blockSize) / 2;

                    const x1 = (swapFrom % cols) * blockSize + blockSize / 2 + offsetX;
                    const x2 = (swapTo % cols) * blockSize + blockSize / 2 + offsetX;
                    const y1 = floor(swapFrom / cols) * blockSize + blockSize / 2 + (height - ceil(NUM_COLORS / cols) * blockSize) / 2;
                    const y2 = floor(swapTo / cols) * blockSize + blockSize / 2 + (height - ceil(NUM_COLORS / cols) * blockSize) / 2;

                    block1.currentX = lerp(x1, x2, eased);
                    block1.currentY = lerp(y1, y2, eased);
                    block2.currentX = lerp(x2, x1, eased);
                    block2.currentY = lerp(y2, y1, eased);
                }
            }

            // Update and draw all blocks
            for (let k = 0; k < colors.length; k++) {
                if (!swapping || (k !== swapFrom && k !== swapTo)) {
                    colors[k].update();
                }
                colors[k].draw();
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            updatePositions();
            for (let k = 0; k < colors.length; k++) {
                colors[k].currentX = colors[k].targetX;
                colors[k].currentY = colors[k].targetY;
            }
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
