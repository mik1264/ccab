<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untangle Wires - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let wires = [];
        const NUM_WIRES = 6;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateWires();
        }

        function generateWires() {
            wires = [];

            const leftX = width * 0.15;
            const rightX = width * 0.85;
            const startY = height * 0.2;
            const endY = height * 0.8;
            const spacing = (endY - startY) / (NUM_WIRES - 1);

            // Create wires with tangled and straight paths
            const colors = [0, 30, 60, 120, 200, 280];

            // Shuffled end positions for tangled state
            const endIndices = [];
            for (let i = 0; i < NUM_WIRES; i++) endIndices.push(i);
            for (let i = endIndices.length - 1; i > 0; i--) {
                const j = floor(random(i + 1));
                [endIndices[i], endIndices[j]] = [endIndices[j], endIndices[i]];
            }

            for (let i = 0; i < NUM_WIRES; i++) {
                const y1 = startY + i * spacing;
                const y2Tangled = startY + endIndices[i] * spacing;
                const y2Straight = y1;

                // Generate tangled control points
                const tangledPoints = generateTangledPath(leftX, y1, rightX, y2Tangled);

                wires.push({
                    startY: y1,
                    endYTangled: y2Tangled,
                    endYStraight: y2Straight,
                    hue: colors[i],
                    tangledPoints: tangledPoints,
                    straightPoints: [
                        { x: leftX, y: y1 },
                        { x: leftX + (rightX - leftX) * 0.33, y: y1 },
                        { x: leftX + (rightX - leftX) * 0.66, y: y1 },
                        { x: rightX, y: y1 }
                    ]
                });
            }
        }

        function generateTangledPath(x1, y1, x2, y2) {
            const points = [{ x: x1, y: y1 }];
            const midX = (x1 + x2) / 2;

            // Add random loops and curves
            const numMidPoints = 4;
            for (let i = 1; i <= numMidPoints; i++) {
                const t = i / (numMidPoints + 1);
                const baseX = lerp(x1, x2, t);
                const baseY = lerp(y1, y2, t);

                // Add random deviation
                const devX = random(-50, 50);
                const devY = random(-80, 80);

                points.push({
                    x: baseX + devX,
                    y: baseY + devY
                });
            }

            points.push({ x: x2, y: y2 });
            return points;
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Animation phases
            let progress;
            if (cycleTime < 2000) {
                progress = 0; // Tangled
            } else if (cycleTime < 5500) {
                progress = easeInOutCubic((cycleTime - 2000) / 3500); // Untangling
            } else if (cycleTime < 7000) {
                progress = 1; // Straight
            } else {
                progress = 1 - easeInOutCubic((cycleTime - 7000) / 1000); // Re-tangle
            }

            // Draw connector boxes
            const leftX = width * 0.15;
            const rightX = width * 0.85;
            const boxWidth = 30;
            const boxHeight = height * 0.7;

            fill(230, 40, 25);
            stroke(230, 30, 35);
            strokeWeight(2);
            rect(leftX - boxWidth, height * 0.15, boxWidth, boxHeight, 5);
            rect(rightX, height * 0.15, boxWidth, boxHeight, 5);

            // Draw wires
            for (let wire of wires) {
                // Interpolate between tangled and straight
                const currentPoints = [];
                for (let i = 0; i < wire.tangledPoints.length; i++) {
                    currentPoints.push({
                        x: lerp(wire.tangledPoints[i].x, wire.straightPoints[i].x, progress),
                        y: lerp(wire.tangledPoints[i].y, wire.straightPoints[i].y, progress)
                    });
                }

                // Draw wire shadow
                stroke(0, 0, 0, 30);
                strokeWeight(8);
                noFill();
                drawWirePath(currentPoints, 2, 2);

                // Draw wire
                stroke(wire.hue, 60, 65);
                strokeWeight(6);
                drawWirePath(currentPoints, 0, 0);

                // Wire highlight
                stroke(wire.hue, 40, 80, 60);
                strokeWeight(2);
                drawWirePath(currentPoints, -1, -1);

                // Connection points
                fill(wire.hue, 70, 50);
                stroke(wire.hue, 80, 40);
                strokeWeight(2);
                ellipse(currentPoints[0].x, currentPoints[0].y, 15);
                ellipse(currentPoints[currentPoints.length - 1].x,
                       currentPoints[currentPoints.length - 1].y, 15);
            }

            // Satisfaction indicator
            if (progress >= 1) {
                fill(120, 60, 70, 30 + sin(time * 0.005) * 20);
                noStroke();
                rect(leftX, height * 0.15, rightX - leftX, boxHeight, 10);
            }
        }

        function drawWirePath(points, offsetX, offsetY) {
            beginShape();
            for (let i = 0; i < points.length; i++) {
                if (i === 0) {
                    curveVertex(points[i].x + offsetX, points[i].y + offsetY);
                }
                curveVertex(points[i].x + offsetX, points[i].y + offsetY);
                if (i === points.length - 1) {
                    curveVertex(points[i].x + offsetX, points[i].y + offsetY);
                }
            }
            endShape();
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateWires();
        }
    </script>
</body>
</html>
