<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tessellation Morph - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            overflow: hidden;
        }
        canvas { display: block; }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(254, 250, 224, 0.9);
            color: #606C38;
            text-decoration: none;
            border-radius: 25px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 2px solid rgba(138, 154, 91, 0.3);
        }
        .back-link:hover {
            background: #FEFAE0;
            transform: translateX(-5px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // Tessellation Morph - Shapes transform smoothly between tessellation patterns

        const LOOP_DURATION = 12000; // 12 seconds per full cycle
        const MORPH_STAGES = 4; // square -> hexagon -> triangle -> circle -> square

        let tiles = [];
        let gridSize;
        let startTime;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            startTime = millis();

            // Calculate grid size based on screen
            gridSize = min(width, height) / 10;
            createGrid();
        }

        function createGrid() {
            tiles = [];
            const cols = ceil(width / gridSize) + 2;
            const rows = ceil(height / gridSize) + 2;

            for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                    tiles.push({
                        x: col * gridSize + gridSize / 2,
                        y: row * gridSize + gridSize / 2,
                        row,
                        col,
                        hue: (row * 20 + col * 30 + 180) % 360
                    });
                }
            }
        }

        // Draw a morphed shape between different polygons
        function drawMorphedShape(x, y, size, morphProgress, hue, brightness) {
            // morphProgress goes from 0 to 1 through all stages
            const totalStages = MORPH_STAGES;
            const stageProgress = (morphProgress * totalStages) % 1;
            const currentStage = floor(morphProgress * totalStages) % totalStages;

            // Define vertex counts for each stage
            const stages = [4, 6, 3, 24]; // square, hexagon, triangle, circle-ish
            const fromSides = stages[currentStage];
            const toSides = stages[(currentStage + 1) % totalStages];

            // Eased transition
            const eased = 0.5 - 0.5 * cos(stageProgress * PI);

            push();
            translate(x, y);

            // Subtle rotation during morph
            rotate(eased * PI / 12);

            // Draw glow
            noStroke();
            for (let r = size + 10; r > size; r -= 2) {
                fill(hue, 50, brightness, map(r, size + 10, size, 0, 15));
                drawInterpolatedPolygon(0, 0, r * 0.9, fromSides, toSides, eased);
            }

            // Main shape
            fill(hue, 45, brightness);
            stroke(hue, 35, brightness + 15);
            strokeWeight(1.5);
            drawInterpolatedPolygon(0, 0, size * 0.85, fromSides, toSides, eased);

            // Inner shape
            fill(hue, 30, brightness + 15, 50);
            noStroke();
            drawInterpolatedPolygon(0, 0, size * 0.4, fromSides, toSides, eased);

            pop();
        }

        function drawInterpolatedPolygon(x, y, radius, fromSides, toSides, t) {
            // Use the higher vertex count for smoother interpolation
            const maxSides = max(fromSides, toSides, 24);

            beginShape();
            for (let i = 0; i < maxSides; i++) {
                const angle = (TWO_PI / maxSides) * i - HALF_PI;

                // Calculate radius for 'from' polygon
                const fromAngle = (TWO_PI / fromSides) * (i % fromSides);
                const fromNextAngle = (TWO_PI / fromSides) * ((i + 1) % fromSides);
                const fromProgress = (angle + HALF_PI) / TWO_PI * fromSides;
                const fromIndex = floor(fromProgress);
                const fromT = fromProgress - fromIndex;
                const fromRadius = radius * getPolygonRadius(fromSides, (i / maxSides) * fromSides);

                // Calculate radius for 'to' polygon
                const toRadius = radius * getPolygonRadius(toSides, (i / maxSides) * toSides);

                // Interpolate
                const r = lerp(fromRadius, toRadius, t);

                vertex(x + cos(angle) * r, y + sin(angle) * r);
            }
            endShape(CLOSE);
        }

        function getPolygonRadius(sides, vertexIndex) {
            // For a regular polygon, adjust radius to maintain edge length
            // This creates the "pinch" effect at vertices
            const anglePerSide = TWO_PI / sides;
            const localAngle = (vertexIndex % 1) * anglePerSide - anglePerSide / 2;
            return 1 / cos(localAngle);
        }

        function draw() {
            background(230, 30, 10);

            const time = millis() - startTime;
            const loopProgress = (time % LOOP_DURATION) / LOOP_DURATION;

            // Draw all tiles with wave-based morph offset
            for (let tile of tiles) {
                // Distance from center for wave effect
                const dx = tile.x - width / 2;
                const dy = tile.y - height / 2;
                const dist = sqrt(dx * dx + dy * dy);
                const maxDist = sqrt(width * width + height * height) / 2;

                // Wave offset based on distance
                const waveOffset = (dist / maxDist) * 0.3;
                const localProgress = (loopProgress + waveOffset) % 1;

                // Calculate brightness based on wave
                const wave = sin(loopProgress * TWO_PI * 2 - (dist / maxDist) * TWO_PI);
                const brightness = 65 + wave * 15;

                // Hue shift over time
                const hue = (tile.hue + time * 0.01) % 360;

                drawMorphedShape(tile.x, tile.y, gridSize, localProgress, hue, brightness);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            gridSize = min(width, height) / 10;
            createGrid();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
