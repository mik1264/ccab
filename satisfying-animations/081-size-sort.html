<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Size Sort - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let circles = [];
        const NUM_CIRCLES = 20;
        let baseSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateCircles();
        }

        function generateCircles() {
            circles = [];
            baseSize = min(width, height) * 0.03;

            for (let i = 0; i < NUM_CIRCLES; i++) {
                const size = baseSize * (1 + i * 0.35);
                circles.push({
                    size: size,
                    originalIndex: i,
                    x: random(size, width - size),
                    y: random(size, height - size),
                    targetX: 0,
                    targetY: 0,
                    vx: random(-1.5, 1.5),
                    vy: random(-1.5, 1.5),
                    hue: (i / NUM_CIRCLES * 60 + 180) % 360
                });
            }

            // Shuffle
            for (let i = circles.length - 1; i > 0; i--) {
                const j = floor(random(i + 1));
                [circles[i], circles[j]] = [circles[j], circles[i]];
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 10000;
            const cycleTime = time % cycleDuration;

            // Calculate line of target positions (smallest to largest)
            const sortedCircles = [...circles].sort((a, b) => a.size - b.size);

            // Calculate total width needed
            let totalWidth = 0;
            for (let c of sortedCircles) {
                totalWidth += c.size * 2 + 10;
            }

            // Position targets in a line
            let currentX = (width - totalWidth) / 2;
            const lineY = height / 2;

            for (let c of sortedCircles) {
                c.targetX = currentX + c.size;
                c.targetY = lineY;
                currentX += c.size * 2 + 10;
            }

            // Animation phases
            let phase, phaseProgress;

            if (cycleTime < 3000) {
                phase = 'chaos';
                phaseProgress = cycleTime / 3000;
            } else if (cycleTime < 6500) {
                phase = 'sorting';
                phaseProgress = (cycleTime - 3000) / 3500;
            } else if (cycleTime < 8500) {
                phase = 'sorted';
                phaseProgress = 1;
            } else {
                phase = 'scatter';
                phaseProgress = (cycleTime - 8500) / 1500;
            }

            // Update circles
            for (let circle of circles) {
                if (phase === 'chaos') {
                    // Random motion
                    circle.x += circle.vx;
                    circle.y += circle.vy;

                    // Bounce
                    if (circle.x < circle.size || circle.x > width - circle.size) circle.vx *= -1;
                    if (circle.y < circle.size || circle.y > height - circle.size) circle.vy *= -1;

                    circle.x = constrain(circle.x, circle.size, width - circle.size);
                    circle.y = constrain(circle.y, circle.size, height - circle.size);
                } else if (phase === 'sorting') {
                    if (phaseProgress < 0.01) {
                        circle.sortStartX = circle.x;
                        circle.sortStartY = circle.y;
                    }

                    const eased = easeOutBack(phaseProgress);
                    if (circle.sortStartX !== undefined) {
                        circle.x = lerp(circle.sortStartX, circle.targetX, eased);
                        circle.y = lerp(circle.sortStartY, circle.targetY, eased);
                    }
                } else if (phase === 'sorted') {
                    // Gentle bounce
                    const bounce = sin(time * 0.004 + circle.size * 0.1) * 5;
                    circle.x = circle.targetX;
                    circle.y = circle.targetY + bounce;
                } else if (phase === 'scatter') {
                    // Scatter with velocity
                    const angle = random(TWO_PI);
                    if (phaseProgress < 0.05) {
                        circle.scatterVx = cos(angle) * random(5, 15);
                        circle.scatterVy = sin(angle) * random(5, 15) - 5;
                    }
                    circle.x += circle.scatterVx || 0;
                    circle.y += circle.scatterVy || 0;
                    circle.scatterVy = (circle.scatterVy || 0) + 0.3; // Gravity
                }
            }

            // Sort by size for drawing (smaller on top)
            const drawOrder = [...circles].sort((a, b) => b.size - a.size);

            // Draw circles
            for (let circle of drawOrder) {
                // Shadow
                fill(0, 0, 0, 20);
                noStroke();
                ellipse(circle.x + 3, circle.y + 3, circle.size * 2);

                // Main circle
                fill(circle.hue, 55, 70);
                stroke(circle.hue, 65, 50);
                strokeWeight(2);
                ellipse(circle.x, circle.y, circle.size * 2);

                // Inner highlight
                fill(circle.hue, 35, 85, 50);
                noStroke();
                ellipse(circle.x - circle.size * 0.25, circle.y - circle.size * 0.25, circle.size * 0.5);
            }

            // Reset for next cycle
            if (phase === 'scatter' && phaseProgress > 0.95) {
                for (let c of circles) {
                    c.x = random(c.size, width - c.size);
                    c.y = random(c.size, height - c.size);
                    c.vx = random(-1.5, 1.5);
                    c.vy = random(-1.5, 1.5);
                    c.sortStartX = undefined;
                    c.scatterVx = undefined;
                    c.scatterVy = undefined;
                }

                for (let i = circles.length - 1; i > 0; i--) {
                    const j = floor(random(i + 1));
                    [circles[i], circles[j]] = [circles[j], circles[i]];
                }
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateCircles();
        }
    </script>
</body>
</html>
