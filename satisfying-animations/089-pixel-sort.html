<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Sort - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let pixels = [];
        const GRID_SIZE = 30;
        let cellSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            noStroke();
            generatePixels();
        }

        function generatePixels() {
            pixels = [];
            cellSize = min(width, height) * 0.8 / GRID_SIZE;

            const offsetX = (width - cellSize * GRID_SIZE) / 2;
            const offsetY = (height - cellSize * GRID_SIZE) / 2;

            // Create gradient pixels
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    // Target: sorted by hue (diagonal gradient)
                    const targetHue = ((row + col) / (GRID_SIZE * 2 - 2)) * 360;

                    // Current: scrambled
                    const scrambledRow = floor(random(GRID_SIZE));
                    const scrambledCol = floor(random(GRID_SIZE));

                    pixels.push({
                        row: row,
                        col: col,
                        hue: targetHue,
                        currentRow: scrambledRow,
                        currentCol: scrambledCol,
                        targetRow: row,
                        targetCol: col,
                        x: offsetX + scrambledCol * cellSize,
                        y: offsetY + scrambledRow * cellSize,
                        targetX: offsetX + col * cellSize,
                        targetY: offsetY + row * cellSize
                    });
                }
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Animation phases
            let phase, progress;

            if (cycleTime < 1500) {
                phase = 'scrambled';
                progress = 0;
            } else if (cycleTime < 5500) {
                phase = 'sorting';
                progress = easeInOutCubic((cycleTime - 1500) / 4000);
            } else if (cycleTime < 7000) {
                phase = 'sorted';
                progress = 1;
            } else {
                phase = 'scatter';
                progress = 1 - easeInOutCubic((cycleTime - 7000) / 1000);
            }

            const offsetX = (width - cellSize * GRID_SIZE) / 2;
            const offsetY = (height - cellSize * GRID_SIZE) / 2;

            // Update and draw pixels
            for (let pixel of pixels) {
                // Calculate current position
                const scrambledX = offsetX + pixel.currentCol * cellSize;
                const scrambledY = offsetY + pixel.currentRow * cellSize;

                const x = lerp(scrambledX, pixel.targetX, progress);
                const y = lerp(scrambledY, pixel.targetY, progress);

                // Draw pixel
                fill(pixel.hue, 65, 70);
                rect(x, y, cellSize - 1, cellSize - 1);
            }

            // Draw frame
            stroke(230, 30, 30);
            strokeWeight(3);
            noFill();
            rect(offsetX - 5, offsetY - 5, cellSize * GRID_SIZE + 10, cellSize * GRID_SIZE + 10, 3);

            // Progress bar
            if (phase === 'sorting') {
                const barWidth = cellSize * GRID_SIZE;
                fill(230, 30, 25);
                noStroke();
                rect(offsetX, offsetY + cellSize * GRID_SIZE + 20, barWidth, 6, 3);
                fill(120, 60, 70);
                rect(offsetX, offsetY + cellSize * GRID_SIZE + 20, barWidth * progress, 6, 3);
            }

            // Reset scrambled positions at cycle end
            if (phase === 'scatter' && cycleTime > 7900) {
                for (let pixel of pixels) {
                    pixel.currentRow = floor(random(GRID_SIZE));
                    pixel.currentCol = floor(random(GRID_SIZE));
                }
            }
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generatePixels();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
