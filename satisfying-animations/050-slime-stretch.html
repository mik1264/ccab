<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Stretch - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let slimePoints = [];
        const NUM_POINTS = 40;
        let anchorTop, anchorBottom;
        let stretchPhase = 0;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initSlime();
        }

        function initSlime() {
            slimePoints = [];

            anchorTop = createVector(width / 2, height * 0.2);
            anchorBottom = createVector(width / 2, height * 0.5);

            // Create slime blob points
            for (let i = 0; i < NUM_POINTS; i++) {
                const angle = (i / NUM_POINTS) * TWO_PI;
                const baseRadius = min(width, height) * 0.12;

                slimePoints.push({
                    angle: angle,
                    baseRadius: baseRadius,
                    radius: baseRadius,
                    targetRadius: baseRadius,
                    offsetX: 0,
                    offsetY: 0,
                    velocity: createVector(0, 0)
                });
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = frameCount * 0.02;

            // Stretch animation cycle
            stretchPhase = (stretchPhase + 0.008) % 1;

            // Calculate anchor positions based on stretch
            let stretchAmount;
            if (stretchPhase < 0.4) {
                // Pulling apart
                stretchAmount = easeInOutCubic(stretchPhase / 0.4);
            } else if (stretchPhase < 0.6) {
                // Held stretched
                stretchAmount = 1;
            } else if (stretchPhase < 0.8) {
                // Snapping back
                stretchAmount = 1 - easeInOutCubic((stretchPhase - 0.6) / 0.2);
            } else {
                // Wobbling after snap
                const wobblePhase = (stretchPhase - 0.8) / 0.2;
                stretchAmount = sin(wobblePhase * PI * 4) * 0.1 * (1 - wobblePhase);
            }

            const maxStretch = height * 0.35;
            anchorTop.y = height * 0.3 - stretchAmount * maxStretch * 0.3;
            anchorBottom.y = height * 0.5 + stretchAmount * maxStretch;

            // Update slime physics
            updateSlime(stretchAmount);

            // Draw slime
            drawSlime();

            // Draw anchor points (hands)
            drawHand(anchorTop.x, anchorTop.y, true);
            drawHand(anchorBottom.x, anchorBottom.y, false);
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2;
        }

        function updateSlime(stretch) {
            const slimeCenter = p5.Vector.lerp(anchorTop, anchorBottom, 0.5);

            for (let i = 0; i < slimePoints.length; i++) {
                const p = slimePoints[i];
                const angle = p.angle;

                // Base shape gets squeezed when stretched
                const squeeze = 1 - stretch * 0.6;
                const verticalStretch = 1 + stretch * 0.5;

                // Determine if point is near top or bottom
                const topInfluence = (1 + cos(angle - HALF_PI)) / 2;
                const bottomInfluence = (1 + cos(angle + HALF_PI)) / 2;

                // Calculate target position
                let targetX = cos(angle) * p.baseRadius * squeeze;
                let targetY = sin(angle) * p.baseRadius * verticalStretch;

                // Pull towards anchors
                if (topInfluence > 0.5) {
                    const pull = (topInfluence - 0.5) * 2 * stretch;
                    targetY = lerp(targetY, anchorTop.y - slimeCenter.y, pull * 0.3);
                }
                if (bottomInfluence > 0.5) {
                    const pull = (bottomInfluence - 0.5) * 2 * stretch;
                    targetY = lerp(targetY, anchorBottom.y - slimeCenter.y, pull * 0.3);
                }

                // Wobble
                const wobble = sin(frameCount * 0.1 + i * 0.3) * 5 * (1 - stretch * 0.5);
                targetX += wobble;

                // Spring physics
                const springK = 0.1;
                const damping = 0.85;

                p.velocity.x += (targetX - p.offsetX) * springK;
                p.velocity.y += (targetY - p.offsetY) * springK;
                p.velocity.mult(damping);

                p.offsetX += p.velocity.x;
                p.offsetY += p.velocity.y;
            }
        }

        function drawSlime() {
            const slimeCenter = p5.Vector.lerp(anchorTop, anchorBottom, 0.5);

            // Get all points
            const points = [];
            for (let p of slimePoints) {
                points.push({
                    x: slimeCenter.x + p.offsetX,
                    y: slimeCenter.y + p.offsetY
                });
            }

            // Outer glow
            noStroke();
            for (let r = 1.3; r > 1.0; r -= 0.1) {
                fill(120, 70, 60, map(r, 1.3, 1.0, 10, 0));
                beginShape();
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const dx = p.x - slimeCenter.x;
                    const dy = p.y - slimeCenter.y;
                    curveVertex(slimeCenter.x + dx * r, slimeCenter.y + dy * r);
                }
                // Close properly
                for (let i = 0; i < 3; i++) {
                    const p = points[i];
                    const dx = p.x - slimeCenter.x;
                    const dy = p.y - slimeCenter.y;
                    curveVertex(slimeCenter.x + dx * r, slimeCenter.y + dy * r);
                }
                endShape(CLOSE);
            }

            // Main slime body
            fill(120, 65, 70, 85);
            stroke(120, 70, 55);
            strokeWeight(3);
            beginShape();
            for (let p of points) {
                curveVertex(p.x, p.y);
            }
            for (let i = 0; i < 3; i++) {
                curveVertex(points[i].x, points[i].y);
            }
            endShape(CLOSE);

            // Inner highlight
            noStroke();
            fill(120, 40, 85, 40);
            beginShape();
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const dx = p.x - slimeCenter.x;
                const dy = p.y - slimeCenter.y;
                curveVertex(slimeCenter.x + dx * 0.6 - 10, slimeCenter.y + dy * 0.6 - 10);
            }
            for (let i = 0; i < 3; i++) {
                const p = points[i];
                const dx = p.x - slimeCenter.x;
                const dy = p.y - slimeCenter.y;
                curveVertex(slimeCenter.x + dx * 0.6 - 10, slimeCenter.y + dy * 0.6 - 10);
            }
            endShape(CLOSE);

            // Specular highlights
            fill(0, 0, 100, 50);
            ellipse(slimeCenter.x - 20, slimeCenter.y - 30, 25, 15);
            fill(0, 0, 100, 35);
            ellipse(slimeCenter.x - 10, slimeCenter.y - 50, 12, 8);
        }

        function drawHand(x, y, isTop) {
            push();
            translate(x, y);
            if (!isTop) rotate(PI);

            // Simple hand shape
            fill(40, 30, 85);
            stroke(40, 40, 70);
            strokeWeight(2);

            // Palm
            ellipse(0, -20, 50, 40);

            // Fingers
            for (let i = -2; i <= 2; i++) {
                const fingerX = i * 10;
                const fingerLength = i === 0 ? 30 : 25;
                rect(fingerX - 5, -45, 10, fingerLength, 5);
            }

            // Thumb
            push();
            rotate(-0.5);
            rect(-30, -30, 12, 25, 5);
            pop();

            pop();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initSlime();
        }
    </script>
</body>
</html>
