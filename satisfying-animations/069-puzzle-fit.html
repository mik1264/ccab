<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Fit - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        const GRID = 4;
        let pieces = [];
        let pieceSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generatePuzzle();
        }

        function generatePuzzle() {
            pieces = [];
            pieceSize = min(width, height) / (GRID + 3);

            const offsetX = (width - pieceSize * GRID) / 2;
            const offsetY = (height - pieceSize * GRID) / 2;

            for (let row = 0; row < GRID; row++) {
                for (let col = 0; col < GRID; col++) {
                    const targetX = offsetX + col * pieceSize + pieceSize / 2;
                    const targetY = offsetY + row * pieceSize + pieceSize / 2;

                    // Random start position (scattered)
                    const startAngle = random(TWO_PI);
                    const startDist = random(200, 400);

                    pieces.push({
                        row: row,
                        col: col,
                        targetX: targetX,
                        targetY: targetY,
                        startX: targetX + cos(startAngle) * startDist,
                        startY: targetY + sin(startAngle) * startDist,
                        x: targetX + cos(startAngle) * startDist,
                        y: targetY + sin(startAngle) * startDist,
                        rotation: random(-PI, PI),
                        targetRotation: 0,
                        hue: (row * 40 + col * 50 + 180) % 360,
                        delay: (row + col) * 200,
                        // Edge types: 0 = flat, 1 = tab, -1 = hole
                        edges: {
                            top: row === 0 ? 0 : -pieces[(row - 1) * GRID + col]?.edges.bottom || (random() > 0.5 ? 1 : -1),
                            right: col === GRID - 1 ? 0 : (random() > 0.5 ? 1 : -1),
                            bottom: row === GRID - 1 ? 0 : (random() > 0.5 ? 1 : -1),
                            left: col === 0 ? 0 : -pieces[row * GRID + col - 1]?.edges.right || (random() > 0.5 ? 1 : -1)
                        }
                    });
                }
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Animation phases
            let phase;
            if (cycleTime < 4000) {
                phase = 'assembling';
            } else if (cycleTime < 6000) {
                phase = 'complete';
            } else {
                phase = 'scattering';
            }

            for (let piece of pieces) {
                let progress;

                if (phase === 'assembling') {
                    const pieceTime = max(0, cycleTime - piece.delay);
                    progress = min(1, pieceTime / 2000);
                    progress = easeOutBack(progress);
                } else if (phase === 'complete') {
                    progress = 1;
                } else {
                    const scatterTime = cycleTime - 6000;
                    progress = 1 - min(1, scatterTime / 1500);
                }

                // Interpolate position and rotation
                piece.x = lerp(piece.startX, piece.targetX, progress);
                piece.y = lerp(piece.startY, piece.targetY, progress);
                piece.rotation = lerp(piece.rotation, piece.targetRotation, progress);

                // Wobble when complete
                let wobble = 0;
                if (phase === 'complete') {
                    wobble = sin(time * 0.003 + piece.row + piece.col) * 0.02;
                }

                push();
                translate(piece.x, piece.y);
                rotate(piece.rotation + wobble);

                drawPuzzlePiece(piece, pieceSize * 0.9);

                pop();
            }
        }

        function drawPuzzlePiece(piece, size) {
            const tabSize = size * 0.2;

            // Shadow
            fill(0, 0, 0, 20);
            noStroke();
            push();
            translate(3, 3);
            drawPieceShape(size, tabSize, piece.edges);
            pop();

            // Main piece
            fill(piece.hue, 50, 70);
            stroke(piece.hue, 60, 50);
            strokeWeight(2);
            drawPieceShape(size, tabSize, piece.edges);

            // Highlight
            fill(piece.hue, 35, 85, 50);
            noStroke();
            ellipse(-size * 0.15, -size * 0.15, size * 0.3);
        }

        function drawPieceShape(size, tabSize, edges) {
            const half = size / 2;

            beginShape();

            // Top edge
            vertex(-half, -half);
            if (edges.top !== 0) {
                vertex(-tabSize, -half);
                if (edges.top === 1) {
                    // Tab
                    bezierVertex(-tabSize, -half - tabSize, tabSize, -half - tabSize, tabSize, -half);
                } else {
                    // Hole
                    bezierVertex(-tabSize, -half + tabSize, tabSize, -half + tabSize, tabSize, -half);
                }
            }
            vertex(half, -half);

            // Right edge
            if (edges.right !== 0) {
                vertex(half, -tabSize);
                if (edges.right === 1) {
                    bezierVertex(half + tabSize, -tabSize, half + tabSize, tabSize, half, tabSize);
                } else {
                    bezierVertex(half - tabSize, -tabSize, half - tabSize, tabSize, half, tabSize);
                }
            }
            vertex(half, half);

            // Bottom edge
            if (edges.bottom !== 0) {
                vertex(tabSize, half);
                if (edges.bottom === 1) {
                    bezierVertex(tabSize, half + tabSize, -tabSize, half + tabSize, -tabSize, half);
                } else {
                    bezierVertex(tabSize, half - tabSize, -tabSize, half - tabSize, -tabSize, half);
                }
            }
            vertex(-half, half);

            // Left edge
            if (edges.left !== 0) {
                vertex(-half, tabSize);
                if (edges.left === 1) {
                    bezierVertex(-half - tabSize, tabSize, -half - tabSize, -tabSize, -half, -tabSize);
                } else {
                    bezierVertex(-half + tabSize, tabSize, -half + tabSize, -tabSize, -half, -tabSize);
                }
            }

            endShape(CLOSE);
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generatePuzzle();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
