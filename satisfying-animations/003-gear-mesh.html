<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gear Mesh - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            overflow: hidden;
        }
        canvas { display: block; }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(254, 250, 224, 0.9);
            color: #606C38;
            text-decoration: none;
            border-radius: 25px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 2px solid rgba(138, 154, 91, 0.3);
        }
        .back-link:hover {
            background: #FEFAE0;
            transform: translateX(-5px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // Gear Mesh - Interlocking gears rotating in perfect harmony

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xDDA15E, 0.5, 20);
        pointLight.position.set(-3, 3, 5);
        scene.add(pointLight);

        // Create gear shape
        function createGearGeometry(innerRadius, outerRadius, teeth, thickness) {
            const shape = new THREE.Shape();
            const toothHeight = (outerRadius - innerRadius) * 0.6;
            const toothWidth = (2 * Math.PI * innerRadius) / (teeth * 2.5);

            for (let i = 0; i < teeth; i++) {
                const angle = (i / teeth) * Math.PI * 2;
                const nextAngle = ((i + 1) / teeth) * Math.PI * 2;
                const midAngle = (angle + nextAngle) / 2;

                // Base of tooth
                const baseX1 = Math.cos(angle + 0.05) * innerRadius;
                const baseY1 = Math.sin(angle + 0.05) * innerRadius;

                // Top of tooth
                const topX1 = Math.cos(angle + 0.1) * outerRadius;
                const topY1 = Math.sin(angle + 0.1) * outerRadius;
                const topX2 = Math.cos(midAngle - 0.1) * outerRadius;
                const topY2 = Math.sin(midAngle - 0.1) * outerRadius;

                // Valley between teeth
                const valleyX = Math.cos(midAngle + 0.15) * innerRadius;
                const valleyY = Math.sin(midAngle + 0.15) * innerRadius;

                if (i === 0) {
                    shape.moveTo(baseX1, baseY1);
                } else {
                    shape.lineTo(baseX1, baseY1);
                }
                shape.lineTo(topX1, topY1);
                shape.lineTo(topX2, topY2);
                shape.lineTo(valleyX, valleyY);
            }
            shape.closePath();

            // Center hole
            const holePath = new THREE.Path();
            const holeRadius = innerRadius * 0.4;
            holePath.absarc(0, 0, holeRadius, 0, Math.PI * 2, true);
            shape.holes.push(holePath);

            const extrudeSettings = {
                steps: 1,
                depth: thickness,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05,
                bevelSegments: 2
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        // Create gear materials with different colors
        const gearColors = [
            0x8A9A5B, // sage
            0xDDA15E, // earth
            0xBC6C25, // terracotta
            0x606C38, // moss
            0x9A8C6C  // bronze
        ];

        const gears = [];

        function createGear(x, y, innerRadius, outerRadius, teeth, thickness, colorIndex, rotationDirection) {
            const geometry = createGearGeometry(innerRadius, outerRadius, teeth, thickness);
            const material = new THREE.MeshStandardMaterial({
                color: gearColors[colorIndex % gearColors.length],
                metalness: 0.7,
                roughness: 0.3
            });
            const gear = new THREE.Mesh(geometry, material);
            gear.position.set(x, y, -thickness / 2);
            gear.userData = {
                teeth,
                rotationDirection,
                speed: 1 / teeth // Speed inversely proportional to teeth
            };
            scene.add(gear);
            gears.push(gear);
            return gear;
        }

        // Create interlocking gear system
        // Central gear
        createGear(0, 0, 1.2, 2, 16, 0.5, 0, 1);

        // Surrounding gears (mesh with central)
        const centralTeeth = 16;
        const centralRadius = 2;

        // Top gear
        const gear2Teeth = 12;
        const gear2Radius = centralRadius * (gear2Teeth / centralTeeth);
        createGear(0, centralRadius + gear2Radius - 0.15, 0.8, gear2Radius, gear2Teeth, 0.5, 1, -1);

        // Right gear
        const gear3Teeth = 20;
        const gear3Radius = centralRadius * (gear3Teeth / centralTeeth);
        createGear(centralRadius + gear3Radius - 0.2, 0, 1, gear3Radius, gear3Teeth, 0.5, 2, -1);

        // Bottom-left gear
        const gear4Teeth = 10;
        const gear4Radius = centralRadius * (gear4Teeth / centralTeeth);
        createGear(-2.5, -2.2, 0.6, gear4Radius, gear4Teeth, 0.5, 3, -1);

        // Small gear connecting bottom-left to center
        const gear5Teeth = 8;
        const gear5Radius = centralRadius * (gear5Teeth / centralTeeth);
        createGear(-1.5, -1.2, 0.4, gear5Radius, gear5Teeth, 0.5, 4, 1);

        // Animation
        const baseSpeed = 0.5;

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Rotate gears based on their teeth count and direction
            // First gear sets the pace, others follow based on gear ratios
            const baseRotation = time * baseSpeed;

            gears.forEach((gear, index) => {
                // Gear ratio: smaller gears rotate faster
                const ratio = gears[0].userData.teeth / gear.userData.teeth;
                gear.rotation.z = baseRotation * ratio * gear.userData.rotationDirection;
            });

            // Subtle camera movement
            camera.position.x = Math.sin(time * 0.2) * 0.5;
            camera.position.y = Math.cos(time * 0.15) * 0.3;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();

        window.reset = function() { camera.position.set(0, 0, 12); camera.lookAt(0, 0, 0); };

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
