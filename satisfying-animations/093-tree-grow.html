<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Grow - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let branches = [];
        let leaves = [];
        let maxDepth = 8;
        let baseLength;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            generateTree();
        }

        function generateTree() {
            branches = [];
            leaves = [];
            baseLength = min(width, height) * 0.15;

            // Generate tree structure using L-system-like recursion
            const startX = width / 2;
            const startY = height * 0.85;

            generateBranch(startX, startY, -HALF_PI, baseLength, 0, 0);
        }

        function generateBranch(x, y, angle, length, depth, delay) {
            if (depth > maxDepth || length < 5) {
                // Add leaf
                leaves.push({
                    x: x,
                    y: y,
                    size: random(8, 15),
                    hue: random(80, 140),
                    delay: delay + 100
                });
                return;
            }

            const endX = x + cos(angle) * length;
            const endY = y + sin(angle) * length;

            branches.push({
                x1: x,
                y1: y,
                x2: endX,
                y2: endY,
                depth: depth,
                delay: delay,
                thickness: map(depth, 0, maxDepth, 15, 2)
            });

            // Create child branches
            const numChildren = depth < 2 ? 2 : (random() > 0.3 ? 2 : 1);
            const angleSpread = map(depth, 0, maxDepth, 0.4, 0.6);
            const lengthRatio = random(0.65, 0.8);

            const branchDelay = 150;

            if (numChildren >= 1) {
                const newAngle1 = angle - angleSpread + random(-0.1, 0.1);
                generateBranch(endX, endY, newAngle1, length * lengthRatio, depth + 1, delay + branchDelay);
            }

            if (numChildren >= 2) {
                const newAngle2 = angle + angleSpread + random(-0.1, 0.1);
                generateBranch(endX, endY, newAngle2, length * lengthRatio * random(0.9, 1.1), depth + 1, delay + branchDelay);
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 10000;
            const cycleTime = time % cycleDuration;

            // Reset at cycle start
            if (cycleTime < 50) {
                generateTree();
            }

            // Calculate max delay for progress
            let maxDelay = 0;
            for (let b of branches) maxDelay = max(maxDelay, b.delay);
            for (let l of leaves) maxDelay = max(maxDelay, l.delay);

            // Animation progress
            let growProgress;
            if (cycleTime < 6000) {
                growProgress = cycleTime;
            } else if (cycleTime < 8000) {
                growProgress = maxDelay + 1000;
            } else {
                growProgress = maxDelay + 1000 - (cycleTime - 8000) * 3;
            }

            // Draw branches
            for (let branch of branches) {
                const branchProgress = constrain((growProgress - branch.delay) / 500, 0, 1);

                if (branchProgress > 0) {
                    const eased = easeOutCubic(branchProgress);

                    const currentX2 = lerp(branch.x1, branch.x2, eased);
                    const currentY2 = lerp(branch.y1, branch.y2, eased);

                    // Branch color (brown gradient)
                    const hue = 25 + branch.depth * 2;
                    const sat = 50 - branch.depth * 3;
                    const bri = 40 + branch.depth * 3;

                    stroke(hue, sat, bri);
                    strokeWeight(branch.thickness * eased);
                    line(branch.x1, branch.y1, currentX2, currentY2);
                }
            }

            // Draw leaves
            for (let leaf of leaves) {
                const leafProgress = constrain((growProgress - leaf.delay) / 300, 0, 1);

                if (leafProgress > 0) {
                    const eased = easeOutBack(leafProgress);
                    const size = leaf.size * eased;

                    // Sway
                    const sway = sin(time * 0.002 + leaf.x * 0.01) * 3 * leafProgress;

                    push();
                    translate(leaf.x + sway, leaf.y);

                    // Leaf shadow
                    fill(0, 0, 0, 20);
                    noStroke();
                    ellipse(2, 2, size, size * 0.6);

                    // Leaf
                    fill(leaf.hue, 60, 60);
                    stroke(leaf.hue, 70, 40);
                    strokeWeight(1);
                    ellipse(0, 0, size, size * 0.6);

                    pop();
                }
            }

            // Ground
            fill(25, 40, 25);
            noStroke();
            rect(0, height * 0.85, width, height * 0.15);

            // Grass tufts
            stroke(100, 50, 40);
            strokeWeight(2);
            for (let i = 0; i < 50; i++) {
                const gx = random(width);
                const gy = height * 0.85 + random(10);
                const gh = random(10, 20);
                const sway = sin(time * 0.003 + gx * 0.01) * 3;
                line(gx, gy, gx + sway, gy - gh);
            }
        }

        function easeOutCubic(x) {
            return 1 - pow(1 - x, 3);
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateTree();
        }
    </script>
</body>
</html>
