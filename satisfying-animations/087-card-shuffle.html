<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Shuffle - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let cards = [];
        const NUM_CARDS = 13;
        let cardWidth, cardHeight;
        const suits = ['♠', '♥', '♦', '♣'];
        const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            textFont('Georgia');
            generateCards();
        }

        function generateCards() {
            cards = [];
            cardWidth = min(width, height) * 0.08;
            cardHeight = cardWidth * 1.4;

            // Create shuffled deck (one suit)
            const indices = [];
            for (let i = 0; i < NUM_CARDS; i++) {
                indices.push(i);
            }

            // Shuffle
            for (let i = indices.length - 1; i > 0; i--) {
                const j = floor(random(i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            for (let i = 0; i < NUM_CARDS; i++) {
                cards.push({
                    value: indices[i],
                    displayValue: values[indices[i]],
                    suit: '♠',
                    isRed: false,
                    position: i,
                    targetPosition: indices[i],
                    x: 0,
                    y: 0,
                    targetX: 0,
                    targetY: 0,
                    rotation: 0,
                    targetRotation: 0
                });
            }
        }

        function draw() {
            background(230, 30, 15);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Calculate card positions
            const spacing = cardWidth * 0.3;
            const totalWidth = (NUM_CARDS - 1) * spacing + cardWidth;
            const startX = (width - totalWidth) / 2 + cardWidth / 2;
            const centerY = height / 2;

            // Animation phases
            let phase, phaseProgress;

            if (cycleTime < 2000) {
                phase = 'shuffled';
                phaseProgress = 0;
            } else if (cycleTime < 5000) {
                phase = 'sorting';
                phaseProgress = easeInOutCubic((cycleTime - 2000) / 3000);
            } else if (cycleTime < 7000) {
                phase = 'sorted';
                phaseProgress = 1;
            } else {
                phase = 'scatter';
                phaseProgress = (cycleTime - 7000) / 1000;
            }

            // Update card positions
            for (let card of cards) {
                // Shuffled position
                const shuffledX = startX + card.position * spacing;
                const shuffledY = centerY + sin(card.position * 0.5) * 20;
                const shuffledRot = (card.position - NUM_CARDS / 2) * 0.03;

                // Sorted position
                const sortedX = startX + card.value * spacing;
                const sortedY = centerY;
                const sortedRot = (card.value - NUM_CARDS / 2) * 0.02;

                if (phase === 'scatter') {
                    // Scatter animation
                    card.x = lerp(sortedX, sortedX + (random() - 0.5) * 500 * phaseProgress, phaseProgress);
                    card.y = lerp(sortedY, sortedY + random() * 300 * phaseProgress, phaseProgress);
                    card.rotation = lerp(sortedRot, random(-1, 1), phaseProgress);
                } else {
                    card.x = lerp(shuffledX, sortedX, phaseProgress);
                    card.y = lerp(shuffledY, sortedY, phaseProgress);
                    card.rotation = lerp(shuffledRot, sortedRot, phaseProgress);
                }

                // Arc during sort
                if (phase === 'sorting') {
                    const dist = abs(card.value - card.position);
                    const arc = sin(phaseProgress * PI) * dist * 15;
                    card.y -= arc;
                }
            }

            // Sort cards by y for proper overlap
            const sortedCards = [...cards].sort((a, b) => {
                if (phase === 'sorting') {
                    return a.y - b.y;
                }
                return a.x - b.x;
            });

            // Draw cards
            for (let card of sortedCards) {
                push();
                translate(card.x, card.y);
                rotate(card.rotation);

                // Shadow
                fill(0, 0, 0, 30);
                noStroke();
                rect(-cardWidth / 2 + 4, -cardHeight / 2 + 4, cardWidth, cardHeight, 5);

                // Card back (during shuffle) or front
                fill(0, 0, 98);
                stroke(0, 0, 80);
                strokeWeight(1);
                rect(-cardWidth / 2, -cardHeight / 2, cardWidth, cardHeight, 5);

                // Card content
                const textCol = card.isRed ? color(0, 80, 60) : color(0, 0, 20);
                fill(textCol);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(cardWidth * 0.35);
                text(card.displayValue, 0, -cardHeight * 0.15);
                textSize(cardWidth * 0.4);
                text(card.suit, 0, cardHeight * 0.15);

                // Corner values
                textSize(cardWidth * 0.18);
                textAlign(LEFT, TOP);
                text(card.displayValue, -cardWidth / 2 + 4, -cardHeight / 2 + 4);
                textSize(cardWidth * 0.2);
                text(card.suit, -cardWidth / 2 + 4, -cardHeight / 2 + cardWidth * 0.2);

                pop();
            }

            // Reset at cycle end
            if (phase === 'scatter' && phaseProgress > 0.95) {
                generateCards();
            }
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateCards();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
