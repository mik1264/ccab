<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Rise - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let bubbles = [];
        const MAX_BUBBLES = 60;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);

            // Create initial bubbles
            for (let i = 0; i < MAX_BUBBLES; i++) {
                bubbles.push(createBubble(random(height)));
            }
        }

        function createBubble(startY = height + 50) {
            const size = random(10, 50);
            return {
                x: random(width),
                y: startY,
                size: size,
                speed: map(size, 10, 50, 2, 0.5), // Smaller = faster
                wobbleOffset: random(TWO_PI),
                wobbleSpeed: random(0.02, 0.05),
                wobbleAmount: random(0.5, 2),
                hue: random(180, 220),
                opacity: random(40, 80)
            };
        }

        function draw() {
            // Underwater gradient background
            for (let y = 0; y < height; y++) {
                const inter = map(y, 0, height, 0, 1);
                const c = lerpColor(
                    color(200, 60, 40),
                    color(210, 80, 20),
                    inter
                );
                stroke(c);
                line(0, y, width, y);
            }

            // Light rays from surface
            noStroke();
            for (let i = 0; i < 5; i++) {
                const rayX = width * (0.2 + i * 0.15);
                const rayWidth = 100 + sin(frameCount * 0.01 + i) * 30;

                for (let y = 0; y < height; y++) {
                    const alpha = map(y, 0, height, 15, 0);
                    const spread = map(y, 0, height, 0, rayWidth * 0.5);
                    fill(180, 30, 100, alpha);
                    rect(rayX - spread, y, spread * 2, 1);
                }
            }

            // Update and draw bubbles
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];

                // Rise
                b.y -= b.speed;

                // Wobble
                b.x += sin(frameCount * b.wobbleSpeed + b.wobbleOffset) * b.wobbleAmount;

                // Pop at surface
                if (b.y < -b.size) {
                    bubbles[i] = createBubble();
                    continue;
                }

                // Draw bubble
                drawBubble(b);
            }

            // Spawn new bubbles
            if (random() < 0.1 && bubbles.length < MAX_BUBBLES) {
                bubbles.push(createBubble());
            }
        }

        function drawBubble(b) {
            push();
            translate(b.x, b.y);

            // Subtle squish based on movement
            const squish = 1 + sin(frameCount * b.wobbleSpeed * 2 + b.wobbleOffset) * 0.05;

            // Outer glow
            noStroke();
            for (let r = b.size * 1.5; r > b.size; r -= 3) {
                fill(b.hue, 40, 100, map(r, b.size * 1.5, b.size, 5, 0));
                ellipse(0, 0, r * 2 / squish, r * 2 * squish);
            }

            // Main bubble body
            fill(b.hue, 30, 95, b.opacity * 0.3);
            stroke(b.hue, 40, 100, b.opacity);
            strokeWeight(1.5);
            ellipse(0, 0, b.size * 2 / squish, b.size * 2 * squish);

            // Inner gradient
            noStroke();
            for (let r = b.size * 0.9; r > 0; r -= b.size * 0.1) {
                const alpha = map(r, b.size * 0.9, 0, 5, 15);
                fill(b.hue - 10, 20, 100, alpha);
                ellipse(0, b.size * 0.1, r * 2 / squish, r * 2 * squish);
            }

            // Highlight (top-left)
            fill(0, 0, 100, 60);
            ellipse(-b.size * 0.3, -b.size * 0.3, b.size * 0.4, b.size * 0.3);

            // Small secondary highlight
            fill(0, 0, 100, 40);
            ellipse(-b.size * 0.15, -b.size * 0.45, b.size * 0.15, b.size * 0.1);

            // Bottom reflection
            fill(b.hue + 20, 40, 90, 20);
            ellipse(b.size * 0.2, b.size * 0.4, b.size * 0.3, b.size * 0.15);

            pop();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
