<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Countdown - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let particles = [];
        let fontSize;
        let currentNumber = 10;
        let lastNumber = 10;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            textFont('Georgia');
            fontSize = min(width, height) * 0.4;
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 12000; // 12 seconds for 10-0 countdown
            const cycleTime = time % cycleDuration;

            // Calculate current number
            if (cycleTime < 10000) {
                currentNumber = 10 - floor(cycleTime / 1000);
            } else {
                currentNumber = 0;
            }

            // Spawn particles on number change
            if (currentNumber !== lastNumber) {
                spawnParticles();
                lastNumber = currentNumber;
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.vy += 0.2; // Gravity
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotSpeed;
                p.life -= 0.02;

                if (p.life > 0) {
                    push();
                    translate(p.x, p.y);
                    rotate(p.rotation);

                    fill(p.hue, 60, 70, p.life * 100);
                    noStroke();

                    if (p.shape === 'rect') {
                        rectMode(CENTER);
                        rect(0, 0, p.size, p.size * 0.5);
                    } else if (p.shape === 'triangle') {
                        triangle(-p.size / 2, p.size / 2, p.size / 2, p.size / 2, 0, -p.size / 2);
                    } else {
                        ellipse(0, 0, p.size);
                    }

                    pop();
                } else {
                    particles.splice(i, 1);
                }
            }

            // Draw countdown number
            const numberProgress = (cycleTime % 1000) / 1000;
            const scale = 1 + sin(numberProgress * PI) * 0.1;
            const alpha = currentNumber === 0 ? 100 : 80 + sin(numberProgress * PI) * 20;

            push();
            translate(width / 2, height / 2);

            // Glow effect
            for (let g = 5; g > 0; g--) {
                fill(45, 50, 70, (10 / g) * (alpha / 100));
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(fontSize * scale + g * 10);
                text(currentNumber, 0, 0);
            }

            // Main number
            fill(45, 60, 90, alpha);
            stroke(45, 70, 70);
            strokeWeight(3);
            textSize(fontSize * scale);
            text(currentNumber, 0, 0);

            pop();

            // Progress ring
            const ringRadius = min(width, height) * 0.35;
            noFill();
            strokeWeight(8);

            // Background ring
            stroke(230, 30, 25);
            ellipse(width / 2, height / 2, ringRadius * 2);

            // Progress ring
            stroke(45, 60, 70);
            const progress = 1 - cycleTime / 10000;
            if (progress > 0) {
                arc(width / 2, height / 2, ringRadius * 2, ringRadius * 2,
                    -HALF_PI, -HALF_PI + progress * TWO_PI);
            }

            // Celebration when reaching zero
            if (currentNumber === 0 && cycleTime > 10000) {
                const celebrationTime = cycleTime - 10000;

                // Pulsing glow
                const pulseAlpha = sin(celebrationTime * 0.01) * 30 + 30;
                fill(45, 50, 80, pulseAlpha);
                noStroke();
                ellipse(width / 2, height / 2, ringRadius * 2.5);

                // Sparkles
                for (let i = 0; i < 20; i++) {
                    const angle = random(TWO_PI);
                    const dist = random(ringRadius * 0.5, ringRadius * 1.2);
                    const x = width / 2 + cos(angle) * dist;
                    const y = height / 2 + sin(angle) * dist;
                    const sparkleSize = random(3, 8);

                    fill(random(30, 60), 60, 90, random(50, 100));
                    noStroke();

                    push();
                    translate(x, y);
                    rotate(random(TWO_PI));
                    star(0, 0, sparkleSize / 2, sparkleSize, 4);
                    pop();
                }
            }
        }

        function spawnParticles() {
            const shapes = ['rect', 'triangle', 'circle'];

            for (let i = 0; i < 30; i++) {
                const angle = random(TWO_PI);
                const speed = random(5, 15);

                particles.push({
                    x: width / 2,
                    y: height / 2,
                    vx: cos(angle) * speed,
                    vy: sin(angle) * speed - 5,
                    rotation: random(TWO_PI),
                    rotSpeed: random(-0.2, 0.2),
                    size: random(10, 25),
                    hue: random(30, 60),
                    life: 1,
                    shape: shapes[floor(random(shapes.length))]
                });
            }
        }

        function star(x, y, radius1, radius2, npoints) {
            let angle = TWO_PI / npoints;
            let halfAngle = angle / 2.0;
            beginShape();
            for (let a = -HALF_PI; a < TWO_PI - HALF_PI; a += angle) {
                let sx = x + cos(a) * radius2;
                let sy = y + sin(a) * radius2;
                vertex(sx, sy);
                sx = x + cos(a + halfAngle) * radius1;
                sy = y + sin(a + halfAngle) * radius1;
                vertex(sx, sy);
            }
            endShape(CLOSE);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            fontSize = min(width, height) * 0.4;
        }
    </script>
</body>
</html>
