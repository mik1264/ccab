<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Assemble - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        let pieces = [];
        const GRID = 5;
        let pieceSize;
        let img;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            pixelDensity(1);

            // Create gradient image
            img = createGraphics(400, 400);
            img.colorMode(HSB, 360, 100, 100);
            for (let y = 0; y < 400; y++) {
                for (let x = 0; x < 400; x++) {
                    const hue = (x + y) * 0.4;
                    img.stroke(hue % 360, 60, 70);
                    img.point(x, y);
                }
            }

            generatePuzzle();
        }

        function generatePuzzle() {
            pieces = [];
            pieceSize = min(width, height) * 0.12;

            const totalSize = pieceSize * GRID;
            const offsetX = (width - totalSize) / 2;
            const offsetY = (height - totalSize) / 2;

            for (let row = 0; row < GRID; row++) {
                for (let col = 0; col < GRID; col++) {
                    const targetX = offsetX + col * pieceSize + pieceSize / 2;
                    const targetY = offsetY + row * pieceSize + pieceSize / 2;

                    // Random scatter position
                    const angle = random(TWO_PI);
                    const dist = random(200, 400);

                    pieces.push({
                        row: row,
                        col: col,
                        targetX: targetX,
                        targetY: targetY,
                        x: targetX + cos(angle) * dist,
                        y: targetY + sin(angle) * dist,
                        rotation: random(-PI, PI),
                        targetRotation: 0,
                        delay: (row + col) * 150,
                        imgX: col * (400 / GRID),
                        imgY: row * (400 / GRID),
                        imgW: 400 / GRID,
                        imgH: 400 / GRID
                    });
                }
            }

            // Shuffle order
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = floor(random(i + 1));
                const temp = pieces[i].delay;
                pieces[i].delay = pieces[j].delay;
                pieces[j].delay = temp;
            }
        }

        function draw() {
            background(230, 30, 10);

            const time = millis();
            const cycleDuration = 8000;
            const cycleTime = time % cycleDuration;

            // Draw target frame
            const totalSize = pieceSize * GRID;
            const offsetX = (width - totalSize) / 2;
            const offsetY = (height - totalSize) / 2;

            stroke(230, 30, 25);
            strokeWeight(2);
            noFill();
            rect(offsetX - 5, offsetY - 5, totalSize + 10, totalSize + 10, 5);

            // Update and draw pieces
            for (let piece of pieces) {
                let progress;

                if (cycleTime < 5000) {
                    const pieceTime = max(0, cycleTime - piece.delay);
                    progress = min(1, pieceTime / 2000);
                    progress = easeOutBack(progress);
                } else if (cycleTime < 6500) {
                    progress = 1;
                } else {
                    const scatterTime = cycleTime - 6500;
                    progress = 1 - min(1, scatterTime / 1500);
                }

                // Interpolate
                const startAngle = random(TWO_PI);
                const startDist = 300;

                if (cycleTime < 50) {
                    piece.x = piece.targetX + cos(startAngle) * startDist;
                    piece.y = piece.targetY + sin(startAngle) * startDist;
                    piece.rotation = random(-PI, PI);
                }

                const currentX = lerp(piece.x, piece.targetX, progress);
                const currentY = lerp(piece.y, piece.targetY, progress);
                const currentRot = lerp(piece.rotation, piece.targetRotation, progress);

                // Draw piece
                push();
                translate(currentX, currentY);
                rotate(currentRot);

                // Shadow
                fill(0, 0, 0, 20);
                noStroke();
                rect(-pieceSize / 2 + 3, -pieceSize / 2 + 3, pieceSize - 4, pieceSize - 4, 3);

                // Piece with image section
                const pImg = img.get(piece.imgX, piece.imgY, piece.imgW, piece.imgH);
                imageMode(CENTER);
                image(pImg, 0, 0, pieceSize - 4, pieceSize - 4);

                // Border
                stroke(0, 0, 100, 40);
                strokeWeight(2);
                noFill();
                rect(-pieceSize / 2 + 2, -pieceSize / 2 + 2, pieceSize - 4, pieceSize - 4, 3);

                pop();
            }

            // Wobble when complete
            if (cycleTime > 5000 && cycleTime < 6500) {
                // Satisfaction glow
                const glowAlpha = sin((cycleTime - 5000) / 1500 * PI) * 30;
                fill(45, 50, 80, glowAlpha);
                noStroke();
                rect(offsetX - 10, offsetY - 10, totalSize + 20, totalSize + 20, 10);
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generatePuzzle();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
