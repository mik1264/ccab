<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chain Reaction - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        const NUM_ELEMENTS = 30;
        let elements = [];
        let triggerTime = 0;
        let reactionSpeed = 80; // ms between triggers
        let elementSize;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            initElements();
        }

        function initElements() {
            elements = [];
            elementSize = min(width, height) * 0.04;

            // Create a winding path of elements
            const path = createPath();

            for (let i = 0; i < path.length; i++) {
                elements.push({
                    x: path[i].x,
                    y: path[i].y,
                    baseX: path[i].x,
                    baseY: path[i].y,
                    triggered: false,
                    triggerTime: 0,
                    hue: map(i, 0, path.length - 1, 30, 330),
                    type: i % 3, // 0: ball, 1: domino, 2: spinner
                    angle: 0,
                    scale: 1
                });
            }

            triggerTime = millis();
        }

        function createPath() {
            const path = [];
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = min(width, height) * 0.35;

            // Spiral path
            for (let i = 0; i < NUM_ELEMENTS; i++) {
                const t = i / NUM_ELEMENTS;
                const angle = t * TWO_PI * 3; // 3 rotations
                const radius = maxRadius * (0.3 + t * 0.7);

                path.push({
                    x: centerX + cos(angle) * radius,
                    y: centerY + sin(angle) * radius
                });
            }

            return path;
        }

        function draw() {
            background(230, 30, 10);
            const time = millis();

            // Trigger elements in sequence
            for (let i = 0; i < elements.length; i++) {
                const e = elements[i];
                const shouldTrigger = time - triggerTime > i * reactionSpeed;

                if (shouldTrigger && !e.triggered) {
                    e.triggered = true;
                    e.triggerTime = time;
                }
            }

            // Reset when all triggered
            const lastElement = elements[elements.length - 1];
            if (lastElement.triggered && time - lastElement.triggerTime > 2000) {
                for (let e of elements) {
                    e.triggered = false;
                    e.angle = 0;
                    e.scale = 1;
                }
                triggerTime = time;
            }

            // Draw connections
            stroke(60, 30, 30);
            strokeWeight(2);
            for (let i = 0; i < elements.length - 1; i++) {
                line(elements[i].x, elements[i].y, elements[i + 1].x, elements[i + 1].y);
            }

            // Draw and animate elements
            for (let i = 0; i < elements.length; i++) {
                const e = elements[i];
                const timeSinceTrigger = e.triggered ? time - e.triggerTime : -1;

                push();
                translate(e.x, e.y);

                if (e.triggered) {
                    // Animation based on type
                    if (e.type === 0) {
                        // Ball - bounces then settles
                        const bounce = sin(timeSinceTrigger * 0.02) * exp(-timeSinceTrigger * 0.003);
                        e.scale = 1 + bounce * 0.5;
                    } else if (e.type === 1) {
                        // Domino - falls over
                        e.angle = min(timeSinceTrigger * 0.01, PI / 2);
                    } else {
                        // Spinner - rotates
                        e.angle = timeSinceTrigger * 0.01;
                    }
                }

                // Draw based on type
                if (e.type === 0) {
                    // Ball
                    const r = elementSize * e.scale;

                    // Glow
                    noStroke();
                    for (let g = r * 1.5; g > r; g -= 3) {
                        fill(e.hue, e.triggered ? 70 : 40, e.triggered ? 90 : 60, map(g, r * 1.5, r, 20, 0));
                        ellipse(0, 0, g * 2);
                    }

                    fill(e.hue, e.triggered ? 60 : 40, e.triggered ? 85 : 50);
                    stroke(e.hue, 50, e.triggered ? 70 : 40);
                    strokeWeight(2);
                    ellipse(0, 0, r * 2);
                } else if (e.type === 1) {
                    // Domino
                    rotate(e.angle);
                    noStroke();

                    // Glow when triggered
                    if (e.triggered) {
                        for (let g = elementSize * 1.5; g > elementSize; g -= 3) {
                            fill(e.hue, 60, 80, map(g, elementSize * 1.5, elementSize, 15, 0));
                            rect(-elementSize * 0.3, -elementSize, elementSize * 0.6, elementSize * 2, 3);
                        }
                    }

                    fill(e.hue, e.triggered ? 55 : 35, e.triggered ? 80 : 45);
                    stroke(e.hue, 45, e.triggered ? 65 : 35);
                    strokeWeight(1);
                    rect(-elementSize * 0.3, -elementSize, elementSize * 0.6, elementSize * 2, 3);

                    // Dots on domino
                    fill(e.hue, 30, e.triggered ? 100 : 70);
                    noStroke();
                    ellipse(0, -elementSize * 0.5, elementSize * 0.15);
                    ellipse(0, elementSize * 0.5, elementSize * 0.15);
                } else {
                    // Spinner
                    rotate(e.angle);
                    noStroke();

                    // Glow when triggered
                    if (e.triggered) {
                        for (let g = elementSize * 1.5; g > elementSize * 0.8; g -= 3) {
                            fill(e.hue, 60, 80, map(g, elementSize * 1.5, elementSize * 0.8, 15, 0));
                            ellipse(0, 0, g * 2);
                        }
                    }

                    fill(e.hue, e.triggered ? 55 : 35, e.triggered ? 80 : 45);
                    stroke(e.hue, 45, e.triggered ? 65 : 35);
                    strokeWeight(1);

                    // Four arms
                    for (let a = 0; a < 4; a++) {
                        push();
                        rotate(a * HALF_PI);
                        rect(-elementSize * 0.15, 0, elementSize * 0.3, elementSize * 0.8, 2);
                        pop();
                    }

                    // Center
                    ellipse(0, 0, elementSize * 0.4);
                }

                pop();
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initElements();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
