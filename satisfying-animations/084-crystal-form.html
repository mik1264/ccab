<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Form - Satisfying Animations - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(254, 250, 224, 0.9); color: #606C38; text-decoration: none; border-radius: 25px; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 14px; z-index: 1000; }
        .back-link:hover { background: #FEFAE0; transform: translateX(-5px); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);
        const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x404060, 0.5));
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(5, 10, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0x8888ff, 0.5);
        light2.position.set(-5, 5, -5);
        scene.add(light2);

        // Crystal material
        const crystalMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x88aaff,
            metalness: 0.1,
            roughness: 0.1,
            transmission: 0.8,
            thickness: 1.5,
            transparent: true,
            opacity: 0.9
        });

        // Create crystal lattice points
        const atoms = [];
        const bonds = [];
        const latticeSize = 3;
        const spacing = 1.2;

        // Create atoms (cubic lattice)
        for (let x = -latticeSize; x <= latticeSize; x++) {
            for (let y = -latticeSize; y <= latticeSize; y++) {
                for (let z = -latticeSize; z <= latticeSize; z++) {
                    // Skip some for visual interest
                    const dist = Math.sqrt(x * x + y * y + z * z);
                    if (dist > latticeSize + 0.5) continue;

                    const geo = new THREE.IcosahedronGeometry(0.15, 1);
                    const atom = new THREE.Mesh(geo, crystalMaterial.clone());

                    atom.userData = {
                        targetX: x * spacing,
                        targetY: y * spacing,
                        targetZ: z * spacing,
                        startX: (Math.random() - 0.5) * 15,
                        startY: (Math.random() - 0.5) * 15,
                        startZ: (Math.random() - 0.5) * 15,
                        delay: dist * 0.1,
                        scale: 0
                    };

                    atom.position.set(atom.userData.startX, atom.userData.startY, atom.userData.startZ);
                    scene.add(atom);
                    atoms.push(atom);
                }
            }
        }

        // Create bonds between nearby atoms
        const bondMaterial = new THREE.LineBasicMaterial({
            color: 0x6688cc,
            transparent: true,
            opacity: 0.5
        });

        for (let i = 0; i < atoms.length; i++) {
            for (let j = i + 1; j < atoms.length; j++) {
                const a1 = atoms[i].userData;
                const a2 = atoms[j].userData;
                const dist = Math.sqrt(
                    Math.pow(a1.targetX - a2.targetX, 2) +
                    Math.pow(a1.targetY - a2.targetY, 2) +
                    Math.pow(a1.targetZ - a2.targetZ, 2)
                );

                if (dist <= spacing * 1.1) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                    const line = new THREE.Line(geometry, bondMaterial.clone());
                    line.userData = { atom1: i, atom2: j };
                    scene.add(line);
                    bonds.push(line);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const t = performance.now() * 0.001;
            const cycleDuration = 10;
            const cycleTime = t % cycleDuration;

            let progress;
            if (cycleTime < 5) {
                progress = easeOutBack(cycleTime / 5);
            } else if (cycleTime < 7.5) {
                progress = 1;
            } else {
                progress = 1 - easeInOutCubic((cycleTime - 7.5) / 2.5);
            }

            // Update atoms
            for (const atom of atoms) {
                const d = atom.userData;
                const delayedProgress = Math.max(0, Math.min(1, (progress - d.delay) / (1 - d.delay)));

                atom.position.x = d.startX + (d.targetX - d.startX) * delayedProgress;
                atom.position.y = d.startY + (d.targetY - d.startY) * delayedProgress;
                atom.position.z = d.startZ + (d.targetZ - d.startZ) * delayedProgress;

                const scale = 0.3 + delayedProgress * 0.7;
                atom.scale.setScalar(scale);

                // Pulse when formed
                if (delayedProgress >= 1) {
                    const pulse = 1 + Math.sin(t * 3 + d.targetX + d.targetY) * 0.1;
                    atom.scale.setScalar(pulse);
                }
            }

            // Update bonds
            for (const bond of bonds) {
                const a1 = atoms[bond.userData.atom1];
                const a2 = atoms[bond.userData.atom2];

                const positions = bond.geometry.attributes.position.array;
                positions[0] = a1.position.x;
                positions[1] = a1.position.y;
                positions[2] = a1.position.z;
                positions[3] = a2.position.x;
                positions[4] = a2.position.y;
                positions[5] = a2.position.z;
                bond.geometry.attributes.position.needsUpdate = true;

                // Fade in with distance
                const dist = a1.position.distanceTo(a2.position);
                bond.material.opacity = Math.max(0, (spacing * 1.5 - dist) / spacing) * progress * 0.6;
            }

            // Rotate scene
            scene.rotation.y = t * 0.2;
            scene.rotation.x = Math.sin(t * 0.3) * 0.2;

            renderer.render(scene, camera);
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        animate();

        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
