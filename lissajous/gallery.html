<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20 Dynamic Visualizations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .viz-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        .viz-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        .viz-card h2 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
        }

        canvas, svg {
            display: block;
            width: 100%;
            height: 250px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .interactive-div {
            width: 100%;
            height: 250px;
            background: #f8f9fa;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ 20 Dynamic Visualizations</h1>

        <div class="grid">
            <!-- Visualization 1: Particle System -->
            <div class="viz-card">
                <h2>1. Particle System</h2>
                <canvas id="particles"></canvas>
            </div>

            <!-- Visualization 2: Sine Wave -->
            <div class="viz-card">
                <h2>2. Animated Sine Waves</h2>
                <canvas id="waves"></canvas>
            </div>

            <!-- Visualization 3: Spiral -->
            <div class="viz-card">
                <h2>3. Rainbow Spiral</h2>
                <canvas id="spiral"></canvas>
            </div>

            <!-- Visualization 4: Clock -->
            <div class="viz-card">
                <h2>4. Analog Clock</h2>
                <canvas id="clock"></canvas>
            </div>

            <!-- Visualization 5: Bouncing Balls -->
            <div class="viz-card">
                <h2>5. Bouncing Balls</h2>
                <canvas id="balls"></canvas>
            </div>

            <!-- Visualization 6: Fractal Tree -->
            <div class="viz-card">
                <h2>6. Fractal Tree</h2>
                <canvas id="tree"></canvas>
            </div>

            <!-- Visualization 7: Matrix Rain -->
            <div class="viz-card">
                <h2>7. Matrix Rain</h2>
                <canvas id="matrix"></canvas>
            </div>

            <!-- Visualization 8: Audio Bars -->
            <div class="viz-card">
                <h2>8. Audio Visualizer Bars</h2>
                <canvas id="audio"></canvas>
            </div>

            <!-- Visualization 9: Starfield -->
            <div class="viz-card">
                <h2>9. Starfield Warp</h2>
                <canvas id="stars"></canvas>
            </div>

            <!-- Visualization 10: DNA Helix -->
            <div class="viz-card">
                <h2>10. DNA Helix</h2>
                <canvas id="dna"></canvas>
            </div>

            <!-- Visualization 11: Fireworks -->
            <div class="viz-card">
                <h2>11. Fireworks</h2>
                <canvas id="fireworks"></canvas>
            </div>

            <!-- Visualization 12: Network Graph -->
            <div class="viz-card">
                <h2>12. Network Graph</h2>
                <canvas id="network"></canvas>
            </div>

            <!-- Visualization 13: Ripple Effect -->
            <div class="viz-card">
                <h2>13. Ripple Effect</h2>
                <canvas id="ripple"></canvas>
            </div>

            <!-- Visualization 14: Pendulum -->
            <div class="viz-card">
                <h2>14. Double Pendulum</h2>
                <canvas id="pendulum"></canvas>
            </div>

            <!-- Visualization 15: Conway's Game of Life -->
            <div class="viz-card">
                <h2>15. Game of Life</h2>
                <canvas id="life"></canvas>
            </div>

            <!-- Visualization 16: 3D Cube -->
            <div class="viz-card">
                <h2>16. Rotating 3D Cube</h2>
                <canvas id="cube"></canvas>
            </div>

            <!-- Visualization 17: Lissajous Curve -->
            <div class="viz-card">
                <h2>17. Lissajous Curve</h2>
                <canvas id="lissajous"></canvas>
            </div>

            <!-- Visualization 18: Metaballs -->
            <div class="viz-card">
                <h2>18. Metaballs</h2>
                <canvas id="metaballs"></canvas>
            </div>

            <!-- Visualization 19: Sierpinski Triangle -->
            <div class="viz-card">
                <h2>19. Sierpinski Triangle</h2>
                <canvas id="sierpinski"></canvas>
            </div>

            <!-- Visualization 20: Perlin Noise Flow Field -->
            <div class="viz-card">
                <h2>20. Flow Field</h2>
                <canvas id="flowfield"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Utility function to setup canvas
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            return { canvas, ctx };
        }

        // 1. PARTICLE SYSTEM
        (function() {
            const { canvas, ctx } = setupCanvas('particles');
            const particles = [];
            const particleCount = 50;

            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.radius = Math.random() * 3 + 1;
                    this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach(p => {
                    p.update();
                    p.draw();
                });

                // Draw connections
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            ctx.strokeStyle = `rgba(100, 100, 100, ${1 - dist / 100})`;
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                        }
                    }
                }

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 2. SINE WAVES
        (function() {
            const { canvas, ctx } = setupCanvas('waves');
            let offset = 0;

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let wave = 0; wave < 3; wave++) {
                    ctx.beginPath();
                    ctx.strokeStyle = `hsl(${wave * 120}, 70%, 60%)`;
                    ctx.lineWidth = 2;

                    for (let x = 0; x < canvas.width; x++) {
                        const y = canvas.height / 2 + Math.sin(x * 0.02 + offset + wave) * 50;
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                offset += 0.05;
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 3. RAINBOW SPIRAL
        (function() {
            const { canvas, ctx } = setupCanvas('spiral');
            let angle = 0;

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);

                for (let i = 0; i < 200; i++) {
                    const radius = i * 0.5;
                    const x = Math.cos(angle + i * 0.1) * radius;
                    const y = Math.sin(angle + i * 0.1) * radius;

                    ctx.fillStyle = `hsl(${i * 2 + angle * 50}, 70%, 60%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
                angle += 0.02;
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 4. ANALOG CLOCK
        (function() {
            const { canvas, ctx } = setupCanvas('clock');

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const now = new Date();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 10;

                // Clock face
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Hour marks
                for (let i = 0; i < 12; i++) {
                    const angle = (i * 30 - 90) * Math.PI / 180;
                    const x1 = centerX + Math.cos(angle) * radius * 0.9;
                    const y1 = centerY + Math.sin(angle) * radius * 0.9;
                    const x2 = centerX + Math.cos(angle) * radius;
                    const y2 = centerY + Math.sin(angle) * radius;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Hour hand
                const hours = now.getHours() % 12;
                const hourAngle = ((hours * 30 + now.getMinutes() * 0.5) - 90) * Math.PI / 180;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(hourAngle) * radius * 0.5, centerY + Math.sin(hourAngle) * radius * 0.5);
                ctx.stroke();

                // Minute hand
                const minuteAngle = ((now.getMinutes() * 6) - 90) * Math.PI / 180;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(minuteAngle) * radius * 0.7, centerY + Math.sin(minuteAngle) * radius * 0.7);
                ctx.stroke();

                // Second hand
                const secondAngle = ((now.getSeconds() * 6) - 90) * Math.PI / 180;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(secondAngle) * radius * 0.8, centerY + Math.sin(secondAngle) * radius * 0.8);
                ctx.stroke();

                // Center dot
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fill();

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 5. BOUNCING BALLS
        (function() {
            const { canvas, ctx } = setupCanvas('balls');
            const balls = [];

            class Ball {
                constructor() {
                    this.radius = Math.random() * 15 + 10;
                    this.x = this.radius + Math.random() * (canvas.width - this.radius * 2);
                    this.y = this.radius + Math.random() * (canvas.height - this.radius * 2);
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = (Math.random() - 0.5) * 4;
                    this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                        this.vx *= -1;
                        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                    }
                    if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                        this.vy *= -1;
                        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                    }
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (let i = 0; i < 10; i++) {
                balls.push(new Ball());
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                balls.forEach(ball => {
                    ball.update();
                    ball.draw();
                });
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 6. FRACTAL TREE
        (function() {
            const { canvas, ctx } = setupCanvas('tree');
            let angle = 0;

            function drawBranch(x, y, length, angle, depth) {
                if (depth === 0) return;

                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;

                ctx.strokeStyle = `hsl(${120 - depth * 10}, 70%, ${40 + depth * 5}%)`;
                ctx.lineWidth = depth;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                drawBranch(endX, endY, length * 0.7, angle - 0.4, depth - 1);
                drawBranch(endX, endY, length * 0.7, angle + 0.4, depth - 1);
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBranch(canvas.width / 2, canvas.height, 60, -Math.PI / 2 + Math.sin(angle) * 0.2, 10);
                angle += 0.01;
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 7. MATRIX RAIN
        (function() {
            const { canvas, ctx } = setupCanvas('matrix');
            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*';

            function animate() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#0F0';
                ctx.font = fontSize + 'px monospace';

                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }

                setTimeout(() => requestAnimationFrame(animate), 50);
            }
            animate();
        })();

        // 8. AUDIO VISUALIZER BARS
        (function() {
            const { canvas, ctx } = setupCanvas('audio');
            const bars = 32;
            const barWidth = canvas.width / bars;
            const barHeights = Array(bars).fill(0).map(() => Math.random());

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < bars; i++) {
                    barHeights[i] += (Math.random() - 0.5) * 0.1;
                    barHeights[i] = Math.max(0.1, Math.min(1, barHeights[i]));

                    const height = barHeights[i] * canvas.height;
                    const gradient = ctx.createLinearGradient(0, canvas.height - height, 0, canvas.height);
                    gradient.addColorStop(0, `hsl(${i * 360 / bars}, 70%, 60%)`);
                    gradient.addColorStop(1, `hsl(${i * 360 / bars}, 70%, 40%)`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(i * barWidth + 1, canvas.height - height, barWidth - 2, height);
                }

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 9. STARFIELD WARP
        (function() {
            const { canvas, ctx } = setupCanvas('stars');
            const stars = [];
            const numStars = 200;

            class Star {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = (Math.random() - 0.5) * canvas.width;
                    this.y = (Math.random() - 0.5) * canvas.height;
                    this.z = canvas.width;
                }

                update() {
                    this.z -= 5;
                    if (this.z <= 0) this.reset();
                }

                draw() {
                    const x = (this.x / this.z) * canvas.width + canvas.width / 2;
                    const y = (this.y / this.z) * canvas.height + canvas.height / 2;
                    const size = (1 - this.z / canvas.width) * 3;

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (let i = 0; i < numStars; i++) {
                stars.push(new Star());
            }

            function animate() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                stars.forEach(star => {
                    star.update();
                    star.draw();
                });

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 10. DNA HELIX
        (function() {
            const { canvas, ctx } = setupCanvas('dna');
            let offset = 0;

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const numPoints = 50;
                for (let i = 0; i < numPoints; i++) {
                    const y = (i / numPoints) * canvas.height;
                    const angle1 = (i * 0.3 + offset);
                    const angle2 = angle1 + Math.PI;

                    const x1 = canvas.width / 2 + Math.cos(angle1) * 80;
                    const x2 = canvas.width / 2 + Math.cos(angle2) * 80;

                    // Strands
                    ctx.fillStyle = '#4A90E2';
                    ctx.beginPath();
                    ctx.arc(x1, y, 5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#E24A90';
                    ctx.beginPath();
                    ctx.arc(x2, y, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Connections
                    if (i % 3 === 0) {
                        ctx.strokeStyle = `rgba(100, 100, 100, 0.5)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x1, y);
                        ctx.lineTo(x2, y);
                        ctx.stroke();
                    }
                }

                offset += 0.05;
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 11. FIREWORKS
        (function() {
            const { canvas, ctx } = setupCanvas('fireworks');
            const fireworks = [];

            class Firework {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height;
                    this.targetY = Math.random() * canvas.height / 2;
                    this.speed = 5;
                    this.particles = [];
                    this.exploded = false;
                    this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                }

                update() {
                    if (!this.exploded) {
                        this.y -= this.speed;
                        if (this.y <= this.targetY) {
                            this.explode();
                        }
                    } else {
                        this.particles.forEach(p => p.update());
                        this.particles = this.particles.filter(p => p.life > 0);
                    }
                }

                explode() {
                    this.exploded = true;
                    for (let i = 0; i < 30; i++) {
                        const angle = (Math.PI * 2 * i) / 30;
                        this.particles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * (Math.random() * 3 + 2),
                            vy: Math.sin(angle) * (Math.random() * 3 + 2),
                            life: 100,
                            color: this.color
                        });
                    }
                }

                draw() {
                    if (!this.exploded) {
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        this.particles.forEach(p => {
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = p.life / 100;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        });
                    }
                }
            }

            Firework.prototype.particles.forEach = function(callback) {
                for (let i = 0; i < this.length; i++) {
                    this[i].update = function() {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.vy += 0.1;
                        this.life -= 2;
                    };
                    callback(this[i]);
                }
            };

            function animate() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (Math.random() < 0.03) {
                    fireworks.push(new Firework());
                }

                fireworks.forEach((fw, index) => {
                    fw.update();
                    fw.draw();
                    if (fw.exploded && fw.particles.length === 0) {
                        fireworks.splice(index, 1);
                    }
                });

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 12. NETWORK GRAPH
        (function() {
            const { canvas, ctx } = setupCanvas('network');
            const nodes = [];
            const numNodes = 20;

            class Node {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = (Math.random() - 0.5) * 1;
                    this.radius = 5;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                }

                draw() {
                    ctx.fillStyle = '#4A90E2';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (let i = 0; i < numNodes; i++) {
                nodes.push(new Node());
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw connections
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[i].x - nodes[j].x;
                        const dy = nodes[i].y - nodes[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 120) {
                            ctx.strokeStyle = `rgba(74, 144, 226, ${1 - dist / 120})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            ctx.stroke();
                        }
                    }
                }

                // Update and draw nodes
                nodes.forEach(node => {
                    node.update();
                    node.draw();
                });

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 13. RIPPLE EFFECT
        (function() {
            const { canvas, ctx } = setupCanvas('ripple');
            const ripples = [];

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                ripples.push({
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    radius: 0,
                    maxRadius: 100,
                    alpha: 1
                });
            });

            // Auto-generate ripples
            setInterval(() => {
                ripples.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 0,
                    maxRadius: 80,
                    alpha: 1
                });
            }, 1000);

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ripples.forEach((ripple, index) => {
                    ripple.radius += 2;
                    ripple.alpha -= 0.02;

                    ctx.strokeStyle = `rgba(74, 144, 226, ${ripple.alpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    if (ripple.alpha <= 0) {
                        ripples.splice(index, 1);
                    }
                });

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 14. DOUBLE PENDULUM
        (function() {
            const { canvas, ctx } = setupCanvas('pendulum');
            let angle1 = Math.PI / 2;
            let angle2 = Math.PI / 2;
            let angleV1 = 0;
            let angleV2 = 0;
            const length1 = 80;
            const length2 = 80;
            const mass1 = 10;
            const mass2 = 10;
            const gravity = 0.5;
            const trail = [];

            function animate() {
                // Physics calculations
                let num1 = -gravity * (2 * mass1 + mass2) * Math.sin(angle1);
                let num2 = -mass2 * gravity * Math.sin(angle1 - 2 * angle2);
                let num3 = -2 * Math.sin(angle1 - angle2) * mass2;
                let num4 = angleV2 * angleV2 * length2 + angleV1 * angleV1 * length1 * Math.cos(angle1 - angle2);
                let den = length1 * (2 * mass1 + mass2 - mass2 * Math.cos(2 * angle1 - 2 * angle2));
                let angleA1 = (num1 + num2 + num3 * num4) / den;

                num1 = 2 * Math.sin(angle1 - angle2);
                num2 = angleV1 * angleV1 * length1 * (mass1 + mass2);
                num3 = gravity * (mass1 + mass2) * Math.cos(angle1);
                num4 = angleV2 * angleV2 * length2 * mass2 * Math.cos(angle1 - angle2);
                den = length2 * (2 * mass1 + mass2 - mass2 * Math.cos(2 * angle1 - 2 * angle2));
                let angleA2 = (num1 * (num2 + num3 + num4)) / den;

                angleV1 += angleA1;
                angleV2 += angleA2;
                angle1 += angleV1;
                angle2 += angleV2;

                angleV1 *= 0.999;
                angleV2 *= 0.999;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const originX = canvas.width / 2;
                const originY = 80;

                const x1 = originX + length1 * Math.sin(angle1);
                const y1 = originY + length1 * Math.cos(angle1);
                const x2 = x1 + length2 * Math.sin(angle2);
                const y2 = y1 + length2 * Math.cos(angle2);

                // Trail
                trail.push({ x: x2, y: y2 });
                if (trail.length > 50) trail.shift();

                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                trail.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();

                // Rods
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(originX, originY);
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Bobs
                ctx.fillStyle = '#4A90E2';
                ctx.beginPath();
                ctx.arc(x1, y1, mass1, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#E24A90';
                ctx.beginPath();
                ctx.arc(x2, y2, mass2, 0, Math.PI * 2);
                ctx.fill();

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 15. CONWAY'S GAME OF LIFE
        (function() {
            const { canvas, ctx } = setupCanvas('life');
            const resolution = 10;
            const cols = Math.floor(canvas.width / resolution);
            const rows = Math.floor(canvas.height / resolution);

            function makeGrid() {
                const grid = new Array(cols);
                for (let i = 0; i < cols; i++) {
                    grid[i] = new Array(rows);
                    for (let j = 0; j < rows; j++) {
                        grid[i][j] = Math.random() > 0.7 ? 1 : 0;
                    }
                }
                return grid;
            }

            let grid = makeGrid();

            function countNeighbors(grid, x, y) {
                let sum = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const col = (x + i + cols) % cols;
                        const row = (y + j + rows) % rows;
                        sum += grid[col][row];
                    }
                }
                sum -= grid[x][y];
                return sum;
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const x = i * resolution;
                        const y = j * resolution;
                        if (grid[i][j] === 1) {
                            ctx.fillStyle = '#4A90E2';
                            ctx.fillRect(x, y, resolution - 1, resolution - 1);
                        }
                    }
                }

                // Update grid
                const next = makeGrid();
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const state = grid[i][j];
                        const neighbors = countNeighbors(grid, i, j);

                        if (state === 0 && neighbors === 3) {
                            next[i][j] = 1;
                        } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
                            next[i][j] = 0;
                        } else {
                            next[i][j] = state;
                        }
                    }
                }
                grid = next;

                setTimeout(() => requestAnimationFrame(animate), 100);
            }
            animate();
        })();

        // 16. ROTATING 3D CUBE
        (function() {
            const { canvas, ctx } = setupCanvas('cube');
            let angleX = 0, angleY = 0, angleZ = 0;

            const vertices = [
                [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
            ];

            const edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            function rotateX(point, angle) {
                const [x, y, z] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x, y * cos - z * sin, y * sin + z * cos];
            }

            function rotateY(point, angle) {
                const [x, y, z] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x * cos + z * sin, y, -x * sin + z * cos];
            }

            function rotateZ(point, angle) {
                const [x, y, z] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x * cos - y * sin, x * sin + y * cos, z];
            }

            function project(point) {
                const scale = 50;
                const distance = 3;
                const z = point[2] + distance;
                const factor = 200 / z;
                return [
                    point[0] * factor * scale + canvas.width / 2,
                    point[1] * factor * scale + canvas.height / 2
                ];
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const rotated = vertices.map(v => {
                    let point = rotateX(v, angleX);
                    point = rotateY(point, angleY);
                    point = rotateZ(point, angleZ);
                    return point;
                });

                const projected = rotated.map(project);

                ctx.strokeStyle = '#4A90E2';
                ctx.lineWidth = 2;
                edges.forEach(edge => {
                    const [i, j] = edge;
                    ctx.beginPath();
                    ctx.moveTo(projected[i][0], projected[i][1]);
                    ctx.lineTo(projected[j][0], projected[j][1]);
                    ctx.stroke();
                });

                ctx.fillStyle = '#E24A90';
                projected.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                angleX += 0.01;
                angleY += 0.01;
                angleZ += 0.01;

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 17. LISSAJOUS CURVE
        (function() {
            const { canvas, ctx } = setupCanvas('lissajous');
            let t = 0;
            const trail = [];
            const a = 3, b = 2;

            function animate() {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const x = canvas.width / 2 + Math.sin(a * t) * 100;
                const y = canvas.height / 2 + Math.sin(b * t + Math.PI / 2) * 100;

                trail.push({ x, y });
                if (trail.length > 500) trail.shift();

                ctx.strokeStyle = '#4A90E2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                trail.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();

                ctx.fillStyle = '#E24A90';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();

                t += 0.02;
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 18. METABALLS
        (function() {
            const { canvas, ctx } = setupCanvas('metaballs');
            const balls = [];
            const numBalls = 5;

            class MetaBall {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.r = Math.random() * 30 + 20;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                }
            }

            for (let i = 0; i < numBalls; i++) {
                balls.push(new MetaBall());
            }

            function animate() {
                const imageData = ctx.createImageData(canvas.width, canvas.height);

                for (let x = 0; x < canvas.width; x += 2) {
                    for (let y = 0; y < canvas.height; y += 2) {
                        let sum = 0;
                        balls.forEach(ball => {
                            const dx = x - ball.x;
                            const dy = y - ball.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            sum += (ball.r * ball.r) / (dist * dist);
                        });

                        if (sum > 1) {
                            const index = (y * canvas.width + x) * 4;
                            imageData.data[index] = 74;
                            imageData.data[index + 1] = 144;
                            imageData.data[index + 2] = 226;
                            imageData.data[index + 3] = 255;
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);

                balls.forEach(ball => ball.update());
                requestAnimationFrame(animate);
            }
            animate();
        })();

        // 19. SIERPINSKI TRIANGLE
        (function() {
            const { canvas, ctx } = setupCanvas('sierpinski');
            let points = [];
            let currentPoint = { x: canvas.width / 2, y: canvas.height / 2 };

            const vertices = [
                { x: canvas.width / 2, y: 20 },
                { x: 20, y: canvas.height - 20 },
                { x: canvas.width - 20, y: canvas.height - 20 }
            ];

            let iteration = 0;

            function animate() {
                for (let i = 0; i < 100; i++) {
                    const target = vertices[Math.floor(Math.random() * 3)];
                    currentPoint = {
                        x: (currentPoint.x + target.x) / 2,
                        y: (currentPoint.y + target.y) / 2
                    };

                    const hue = (iteration / 100) % 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    ctx.fillRect(currentPoint.x, currentPoint.y, 1, 1);
                    iteration++;
                }

                requestAnimationFrame(animate);
            }

            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            animate();
        })();

        // 20. FLOW FIELD
        (function() {
            const { canvas, ctx } = setupCanvas('flowfield');
            const particles = [];
            const numParticles = 500;
            let time = 0;

            class FlowParticle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.prevX = this.x;
                    this.prevY = this.y;
                    this.life = Math.random() * 100;
                }

                update() {
                    this.prevX = this.x;
                    this.prevY = this.y;

                    const angle = Math.sin(this.x * 0.01 + time) * Math.cos(this.y * 0.01 + time) * Math.PI * 2;
                    this.x += Math.cos(angle) * 2;
                    this.y += Math.sin(angle) * 2;

                    this.life--;
                    if (this.life <= 0 || this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                        this.reset();
                    }
                }

                draw() {
                    ctx.strokeStyle = `hsla(${(this.x + this.y) * 0.5}, 70%, 60%, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.prevX, this.prevY);
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                }
            }

            for (let i = 0; i < numParticles; i++) {
                particles.push(new FlowParticle());
            }

            function animate() {
                ctx.fillStyle = 'rgba(248, 249, 250, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                particles.forEach(p => {
                    p.update();
                    p.draw();
                });

                time += 0.01;
                requestAnimationFrame(animate);
            }
            animate();
        })();
    </script>
</body>
</html>
