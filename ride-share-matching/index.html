<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ride-Share Matching Algorithm</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 18px; font-family: sans-serif; z-index: 999; text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 999; }
.panel { background: rgba(0,0,0,0.75); color: #e0e0e0; padding: 12px 16px; border-radius: 8px; font-size: 13px; min-width: 210px; }
.panel label { display: block; margin: 6px 0 2px; color: #fbbf24; }
.panel input[type=range] { width: 100%; }
.panel button { background: #fbbf24; color: #0a0e1a; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 6px; width: 100%; }
.panel button:hover { background: #f59e0b; }
#stats { color: #aaa; margin-top: 8px; line-height: 1.6; }
.legend { margin-top: 8px; }
.legend-item { display: flex; align-items: center; gap: 6px; margin: 3px 0; font-size: 11px; }
.legend-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Ride-Share Matching Algorithm</div>
<div id="ui">
    <div class="panel">
        <label>Drivers: <span id="drVal">15</span></label>
        <input type="range" id="driverCount" min="5" max="40" value="15">
        <label>Rider Spawn Rate: <span id="rsVal">4</span></label>
        <input type="range" id="riderSpawn" min="1" max="10" value="4">
        <label>Driver Speed: <span id="dspVal">3</span></label>
        <input type="range" id="driverSpeed" min="1" max="8" value="3">
        <button id="resetBtn">Reset</button>
        <div class="legend">
            <div class="legend-item"><span class="legend-dot" style="background:#60a5fa;"></span> Available Driver</div>
            <div class="legend-item"><span class="legend-dot" style="background:#22c55e;"></span> Picking Up</div>
            <div class="legend-item"><span class="legend-dot" style="background:#f87171;"></span> Waiting Rider</div>
            <div class="legend-item"><span class="legend-dot" style="background:#fbbf24;"></span> In Transit</div>
        </div>
        <div id="stats"></div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;

    let driverCount = 15;
    let riderSpawnRate = 4;
    let driverSpeed = 3;
    let drivers = [];
    let riders = [];
    let frame = 0;
    let totalTrips = 0;
    let totalWaitTime = 0;
    let totalTripDist = 0;
    let matchLines = [];

    document.getElementById('driverCount').addEventListener('input', function() {
        driverCount = parseInt(this.value);
        document.getElementById('drVal').textContent = driverCount;
    });
    document.getElementById('riderSpawn').addEventListener('input', function() {
        riderSpawnRate = parseInt(this.value);
        document.getElementById('rsVal').textContent = riderSpawnRate;
    });
    document.getElementById('driverSpeed').addEventListener('input', function() {
        driverSpeed = parseInt(this.value);
        document.getElementById('dspVal').textContent = driverSpeed;
    });
    document.getElementById('resetBtn').addEventListener('click', init);

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
    }

    function dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function init() {
        resize();
        drivers = [];
        riders = [];
        matchLines = [];
        frame = 0;
        totalTrips = 0;
        totalWaitTime = 0;
        totalTripDist = 0;

        const margin = 80;
        for (let i = 0; i < driverCount; i++) {
            drivers.push({
                x: margin + Math.random() * (W - margin * 2),
                y: margin + Math.random() * (H - margin * 2),
                vx: 0, vy: 0,
                state: 'available', // available, picking_up, in_transit
                rider: null,
                destX: 0, destY: 0,
                tripDist: 0
            });
        }
    }

    function spawnRider() {
        const margin = 60;
        // Riders cluster in "hotspot" areas
        const hotspots = [
            { x: W * 0.3, y: H * 0.3 },
            { x: W * 0.7, y: H * 0.3 },
            { x: W * 0.5, y: H * 0.6 },
            { x: W * 0.2, y: H * 0.7 },
            { x: W * 0.8, y: H * 0.7 }
        ];
        const spot = hotspots[Math.floor(Math.random() * hotspots.length)];
        const spread = 100;

        riders.push({
            x: Math.max(margin, Math.min(W - margin, spot.x + (Math.random() - 0.5) * spread)),
            y: Math.max(margin, Math.min(H - margin, spot.y + (Math.random() - 0.5) * spread)),
            destX: margin + Math.random() * (W - margin * 2),
            destY: margin + Math.random() * (H - margin * 2),
            spawnFrame: frame,
            matched: false,
            pulse: 0
        });
    }

    function matchRiders() {
        // Greedy nearest-first matching
        const availableDrivers = drivers.filter(d => d.state === 'available');
        const unmatchedRiders = riders.filter(r => !r.matched);

        for (const rider of unmatchedRiders) {
            let bestDriver = null;
            let bestDist = Infinity;

            for (const driver of availableDrivers) {
                const d = dist(driver, rider);
                if (d < bestDist) {
                    bestDist = d;
                    bestDriver = driver;
                }
            }

            if (bestDriver) {
                bestDriver.state = 'picking_up';
                bestDriver.rider = rider;
                bestDriver.destX = rider.x;
                bestDriver.destY = rider.y;
                rider.matched = true;

                // Visual match line
                matchLines.push({
                    x1: bestDriver.x, y1: bestDriver.y,
                    x2: rider.x, y2: rider.y,
                    alpha: 1
                });

                // Remove from available list
                const idx = availableDrivers.indexOf(bestDriver);
                if (idx >= 0) availableDrivers.splice(idx, 1);
            }
        }
    }

    function moveToward(obj, tx, ty, speed) {
        const dx = tx - obj.x;
        const dy = ty - obj.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < speed) {
            obj.x = tx;
            obj.y = ty;
            return true;
        }
        obj.x += (dx / d) * speed;
        obj.y += (dy / d) * speed;
        obj.tripDist = (obj.tripDist || 0) + speed;
        return false;
    }

    function update() {
        frame++;

        // Spawn riders
        if (frame % Math.max(1, Math.floor(60 / riderSpawnRate)) === 0) {
            spawnRider();
        }

        // Ensure right number of drivers
        while (drivers.length < driverCount) {
            drivers.push({
                x: 50 + Math.random() * (W - 100),
                y: 50 + Math.random() * (H - 100),
                vx: 0, vy: 0, state: 'available', rider: null,
                destX: 0, destY: 0, tripDist: 0
            });
        }

        // Match unmatched riders
        if (frame % 30 === 0) {
            matchRiders();
        }

        // Update drivers
        for (const driver of drivers) {
            if (driver.state === 'picking_up') {
                const arrived = moveToward(driver, driver.destX, driver.destY, driverSpeed);
                if (arrived && driver.rider) {
                    // Pick up rider
                    driver.state = 'in_transit';
                    driver.destX = driver.rider.destX;
                    driver.destY = driver.rider.destY;
                    totalWaitTime += frame - driver.rider.spawnFrame;
                }
            } else if (driver.state === 'in_transit') {
                if (driver.rider) {
                    driver.rider.x = driver.x;
                    driver.rider.y = driver.y;
                }
                const arrived = moveToward(driver, driver.destX, driver.destY, driverSpeed);
                if (arrived) {
                    // Drop off
                    if (driver.rider) {
                        const idx = riders.indexOf(driver.rider);
                        if (idx >= 0) riders.splice(idx, 1);
                    }
                    totalTrips++;
                    totalTripDist += driver.tripDist;
                    driver.state = 'available';
                    driver.rider = null;
                    driver.tripDist = 0;
                }
            } else {
                // Idle wander
                driver.x += (Math.random() - 0.5) * 1.5;
                driver.y += (Math.random() - 0.5) * 1.5;
                driver.x = Math.max(20, Math.min(W - 20, driver.x));
                driver.y = Math.max(20, Math.min(H - 20, driver.y));
            }
        }

        // Fade match lines
        matchLines = matchLines.filter(l => {
            l.alpha -= 0.015;
            return l.alpha > 0;
        });

        // Rider pulse
        for (const r of riders) {
            r.pulse = (r.pulse + 0.05) % (Math.PI * 2);
        }

        // Remove very old unmatched riders
        riders = riders.filter(r => r.matched || frame - r.spawnFrame < 600);
    }

    function drawCity() {
        // Subtle city grid
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = 1;
        const gridSize = 60;
        for (let x = 0; x < W; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
        }
        for (let y = 0; y < H; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
        }

        // "Buildings" as subtle blocks
        ctx.fillStyle = 'rgba(30, 41, 59, 0.3)';
        for (let x = gridSize; x < W - gridSize; x += gridSize) {
            for (let y = gridSize; y < H - gridSize; y += gridSize) {
                if (Math.sin(x * 0.01 + y * 0.02) > 0.3) {
                    const sz = 15 + Math.sin(x * 0.03) * 10;
                    ctx.fillRect(x - sz / 2, y - sz / 2, sz, sz);
                }
            }
        }
    }

    function draw() {
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, W, H);

        drawCity();

        // Draw match lines
        for (const line of matchLines) {
            ctx.strokeStyle = `rgba(251, 191, 36, ${line.alpha * 0.5})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(line.x1, line.y1);
            ctx.lineTo(line.x2, line.y2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw trip paths (driver to destination)
        for (const d of drivers) {
            if (d.state === 'in_transit') {
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 6]);
                ctx.beginPath();
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.destX, d.destY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Destination marker
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(d.destX, d.destY, 6, 0, Math.PI * 2);
                ctx.stroke();
            } else if (d.state === 'picking_up') {
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 6]);
                ctx.beginPath();
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.destX, d.destY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Draw waiting riders
        for (const r of riders) {
            if (r.matched && drivers.some(d => d.rider === r && d.state === 'in_transit')) continue;

            const pulseR = 8 + Math.sin(r.pulse) * 3;
            // Pulse ring
            ctx.strokeStyle = r.matched ? 'rgba(34,197,94,0.3)' : 'rgba(248,113,113,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(r.x, r.y, pulseR, 0, Math.PI * 2);
            ctx.stroke();

            // Rider dot
            ctx.fillStyle = r.matched ? '#22c55e' : '#f87171';
            ctx.shadowColor = r.matched ? '#22c55e' : '#f87171';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(r.x, r.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Wait time indicator
            if (!r.matched) {
                const wait = frame - r.spawnFrame;
                if (wait > 120) {
                    ctx.fillStyle = 'rgba(248,113,113,0.6)';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.floor(wait / 60) + 's', r.x, r.y - 10);
                }
            }
        }

        // Draw drivers
        for (const d of drivers) {
            let color, glowColor;
            if (d.state === 'available') {
                color = '#60a5fa'; glowColor = '#60a5fa';
            } else if (d.state === 'picking_up') {
                color = '#22c55e'; glowColor = '#22c55e';
            } else {
                color = '#fbbf24'; glowColor = '#fbbf24';
            }

            // Glow
            ctx.fillStyle = glowColor.replace(')', ',0.15)').replace('rgb', 'rgba').replace('#', '');
            const grad = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, 15);
            grad.addColorStop(0, color + '33');
            grad.addColorStop(1, color + '00');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(d.x, d.y, 15, 0, Math.PI * 2);
            ctx.fill();

            // Car shape
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(d.x, d.y, 5, 0, Math.PI * 2);
            ctx.fill();

            // Direction arrow if moving
            if (d.state !== 'available') {
                const dx = d.destX - d.x;
                const dy = d.destY - d.y;
                const dd = Math.sqrt(dx * dx + dy * dy);
                if (dd > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(d.x, d.y);
                    ctx.lineTo(d.x + (dx / dd) * 10, d.y + (dy / dd) * 10);
                    ctx.stroke();
                }
            }
        }

        // Stats
        const available = drivers.filter(d => d.state === 'available').length;
        const picking = drivers.filter(d => d.state === 'picking_up').length;
        const transit = drivers.filter(d => d.state === 'in_transit').length;
        const waiting = riders.filter(r => !r.matched).length;
        const avgWait = totalTrips > 0 ? (totalWaitTime / totalTrips / 60).toFixed(1) : '0.0';
        const utilization = drivers.length > 0 ? ((1 - available / drivers.length) * 100).toFixed(0) : '0';

        document.getElementById('stats').innerHTML =
            `Drivers: ${available} free / ${picking} pickup / ${transit} transit<br>` +
            `Riders Waiting: ${waiting}<br>` +
            `Trips Completed: ${totalTrips}<br>` +
            `Avg Wait: ${avgWait}s<br>` +
            `Utilization: ${utilization}%`;
    }

    window.addEventListener('resize', resize);

    function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
    }

    init();
    animate();
})();
</script>
</body>
</html>
