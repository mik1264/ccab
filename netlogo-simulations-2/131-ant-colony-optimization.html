<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Colony Optimization - TSP Solver</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #1a1a2e; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; font-family: inherit; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .history-chart { height: 80px; background: #1a1a2e; border-radius: 6px; margin-top: 10px; padding: 5px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Ant Colony Optimization</h1>
            <p class="subtitle">Solving the Traveling Salesman Problem with pheromone trails</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Problem</label>
                    <select id="problem">
                        <option value="random">Random Cities</option>
                        <option value="circle">Circle</option>
                        <option value="grid">Grid</option>
                        <option value="cluster">Clusters</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Number of Cities</label>
                    <input type="range" id="numCities" min="5" max="50" value="20">
                    <div class="control-value"><span id="numCitiesVal">20</span></div>
                </div>
                <div class="control-group">
                    <label>Number of Ants</label>
                    <input type="range" id="numAnts" min="5" max="50" value="20">
                    <div class="control-value"><span id="numAntsVal">20</span></div>
                </div>
                <div class="control-group">
                    <label>Pheromone Importance (α)</label>
                    <input type="range" id="alpha" min="0" max="50" value="10">
                    <div class="control-value"><span id="alphaVal">1.0</span></div>
                </div>
                <div class="control-group">
                    <label>Distance Importance (β)</label>
                    <input type="range" id="beta" min="0" max="50" value="20">
                    <div class="control-value"><span id="betaVal">2.0</span></div>
                </div>
                <div class="control-group">
                    <label>Evaporation Rate</label>
                    <input type="range" id="evaporation" min="1" max="50" value="10">
                    <div class="control-value"><span id="evaporationVal">10</span>%</div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">New Problem</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="iteration">0</div><div class="stat-label">Iteration</div></div>
                    <div class="stat-box"><div class="stat-value" id="bestLength">∞</div><div class="stat-label">Best Tour</div></div>
                    <div class="stat-box"><div class="stat-value" id="currentLength">-</div><div class="stat-label">Current Best</div></div>
                    <div class="stat-box"><div class="stat-value" id="improvement">0%</div><div class="stat-label">Improvement</div></div>
                </div>

                <div class="control-group">
                    <label>Convergence History</label>
                    <canvas id="historyChart" class="history-chart"></canvas>
                </div>

                <div class="info-panel">
                    <strong>ACO Algorithm (Dorigo 1991):</strong> Ants deposit pheromone on edges. Higher pheromone = more likely to be chosen. Good paths get reinforced; bad paths evaporate.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const historyCanvas = document.getElementById('historyChart');
        const historyCtx = historyCanvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * dpr;
            canvas.style.height = rect.width + 'px';
            ctx.scale(dpr, dpr);

            historyCanvas.width = 280;
            historyCanvas.height = 80;

            return { width: rect.width, height: rect.width };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); draw(); });

        class ACO {
            constructor(cities, numAnts, alpha, beta, evaporation) {
                this.cities = cities;
                this.numCities = cities.length;
                this.numAnts = numAnts;
                this.alpha = alpha;
                this.beta = beta;
                this.evaporation = evaporation;

                // Initialize distance matrix
                this.distances = [];
                for (let i = 0; i < this.numCities; i++) {
                    this.distances[i] = [];
                    for (let j = 0; j < this.numCities; j++) {
                        this.distances[i][j] = Math.sqrt(
                            (cities[i].x - cities[j].x) ** 2 +
                            (cities[i].y - cities[j].y) ** 2
                        );
                    }
                }

                // Initialize pheromone matrix
                this.pheromones = [];
                for (let i = 0; i < this.numCities; i++) {
                    this.pheromones[i] = [];
                    for (let j = 0; j < this.numCities; j++) {
                        this.pheromones[i][j] = 1;
                    }
                }

                this.bestTour = null;
                this.bestLength = Infinity;
                this.currentTours = [];
                this.history = [];
            }

            runIteration() {
                const tours = [];
                const lengths = [];

                // Each ant builds a tour
                for (let a = 0; a < this.numAnts; a++) {
                    const tour = this.buildTour();
                    const length = this.tourLength(tour);
                    tours.push(tour);
                    lengths.push(length);

                    if (length < this.bestLength) {
                        this.bestLength = length;
                        this.bestTour = [...tour];
                    }
                }

                this.currentTours = tours;

                // Evaporate pheromones
                for (let i = 0; i < this.numCities; i++) {
                    for (let j = 0; j < this.numCities; j++) {
                        this.pheromones[i][j] *= (1 - this.evaporation);
                        this.pheromones[i][j] = Math.max(0.001, this.pheromones[i][j]);
                    }
                }

                // Deposit new pheromones
                for (let a = 0; a < this.numAnts; a++) {
                    const tour = tours[a];
                    const deposit = 1 / lengths[a];

                    for (let i = 0; i < tour.length - 1; i++) {
                        this.pheromones[tour[i]][tour[i+1]] += deposit;
                        this.pheromones[tour[i+1]][tour[i]] += deposit;
                    }
                    // Close the tour
                    this.pheromones[tour[tour.length-1]][tour[0]] += deposit;
                    this.pheromones[tour[0]][tour[tour.length-1]] += deposit;
                }

                this.history.push(this.bestLength);
                if (this.history.length > 100) this.history.shift();

                return Math.min(...lengths);
            }

            buildTour() {
                const visited = new Set();
                const tour = [];

                // Start from random city
                let current = Math.floor(Math.random() * this.numCities);
                tour.push(current);
                visited.add(current);

                while (tour.length < this.numCities) {
                    const next = this.selectNextCity(current, visited);
                    tour.push(next);
                    visited.add(next);
                    current = next;
                }

                return tour;
            }

            selectNextCity(current, visited) {
                const probabilities = [];
                let total = 0;

                for (let j = 0; j < this.numCities; j++) {
                    if (visited.has(j)) {
                        probabilities.push(0);
                    } else {
                        const pheromone = Math.pow(this.pheromones[current][j], this.alpha);
                        const heuristic = Math.pow(1 / this.distances[current][j], this.beta);
                        const prob = pheromone * heuristic;
                        probabilities.push(prob);
                        total += prob;
                    }
                }

                // Roulette wheel selection
                const r = Math.random() * total;
                let sum = 0;
                for (let j = 0; j < this.numCities; j++) {
                    sum += probabilities[j];
                    if (sum >= r) return j;
                }

                // Fallback: return first unvisited
                for (let j = 0; j < this.numCities; j++) {
                    if (!visited.has(j)) return j;
                }
            }

            tourLength(tour) {
                let length = 0;
                for (let i = 0; i < tour.length - 1; i++) {
                    length += this.distances[tour[i]][tour[i+1]];
                }
                length += this.distances[tour[tour.length-1]][tour[0]];
                return length;
            }
        }

        let state = {
            running: false,
            cities: [],
            aco: null,
            iteration: 0,
            initialBest: null,
            ants: []
        };

        function generateCities() {
            const num = parseInt(document.getElementById('numCities').value);
            const problem = document.getElementById('problem').value;
            const cities = [];
            const margin = 50;
            const usableWidth = dims.width - margin * 2;
            const usableHeight = dims.height - margin * 2;

            switch (problem) {
                case 'random':
                    for (let i = 0; i < num; i++) {
                        cities.push({
                            x: margin + Math.random() * usableWidth,
                            y: margin + Math.random() * usableHeight
                        });
                    }
                    break;

                case 'circle':
                    for (let i = 0; i < num; i++) {
                        const angle = (i / num) * Math.PI * 2;
                        cities.push({
                            x: dims.width/2 + Math.cos(angle) * usableWidth * 0.4,
                            y: dims.height/2 + Math.sin(angle) * usableHeight * 0.4
                        });
                    }
                    break;

                case 'grid':
                    const side = Math.ceil(Math.sqrt(num));
                    for (let i = 0; i < num; i++) {
                        const row = Math.floor(i / side);
                        const col = i % side;
                        cities.push({
                            x: margin + col * (usableWidth / (side - 1 || 1)),
                            y: margin + row * (usableHeight / (side - 1 || 1))
                        });
                    }
                    break;

                case 'cluster':
                    const numClusters = 4;
                    const centers = [];
                    for (let c = 0; c < numClusters; c++) {
                        centers.push({
                            x: margin + (c % 2) * usableWidth * 0.7 + usableWidth * 0.15,
                            y: margin + Math.floor(c / 2) * usableHeight * 0.7 + usableHeight * 0.15
                        });
                    }
                    for (let i = 0; i < num; i++) {
                        const center = centers[i % numClusters];
                        cities.push({
                            x: center.x + (Math.random() - 0.5) * 80,
                            y: center.y + (Math.random() - 0.5) * 80
                        });
                    }
                    break;
            }

            return cities;
        }

        function initACO() {
            state.cities = generateCities();
            const numAnts = parseInt(document.getElementById('numAnts').value);
            const alpha = parseInt(document.getElementById('alpha').value) / 10;
            const beta = parseInt(document.getElementById('beta').value) / 10;
            const evaporation = parseInt(document.getElementById('evaporation').value) / 100;

            state.aco = new ACO(state.cities, numAnts, alpha, beta, evaporation);
            state.iteration = 0;
            state.initialBest = null;

            // Initialize ant positions
            state.ants = [];
            for (let i = 0; i < numAnts; i++) {
                state.ants.push({
                    x: state.cities[0].x,
                    y: state.cities[0].y,
                    progress: 0
                });
            }
        }

        function update() {
            if (!state.running) return;

            state.iteration++;
            const currentBest = state.aco.runIteration();

            if (state.initialBest === null) {
                state.initialBest = currentBest;
            }

            // Animate ants along current tours
            for (let i = 0; i < state.ants.length; i++) {
                const ant = state.ants[i];
                ant.progress = (ant.progress + 0.02) % 1;

                const tour = state.aco.currentTours[i];
                if (tour) {
                    const tourPos = ant.progress * tour.length;
                    const fromIdx = Math.floor(tourPos) % tour.length;
                    const toIdx = (fromIdx + 1) % tour.length;
                    const t = tourPos - fromIdx;

                    const from = state.cities[tour[fromIdx]];
                    const to = state.cities[tour[toIdx]];
                    ant.x = from.x + (to.x - from.x) * t;
                    ant.y = from.y + (to.y - from.y) * t;
                }
            }

            updateStats();
            draw();
            drawHistory();

            if (state.iteration < 500) {
                setTimeout(() => requestAnimationFrame(update), 50);
            } else {
                state.running = false;
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, dims.width, dims.height);

            // Draw pheromone trails
            const maxPheromone = Math.max(...state.aco.pheromones.flat());
            for (let i = 0; i < state.cities.length; i++) {
                for (let j = i + 1; j < state.cities.length; j++) {
                    const pheromone = state.aco.pheromones[i][j];
                    const intensity = Math.min(1, pheromone / maxPheromone * 2);

                    if (intensity > 0.1) {
                        ctx.strokeStyle = `rgba(149, 117, 205, ${intensity * 0.8})`;
                        ctx.lineWidth = 1 + intensity * 3;
                        ctx.beginPath();
                        ctx.moveTo(state.cities[i].x, state.cities[i].y);
                        ctx.lineTo(state.cities[j].x, state.cities[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw best tour
            if (state.aco.bestTour) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(
                    state.cities[state.aco.bestTour[0]].x,
                    state.cities[state.aco.bestTour[0]].y
                );
                for (let i = 1; i < state.aco.bestTour.length; i++) {
                    ctx.lineTo(
                        state.cities[state.aco.bestTour[i]].x,
                        state.cities[state.aco.bestTour[i]].y
                    );
                }
                ctx.closePath();
                ctx.stroke();
            }

            // Draw cities
            for (let i = 0; i < state.cities.length; i++) {
                const city = state.cities[i];

                ctx.fillStyle = '#ffb74d';
                ctx.beginPath();
                ctx.arc(city.x, city.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), city.x, city.y + 3);
            }

            // Draw ants
            for (const ant of state.ants) {
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(ant.x, ant.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '14px Lora';
            ctx.textAlign = 'left';
            ctx.fillText(`ACO for TSP | ${state.cities.length} cities`, 10, 25);
        }

        function drawHistory() {
            historyCtx.fillStyle = '#1a1a2e';
            historyCtx.fillRect(0, 0, 280, 80);

            if (state.aco.history.length < 2) return;

            const history = state.aco.history;
            const max = Math.max(...history);
            const min = Math.min(...history);
            const range = max - min || 1;

            historyCtx.strokeStyle = '#4CAF50';
            historyCtx.lineWidth = 2;
            historyCtx.beginPath();

            for (let i = 0; i < history.length; i++) {
                const x = (i / (history.length - 1)) * 270 + 5;
                const y = 75 - ((history[i] - min) / range) * 65;

                if (i === 0) historyCtx.moveTo(x, y);
                else historyCtx.lineTo(x, y);
            }
            historyCtx.stroke();

            // Labels
            historyCtx.fillStyle = '#aaa';
            historyCtx.font = '9px Nunito';
            historyCtx.fillText(max.toFixed(0), 3, 12);
            historyCtx.fillText(min.toFixed(0), 3, 75);
        }

        function updateStats() {
            document.getElementById('iteration').textContent = state.iteration;
            document.getElementById('bestLength').textContent = state.aco.bestLength.toFixed(1);

            const currentBest = state.aco.history[state.aco.history.length - 1];
            document.getElementById('currentLength').textContent = currentBest ? currentBest.toFixed(1) : '-';

            const improvement = state.initialBest ?
                ((state.initialBest - state.aco.bestLength) / state.initialBest * 100).toFixed(1) : 0;
            document.getElementById('improvement').textContent = improvement + '%';
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            initACO();
            draw();
            drawHistory();
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('numCitiesVal').textContent = document.getElementById('numCities').value;
            document.getElementById('numAntsVal').textContent = document.getElementById('numAnts').value;
            document.getElementById('alphaVal').textContent = (parseInt(document.getElementById('alpha').value) / 10).toFixed(1);
            document.getElementById('betaVal').textContent = (parseInt(document.getElementById('beta').value) / 10).toFixed(1);
            document.getElementById('evaporationVal').textContent = document.getElementById('evaporation').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));
        document.getElementById('problem').addEventListener('change', resetSimulation);

        initACO();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
