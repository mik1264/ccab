<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Conflict Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box.danger {
            border-left-color: #e74c3c;
        }

        .stat-box.selfish {
            border-left-color: #9C27B0;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.75em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .genotype-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .genotype-box {
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.8em;
        }

        .genotype-box .freq {
            font-size: 1.1em;
            font-weight: bold;
        }

        .conflict-type {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .conflict-btn {
            flex: 1;
            padding: 8px 4px;
            border: 2px solid var(--sage);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7em;
            transition: all 0.2s;
        }

        .conflict-btn.active {
            background: var(--sage);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Genetic Conflict</h1>
            <p class="subtitle">Selfish Genetic Elements: Transposons, Meiotic Drive & Cytoplasmic Male Sterility</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Conflict Type</h3>
                    <div class="conflict-type">
                        <button class="conflict-btn active" data-type="segregation">Segregation Distorter</button>
                        <button class="conflict-btn" data-type="transposon">Transposon</button>
                        <button class="conflict-btn" data-type="cms">CMS</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Population</h3>
                    <div class="control-group">
                        <label>Population Size: <span id="popSizeVal">500</span></label>
                        <input type="range" id="popSize" min="100" max="2000" value="500" step="50">
                    </div>
                </div>

                <div class="control-section" id="segregationParams">
                    <h3>Segregation Distorter (SD)</h3>
                    <div class="control-group">
                        <label>Drive Strength (k): <span id="driveStrengthVal">0.90</span></label>
                        <input type="range" id="driveStrength" min="50" max="99" value="90">
                        <div class="value">% transmission to offspring</div>
                    </div>
                    <div class="control-group">
                        <label>Fitness Cost: <span id="fitnessCostVal">0.10</span></label>
                        <input type="range" id="fitnessCost" min="0" max="50" value="10">
                        <div class="value">homozygote viability</div>
                    </div>
                    <div class="control-group">
                        <label>Suppressor Rate: <span id="suppressorVal">0.001</span></label>
                        <input type="range" id="suppressor" min="0" max="50" value="10">
                        <div class="value">×10⁻⁴</div>
                    </div>
                </div>

                <div class="control-section" id="transposonParams" style="display: none;">
                    <h3>Transposon Parameters</h3>
                    <div class="control-group">
                        <label>Transposition Rate: <span id="transpRateVal">0.01</span></label>
                        <input type="range" id="transpRate" min="1" max="50" value="10">
                        <div class="value">×10⁻³ per copy</div>
                    </div>
                    <div class="control-group">
                        <label>Fitness Cost per Copy: <span id="copyFitCostVal">0.01</span></label>
                        <input type="range" id="copyFitCost" min="1" max="50" value="10">
                        <div class="value">×10⁻³</div>
                    </div>
                    <div class="control-group">
                        <label>Excision Rate: <span id="excisionVal">0.001</span></label>
                        <input type="range" id="excision" min="0" max="20" value="5">
                        <div class="value">×10⁻³</div>
                    </div>
                </div>

                <div class="control-section" id="cmsParams" style="display: none;">
                    <h3>Cytoplasmic Male Sterility</h3>
                    <div class="control-group">
                        <label>CMS Advantage: <span id="cmsAdvVal">0.20</span></label>
                        <input type="range" id="cmsAdv" min="0" max="50" value="20">
                        <div class="value">female fertility bonus</div>
                    </div>
                    <div class="control-group">
                        <label>Restorer Frequency: <span id="restorerVal">0.10</span></label>
                        <input type="range" id="restorer" min="0" max="50" value="10">
                        <div class="value">initial Rf allele freq</div>
                    </div>
                    <div class="control-group">
                        <label>Restorer Cost: <span id="restorerCostVal">0.05</span></label>
                        <input type="range" id="restorerCost" min="0" max="30" value="5">
                        <div class="value">when no CMS present</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box" id="infoBox">
                    <strong>Segregation Distorters:</strong><br>
                    "Selfish" chromosomes that bias their own transmission above 50% during meiosis, often by destroying gametes carrying the alternative allele. Creates conflict between distorter and host genome.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Allele Frequency Dynamics</h3>
                    <canvas id="freqCanvas"></canvas>
                    <div class="legend" id="freqLegend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f44336;"></div>
                            <span>SD (Distorter)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>SD+ (Wild-type)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Suppressor</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Genotype Frequencies</h3>
                        <canvas id="genoCanvas"></canvas>
                        <div class="genotype-display" id="genotypeDisplay">
                            <!-- Filled by JS -->
                        </div>
                    </div>
                    <div class="viz-panel">
                        <h3>Fitness Landscape</h3>
                        <canvas id="fitnessCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Arms Race Dynamics</h3>
                        <canvas id="armsCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Population Fitness</h3>
                        <canvas id="popFitCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Population</div>
                        <div class="value" id="popStat">500</div>
                    </div>
                    <div class="stat-box selfish">
                        <div class="label">Selfish Element</div>
                        <div class="value" id="selfishStat">0.0%</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Suppressor</div>
                        <div class="value" id="suppressStat">0.0%</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Mean Fitness</div>
                        <div class="value" id="fitnessStat">1.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Sex Ratio</div>
                        <div class="value" id="sexRatioStat">1.00</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const freqCanvas = document.getElementById('freqCanvas');
        const genoCanvas = document.getElementById('genoCanvas');
        const fitnessCanvas = document.getElementById('fitnessCanvas');
        const armsCanvas = document.getElementById('armsCanvas');
        const popFitCanvas = document.getElementById('popFitCanvas');

        const freqCtx = freqCanvas.getContext('2d');
        const genoCtx = genoCanvas.getContext('2d');
        const fitnessCtx = fitnessCanvas.getContext('2d');
        const armsCtx = armsCanvas.getContext('2d');
        const popFitCtx = popFitCanvas.getContext('2d');

        // Parameters
        let conflictType = 'segregation';
        let popSize = 500;
        let driveStrength = 0.90;
        let fitnessCost = 0.10;
        let suppressorRate = 0.001;

        let transpRate = 0.01;
        let copyFitCost = 0.01;
        let excision = 0.001;

        let cmsAdv = 0.20;
        let restorerFreq = 0.10;
        let restorerCost = 0.05;

        // State
        let population = [];
        let generation = 0;
        let freqHistory = [];
        let fitnessHistory = [];
        let running = false;
        let animationId = null;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        // Segregation Distorter
        function createSegregationIndividual(sdAllele1, sdAllele2, suppressor1, suppressor2, sex) {
            return {
                sd: [sdAllele1, sdAllele2],  // 0 = SD+, 1 = SD
                sup: [suppressor1, suppressor2],  // 0 = no suppressor, 1 = suppressor
                sex: sex  // 'M' or 'F'
            };
        }

        function initSegregation() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                const sd1 = Math.random() < 0.01 ? 1 : 0;  // Start with low SD frequency
                const sd2 = Math.random() < 0.01 ? 1 : 0;
                const sup1 = 0;
                const sup2 = 0;
                const sex = Math.random() < 0.5 ? 'M' : 'F';
                population.push(createSegregationIndividual(sd1, sd2, sup1, sup2, sex));
            }
        }

        function segregationMeiosis(parent, sex) {
            // Gamete production with drive
            let gamete = { sd: 0, sup: 0 };

            // SD drive only occurs in males
            if (sex === 'M' && parent.sd[0] !== parent.sd[1]) {
                // Heterozygote - drive occurs
                const hasSupp = parent.sup[0] === 1 || parent.sup[1] === 1;
                const effectiveDrive = hasSupp ? 0.5 : driveStrength;

                // SD is transmitted at drive rate
                if (parent.sd[0] === 1) {
                    gamete.sd = Math.random() < effectiveDrive ? 1 : 0;
                } else {
                    gamete.sd = Math.random() < effectiveDrive ? 0 : 1;
                }
            } else {
                // Normal segregation
                gamete.sd = parent.sd[Math.random() < 0.5 ? 0 : 1];
            }

            // Normal segregation for suppressor
            gamete.sup = parent.sup[Math.random() < 0.5 ? 0 : 1];

            // Mutation to suppressor
            if (gamete.sup === 0 && Math.random() < suppressorRate) {
                gamete.sup = 1;
            }

            return gamete;
        }

        function segregationFitness(ind) {
            // Homozygotes for SD have reduced viability
            if (ind.sd[0] === 1 && ind.sd[1] === 1) {
                return 1 - fitnessCost * 2;  // Stronger penalty for homozygotes
            }
            return 1;
        }

        // Transposon
        function createTransposonIndividual(copies, suppLevel) {
            return {
                copies: copies,
                suppLevel: suppLevel
            };
        }

        function initTransposon() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                const copies = Math.floor(Math.random() * 3);  // 0-2 initial copies
                population.push(createTransposonIndividual(copies, 0));
            }
        }

        function transposonFitness(ind) {
            return Math.max(0, 1 - ind.copies * copyFitCost);
        }

        // CMS
        function createCMSIndividual(hasCMS, restorer1, restorer2, sex) {
            return {
                cms: hasCMS,  // Cytoplasmic (maternally inherited)
                rf: [restorer1, restorer2],  // Nuclear restorer
                sex: sex
            };
        }

        function initCMS() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                const cms = Math.random() < 0.1;
                const rf1 = Math.random() < restorerFreq ? 1 : 0;
                const rf2 = Math.random() < restorerFreq ? 1 : 0;
                const sex = Math.random() < 0.5 ? 'M' : 'F';
                population.push(createCMSIndividual(cms, rf1, rf2, sex));
            }
        }

        function cmsFitness(ind) {
            if (ind.cms && ind.sex === 'M') {
                // Male sterile unless has restorer
                const hasRestorer = ind.rf[0] === 1 || ind.rf[1] === 1;
                if (!hasRestorer) return 0;  // Sterile
            }

            // Restorer has cost when no CMS
            if (!ind.cms && (ind.rf[0] === 1 || ind.rf[1] === 1)) {
                return 1 - restorerCost;
            }

            // CMS females have fertility advantage
            if (ind.cms && ind.sex === 'F') {
                return 1 + cmsAdv;
            }

            return 1;
        }

        function initPopulation() {
            if (conflictType === 'segregation') {
                initSegregation();
            } else if (conflictType === 'transposon') {
                initTransposon();
            } else {
                initCMS();
            }

            generation = 0;
            freqHistory = [];
            fitnessHistory = [];
        }

        function reproduce() {
            if (conflictType === 'segregation') {
                reproduceSegregation();
            } else if (conflictType === 'transposon') {
                reproduceTransposon();
            } else {
                reproduceCMS();
            }
        }

        function reproduceSegregation() {
            const males = population.filter(p => p.sex === 'M');
            const females = population.filter(p => p.sex === 'F');

            if (males.length === 0 || females.length === 0) {
                population = [];
                return;
            }

            const newPop = [];
            const targetSize = popSize;

            while (newPop.length < targetSize && males.length > 0 && females.length > 0) {
                // Select parents
                const maleIdx = Math.floor(Math.random() * males.length);
                const femaleIdx = Math.floor(Math.random() * females.length);
                const male = males[maleIdx];
                const female = females[femaleIdx];

                // Create gametes
                const sperm = segregationMeiosis(male, 'M');
                const egg = segregationMeiosis(female, 'F');

                // Create offspring
                const offspring = createSegregationIndividual(
                    sperm.sd, egg.sd,
                    sperm.sup, egg.sup,
                    Math.random() < 0.5 ? 'M' : 'F'
                );

                // Viability selection
                const fitness = segregationFitness(offspring);
                if (Math.random() < fitness) {
                    newPop.push(offspring);
                }
            }

            population = newPop;
        }

        function reproduceTransposon() {
            const fitnesses = population.map(transposonFitness);
            const totalFit = fitnesses.reduce((a, b) => a + b, 0);

            const newPop = [];
            while (newPop.length < popSize) {
                // Select two parents
                let r = Math.random() * totalFit;
                let p1Idx = 0;
                let cumFit = fitnesses[0];
                while (cumFit < r && p1Idx < population.length - 1) {
                    p1Idx++;
                    cumFit += fitnesses[p1Idx];
                }

                r = Math.random() * totalFit;
                let p2Idx = 0;
                cumFit = fitnesses[0];
                while (cumFit < r && p2Idx < population.length - 1) {
                    p2Idx++;
                    cumFit += fitnesses[p2Idx];
                }

                const p1 = population[p1Idx];
                const p2 = population[p2Idx];

                // Offspring inherits average copies with variation
                let copies = Math.round((p1.copies + p2.copies) / 2);

                // Transposition
                for (let c = 0; c < copies; c++) {
                    if (Math.random() < transpRate) {
                        copies++;
                    }
                }

                // Excision
                for (let c = 0; c < copies; c++) {
                    if (Math.random() < excision) {
                        copies = Math.max(0, copies - 1);
                    }
                }

                // Suppression evolution
                const suppLevel = Math.max(p1.suppLevel, p2.suppLevel);

                newPop.push(createTransposonIndividual(copies, suppLevel));
            }

            population = newPop;
        }

        function reproduceCMS() {
            const males = population.filter(p => p.sex === 'M' && cmsFitness(p) > 0);
            const females = population.filter(p => p.sex === 'F');

            if (males.length === 0 || females.length === 0) {
                population = [];
                return;
            }

            const femFitnesses = females.map(cmsFitness);
            const totalFemFit = femFitnesses.reduce((a, b) => a + b, 0);

            const newPop = [];
            while (newPop.length < popSize && males.length > 0) {
                // Select female proportional to fitness
                let r = Math.random() * totalFemFit;
                let femIdx = 0;
                let cumFit = femFitnesses[0];
                while (cumFit < r && femIdx < females.length - 1) {
                    femIdx++;
                    cumFit += femFitnesses[femIdx];
                }

                const female = females[femIdx];
                const male = males[Math.floor(Math.random() * males.length)];

                // CMS is maternally inherited
                const hasCMS = female.cms;

                // Nuclear genes segregate normally
                const rf1 = (Math.random() < 0.5 ? female.rf[0] : female.rf[1]);
                const rf2 = (Math.random() < 0.5 ? male.rf[0] : male.rf[1]);

                newPop.push(createCMSIndividual(hasCMS, rf1, rf2, Math.random() < 0.5 ? 'M' : 'F'));
            }

            population = newPop;
        }

        function getFrequencies() {
            if (conflictType === 'segregation') {
                let sdCount = 0;
                let supCount = 0;
                let totalAlleles = population.length * 2;

                population.forEach(ind => {
                    sdCount += ind.sd[0] + ind.sd[1];
                    supCount += ind.sup[0] + ind.sup[1];
                });

                return {
                    selfish: sdCount / totalAlleles,
                    suppressor: supCount / totalAlleles,
                    wildtype: 1 - sdCount / totalAlleles
                };
            } else if (conflictType === 'transposon') {
                const totalCopies = population.reduce((sum, p) => sum + p.copies, 0);
                const meanCopies = totalCopies / population.length;
                return {
                    selfish: meanCopies / 20,  // Normalize
                    suppressor: 0,
                    copies: meanCopies
                };
            } else {
                let cmsCount = population.filter(p => p.cms).length;
                let rfCount = 0;
                population.forEach(p => rfCount += p.rf[0] + p.rf[1]);

                return {
                    selfish: cmsCount / population.length,
                    suppressor: rfCount / (population.length * 2),
                    cms: cmsCount / population.length,
                    restorer: rfCount / (population.length * 2)
                };
            }
        }

        function getMeanFitness() {
            if (population.length === 0) return 0;

            let fitnessFunc;
            if (conflictType === 'segregation') {
                fitnessFunc = segregationFitness;
            } else if (conflictType === 'transposon') {
                fitnessFunc = transposonFitness;
            } else {
                fitnessFunc = cmsFitness;
            }

            return population.reduce((sum, p) => sum + fitnessFunc(p), 0) / population.length;
        }

        function getSexRatio() {
            if (conflictType !== 'cms' && conflictType !== 'segregation') return 1;

            const males = population.filter(p => p.sex === 'M').length;
            const females = population.filter(p => p.sex === 'F').length;

            return females > 0 ? males / females : 0;
        }

        function step() {
            reproduce();
            generation++;

            const freqs = getFrequencies();
            const meanFit = getMeanFitness();

            freqHistory.push({ gen: generation, ...freqs });
            fitnessHistory.push({ gen: generation, fitness: meanFit });

            if (freqHistory.length > 500) {
                freqHistory = freqHistory.filter((_, i) => i % 2 === 0);
                fitnessHistory = fitnessHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawFrequencies() {
            const width = freqCanvas.width / (window.devicePixelRatio || 1);
            const height = freqCanvas.height / (window.devicePixelRatio || 1);

            freqCtx.fillStyle = '#1a1a2e';
            freqCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            freqCtx.strokeStyle = '#ffffff44';
            freqCtx.beginPath();
            freqCtx.moveTo(padding, padding);
            freqCtx.lineTo(padding, height - padding);
            freqCtx.lineTo(width - padding, height - padding);
            freqCtx.stroke();

            freqCtx.fillStyle = '#ffffffaa';
            freqCtx.font = '11px sans-serif';
            freqCtx.fillText('Frequency', padding, padding - 10);
            freqCtx.fillText('Generation', width - padding - 50, height - 10);

            if (freqHistory.length < 2) return;

            const maxGen = freqHistory[freqHistory.length - 1].gen;

            // Draw selfish element frequency
            freqCtx.strokeStyle = '#f44336';
            freqCtx.lineWidth = 2;
            freqCtx.beginPath();
            freqHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - point.selfish * graphHeight;
                if (i === 0) freqCtx.moveTo(x, y);
                else freqCtx.lineTo(x, y);
            });
            freqCtx.stroke();

            // Draw suppressor frequency
            freqCtx.strokeStyle = '#2196F3';
            freqCtx.lineWidth = 2;
            freqCtx.beginPath();
            freqHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - point.suppressor * graphHeight;
                if (i === 0) freqCtx.moveTo(x, y);
                else freqCtx.lineTo(x, y);
            });
            freqCtx.stroke();
        }

        function drawGenotypes() {
            const width = genoCanvas.width / (window.devicePixelRatio || 1);
            const height = genoCanvas.height / (window.devicePixelRatio || 1);

            genoCtx.fillStyle = '#1a1a2e';
            genoCtx.fillRect(0, 0, width, height);

            if (conflictType === 'segregation') {
                // Count genotypes
                let sd00 = 0, sd01 = 0, sd11 = 0;
                population.forEach(p => {
                    const sum = p.sd[0] + p.sd[1];
                    if (sum === 0) sd00++;
                    else if (sum === 1) sd01++;
                    else sd11++;
                });

                const total = population.length || 1;
                const barWidth = (width - 80) / 3;

                const genotypes = [
                    { label: 'SD+/SD+', freq: sd00 / total, color: '#4CAF50' },
                    { label: 'SD/SD+', freq: sd01 / total, color: '#FFC107' },
                    { label: 'SD/SD', freq: sd11 / total, color: '#f44336' }
                ];

                genotypes.forEach((g, i) => {
                    const x = 40 + i * barWidth;
                    const barHeight = g.freq * (height - 60);

                    genoCtx.fillStyle = g.color;
                    genoCtx.fillRect(x, height - 30 - barHeight, barWidth - 10, barHeight);

                    genoCtx.fillStyle = '#ffffffaa';
                    genoCtx.font = '10px sans-serif';
                    genoCtx.textAlign = 'center';
                    genoCtx.fillText(g.label, x + (barWidth - 10) / 2, height - 15);
                    genoCtx.fillText((g.freq * 100).toFixed(1) + '%', x + (barWidth - 10) / 2, height - 40 - barHeight);
                });
            } else if (conflictType === 'transposon') {
                // Histogram of copy numbers
                const maxCopies = Math.max(10, ...population.map(p => p.copies));
                const histogram = new Array(maxCopies + 1).fill(0);
                population.forEach(p => histogram[Math.min(p.copies, maxCopies)]++);

                const barWidth = (width - 60) / (maxCopies + 1);
                const maxCount = Math.max(...histogram);

                histogram.forEach((count, copies) => {
                    const x = 30 + copies * barWidth;
                    const barHeight = (count / maxCount) * (height - 60);

                    genoCtx.fillStyle = `hsl(${280 - copies * 20}, 70%, 50%)`;
                    genoCtx.fillRect(x, height - 30 - barHeight, barWidth - 2, barHeight);
                });

                genoCtx.fillStyle = '#ffffffaa';
                genoCtx.font = '10px sans-serif';
                genoCtx.fillText('TE Copy Number', width / 2, 20);
            }
        }

        function drawFitness() {
            const width = fitnessCanvas.width / (window.devicePixelRatio || 1);
            const height = fitnessCanvas.height / (window.devicePixelRatio || 1);

            fitnessCtx.fillStyle = '#1a1a2e';
            fitnessCtx.fillRect(0, 0, width, height);

            // Draw fitness function
            const padding = 30;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            if (conflictType === 'segregation') {
                // Bar chart for genotype fitness
                const fitnesses = [
                    { label: 'SD+/SD+', fit: 1, color: '#4CAF50' },
                    { label: 'SD/SD+', fit: 1, color: '#FFC107' },
                    { label: 'SD/SD', fit: 1 - fitnessCost * 2, color: '#f44336' }
                ];

                const barWidth = graphWidth / 3;
                fitnesses.forEach((f, i) => {
                    const x = padding + i * barWidth;
                    const barHeight = f.fit * graphHeight;

                    fitnessCtx.fillStyle = f.color;
                    fitnessCtx.fillRect(x + 5, height - padding - barHeight, barWidth - 10, barHeight);

                    fitnessCtx.fillStyle = '#ffffffaa';
                    fitnessCtx.font = '9px sans-serif';
                    fitnessCtx.textAlign = 'center';
                    fitnessCtx.fillText(f.label, x + barWidth / 2, height - 10);
                    fitnessCtx.fillText(f.fit.toFixed(2), x + barWidth / 2, height - padding - barHeight - 5);
                });
            } else {
                // Fitness curve
                fitnessCtx.strokeStyle = '#E91E63';
                fitnessCtx.lineWidth = 2;
                fitnessCtx.beginPath();

                for (let x = 0; x <= 50; x++) {
                    const copies = x / 5;
                    const fit = Math.max(0, 1 - copies * copyFitCost);
                    const px = padding + (x / 50) * graphWidth;
                    const py = height - padding - fit * graphHeight;

                    if (x === 0) fitnessCtx.moveTo(px, py);
                    else fitnessCtx.lineTo(px, py);
                }
                fitnessCtx.stroke();

                fitnessCtx.fillStyle = '#ffffffaa';
                fitnessCtx.fillText('Fitness vs TE Copies', width / 2, 15);
            }
        }

        function drawArmsRace() {
            const width = armsCanvas.width / (window.devicePixelRatio || 1);
            const height = armsCanvas.height / (window.devicePixelRatio || 1);

            armsCtx.fillStyle = '#1a1a2e';
            armsCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Phase space: selfish vs suppressor
            armsCtx.strokeStyle = '#ffffff44';
            armsCtx.beginPath();
            armsCtx.moveTo(padding, padding);
            armsCtx.lineTo(padding, height - padding);
            armsCtx.lineTo(width - padding, height - padding);
            armsCtx.stroke();

            armsCtx.fillStyle = '#ffffffaa';
            armsCtx.font = '10px sans-serif';
            armsCtx.fillText('Suppressor Freq', padding - 5, padding - 5);
            armsCtx.fillText('Selfish Freq', width - padding - 50, height - 5);

            if (freqHistory.length < 2) return;

            // Draw trajectory
            armsCtx.strokeStyle = '#FFC107';
            armsCtx.lineWidth = 1;
            armsCtx.beginPath();

            freqHistory.forEach((point, i) => {
                const x = padding + point.selfish * graphWidth;
                const y = height - padding - point.suppressor * graphHeight;

                if (i === 0) armsCtx.moveTo(x, y);
                else armsCtx.lineTo(x, y);
            });
            armsCtx.stroke();

            // Current position
            const current = freqHistory[freqHistory.length - 1];
            const cx = padding + current.selfish * graphWidth;
            const cy = height - padding - current.suppressor * graphHeight;

            armsCtx.beginPath();
            armsCtx.arc(cx, cy, 5, 0, Math.PI * 2);
            armsCtx.fillStyle = '#f44336';
            armsCtx.fill();
        }

        function drawPopFitness() {
            const width = popFitCanvas.width / (window.devicePixelRatio || 1);
            const height = popFitCanvas.height / (window.devicePixelRatio || 1);

            popFitCtx.fillStyle = '#1a1a2e';
            popFitCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            popFitCtx.strokeStyle = '#ffffff44';
            popFitCtx.beginPath();
            popFitCtx.moveTo(padding, padding);
            popFitCtx.lineTo(padding, height - padding);
            popFitCtx.lineTo(width - padding, height - padding);
            popFitCtx.stroke();

            if (fitnessHistory.length < 2) return;

            const maxGen = fitnessHistory[fitnessHistory.length - 1].gen;

            popFitCtx.strokeStyle = '#4CAF50';
            popFitCtx.lineWidth = 2;
            popFitCtx.beginPath();

            fitnessHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - point.fitness * graphHeight;

                if (i === 0) popFitCtx.moveTo(x, y);
                else popFitCtx.lineTo(x, y);
            });
            popFitCtx.stroke();

            popFitCtx.fillStyle = '#ffffffaa';
            popFitCtx.font = '10px sans-serif';
            popFitCtx.fillText('Mean Population Fitness', padding, padding - 5);
        }

        function updateStats() {
            const freqs = getFrequencies();

            document.getElementById('genStat').textContent = generation;
            document.getElementById('popStat').textContent = population.length;
            document.getElementById('selfishStat').textContent = (freqs.selfish * 100).toFixed(1) + '%';
            document.getElementById('suppressStat').textContent = (freqs.suppressor * 100).toFixed(1) + '%';
            document.getElementById('fitnessStat').textContent = getMeanFitness().toFixed(3);
            document.getElementById('sexRatioStat').textContent = getSexRatio().toFixed(2);
        }

        function updateLegend() {
            const legend = document.getElementById('freqLegend');
            if (conflictType === 'segregation') {
                legend.innerHTML = `
                    <div class="legend-item"><div class="legend-color" style="background: #f44336;"></div><span>SD (Distorter)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #4CAF50;"></div><span>SD+ (Wild-type)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #2196F3;"></div><span>Suppressor</span></div>
                `;
            } else if (conflictType === 'transposon') {
                legend.innerHTML = `
                    <div class="legend-item"><div class="legend-color" style="background: #9C27B0;"></div><span>TE Copy Number</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #2196F3;"></div><span>Suppression Level</span></div>
                `;
            } else {
                legend.innerHTML = `
                    <div class="legend-item"><div class="legend-color" style="background: #f44336;"></div><span>CMS Cytoplasm</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #2196F3;"></div><span>Restorer Allele</span></div>
                `;
            }
        }

        function updateInfo() {
            const info = document.getElementById('infoBox');
            if (conflictType === 'segregation') {
                info.innerHTML = '<strong>Segregation Distorters:</strong><br>"Selfish" chromosomes that bias their own transmission above 50% during meiosis, often by destroying gametes carrying the alternative allele. Creates conflict between distorter and host genome.';
            } else if (conflictType === 'transposon') {
                info.innerHTML = '<strong>Transposons:</strong><br>Selfish DNA sequences that copy themselves to new locations in the genome. Host evolves suppression mechanisms (piRNA), creating ongoing arms race dynamics.';
            } else {
                info.innerHTML = '<strong>Cytoplasmic Male Sterility:</strong><br>Mitochondrial mutations that sterilize males (who don\'t transmit mitochondria). Nuclear "restorer" genes evolve to counteract CMS. Classic example of nuclear-cytoplasmic conflict.';
            }
        }

        function animate() {
            step();

            drawFrequencies();
            drawGenotypes();
            drawFitness();
            drawArmsRace();
            drawPopFitness();
            updateStats();

            if (running && population.length > 0) {
                animationId = requestAnimationFrame(animate);
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            popSize = parseInt(document.getElementById('popSize').value);
            driveStrength = parseInt(document.getElementById('driveStrength').value) / 100;
            fitnessCost = parseInt(document.getElementById('fitnessCost').value) / 100;
            suppressorRate = parseInt(document.getElementById('suppressor').value) / 10000;
            transpRate = parseInt(document.getElementById('transpRate').value) / 1000;
            copyFitCost = parseInt(document.getElementById('copyFitCost').value) / 1000;
            excision = parseInt(document.getElementById('excision').value) / 1000;
            cmsAdv = parseInt(document.getElementById('cmsAdv').value) / 100;
            restorerFreq = parseInt(document.getElementById('restorer').value) / 100;
            restorerCost = parseInt(document.getElementById('restorerCost').value) / 100;

            initPopulation();
            drawFrequencies();
            drawGenotypes();
            drawFitness();
            drawArmsRace();
            drawPopFitness();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.querySelectorAll('.conflict-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.conflict-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                conflictType = btn.dataset.type;

                document.getElementById('segregationParams').style.display =
                    conflictType === 'segregation' ? 'block' : 'none';
                document.getElementById('transposonParams').style.display =
                    conflictType === 'transposon' ? 'block' : 'none';
                document.getElementById('cmsParams').style.display =
                    conflictType === 'cms' ? 'block' : 'none';

                updateLegend();
                updateInfo();
                reset();
            });
        });

        // Slider listeners
        document.getElementById('popSize').addEventListener('input', (e) => {
            document.getElementById('popSizeVal').textContent = e.target.value;
        });

        document.getElementById('driveStrength').addEventListener('input', (e) => {
            document.getElementById('driveStrengthVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('fitnessCost').addEventListener('input', (e) => {
            document.getElementById('fitnessCostVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('suppressor').addEventListener('input', (e) => {
            document.getElementById('suppressorVal').textContent = (e.target.value / 10000).toFixed(4);
        });

        document.getElementById('transpRate').addEventListener('input', (e) => {
            document.getElementById('transpRateVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('copyFitCost').addEventListener('input', (e) => {
            document.getElementById('copyFitCostVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('excision').addEventListener('input', (e) => {
            document.getElementById('excisionVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('cmsAdv').addEventListener('input', (e) => {
            document.getElementById('cmsAdvVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('restorer').addEventListener('input', (e) => {
            document.getElementById('restorerVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('restorerCost').addEventListener('input', (e) => {
            document.getElementById('restorerCostVal').textContent = (e.target.value / 100).toFixed(2);
        });

        // Initialize
        function init() {
            setupCanvas(freqCanvas, freqCtx, 180);
            setupCanvas(genoCanvas, genoCtx, 150);
            setupCanvas(fitnessCanvas, fitnessCtx, 150);
            setupCanvas(armsCanvas, armsCtx, 150);
            setupCanvas(popFitCanvas, popFitCtx, 150);

            initPopulation();
            drawFrequencies();
            drawGenotypes();
            drawFitness();
            drawArmsRace();
            drawPopFitness();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(freqCanvas, freqCtx, 180);
            setupCanvas(genoCanvas, genoCtx, 150);
            setupCanvas(fitnessCanvas, fitnessCtx, 150);
            setupCanvas(armsCanvas, armsCtx, 150);
            setupCanvas(popFitCanvas, popFitCtx, 150);
            drawFrequencies();
            drawGenotypes();
            drawFitness();
            drawArmsRace();
            drawPopFitness();
        });

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
