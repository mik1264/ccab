<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Robotics - Collective Intelligence</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #2d2d3a; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; font-family: inherit; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .legend { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; margin-top: 10px; font-size: 0.75rem; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Swarm Robotics</h1>
            <p class="subtitle">Emergent collective behaviors from simple local rules</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Task</label>
                    <select id="task">
                        <option value="foraging">Foraging (collect resources)</option>
                        <option value="coverage">Area Coverage</option>
                        <option value="construction">Construction</option>
                        <option value="transport">Object Transport</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Swarm Size</label>
                    <input type="range" id="swarmSize" min="10" max="100" value="40">
                    <div class="control-value"><span id="swarmSizeVal">40</span> robots</div>
                </div>
                <div class="control-group">
                    <label>Communication Range</label>
                    <input type="range" id="commRange" min="20" max="100" value="50">
                    <div class="control-value"><span id="commRangeVal">50</span>px</div>
                </div>
                <div class="control-group">
                    <label>Pheromone Strength</label>
                    <input type="range" id="pheromone" min="0" max="100" value="50">
                    <div class="control-value"><span id="pheromoneVal">50</span>%</div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset Swarm</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="collected">0</div><div class="stat-label">Resources</div></div>
                    <div class="stat-box"><div class="stat-value" id="coverage">0%</div><div class="stat-label">Coverage</div></div>
                    <div class="stat-box"><div class="stat-value" id="efficiency">0</div><div class="stat-label">Efficiency</div></div>
                    <div class="stat-box"><div class="stat-value" id="time">0</div><div class="stat-label">Time (s)</div></div>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#4fc3f7"></div>Searching</div>
                    <div class="legend-item"><div class="legend-color" style="background:#81c784"></div>Carrying</div>
                    <div class="legend-item"><div class="legend-color" style="background:#ffb74d"></div>Resource</div>
                    <div class="legend-item"><div class="legend-color" style="background:#9575cd"></div>Pheromone</div>
                </div>

                <div class="info-panel">
                    <strong>Swarm Intelligence:</strong> Robots use local sensing and stigmergic communication (pheromone trails) to coordinate. No central controller—emergent behavior arises from simple rules.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * dpr;
            canvas.style.height = rect.width + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); });

        // Robot class
        class Robot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 1.5;
                this.state = 'searching'; // searching, carrying, constructing
                this.carrying = null;
                this.target = null;
                this.sensorRange = 30;
            }

            update(robots, resources, pheromones, base, task, params) {
                // Sense environment
                const nearbyRobots = robots.filter(r => r !== this && this.distTo(r) < params.commRange);
                const nearbyResources = resources.filter(r => this.distTo(r) < this.sensorRange && !r.collected);
                const nearbyPheromone = this.sensePheromone(pheromones);

                switch (task) {
                    case 'foraging':
                        this.foragingBehavior(nearbyRobots, nearbyResources, nearbyPheromone, base, params);
                        break;
                    case 'coverage':
                        this.coverageBehavior(nearbyRobots, params);
                        break;
                    case 'construction':
                        this.constructionBehavior(nearbyRobots, nearbyResources, base, params);
                        break;
                    case 'transport':
                        this.transportBehavior(nearbyRobots, nearbyResources, base, params);
                        break;
                }

                // Movement
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // Boundary avoidance
                const margin = 30;
                if (this.x < margin) this.angle = 0;
                if (this.x > dims.width - margin) this.angle = Math.PI;
                if (this.y < margin) this.angle = Math.PI / 2;
                if (this.y > dims.height - margin) this.angle = -Math.PI / 2;

                this.x = Math.max(10, Math.min(dims.width - 10, this.x));
                this.y = Math.max(10, Math.min(dims.height - 10, this.y));
            }

            foragingBehavior(nearbyRobots, nearbyResources, pheromoneGradient, base, params) {
                if (this.state === 'searching') {
                    // Look for resources
                    if (nearbyResources.length > 0) {
                        const target = nearbyResources[0];
                        this.angle = Math.atan2(target.y - this.y, target.x - this.x);

                        if (this.distTo(target) < 10) {
                            target.collected = true;
                            this.carrying = target;
                            this.state = 'carrying';
                        }
                    } else if (pheromoneGradient && params.pheromone > 0) {
                        // Follow pheromone trail
                        this.angle += (pheromoneGradient - 0.5) * 0.5;
                    } else {
                        // Random walk with collision avoidance
                        for (const other of nearbyRobots) {
                            if (this.distTo(other) < 15) {
                                this.angle += Math.PI / 4;
                            }
                        }
                        this.angle += (Math.random() - 0.5) * 0.3;
                    }
                } else if (this.state === 'carrying') {
                    // Return to base
                    this.angle = Math.atan2(base.y - this.y, base.x - this.x);

                    if (this.distTo(base) < 25) {
                        this.carrying = null;
                        this.state = 'searching';
                        return true; // Delivered
                    }
                }
                return false;
            }

            coverageBehavior(nearbyRobots, params) {
                // Disperse to maximize coverage
                let repelX = 0, repelY = 0;

                for (const other of nearbyRobots) {
                    const d = this.distTo(other);
                    if (d < params.commRange && d > 0) {
                        const strength = (params.commRange - d) / params.commRange;
                        repelX += (this.x - other.x) / d * strength;
                        repelY += (this.y - other.y) / d * strength;
                    }
                }

                if (repelX !== 0 || repelY !== 0) {
                    this.angle = Math.atan2(repelY, repelX);
                } else {
                    this.angle += (Math.random() - 0.5) * 0.5;
                }
            }

            constructionBehavior(nearbyRobots, nearbyResources, base, params) {
                // Build a structure by placing blocks in patterns
                if (this.state === 'searching') {
                    if (nearbyResources.length > 0) {
                        const target = nearbyResources.find(r => !r.placed);
                        if (target) {
                            this.angle = Math.atan2(target.y - this.y, target.x - this.x);
                            if (this.distTo(target) < 10) {
                                target.collected = true;
                                this.carrying = target;
                                this.state = 'carrying';
                            }
                        }
                    } else {
                        this.angle += (Math.random() - 0.5) * 0.3;
                    }
                } else if (this.state === 'carrying') {
                    // Find construction site near base
                    const buildX = base.x + Math.cos(Math.atan2(this.y - base.y, this.x - base.x)) * 60;
                    const buildY = base.y + Math.sin(Math.atan2(this.y - base.y, this.x - base.x)) * 60;

                    this.angle = Math.atan2(buildY - this.y, buildX - this.x);

                    if (Math.abs(this.x - buildX) < 15 && Math.abs(this.y - buildY) < 15) {
                        if (this.carrying) {
                            this.carrying.placed = true;
                            this.carrying.x = buildX + (Math.random() - 0.5) * 20;
                            this.carrying.y = buildY + (Math.random() - 0.5) * 20;
                            this.carrying.collected = false;
                        }
                        this.carrying = null;
                        this.state = 'searching';
                    }
                }
            }

            transportBehavior(nearbyRobots, nearbyResources, target, params) {
                // Coordinate to push large object
                const largeObject = { x: dims.width / 2, y: dims.height / 2, r: 40 };
                const distToObj = this.distTo(largeObject);

                if (distToObj < 60) {
                    // Push toward target
                    const pushAngle = Math.atan2(target.y - largeObject.y, target.x - largeObject.x);
                    const behindAngle = pushAngle + Math.PI;
                    const idealX = largeObject.x + Math.cos(behindAngle) * 50;
                    const idealY = largeObject.y + Math.sin(behindAngle) * 50;

                    this.angle = Math.atan2(idealY - this.y, idealX - this.x);

                    if (distToObj < 45) {
                        this.angle = pushAngle;
                    }
                } else {
                    // Move toward object
                    this.angle = Math.atan2(largeObject.y - this.y, largeObject.x - this.x);
                }

                // Avoid other robots
                for (const other of nearbyRobots) {
                    if (this.distTo(other) < 12) {
                        this.angle += (Math.random() - 0.5) * 1;
                    }
                }
            }

            sensePheromone(pheromones) {
                // Sample pheromone at left and right sensors
                const sensorDist = 15;
                const leftX = this.x + Math.cos(this.angle - 0.5) * sensorDist;
                const leftY = this.y + Math.sin(this.angle - 0.5) * sensorDist;
                const rightX = this.x + Math.cos(this.angle + 0.5) * sensorDist;
                const rightY = this.y + Math.sin(this.angle + 0.5) * sensorDist;

                let leftStrength = 0, rightStrength = 0;
                for (const p of pheromones) {
                    const dL = Math.sqrt((leftX - p.x) ** 2 + (leftY - p.y) ** 2);
                    const dR = Math.sqrt((rightX - p.x) ** 2 + (rightY - p.y) ** 2);
                    if (dL < 20) leftStrength += p.strength;
                    if (dR < 20) rightStrength += p.strength;
                }

                if (leftStrength + rightStrength > 0) {
                    return rightStrength / (leftStrength + rightStrength);
                }
                return null;
            }

            distTo(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Body
                ctx.fillStyle = this.state === 'carrying' ? '#81c784' : '#4fc3f7';
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();

                // Direction indicator
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(4, -4);
                ctx.lineTo(4, 4);
                ctx.closePath();
                ctx.fill();

                // Communication range indicator (faint)
                if (this.state === 'carrying') {
                    ctx.strokeStyle = 'rgba(129, 199, 132, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Carried resource
                if (this.carrying) {
                    ctx.fillStyle = '#ffb74d';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - 12, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        let state = {
            running: false,
            robots: [],
            resources: [],
            pheromones: [],
            base: { x: 0, y: 0 },
            collected: 0,
            time: 0,
            coverageGrid: null
        };

        function initSimulation() {
            const size = parseInt(document.getElementById('swarmSize').value);
            state.robots = [];
            state.resources = [];
            state.pheromones = [];
            state.collected = 0;
            state.time = 0;

            // Base location
            state.base = { x: dims.width / 2, y: dims.height / 2 };

            // Create robots
            for (let i = 0; i < size; i++) {
                const angle = (i / size) * Math.PI * 2;
                const r = 50 + Math.random() * 30;
                state.robots.push(new Robot(
                    state.base.x + Math.cos(angle) * r,
                    state.base.y + Math.sin(angle) * r
                ));
            }

            // Create resources (scattered)
            for (let i = 0; i < 50; i++) {
                let x, y;
                do {
                    x = Math.random() * (dims.width - 60) + 30;
                    y = Math.random() * (dims.height - 60) + 30;
                } while (Math.sqrt((x - state.base.x) ** 2 + (y - state.base.y) ** 2) < 100);

                state.resources.push({
                    x, y,
                    collected: false,
                    placed: false
                });
            }

            // Coverage grid
            const gridSize = 20;
            state.coverageGrid = [];
            for (let i = 0; i < Math.ceil(dims.width / gridSize); i++) {
                state.coverageGrid[i] = [];
                for (let j = 0; j < Math.ceil(dims.height / gridSize); j++) {
                    state.coverageGrid[i][j] = false;
                }
            }
        }

        function update() {
            if (!state.running) return;

            const task = document.getElementById('task').value;
            const params = {
                commRange: parseInt(document.getElementById('commRange').value),
                pheromone: parseInt(document.getElementById('pheromone').value)
            };

            state.time++;

            // Update robots
            for (const robot of state.robots) {
                const delivered = robot.update(
                    state.robots,
                    state.resources,
                    state.pheromones,
                    state.base,
                    task,
                    params
                );
                if (delivered) {
                    state.collected++;
                    // Leave pheromone trail
                    if (params.pheromone > 0) {
                        state.pheromones.push({
                            x: robot.x,
                            y: robot.y,
                            strength: params.pheromone / 100
                        });
                    }
                }

                // Update coverage grid
                if (task === 'coverage') {
                    const gridX = Math.floor(robot.x / 20);
                    const gridY = Math.floor(robot.y / 20);
                    if (state.coverageGrid[gridX] && state.coverageGrid[gridX][gridY] !== undefined) {
                        state.coverageGrid[gridX][gridY] = true;
                    }
                }
            }

            // Decay pheromones
            state.pheromones = state.pheromones.filter(p => {
                p.strength *= 0.995;
                return p.strength > 0.01;
            });

            updateStats(task);
            draw(task);
            requestAnimationFrame(update);
        }

        function draw(task) {
            // Background
            ctx.fillStyle = '#2d2d3a';
            ctx.fillRect(0, 0, dims.width, dims.height);

            // Grid
            ctx.strokeStyle = 'rgba(100, 100, 120, 0.2)';
            ctx.lineWidth = 1;
            for (let x = 0; x < dims.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, dims.height);
                ctx.stroke();
            }
            for (let y = 0; y < dims.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(dims.width, y);
                ctx.stroke();
            }

            // Coverage visualization
            if (task === 'coverage' && state.coverageGrid) {
                for (let i = 0; i < state.coverageGrid.length; i++) {
                    for (let j = 0; j < state.coverageGrid[i].length; j++) {
                        if (state.coverageGrid[i][j]) {
                            ctx.fillStyle = 'rgba(129, 199, 132, 0.2)';
                            ctx.fillRect(i * 20, j * 20, 20, 20);
                        }
                    }
                }
            }

            // Draw pheromones
            for (const p of state.pheromones) {
                ctx.fillStyle = `rgba(149, 117, 205, ${p.strength * 0.5})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8 + p.strength * 10, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw resources
            for (const r of state.resources) {
                if (!r.collected) {
                    ctx.fillStyle = r.placed ? '#9575cd' : '#ffb74d';
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw base
            ctx.fillStyle = '#ef5350';
            ctx.beginPath();
            ctx.arc(state.base.x, state.base.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Nunito';
            ctx.textAlign = 'center';
            ctx.fillText('BASE', state.base.x, state.base.y + 4);
            ctx.textAlign = 'left';

            // Transport task: draw large object
            if (task === 'transport') {
                ctx.fillStyle = '#ff7043';
                ctx.beginPath();
                ctx.arc(dims.width / 2, dims.height / 2, 40, 0, Math.PI * 2);
                ctx.fill();

                // Target
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(dims.width * 0.8, dims.height * 0.8, 45, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw robots
            for (const robot of state.robots) {
                robot.draw();
            }

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '14px Lora';
            ctx.fillText(`Swarm Robotics: ${task.charAt(0).toUpperCase() + task.slice(1)}`, 10, 25);
        }

        function updateStats(task) {
            const remaining = state.resources.filter(r => !r.collected).length;
            document.getElementById('collected').textContent = state.collected;
            document.getElementById('time').textContent = (state.time / 60).toFixed(1);

            // Calculate coverage
            if (task === 'coverage' && state.coverageGrid) {
                let covered = 0, total = 0;
                for (const row of state.coverageGrid) {
                    for (const cell of row) {
                        total++;
                        if (cell) covered++;
                    }
                }
                document.getElementById('coverage').textContent = Math.round(covered / total * 100) + '%';
            } else {
                document.getElementById('coverage').textContent = Math.round((50 - remaining) / 50 * 100) + '%';
            }

            // Efficiency (resources per time)
            const efficiency = state.time > 0 ? (state.collected / state.time * 60).toFixed(2) : 0;
            document.getElementById('efficiency').textContent = efficiency;
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            initSimulation();
            draw(document.getElementById('task').value);
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('swarmSizeVal').textContent = document.getElementById('swarmSize').value;
            document.getElementById('commRangeVal').textContent = document.getElementById('commRange').value;
            document.getElementById('pheromoneVal').textContent = document.getElementById('pheromone').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));

        initSimulation();
        draw('foraging');
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
