<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markov Chain Generative Music - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 320px; background: rgba(0,0,0,0.85); padding: 20px; overflow-y: auto; }
        h1 { font-family: 'Lora', serif; font-size: 1.3rem; margin-bottom: 15px; color: #ec4899; }
        .section-title { font-size: 0.9rem; color: #ec4899; margin: 15px 0 10px; border-bottom: 1px solid rgba(236,72,153,0.3); padding-bottom: 5px; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 4px; color: #aaa; }
        input[type="range"] { width: 100%; accent-color: #ec4899; }
        select { width: 100%; padding: 8px; background: #2d2d44; color: #fff; border: 1px solid #444; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: linear-gradient(135deg, #ec4899 0%, #be185d 100%); color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(236,72,153,0.3); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-secondary { background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); }
        .stats { background: rgba(255,255,255,0.08); padding: 12px; border-radius: 8px; font-size: 0.85rem; margin-top: 15px; }
        .stats div { margin: 5px 0; display: flex; justify-content: space-between; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #ec4899; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info-panel { background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%); padding: 15px; border-radius: 10px; margin-top: 15px; border: 1px solid rgba(236,72,153,0.2); }
        .info-panel h3 { font-family: 'Lora', serif; color: #ec4899; margin-bottom: 10px; font-size: 1rem; }
        .info-panel p { font-size: 0.8rem; line-height: 1.5; color: #ccc; }
        .note-row { display: flex; gap: 2px; margin-bottom: 2px; }
        .note-cell { flex: 1; height: 20px; font-size: 8px; display: flex; align-items: center; justify-content: center; border-radius: 2px; }
        #pianoRoll { margin-top: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; max-height: 200px; overflow-y: auto; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Markov Chain Music</h1>

            <div class="section-title">Markov Chain Settings</div>
            <div class="control-group">
                <label>Order (Memory): <span id="orderValue">2</span></label>
                <input type="range" id="order" min="1" max="4" step="1" value="2">
            </div>
            <div class="control-group">
                <label>Training Style:</label>
                <select id="style">
                    <option value="classical">Classical (Bach-like)</option>
                    <option value="jazz">Jazz (Chromatic)</option>
                    <option value="blues">Blues (Pentatonic)</option>
                    <option value="random">Random Transitions</option>
                </select>
            </div>
            <div class="control-group">
                <label>Tempo: <span id="tempoValue">120</span> BPM</label>
                <input type="range" id="tempo" min="60" max="200" step="10" value="120">
            </div>
            <div class="control-group">
                <label>Note Probability Bias: <span id="biasValue">0.5</span></label>
                <input type="range" id="bias" min="0" max="1" step="0.1" value="0.5">
            </div>

            <div class="section-title">Playback</div>
            <button id="generate">Generate Melody</button>
            <button id="play" class="btn-secondary" disabled>Play/Stop</button>
            <button id="reset">Reset Chain</button>

            <div class="stats">
                <div><span>States in Chain:</span><span id="stateCount">0</span></div>
                <div><span>Notes Generated:</span><span id="noteCount">0</span></div>
                <div><span>Current Note:</span><span id="currentNote">-</span></div>
                <div><span>Entropy:</span><span id="entropy">0.00</span></div>
            </div>

            <div id="pianoRoll"></div>

            <div class="info-panel">
                <h3>How It Works</h3>
                <p>This simulation uses Markov chains to generate melodies. The chain learns transition probabilities between note sequences, then generates new sequences statistically similar to the training data. Higher order = more memory of previous notes.</p>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        // Musical notes (C4 to C6)
        const NOTES = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5', 'C6'];
        const NOTE_FREQS = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00,
            'A4': 440.00, 'B4': 493.88, 'C5': 523.25, 'D5': 587.33, 'E5': 659.25,
            'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77, 'C6': 1046.50
        };

        let params = { order: 2, style: 'classical', tempo: 120, bias: 0.5 };
        let markovChain = {};
        let generatedMelody = [];
        let isPlaying = false;
        let audioCtx = null;
        let playIndex = 0;
        let playInterval = null;

        // Training patterns for different styles
        const TRAINING_DATA = {
            classical: [
                ['C4','E4','G4','C5','G4','E4'],
                ['C4','D4','E4','F4','G4','A4','G4','F4','E4','D4'],
                ['G4','A4','B4','C5','D5','C5','B4','A4','G4'],
                ['C4','G4','E4','C5','E4','G4','C4'],
                ['E4','F4','G4','A4','B4','C5','B4','A4','G4','F4','E4']
            ],
            jazz: [
                ['C4','Eb4','G4','Bb4','C5','Bb4','G4','Eb4'],
                ['D4','F4','Ab4','B4','D5','B4','Ab4','F4'],
                ['G4','A4','Bb4','B4','C5','B4','Bb4','A4','G4'],
                ['C4','E4','F4','F#4','G4','Bb4','B4','C5']
            ],
            blues: [
                ['C4','Eb4','F4','G4','Bb4','C5','Bb4','G4','F4','Eb4'],
                ['G4','Bb4','C5','Eb5','C5','Bb4','G4'],
                ['C4','Eb4','F4','F#4','G4','Bb4','G4','Eb4','C4'],
                ['Eb4','G4','Bb4','C5','Bb4','G4','Eb4']
            ],
            random: []
        };

        // Add sharps/flats to notes for jazz
        NOTES.push('Eb4', 'Bb4', 'F#4', 'Ab4', 'Eb5');
        NOTE_FREQS['Eb4'] = 311.13; NOTE_FREQS['Bb4'] = 466.16;
        NOTE_FREQS['F#4'] = 369.99; NOTE_FREQS['Ab4'] = 415.30;
        NOTE_FREQS['Eb5'] = 622.25;

        function resize() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);
        }

        function buildMarkovChain() {
            markovChain = {};
            const order = params.order;
            let trainingSet = TRAINING_DATA[params.style];

            if (params.style === 'random') {
                // Generate random training data
                trainingSet = [];
                for (let i = 0; i < 5; i++) {
                    const seq = [];
                    for (let j = 0; j < 10; j++) {
                        seq.push(NOTES[Math.floor(Math.random() * 15)]);
                    }
                    trainingSet.push(seq);
                }
            }

            for (const sequence of trainingSet) {
                for (let i = 0; i < sequence.length - order; i++) {
                    const state = sequence.slice(i, i + order).join('|');
                    const nextNote = sequence[i + order];

                    if (!markovChain[state]) {
                        markovChain[state] = {};
                    }
                    markovChain[state][nextNote] = (markovChain[state][nextNote] || 0) + 1;
                }
            }

            // Normalize probabilities
            for (const state in markovChain) {
                const total = Object.values(markovChain[state]).reduce((a, b) => a + b, 0);
                for (const note in markovChain[state]) {
                    markovChain[state][note] /= total;
                }
            }

            document.getElementById('stateCount').textContent = Object.keys(markovChain).length;
        }

        function getNextNote(history) {
            const order = params.order;
            if (history.length < order) {
                return NOTES[Math.floor(Math.random() * 15)];
            }

            const state = history.slice(-order).join('|');
            const transitions = markovChain[state];

            if (!transitions) {
                // Fall back to random if state not found
                return NOTES[Math.floor(Math.random() * 15)];
            }

            // Apply bias to make transitions more or less predictable
            const r = Math.random();
            let cumulative = 0;
            const entries = Object.entries(transitions);

            // Sort by probability (higher first when bias is high)
            entries.sort((a, b) => params.bias > 0.5 ? b[1] - a[1] : a[1] - b[1]);

            for (const [note, prob] of entries) {
                cumulative += prob;
                if (r <= cumulative) return note;
            }

            return entries[0][0];
        }

        function generateMelody(length = 32) {
            buildMarkovChain();
            generatedMelody = [];

            // Start with random notes from training data
            const trainingSet = TRAINING_DATA[params.style];
            if (trainingSet && trainingSet.length > 0) {
                const startSeq = trainingSet[Math.floor(Math.random() * trainingSet.length)];
                generatedMelody = startSeq.slice(0, params.order);
            } else {
                for (let i = 0; i < params.order; i++) {
                    generatedMelody.push(NOTES[Math.floor(Math.random() * 15)]);
                }
            }

            // Generate new notes using Markov chain
            for (let i = 0; i < length - params.order; i++) {
                const nextNote = getNextNote(generatedMelody);
                generatedMelody.push(nextNote);
            }

            document.getElementById('noteCount').textContent = generatedMelody.length;
            document.getElementById('play').disabled = false;
            updatePianoRoll();
            calculateEntropy();
        }

        function calculateEntropy() {
            // Calculate Shannon entropy of the melody
            const counts = {};
            for (const note of generatedMelody) {
                counts[note] = (counts[note] || 0) + 1;
            }

            let entropy = 0;
            const len = generatedMelody.length;
            for (const count of Object.values(counts)) {
                const p = count / len;
                if (p > 0) entropy -= p * Math.log2(p);
            }

            document.getElementById('entropy').textContent = entropy.toFixed(2);
        }

        function updatePianoRoll() {
            const container = document.getElementById('pianoRoll');
            container.innerHTML = '';

            const noteHeight = NOTES.slice(0, 15);
            for (let i = noteHeight.length - 1; i >= 0; i--) {
                const row = document.createElement('div');
                row.className = 'note-row';

                for (let j = 0; j < Math.min(generatedMelody.length, 32); j++) {
                    const cell = document.createElement('div');
                    cell.className = 'note-cell';

                    if (generatedMelody[j] === noteHeight[i]) {
                        cell.style.background = `hsl(${330 + j * 5}, 70%, 50%)`;
                    } else {
                        cell.style.background = 'rgba(255,255,255,0.05)';
                    }

                    row.appendChild(cell);
                }

                container.appendChild(row);
            }
        }

        function playNote(frequency, duration) {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function togglePlay() {
            if (isPlaying) {
                isPlaying = false;
                clearInterval(playInterval);
                document.getElementById('play').textContent = 'Play/Stop';
            } else {
                isPlaying = true;
                playIndex = 0;
                document.getElementById('play').textContent = 'Stop';

                const beatDuration = 60000 / params.tempo;

                playInterval = setInterval(() => {
                    if (playIndex >= generatedMelody.length) {
                        togglePlay();
                        return;
                    }

                    const note = generatedMelody[playIndex];
                    const freq = NOTE_FREQS[note];

                    if (freq) {
                        playNote(freq, beatDuration / 1000 * 0.8);
                    }

                    document.getElementById('currentNote').textContent = note;
                    playIndex++;
                    draw();
                }, beatDuration / 2);
            }
        }

        function draw() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;

            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            // Draw Markov chain visualization
            const states = Object.keys(markovChain);
            const radius = Math.min(w, h) * 0.35;
            const centerX = w / 2;
            const centerY = h / 2;

            if (states.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '18px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText('Click "Generate Melody" to build Markov chain', centerX, centerY);
                return;
            }

            // Draw state nodes
            const statePositions = {};
            states.forEach((state, i) => {
                const angle = (i / states.length) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                statePositions[state] = { x, y };
            });

            // Draw transitions
            ctx.lineWidth = 1;
            for (const state in markovChain) {
                const pos = statePositions[state];
                if (!pos) continue;

                for (const nextNote in markovChain[state]) {
                    const prob = markovChain[state][nextNote];

                    // Find states that end with this next note
                    for (const targetState in statePositions) {
                        if (targetState.endsWith(nextNote)) {
                            const targetPos = statePositions[targetState];

                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                            ctx.lineTo(targetPos.x, targetPos.y);
                            ctx.strokeStyle = `rgba(236, 72, 153, ${prob * 0.5})`;
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw state nodes
            for (const state in statePositions) {
                const pos = statePositions[state];
                const nodeSize = 20;

                // Check if this state is current
                let isCurrent = false;
                if (isPlaying && playIndex > 0 && playIndex <= generatedMelody.length) {
                    const currentState = generatedMelody.slice(Math.max(0, playIndex - params.order), playIndex).join('|');
                    isCurrent = state === currentState;
                }

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
                ctx.fillStyle = isCurrent ? '#ec4899' : '#3d3d5c';
                ctx.fill();
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = isCurrent ? 3 : 1;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = '9px Nunito';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const shortLabel = state.split('|').map(n => n.replace('4', '').replace('5', "′")).join('');
                ctx.fillText(shortLabel, pos.x, pos.y);
            }

            // Draw generated melody timeline at bottom
            const timelineY = h - 60;
            const noteWidth = (w - 100) / Math.min(generatedMelody.length, 32);

            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(50, timelineY - 20, w - 100, 40);

            for (let i = 0; i < Math.min(generatedMelody.length, 32); i++) {
                const note = generatedMelody[i];
                const noteIndex = NOTES.indexOf(note);
                const hue = 330 + (noteIndex / 15) * 60;

                ctx.fillStyle = i === playIndex - 1 ? '#fff' : `hsl(${hue}, 70%, 50%)`;
                ctx.fillRect(50 + i * noteWidth, timelineY - 15, noteWidth - 2, 30);

                ctx.fillStyle = '#000';
                ctx.font = '8px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(note.replace('4', '').replace('5', "'"), 50 + i * noteWidth + noteWidth / 2, timelineY);
            }

            // Title
            ctx.fillStyle = '#ec4899';
            ctx.font = 'bold 16px Lora';
            ctx.textAlign = 'center';
            ctx.fillText(`Order-${params.order} Markov Chain (${params.style})`, centerX, 30);
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('order').addEventListener('input', e => {
            params.order = parseInt(e.target.value);
            document.getElementById('orderValue').textContent = params.order;
        });

        document.getElementById('style').addEventListener('change', e => {
            params.style = e.target.value;
        });

        document.getElementById('tempo').addEventListener('input', e => {
            params.tempo = parseInt(e.target.value);
            document.getElementById('tempoValue').textContent = params.tempo;
        });

        document.getElementById('bias').addEventListener('input', e => {
            params.bias = parseFloat(e.target.value);
            document.getElementById('biasValue').textContent = params.bias.toFixed(1);
        });

        document.getElementById('generate').addEventListener('click', () => generateMelody(32));
        document.getElementById('play').addEventListener('click', togglePlay);
        document.getElementById('reset').addEventListener('click', () => {
            markovChain = {};
            generatedMelody = [];
            isPlaying = false;
            clearInterval(playInterval);
            document.getElementById('stateCount').textContent = '0';
            document.getElementById('noteCount').textContent = '0';
            document.getElementById('currentNote').textContent = '-';
            document.getElementById('entropy').textContent = '0.00';
            document.getElementById('pianoRoll').innerHTML = '';
            document.getElementById('play').disabled = true;
        });

        window.addEventListener('resize', resize);

        resize();
        animate();
    </script>
</body>
</html>
