<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Chambers & Filter Bubbles - NetLogo-Style Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #3498db, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .panel h3 {
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85em;
            color: #3498db;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-wrapper h4 {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #3498db;
            font-size: 0.95em;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #3498db;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .polarization-meter {
            height: 20px;
            background: linear-gradient(90deg, #3498db, #9b59b6, #e74c3c);
            border-radius: 10px;
            position: relative;
            margin-top: 5px;
        }

        .polarization-indicator {
            position: absolute;
            width: 4px;
            height: 26px;
            background: #fff;
            top: -3px;
            border-radius: 2px;
            transition: left 0.3s ease;
        }

        .exposure-bar {
            display: flex;
            height: 15px;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 5px;
        }

        .exposure-segment {
            height: 100%;
            transition: width 0.3s ease;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #3498db;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Echo Chambers & Filter Bubbles</h1>
            <p class="subtitle">Media Consumption, Opinion Polarization, and Exposure Diversity</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h3>Population Parameters</h3>

                <div class="control-group">
                    <label>Number of Agents</label>
                    <input type="range" id="numAgents" min="50" max="300" value="150">
                    <div class="value"><span id="numAgentsVal">150</span></div>
                </div>

                <div class="control-group">
                    <label>Network Type</label>
                    <select id="networkType">
                        <option value="homophily">Homophily-Based</option>
                        <option value="random">Random</option>
                        <option value="scaleFree">Scale-Free</option>
                        <option value="smallWorld">Small World</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Initial Opinion Distribution</label>
                    <select id="opinionDist">
                        <option value="uniform">Uniform</option>
                        <option value="bimodal">Bimodal (Pre-polarized)</option>
                        <option value="normal">Normal (Centered)</option>
                    </select>
                </div>

                <h3>Algorithm Parameters</h3>

                <div class="control-group">
                    <label>Filter Bubble Strength</label>
                    <input type="range" id="filterStrength" min="0" max="1" step="0.01" value="0.5">
                    <div class="value"><span id="filterStrengthVal">0.50</span></div>
                </div>

                <div class="control-group">
                    <label>Recommendation Algorithm</label>
                    <select id="algorithm">
                        <option value="similarity">Similarity-Based</option>
                        <option value="engagement">Engagement-Optimized</option>
                        <option value="diverse">Diversity-Promoting</option>
                        <option value="none">No Algorithm (Chronological)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Content Diversity</label>
                    <input type="range" id="contentDiversity" min="0" max="1" step="0.01" value="0.5">
                    <div class="value"><span id="contentDiversityVal">0.50</span></div>
                </div>

                <h3>Social Dynamics</h3>

                <div class="control-group">
                    <label>Social Influence Strength</label>
                    <input type="range" id="socialInfluence" min="0" max="1" step="0.01" value="0.3">
                    <div class="value"><span id="socialInfluenceVal">0.30</span></div>
                </div>

                <div class="control-group">
                    <label>Confirmation Bias</label>
                    <input type="range" id="confirmationBias" min="0" max="1" step="0.01" value="0.4">
                    <div class="value"><span id="confirmationBiasVal">0.40</span></div>
                </div>

                <div class="control-group">
                    <label>Network Rewiring Rate</label>
                    <input type="range" id="rewiringRate" min="0" max="0.1" step="0.001" value="0.01">
                    <div class="value"><span id="rewiringRateVal">0.010</span></div>
                </div>

                <h3>Simulation Control</h3>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-danger" id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="speed" min="1" max="20" value="5">
                    <div class="value"><span id="speedVal">5</span> steps/frame</div>
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <h4>Social Network & Opinions</h4>
                        <canvas id="networkCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Opinion Distribution Over Time</h4>
                        <canvas id="opinionCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Exposure Diversity</h4>
                        <canvas id="exposureCanvas" width="400" height="250"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Echo Chamber Detection</h4>
                        <canvas id="chamberCanvas" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Polarization Status</h3>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="timeStep">0</div>
                        <div class="label">Time Step</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="polarizationIndex">0.00</div>
                        <div class="label">Polarization</div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Polarization Meter</label>
                    <div class="polarization-meter">
                        <div class="polarization-indicator" id="polarizationIndicator" style="left: 50%;"></div>
                    </div>
                </div>

                <h3>Network Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="numChambers">0</div>
                        <div class="label">Echo Chambers</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="avgChamberSize">0</div>
                        <div class="label">Avg Chamber Size</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="modularity">0.00</div>
                        <div class="label">Modularity (Q)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="homophily">0.00</div>
                        <div class="label">Homophily Index</div>
                    </div>
                </div>

                <h3>Exposure Diversity</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="avgExposure">0.00</div>
                        <div class="label">Avg Exposure Range</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="crossCutting">0.0</div>
                        <div class="label">Cross-Cutting %</div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Average Content Exposure</label>
                    <div class="exposure-bar" id="exposureBar">
                        <div class="exposure-segment" style="background: #3498db; width: 50%"></div>
                        <div class="exposure-segment" style="background: #e74c3c; width: 50%"></div>
                    </div>
                </div>

                <h3>Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Liberal (-1)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>Moderate (0)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Conservative (+1)</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Filter Bubble Effect:</strong><br>
                    Algorithms that optimize for engagement often show users content
                    similar to their existing views, potentially creating echo chambers
                    and increasing polarization.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const networkCanvas = document.getElementById('networkCanvas');
        const opinionCanvas = document.getElementById('opinionCanvas');
        const exposureCanvas = document.getElementById('exposureCanvas');
        const chamberCanvas = document.getElementById('chamberCanvas');

        const netCtx = networkCanvas.getContext('2d');
        const opCtx = opinionCanvas.getContext('2d');
        const expCtx = exposureCanvas.getContext('2d');
        const chamCtx = chamberCanvas.getContext('2d');

        // Simulation state
        let agents = [];
        let edges = [];
        let content = [];
        let timeStep = 0;
        let isRunning = false;
        let animationId = null;
        let opinionHistory = [];
        let exposureHistory = [];
        let polarizationHistory = [];

        // Parameters
        let numAgents = 150;
        let networkType = 'homophily';
        let opinionDist = 'uniform';
        let filterStrength = 0.5;
        let algorithm = 'similarity';
        let contentDiversity = 0.5;
        let socialInfluence = 0.3;
        let confirmationBias = 0.4;
        let rewiringRate = 0.01;
        let speed = 5;

        // UI Elements
        const elements = {
            numAgents: document.getElementById('numAgents'),
            numAgentsVal: document.getElementById('numAgentsVal'),
            networkType: document.getElementById('networkType'),
            opinionDist: document.getElementById('opinionDist'),
            filterStrength: document.getElementById('filterStrength'),
            filterStrengthVal: document.getElementById('filterStrengthVal'),
            algorithm: document.getElementById('algorithm'),
            contentDiversity: document.getElementById('contentDiversity'),
            contentDiversityVal: document.getElementById('contentDiversityVal'),
            socialInfluence: document.getElementById('socialInfluence'),
            socialInfluenceVal: document.getElementById('socialInfluenceVal'),
            confirmationBias: document.getElementById('confirmationBias'),
            confirmationBiasVal: document.getElementById('confirmationBiasVal'),
            rewiringRate: document.getElementById('rewiringRate'),
            rewiringRateVal: document.getElementById('rewiringRateVal'),
            speed: document.getElementById('speed'),
            speedVal: document.getElementById('speedVal'),
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            timeStep: document.getElementById('timeStep'),
            polarizationIndex: document.getElementById('polarizationIndex'),
            polarizationIndicator: document.getElementById('polarizationIndicator'),
            numChambers: document.getElementById('numChambers'),
            avgChamberSize: document.getElementById('avgChamberSize'),
            modularity: document.getElementById('modularity'),
            homophily: document.getElementById('homophily'),
            avgExposure: document.getElementById('avgExposure'),
            crossCutting: document.getElementById('crossCutting'),
            exposureBar: document.getElementById('exposureBar')
        };

        // Generate initial opinion
        function generateOpinion() {
            switch (opinionDist) {
                case 'uniform':
                    return Math.random() * 2 - 1;
                case 'bimodal':
                    return Math.random() < 0.5 ?
                        -0.7 + (Math.random() - 0.5) * 0.4 :
                        0.7 + (Math.random() - 0.5) * 0.4;
                case 'normal':
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    return Math.max(-1, Math.min(1, z * 0.3));
                default:
                    return Math.random() * 2 - 1;
            }
        }

        // Initialize simulation
        function initialize() {
            agents = [];
            edges = [];
            content = [];
            timeStep = 0;
            opinionHistory = [];
            exposureHistory = [];
            polarizationHistory = [];

            const width = networkCanvas.width;
            const height = networkCanvas.height;

            // Create agents
            for (let i = 0; i < numAgents; i++) {
                const opinion = generateOpinion();
                agents.push({
                    id: i,
                    x: 0,
                    y: 0,
                    opinion: opinion,
                    initialOpinion: opinion,
                    exposure: { min: opinion, max: opinion },
                    recentContent: [],
                    neighbors: [],
                    chamber: -1
                });
            }

            // Position agents by opinion on x-axis
            agents.forEach(agent => {
                const angle = Math.random() * Math.PI * 2;
                const radius = 50 + Math.random() * 100;
                agent.x = width / 2 + (agent.opinion * width * 0.3) + Math.cos(angle) * radius * 0.3;
                agent.y = height / 2 + Math.sin(angle) * radius;
            });

            // Create network
            createNetwork();

            // Generate content pool
            generateContent();

            updateStats();
            draw();
        }

        // Create network based on type
        function createNetwork() {
            edges = [];
            agents.forEach(a => a.neighbors = []);

            const avgDegree = 6;

            switch (networkType) {
                case 'homophily':
                    createHomophilyNetwork(avgDegree);
                    break;
                case 'random':
                    createRandomNetwork(avgDegree);
                    break;
                case 'scaleFree':
                    createScaleFreeNetwork(avgDegree);
                    break;
                case 'smallWorld':
                    createSmallWorldNetwork(avgDegree);
                    break;
            }

            // Update neighbor lists
            edges.forEach(edge => {
                agents[edge[0]].neighbors.push(edge[1]);
                agents[edge[1]].neighbors.push(edge[0]);
            });
        }

        function createHomophilyNetwork(avgDegree) {
            // Connect agents with similar opinions
            for (let i = 0; i < numAgents; i++) {
                // Sort others by opinion similarity
                const others = agents.filter((_, j) => j !== i)
                    .map((a, j) => ({
                        idx: j >= i ? j + 1 : j,
                        diff: Math.abs(agents[i].opinion - a.opinion)
                    }))
                    .sort((a, b) => a.diff - b.diff);

                // Connect to most similar (with some randomness)
                let connections = 0;
                for (const other of others) {
                    if (connections >= avgDegree / 2) break;
                    if (Math.random() < 0.8 || other.diff < 0.3) {
                        const edgeExists = edges.some(e =>
                            (e[0] === i && e[1] === other.idx) ||
                            (e[0] === other.idx && e[1] === i)
                        );
                        if (!edgeExists) {
                            edges.push([i, other.idx]);
                            connections++;
                        }
                    }
                }
            }
        }

        function createRandomNetwork(avgDegree) {
            const edgeProb = avgDegree / numAgents;
            for (let i = 0; i < numAgents; i++) {
                for (let j = i + 1; j < numAgents; j++) {
                    if (Math.random() < edgeProb) {
                        edges.push([i, j]);
                    }
                }
            }
        }

        function createScaleFreeNetwork(avgDegree) {
            const m = Math.floor(avgDegree / 2);
            const degree = new Array(numAgents).fill(0);

            for (let i = 0; i < Math.min(m + 1, numAgents); i++) {
                for (let j = i + 1; j < Math.min(m + 1, numAgents); j++) {
                    edges.push([i, j]);
                    degree[i]++;
                    degree[j]++;
                }
            }

            for (let i = m + 1; i < numAgents; i++) {
                const totalDegree = degree.reduce((a, b) => a + b, 0);
                const connected = new Set();

                while (connected.size < m && connected.size < i) {
                    let cumulative = 0;
                    const r = Math.random() * totalDegree;

                    for (let j = 0; j < i; j++) {
                        cumulative += degree[j] + 1;
                        if (cumulative >= r) {
                            if (!connected.has(j)) {
                                connected.add(j);
                                edges.push([i, j]);
                                degree[i]++;
                                degree[j]++;
                            }
                            break;
                        }
                    }
                }
            }
        }

        function createSmallWorldNetwork(avgDegree) {
            const k = Math.floor(avgDegree / 2);
            const rewiringProb = 0.1;

            // Sort by opinion for ring
            const sorted = [...agents].sort((a, b) => a.opinion - b.opinion);
            const idxMap = new Map();
            sorted.forEach((a, i) => idxMap.set(a.id, i));

            for (let i = 0; i < numAgents; i++) {
                for (let j = 1; j <= k; j++) {
                    const target = (i + j) % numAgents;
                    edges.push([sorted[i].id, sorted[target].id]);
                }
            }

            edges.forEach((edge, idx) => {
                if (Math.random() < rewiringProb) {
                    const newTarget = Math.floor(Math.random() * numAgents);
                    if (newTarget !== edge[0] && newTarget !== edge[1]) {
                        edges[idx] = [edge[0], newTarget];
                    }
                }
            });
        }

        // Generate content pool
        function generateContent() {
            content = [];
            for (let i = 0; i < 100; i++) {
                // Content opinion based on diversity setting
                let opinion;
                if (contentDiversity > 0.5) {
                    opinion = Math.random() * 2 - 1;
                } else {
                    // More extreme content
                    opinion = Math.random() < 0.5 ? -1 + Math.random() * 0.5 : 1 - Math.random() * 0.5;
                }

                content.push({
                    id: i,
                    opinion: opinion,
                    engagement: 0.5 + Math.random() * 0.5
                });
            }
        }

        // Recommend content based on algorithm
        function recommendContent(agent) {
            let recommended;

            switch (algorithm) {
                case 'similarity':
                    // Filter bubble - show similar content
                    recommended = [...content]
                        .map(c => ({
                            content: c,
                            score: 1 - Math.abs(c.opinion - agent.opinion) * filterStrength
                        }))
                        .sort((a, b) => b.score - a.score)
                        .slice(0, 5)
                        .map(r => r.content);
                    break;

                case 'engagement':
                    // Optimize for engagement (often extreme content)
                    recommended = [...content]
                        .map(c => {
                            const alignment = 1 - Math.abs(c.opinion - agent.opinion);
                            const extremity = Math.abs(c.opinion);
                            return {
                                content: c,
                                score: (alignment * filterStrength + extremity * 0.5) * c.engagement
                            };
                        })
                        .sort((a, b) => b.score - a.score)
                        .slice(0, 5)
                        .map(r => r.content);
                    break;

                case 'diverse':
                    // Promote diversity
                    recommended = [...content]
                        .map(c => ({
                            content: c,
                            score: Math.random() + (1 - filterStrength) * Math.abs(c.opinion - agent.opinion)
                        }))
                        .sort((a, b) => b.score - a.score)
                        .slice(0, 5)
                        .map(r => r.content);
                    break;

                case 'none':
                default:
                    // Random/chronological
                    recommended = [...content]
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 5);
                    break;
            }

            return recommended;
        }

        // Simulation step
        function step() {
            timeStep++;

            // Each agent consumes content and interacts
            agents.forEach(agent => {
                // Get recommended content
                const recommended = recommendContent(agent);
                agent.recentContent = recommended.map(c => c.opinion);

                // Update exposure range
                recommended.forEach(c => {
                    agent.exposure.min = Math.min(agent.exposure.min, c.opinion);
                    agent.exposure.max = Math.max(agent.exposure.max, c.opinion);
                });

                // Content influence on opinion
                const avgContentOpinion = recommended.reduce((sum, c) => sum + c.opinion, 0) / recommended.length;

                // Confirmation bias - more influenced by agreeable content
                const contentDistance = Math.abs(avgContentOpinion - agent.opinion);
                const contentInfluence = (1 - confirmationBias * contentDistance) * 0.05;

                // Social influence from neighbors
                if (agent.neighbors.length > 0) {
                    const neighborOpinion = agent.neighbors.reduce((sum, nIdx) =>
                        sum + agents[nIdx].opinion, 0) / agent.neighbors.length;

                    const neighborDistance = Math.abs(neighborOpinion - agent.opinion);
                    const neighborInfluence = socialInfluence * (1 - confirmationBias * neighborDistance);

                    agent.opinion += neighborInfluence * (neighborOpinion - agent.opinion) * 0.1;
                }

                // Content influence
                agent.opinion += contentInfluence * (avgContentOpinion - agent.opinion);

                // Clamp opinion
                agent.opinion = Math.max(-1, Math.min(1, agent.opinion));
            });

            // Network rewiring (homophily-driven)
            if (Math.random() < rewiringRate * numAgents) {
                rewireNetwork();
            }

            // Update positions based on opinions
            updatePositions();

            // Detect echo chambers
            detectEchoChambers();

            // Record history
            recordHistory();

            updateStats();
        }

        // Rewire network based on homophily
        function rewireNetwork() {
            if (edges.length === 0) return;

            // Pick random edge
            const edgeIdx = Math.floor(Math.random() * edges.length);
            const edge = edges[edgeIdx];
            const agent = agents[edge[0]];

            // Find new connection with similar opinion
            const candidates = agents.filter(a =>
                a.id !== agent.id &&
                !agent.neighbors.includes(a.id) &&
                Math.abs(a.opinion - agent.opinion) < 0.5
            );

            if (candidates.length > 0) {
                const newNeighbor = candidates[Math.floor(Math.random() * candidates.length)];

                // Remove old edge
                const oldNeighbor = edge[1];
                agents[edge[0]].neighbors = agents[edge[0]].neighbors.filter(n => n !== oldNeighbor);
                agents[oldNeighbor].neighbors = agents[oldNeighbor].neighbors.filter(n => n !== edge[0]);

                // Add new edge
                edges[edgeIdx] = [agent.id, newNeighbor.id];
                agents[agent.id].neighbors.push(newNeighbor.id);
                agents[newNeighbor.id].neighbors.push(agent.id);
            }
        }

        // Update agent positions
        function updatePositions() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            agents.forEach(agent => {
                // Target x based on opinion
                const targetX = width / 2 + agent.opinion * width * 0.35;

                // Move towards target
                agent.x += (targetX - agent.x) * 0.1;

                // Slight vertical jitter
                agent.y += (Math.random() - 0.5) * 2;
                agent.y = Math.max(30, Math.min(height - 30, agent.y));
            });
        }

        // Detect echo chambers using simple clustering
        function detectEchoChambers() {
            // Reset chamber assignments
            agents.forEach(a => a.chamber = -1);

            let chamberCount = 0;

            // Simple connected components with opinion similarity
            agents.forEach((agent, i) => {
                if (agent.chamber === -1) {
                    // Start new chamber
                    const chamber = chamberCount++;
                    const queue = [i];
                    agent.chamber = chamber;

                    while (queue.length > 0) {
                        const current = queue.shift();
                        const currentAgent = agents[current];

                        currentAgent.neighbors.forEach(nIdx => {
                            const neighbor = agents[nIdx];
                            if (neighbor.chamber === -1 &&
                                Math.abs(neighbor.opinion - currentAgent.opinion) < 0.4) {
                                neighbor.chamber = chamber;
                                queue.push(nIdx);
                            }
                        });
                    }
                }
            });
        }

        // Record history for charts
        function recordHistory() {
            // Opinion histogram
            const bins = 10;
            const histogram = new Array(bins).fill(0);
            agents.forEach(agent => {
                const bin = Math.min(bins - 1, Math.floor((agent.opinion + 1) / 2 * bins));
                histogram[bin]++;
            });
            opinionHistory.push(histogram);
            if (opinionHistory.length > 200) opinionHistory.shift();

            // Exposure diversity
            const avgExposure = agents.reduce((sum, a) =>
                sum + (a.exposure.max - a.exposure.min), 0) / numAgents;
            exposureHistory.push(avgExposure);
            if (exposureHistory.length > 200) exposureHistory.shift();

            // Polarization
            const polarization = calculatePolarization();
            polarizationHistory.push(polarization);
            if (polarizationHistory.length > 200) polarizationHistory.shift();
        }

        // Calculate polarization index
        function calculatePolarization() {
            // Bimodality measure
            const opinions = agents.map(a => a.opinion);
            const mean = opinions.reduce((a, b) => a + b, 0) / opinions.length;
            const variance = opinions.reduce((sum, o) => sum + Math.pow(o - mean, 2), 0) / opinions.length;

            // Count at extremes
            const extreme = opinions.filter(o => Math.abs(o) > 0.6).length / opinions.length;

            return Math.min(1, variance + extreme * 0.5);
        }

        // Calculate modularity
        function calculateModularity() {
            if (edges.length === 0) return 0;

            const m = edges.length;
            let q = 0;

            // Get unique chambers
            const chambers = [...new Set(agents.map(a => a.chamber))];

            chambers.forEach(c => {
                const members = agents.filter(a => a.chamber === c);
                if (members.length === 0) return;

                // Edges within chamber
                let internalEdges = 0;
                let totalDegree = 0;

                members.forEach(member => {
                    totalDegree += member.neighbors.length;
                    member.neighbors.forEach(nIdx => {
                        if (agents[nIdx].chamber === c) {
                            internalEdges++;
                        }
                    });
                });

                internalEdges /= 2; // Counted twice
                q += internalEdges / m - Math.pow(totalDegree / (2 * m), 2);
            });

            return Math.max(0, q);
        }

        // Calculate homophily index
        function calculateHomophily() {
            if (edges.length === 0) return 0;

            let sameOpinion = 0;
            edges.forEach(edge => {
                const diff = Math.abs(agents[edge[0]].opinion - agents[edge[1]].opinion);
                if (diff < 0.3) sameOpinion++;
            });

            return sameOpinion / edges.length;
        }

        // Update statistics
        function updateStats() {
            elements.timeStep.textContent = timeStep;

            const polarization = calculatePolarization();
            elements.polarizationIndex.textContent = polarization.toFixed(2);
            elements.polarizationIndicator.style.left = (polarization * 100) + '%';

            // Echo chambers
            const chambers = [...new Set(agents.map(a => a.chamber))].filter(c => c >= 0);
            elements.numChambers.textContent = chambers.length;

            const chamberSizes = chambers.map(c => agents.filter(a => a.chamber === c).length);
            const avgSize = chamberSizes.length > 0 ?
                chamberSizes.reduce((a, b) => a + b, 0) / chamberSizes.length : 0;
            elements.avgChamberSize.textContent = avgSize.toFixed(1);

            elements.modularity.textContent = calculateModularity().toFixed(2);
            elements.homophily.textContent = calculateHomophily().toFixed(2);

            // Exposure diversity
            const avgExposure = agents.reduce((sum, a) =>
                sum + (a.exposure.max - a.exposure.min), 0) / numAgents;
            elements.avgExposure.textContent = avgExposure.toFixed(2);

            // Cross-cutting exposure
            const crossCutting = agents.filter(a =>
                a.exposure.min < 0 && a.exposure.max > 0).length / numAgents * 100;
            elements.crossCutting.textContent = crossCutting.toFixed(1);

            // Update exposure bar
            const leftExposure = agents.filter(a => a.opinion < 0).length / numAgents * 100;
            const rightExposure = 100 - leftExposure;
            elements.exposureBar.innerHTML = `
                <div class="exposure-segment" style="background: #3498db; width: ${leftExposure}%"></div>
                <div class="exposure-segment" style="background: #e74c3c; width: ${rightExposure}%"></div>
            `;
        }

        // Draw network
        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            netCtx.clearRect(0, 0, width, height);
            netCtx.fillStyle = '#1a1a2e';
            netCtx.fillRect(0, 0, width, height);

            // Draw opinion axis
            netCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            netCtx.lineWidth = 1;
            netCtx.beginPath();
            netCtx.moveTo(width * 0.15, height - 20);
            netCtx.lineTo(width * 0.85, height - 20);
            netCtx.stroke();

            netCtx.fillStyle = '#3498db';
            netCtx.font = '10px sans-serif';
            netCtx.textAlign = 'center';
            netCtx.fillText('Liberal', width * 0.15, height - 5);

            netCtx.fillStyle = '#e74c3c';
            netCtx.fillText('Conservative', width * 0.85, height - 5);

            // Draw edges
            edges.forEach(edge => {
                const a1 = agents[edge[0]];
                const a2 = agents[edge[1]];

                const crossCutting = (a1.opinion < 0) !== (a2.opinion < 0);
                netCtx.strokeStyle = crossCutting ?
                    'rgba(155, 89, 182, 0.3)' : 'rgba(255, 255, 255, 0.1)';
                netCtx.lineWidth = crossCutting ? 1 : 0.5;

                netCtx.beginPath();
                netCtx.moveTo(a1.x, a1.y);
                netCtx.lineTo(a2.x, a2.y);
                netCtx.stroke();
            });

            // Draw agents
            agents.forEach(agent => {
                // Color based on opinion (blue to purple to red)
                const hue = (1 - (agent.opinion + 1) / 2) * 240;
                netCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;

                const radius = 4;
                netCtx.beginPath();
                netCtx.arc(agent.x, agent.y, radius, 0, Math.PI * 2);
                netCtx.fill();
            });
        }

        // Draw opinion distribution
        function drawOpinionDistribution() {
            const width = opinionCanvas.width;
            const height = opinionCanvas.height;
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            opCtx.clearRect(0, 0, width, height);
            opCtx.fillStyle = '#1a1a2e';
            opCtx.fillRect(0, 0, width, height);

            // Axes
            opCtx.strokeStyle = '#666';
            opCtx.lineWidth = 1;
            opCtx.beginPath();
            opCtx.moveTo(margin.left, margin.top);
            opCtx.lineTo(margin.left, height - margin.bottom);
            opCtx.lineTo(width - margin.right, height - margin.bottom);
            opCtx.stroke();

            // Labels
            opCtx.fillStyle = '#aaa';
            opCtx.font = '11px sans-serif';
            opCtx.textAlign = 'center';
            opCtx.fillText('Time', width / 2, height - 5);

            opCtx.save();
            opCtx.translate(12, height / 2);
            opCtx.rotate(-Math.PI / 2);
            opCtx.fillText('Opinion', 0, 0);
            opCtx.restore();

            if (opinionHistory.length < 2) return;

            const bins = opinionHistory[0].length;
            const maxCount = Math.max(...opinionHistory.flat(), 1);

            // Draw heatmap
            opinionHistory.forEach((histogram, t) => {
                const x = margin.left + (t / opinionHistory.length) * chartWidth;
                const binWidth = chartWidth / opinionHistory.length + 1;

                histogram.forEach((count, b) => {
                    const y = margin.top + (1 - b / bins) * chartHeight;
                    const binHeight = chartHeight / bins + 1;

                    const intensity = count / maxCount;
                    const hue = (1 - b / bins) * 240; // Blue to red
                    opCtx.fillStyle = `hsla(${hue}, 70%, 50%, ${intensity})`;
                    opCtx.fillRect(x, y - binHeight, binWidth, binHeight);
                });
            });

            // Draw mean opinion line
            opCtx.strokeStyle = '#fff';
            opCtx.lineWidth = 2;
            opCtx.beginPath();

            opinionHistory.forEach((histogram, t) => {
                // Calculate mean from histogram
                let sum = 0, total = 0;
                histogram.forEach((count, b) => {
                    const opinion = (b / bins) * 2 - 1;
                    sum += opinion * count;
                    total += count;
                });
                const mean = total > 0 ? sum / total : 0;

                const x = margin.left + (t / opinionHistory.length) * chartWidth;
                const y = margin.top + (1 - (mean + 1) / 2) * chartHeight;

                if (t === 0) {
                    opCtx.moveTo(x, y);
                } else {
                    opCtx.lineTo(x, y);
                }
            });
            opCtx.stroke();
        }

        // Draw exposure diversity
        function drawExposureDiversity() {
            const width = exposureCanvas.width;
            const height = exposureCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            expCtx.clearRect(0, 0, width, height);
            expCtx.fillStyle = '#1a1a2e';
            expCtx.fillRect(0, 0, width, height);

            // Axes
            expCtx.strokeStyle = '#666';
            expCtx.lineWidth = 1;
            expCtx.beginPath();
            expCtx.moveTo(margin.left, margin.top);
            expCtx.lineTo(margin.left, height - margin.bottom);
            expCtx.lineTo(width - margin.right, height - margin.bottom);
            expCtx.stroke();

            // Labels
            expCtx.fillStyle = '#aaa';
            expCtx.font = '10px sans-serif';
            expCtx.textAlign = 'center';
            expCtx.fillText('Time', width / 2, height - 5);

            expCtx.save();
            expCtx.translate(10, height / 2);
            expCtx.rotate(-Math.PI / 2);
            expCtx.fillText('Diversity', 0, 0);
            expCtx.restore();

            if (exposureHistory.length < 2) return;

            // Draw exposure diversity
            expCtx.strokeStyle = '#27ae60';
            expCtx.lineWidth = 2;
            expCtx.beginPath();

            exposureHistory.forEach((exp, i) => {
                const x = margin.left + (i / exposureHistory.length) * chartWidth;
                const y = margin.top + (1 - exp / 2) * chartHeight;

                if (i === 0) {
                    expCtx.moveTo(x, y);
                } else {
                    expCtx.lineTo(x, y);
                }
            });
            expCtx.stroke();

            // Draw polarization
            expCtx.strokeStyle = '#e74c3c';
            expCtx.beginPath();

            polarizationHistory.forEach((pol, i) => {
                const x = margin.left + (i / polarizationHistory.length) * chartWidth;
                const y = margin.top + (1 - pol) * chartHeight;

                if (i === 0) {
                    expCtx.moveTo(x, y);
                } else {
                    expCtx.lineTo(x, y);
                }
            });
            expCtx.stroke();

            // Legend
            expCtx.fillStyle = '#27ae60';
            expCtx.font = '10px sans-serif';
            expCtx.textAlign = 'left';
            expCtx.fillText('Exposure', margin.left + 10, margin.top + 15);

            expCtx.fillStyle = '#e74c3c';
            expCtx.fillText('Polarization', margin.left + 70, margin.top + 15);
        }

        // Draw echo chamber visualization
        function drawEchoChambers() {
            const width = chamberCanvas.width;
            const height = chamberCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            chamCtx.clearRect(0, 0, width, height);
            chamCtx.fillStyle = '#1a1a2e';
            chamCtx.fillRect(0, 0, width, height);

            // Axes
            chamCtx.strokeStyle = '#666';
            chamCtx.lineWidth = 1;
            chamCtx.beginPath();
            chamCtx.moveTo(margin.left, margin.top);
            chamCtx.lineTo(margin.left, height - margin.bottom);
            chamCtx.lineTo(width - margin.right, height - margin.bottom);
            chamCtx.stroke();

            // Labels
            chamCtx.fillStyle = '#aaa';
            chamCtx.font = '10px sans-serif';
            chamCtx.textAlign = 'center';
            chamCtx.fillText('Opinion', width / 2, height - 5);

            chamCtx.save();
            chamCtx.translate(10, height / 2);
            chamCtx.rotate(-Math.PI / 2);
            chamCtx.fillText('Count', 0, 0);
            chamCtx.restore();

            // Draw current opinion histogram with chamber coloring
            const bins = 20;
            const histogram = new Array(bins).fill(0);
            const chamberColors = ['#3498db', '#e74c3c', '#27ae60', '#f39c12', '#9b59b6', '#1abc9c'];

            // Count by chamber
            const chamberHistograms = {};
            agents.forEach(agent => {
                const bin = Math.min(bins - 1, Math.floor((agent.opinion + 1) / 2 * bins));
                histogram[bin]++;

                if (!chamberHistograms[agent.chamber]) {
                    chamberHistograms[agent.chamber] = new Array(bins).fill(0);
                }
                chamberHistograms[agent.chamber][bin]++;
            });

            const maxCount = Math.max(...histogram, 1);
            const barWidth = chartWidth / bins;

            // Draw stacked bars by chamber
            const chambers = Object.keys(chamberHistograms).sort((a, b) => parseInt(a) - parseInt(b));

            for (let b = 0; b < bins; b++) {
                let yOffset = 0;
                const x = margin.left + b * barWidth;

                chambers.forEach((chamber, cIdx) => {
                    const count = chamberHistograms[chamber][b];
                    const barHeight = (count / maxCount) * chartHeight;

                    chamCtx.fillStyle = chamberColors[cIdx % chamberColors.length];
                    chamCtx.fillRect(x, height - margin.bottom - yOffset - barHeight, barWidth - 1, barHeight);

                    yOffset += barHeight;
                });
            }

            // X-axis labels
            chamCtx.fillStyle = '#aaa';
            chamCtx.font = '9px sans-serif';
            chamCtx.fillText('-1', margin.left, height - margin.bottom + 12);
            chamCtx.fillText('0', margin.left + chartWidth / 2, height - margin.bottom + 12);
            chamCtx.textAlign = 'right';
            chamCtx.fillText('+1', margin.left + chartWidth, height - margin.bottom + 12);
        }

        // Main draw function
        function draw() {
            drawNetwork();
            drawOpinionDistribution();
            drawExposureDiversity();
            drawEchoChambers();
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;

            for (let i = 0; i < speed; i++) {
                step();
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        elements.numAgents.addEventListener('input', (e) => {
            numAgents = parseInt(e.target.value);
            elements.numAgentsVal.textContent = numAgents;
        });

        elements.networkType.addEventListener('change', (e) => {
            networkType = e.target.value;
        });

        elements.opinionDist.addEventListener('change', (e) => {
            opinionDist = e.target.value;
        });

        elements.filterStrength.addEventListener('input', (e) => {
            filterStrength = parseFloat(e.target.value);
            elements.filterStrengthVal.textContent = filterStrength.toFixed(2);
        });

        elements.algorithm.addEventListener('change', (e) => {
            algorithm = e.target.value;
        });

        elements.contentDiversity.addEventListener('input', (e) => {
            contentDiversity = parseFloat(e.target.value);
            elements.contentDiversityVal.textContent = contentDiversity.toFixed(2);
            generateContent();
        });

        elements.socialInfluence.addEventListener('input', (e) => {
            socialInfluence = parseFloat(e.target.value);
            elements.socialInfluenceVal.textContent = socialInfluence.toFixed(2);
        });

        elements.confirmationBias.addEventListener('input', (e) => {
            confirmationBias = parseFloat(e.target.value);
            elements.confirmationBiasVal.textContent = confirmationBias.toFixed(2);
        });

        elements.rewiringRate.addEventListener('input', (e) => {
            rewiringRate = parseFloat(e.target.value);
            elements.rewiringRateVal.textContent = rewiringRate.toFixed(3);
        });

        elements.speed.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            elements.speedVal.textContent = speed;
        });

        elements.startBtn.addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                elements.startBtn.textContent = 'Running...';
                animate();
            }
        });

        elements.pauseBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        });

        elements.resetBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            initialize();
        });

        // Initialize
        initialize();
    </script>
</body>
</html>
