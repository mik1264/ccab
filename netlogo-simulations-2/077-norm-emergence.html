<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Norm Emergence - NetLogo-Style Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .panel h3 {
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85em;
            color: #3498db;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #9b59b6);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-wrapper h4 {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #3498db;
            font-size: 0.95em;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #3498db;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .norm-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .norm-emerging {
            background: rgba(243, 156, 18, 0.3);
            color: #f39c12;
        }

        .norm-crystallized {
            background: rgba(39, 174, 96, 0.3);
            color: #27ae60;
        }

        .norm-contested {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .event-log {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.8em;
        }

        .event-item {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .event-item:last-child {
            border-bottom: none;
        }

        .event-punishment {
            color: #e74c3c;
        }

        .event-adoption {
            color: #27ae60;
        }

        .event-violation {
            color: #f39c12;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #3498db;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Social Norm Emergence</h1>
            <p class="subtitle">Norm Crystallization, Punishment, and Change Without Top-Down Enforcement</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h3>Population Parameters</h3>

                <div class="control-group">
                    <label>Population Size</label>
                    <input type="range" id="populationSize" min="50" max="500" value="200">
                    <div class="value"><span id="populationSizeVal">200</span></div>
                </div>

                <div class="control-group">
                    <label>Network Type</label>
                    <select id="networkType">
                        <option value="random">Random Network</option>
                        <option value="smallWorld">Small World</option>
                        <option value="scaleFree">Scale-Free</option>
                        <option value="lattice">Spatial Lattice</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Average Connections</label>
                    <input type="range" id="avgConnections" min="2" max="20" value="8">
                    <div class="value"><span id="avgConnectionsVal">8</span></div>
                </div>

                <h3>Norm Dynamics</h3>

                <div class="control-group">
                    <label>Number of Norm Variants</label>
                    <input type="range" id="numNorms" min="2" max="6" value="3">
                    <div class="value"><span id="numNormsVal">3</span></div>
                </div>

                <div class="control-group">
                    <label>Conformity Pressure</label>
                    <input type="range" id="conformityPressure" min="0" max="1" step="0.01" value="0.6">
                    <div class="value"><span id="conformityPressureVal">0.60</span></div>
                </div>

                <div class="control-group">
                    <label>Innovation Rate</label>
                    <input type="range" id="innovationRate" min="0" max="0.1" step="0.001" value="0.01">
                    <div class="value"><span id="innovationRateVal">0.010</span></div>
                </div>

                <h3>Punishment Parameters</h3>

                <div class="control-group">
                    <label>Punishment Probability</label>
                    <input type="range" id="punishmentProb" min="0" max="1" step="0.01" value="0.3">
                    <div class="value"><span id="punishmentProbVal">0.30</span></div>
                </div>

                <div class="control-group">
                    <label>Punishment Severity</label>
                    <input type="range" id="punishmentSeverity" min="0" max="1" step="0.01" value="0.5">
                    <div class="value"><span id="punishmentSeverityVal">0.50</span></div>
                </div>

                <div class="control-group">
                    <label>Cost of Punishing</label>
                    <input type="range" id="punishmentCost" min="0" max="0.5" step="0.01" value="0.1">
                    <div class="value"><span id="punishmentCostVal">0.10</span></div>
                </div>

                <h3>Simulation Control</h3>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-danger" id="resetBtn">Reset</button>
                </div>

                <div class="button-group">
                    <button class="btn-secondary" id="shockBtn">External Shock</button>
                </div>

                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="speed" min="1" max="20" value="5">
                    <div class="value"><span id="speedVal">5</span> steps/frame</div>
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <h4>Social Network</h4>
                        <canvas id="networkCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Norm Adoption Over Time</h4>
                        <canvas id="adoptionCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Internalization Distribution</h4>
                        <canvas id="internalizationCanvas" width="400" height="250"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Punishment & Violation Rates</h4>
                        <canvas id="punishmentCanvas" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Norm Status</h3>

                <div class="norm-status norm-emerging" id="normStatus">EMERGING</div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="generation">0</div>
                        <div class="label">Time Step</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="dominantNorm">-</div>
                        <div class="label">Dominant Norm</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="dominantShare">0</div>
                        <div class="label">Dominant Share (%)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="entropy">1.00</div>
                        <div class="label">Norm Entropy</div>
                    </div>
                </div>

                <h3>Dynamics Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="violations">0</div>
                        <div class="label">Violations</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="punishments">0</div>
                        <div class="label">Punishments</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="avgInternalization">0.00</div>
                        <div class="label">Avg Internalization</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="normChanges">0</div>
                        <div class="label">Norm Changes</div>
                    </div>
                </div>

                <h3>Recent Events</h3>
                <div class="event-log" id="eventLog"></div>

                <h3>Legend</h3>
                <div class="legend" id="normLegend"></div>

                <div class="info-box">
                    <strong>Norm Crystallization:</strong><br>
                    A norm becomes crystallized when >80% of agents adopt it and average internalization exceeds 0.7.
                    Violations decrease as norms become internalized.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const networkCanvas = document.getElementById('networkCanvas');
        const adoptionCanvas = document.getElementById('adoptionCanvas');
        const internalizationCanvas = document.getElementById('internalizationCanvas');
        const punishmentCanvas = document.getElementById('punishmentCanvas');

        const netCtx = networkCanvas.getContext('2d');
        const adoptCtx = adoptionCanvas.getContext('2d');
        const internCtx = internalizationCanvas.getContext('2d');
        const punCtx = punishmentCanvas.getContext('2d');

        // Norm colors
        const normColors = ['#3498db', '#e74c3c', '#27ae60', '#f39c12', '#9b59b6', '#1abc9c'];

        // Simulation state
        let agents = [];
        let edges = [];
        let generation = 0;
        let isRunning = false;
        let animationId = null;
        let normHistory = [];
        let punishmentHistory = [];
        let violationHistory = [];
        let events = [];
        let totalViolations = 0;
        let totalPunishments = 0;
        let totalNormChanges = 0;

        // Parameters
        let populationSize = 200;
        let networkType = 'random';
        let avgConnections = 8;
        let numNorms = 3;
        let conformityPressure = 0.6;
        let innovationRate = 0.01;
        let punishmentProb = 0.3;
        let punishmentSeverity = 0.5;
        let punishmentCost = 0.1;
        let speed = 5;

        // UI Elements
        const elements = {
            populationSize: document.getElementById('populationSize'),
            populationSizeVal: document.getElementById('populationSizeVal'),
            networkType: document.getElementById('networkType'),
            avgConnections: document.getElementById('avgConnections'),
            avgConnectionsVal: document.getElementById('avgConnectionsVal'),
            numNorms: document.getElementById('numNorms'),
            numNormsVal: document.getElementById('numNormsVal'),
            conformityPressure: document.getElementById('conformityPressure'),
            conformityPressureVal: document.getElementById('conformityPressureVal'),
            innovationRate: document.getElementById('innovationRate'),
            innovationRateVal: document.getElementById('innovationRateVal'),
            punishmentProb: document.getElementById('punishmentProb'),
            punishmentProbVal: document.getElementById('punishmentProbVal'),
            punishmentSeverity: document.getElementById('punishmentSeverity'),
            punishmentSeverityVal: document.getElementById('punishmentSeverityVal'),
            punishmentCost: document.getElementById('punishmentCost'),
            punishmentCostVal: document.getElementById('punishmentCostVal'),
            speed: document.getElementById('speed'),
            speedVal: document.getElementById('speedVal'),
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            shockBtn: document.getElementById('shockBtn'),
            generation: document.getElementById('generation'),
            dominantNorm: document.getElementById('dominantNorm'),
            dominantShare: document.getElementById('dominantShare'),
            entropy: document.getElementById('entropy'),
            violations: document.getElementById('violations'),
            punishments: document.getElementById('punishments'),
            avgInternalization: document.getElementById('avgInternalization'),
            normChanges: document.getElementById('normChanges'),
            normStatus: document.getElementById('normStatus'),
            eventLog: document.getElementById('eventLog'),
            normLegend: document.getElementById('normLegend')
        };

        // Initialize simulation
        function initialize() {
            agents = [];
            edges = [];
            generation = 0;
            normHistory = [];
            punishmentHistory = [];
            violationHistory = [];
            events = [];
            totalViolations = 0;
            totalPunishments = 0;
            totalNormChanges = 0;

            const width = networkCanvas.width;
            const height = networkCanvas.height;

            // Create agents
            for (let i = 0; i < populationSize; i++) {
                const angle = (i / populationSize) * Math.PI * 2;
                const radius = Math.min(width, height) * 0.35;

                agents.push({
                    id: i,
                    x: width / 2 + radius * Math.cos(angle) + (Math.random() - 0.5) * 50,
                    y: height / 2 + radius * Math.sin(angle) + (Math.random() - 0.5) * 50,
                    norm: Math.floor(Math.random() * numNorms),
                    internalization: 0.1 + Math.random() * 0.3, // Initial internalization is low
                    neighbors: [],
                    lastViolation: 0,
                    punished: false
                });
            }

            // Create network
            createNetwork();

            // Update legend
            updateLegend();
            updateStats();
            draw();
        }

        // Create network based on type
        function createNetwork() {
            edges = [];

            switch (networkType) {
                case 'random':
                    createRandomNetwork();
                    break;
                case 'smallWorld':
                    createSmallWorldNetwork();
                    break;
                case 'scaleFree':
                    createScaleFreeNetwork();
                    break;
                case 'lattice':
                    createLatticeNetwork();
                    break;
            }

            // Update neighbor lists
            agents.forEach(agent => agent.neighbors = []);
            edges.forEach(edge => {
                agents[edge[0]].neighbors.push(edge[1]);
                agents[edge[1]].neighbors.push(edge[0]);
            });
        }

        function createRandomNetwork() {
            const edgeProb = avgConnections / populationSize;
            for (let i = 0; i < populationSize; i++) {
                for (let j = i + 1; j < populationSize; j++) {
                    if (Math.random() < edgeProb) {
                        edges.push([i, j]);
                    }
                }
            }
        }

        function createSmallWorldNetwork() {
            // Watts-Strogatz small world
            const k = Math.floor(avgConnections / 2);
            const rewiringProb = 0.1;

            // Create ring lattice
            for (let i = 0; i < populationSize; i++) {
                for (let j = 1; j <= k; j++) {
                    const target = (i + j) % populationSize;
                    edges.push([i, target]);
                }
            }

            // Rewire
            edges.forEach((edge, idx) => {
                if (Math.random() < rewiringProb) {
                    const newTarget = Math.floor(Math.random() * populationSize);
                    if (newTarget !== edge[0] && newTarget !== edge[1]) {
                        edges[idx] = [edge[0], newTarget];
                    }
                }
            });
        }

        function createScaleFreeNetwork() {
            // Barabasi-Albert preferential attachment
            const m = Math.floor(avgConnections / 2);
            const degree = new Array(populationSize).fill(0);

            // Start with fully connected core
            for (let i = 0; i < m + 1; i++) {
                for (let j = i + 1; j < m + 1; j++) {
                    edges.push([i, j]);
                    degree[i]++;
                    degree[j]++;
                }
            }

            // Add remaining nodes with preferential attachment
            for (let i = m + 1; i < populationSize; i++) {
                const totalDegree = degree.reduce((a, b) => a + b, 0);
                const connected = new Set();

                while (connected.size < m) {
                    let target = 0;
                    let cumulative = 0;
                    const r = Math.random() * totalDegree;

                    for (let j = 0; j < i; j++) {
                        cumulative += degree[j] + 1;
                        if (cumulative >= r) {
                            target = j;
                            break;
                        }
                    }

                    if (!connected.has(target)) {
                        connected.add(target);
                        edges.push([i, target]);
                        degree[i]++;
                        degree[target]++;
                    }
                }
            }
        }

        function createLatticeNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            const cols = Math.ceil(Math.sqrt(populationSize));
            const cellWidth = width / cols;
            const cellHeight = height / cols;

            // Position agents in grid
            agents.forEach((agent, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                agent.x = cellWidth * (col + 0.5);
                agent.y = cellHeight * (row + 0.5);
            });

            // Connect to neighbors in grid
            for (let i = 0; i < populationSize; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);

                // Right neighbor
                if (col < cols - 1 && i + 1 < populationSize) {
                    edges.push([i, i + 1]);
                }
                // Bottom neighbor
                if (i + cols < populationSize) {
                    edges.push([i, i + cols]);
                }
                // Diagonal neighbors for more connections
                if (col < cols - 1 && i + cols + 1 < populationSize) {
                    edges.push([i, i + cols + 1]);
                }
                if (col > 0 && i + cols - 1 < populationSize) {
                    edges.push([i, i + cols - 1]);
                }
            }
        }

        // Simulation step
        function step() {
            generation++;
            let stepViolations = 0;
            let stepPunishments = 0;

            // Each agent interacts
            agents.forEach(agent => {
                if (agent.neighbors.length === 0) return;

                // Pick random neighbor
                const neighborIdx = agent.neighbors[Math.floor(Math.random() * agent.neighbors.length)];
                const neighbor = agents[neighborIdx];

                // Check for norm violation (different norms)
                if (agent.norm !== neighbor.norm) {
                    stepViolations++;
                    totalViolations++;
                    agent.lastViolation = generation;

                    // Punishment decision
                    const punishDecision = Math.random() < punishmentProb *
                        (1 - agent.internalization * 0.5); // Internalized agents punish less

                    if (punishDecision) {
                        stepPunishments++;
                        totalPunishments++;

                        // Apply punishment
                        neighbor.internalization -= punishmentSeverity * 0.1;
                        neighbor.internalization = Math.max(0, neighbor.internalization);
                        neighbor.punished = true;

                        // Cost to punisher
                        agent.internalization -= punishmentCost;
                        agent.internalization = Math.max(0, agent.internalization);

                        addEvent(`Agent ${agent.id} punished ${neighbor.id} for violating norm`, 'punishment');
                    }

                    // Conformity pressure may cause norm change
                    if (Math.random() < conformityPressure * (1 - neighbor.internalization)) {
                        // Count neighbor's norm followers
                        let neighborNormCount = 0;
                        neighbor.neighbors.forEach(nIdx => {
                            if (agents[nIdx].norm === agent.norm) neighborNormCount++;
                        });

                        const majorityPressure = neighborNormCount / neighbor.neighbors.length;

                        if (Math.random() < majorityPressure) {
                            const oldNorm = neighbor.norm;
                            neighbor.norm = agent.norm;
                            neighbor.internalization = 0.1; // Reset internalization
                            totalNormChanges++;
                            addEvent(`Agent ${neighbor.id} changed from norm ${oldNorm} to ${agent.norm}`, 'adoption');
                        }
                    }
                } else {
                    // Same norm - reinforce internalization
                    agent.internalization += 0.01;
                    neighbor.internalization += 0.01;
                    agent.internalization = Math.min(1, agent.internalization);
                    neighbor.internalization = Math.min(1, neighbor.internalization);
                }

                // Innovation - random norm change
                if (Math.random() < innovationRate) {
                    const oldNorm = agent.norm;
                    agent.norm = Math.floor(Math.random() * numNorms);
                    if (agent.norm !== oldNorm) {
                        agent.internalization = 0.1;
                        totalNormChanges++;
                        addEvent(`Agent ${agent.id} innovated new norm ${agent.norm}`, 'violation');
                    }
                }

                // Natural internalization increase over time
                if (generation - agent.lastViolation > 10) {
                    agent.internalization += 0.005;
                    agent.internalization = Math.min(1, agent.internalization);
                }

                agent.punished = false;
            });

            // Record history
            recordHistory();
            punishmentHistory.push(stepPunishments);
            violationHistory.push(stepViolations);

            if (punishmentHistory.length > 500) punishmentHistory.shift();
            if (violationHistory.length > 500) violationHistory.shift();
        }

        // Record norm adoption history
        function recordHistory() {
            const counts = new Array(numNorms).fill(0);
            agents.forEach(agent => counts[agent.norm]++);
            normHistory.push(counts.map(c => c / populationSize));

            if (normHistory.length > 500) normHistory.shift();
        }

        // Add event to log
        function addEvent(text, type) {
            events.unshift({ text, type, time: generation });
            if (events.length > 20) events.pop();
        }

        // Calculate entropy of norm distribution
        function calculateEntropy() {
            const counts = new Array(numNorms).fill(0);
            agents.forEach(agent => counts[agent.norm]++);

            let entropy = 0;
            counts.forEach(c => {
                if (c > 0) {
                    const p = c / populationSize;
                    entropy -= p * Math.log2(p);
                }
            });

            return entropy / Math.log2(numNorms); // Normalize to 0-1
        }

        // Get dominant norm info
        function getDominantNorm() {
            const counts = new Array(numNorms).fill(0);
            agents.forEach(agent => counts[agent.norm]++);

            let maxNorm = 0;
            let maxCount = counts[0];
            counts.forEach((c, i) => {
                if (c > maxCount) {
                    maxCount = c;
                    maxNorm = i;
                }
            });

            return { norm: maxNorm, share: maxCount / populationSize };
        }

        // Check norm crystallization status
        function getNormStatus() {
            const dominant = getDominantNorm();
            const avgIntern = agents.reduce((sum, a) => sum + a.internalization, 0) / populationSize;
            const entropy = calculateEntropy();

            if (dominant.share > 0.8 && avgIntern > 0.7) {
                return 'crystallized';
            } else if (entropy > 0.8) {
                return 'contested';
            } else {
                return 'emerging';
            }
        }

        // External shock - introduce new norm randomly
        function externalShock() {
            const affectedCount = Math.floor(populationSize * 0.2);
            const newNorm = Math.floor(Math.random() * numNorms);

            const shuffled = [...agents].sort(() => Math.random() - 0.5);
            shuffled.slice(0, affectedCount).forEach(agent => {
                agent.norm = newNorm;
                agent.internalization = 0.3;
            });

            addEvent(`External shock: ${affectedCount} agents adopted norm ${newNorm}`, 'violation');
        }

        // Update legend
        function updateLegend() {
            let html = '';
            for (let i = 0; i < numNorms; i++) {
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${normColors[i]};"></div>
                        <span>Norm ${i + 1}</span>
                    </div>
                `;
            }
            elements.normLegend.innerHTML = html;
        }

        // Update statistics
        function updateStats() {
            elements.generation.textContent = generation;

            const dominant = getDominantNorm();
            elements.dominantNorm.textContent = dominant.norm + 1;
            elements.dominantShare.textContent = (dominant.share * 100).toFixed(1);

            const entropy = calculateEntropy();
            elements.entropy.textContent = entropy.toFixed(2);

            elements.violations.textContent = totalViolations;
            elements.punishments.textContent = totalPunishments;

            const avgIntern = agents.reduce((sum, a) => sum + a.internalization, 0) / populationSize;
            elements.avgInternalization.textContent = avgIntern.toFixed(2);

            elements.normChanges.textContent = totalNormChanges;

            // Update status
            const status = getNormStatus();
            elements.normStatus.className = 'norm-status';
            if (status === 'crystallized') {
                elements.normStatus.classList.add('norm-crystallized');
                elements.normStatus.textContent = 'CRYSTALLIZED';
            } else if (status === 'contested') {
                elements.normStatus.classList.add('norm-contested');
                elements.normStatus.textContent = 'CONTESTED';
            } else {
                elements.normStatus.classList.add('norm-emerging');
                elements.normStatus.textContent = 'EMERGING';
            }

            // Update event log
            let eventHtml = '';
            events.slice(0, 10).forEach(event => {
                eventHtml += `<div class="event-item event-${event.type}">[${event.time}] ${event.text}</div>`;
            });
            elements.eventLog.innerHTML = eventHtml;
        }

        // Draw network
        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            netCtx.clearRect(0, 0, width, height);
            netCtx.fillStyle = '#1a1a2e';
            netCtx.fillRect(0, 0, width, height);

            // Draw edges
            netCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            netCtx.lineWidth = 0.5;

            edges.forEach(edge => {
                const a1 = agents[edge[0]];
                const a2 = agents[edge[1]];

                netCtx.beginPath();
                netCtx.moveTo(a1.x, a1.y);
                netCtx.lineTo(a2.x, a2.y);
                netCtx.stroke();
            });

            // Draw agents
            agents.forEach(agent => {
                const radius = 3 + agent.internalization * 4;
                const color = normColors[agent.norm % normColors.length];

                // Outer glow for high internalization
                if (agent.internalization > 0.7) {
                    netCtx.fillStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    netCtx.beginPath();
                    netCtx.arc(agent.x, agent.y, radius + 3, 0, Math.PI * 2);
                    netCtx.fill();
                }

                netCtx.fillStyle = color;
                netCtx.beginPath();
                netCtx.arc(agent.x, agent.y, radius, 0, Math.PI * 2);
                netCtx.fill();

                // Red ring if recently punished
                if (agent.punished) {
                    netCtx.strokeStyle = '#e74c3c';
                    netCtx.lineWidth = 2;
                    netCtx.beginPath();
                    netCtx.arc(agent.x, agent.y, radius + 2, 0, Math.PI * 2);
                    netCtx.stroke();
                }
            });
        }

        // Draw adoption chart
        function drawAdoption() {
            const width = adoptionCanvas.width;
            const height = adoptionCanvas.height;
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            adoptCtx.clearRect(0, 0, width, height);
            adoptCtx.fillStyle = '#1a1a2e';
            adoptCtx.fillRect(0, 0, width, height);

            // Axes
            adoptCtx.strokeStyle = '#666';
            adoptCtx.lineWidth = 1;
            adoptCtx.beginPath();
            adoptCtx.moveTo(margin.left, margin.top);
            adoptCtx.lineTo(margin.left, height - margin.bottom);
            adoptCtx.lineTo(width - margin.right, height - margin.bottom);
            adoptCtx.stroke();

            // Labels
            adoptCtx.fillStyle = '#aaa';
            adoptCtx.font = '11px sans-serif';
            adoptCtx.textAlign = 'center';
            adoptCtx.fillText('Time', width / 2, height - 5);

            adoptCtx.save();
            adoptCtx.translate(12, height / 2);
            adoptCtx.rotate(-Math.PI / 2);
            adoptCtx.fillText('Fraction Adopting', 0, 0);
            adoptCtx.restore();

            if (normHistory.length < 2) return;

            // Draw stacked area chart
            for (let n = numNorms - 1; n >= 0; n--) {
                adoptCtx.fillStyle = normColors[n].replace(')', ', 0.7)').replace('rgb', 'rgba');
                adoptCtx.beginPath();
                adoptCtx.moveTo(margin.left, height - margin.bottom);

                normHistory.forEach((fractions, i) => {
                    const x = margin.left + (i / normHistory.length) * chartWidth;
                    let cumulative = 0;
                    for (let j = 0; j <= n; j++) {
                        cumulative += fractions[j];
                    }
                    const y = margin.top + (1 - cumulative) * chartHeight;
                    adoptCtx.lineTo(x, y);
                });

                adoptCtx.lineTo(width - margin.right, height - margin.bottom);
                adoptCtx.closePath();
                adoptCtx.fill();
            }

            // Crystallization threshold line
            adoptCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            adoptCtx.setLineDash([5, 5]);
            adoptCtx.beginPath();
            adoptCtx.moveTo(margin.left, margin.top + chartHeight * 0.2);
            adoptCtx.lineTo(width - margin.right, margin.top + chartHeight * 0.2);
            adoptCtx.stroke();
            adoptCtx.setLineDash([]);

            adoptCtx.fillStyle = '#aaa';
            adoptCtx.font = '9px sans-serif';
            adoptCtx.textAlign = 'left';
            adoptCtx.fillText('80%', margin.left + 5, margin.top + chartHeight * 0.2 - 3);
        }

        // Draw internalization distribution
        function drawInternalization() {
            const width = internalizationCanvas.width;
            const height = internalizationCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            internCtx.clearRect(0, 0, width, height);
            internCtx.fillStyle = '#1a1a2e';
            internCtx.fillRect(0, 0, width, height);

            // Axes
            internCtx.strokeStyle = '#666';
            internCtx.lineWidth = 1;
            internCtx.beginPath();
            internCtx.moveTo(margin.left, margin.top);
            internCtx.lineTo(margin.left, height - margin.bottom);
            internCtx.lineTo(width - margin.right, height - margin.bottom);
            internCtx.stroke();

            // Labels
            internCtx.fillStyle = '#aaa';
            internCtx.font = '10px sans-serif';
            internCtx.textAlign = 'center';
            internCtx.fillText('Internalization Level', width / 2, height - 5);

            internCtx.save();
            internCtx.translate(10, height / 2);
            internCtx.rotate(-Math.PI / 2);
            internCtx.fillText('Count', 0, 0);
            internCtx.restore();

            // Create histogram bins
            const numBins = 20;
            const bins = new Array(numBins).fill(0);

            agents.forEach(agent => {
                const bin = Math.min(numBins - 1, Math.floor(agent.internalization * numBins));
                bins[bin]++;
            });

            const maxCount = Math.max(...bins, 1);
            const barWidth = chartWidth / numBins;

            // Draw bars colored by dominant norm in that bin
            bins.forEach((count, i) => {
                const x = margin.left + i * barWidth;
                const barHeight = (count / maxCount) * chartHeight;
                const y = margin.top + chartHeight - barHeight;

                // Color gradient from red (low) to green (high)
                const hue = (i / numBins) * 120;
                internCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                internCtx.fillRect(x, y, barWidth - 1, barHeight);
            });

            // Mark 0.7 threshold
            const threshX = margin.left + 0.7 * chartWidth;
            internCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            internCtx.setLineDash([5, 5]);
            internCtx.beginPath();
            internCtx.moveTo(threshX, margin.top);
            internCtx.lineTo(threshX, height - margin.bottom);
            internCtx.stroke();
            internCtx.setLineDash([]);

            internCtx.fillStyle = '#aaa';
            internCtx.font = '9px sans-serif';
            internCtx.fillText('0.7', threshX, height - margin.bottom + 12);
        }

        // Draw punishment/violation chart
        function drawPunishment() {
            const width = punishmentCanvas.width;
            const height = punishmentCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            punCtx.clearRect(0, 0, width, height);
            punCtx.fillStyle = '#1a1a2e';
            punCtx.fillRect(0, 0, width, height);

            // Axes
            punCtx.strokeStyle = '#666';
            punCtx.lineWidth = 1;
            punCtx.beginPath();
            punCtx.moveTo(margin.left, margin.top);
            punCtx.lineTo(margin.left, height - margin.bottom);
            punCtx.lineTo(width - margin.right, height - margin.bottom);
            punCtx.stroke();

            // Labels
            punCtx.fillStyle = '#aaa';
            punCtx.font = '10px sans-serif';
            punCtx.textAlign = 'center';
            punCtx.fillText('Time', width / 2, height - 5);

            punCtx.save();
            punCtx.translate(10, height / 2);
            punCtx.rotate(-Math.PI / 2);
            punCtx.fillText('Rate', 0, 0);
            punCtx.restore();

            if (violationHistory.length < 2) return;

            const maxVal = Math.max(
                ...violationHistory,
                ...punishmentHistory,
                1
            );

            // Draw violation line
            punCtx.strokeStyle = '#f39c12';
            punCtx.lineWidth = 2;
            punCtx.beginPath();

            violationHistory.forEach((v, i) => {
                const x = margin.left + (i / violationHistory.length) * chartWidth;
                const y = margin.top + (1 - v / maxVal) * chartHeight;

                if (i === 0) {
                    punCtx.moveTo(x, y);
                } else {
                    punCtx.lineTo(x, y);
                }
            });
            punCtx.stroke();

            // Draw punishment line
            punCtx.strokeStyle = '#e74c3c';
            punCtx.beginPath();

            punishmentHistory.forEach((p, i) => {
                const x = margin.left + (i / punishmentHistory.length) * chartWidth;
                const y = margin.top + (1 - p / maxVal) * chartHeight;

                if (i === 0) {
                    punCtx.moveTo(x, y);
                } else {
                    punCtx.lineTo(x, y);
                }
            });
            punCtx.stroke();

            // Legend
            punCtx.fillStyle = '#f39c12';
            punCtx.font = '10px sans-serif';
            punCtx.textAlign = 'left';
            punCtx.fillText('Violations', margin.left + 10, margin.top + 15);

            punCtx.fillStyle = '#e74c3c';
            punCtx.fillText('Punishments', margin.left + 80, margin.top + 15);
        }

        // Main draw function
        function draw() {
            drawNetwork();
            drawAdoption();
            drawInternalization();
            drawPunishment();
            updateStats();
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;

            for (let i = 0; i < speed; i++) {
                step();
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        elements.populationSize.addEventListener('input', (e) => {
            populationSize = parseInt(e.target.value);
            elements.populationSizeVal.textContent = populationSize;
        });

        elements.networkType.addEventListener('change', (e) => {
            networkType = e.target.value;
        });

        elements.avgConnections.addEventListener('input', (e) => {
            avgConnections = parseInt(e.target.value);
            elements.avgConnectionsVal.textContent = avgConnections;
        });

        elements.numNorms.addEventListener('input', (e) => {
            numNorms = parseInt(e.target.value);
            elements.numNormsVal.textContent = numNorms;
        });

        elements.conformityPressure.addEventListener('input', (e) => {
            conformityPressure = parseFloat(e.target.value);
            elements.conformityPressureVal.textContent = conformityPressure.toFixed(2);
        });

        elements.innovationRate.addEventListener('input', (e) => {
            innovationRate = parseFloat(e.target.value);
            elements.innovationRateVal.textContent = innovationRate.toFixed(3);
        });

        elements.punishmentProb.addEventListener('input', (e) => {
            punishmentProb = parseFloat(e.target.value);
            elements.punishmentProbVal.textContent = punishmentProb.toFixed(2);
        });

        elements.punishmentSeverity.addEventListener('input', (e) => {
            punishmentSeverity = parseFloat(e.target.value);
            elements.punishmentSeverityVal.textContent = punishmentSeverity.toFixed(2);
        });

        elements.punishmentCost.addEventListener('input', (e) => {
            punishmentCost = parseFloat(e.target.value);
            elements.punishmentCostVal.textContent = punishmentCost.toFixed(2);
        });

        elements.speed.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            elements.speedVal.textContent = speed;
        });

        elements.startBtn.addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                elements.startBtn.textContent = 'Running...';
                animate();
            }
        });

        elements.pauseBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        });

        elements.resetBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            initialize();
        });

        elements.shockBtn.addEventListener('click', externalShock);

        // Initialize
        initialize();
    </script>
</body>
</html>
