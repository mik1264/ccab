<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viscous Fingering - Saffman-Taylor Instability</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
            --invading: #4A90D9;
            --defending: #2C3E50;
            --interface: #E74C3C;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            gap: 20px;
        }

        .controls, .stats-panel {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(96, 108, 56, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"],
        .checkbox-group input[type="radio"] {
            accent-color: var(--moss);
            width: 18px;
            height: 18px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--dark-moss);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--terracotta);
        }

        button.secondary:hover {
            background: #a05a1f;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background: #1a1a2e;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(96, 108, 56, 0.1);
        }

        .stat-label {
            font-weight: 600;
            color: var(--moss);
        }

        .stat-value {
            color: var(--terracotta);
            font-weight: 700;
        }

        .chart-container {
            height: 100px;
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 10px;
        }

        .chart-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
        }

        .mini-canvas {
            width: 100%;
            height: 60px;
            border-radius: 5px;
            background: white;
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border-left: 3px solid var(--sage);
            padding: 12px;
            border-radius: 0 10px 10px 0;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        @media (max-width: 1200px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .controls, .stats-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">←</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <h1>Viscous Fingering Simulation</h1>
        <p class="subtitle">Saffman-Taylor Instability in Hele-Shaw Cells</p>

        <div class="simulation-area">
            <div class="controls">
                <div class="control-section">
                    <h3>Simulation Controls</h3>
                    <button id="startBtn">Start Injection</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>

                <div class="control-section">
                    <h3>Flow Configuration</h3>
                    <div class="checkbox-group">
                        <input type="radio" name="flowType" id="radialFlow" checked>
                        <label for="radialFlow">Radial (center injection)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="flowType" id="linearFlow">
                        <label for="linearFlow">Linear (side injection)</label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Fluid Properties</h3>
                    <div class="control-group">
                        <label>Viscosity Ratio (μ₂/μ₁): <span class="value" id="viscosityVal">100</span></label>
                        <input type="range" id="viscosity" min="5" max="500" value="100" step="5">
                    </div>
                    <div class="control-group">
                        <label>Surface Tension: <span class="value" id="tensionVal">0.3</span></label>
                        <input type="range" id="tension" min="0" max="1" value="0.3" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>Injection Rate: <span class="value" id="rateVal">5</span></label>
                        <input type="range" id="rate" min="1" max="20" value="5" step="1">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Noise & Perturbations</h3>
                    <div class="control-group">
                        <label>Initial Noise: <span class="value" id="noiseVal">0.2</span></label>
                        <input type="range" id="noise" min="0" max="1" value="0.2" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>DLA Stickiness: <span class="value" id="stickinessVal">0.8</span></label>
                        <input type="range" id="stickiness" min="0.1" max="1" value="0.8" step="0.05">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Visualization</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPressure">
                        <label for="showPressure">Show Pressure Field</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showVelocity">
                        <label for="showVelocity">Show Flow Velocity</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="colorByAge" checked>
                        <label for="colorByAge">Color by Time</label>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="simCanvas" width="700" height="700"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4A90D9;"></div>
                        <span>Invading Fluid</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2C3E50;"></div>
                        <span>Defending Fluid</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #E74C3C;"></div>
                        <span>Interface</span>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="control-section">
                    <h3>Pattern Statistics</h3>
                    <div class="stat-item">
                        <span class="stat-label">Interface Length:</span>
                        <span class="stat-value" id="statLength">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Invaded Area:</span>
                        <span class="stat-value" id="statArea">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Num. Fingers:</span>
                        <span class="stat-value" id="statFingers">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Avg. Finger Width:</span>
                        <span class="stat-value" id="statWidth">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Max Radius:</span>
                        <span class="stat-value" id="statRadius">0</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Fractal Analysis</h3>
                    <div class="stat-item">
                        <span class="stat-label">Box-counting Dim:</span>
                        <span class="stat-value" id="statFractal">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Tip-split Events:</span>
                        <span class="stat-value" id="statSplits">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Growth Rate:</span>
                        <span class="stat-value" id="statGrowth">0</span>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Finger Width Distribution</div>
                    <canvas id="widthChart" class="mini-canvas"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Radial Growth</div>
                    <canvas id="growthChart" class="mini-canvas"></canvas>
                </div>

                <div class="info-box">
                    <strong>Physics:</strong> The Saffman-Taylor instability occurs when a less viscous fluid displaces a more viscous one in a Hele-Shaw cell. Small perturbations grow into fingers due to pressure gradients - longer fingers "screen" shorter ones from the pressure field, causing tip-splitting and fractal patterns.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Viscous Fingering Simulation using DLA-like growth
        // Models Saffman-Taylor instability in Hele-Shaw cells

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const widthCanvas = document.getElementById('widthChart');
        const widthCtx = widthCanvas.getContext('2d');
        const growthCanvas = document.getElementById('growthChart');
        const growthCtx = growthCanvas.getContext('2d');

        // Grid for pattern
        const gridSize = 2;
        const cols = Math.floor(canvas.width / gridSize);
        const rows = Math.floor(canvas.height / gridSize);
        let grid = [];
        let ageGrid = [];

        // Simulation state
        let running = false;
        let animationId = null;
        let step = 0;
        let tipSplits = 0;
        let radiusHistory = [];

        // Parameters
        const params = {
            viscosityRatio: 100,
            surfaceTension: 0.3,
            injectionRate: 5,
            noise: 0.2,
            stickiness: 0.8,
            radialFlow: true,
            showPressure: false,
            showVelocity: false,
            colorByAge: true
        };

        // Initialize grid
        function initGrid() {
            grid = [];
            ageGrid = [];
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                ageGrid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = 0; // 0 = defending fluid, 1 = invading fluid
                    ageGrid[i][j] = 0;
                }
            }

            // Seed initial pattern
            const cx = Math.floor(cols / 2);
            const cy = Math.floor(rows / 2);

            if (params.radialFlow) {
                // Central injection point with small perturbations
                const seedRadius = 5;
                for (let i = -seedRadius; i <= seedRadius; i++) {
                    for (let j = -seedRadius; j <= seedRadius; j++) {
                        const dist = Math.sqrt(i*i + j*j);
                        if (dist <= seedRadius) {
                            const nx = cx + i;
                            const ny = cy + j;
                            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                                grid[nx][ny] = 1;
                                ageGrid[nx][ny] = 0;
                            }
                        }
                    }
                }
            } else {
                // Linear injection from left side
                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < 10; i++) {
                        grid[i][j] = 1;
                        ageGrid[i][j] = 0;
                    }
                }
            }

            step = 0;
            tipSplits = 0;
            radiusHistory = [];
        }

        // Find interface cells (invading cells adjacent to defending)
        function findInterface() {
            const interface = [];
            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < rows - 1; j++) {
                    if (grid[i][j] === 0) {
                        // Check if adjacent to invading fluid
                        let hasNeighbor = false;
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                if (di === 0 && dj === 0) continue;
                                if (grid[i + di][j + dj] === 1) {
                                    hasNeighbor = true;
                                    break;
                                }
                            }
                            if (hasNeighbor) break;
                        }
                        if (hasNeighbor) {
                            interface.push({ x: i, y: j });
                        }
                    }
                }
            }
            return interface;
        }

        // Calculate local pressure gradient (simplified Laplacian)
        function calculatePressure(x, y) {
            const cx = cols / 2;
            const cy = rows / 2;

            if (params.radialFlow) {
                // Radial pressure gradient
                const dx = x - cx;
                const dy = y - cy;
                const r = Math.sqrt(dx * dx + dy * dy);
                return 1 / (r + 1);
            } else {
                // Linear pressure gradient
                return (cols - x) / cols;
            }
        }

        // Calculate growth probability based on local curvature and pressure
        function growthProbability(x, y) {
            // Base probability from pressure gradient
            let prob = calculatePressure(x, y);

            // Count nearby invaded cells (curvature effect)
            let neighbors = 0;
            let interfaceNeighbors = 0;
            for (let di = -2; di <= 2; di++) {
                for (let dj = -2; dj <= 2; dj++) {
                    const nx = x + di;
                    const ny = y + dj;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                        if (grid[nx][ny] === 1) {
                            neighbors++;
                        }
                    }
                }
            }

            // Surface tension effect: high curvature = lower probability
            const curvatureEffect = params.surfaceTension * (neighbors / 25);
            prob = prob * (1 - curvatureEffect);

            // Viscosity ratio effect: higher ratio = more instability
            prob = prob * Math.log10(params.viscosityRatio) / 2;

            // Add noise
            prob += (Math.random() - 0.5) * params.noise;

            // Stickiness factor
            prob *= params.stickiness;

            return Math.max(0, Math.min(1, prob));
        }

        // Simulation step
        function simulateStep() {
            const interface = findInterface();
            if (interface.length === 0) return;

            // Calculate probabilities for all interface cells
            const candidates = interface.map(cell => ({
                ...cell,
                prob: growthProbability(cell.x, cell.y)
            }));

            // Sort by probability (for tip selection)
            candidates.sort((a, b) => b.prob - a.prob);

            // Grow at multiple points based on injection rate
            const growCount = Math.min(params.injectionRate, candidates.length);
            let grown = 0;

            for (let i = 0; i < candidates.length && grown < growCount; i++) {
                const cell = candidates[i];

                // Probabilistic selection
                if (Math.random() < cell.prob * 2) {
                    grid[cell.x][cell.y] = 1;
                    ageGrid[cell.x][cell.y] = step;
                    grown++;

                    // Detect tip-splitting (check for branching)
                    if (detectTipSplit(cell.x, cell.y)) {
                        tipSplits++;
                    }
                }
            }

            step++;

            // Track radial growth
            if (step % 10 === 0) {
                radiusHistory.push(calculateMaxRadius());
                if (radiusHistory.length > 100) radiusHistory.shift();
            }
        }

        // Detect tip-splitting events
        function detectTipSplit(x, y) {
            // Count invaded neighbors in different directions
            let sectors = [0, 0, 0, 0]; // Up, Right, Down, Left

            for (let di = -3; di <= 3; di++) {
                for (let dj = -3; dj <= 3; dj++) {
                    const nx = x + di;
                    const ny = y + dj;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && grid[nx][ny] === 1) {
                        if (dj < -1) sectors[0]++;
                        if (di > 1) sectors[1]++;
                        if (dj > 1) sectors[2]++;
                        if (di < -1) sectors[3]++;
                    }
                }
            }

            // Tip split if high in opposite sectors
            const vertical = sectors[0] + sectors[2];
            const horizontal = sectors[1] + sectors[3];

            return vertical > 5 && horizontal > 5;
        }

        // Calculate maximum radius of pattern
        function calculateMaxRadius() {
            const cx = cols / 2;
            const cy = rows / 2;
            let maxR = 0;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j] === 1) {
                        const r = Math.sqrt((i - cx) ** 2 + (j - cy) ** 2);
                        if (r > maxR) maxR = r;
                    }
                }
            }

            return maxR * gridSize;
        }

        // Calculate invaded area
        function calculateArea() {
            let count = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j] === 1) count++;
                }
            }
            return count * gridSize * gridSize;
        }

        // Calculate interface length
        function calculateInterfaceLength() {
            let length = 0;
            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < rows - 1; j++) {
                    if (grid[i][j] === 1) {
                        // Check each edge
                        if (grid[i+1][j] === 0) length++;
                        if (grid[i-1][j] === 0) length++;
                        if (grid[i][j+1] === 0) length++;
                        if (grid[i][j-1] === 0) length++;
                    }
                }
            }
            return length * gridSize;
        }

        // Count fingers (simplified)
        function countFingers() {
            const cx = cols / 2;
            const cy = rows / 2;
            const radius = calculateMaxRadius() / gridSize * 0.8;

            if (radius < 20) return 0;

            // Count crossings at 80% of max radius
            let crossings = 0;
            const numPoints = 360;

            for (let a = 0; a < numPoints; a++) {
                const angle1 = (a / numPoints) * Math.PI * 2;
                const angle2 = ((a + 1) / numPoints) * Math.PI * 2;

                const x1 = Math.floor(cx + Math.cos(angle1) * radius);
                const y1 = Math.floor(cy + Math.sin(angle1) * radius);
                const x2 = Math.floor(cx + Math.cos(angle2) * radius);
                const y2 = Math.floor(cy + Math.sin(angle2) * radius);

                if (x1 >= 0 && x1 < cols && y1 >= 0 && y1 < rows &&
                    x2 >= 0 && x2 < cols && y2 >= 0 && y2 < rows) {
                    if (grid[x1][y1] !== grid[x2][y2]) {
                        crossings++;
                    }
                }
            }

            return Math.floor(crossings / 2);
        }

        // Estimate fractal dimension using box counting
        function estimateFractalDimension() {
            const sizes = [4, 8, 16, 32, 64];
            const counts = [];

            for (const size of sizes) {
                let count = 0;
                const boxCols = Math.ceil(cols / size);
                const boxRows = Math.ceil(rows / size);

                for (let bi = 0; bi < boxCols; bi++) {
                    for (let bj = 0; bj < boxRows; bj++) {
                        let hasInvaded = false;
                        boxLoop:
                        for (let i = bi * size; i < Math.min((bi + 1) * size, cols); i++) {
                            for (let j = bj * size; j < Math.min((bj + 1) * size, rows); j++) {
                                if (grid[i][j] === 1) {
                                    hasInvaded = true;
                                    break boxLoop;
                                }
                            }
                        }
                        if (hasInvaded) count++;
                    }
                }
                counts.push(count);
            }

            // Linear regression in log-log space
            if (counts.some(c => c === 0)) return null;

            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            for (let i = 0; i < sizes.length; i++) {
                const x = -Math.log(sizes[i]);
                const y = Math.log(counts[i]);
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            }

            const n = sizes.length;
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);

            return slope;
        }

        // Draw simulation
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pressure field if enabled
            if (params.showPressure) {
                for (let i = 0; i < cols; i += 5) {
                    for (let j = 0; j < rows; j += 5) {
                        const p = calculatePressure(i, j);
                        ctx.fillStyle = `rgba(100, 100, 255, ${p * 0.3})`;
                        ctx.fillRect(i * gridSize, j * gridSize, gridSize * 5, gridSize * 5);
                    }
                }
            }

            // Draw pattern
            const maxAge = step;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j] === 1) {
                        if (params.colorByAge && maxAge > 0) {
                            const age = ageGrid[i][j] / maxAge;
                            // Blue to cyan to white gradient
                            const r = Math.floor(74 + age * 181);
                            const g = Math.floor(144 + age * 111);
                            const b = Math.floor(217 + age * 38);
                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            ctx.fillStyle = '#4A90D9';
                        }
                        ctx.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
                    }
                }
            }

            // Draw interface
            const interface = findInterface();
            ctx.fillStyle = '#E74C3C';
            interface.forEach(cell => {
                ctx.fillRect(cell.x * gridSize, cell.y * gridSize, gridSize, gridSize);
            });

            // Draw flow velocity vectors if enabled
            if (params.showVelocity) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                const cx = cols / 2;
                const cy = rows / 2;

                for (let i = 20; i < cols; i += 30) {
                    for (let j = 20; j < rows; j += 30) {
                        if (grid[i][j] === 0) {
                            const dx = params.radialFlow ? (i - cx) : 1;
                            const dy = params.radialFlow ? (j - cy) : 0;
                            const mag = Math.sqrt(dx * dx + dy * dy);
                            if (mag > 0) {
                                const scale = 10;
                                ctx.beginPath();
                                ctx.moveTo(i * gridSize, j * gridSize);
                                ctx.lineTo(
                                    i * gridSize - (dx / mag) * scale,
                                    j * gridSize - (dy / mag) * scale
                                );
                                ctx.stroke();
                            }
                        }
                    }
                }
            }

            updateStats();
        }

        // Update statistics display
        function updateStats() {
            const area = calculateArea();
            const length = calculateInterfaceLength();
            const fingers = countFingers();
            const radius = calculateMaxRadius();
            const fractalDim = estimateFractalDimension();

            document.getElementById('statLength').textContent = length.toFixed(0);
            document.getElementById('statArea').textContent = area.toFixed(0);
            document.getElementById('statFingers').textContent = fingers;
            document.getElementById('statWidth').textContent = fingers > 0 ?
                (2 * Math.PI * radius / fingers).toFixed(1) + 'px' : '--';
            document.getElementById('statRadius').textContent = radius.toFixed(1) + 'px';
            document.getElementById('statFractal').textContent = fractalDim ?
                fractalDim.toFixed(3) : '--';
            document.getElementById('statSplits').textContent = tipSplits;
            document.getElementById('statGrowth').textContent =
                radiusHistory.length > 1 ?
                    (radiusHistory[radiusHistory.length - 1] - radiusHistory[0]).toFixed(1) + '/s' : '0';

            drawWidthChart(fingers, radius);
            drawGrowthChart();
        }

        // Draw finger width distribution chart
        function drawWidthChart(fingers, radius) {
            const w = widthCanvas.width = widthCanvas.offsetWidth;
            const h = widthCanvas.height = 60;

            widthCtx.clearRect(0, 0, w, h);
            widthCtx.fillStyle = '#f8f8f8';
            widthCtx.fillRect(0, 0, w, h);

            if (fingers === 0 || radius < 20) {
                widthCtx.fillStyle = '#999';
                widthCtx.font = '11px Nunito';
                widthCtx.textAlign = 'center';
                widthCtx.fillText('Insufficient data', w/2, h/2);
                return;
            }

            // Sample finger widths at different radii
            const widths = [];
            const cx = cols / 2;
            const cy = rows / 2;

            for (let r = 20; r < radius / gridSize; r += 10) {
                let fingerWidth = 0;
                let inFinger = false;
                let currentWidth = 0;

                for (let a = 0; a < 360; a++) {
                    const angle = (a / 360) * Math.PI * 2;
                    const x = Math.floor(cx + Math.cos(angle) * r);
                    const y = Math.floor(cy + Math.sin(angle) * r);

                    if (x >= 0 && x < cols && y >= 0 && y < rows) {
                        if (grid[x][y] === 1) {
                            if (!inFinger) {
                                inFinger = true;
                                currentWidth = 0;
                            }
                            currentWidth++;
                        } else {
                            if (inFinger && currentWidth > 2) {
                                widths.push(currentWidth * 2 * Math.PI * r / 360);
                            }
                            inFinger = false;
                        }
                    }
                }
            }

            if (widths.length === 0) return;

            // Create histogram
            const maxWidth = Math.max(...widths);
            const bins = 10;
            const binSize = maxWidth / bins;
            const histogram = new Array(bins).fill(0);

            widths.forEach(w => {
                const binIdx = Math.min(Math.floor(w / binSize), bins - 1);
                histogram[binIdx]++;
            });

            const maxCount = Math.max(...histogram);
            const barW = (w - 20) / bins;

            histogram.forEach((count, i) => {
                const barHeight = maxCount > 0 ? (count / maxCount) * (h - 15) : 0;
                const x = 10 + i * barW;
                const y = h - 5 - barHeight;

                widthCtx.fillStyle = '#4A90D9';
                widthCtx.fillRect(x, y, barW - 2, barHeight);
            });
        }

        // Draw radial growth chart
        function drawGrowthChart() {
            const w = growthCanvas.width = growthCanvas.offsetWidth;
            const h = growthCanvas.height = 60;

            growthCtx.clearRect(0, 0, w, h);
            growthCtx.fillStyle = '#f8f8f8';
            growthCtx.fillRect(0, 0, w, h);

            if (radiusHistory.length < 2) {
                growthCtx.fillStyle = '#999';
                growthCtx.font = '11px Nunito';
                growthCtx.textAlign = 'center';
                growthCtx.fillText('Collecting data...', w/2, h/2);
                return;
            }

            const maxR = Math.max(...radiusHistory);
            const step = (w - 20) / (radiusHistory.length - 1);

            growthCtx.strokeStyle = '#BC6C25';
            growthCtx.lineWidth = 2;
            growthCtx.beginPath();

            radiusHistory.forEach((r, i) => {
                const x = 10 + i * step;
                const y = h - 5 - (r / maxR) * (h - 15);

                if (i === 0) {
                    growthCtx.moveTo(x, y);
                } else {
                    growthCtx.lineTo(x, y);
                }
            });

            growthCtx.stroke();
        }

        // Animation loop
        function animate() {
            if (!running) return;

            for (let i = 0; i < 3; i++) {
                simulateStep();
            }
            draw();

            // Check if pattern has reached edges
            const maxR = calculateMaxRadius();
            if (maxR > canvas.width * 0.45) {
                running = false;
                document.getElementById('startBtn').textContent = 'Restart';
                return;
            }

            animationId = requestAnimationFrame(animate);
        }

        // Start/stop simulation
        function toggleSimulation() {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Continue';
            if (running) {
                animate();
            }
        }

        // Reset simulation
        function resetSimulation() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Injection';
            if (animationId) cancelAnimationFrame(animationId);
            initGrid();
            draw();
        }

        // UI Event listeners
        document.getElementById('startBtn').addEventListener('click', toggleSimulation);
        document.getElementById('resetBtn').addEventListener('click', resetSimulation);

        document.getElementById('radialFlow').addEventListener('change', function() {
            if (this.checked) {
                params.radialFlow = true;
                resetSimulation();
            }
        });

        document.getElementById('linearFlow').addEventListener('change', function() {
            if (this.checked) {
                params.radialFlow = false;
                resetSimulation();
            }
        });

        document.getElementById('viscosity').addEventListener('input', function() {
            params.viscosityRatio = parseInt(this.value);
            document.getElementById('viscosityVal').textContent = this.value;
        });

        document.getElementById('tension').addEventListener('input', function() {
            params.surfaceTension = parseFloat(this.value);
            document.getElementById('tensionVal').textContent = this.value;
        });

        document.getElementById('rate').addEventListener('input', function() {
            params.injectionRate = parseInt(this.value);
            document.getElementById('rateVal').textContent = this.value;
        });

        document.getElementById('noise').addEventListener('input', function() {
            params.noise = parseFloat(this.value);
            document.getElementById('noiseVal').textContent = this.value;
        });

        document.getElementById('stickiness').addEventListener('input', function() {
            params.stickiness = parseFloat(this.value);
            document.getElementById('stickinessVal').textContent = this.value;
        });

        document.getElementById('showPressure').addEventListener('change', function() {
            params.showPressure = this.checked;
            if (!running) draw();
        });

        document.getElementById('showVelocity').addEventListener('change', function() {
            params.showVelocity = this.checked;
            if (!running) draw();
        });

        document.getElementById('colorByAge').addEventListener('change', function() {
            params.colorByAge = this.checked;
            if (!running) draw();
        });

        // Initialize
        initGrid();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
