<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primordial Soup - Origin of Life Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #0a1628; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .legend { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; margin-top: 10px; font-size: 0.75rem; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
        .phase-indicator { margin-top: 10px; padding: 8px; background: #e8f5e9; border-radius: 6px; text-align: center; font-weight: 600; color: #2e7d32; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Primordial Soup</h1>
            <p class="subtitle">Artificial chemistry with autocatalytic sets and template-based replication</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Molecule Diversity</label>
                    <input type="range" id="diversity" min="5" max="20" value="10">
                    <div class="control-value"><span id="diversityVal">10</span> types</div>
                </div>
                <div class="control-group">
                    <label>Reaction Rate</label>
                    <input type="range" id="reactionRate" min="1" max="20" value="8">
                    <div class="control-value"><span id="reactionRateVal">8</span>%</div>
                </div>
                <div class="control-group">
                    <label>Catalysis Probability</label>
                    <input type="range" id="catalysis" min="5" max="50" value="20">
                    <div class="control-value"><span id="catalysisVal">20</span>%</div>
                </div>
                <div class="control-group">
                    <label>Energy Input (lightning)</label>
                    <input type="range" id="energy" min="0" max="100" value="30">
                    <div class="control-value"><span id="energyVal">30</span></div>
                </div>
                <div class="control-group">
                    <label>Hydrolysis Rate</label>
                    <input type="range" id="hydrolysis" min="1" max="30" value="10">
                    <div class="control-value"><span id="hydrolysisVal">10</span>%</div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset Soup</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="totalMolecules">0</div><div class="stat-label">Molecules</div></div>
                    <div class="stat-box"><div class="stat-value" id="polymers">0</div><div class="stat-label">Polymers</div></div>
                    <div class="stat-box"><div class="stat-value" id="replicators">0</div><div class="stat-label">Replicators</div></div>
                    <div class="stat-box"><div class="stat-value" id="generations">0</div><div class="stat-label">Generations</div></div>
                </div>

                <div class="phase-indicator" id="phase">Pre-biotic Chemistry</div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#4fc3f7"></div>Monomers</div>
                    <div class="legend-item"><div class="legend-color" style="background:#81c784"></div>Polymers</div>
                    <div class="legend-item"><div class="legend-color" style="background:#ffb74d"></div>Catalysts</div>
                    <div class="legend-item"><div class="legend-color" style="background:#f06292"></div>Replicators</div>
                </div>

                <div class="info-panel">
                    <strong>Autocatalytic Sets (Kauffman 1986):</strong> When molecular diversity exceeds a threshold, self-sustaining reaction networks emerge spontaneously ‚Äî a phase transition to life-like chemistry.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = (rect.width * 0.65) * dpr;
            canvas.style.height = (rect.width * 0.65) + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width * 0.65 };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); });

        // Molecule types
        const TYPES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'];
        const TYPE_COLORS = {};
        TYPES.forEach((t, i) => {
            TYPE_COLORS[t] = `hsl(${i * 18}, 70%, 55%)`;
        });

        class Molecule {
            constructor(sequence, x, y) {
                this.sequence = sequence; // string of types, e.g., "ABC"
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.catalyzes = []; // what reactions this catalyzes
                this.isReplicator = false;
                this.template = null;
                this.age = 0;
            }

            get length() { return this.sequence.length; }
            get isPolymer() { return this.length > 1; }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.99;
                this.vy *= 0.99;

                // Brownian motion
                this.vx += (Math.random() - 0.5) * 0.3;
                this.vy += (Math.random() - 0.5) * 0.3;

                // Bounce off walls
                if (this.x < 10 || this.x > dims.width - 10) this.vx *= -1;
                if (this.y < 10 || this.y > dims.height - 10) this.vy *= -1;
                this.x = Math.max(10, Math.min(dims.width - 10, this.x));
                this.y = Math.max(10, Math.min(dims.height - 10, this.y));

                this.age++;
            }

            draw() {
                const size = 4 + this.length * 2;

                if (this.isReplicator) {
                    // Glowing replicator
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#f06292';
                    ctx.fillStyle = '#f06292';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // DNA-like helix
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < this.length; i++) {
                        const angle = this.age * 0.1 + i * 0.5;
                        const ox = Math.cos(angle) * 3;
                        ctx.beginPath();
                        ctx.arc(this.x + ox + i * 3 - this.length * 1.5, this.y, 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (this.catalyzes.length > 0) {
                    // Catalyst with ring
                    ctx.strokeStyle = '#ffb74d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 4, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.fillStyle = TYPE_COLORS[this.sequence[0]] || '#81c784';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.isPolymer) {
                    // Polymer chain
                    ctx.fillStyle = '#81c784';
                    for (let i = 0; i < this.length; i++) {
                        ctx.fillStyle = TYPE_COLORS[this.sequence[i]] || '#81c784';
                        ctx.beginPath();
                        ctx.arc(this.x + i * 5 - this.length * 2.5, this.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Links
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < this.length - 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i * 5 - this.length * 2.5, this.y);
                        ctx.lineTo(this.x + (i + 1) * 5 - this.length * 2.5, this.y);
                        ctx.stroke();
                    }
                } else {
                    // Monomer
                    ctx.fillStyle = TYPE_COLORS[this.sequence] || '#4fc3f7';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = '8px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.sequence, this.x, this.y + 3);
                }
            }

            distTo(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }

        let state = {
            running: false,
            molecules: [],
            reactions: new Map(), // Maps reaction string to catalyst set
            generation: 0,
            lightningTimer: 0,
            autocatalyticSets: 0
        };

        function initSoup() {
            state.molecules = [];
            state.reactions = new Map();
            state.generation = 0;
            state.autocatalyticSets = 0;

            const diversity = parseInt(document.getElementById('diversity').value);
            const types = TYPES.slice(0, diversity);

            // Create initial monomers
            for (let i = 0; i < 150; i++) {
                const type = types[Math.floor(Math.random() * types.length)];
                state.molecules.push(new Molecule(
                    type,
                    Math.random() * (dims.width - 40) + 20,
                    Math.random() * (dims.height - 40) + 20
                ));
            }

            // Initialize random catalytic network
            const catalysis = parseInt(document.getElementById('catalysis').value) / 100;
            for (const m of state.molecules) {
                if (Math.random() < catalysis * 0.1) {
                    // This molecule can catalyze a random reaction
                    const t1 = types[Math.floor(Math.random() * types.length)];
                    const t2 = types[Math.floor(Math.random() * types.length)];
                    m.catalyzes.push(t1 + '+' + t2);
                }
            }
        }

        function update() {
            if (!state.running) return;

            const reactionRate = parseInt(document.getElementById('reactionRate').value) / 100;
            const catalysis = parseInt(document.getElementById('catalysis').value) / 100;
            const energy = parseInt(document.getElementById('energy').value);
            const hydrolysis = parseInt(document.getElementById('hydrolysisVal').value) / 100;
            const diversity = parseInt(document.getElementById('diversity').value);

            // Update molecules
            for (const m of state.molecules) {
                m.update();
            }

            // Lightning energy input
            state.lightningTimer--;
            if (energy > 0 && Math.random() < energy / 1000) {
                state.lightningTimer = 10;
                // Lightning creates random reactions
                for (let i = 0; i < 3; i++) {
                    const idx = Math.floor(Math.random() * state.molecules.length);
                    const m = state.molecules[idx];
                    if (m && m.length === 1) {
                        // Chance to become a catalyst
                        if (Math.random() < 0.3 && m.catalyzes.length === 0) {
                            const types = TYPES.slice(0, diversity);
                            const t1 = types[Math.floor(Math.random() * types.length)];
                            const t2 = types[Math.floor(Math.random() * types.length)];
                            m.catalyzes.push(t1 + '+' + t2);
                        }
                    }
                }
            }

            // Reactions
            const newMolecules = [];
            const toRemove = new Set();

            for (let i = 0; i < state.molecules.length; i++) {
                const m1 = state.molecules[i];
                if (toRemove.has(i)) continue;

                for (let j = i + 1; j < state.molecules.length; j++) {
                    const m2 = state.molecules[j];
                    if (toRemove.has(j)) continue;

                    if (m1.distTo(m2) < 20) {
                        // Check for reaction
                        const reactionKey = m1.sequence + '+' + m2.sequence;

                        // Base reaction rate
                        let rate = reactionRate * 0.1;

                        // Check for catalysts nearby
                        for (const cat of state.molecules) {
                            if (cat.catalyzes.includes(reactionKey) && cat.distTo(m1) < 40) {
                                rate *= 5; // Catalyzed reaction is much faster
                                break;
                            }
                        }

                        // Template-based replication
                        if (m1.isReplicator && m2.length === 1 && m1.sequence.includes(m2.sequence)) {
                            rate *= 10;
                        }

                        if (Math.random() < rate && m1.length + m2.length <= 8) {
                            // Polymerization!
                            const newSeq = m1.sequence + m2.sequence;
                            const newMol = new Molecule(newSeq, (m1.x + m2.x) / 2, (m1.y + m2.y) / 2);

                            // Check if new polymer is a replicator (can template its own synthesis)
                            if (newSeq.length >= 4) {
                                // Check for self-catalysis
                                const half1 = newSeq.slice(0, Math.floor(newSeq.length / 2));
                                const half2 = newSeq.slice(Math.floor(newSeq.length / 2));

                                // If parts can recombine to form this, it's a replicator
                                for (const other of state.molecules) {
                                    if (other.sequence === half1 || other.sequence === half2) {
                                        newMol.isReplicator = true;
                                        newMol.template = newSeq;
                                        break;
                                    }
                                }

                                // Inherit catalytic abilities
                                if (m1.catalyzes.length > 0) newMol.catalyzes = [...m1.catalyzes];
                                if (m2.catalyzes.length > 0) newMol.catalyzes.push(...m2.catalyzes);

                                // Add new catalysis ability sometimes
                                if (Math.random() < catalysis * 0.1) {
                                    const types = TYPES.slice(0, diversity);
                                    const t1 = types[Math.floor(Math.random() * types.length)];
                                    const t2 = types[Math.floor(Math.random() * types.length)];
                                    newMol.catalyzes.push(t1 + '+' + t2);
                                }
                            }

                            newMolecules.push(newMol);
                            toRemove.add(i);
                            toRemove.add(j);
                            break;
                        }
                    }
                }

                // Hydrolysis (polymer breakdown)
                if (m1.isPolymer && Math.random() < hydrolysis * 0.01) {
                    const breakPoint = Math.floor(Math.random() * (m1.length - 1)) + 1;
                    const seq1 = m1.sequence.slice(0, breakPoint);
                    const seq2 = m1.sequence.slice(breakPoint);

                    newMolecules.push(new Molecule(seq1, m1.x - 5, m1.y));
                    newMolecules.push(new Molecule(seq2, m1.x + 5, m1.y));
                    toRemove.add(i);
                }
            }

            // Remove reacted molecules
            state.molecules = state.molecules.filter((_, i) => !toRemove.has(i));
            state.molecules.push(...newMolecules);

            // Limit total molecules
            while (state.molecules.length > 400) {
                const idx = Math.floor(Math.random() * state.molecules.length);
                if (!state.molecules[idx].isReplicator) {
                    state.molecules.splice(idx, 1);
                }
            }

            // Replenish monomers
            if (state.molecules.length < 100) {
                const types = TYPES.slice(0, diversity);
                for (let i = 0; i < 10; i++) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    state.molecules.push(new Molecule(
                        type,
                        Math.random() * (dims.width - 40) + 20,
                        Math.random() * (dims.height - 40) + 20
                    ));
                }
            }

            state.generation++;
            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            // Primordial ocean background
            const gradient = ctx.createLinearGradient(0, 0, 0, dims.height);
            gradient.addColorStop(0, '#0a1628');
            gradient.addColorStop(0.5, '#1a2744');
            gradient.addColorStop(1, '#0d1f3c');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, dims.width, dims.height);

            // Volcanic vents at bottom
            for (let i = 0; i < 5; i++) {
                const x = dims.width * (0.1 + i * 0.2);
                const gradient2 = ctx.createRadialGradient(x, dims.height, 0, x, dims.height, 60);
                gradient2.addColorStop(0, 'rgba(255, 100, 50, 0.3)');
                gradient2.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = gradient2;
                ctx.beginPath();
                ctx.arc(x, dims.height, 60, 0, Math.PI * 2);
                ctx.fill();
            }

            // Lightning flash
            if (state.lightningTimer > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${state.lightningTimer / 10 * 0.3})`;
                ctx.fillRect(0, 0, dims.width, dims.height);

                // Lightning bolt
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                let lx = dims.width / 2 + (Math.random() - 0.5) * 200;
                ctx.moveTo(lx, 0);
                for (let y = 0; y < dims.height; y += 30) {
                    lx += (Math.random() - 0.5) * 50;
                    ctx.lineTo(lx, y);
                }
                ctx.stroke();
            }

            // Draw reaction network (faint connections between catalysts and substrates)
            ctx.strokeStyle = 'rgba(255, 180, 100, 0.1)';
            ctx.lineWidth = 0.5;
            for (const m of state.molecules) {
                if (m.catalyzes.length > 0) {
                    for (const reaction of m.catalyzes) {
                        const [t1, t2] = reaction.split('+');
                        for (const other of state.molecules) {
                            if (other.sequence === t1 || other.sequence === t2) {
                                if (m.distTo(other) < 60) {
                                    ctx.beginPath();
                                    ctx.moveTo(m.x, m.y);
                                    ctx.lineTo(other.x, other.y);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                }
            }

            // Draw molecules
            for (const m of state.molecules) {
                m.draw();
            }

            // Title
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '14px Lora';
            ctx.fillText(`Primordial Soup | Generation ${state.generation}`, 20, 25);
        }

        function updateStats() {
            const monomers = state.molecules.filter(m => m.length === 1).length;
            const polymers = state.molecules.filter(m => m.length > 1).length;
            const replicators = state.molecules.filter(m => m.isReplicator).length;
            const catalysts = state.molecules.filter(m => m.catalyzes.length > 0).length;

            document.getElementById('totalMolecules').textContent = state.molecules.length;
            document.getElementById('polymers').textContent = polymers;
            document.getElementById('replicators').textContent = replicators;
            document.getElementById('generations').textContent = Math.floor(state.generation / 60);

            // Determine phase
            let phase = 'Pre-biotic Chemistry';
            let phaseColor = '#e8f5e9';
            let phaseTextColor = '#2e7d32';

            if (replicators > 0) {
                phase = 'üß¨ RNA World Emerged!';
                phaseColor = '#fce4ec';
                phaseTextColor = '#c2185b';
            } else if (catalysts > 10 && polymers > 20) {
                phase = 'Autocatalytic Network';
                phaseColor = '#fff3e0';
                phaseTextColor = '#e65100';
            } else if (polymers > 10) {
                phase = 'Polymer Formation';
                phaseColor = '#e3f2fd';
                phaseTextColor = '#1565c0';
            }

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = phase;
            phaseEl.style.background = phaseColor;
            phaseEl.style.color = phaseTextColor;
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            initSoup();
            draw();
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('diversityVal').textContent = document.getElementById('diversity').value;
            document.getElementById('reactionRateVal').textContent = document.getElementById('reactionRate').value;
            document.getElementById('catalysisVal').textContent = document.getElementById('catalysis').value;
            document.getElementById('energyVal').textContent = document.getElementById('energy').value;
            document.getElementById('hydrolysisVal').textContent = document.getElementById('hydrolysis').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));

        initSoup();
        draw();
    </script>
</body>
</html>
