<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soap Film Minimization - Plateau's Problem</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 20px;
        }

        .controls, .stats-panel {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(96, 108, 56, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            accent-color: var(--moss);
            width: 18px;
            height: 18px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--dark-moss);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--terracotta);
        }

        button.secondary:hover {
            background: #a05a1f;
        }

        .preset-btn {
            padding: 8px;
            font-size: 0.85rem;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(96, 108, 56, 0.1);
        }

        .stat-label {
            font-weight: 600;
            color: var(--moss);
        }

        .stat-value {
            color: var(--terracotta);
            font-weight: 700;
        }

        .chart-container {
            height: 100px;
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 10px;
        }

        .chart-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
        }

        .mini-canvas {
            width: 100%;
            height: 60px;
            border-radius: 5px;
            background: white;
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border-left: 3px solid var(--sage);
            padding: 12px;
            border-radius: 0 10px 10px 0;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        @media (max-width: 1200px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .controls, .stats-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <h1>Soap Film Minimization</h1>
        <p class="subtitle">Minimal Surfaces & Plateau's Problem</p>

        <div class="simulation-area">
            <div class="controls">
                <div class="control-section">
                    <h3>Simulation Controls</h3>
                    <button id="startBtn">Start Relaxation</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>

                <div class="control-section">
                    <h3>Boundary Shapes</h3>
                    <button class="preset-btn" onclick="setPreset('circle')">Circle</button>
                    <button class="preset-btn secondary" onclick="setPreset('square')">Square Frame</button>
                    <button class="preset-btn secondary" onclick="setPreset('trefoil')">Trefoil Knot</button>
                    <button class="preset-btn secondary" onclick="setPreset('saddle')">Saddle Frame</button>
                    <button class="preset-btn secondary" onclick="setPreset('helix')">Helicoid</button>
                    <button class="preset-btn secondary" onclick="setPreset('catenoid')">Catenoid</button>
                </div>

                <div class="control-section">
                    <h3>Mesh Parameters</h3>
                    <div class="control-group">
                        <label>Mesh Resolution: <span class="value" id="resolutionVal">20</span></label>
                        <input type="range" id="resolution" min="8" max="40" value="20" step="2">
                    </div>
                    <div class="control-group">
                        <label>Surface Tension: <span class="value" id="tensionVal">0.5</span></label>
                        <input type="range" id="tension" min="0.1" max="1.0" value="0.5" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Damping: <span class="value" id="dampingVal">0.9</span></label>
                        <input type="range" id="damping" min="0.5" max="0.99" value="0.9" step="0.01">
                    </div>
                </div>

                <div class="control-section">
                    <h3>View Controls</h3>
                    <div class="control-group">
                        <label>Rotation Speed: <span class="value" id="rotSpeedVal">0.5</span></label>
                        <input type="range" id="rotSpeed" min="0" max="2" value="0.5" step="0.1">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showWireframe" checked>
                        <label for="showWireframe">Show Wireframe</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showNormals">
                        <label for="showNormals">Show Normals</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="colorByCurvature" checked>
                        <label for="colorByCurvature">Color by Curvature</label>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="simCanvas" width="700" height="600"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Boundary Wire</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #4ECDC4, #FF6B6B);"></div>
                        <span>Surface (by curvature)</span>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="control-section">
                    <h3>Surface Statistics</h3>
                    <div class="stat-item">
                        <span class="stat-label">Surface Area:</span>
                        <span class="stat-value" id="statArea">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Mean Curvature:</span>
                        <span class="stat-value" id="statMeanCurv">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Gaussian Curv:</span>
                        <span class="stat-value" id="statGaussCurv">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Vertices:</span>
                        <span class="stat-value" id="statVertices">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Triangles:</span>
                        <span class="stat-value" id="statTriangles">0</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Convergence</h3>
                    <div class="stat-item">
                        <span class="stat-label">Iteration:</span>
                        <span class="stat-value" id="statIteration">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Energy:</span>
                        <span class="stat-value" id="statEnergy">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Converged:</span>
                        <span class="stat-value" id="statConverged">No</span>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Area Minimization</div>
                    <canvas id="areaChart" class="mini-canvas"></canvas>
                </div>

                <div class="info-box">
                    <strong>Physics:</strong> Soap films minimize surface area due to surface tension. This creates minimal surfaces with zero mean curvature everywhere. Plateau's problem (solved 1930) proves such surfaces exist for any closed boundary curve, following Plateau's rules for angles at intersections.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Soap Film Minimal Surface Simulation
        // Uses gradient descent on surface area to find minimal surfaces

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const areaCanvas = document.getElementById('areaChart');
        const areaCtx = areaCanvas.getContext('2d');

        // Mesh data
        let vertices = [];
        let edges = [];
        let faces = [];
        let boundaryVertices = new Set();

        // Parameters
        let resolution = 20;
        let surfaceTension = 0.5;
        let damping = 0.9;
        let rotationSpeed = 0.5;
        let showWireframe = true;
        let showNormals = false;
        let colorByCurvature = true;

        // State
        let running = false;
        let animationId = null;
        let iteration = 0;
        let rotationAngle = 0;
        let areaHistory = [];
        let converged = false;

        // 3D projection parameters
        const focalLength = 400;
        const cameraZ = 5;

        // Create initial mesh for a boundary shape
        function createMesh(shape) {
            vertices = [];
            edges = [];
            faces = [];
            boundaryVertices = new Set();
            iteration = 0;
            areaHistory = [];
            converged = false;

            const n = resolution;

            switch(shape) {
                case 'circle':
                    createCircleMesh(n);
                    break;
                case 'square':
                    createSquareMesh(n);
                    break;
                case 'trefoil':
                    createTrefoilMesh(n);
                    break;
                case 'saddle':
                    createSaddleMesh(n);
                    break;
                case 'helix':
                    createHelicoidMesh(n);
                    break;
                case 'catenoid':
                    createCatenoidMesh(n);
                    break;
                default:
                    createCircleMesh(n);
            }
        }

        // Create circular disk mesh
        function createCircleMesh(n) {
            // Center vertex
            vertices.push({ x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 });

            // Radial vertices
            for (let ring = 1; ring <= n; ring++) {
                const r = ring / n;
                const numVerts = Math.max(6, ring * 6);
                for (let i = 0; i < numVerts; i++) {
                    const angle = (i / numVerts) * Math.PI * 2;
                    vertices.push({
                        x: r * Math.cos(angle),
                        y: r * Math.sin(angle),
                        z: 0,
                        vx: 0, vy: 0, vz: 0
                    });
                    if (ring === n) {
                        boundaryVertices.add(vertices.length - 1);
                    }
                }
            }

            // Create triangular faces
            let offset = 1;
            for (let ring = 1; ring <= n; ring++) {
                const numVerts = Math.max(6, ring * 6);
                const prevNumVerts = ring === 1 ? 1 : Math.max(6, (ring - 1) * 6);

                if (ring === 1) {
                    // Connect to center
                    for (let i = 0; i < numVerts; i++) {
                        const next = (i + 1) % numVerts;
                        faces.push([0, offset + i, offset + next]);
                    }
                } else {
                    // Connect to previous ring
                    const prevOffset = offset - prevNumVerts;
                    for (let i = 0; i < numVerts; i++) {
                        const next = (i + 1) % numVerts;
                        const prevI = Math.floor(i * prevNumVerts / numVerts);
                        const prevNext = (prevI + 1) % prevNumVerts;

                        faces.push([prevOffset + prevI, offset + i, offset + next]);
                        if (prevI !== Math.floor(next * prevNumVerts / numVerts)) {
                            faces.push([prevOffset + prevI, offset + next, prevOffset + prevNext]);
                        }
                    }
                }
                offset += numVerts;
            }

            createEdgesFromFaces();
        }

        // Create square frame mesh
        function createSquareMesh(n) {
            // Grid vertices
            for (let i = 0; i <= n; i++) {
                for (let j = 0; j <= n; j++) {
                    const x = (i / n - 0.5) * 2;
                    const y = (j / n - 0.5) * 2;
                    vertices.push({
                        x, y, z: 0,
                        vx: 0, vy: 0, vz: 0
                    });
                    if (i === 0 || i === n || j === 0 || j === n) {
                        boundaryVertices.add(vertices.length - 1);
                    }
                }
            }

            // Create triangular faces
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const idx = i * (n + 1) + j;
                    faces.push([idx, idx + 1, idx + n + 2]);
                    faces.push([idx, idx + n + 2, idx + n + 1]);
                }
            }

            createEdgesFromFaces();
        }

        // Create trefoil knot boundary mesh
        function createTrefoilMesh(n) {
            // Create boundary curve
            const boundaryPoints = [];
            const numBoundary = n * 3;

            for (let i = 0; i < numBoundary; i++) {
                const t = (i / numBoundary) * Math.PI * 2;
                // Trefoil knot parametrization
                const x = Math.sin(t) + 2 * Math.sin(2 * t);
                const y = Math.cos(t) - 2 * Math.cos(2 * t);
                const z = -Math.sin(3 * t);
                boundaryPoints.push({ x: x * 0.3, y: y * 0.3, z: z * 0.3 });
            }

            // Create disk-like mesh filling
            vertices.push({ x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 });

            // Interpolate to boundary
            const rings = Math.floor(n / 2);
            for (let ring = 1; ring <= rings; ring++) {
                const t = ring / rings;
                for (let i = 0; i < numBoundary; i++) {
                    const bp = boundaryPoints[i];
                    vertices.push({
                        x: bp.x * t,
                        y: bp.y * t,
                        z: bp.z * t,
                        vx: 0, vy: 0, vz: 0
                    });
                    if (ring === rings) {
                        boundaryVertices.add(vertices.length - 1);
                    }
                }
            }

            // Create faces
            let offset = 1;
            for (let ring = 1; ring <= rings; ring++) {
                if (ring === 1) {
                    for (let i = 0; i < numBoundary; i++) {
                        const next = (i + 1) % numBoundary;
                        faces.push([0, offset + i, offset + next]);
                    }
                } else {
                    const prevOffset = offset - numBoundary;
                    for (let i = 0; i < numBoundary; i++) {
                        const next = (i + 1) % numBoundary;
                        faces.push([prevOffset + i, offset + i, offset + next]);
                        faces.push([prevOffset + i, offset + next, prevOffset + next]);
                    }
                }
                offset += numBoundary;
            }

            createEdgesFromFaces();
        }

        // Create saddle-shaped frame
        function createSaddleMesh(n) {
            // Grid with saddle boundary
            for (let i = 0; i <= n; i++) {
                for (let j = 0; j <= n; j++) {
                    const x = (i / n - 0.5) * 2;
                    const y = (j / n - 0.5) * 2;
                    let z = 0;

                    // Saddle boundary conditions
                    if (i === 0 || i === n || j === 0 || j === n) {
                        z = x * x - y * y;
                        boundaryVertices.add(vertices.length);
                    }

                    vertices.push({
                        x, y, z: z * 0.5,
                        vx: 0, vy: 0, vz: 0
                    });
                }
            }

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const idx = i * (n + 1) + j;
                    faces.push([idx, idx + 1, idx + n + 2]);
                    faces.push([idx, idx + n + 2, idx + n + 1]);
                }
            }

            createEdgesFromFaces();
        }

        // Create helicoid surface
        function createHelicoidMesh(n) {
            const twists = 1;

            for (let i = 0; i <= n; i++) {
                const u = (i / n - 0.5) * 2;
                for (let j = 0; j <= n; j++) {
                    const v = (j / n) * Math.PI * 2 * twists;

                    const x = u * Math.cos(v);
                    const y = u * Math.sin(v);
                    const z = v / (Math.PI * 2) * 0.5;

                    vertices.push({
                        x, y, z,
                        vx: 0, vy: 0, vz: 0
                    });

                    if (i === 0 || i === n || j === 0 || j === n) {
                        boundaryVertices.add(vertices.length - 1);
                    }
                }
            }

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const idx = i * (n + 1) + j;
                    faces.push([idx, idx + 1, idx + n + 2]);
                    faces.push([idx, idx + n + 2, idx + n + 1]);
                }
            }

            createEdgesFromFaces();
        }

        // Create catenoid surface
        function createCatenoidMesh(n) {
            const a = 0.5;

            for (let i = 0; i <= n; i++) {
                const u = (i / n - 0.5) * 2;
                for (let j = 0; j <= n; j++) {
                    const v = (j / n) * Math.PI * 2;

                    const coshU = (Math.exp(u) + Math.exp(-u)) / 2;
                    const x = a * coshU * Math.cos(v);
                    const y = a * coshU * Math.sin(v);
                    const z = u * 0.5;

                    vertices.push({
                        x, y, z,
                        vx: 0, vy: 0, vz: 0
                    });

                    if (i === 0 || i === n) {
                        boundaryVertices.add(vertices.length - 1);
                    }
                }
            }

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const idx = i * (n + 1) + j;
                    const nextJ = (j + 1) % (n + 1);
                    faces.push([idx, i * (n + 1) + nextJ, (i + 1) * (n + 1) + nextJ]);
                    faces.push([idx, (i + 1) * (n + 1) + nextJ, (i + 1) * (n + 1) + j]);
                }
            }

            createEdgesFromFaces();
        }

        // Create edges from faces
        function createEdgesFromFaces() {
            const edgeSet = new Set();
            edges = [];

            faces.forEach(face => {
                for (let i = 0; i < face.length; i++) {
                    const a = face[i];
                    const b = face[(i + 1) % face.length];
                    const key = Math.min(a, b) + ',' + Math.max(a, b);
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        edges.push([a, b]);
                    }
                }
            });
        }

        // Minimize surface area using gradient descent
        function minimizeStep() {
            const dt = surfaceTension * 0.1;

            // Calculate forces on each vertex
            vertices.forEach((v, i) => {
                if (boundaryVertices.has(i)) return;

                // Find neighboring vertices
                const neighbors = [];
                edges.forEach(edge => {
                    if (edge[0] === i) neighbors.push(edge[1]);
                    if (edge[1] === i) neighbors.push(edge[0]);
                });

                if (neighbors.length === 0) return;

                // Calculate mean curvature force (Laplacian smoothing)
                let fx = 0, fy = 0, fz = 0;
                neighbors.forEach(ni => {
                    fx += vertices[ni].x - v.x;
                    fy += vertices[ni].y - v.y;
                    fz += vertices[ni].z - v.z;
                });

                fx /= neighbors.length;
                fy /= neighbors.length;
                fz /= neighbors.length;

                // Update velocity with damping
                v.vx = v.vx * damping + fx * dt;
                v.vy = v.vy * damping + fy * dt;
                v.vz = v.vz * damping + fz * dt;
            });

            // Update positions
            let maxMove = 0;
            vertices.forEach((v, i) => {
                if (boundaryVertices.has(i)) return;

                v.x += v.vx;
                v.y += v.vy;
                v.z += v.vz;

                const move = Math.sqrt(v.vx*v.vx + v.vy*v.vy + v.vz*v.vz);
                if (move > maxMove) maxMove = move;
            });

            iteration++;

            // Check convergence
            if (maxMove < 0.0001) {
                converged = true;
            }

            // Track area history
            const area = calculateSurfaceArea();
            areaHistory.push(area);
            if (areaHistory.length > 200) areaHistory.shift();
        }

        // Calculate surface area
        function calculateSurfaceArea() {
            let area = 0;

            faces.forEach(face => {
                const v0 = vertices[face[0]];
                const v1 = vertices[face[1]];
                const v2 = vertices[face[2]];

                // Cross product for area
                const ax = v1.x - v0.x;
                const ay = v1.y - v0.y;
                const az = v1.z - v0.z;
                const bx = v2.x - v0.x;
                const by = v2.y - v0.y;
                const bz = v2.z - v0.z;

                const cx = ay * bz - az * by;
                const cy = az * bx - ax * bz;
                const cz = ax * by - ay * bx;

                area += 0.5 * Math.sqrt(cx*cx + cy*cy + cz*cz);
            });

            return area;
        }

        // Calculate mean curvature at each vertex
        function calculateCurvatures() {
            return vertices.map((v, i) => {
                if (boundaryVertices.has(i)) return { mean: 0, gaussian: 0 };

                const neighbors = [];
                edges.forEach(edge => {
                    if (edge[0] === i) neighbors.push(edge[1]);
                    if (edge[1] === i) neighbors.push(edge[0]);
                });

                if (neighbors.length === 0) return { mean: 0, gaussian: 0 };

                // Laplacian as approximation of mean curvature
                let lx = 0, ly = 0, lz = 0;
                neighbors.forEach(ni => {
                    lx += vertices[ni].x - v.x;
                    ly += vertices[ni].y - v.y;
                    lz += vertices[ni].z - v.z;
                });

                const meanCurv = Math.sqrt(lx*lx + ly*ly + lz*lz) / neighbors.length;

                return { mean: meanCurv, gaussian: 0 };
            });
        }

        // 3D to 2D projection
        function project(x, y, z) {
            // Rotate around Y axis
            const cosR = Math.cos(rotationAngle);
            const sinR = Math.sin(rotationAngle);
            const rx = x * cosR - z * sinR;
            const rz = x * sinR + z * cosR;

            // Rotate around X axis slightly
            const tilt = 0.3;
            const cosT = Math.cos(tilt);
            const sinT = Math.sin(tilt);
            const ry = y * cosT - rz * sinT;
            const fz = y * sinT + rz * cosT;

            // Perspective projection
            const scale = focalLength / (cameraZ - fz + 3);
            return {
                x: canvas.width / 2 + rx * scale * 150,
                y: canvas.height / 2 - ry * scale * 150,
                z: fz
            };
        }

        // Draw the surface
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            rotationAngle += rotationSpeed * 0.02;

            const curvatures = calculateCurvatures();
            const maxCurv = Math.max(...curvatures.map(c => c.mean), 0.1);

            // Project all vertices
            const projected = vertices.map(v => project(v.x, v.y, v.z));

            // Sort faces by depth for proper rendering
            const sortedFaces = faces.map((face, i) => {
                const avgZ = (projected[face[0]].z + projected[face[1]].z + projected[face[2]].z) / 3;
                return { face, avgZ, idx: i };
            }).sort((a, b) => a.avgZ - b.avgZ);

            // Draw faces
            sortedFaces.forEach(({ face }) => {
                const p0 = projected[face[0]];
                const p1 = projected[face[1]];
                const p2 = projected[face[2]];

                // Calculate face normal for shading
                const v0 = vertices[face[0]];
                const v1 = vertices[face[1]];
                const v2 = vertices[face[2]];

                const ax = v1.x - v0.x;
                const ay = v1.y - v0.y;
                const az = v1.z - v0.z;
                const bx = v2.x - v0.x;
                const by = v2.y - v0.y;
                const bz = v2.z - v0.z;

                const nx = ay * bz - az * by;
                const ny = az * bx - ax * bz;
                const nz = ax * by - ay * bx;
                const mag = Math.sqrt(nx*nx + ny*ny + nz*nz);

                // Light direction
                const light = (nz / mag + 1) * 0.5;

                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.closePath();

                if (colorByCurvature) {
                    // Color by mean curvature
                    const avgCurv = (curvatures[face[0]].mean + curvatures[face[1]].mean + curvatures[face[2]].mean) / 3;
                    const t = Math.min(avgCurv / maxCurv, 1);

                    const r = Math.floor(78 + t * 177);
                    const g = Math.floor(205 - t * 98);
                    const b = Math.floor(196 - t * 91);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.7 + light * 0.3})`;
                } else {
                    const shade = Math.floor(100 + light * 100);
                    ctx.fillStyle = `rgba(${shade}, ${shade + 50}, ${shade + 100}, 0.8)`;
                }

                ctx.fill();

                if (showWireframe) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            });

            // Draw boundary
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;

            const boundaryList = Array.from(boundaryVertices);
            if (boundaryList.length > 0) {
                // Sort boundary vertices by angle for connected drawing
                const center = { x: 0, y: 0 };
                boundaryList.forEach(i => {
                    center.x += vertices[i].x;
                    center.y += vertices[i].y;
                });
                center.x /= boundaryList.length;
                center.y /= boundaryList.length;

                // Draw boundary edges
                edges.forEach(edge => {
                    if (boundaryVertices.has(edge[0]) && boundaryVertices.has(edge[1])) {
                        const p0 = projected[edge[0]];
                        const p1 = projected[edge[1]];
                        ctx.beginPath();
                        ctx.moveTo(p0.x, p0.y);
                        ctx.lineTo(p1.x, p1.y);
                        ctx.stroke();
                    }
                });
            }

            // Draw normals if enabled
            if (showNormals) {
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 1;

                for (let i = 0; i < vertices.length; i += 3) {
                    if (boundaryVertices.has(i)) continue;

                    const v = vertices[i];
                    const neighbors = [];
                    edges.forEach(edge => {
                        if (edge[0] === i) neighbors.push(edge[1]);
                        if (edge[1] === i) neighbors.push(edge[0]);
                    });

                    if (neighbors.length < 3) continue;

                    // Estimate normal from neighbors
                    let nx = 0, ny = 0, nz = 0;
                    for (let j = 0; j < neighbors.length; j++) {
                        const n1 = neighbors[j];
                        const n2 = neighbors[(j + 1) % neighbors.length];
                        const v1 = vertices[n1];
                        const v2 = vertices[n2];

                        const ax = v1.x - v.x;
                        const ay = v1.y - v.y;
                        const az = v1.z - v.z;
                        const bx = v2.x - v.x;
                        const by = v2.y - v.y;
                        const bz = v2.z - v.z;

                        nx += ay * bz - az * by;
                        ny += az * bx - ax * bz;
                        nz += ax * by - ay * bx;
                    }

                    const mag = Math.sqrt(nx*nx + ny*ny + nz*nz);
                    if (mag > 0) {
                        nx /= mag; ny /= mag; nz /= mag;
                        const p0 = projected[i];
                        const p1 = project(v.x + nx * 0.1, v.y + ny * 0.1, v.z + nz * 0.1);
                        ctx.beginPath();
                        ctx.moveTo(p0.x, p0.y);
                        ctx.lineTo(p1.x, p1.y);
                        ctx.stroke();
                    }
                }
            }

            updateStats(curvatures);
        }

        // Update statistics display
        function updateStats(curvatures) {
            const area = calculateSurfaceArea();
            const meanCurvatures = curvatures.filter(c => c.mean > 0).map(c => c.mean);
            const avgMeanCurv = meanCurvatures.length > 0 ?
                meanCurvatures.reduce((a, b) => a + b, 0) / meanCurvatures.length : 0;

            document.getElementById('statArea').textContent = area.toFixed(4);
            document.getElementById('statMeanCurv').textContent = avgMeanCurv.toFixed(6);
            document.getElementById('statGaussCurv').textContent = '~0';
            document.getElementById('statVertices').textContent = vertices.length;
            document.getElementById('statTriangles').textContent = faces.length;
            document.getElementById('statIteration').textContent = iteration;
            document.getElementById('statEnergy').textContent = area.toFixed(4);
            document.getElementById('statConverged').textContent = converged ? 'Yes' : 'No';

            drawAreaChart();
        }

        // Draw area minimization chart
        function drawAreaChart() {
            const w = areaCanvas.width = areaCanvas.offsetWidth;
            const h = areaCanvas.height = 60;

            areaCtx.clearRect(0, 0, w, h);
            areaCtx.fillStyle = '#f8f8f8';
            areaCtx.fillRect(0, 0, w, h);

            if (areaHistory.length < 2) {
                areaCtx.fillStyle = '#999';
                areaCtx.font = '10px Nunito';
                areaCtx.textAlign = 'center';
                areaCtx.fillText('Start relaxation to see area reduction', w/2, h/2);
                return;
            }

            const minArea = Math.min(...areaHistory);
            const maxArea = Math.max(...areaHistory);
            const range = maxArea - minArea || 1;
            const step = (w - 20) / (areaHistory.length - 1);

            areaCtx.strokeStyle = '#4A90D9';
            areaCtx.lineWidth = 2;
            areaCtx.beginPath();

            areaHistory.forEach((area, i) => {
                const x = 10 + i * step;
                const y = h - 5 - ((area - minArea) / range) * (h - 15);

                if (i === 0) {
                    areaCtx.moveTo(x, y);
                } else {
                    areaCtx.lineTo(x, y);
                }
            });

            areaCtx.stroke();
        }

        // Animation loop
        function animate() {
            if (running && !converged) {
                for (let i = 0; i < 5; i++) {
                    minimizeStep();
                }
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Preset selection
        function setPreset(shape) {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Relaxation';
            createMesh(shape);
        }
        window.setPreset = setPreset;

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            converged = false;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Continue';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Relaxation';
            createMesh('circle');
        });

        document.getElementById('resolution').addEventListener('input', function() {
            resolution = parseInt(this.value);
            document.getElementById('resolutionVal').textContent = this.value;
            createMesh('circle');
        });

        document.getElementById('tension').addEventListener('input', function() {
            surfaceTension = parseFloat(this.value);
            document.getElementById('tensionVal').textContent = this.value;
        });

        document.getElementById('damping').addEventListener('input', function() {
            damping = parseFloat(this.value);
            document.getElementById('dampingVal').textContent = this.value;
        });

        document.getElementById('rotSpeed').addEventListener('input', function() {
            rotationSpeed = parseFloat(this.value);
            document.getElementById('rotSpeedVal').textContent = this.value;
        });

        document.getElementById('showWireframe').addEventListener('change', function() {
            showWireframe = this.checked;
        });

        document.getElementById('showNormals').addEventListener('change', function() {
            showNormals = this.checked;
        });

        document.getElementById('colorByCurvature').addEventListener('change', function() {
            colorByCurvature = this.checked;
        });

        // Initialize
        createMesh('circle');
        animate();
    </script>
</body>
</html>
