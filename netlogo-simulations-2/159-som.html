<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Organizing Maps - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #f97316; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; background: #333; color: #fff; border: none; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #f97316; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f97316; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info { background: rgba(249,115,22,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; border-left: 3px solid #f97316; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Self-Organizing Maps</h1>
            <div class="control-group">
                <label>Data Distribution:</label>
                <select id="distribution">
                    <option value="colors">RGB Colors</option>
                    <option value="ring">Ring Shape</option>
                    <option value="clusters">Clusters</option>
                </select>
            </div>
            <div class="control-group">
                <label>Grid Size: <span id="gridValue">10</span>×<span id="gridValue2">10</span></label>
                <input type="range" id="grid" min="5" max="20" step="1" value="10">
            </div>
            <div class="control-group">
                <label>Learning Rate: <span id="lrValue">0.5</span></label>
                <input type="range" id="lr" min="0.1" max="1" step="0.05" value="0.5">
            </div>
            <button id="reset">Reset Network</button>
            <button id="step">Training Step (100)</button>
            <button id="train">Train (1000 steps)</button>
            <div class="stats">
                <div>Iterations: <span id="iterations">0</span></div>
                <div>Neighborhood: <span id="neighborhood">-</span></div>
                <div>Current LR: <span id="currentLR">-</span></div>
            </div>
            <div class="info">
                <strong>Kohonen Self-Organizing Map</strong><br><br>
                • Unsupervised learning<br>
                • Preserves topological structure<br>
                • Maps high-D data to 2D grid<br>
                • Watch nodes organize!<br><br>
                Colors show weight values.
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let params = { gridSize: 10, lr: 0.5, distribution: 'colors' };
        let som = [];
        let data = [];
        let iterations = 0;
        let maxIterations = 10000;
        let running = false;

        function resize() {
            canvas.width = document.getElementById('canvas-container').clientWidth;
            canvas.height = document.getElementById('canvas-container').clientHeight;
        }

        function generateData() {
            data = [];
            const numSamples = 500;
            
            if (params.distribution === 'colors') {
                // RGB color space
                for (let i = 0; i < numSamples; i++) {
                    data.push([Math.random(), Math.random(), Math.random()]);
                }
            } else if (params.distribution === 'ring') {
                // Ring in 2D (embedded in 3D for visualization)
                for (let i = 0; i < numSamples; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 0.4 + Math.random() * 0.2;
                    data.push([
                        0.5 + r * Math.cos(angle),
                        0.5 + r * Math.sin(angle),
                        0.5
                    ]);
                }
            } else {
                // Clusters
                const centers = [
                    [0.2, 0.2, 0.2],
                    [0.8, 0.2, 0.5],
                    [0.5, 0.8, 0.8],
                    [0.2, 0.5, 0.9]
                ];
                for (let i = 0; i < numSamples; i++) {
                    const c = centers[Math.floor(Math.random() * centers.length)];
                    data.push([
                        c[0] + (Math.random() - 0.5) * 0.3,
                        c[1] + (Math.random() - 0.5) * 0.3,
                        c[2] + (Math.random() - 0.5) * 0.3
                    ]);
                }
            }
        }

        function initSOM() {
            som = [];
            for (let i = 0; i < params.gridSize; i++) {
                som[i] = [];
                for (let j = 0; j < params.gridSize; j++) {
                    // Initialize weights randomly
                    som[i][j] = [Math.random(), Math.random(), Math.random()];
                }
            }
            iterations = 0;
        }

        function distance(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) {
                sum += Math.pow(a[i] - b[i], 2);
            }
            return Math.sqrt(sum);
        }

        function findBMU(input) {
            let minDist = Infinity;
            let bmu = [0, 0];
            
            for (let i = 0; i < params.gridSize; i++) {
                for (let j = 0; j < params.gridSize; j++) {
                    const d = distance(input, som[i][j]);
                    if (d < minDist) {
                        minDist = d;
                        bmu = [i, j];
                    }
                }
            }
            return bmu;
        }

        function getNeighborhoodRadius() {
            const initialRadius = params.gridSize / 2;
            const timeConstant = maxIterations / Math.log(initialRadius);
            return initialRadius * Math.exp(-iterations / timeConstant);
        }

        function getLearningRate() {
            return params.lr * Math.exp(-iterations / maxIterations);
        }

        function trainStep() {
            // Pick random data point
            const input = data[Math.floor(Math.random() * data.length)];
            
            // Find BMU
            const [bmuI, bmuJ] = findBMU(input);
            
            // Get current parameters
            const radius = getNeighborhoodRadius();
            const lr = getLearningRate();
            
            // Update weights
            for (let i = 0; i < params.gridSize; i++) {
                for (let j = 0; j < params.gridSize; j++) {
                    const dist = Math.sqrt(Math.pow(i - bmuI, 2) + Math.pow(j - bmuJ, 2));
                    
                    if (dist <= radius) {
                        // Gaussian neighborhood function
                        const influence = Math.exp(-(dist * dist) / (2 * radius * radius));
                        
                        for (let k = 0; k < 3; k++) {
                            som[i][j][k] += lr * influence * (input[k] - som[i][j][k]);
                        }
                    }
                }
            }
            
            iterations++;
        }

        function train(steps) {
            for (let s = 0; s < steps; s++) {
                trainStep();
            }
            updateStats();
        }

        function updateStats() {
            document.getElementById('iterations').textContent = iterations;
            document.getElementById('neighborhood').textContent = getNeighborhoodRadius().toFixed(2);
            document.getElementById('currentLR').textContent = getLearningRate().toFixed(4);
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const w = canvas.width - 350;
            const h = canvas.height - 50;
            const cellSize = Math.min(w, h) / params.gridSize;
            const startX = 50;
            const startY = 50;
            
            // Draw SOM grid
            for (let i = 0; i < params.gridSize; i++) {
                for (let j = 0; j < params.gridSize; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;
                    const weights = som[i][j];
                    
                    // Color based on weights (RGB)
                    const r = Math.floor(weights[0] * 255);
                    const g = Math.floor(weights[1] * 255);
                    const b = Math.floor(weights[2] * 255);
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                }
            }
            
            // Draw grid connections
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < params.gridSize; i++) {
                for (let j = 0; j < params.gridSize; j++) {
                    const x = startX + j * cellSize + cellSize / 2;
                    const y = startY + i * cellSize + cellSize / 2;
                    
                    if (j < params.gridSize - 1) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + cellSize, y);
                        ctx.stroke();
                    }
                    if (i < params.gridSize - 1) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, y + cellSize);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw some data points for reference
            const dataX = startX + params.gridSize * cellSize + 50;
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('Training Data Samples:', dataX, startY);
            
            for (let i = 0; i < Math.min(20, data.length); i++) {
                const d = data[i];
                const r = Math.floor(d[0] * 255);
                const g = Math.floor(d[1] * 255);
                const b = Math.floor(d[2] * 255);
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(dataX + (i % 5) * 25, startY + 10 + Math.floor(i / 5) * 25, 20, 20);
            }
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('distribution').addEventListener('change', e => {
            params.distribution = e.target.value;
            generateData();
            initSOM();
        });

        document.getElementById('grid').addEventListener('input', e => {
            params.gridSize = parseInt(e.target.value);
            document.getElementById('gridValue').textContent = params.gridSize;
            document.getElementById('gridValue2').textContent = params.gridSize;
        });

        document.getElementById('lr').addEventListener('input', e => {
            params.lr = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = params.lr;
        });

        document.getElementById('reset').addEventListener('click', () => {
            generateData();
            initSOM();
            updateStats();
        });

        document.getElementById('step').addEventListener('click', () => train(100));
        document.getElementById('train').addEventListener('click', () => train(1000));

        window.addEventListener('resize', resize);

        resize();
        generateData();
        initSOM();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
