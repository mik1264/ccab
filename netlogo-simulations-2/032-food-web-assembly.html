<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Food Web Assembly - Niche Model & Extinction Cascades</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--dark-moss);
            font-size: 0.95rem;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--moss);
            font-size: 0.8rem;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--dark-moss);
            background: white;
        }

        .value-display {
            text-align: right;
            font-size: 0.75rem;
            color: var(--terracotta);
            font-weight: 600;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .btn-full {
            grid-column: span 2;
        }

        .btn-extinction {
            background: var(--terracotta);
            color: white;
            grid-column: span 2;
            margin-top: 8px;
        }

        .btn-extinction:hover {
            background: #a55a1f;
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 16px;
        }

        .viz-panel {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .viz-panel h4 {
            color: var(--dark-moss);
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 280px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .stats-panel {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 12px;
            background: var(--cream);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--moss);
            margin-top: 4px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.7rem;
            color: var(--dark-moss);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .info-panel {
            grid-column: span 2;
            background: linear-gradient(135deg, var(--sage) 0%, var(--moss) 100%);
            color: white;
            padding: 16px;
            border-radius: 12px;
            margin-top: 12px;
        }

        .info-panel h4 {
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .info-panel p {
            font-size: 0.8rem;
            opacity: 0.95;
            line-height: 1.5;
        }

        .trophic-indicator {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 12px;
            padding: 10px;
            background: var(--cream);
            border-radius: 8px;
        }

        .trophic-level {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .trophic-bar {
            flex: 1;
            height: 14px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .trophic-fill {
            height: 100%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Simulations</a>

    <div class="container">
        <header>
            <h1>Food Web Assembly</h1>
            <p class="subtitle">Niche Model, Network Properties & Extinction Cascades</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Web Generation Model</h3>
                    <div class="control-group">
                        <label>Assembly Model</label>
                        <select id="webModel">
                            <option value="niche">Niche Model (Williams & Martinez)</option>
                            <option value="cascade">Cascade Model (Cohen)</option>
                            <option value="random">Random (Erdős-Rényi)</option>
                            <option value="nestedHierarchy">Nested Hierarchy</option>
                        </select>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Network Parameters</h3>
                    <div class="control-group">
                        <label>Number of Species (S)</label>
                        <input type="range" id="numSpecies" min="10" max="80" step="5" value="30">
                        <div class="value-display" id="numSpeciesValue">30</div>
                    </div>
                    <div class="control-group">
                        <label>Connectance (C)</label>
                        <input type="range" id="connectance" min="0.05" max="0.3" step="0.01" value="0.15">
                        <div class="value-display" id="connectanceValue">0.15</div>
                    </div>
                    <div class="control-group">
                        <label>Basal Species Fraction</label>
                        <input type="range" id="basalFraction" min="0.1" max="0.4" step="0.05" value="0.2">
                        <div class="value-display" id="basalFractionValue">0.20</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Dynamics</h3>
                    <div class="control-group">
                        <label>Extinction Threshold</label>
                        <input type="range" id="extinctionThreshold" min="0" max="1" step="0.1" value="0.5">
                        <div class="value-display" id="extinctionThresholdValue">0.50</div>
                    </div>
                    <div class="control-group">
                        <label>Removal Strategy</label>
                        <select id="removalStrategy">
                            <option value="random">Random</option>
                            <option value="mostConnected">Most Connected First</option>
                            <option value="leastConnected">Least Connected First</option>
                            <option value="topPredator">Top Predators First</option>
                            <option value="basal">Basal Species First</option>
                        </select>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Perturbations</h3>
                    <button class="btn-extinction" id="removeSpecies">Remove Species (Trigger Cascade)</button>
                    <button class="btn-extinction" id="runRobustness">Run Robustness Analysis</button>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="generateBtn">Generate Web</button>
                    <button class="btn-secondary" id="stepBtn">Step Cascade</button>
                    <button class="btn-secondary btn-full" id="resetBtn">Reset</button>
                </div>

                <div class="trophic-indicator">
                    <div class="trophic-level">
                        <span style="min-width: 80px; color: var(--dark-moss);">Top Pred:</span>
                        <div class="trophic-bar">
                            <div class="trophic-fill" id="topPredFill" style="background: #e74c3c; width: 0%;"></div>
                        </div>
                        <span id="topPredCount" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="trophic-level">
                        <span style="min-width: 80px; color: var(--dark-moss);">Consumers:</span>
                        <div class="trophic-bar">
                            <div class="trophic-fill" id="consumerFill" style="background: #f39c12; width: 0%;"></div>
                        </div>
                        <span id="consumerCount" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="trophic-level">
                        <span style="min-width: 80px; color: var(--dark-moss);">Basal:</span>
                        <div class="trophic-bar">
                            <div class="trophic-fill" id="basalFill" style="background: #27ae60; width: 0%;"></div>
                        </div>
                        <span id="basalCount" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Basal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Consumer</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Top Pred</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #666;"></div>
                        <span>Extinct</span>
                    </div>
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h4>Food Web Network</h4>
                    <div class="canvas-container">
                        <canvas id="networkCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Trophic Pyramid</h4>
                    <div class="canvas-container">
                        <canvas id="pyramidCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Degree Distribution</h4>
                    <div class="canvas-container">
                        <canvas id="degreeCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Robustness Curve (R50)</h4>
                    <div class="canvas-container">
                        <canvas id="robustnessCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="speciesCount">0</div>
                    <div class="stat-label">Species (S)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="linksCount">0</div>
                    <div class="stat-label">Links (L)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="actualConnectance">0</div>
                    <div class="stat-label">Connectance (C)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="linkDensity">0</div>
                    <div class="stat-label">Link Density (L/S)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="meanTrophic">0</div>
                    <div class="stat-label">Mean Trophic Level</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="maxChainLength">0</div>
                    <div class="stat-label">Max Chain Length</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="extinctions">0</div>
                    <div class="stat-label">Secondary Extinctions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="r50">-</div>
                    <div class="stat-label">R50 Robustness</div>
                </div>
            </div>
            <div class="info-panel">
                <h4>Food Web Assembly Models (Williams & Martinez 2000)</h4>
                <p><strong>Niche Model:</strong> Each species has a niche value n ∈ [0,1] and eats species with niche values in a contiguous range below it.
                <strong>Cascade Model:</strong> Species only eat species with lower niche values (hierarchical).
                <strong>Connectance</strong> C = L/S² predicts network robustness. Higher connectance generally increases stability but R50 depends on network type and extinction thresholds.</p>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const networkCanvas = document.getElementById('networkCanvas');
        const pyramidCanvas = document.getElementById('pyramidCanvas');
        const degreeCanvas = document.getElementById('degreeCanvas');
        const robustnessCanvas = document.getElementById('robustnessCanvas');

        const nCtx = networkCanvas.getContext('2d');
        const pCtx = pyramidCanvas.getContext('2d');
        const dCtx = degreeCanvas.getContext('2d');
        const rCtx = robustnessCanvas.getContext('2d');

        function resizeCanvas(canvas) {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        [networkCanvas, pyramidCanvas, degreeCanvas, robustnessCanvas].forEach(resizeCanvas);
        window.addEventListener('resize', () => {
            [networkCanvas, pyramidCanvas, degreeCanvas, robustnessCanvas].forEach(resizeCanvas);
        });

        // Model state
        let species = [];
        let links = [];
        let params = {};
        let extinctionHistory = [];
        let robustnessData = [];
        let secondaryExtinctions = 0;

        function updateParams() {
            params = {
                webModel: document.getElementById('webModel').value,
                numSpecies: parseInt(document.getElementById('numSpecies').value),
                connectance: parseFloat(document.getElementById('connectance').value),
                basalFraction: parseFloat(document.getElementById('basalFraction').value),
                extinctionThreshold: parseFloat(document.getElementById('extinctionThreshold').value),
                removalStrategy: document.getElementById('removalStrategy').value
            };
        }

        // Generate food web using specified model
        function generateWeb() {
            species = [];
            links = [];
            extinctionHistory = [];
            robustnessData = [];
            secondaryExtinctions = 0;

            const S = params.numSpecies;
            const C = params.connectance;
            const L = Math.floor(C * S * S); // Target number of links

            // Create species with niche values
            for (let i = 0; i < S; i++) {
                species.push({
                    id: i,
                    niche: Math.random(),
                    alive: true,
                    x: 0, y: 0, // Position for visualization
                    trophicLevel: 1,
                    preyCount: 0,
                    predatorCount: 0
                });
            }

            // Sort by niche value
            species.sort((a, b) => a.niche - b.niche);
            species.forEach((s, i) => s.id = i);

            // Generate links based on model
            if (params.webModel === 'niche') {
                generateNicheModel(S, C);
            } else if (params.webModel === 'cascade') {
                generateCascadeModel(S, C);
            } else if (params.webModel === 'random') {
                generateRandomModel(S, L);
            } else {
                generateNestedHierarchy(S, C);
            }

            // Calculate trophic levels
            calculateTrophicLevels();

            // Set positions based on trophic level
            positionSpecies();

            // Count prey/predators
            updateDegrees();
        }

        function generateNicheModel(S, C) {
            // Williams & Martinez 2000 niche model
            const beta = 1 / (2 * C) - 1;

            species.forEach((consumer, i) => {
                if (i === 0) return; // Lowest niche species has no prey

                // Range of prey (from beta distribution)
                const r = consumer.niche * Math.pow(Math.random(), 1 / beta);

                // Center of range
                const c = Math.random() * consumer.niche;

                // Diet range
                const lower = Math.max(0, c - r/2);
                const upper = Math.min(consumer.niche, c + r/2);

                // Find prey in range
                species.forEach((prey, j) => {
                    if (prey.niche >= lower && prey.niche < upper && i !== j) {
                        links.push({ predator: i, prey: j, alive: true });
                    }
                });
            });
        }

        function generateCascadeModel(S, C) {
            // Cohen cascade model - species can only eat lower niche values
            const p = 2 * C; // Probability of each potential link

            for (let i = 1; i < S; i++) {
                for (let j = 0; j < i; j++) {
                    if (Math.random() < p) {
                        links.push({ predator: i, prey: j, alive: true });
                    }
                }
            }
        }

        function generateRandomModel(S, L) {
            // Erdős-Rényi random graph
            const attempts = L * 5;
            const added = new Set();

            for (let a = 0; a < attempts && links.length < L; a++) {
                const i = Math.floor(Math.random() * S);
                const j = Math.floor(Math.random() * S);
                if (i !== j) {
                    const key = `${i}-${j}`;
                    if (!added.has(key)) {
                        added.add(key);
                        links.push({ predator: i, prey: j, alive: true });
                    }
                }
            }
        }

        function generateNestedHierarchy(S, C) {
            // Nested hierarchy model
            const numGroups = Math.ceil(Math.sqrt(S));

            // Assign species to groups
            species.forEach((s, i) => {
                s.group = Math.floor(s.niche * numGroups);
            });

            // Links within and between adjacent groups
            const p = 2 * C;

            for (let i = 0; i < S; i++) {
                for (let j = 0; j < i; j++) {
                    const groupDiff = species[i].group - species[j].group;
                    if (groupDiff >= 0 && groupDiff <= 1) {
                        if (Math.random() < p) {
                            links.push({ predator: i, prey: j, alive: true });
                        }
                    }
                }
            }
        }

        function calculateTrophicLevels() {
            // Short-weighted trophic level
            const maxIter = 100;

            // Initialize basal species
            species.forEach(s => {
                s.trophicLevel = 1;
            });

            for (let iter = 0; iter < maxIter; iter++) {
                let changed = false;

                species.forEach((consumer, i) => {
                    if (!consumer.alive) return;

                    const prey = links.filter(l => l.predator === i && l.alive)
                                     .map(l => species[l.prey])
                                     .filter(p => p.alive);

                    if (prey.length > 0) {
                        const avgPreyLevel = prey.reduce((sum, p) => sum + p.trophicLevel, 0) / prey.length;
                        const newLevel = avgPreyLevel + 1;
                        if (Math.abs(newLevel - consumer.trophicLevel) > 0.01) {
                            consumer.trophicLevel = newLevel;
                            changed = true;
                        }
                    }
                });

                if (!changed) break;
            }
        }

        function positionSpecies() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            const margin = 50;

            // Group by trophic level
            const maxTL = Math.max(...species.filter(s => s.alive).map(s => s.trophicLevel));

            species.forEach(s => {
                if (!s.alive) return;

                // Y position based on trophic level
                s.y = height - margin - ((s.trophicLevel - 1) / Math.max(1, maxTL - 1)) * (height - 2 * margin);

                // X position with some randomness within level
                const levelSpecies = species.filter(sp => sp.alive && Math.abs(sp.trophicLevel - s.trophicLevel) < 0.5);
                const index = levelSpecies.indexOf(s);
                const spacing = (width - 2 * margin) / Math.max(1, levelSpecies.length);
                s.x = margin + spacing * (index + 0.5) + (Math.random() - 0.5) * 20;
            });

            // Apply force-directed adjustment
            for (let iter = 0; iter < 50; iter++) {
                species.forEach((s, i) => {
                    if (!s.alive) return;

                    let fx = 0, fy = 0;

                    // Repulsion from other species
                    species.forEach((other, j) => {
                        if (i === j || !other.alive) return;

                        const dx = s.x - other.x;
                        const dy = s.y - other.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) + 1;

                        if (dist < 60) {
                            fx += (dx / dist) * (60 - dist) * 0.5;
                            fy += (dy / dist) * (60 - dist) * 0.2;
                        }
                    });

                    // Keep within bounds
                    s.x = Math.max(margin, Math.min(width - margin, s.x + fx));
                    // Keep Y relatively fixed to trophic level
                    s.y = Math.max(margin, Math.min(height - margin, s.y + fy * 0.1));
                });
            }
        }

        function updateDegrees() {
            species.forEach(s => {
                s.preyCount = 0;
                s.predatorCount = 0;
            });

            links.forEach(l => {
                if (l.alive) {
                    species[l.predator].preyCount++;
                    species[l.prey].predatorCount++;
                }
            });
        }

        function getSpeciesColor(s) {
            if (!s.alive) return '#444';

            const prey = links.filter(l => l.predator === s.id && l.alive);
            const predators = links.filter(l => l.prey === s.id && l.alive);

            if (prey.length === 0) return '#27ae60'; // Basal (green)
            if (predators.length === 0) return '#e74c3c'; // Top predator (red)
            return '#f39c12'; // Intermediate (orange)
        }

        function removeOneSpecies() {
            const alive = species.filter(s => s.alive);
            if (alive.length === 0) return;

            let target;
            const strategy = params.removalStrategy;

            if (strategy === 'random') {
                target = alive[Math.floor(Math.random() * alive.length)];
            } else if (strategy === 'mostConnected') {
                target = alive.reduce((max, s) =>
                    (s.preyCount + s.predatorCount) > (max.preyCount + max.predatorCount) ? s : max);
            } else if (strategy === 'leastConnected') {
                target = alive.reduce((min, s) =>
                    (s.preyCount + s.predatorCount) < (min.preyCount + min.predatorCount) ? s : min);
            } else if (strategy === 'topPredator') {
                const tops = alive.filter(s => s.predatorCount === 0 && s.preyCount > 0);
                target = tops.length > 0 ? tops[Math.floor(Math.random() * tops.length)] : alive[0];
            } else if (strategy === 'basal') {
                const basals = alive.filter(s => s.preyCount === 0);
                target = basals.length > 0 ? basals[Math.floor(Math.random() * basals.length)] : alive[0];
            }

            if (target) {
                target.alive = false;
                extinctionHistory.push({ type: 'primary', species: target.id });

                // Remove links involving this species
                links.forEach(l => {
                    if (l.predator === target.id || l.prey === target.id) {
                        l.alive = false;
                    }
                });

                // Trigger secondary extinctions
                triggerSecondaryExtinctions();
            }
        }

        function triggerSecondaryExtinctions() {
            let cascadeHappened = true;

            while (cascadeHappened) {
                cascadeHappened = false;

                species.forEach(s => {
                    if (!s.alive) return;

                    // Check if consumer has enough prey
                    const preyLinks = links.filter(l => l.predator === s.id && l.alive);
                    const originalPrey = links.filter(l => l.predator === s.id);

                    if (originalPrey.length > 0) {
                        const preyRemaining = preyLinks.length / originalPrey.length;

                        if (preyRemaining < params.extinctionThreshold) {
                            // Secondary extinction
                            s.alive = false;
                            secondaryExtinctions++;
                            extinctionHistory.push({ type: 'secondary', species: s.id });

                            links.forEach(l => {
                                if (l.predator === s.id || l.prey === s.id) {
                                    l.alive = false;
                                }
                            });

                            cascadeHappened = true;
                        }
                    }
                });
            }

            updateDegrees();
            calculateTrophicLevels();
            positionSpecies();
        }

        function runRobustnessAnalysis() {
            // Reset and regenerate
            generateWeb();
            robustnessData = [];

            const initialS = species.length;
            let removals = 0;

            while (species.filter(s => s.alive).length > 0) {
                const surviving = species.filter(s => s.alive).length;
                robustnessData.push({
                    removals: removals,
                    surviving: surviving / initialS,
                    secondary: secondaryExtinctions
                });

                removeOneSpecies();
                removals++;

                if (removals > initialS) break;
            }

            robustnessData.push({
                removals: removals,
                surviving: 0,
                secondary: secondaryExtinctions
            });

            draw();
        }

        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            nCtx.fillStyle = '#1a1a1a';
            nCtx.fillRect(0, 0, width, height);

            // Draw links
            links.forEach(l => {
                if (!l.alive) return;

                const pred = species[l.predator];
                const prey = species[l.prey];

                if (!pred.alive || !prey.alive) return;

                nCtx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                nCtx.lineWidth = 1;
                nCtx.beginPath();
                nCtx.moveTo(pred.x, pred.y);
                nCtx.lineTo(prey.x, prey.y);
                nCtx.stroke();
            });

            // Draw species nodes
            species.forEach(s => {
                const color = getSpeciesColor(s);
                const radius = s.alive ? 6 + Math.sqrt(s.preyCount + s.predatorCount) : 4;

                nCtx.beginPath();
                nCtx.arc(s.x, s.y, radius, 0, Math.PI * 2);
                nCtx.fillStyle = color;
                nCtx.fill();

                if (s.alive) {
                    nCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                    nCtx.lineWidth = 1;
                    nCtx.stroke();
                }
            });

            // Trophic level labels
            nCtx.fillStyle = '#666';
            nCtx.font = '10px sans-serif';
            nCtx.textAlign = 'left';
            const maxTL = Math.ceil(Math.max(...species.filter(s => s.alive).map(s => s.trophicLevel)));
            for (let tl = 1; tl <= maxTL; tl++) {
                const y = height - 50 - ((tl - 1) / Math.max(1, maxTL - 1)) * (height - 100);
                nCtx.fillText('TL ' + tl, 5, y);
            }
        }

        function drawPyramid() {
            const width = pyramidCanvas.width;
            const height = pyramidCanvas.height;

            pCtx.fillStyle = '#1a1a1a';
            pCtx.fillRect(0, 0, width, height);

            const margin = { top: 30, right: 30, bottom: 30, left: 30 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Count species at each trophic level
            const levels = {};
            species.filter(s => s.alive).forEach(s => {
                const tl = Math.round(s.trophicLevel);
                levels[tl] = (levels[tl] || 0) + 1;
            });

            const maxLevel = Math.max(...Object.keys(levels).map(Number), 1);
            const maxCount = Math.max(...Object.values(levels), 1);

            // Draw pyramid bars
            for (let tl = 1; tl <= maxLevel; tl++) {
                const count = levels[tl] || 0;
                const barWidth = (count / maxCount) * plotWidth * 0.8;
                const barHeight = plotHeight / maxLevel - 10;

                const x = margin.left + (plotWidth - barWidth) / 2;
                const y = margin.top + plotHeight - tl * (barHeight + 10);

                // Color by trophic level
                const colors = ['#27ae60', '#f39c12', '#e67e22', '#e74c3c', '#9b59b6'];
                pCtx.fillStyle = colors[Math.min(tl - 1, colors.length - 1)];
                pCtx.fillRect(x, y, barWidth, barHeight);

                // Label
                pCtx.fillStyle = '#fff';
                pCtx.font = 'bold 12px sans-serif';
                pCtx.textAlign = 'center';
                pCtx.fillText(count, width / 2, y + barHeight / 2 + 4);

                pCtx.fillStyle = '#888';
                pCtx.font = '10px sans-serif';
                pCtx.fillText('Level ' + tl, margin.left - 5 + 20, y + barHeight / 2 + 4);
            }

            pCtx.fillStyle = '#fff';
            pCtx.font = 'bold 12px sans-serif';
            pCtx.textAlign = 'center';
            pCtx.fillText('Trophic Pyramid', width / 2, 18);
        }

        function drawDegree() {
            const width = degreeCanvas.width;
            const height = degreeCanvas.height;

            dCtx.fillStyle = '#1a1a1a';
            dCtx.fillRect(0, 0, width, height);

            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Calculate degree distribution
            const degrees = {};
            species.filter(s => s.alive).forEach(s => {
                const degree = s.preyCount + s.predatorCount;
                degrees[degree] = (degrees[degree] || 0) + 1;
            });

            const maxDegree = Math.max(...Object.keys(degrees).map(Number), 1);
            const maxCount = Math.max(...Object.values(degrees), 1);

            const barWidth = plotWidth / (maxDegree + 1) - 2;

            // Draw bars
            Object.entries(degrees).forEach(([deg, count]) => {
                const x = margin.left + (parseInt(deg) / (maxDegree + 1)) * plotWidth;
                const barHeight = (count / maxCount) * plotHeight;
                const y = margin.top + plotHeight - barHeight;

                dCtx.fillStyle = '#3498db';
                dCtx.fillRect(x, y, barWidth, barHeight);
            });

            // Axes
            dCtx.strokeStyle = '#666';
            dCtx.lineWidth = 1;
            dCtx.beginPath();
            dCtx.moveTo(margin.left, margin.top);
            dCtx.lineTo(margin.left, margin.top + plotHeight);
            dCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            dCtx.stroke();

            // Labels
            dCtx.fillStyle = '#aaa';
            dCtx.font = '10px sans-serif';
            dCtx.textAlign = 'center';
            dCtx.fillText('Degree (links per species)', width / 2, height - 5);

            dCtx.save();
            dCtx.translate(12, height / 2);
            dCtx.rotate(-Math.PI / 2);
            dCtx.fillText('Count', 0, 0);
            dCtx.restore();

            dCtx.fillStyle = '#fff';
            dCtx.font = 'bold 12px sans-serif';
            dCtx.fillText('Degree Distribution', width / 2, 18);
        }

        function drawRobustness() {
            const width = robustnessCanvas.width;
            const height = robustnessCanvas.height;

            rCtx.fillStyle = '#1a1a1a';
            rCtx.fillRect(0, 0, width, height);

            if (robustnessData.length < 2) {
                rCtx.fillStyle = '#666';
                rCtx.font = '12px sans-serif';
                rCtx.textAlign = 'center';
                rCtx.fillText('Click "Run Robustness Analysis"', width / 2, height / 2);
                rCtx.fillText('to generate robustness curve', width / 2, height / 2 + 20);
                return;
            }

            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const maxRemovals = robustnessData[robustnessData.length - 1].removals;

            // Draw curve
            rCtx.strokeStyle = '#e74c3c';
            rCtx.lineWidth = 2;
            rCtx.beginPath();

            robustnessData.forEach((d, i) => {
                const x = margin.left + (d.removals / maxRemovals) * plotWidth;
                const y = margin.top + plotHeight - d.surviving * plotHeight;

                if (i === 0) rCtx.moveTo(x, y);
                else rCtx.lineTo(x, y);
            });

            rCtx.stroke();

            // Find R50 (removals needed to reduce to 50%)
            let r50 = -1;
            for (let i = 0; i < robustnessData.length; i++) {
                if (robustnessData[i].surviving <= 0.5) {
                    r50 = robustnessData[i].removals / maxRemovals;
                    break;
                }
            }

            // Draw R50 line
            if (r50 > 0) {
                const r50x = margin.left + r50 * plotWidth;
                rCtx.strokeStyle = 'rgba(255, 200, 0, 0.7)';
                rCtx.setLineDash([5, 5]);
                rCtx.beginPath();
                rCtx.moveTo(r50x, margin.top);
                rCtx.lineTo(r50x, margin.top + plotHeight);
                rCtx.stroke();
                rCtx.setLineDash([]);

                rCtx.fillStyle = '#FFC107';
                rCtx.font = '10px sans-serif';
                rCtx.textAlign = 'left';
                rCtx.fillText('R50 = ' + r50.toFixed(2), r50x + 5, margin.top + 15);
            }

            // 50% line
            const halfY = margin.top + plotHeight * 0.5;
            rCtx.strokeStyle = 'rgba(100, 200, 100, 0.5)';
            rCtx.setLineDash([5, 5]);
            rCtx.beginPath();
            rCtx.moveTo(margin.left, halfY);
            rCtx.lineTo(margin.left + plotWidth, halfY);
            rCtx.stroke();
            rCtx.setLineDash([]);

            // Axes
            rCtx.strokeStyle = '#666';
            rCtx.lineWidth = 1;
            rCtx.beginPath();
            rCtx.moveTo(margin.left, margin.top);
            rCtx.lineTo(margin.left, margin.top + plotHeight);
            rCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            rCtx.stroke();

            // Labels
            rCtx.fillStyle = '#aaa';
            rCtx.font = '10px sans-serif';
            rCtx.textAlign = 'center';
            rCtx.fillText('Fraction of Species Removed', width / 2, height - 5);

            rCtx.save();
            rCtx.translate(12, height / 2);
            rCtx.rotate(-Math.PI / 2);
            rCtx.fillText('Fraction Surviving', 0, 0);
            rCtx.restore();

            rCtx.fillStyle = '#fff';
            rCtx.font = 'bold 12px sans-serif';
            rCtx.fillText('Robustness Curve', width / 2, 18);

            // Update R50 stat
            document.getElementById('r50').textContent = r50 > 0 ? r50.toFixed(2) : '-';
        }

        function updateStats() {
            const alive = species.filter(s => s.alive);
            const aliveLinks = links.filter(l => l.alive);

            const S = alive.length;
            const L = aliveLinks.length;
            const C = S > 0 ? L / (S * S) : 0;
            const LD = S > 0 ? L / S : 0;

            const meanTL = S > 0 ? alive.reduce((sum, s) => sum + s.trophicLevel, 0) / S : 0;
            const maxTL = S > 0 ? Math.max(...alive.map(s => s.trophicLevel)) : 0;

            document.getElementById('speciesCount').textContent = S;
            document.getElementById('linksCount').textContent = L;
            document.getElementById('actualConnectance').textContent = C.toFixed(3);
            document.getElementById('linkDensity').textContent = LD.toFixed(2);
            document.getElementById('meanTrophic').textContent = meanTL.toFixed(2);
            document.getElementById('maxChainLength').textContent = Math.floor(maxTL);
            document.getElementById('extinctions').textContent = secondaryExtinctions;

            // Trophic level indicators
            const basal = alive.filter(s => s.preyCount === 0);
            const topPred = alive.filter(s => s.predatorCount === 0 && s.preyCount > 0);
            const consumers = alive.filter(s => s.preyCount > 0 && s.predatorCount > 0);

            const total = params.numSpecies;
            document.getElementById('basalFill').style.width = (basal.length / total * 100) + '%';
            document.getElementById('consumerFill').style.width = (consumers.length / total * 100) + '%';
            document.getElementById('topPredFill').style.width = (topPred.length / total * 100) + '%';

            document.getElementById('basalCount').textContent = basal.length;
            document.getElementById('consumerCount').textContent = consumers.length;
            document.getElementById('topPredCount').textContent = topPred.length;
        }

        function draw() {
            drawNetwork();
            drawPyramid();
            drawDegree();
            drawRobustness();
            updateStats();
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', () => {
            updateParams();
            generateWeb();
            robustnessData = [];
            draw();
        });

        document.getElementById('removeSpecies').addEventListener('click', () => {
            removeOneSpecies();
            draw();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            removeOneSpecies();
            draw();
        });

        document.getElementById('runRobustness').addEventListener('click', () => {
            updateParams();
            runRobustnessAnalysis();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            updateParams();
            generateWeb();
            robustnessData = [];
            draw();
        });

        // Parameter sliders
        const sliders = ['numSpecies', 'connectance', 'basalFraction', 'extinctionThreshold'];
        sliders.forEach(id => {
            const slider = document.getElementById(id);
            const display = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                display.textContent = slider.value;
                updateParams();
            });
        });

        document.getElementById('webModel').addEventListener('change', updateParams);
        document.getElementById('removalStrategy').addEventListener('change', updateParams);

        // Initialize
        updateParams();
        generateWeb();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
