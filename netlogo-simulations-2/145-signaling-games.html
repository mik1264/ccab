<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signaling Games - Communication & Deception</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { display: block; width: 100%; border-radius: 8px; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; }
        .control-group .value { color: #8A9A5B; font-size: 0.85rem; }
        button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; margin-right: 8px; margin-bottom: 8px; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-box { background: #FEFAE0; border-radius: 8px; padding: 12px; margin-top: 15px; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #EDE8D5; }
        .stat:last-child { border-bottom: none; }
        .stat-label { color: #606C38; font-size: 0.85rem; }
        .stat-value { color: #BC6C25; font-weight: 600; font-size: 0.9rem; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.85rem; color: #606C38; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .equilibrium-display { padding: 12px; border-radius: 8px; margin-bottom: 15px; text-align: center; }
        .eq-separating { background: #E8F5E9; }
        .eq-pooling { background: #E3F2FD; }
        .eq-semi { background: #FFF3E0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Signaling Games</h1>
            <p class="subtitle">Separating, pooling equilibria and honest signaling evolution</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="equilibrium-display eq-separating" id="eqDisplay">
                    <div style="font-weight: 600;">Current Equilibrium Type</div>
                    <div id="eqType">Detecting...</div>
                </div>

                <div class="control-group">
                    <label>Signaling Cost: <span class="value" id="valueCost">0.20</span></label>
                    <input type="range" id="signalCost" min="0" max="100" value="20">
                </div>

                <div class="control-group">
                    <label>High Type Frequency: <span class="value" id="valueHigh">0.50</span></label>
                    <input type="range" id="highFreq" min="10" max="90" value="50">
                </div>

                <div class="control-group">
                    <label>Benefit to Receiver: <span class="value" id="valueBenefit">1.00</span></label>
                    <input type="range" id="benefit" min="50" max="200" value="100">
                </div>

                <div class="control-group">
                    <label>Population: <span class="value" id="valuePop">100</span></label>
                    <input type="range" id="population" min="20" max="200" value="100">
                </div>

                <div class="control-group">
                    <label>Mutation Rate: <span class="value" id="valueMut">0.02</span></label>
                    <input type="range" id="mutation" min="0" max="100" value="20">
                </div>

                <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                <button class="btn-secondary" onclick="togglePause()">Pause</button>

                <div class="stats-box">
                    <div class="stat"><span class="stat-label">Generation:</span><span class="stat-value" id="genStat">0</span></div>
                    <div class="stat"><span class="stat-label">High Signal Rate:</span><span class="stat-value" id="highSigStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Low Signal Rate:</span><span class="stat-value" id="lowSigStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Receiver Trust:</span><span class="stat-value" id="trustStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Honest Signals:</span><span class="stat-value" id="honestStat">0%</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <strong>About this simulation:</strong> In signaling games, a <strong>sender</strong> with private information
            sends a signal to a <strong>receiver</strong> who then takes an action.
            In <strong>separating equilibrium</strong>, different types send different signals (honest communication).
            In <strong>pooling equilibrium</strong>, all types send the same signal (no information transfer).
            <strong>Costly signaling</strong> (handicap principle) can maintain honesty when interests diverge.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = 600 * dpr;
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = 600;

        let signalCost = 0.2;
        let highFreq = 0.5;
        let benefit = 1.0;
        let popSize = 100;
        let mutationRate = 0.02;

        let senders = [];
        let receivers = [];
        let history = { highSig: [], lowSig: [], trust: [] };
        let generation = 0;
        let paused = false;

        // Types: HIGH or LOW quality
        // Signals: SIGNAL or NO_SIGNAL
        // Actions: TRUST or DISTRUST

        function initSimulation() {
            senders = [];
            receivers = [];
            history = { highSig: [], lowSig: [], trust: [] };
            generation = 0;

            for (let i = 0; i < popSize; i++) {
                senders.push({
                    isHigh: Math.random() < highFreq,
                    // Strategy: probability of signaling for each type
                    signalIfHigh: Math.random(),
                    signalIfLow: Math.random(),
                    fitness: 0,
                    x: Math.random() * (width/2 - 80) + 40,
                    y: Math.random() * 200 + 50
                });

                receivers.push({
                    // Strategy: probability of trusting given signal/no signal
                    trustIfSignal: Math.random(),
                    trustIfNoSignal: Math.random(),
                    fitness: 0,
                    x: Math.random() * (width/2 - 80) + width/2 + 40,
                    y: Math.random() * 200 + 50
                });
            }
        }

        function playGame(sender, receiver) {
            // Sender decides whether to signal based on type
            const signalProb = sender.isHigh ? sender.signalIfHigh : sender.signalIfLow;
            const signals = Math.random() < signalProb;

            // Signaling is costly
            const signalCostPaid = signals ? signalCost : 0;

            // Receiver decides based on signal
            const trustProb = signals ? receiver.trustIfSignal : receiver.trustIfNoSignal;
            const trusts = Math.random() < trustProb;

            // Payoffs
            let senderPayoff = -signalCostPaid;
            let receiverPayoff = 0;

            if (trusts) {
                if (sender.isHigh) {
                    // Good match - both benefit
                    senderPayoff += 1;
                    receiverPayoff += benefit;
                } else {
                    // Bad match - sender benefits, receiver loses
                    senderPayoff += 1;
                    receiverPayoff -= benefit;
                }
            }
            // If doesn't trust, both get 0

            sender.fitness += senderPayoff;
            receiver.fitness += receiverPayoff;

            return { signals, trusts, isHigh: sender.isHigh };
        }

        function runGeneration() {
            // Reset fitness
            senders.forEach(s => s.fitness = 0);
            receivers.forEach(r => r.fitness = 0);

            // Random matchings
            const shuffledSenders = [...senders].sort(() => Math.random() - 0.5);
            const shuffledReceivers = [...receivers].sort(() => Math.random() - 0.5);

            let interactions = [];

            for (let i = 0; i < popSize; i++) {
                const result = playGame(shuffledSenders[i], shuffledReceivers[i]);
                interactions.push(result);
            }

            // Record statistics
            const highSenders = senders.filter(s => s.isHigh);
            const lowSenders = senders.filter(s => !s.isHigh);

            const highSigRate = highSenders.length > 0 ?
                highSenders.reduce((s, a) => s + a.signalIfHigh, 0) / highSenders.length : 0;
            const lowSigRate = lowSenders.length > 0 ?
                lowSenders.reduce((s, a) => s + a.signalIfLow, 0) / lowSenders.length : 0;
            const trustRate = receivers.reduce((s, r) => s + r.trustIfSignal, 0) / popSize;

            history.highSig.push(highSigRate);
            history.lowSig.push(lowSigRate);
            history.trust.push(trustRate);

            if (history.highSig.length > 500) {
                history.highSig.shift();
                history.lowSig.shift();
                history.trust.shift();
            }

            // Evolution
            evolve();
            generation++;
        }

        function evolve() {
            // Evolve senders
            const minSenderFitness = Math.min(...senders.map(s => s.fitness));
            senders.forEach(s => s.fitness -= minSenderFitness - 1);
            const totalSenderFitness = senders.reduce((sum, s) => sum + s.fitness, 0);

            const newSenders = [];
            for (let i = 0; i < popSize; i++) {
                let r = Math.random() * totalSenderFitness;
                let parent = senders[0];
                for (const s of senders) {
                    r -= s.fitness;
                    if (r <= 0) { parent = s; break; }
                }

                let signalIfHigh = parent.signalIfHigh;
                let signalIfLow = parent.signalIfLow;

                // Mutation
                if (Math.random() < mutationRate) {
                    signalIfHigh += (Math.random() - 0.5) * 0.2;
                    signalIfHigh = Math.max(0, Math.min(1, signalIfHigh));
                }
                if (Math.random() < mutationRate) {
                    signalIfLow += (Math.random() - 0.5) * 0.2;
                    signalIfLow = Math.max(0, Math.min(1, signalIfLow));
                }

                newSenders.push({
                    isHigh: Math.random() < highFreq,
                    signalIfHigh,
                    signalIfLow,
                    fitness: 0,
                    x: Math.random() * (width/2 - 80) + 40,
                    y: Math.random() * 200 + 50
                });
            }
            senders = newSenders;

            // Evolve receivers
            const minReceiverFitness = Math.min(...receivers.map(r => r.fitness));
            receivers.forEach(r => r.fitness -= minReceiverFitness - 1);
            const totalReceiverFitness = receivers.reduce((sum, r) => sum + r.fitness, 0);

            const newReceivers = [];
            for (let i = 0; i < popSize; i++) {
                let r = Math.random() * totalReceiverFitness;
                let parent = receivers[0];
                for (const recv of receivers) {
                    r -= recv.fitness;
                    if (r <= 0) { parent = recv; break; }
                }

                let trustIfSignal = parent.trustIfSignal;
                let trustIfNoSignal = parent.trustIfNoSignal;

                if (Math.random() < mutationRate) {
                    trustIfSignal += (Math.random() - 0.5) * 0.2;
                    trustIfSignal = Math.max(0, Math.min(1, trustIfSignal));
                }
                if (Math.random() < mutationRate) {
                    trustIfNoSignal += (Math.random() - 0.5) * 0.2;
                    trustIfNoSignal = Math.max(0, Math.min(1, trustIfNoSignal));
                }

                newReceivers.push({
                    trustIfSignal,
                    trustIfNoSignal,
                    fitness: 0,
                    x: Math.random() * (width/2 - 80) + width/2 + 40,
                    y: Math.random() * 200 + 50
                });
            }
            receivers = newReceivers;
        }

        function detectEquilibrium() {
            const highSig = history.highSig.slice(-50).reduce((a, b) => a + b, 0) / 50;
            const lowSig = history.lowSig.slice(-50).reduce((a, b) => a + b, 0) / 50;

            if (highSig > 0.7 && lowSig < 0.3) {
                return 'separating';
            } else if (Math.abs(highSig - lowSig) < 0.2) {
                return 'pooling';
            } else {
                return 'semi-separating';
            }
        }

        function draw() {
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            // Draw divider
            ctx.strokeStyle = '#DDA15E';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2, 20);
            ctx.lineTo(width/2, 280);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#606C38';
            ctx.font = 'bold 14px Nunito';
            ctx.fillText('Senders (with private type)', 40, 35);
            ctx.fillText('Receivers', width/2 + 40, 35);

            // Draw senders
            senders.forEach(s => {
                const sigProb = s.isHigh ? s.signalIfHigh : s.signalIfLow;
                const hue = s.isHigh ? 120 : 0; // Green for high, red for low
                const saturation = sigProb * 100; // Brighter = more likely to signal

                ctx.beginPath();
                ctx.arc(s.x, s.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${hue}, ${saturation}%, 50%, 0.7)`;
                ctx.fill();

                // Signal indicator
                if (sigProb > 0.5) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Draw receivers
            receivers.forEach(r => {
                const trustLevel = (r.trustIfSignal + r.trustIfNoSignal) / 2;
                ctx.beginPath();
                ctx.arc(r.x, r.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(220, ${trustLevel * 100}%, 50%, 0.7)`;
                ctx.fill();
            });

            // Strategy space visualization
            const stratY = 300;
            const stratHeight = 130;

            // Sender strategy space
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(40, stratY, width/2 - 60, stratHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(40, stratY, width/2 - 60, stratHeight);

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Sender Strategies: P(signal|type)', 50, stratY + 15);
            ctx.fillText('High type →', 50, stratY + 40);
            ctx.fillText('Low type →', 50, stratY + 80);

            // Draw strategy distributions
            const highSenders = senders.filter(s => s.isHigh);
            const lowSenders = senders.filter(s => !s.isHigh);

            const histWidth = (width/2 - 100) / 2;

            // High type histogram
            const highBins = new Array(10).fill(0);
            highSenders.forEach(s => {
                const bin = Math.min(9, Math.floor(s.signalIfHigh * 10));
                highBins[bin]++;
            });

            const maxHighBin = Math.max(...highBins, 1);
            highBins.forEach((count, i) => {
                const h = (count / maxHighBin) * 30;
                ctx.fillStyle = '#2A9D8F';
                ctx.fillRect(120 + i * 15, stratY + 55 - h, 12, h);
            });

            // Low type histogram
            const lowBins = new Array(10).fill(0);
            lowSenders.forEach(s => {
                const bin = Math.min(9, Math.floor(s.signalIfLow * 10));
                lowBins[bin]++;
            });

            const maxLowBin = Math.max(...lowBins, 1);
            lowBins.forEach((count, i) => {
                const h = (count / maxLowBin) * 30;
                ctx.fillStyle = '#E63946';
                ctx.fillRect(120 + i * 15, stratY + 95 - h, 12, h);
            });

            // Receiver strategy space
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(width/2 + 20, stratY, width/2 - 60, stratHeight);
            ctx.strokeRect(width/2 + 20, stratY, width/2 - 60, stratHeight);

            ctx.fillStyle = '#606C38';
            ctx.fillText('Receiver Strategies: P(trust|signal)', width/2 + 30, stratY + 15);
            ctx.fillText('If signal →', width/2 + 30, stratY + 40);
            ctx.fillText('If no signal →', width/2 + 30, stratY + 80);

            // Receiver histograms
            const trustSigBins = new Array(10).fill(0);
            const trustNoSigBins = new Array(10).fill(0);

            receivers.forEach(r => {
                const bin1 = Math.min(9, Math.floor(r.trustIfSignal * 10));
                const bin2 = Math.min(9, Math.floor(r.trustIfNoSignal * 10));
                trustSigBins[bin1]++;
                trustNoSigBins[bin2]++;
            });

            const maxTrustBin = Math.max(...trustSigBins, ...trustNoSigBins, 1);

            trustSigBins.forEach((count, i) => {
                const h = (count / maxTrustBin) * 30;
                ctx.fillStyle = '#457B9D';
                ctx.fillRect(width/2 + 100 + i * 15, stratY + 55 - h, 12, h);
            });

            trustNoSigBins.forEach((count, i) => {
                const h = (count / maxTrustBin) * 30;
                ctx.fillStyle = '#E9C46A';
                ctx.fillRect(width/2 + 100 + i * 15, stratY + 95 - h, 12, h);
            });

            // History chart
            const chartY = 450;
            const chartHeight = 130;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, chartY, width - 40, chartHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, chartY, width - 40, chartHeight);

            if (history.highSig.length > 1) {
                const maxPoints = 200;
                const startIdx = Math.max(0, history.highSig.length - maxPoints);
                const step = (width - 60) / Math.max(1, Math.min(history.highSig.length, maxPoints) - 1);

                // High type signaling rate
                ctx.beginPath();
                for (let i = startIdx; i < history.highSig.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.highSig[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#2A9D8F';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Low type signaling rate
                ctx.beginPath();
                for (let i = startIdx; i < history.lowSig.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.lowSig[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#E63946';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Trust rate
                ctx.beginPath();
                for (let i = startIdx; i < history.trust.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.trust[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#457B9D';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Green: High types signal, Red: Low types signal, Blue dashed: Trust rate', 30, chartY + 15);
        }

        function updateStats() {
            const highSig = history.highSig.length > 0 ? history.highSig[history.highSig.length - 1] : 0;
            const lowSig = history.lowSig.length > 0 ? history.lowSig[history.lowSig.length - 1] : 0;
            const trust = history.trust.length > 0 ? history.trust[history.trust.length - 1] : 0;

            document.getElementById('genStat').textContent = generation;
            document.getElementById('highSigStat').textContent = (highSig * 100).toFixed(1) + '%';
            document.getElementById('lowSigStat').textContent = (lowSig * 100).toFixed(1) + '%';
            document.getElementById('trustStat').textContent = (trust * 100).toFixed(1) + '%';

            // Honesty: high types signal more than low types
            const honesty = Math.max(0, highSig - lowSig);
            document.getElementById('honestStat').textContent = (honesty * 100).toFixed(1) + '%';

            // Update equilibrium display
            const eq = detectEquilibrium();
            const eqDisplay = document.getElementById('eqDisplay');
            const eqType = document.getElementById('eqType');

            eqDisplay.className = 'equilibrium-display';
            if (eq === 'separating') {
                eqDisplay.classList.add('eq-separating');
                eqType.textContent = 'SEPARATING (Honest signals)';
            } else if (eq === 'pooling') {
                eqDisplay.classList.add('eq-pooling');
                eqType.textContent = 'POOLING (No information)';
            } else {
                eqDisplay.classList.add('eq-semi');
                eqType.textContent = 'SEMI-SEPARATING (Partial honesty)';
            }
        }

        function updateControls() {
            signalCost = parseInt(document.getElementById('signalCost').value) / 100;
            highFreq = parseInt(document.getElementById('highFreq').value) / 100;
            benefit = parseInt(document.getElementById('benefit').value) / 100;
            popSize = parseInt(document.getElementById('population').value);
            mutationRate = parseInt(document.getElementById('mutation').value) / 1000;

            document.getElementById('valueCost').textContent = signalCost.toFixed(2);
            document.getElementById('valueHigh').textContent = highFreq.toFixed(2);
            document.getElementById('valueBenefit').textContent = benefit.toFixed(2);
            document.getElementById('valuePop').textContent = popSize;
            document.getElementById('valueMut').textContent = mutationRate.toFixed(3);
        }

        function resetSimulation() {
            updateControls();
            initSimulation();
        }

        function togglePause() {
            paused = !paused;
        }

        let frameCount = 0;
        function animate() {
            if (!paused) {
                frameCount++;
                if (frameCount % 5 === 0) {
                    runGeneration();
                    updateStats();
                }
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', updateControls);
        });

        updateControls();
        initSimulation();
        animate();
    </script>
</body>
</html>
