<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micelle Formation - Amphiphilic Self-Assembly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a1825 0%, #152535 50%, #0a2030 100%);
            min-height: 100vh;
            color: #e0f0ff;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2rem;
            color: #44ddff;
            text-shadow: 0 0 20px rgba(68, 221, 255, 0.5);
            margin-bottom: 5px;
        }

        .subtitle {
            color: #88ccff;
            font-size: 0.95rem;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #44ddff;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 1;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .simulation-area {
            background: rgba(10, 20, 40, 0.8);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(68, 221, 255, 0.3);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background: linear-gradient(180deg, #0a1520 0%, #051015 100%);
        }

        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: rgba(20, 35, 55, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(68, 221, 255, 0.3);
        }

        .control-group h3 {
            color: #44ddff;
            font-size: 0.85rem;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            margin-bottom: 10px;
        }

        .control-row label {
            display: block;
            font-size: 0.8rem;
            color: #88ccff;
            margin-bottom: 4px;
        }

        .control-row input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(68, 221, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #44ddff;
            cursor: pointer;
        }

        .control-row select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            background: rgba(10, 25, 45, 0.9);
            border: 1px solid rgba(68, 221, 255, 0.3);
            color: #e0f0ff;
            font-size: 0.85rem;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 70px;
            padding: 10px 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #44ddff, #2288cc);
            color: #000;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff88aa, #cc4466);
            color: #fff;
        }

        .btn-tertiary {
            background: linear-gradient(135deg, #88ff88, #44aa44);
            color: #000;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(68, 221, 255, 0.4);
        }

        .cmc-indicator {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            transition: all 0.5s;
        }

        .cmc-below {
            background: rgba(100, 100, 50, 0.4);
            color: #ffff88;
            border: 1px solid #aaaa44;
        }

        .cmc-at {
            background: rgba(50, 100, 100, 0.4);
            color: #88ffff;
            border: 1px solid #44aaaa;
            animation: pulse 1s infinite;
        }

        .cmc-above {
            background: rgba(50, 100, 50, 0.4);
            color: #88ff88;
            border: 1px solid #44aa44;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            background: rgba(10, 25, 45, 0.6);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1rem;
            font-weight: bold;
            color: #44ddff;
        }

        .stat-label {
            font-size: 0.65rem;
            color: #888;
            text-transform: uppercase;
        }

        .info-box {
            background: rgba(20, 50, 70, 0.6);
            border-radius: 10px;
            padding: 12px;
            font-size: 0.8rem;
            line-height: 1.5;
            border-left: 3px solid #44ddff;
        }

        .info-box h4 {
            color: #44ddff;
            margin-bottom: 8px;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        .head {
            background: #44ddff;
        }

        .tail {
            background: #ff8844;
        }

        .water {
            background: rgba(100, 150, 255, 0.3);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Simulations</a>

    <div class="container">
        <header>
            <h1>üß™ Micelle Formation</h1>
            <p class="subtitle">Amphiphilic Self-Assembly & Critical Micelle Concentration</p>
        </header>

        <div class="main-content">
            <div class="simulation-area">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot head"></div>
                        <span>Hydrophilic Head</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot tail"></div>
                        <span>Hydrophobic Tail</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot water"></div>
                        <span>Water</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <div class="cmc-indicator cmc-below" id="cmcIndicator">
                        BELOW CMC
                    </div>
                    <div class="buttons">
                        <button class="btn-primary" id="startBtn">‚ñ∂ Start</button>
                        <button class="btn-secondary" id="resetBtn">‚Ü∫ Reset</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Concentration</h3>
                    <div class="control-row">
                        <label>Surfactant Count: <span id="countVal">100</span></label>
                        <input type="range" id="surfactantCount" min="20" max="400" value="100" step="10">
                    </div>
                    <div class="control-row">
                        <label>CMC Threshold: <span id="cmcVal">80</span></label>
                        <input type="range" id="cmcThreshold" min="30" max="200" value="80" step="10">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Surfactant Properties</h3>
                    <div class="control-row">
                        <label>Type</label>
                        <select id="surfactantType">
                            <option value="short">Short Tail (SDS-like)</option>
                            <option value="medium">Medium Tail (CTAB-like)</option>
                            <option value="long">Long Tail (Lipid-like)</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Tail Length: <span id="tailVal">3</span></label>
                        <input type="range" id="tailLength" min="1" max="6" value="3">
                    </div>
                    <div class="control-row">
                        <label>Head-Water Attraction: <span id="headAttrVal">1.0</span></label>
                        <input type="range" id="headAttraction" min="0.5" max="2" value="1.0" step="0.1">
                    </div>
                    <div class="control-row">
                        <label>Tail-Tail Attraction: <span id="tailAttrVal">1.0</span></label>
                        <input type="range" id="tailAttraction" min="0.5" max="2" value="1.0" step="0.1">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="freeSurfactants">0</div>
                            <div class="stat-label">Free</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="numMicelles">0</div>
                            <div class="stat-label">Micelles</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avgSize">0</div>
                            <div class="stat-label">Avg Size</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="maxSize">0</div>
                            <div class="stat-label">Max Size</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="aggregation">0%</div>
                            <div class="stat-label">Aggregated</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="temperature">300</div>
                            <div class="stat-label">Temp (K)</div>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Temperature</h3>
                    <div class="control-row">
                        <label>T: <span id="tempVal">300</span> K</label>
                        <input type="range" id="temperature" min="280" max="350" value="300">
                    </div>
                </div>

                <div class="control-group info-box">
                    <h4>Critical Micelle Concentration</h4>
                    <p>
                        Above the <b>CMC</b>, surfactant molecules spontaneously
                        self-assemble into micelles. The hydrophilic heads
                        face outward (toward water) while hydrophobic tails
                        cluster in the core.
                    </p>
                    <ul style="margin-top: 8px; padding-left: 15px;">
                        <li><b>Spherical:</b> Low packing parameter</li>
                        <li><b>Cylindrical:</b> Intermediate</li>
                        <li><b>Bilayer:</b> High packing parameter</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth - 30;
            const height = Math.min(width * 0.7, window.innerHeight - 280);
            canvas.width = width;
            canvas.height = height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // State
        let running = false;
        let time = 0;

        // Parameters
        let surfactantCount = 100;
        let cmcThreshold = 80;
        let tailLength = 3;
        let headAttraction = 1.0;
        let tailAttraction = 1.0;
        let temperature = 300;

        // Surfactant molecules
        let surfactants = [];

        // Surfactant class
        class Surfactant {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.angle = Math.random() * Math.PI * 2;
                this.angularVel = (Math.random() - 0.5) * 0.1;
                this.tailLen = tailLength;
                this.micelleId = -1;  // -1 = free
            }

            get headX() {
                return this.x + Math.cos(this.angle) * (this.tailLen * 3 + 4);
            }

            get headY() {
                return this.y + Math.sin(this.angle) * (this.tailLen * 3 + 4);
            }

            update(width, height) {
                // Brownian motion based on temperature
                const thermalNoise = (temperature - 273) / 100;
                this.vx += (Math.random() - 0.5) * thermalNoise;
                this.vy += (Math.random() - 0.5) * thermalNoise;
                this.angularVel += (Math.random() - 0.5) * 0.02 * thermalNoise;

                // Damping
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.angularVel *= 0.95;

                // Update position
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.angularVel;

                // Boundary reflection
                const margin = 20;
                if (this.x < margin) { this.x = margin; this.vx *= -0.5; }
                if (this.x > width - margin) { this.x = width - margin; this.vx *= -0.5; }
                if (this.y < margin) { this.y = margin; this.vy *= -0.5; }
                if (this.y > height - margin) { this.y = height - margin; this.vy *= -0.5; }
            }

            draw(ctx) {
                const tailEndX = this.x;
                const tailEndY = this.y;
                const headX = this.headX;
                const headY = this.headY;

                // Draw tail segments
                ctx.strokeStyle = '#ff8844';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                for (let i = 0; i < this.tailLen; i++) {
                    const t1 = i / this.tailLen;
                    const t2 = (i + 1) / this.tailLen;
                    const x1 = tailEndX + (headX - tailEndX) * t1 * 0.7;
                    const y1 = tailEndY + (headY - tailEndY) * t1 * 0.7;
                    const x2 = tailEndX + (headX - tailEndX) * t2 * 0.7;
                    const y2 = tailEndY + (headY - tailEndY) * t2 * 0.7;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Draw head
                ctx.beginPath();
                ctx.arc(headX, headY, 5, 0, Math.PI * 2);
                ctx.fillStyle = this.micelleId >= 0 ? '#00ffff' : '#44ddff';
                ctx.shadowColor = '#44ddff';
                ctx.shadowBlur = this.micelleId >= 0 ? 8 : 3;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Initialize simulation
        function initialize() {
            time = 0;
            surfactants = [];

            const width = canvas.width;
            const height = canvas.height;

            for (let i = 0; i < surfactantCount; i++) {
                surfactants.push(new Surfactant(
                    50 + Math.random() * (width - 100),
                    50 + Math.random() * (height - 100)
                ));
            }
        }

        // Calculate forces between surfactants
        function calculateForces() {
            const n = surfactants.length;

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const si = surfactants[i];
                    const sj = surfactants[j];

                    // Tail-tail interaction (hydrophobic attraction)
                    const dxTail = sj.x - si.x;
                    const dyTail = sj.y - si.y;
                    const distTail = Math.sqrt(dxTail * dxTail + dyTail * dyTail);

                    if (distTail < 40 && distTail > 0) {
                        // Attractive force between tails
                        const forceTail = tailAttraction * 0.3 * (1 - distTail / 40);
                        si.vx += dxTail / distTail * forceTail;
                        si.vy += dyTail / distTail * forceTail;
                        sj.vx -= dxTail / distTail * forceTail;
                        sj.vy -= dyTail / distTail * forceTail;

                        // Align tails (orient together)
                        const angleDiff = sj.angle - si.angle;
                        si.angularVel += Math.sin(angleDiff) * 0.01;
                        sj.angularVel -= Math.sin(angleDiff) * 0.01;
                    }

                    // Head-head repulsion (steric + electrostatic)
                    const dxHead = sj.headX - si.headX;
                    const dyHead = sj.headY - si.headY;
                    const distHead = Math.sqrt(dxHead * dxHead + dyHead * dyHead);

                    if (distHead < 20 && distHead > 0) {
                        const forceHead = 0.5 * (1 - distHead / 20);
                        si.vx -= dxHead / distHead * forceHead;
                        si.vy -= dyHead / distHead * forceHead;
                        sj.vx += dxHead / distHead * forceHead;
                        sj.vy += dyHead / distHead * forceHead;
                    }

                    // LJ-like repulsion at very close range
                    if (distTail < 10 && distTail > 0) {
                        const repulsion = 2 * (10 - distTail) / 10;
                        si.vx -= dxTail / distTail * repulsion;
                        si.vy -= dyTail / distTail * repulsion;
                        sj.vx += dxTail / distTail * repulsion;
                        sj.vy += dyTail / distTail * repulsion;
                    }
                }

                // Head-water attraction (keep heads at surface)
                // This simulates the preference for heads to be in water
                const si = surfactants[i];
                // Add slight attraction to edges (water interface)
                const centerDist = Math.sqrt(
                    Math.pow(si.headX - canvas.width/2, 2) +
                    Math.pow(si.headY - canvas.height/2, 2)
                );
                // Slight tendency for heads to face outward in aggregates
            }
        }

        // Detect micelles using clustering
        function detectMicelles() {
            const n = surfactants.length;
            const threshold = 30;

            // Reset micelle IDs
            surfactants.forEach(s => s.micelleId = -1);

            let micelleCount = 0;
            const visited = new Set();

            for (let i = 0; i < n; i++) {
                if (visited.has(i)) continue;

                // BFS to find cluster
                const cluster = [];
                const queue = [i];

                while (queue.length > 0) {
                    const current = queue.shift();
                    if (visited.has(current)) continue;

                    visited.add(current);
                    cluster.push(current);

                    // Find neighbors
                    for (let j = 0; j < n; j++) {
                        if (visited.has(j)) continue;

                        const dx = surfactants[j].x - surfactants[current].x;
                        const dy = surfactants[j].y - surfactants[current].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < threshold) {
                            queue.push(j);
                        }
                    }
                }

                // Mark as micelle if cluster is large enough
                if (cluster.length >= 3) {
                    cluster.forEach(idx => {
                        surfactants[idx].micelleId = micelleCount;
                    });
                    micelleCount++;
                }
            }

            return micelleCount;
        }

        // Update statistics
        function updateStats() {
            const numMicelles = detectMicelles();
            const aggregated = surfactants.filter(s => s.micelleId >= 0);
            const free = surfactants.length - aggregated.length;

            // Calculate micelle sizes
            const micelleSizes = {};
            surfactants.forEach(s => {
                if (s.micelleId >= 0) {
                    micelleSizes[s.micelleId] = (micelleSizes[s.micelleId] || 0) + 1;
                }
            });

            const sizes = Object.values(micelleSizes);
            const avgSize = sizes.length > 0 ?
                sizes.reduce((a, b) => a + b, 0) / sizes.length : 0;
            const maxSize = sizes.length > 0 ? Math.max(...sizes) : 0;

            document.getElementById('freeSurfactants').textContent = free;
            document.getElementById('numMicelles').textContent = numMicelles;
            document.getElementById('avgSize').textContent = avgSize.toFixed(1);
            document.getElementById('maxSize').textContent = maxSize;
            document.getElementById('aggregation').textContent =
                Math.round(aggregated.length / surfactants.length * 100) + '%';
            document.getElementById('temperature').textContent = temperature;

            // Update CMC indicator
            const indicator = document.getElementById('cmcIndicator');
            if (surfactantCount < cmcThreshold * 0.8) {
                indicator.className = 'cmc-indicator cmc-below';
                indicator.textContent = 'BELOW CMC';
            } else if (surfactantCount < cmcThreshold * 1.2) {
                indicator.className = 'cmc-indicator cmc-at';
                indicator.textContent = 'AT CMC';
            } else {
                indicator.className = 'cmc-indicator cmc-above';
                indicator.textContent = 'ABOVE CMC - MICELLES FORMING';
            }
        }

        // Render
        function render() {
            const width = canvas.width;
            const height = canvas.height;

            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#0a1520');
            gradient.addColorStop(1, '#051015');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Draw water molecule hints
            ctx.fillStyle = 'rgba(100, 150, 255, 0.05)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 47 + time * 0.5) % width;
                const y = (i * 31 + time * 0.3) % height;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw surfactants
            surfactants.forEach(s => s.draw(ctx));

            // Draw micelle outlines
            const micellePositions = {};
            surfactants.forEach(s => {
                if (s.micelleId >= 0) {
                    if (!micellePositions[s.micelleId]) {
                        micellePositions[s.micelleId] = { x: 0, y: 0, count: 0 };
                    }
                    micellePositions[s.micelleId].x += s.x;
                    micellePositions[s.micelleId].y += s.y;
                    micellePositions[s.micelleId].count++;
                }
            });

            Object.values(micellePositions).forEach(m => {
                if (m.count >= 3) {
                    const cx = m.x / m.count;
                    const cy = m.y / m.count;
                    const radius = 10 + m.count * 2;

                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(68, 221, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Info text
            ctx.fillStyle = '#666666';
            ctx.font = '11px sans-serif';
            ctx.fillText(`Time: ${time}  Surfactants: ${surfactants.length}`, 10, 15);
        }

        // Animation loop
        function animate() {
            if (running) {
                time++;

                calculateForces();

                surfactants.forEach(s => {
                    s.tailLen = tailLength;
                    s.update(canvas.width, canvas.height);
                });

                updateStats();
            }

            render();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? '‚è∏ Pause' : '‚ñ∂ Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = '‚ñ∂ Start';
            initialize();
        });

        // Parameter controls
        document.getElementById('surfactantCount').addEventListener('input', (e) => {
            const newCount = parseInt(e.target.value);
            document.getElementById('countVal').textContent = newCount;

            // Add or remove surfactants
            while (surfactants.length < newCount) {
                surfactants.push(new Surfactant(
                    50 + Math.random() * (canvas.width - 100),
                    50 + Math.random() * (canvas.height - 100)
                ));
            }
            while (surfactants.length > newCount) {
                surfactants.pop();
            }
            surfactantCount = newCount;
        });

        document.getElementById('cmcThreshold').addEventListener('input', (e) => {
            cmcThreshold = parseInt(e.target.value);
            document.getElementById('cmcVal').textContent = cmcThreshold;
        });

        document.getElementById('tailLength').addEventListener('input', (e) => {
            tailLength = parseInt(e.target.value);
            document.getElementById('tailVal').textContent = tailLength;
        });

        document.getElementById('headAttraction').addEventListener('input', (e) => {
            headAttraction = parseFloat(e.target.value);
            document.getElementById('headAttrVal').textContent = headAttraction.toFixed(1);
        });

        document.getElementById('tailAttraction').addEventListener('input', (e) => {
            tailAttraction = parseFloat(e.target.value);
            document.getElementById('tailAttrVal').textContent = tailAttraction.toFixed(1);
        });

        document.getElementById('temperature').addEventListener('input', (e) => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
        });

        document.getElementById('surfactantType').addEventListener('change', (e) => {
            switch (e.target.value) {
                case 'short':
                    tailLength = 2;
                    tailAttraction = 0.8;
                    break;
                case 'medium':
                    tailLength = 3;
                    tailAttraction = 1.0;
                    break;
                case 'long':
                    tailLength = 5;
                    tailAttraction = 1.5;
                    break;
            }
            document.getElementById('tailLength').value = tailLength;
            document.getElementById('tailVal').textContent = tailLength;
            document.getElementById('tailAttraction').value = tailAttraction;
            document.getElementById('tailAttrVal').textContent = tailAttraction.toFixed(1);
        });

        // Initialize and start
        initialize();
        animate();
    </script>
</body>
</html>
