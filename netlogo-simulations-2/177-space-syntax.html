<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architectural Space Syntax - Visibility Graph Analysis - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        #controls { width: 340px; background: rgba(0,0,0,0.85); padding: 20px; overflow-y: auto; }
        h1 { font-family: 'Lora', serif; font-size: 1.3rem; margin-bottom: 15px; color: #06b6d4; }
        .section-title { font-size: 0.9rem; color: #06b6d4; margin: 15px 0 10px; border-bottom: 1px solid rgba(6,182,212,0.3); padding-bottom: 5px; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 4px; color: #aaa; }
        input[type="range"] { width: 100%; accent-color: #06b6d4; }
        select { width: 100%; padding: 8px; background: #2d2d44; color: #fff; border: 1px solid #444; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(6,182,212,0.3); }
        .btn-secondary { background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); }
        .stats { background: rgba(255,255,255,0.08); padding: 12px; border-radius: 8px; font-size: 0.85rem; margin-top: 15px; }
        .stats div { margin: 5px 0; display: flex; justify-content: space-between; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #06b6d4; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info-panel { background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%); padding: 15px; border-radius: 10px; margin-top: 15px; border: 1px solid rgba(6,182,212,0.2); }
        .info-panel h3 { font-family: 'Lora', serif; color: #06b6d4; margin-bottom: 10px; font-size: 1rem; }
        .info-panel p { font-size: 0.8rem; line-height: 1.5; color: #ccc; }
        .legend { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.75rem; }
        .legend-color { width: 15px; height: 15px; border-radius: 3px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Space Syntax Analysis</h1>

            <div class="section-title">Floor Plan</div>
            <div class="control-group">
                <label>Layout Preset:</label>
                <select id="layoutPreset">
                    <option value="office">Open Office</option>
                    <option value="gallery">Art Gallery</option>
                    <option value="apartment">Apartment</option>
                    <option value="museum">Museum</option>
                    <option value="custom">Custom (Click to Draw)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Grid Resolution: <span id="gridValue">20</span></label>
                <input type="range" id="gridRes" min="10" max="40" step="5" value="20">
            </div>

            <div class="section-title">Visualization</div>
            <div class="control-group">
                <label>Display Mode:</label>
                <select id="displayMode">
                    <option value="integration">Integration (Accessibility)</option>
                    <option value="connectivity">Connectivity (Visibility)</option>
                    <option value="depth">Mean Depth</option>
                    <option value="isovist">Isovist Area</option>
                </select>
            </div>

            <button id="analyze">Analyze Space</button>
            <button id="reset" class="btn-secondary">Reset Layout</button>

            <div class="stats">
                <div><span>Grid Cells:</span><span id="cellCount">0</span></div>
                <div><span>Avg Connectivity:</span><span id="avgConnectivity">0</span></div>
                <div><span>Max Integration:</span><span id="maxIntegration">0</span></div>
                <div><span>Movement Prediction:</span><span id="movement">-</span></div>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div>High</div>
                <div class="legend-item"><div class="legend-color" style="background: #eab308;"></div>Medium</div>
                <div class="legend-item"><div class="legend-color" style="background: #ef4444;"></div>Low</div>
                <div class="legend-item"><div class="legend-color" style="background: #333;"></div>Wall</div>
            </div>

            <div class="info-panel">
                <h3>Space Syntax Theory</h3>
                <p><strong>Integration:</strong> How accessible a space is from all other spaces.<br>
                   <strong>Connectivity:</strong> How many spaces are directly visible.<br>
                   <strong>Depth:</strong> Average topological steps to reach all spaces.<br>
                   High integration areas predict higher pedestrian movement.</p>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        let params = { gridRes: 20, displayMode: 'integration', layout: 'office' };
        let grid = [];
        let walls = [];
        let visibilityGraph = [];
        let analysisResults = [];
        let isDrawing = false;
        let drawStart = null;

        function resize() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // Layout presets
        const LAYOUTS = {
            office: [
                { x: 0.1, y: 0.1, w: 0.01, h: 0.8 },     // Left wall
                { x: 0.9, y: 0.1, w: 0.01, h: 0.8 },     // Right wall
                { x: 0.1, y: 0.1, w: 0.8, h: 0.01 },     // Top wall
                { x: 0.1, y: 0.9, w: 0.8, h: 0.01 },     // Bottom wall
                { x: 0.3, y: 0.1, w: 0.01, h: 0.4 },     // Partition 1
                { x: 0.5, y: 0.5, w: 0.01, h: 0.4 },     // Partition 2
                { x: 0.7, y: 0.1, w: 0.01, h: 0.4 },     // Partition 3
            ],
            gallery: [
                { x: 0.05, y: 0.05, w: 0.01, h: 0.9 },
                { x: 0.95, y: 0.05, w: 0.01, h: 0.9 },
                { x: 0.05, y: 0.05, w: 0.9, h: 0.01 },
                { x: 0.05, y: 0.95, w: 0.9, h: 0.01 },
                { x: 0.25, y: 0.25, w: 0.2, h: 0.01 },
                { x: 0.25, y: 0.25, w: 0.01, h: 0.2 },
                { x: 0.55, y: 0.55, w: 0.2, h: 0.01 },
                { x: 0.75, y: 0.55, w: 0.01, h: 0.2 },
                { x: 0.25, y: 0.55, w: 0.01, h: 0.2 },
                { x: 0.55, y: 0.25, w: 0.01, h: 0.2 },
            ],
            apartment: [
                { x: 0.1, y: 0.1, w: 0.01, h: 0.8 },
                { x: 0.9, y: 0.1, w: 0.01, h: 0.8 },
                { x: 0.1, y: 0.1, w: 0.8, h: 0.01 },
                { x: 0.1, y: 0.9, w: 0.8, h: 0.01 },
                { x: 0.4, y: 0.1, w: 0.01, h: 0.5 },
                { x: 0.1, y: 0.5, w: 0.2, h: 0.01 },
                { x: 0.6, y: 0.4, w: 0.3, h: 0.01 },
                { x: 0.6, y: 0.4, w: 0.01, h: 0.3 },
            ],
            museum: [
                { x: 0.05, y: 0.05, w: 0.01, h: 0.9 },
                { x: 0.95, y: 0.05, w: 0.01, h: 0.9 },
                { x: 0.05, y: 0.05, w: 0.9, h: 0.01 },
                { x: 0.05, y: 0.95, w: 0.9, h: 0.01 },
                { x: 0.3, y: 0.2, w: 0.15, h: 0.15 },
                { x: 0.55, y: 0.2, w: 0.15, h: 0.15 },
                { x: 0.3, y: 0.65, w: 0.15, h: 0.15 },
                { x: 0.55, y: 0.65, w: 0.15, h: 0.15 },
            ],
            custom: []
        };

        function loadLayout() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            walls = LAYOUTS[params.layout].map(wall => ({
                x: wall.x * w,
                y: wall.y * h,
                w: wall.w * w,
                h: wall.h * h
            }));
        }

        function createGrid() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cellW = w / params.gridRes;
            const cellH = h / params.gridRes;

            grid = [];
            for (let y = 0; y < params.gridRes; y++) {
                for (let x = 0; x < params.gridRes; x++) {
                    const cx = x * cellW + cellW / 2;
                    const cy = y * cellH + cellH / 2;

                    // Check if cell is inside a wall
                    const inWall = walls.some(wall =>
                        cx >= wall.x && cx <= wall.x + wall.w &&
                        cy >= wall.y && cy <= wall.y + wall.h
                    );

                    grid.push({
                        x: x,
                        y: y,
                        cx: cx,
                        cy: cy,
                        isWall: inWall,
                        connectivity: 0,
                        integration: 0,
                        depth: 0,
                        isovist: 0
                    });
                }
            }
        }

        // Check if line of sight is blocked
        function lineOfSight(x1, y1, x2, y2) {
            for (const wall of walls) {
                if (lineIntersectsRect(x1, y1, x2, y2, wall.x, wall.y, wall.w, wall.h)) {
                    return false;
                }
            }
            return true;
        }

        function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
            // Check all four edges of rectangle
            return (
                lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx + rw, ry) ||
                lineIntersectsLine(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh) ||
                lineIntersectsLine(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh) ||
                lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx, ry + rh)
            );
        }

        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 0.0001) return false;

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

            return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
        }

        function buildVisibilityGraph() {
            const openCells = grid.filter(c => !c.isWall);

            // Calculate connectivity (direct visibility count)
            for (const cell of openCells) {
                let connections = 0;
                for (const other of openCells) {
                    if (cell !== other && lineOfSight(cell.cx, cell.cy, other.cx, other.cy)) {
                        connections++;
                    }
                }
                cell.connectivity = connections;
            }

            // Calculate depth using BFS from each cell
            for (const start of openCells) {
                const distances = new Map();
                const queue = [start];
                distances.set(start, 0);

                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentDist = distances.get(current);

                    for (const other of openCells) {
                        if (!distances.has(other) && lineOfSight(current.cx, current.cy, other.cx, other.cy)) {
                            distances.set(other, currentDist + 1);
                            queue.push(other);
                        }
                    }
                }

                // Mean depth
                let totalDepth = 0;
                distances.forEach(d => totalDepth += d);
                start.depth = totalDepth / (distances.size - 1) || 0;
            }

            // Calculate integration (inverse of depth, normalized)
            const maxDepth = Math.max(...openCells.map(c => c.depth));
            for (const cell of openCells) {
                cell.integration = maxDepth > 0 ? 1 - (cell.depth / maxDepth) : 0;
            }

            // Calculate isovist area (approximation)
            for (const cell of openCells) {
                cell.isovist = cell.connectivity / openCells.length;
            }

            updateStats();
        }

        function updateStats() {
            const openCells = grid.filter(c => !c.isWall);
            document.getElementById('cellCount').textContent = openCells.length;

            const avgConn = openCells.reduce((s, c) => s + c.connectivity, 0) / openCells.length;
            document.getElementById('avgConnectivity').textContent = avgConn.toFixed(1);

            const maxInt = Math.max(...openCells.map(c => c.integration));
            document.getElementById('maxIntegration').textContent = maxInt.toFixed(3);

            // Movement prediction based on integration
            const highIntegration = openCells.filter(c => c.integration > 0.7).length;
            const movementPct = (highIntegration / openCells.length * 100).toFixed(0);
            document.getElementById('movement').textContent = `${movementPct}% high-traffic areas`;
        }

        function getValueColor(value, min, max) {
            const norm = max > min ? (value - min) / (max - min) : 0;
            // Green (high) -> Yellow -> Red (low)
            if (norm > 0.5) {
                const t = (norm - 0.5) * 2;
                const r = Math.round(234 * (1 - t) + 34 * t);
                const g = Math.round(179 + (197 - 179) * t);
                const b = Math.round(8 * (1 - t) + 94 * t);
                return `rgb(${r},${g},${b})`;
            } else {
                const t = norm * 2;
                const r = Math.round(239 * (1 - t) + 234 * t);
                const g = Math.round(68 * (1 - t) + 179 * t);
                const b = Math.round(68 * (1 - t) + 8 * t);
                return `rgb(${r},${g},${b})`;
            }
        }

        function draw() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cellW = w / params.gridRes;
            const cellH = h / params.gridRes;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            // Get value range for current display mode
            const openCells = grid.filter(c => !c.isWall);
            let values, min, max;

            switch (params.displayMode) {
                case 'connectivity':
                    values = openCells.map(c => c.connectivity);
                    break;
                case 'integration':
                    values = openCells.map(c => c.integration);
                    break;
                case 'depth':
                    values = openCells.map(c => c.depth);
                    break;
                case 'isovist':
                    values = openCells.map(c => c.isovist);
                    break;
            }

            min = Math.min(...values);
            max = Math.max(...values);

            // Draw grid cells
            for (const cell of grid) {
                const x = cell.x * cellW;
                const y = cell.y * cellH;

                if (cell.isWall) {
                    ctx.fillStyle = '#333';
                } else {
                    let value;
                    switch (params.displayMode) {
                        case 'connectivity': value = cell.connectivity; break;
                        case 'integration': value = cell.integration; break;
                        case 'depth': value = max - cell.depth + min; break; // Invert for depth
                        case 'isovist': value = cell.isovist; break;
                    }
                    ctx.fillStyle = getValueColor(value, min, max);
                }

                ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
            }

            // Draw walls
            ctx.fillStyle = '#222';
            for (const wall of walls) {
                ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
            }

            // Title
            ctx.fillStyle = '#06b6d4';
            ctx.font = 'bold 16px Lora';
            ctx.textAlign = 'center';
            const titles = {
                connectivity: 'Connectivity Analysis (Visible Cells)',
                integration: 'Integration Analysis (Accessibility)',
                depth: 'Mean Depth Analysis (Topological Distance)',
                isovist: 'Isovist Area Analysis (Visibility Field)'
            };
            ctx.fillText(titles[params.displayMode], w / 2, 30);
        }

        function analyze() {
            createGrid();
            buildVisibilityGraph();
            draw();
        }

        // Event listeners
        document.getElementById('layoutPreset').addEventListener('change', e => {
            params.layout = e.target.value;
            if (params.layout !== 'custom') {
                loadLayout();
                analyze();
            } else {
                walls = [];
                grid = [];
                draw();
            }
        });

        document.getElementById('gridRes').addEventListener('input', e => {
            params.gridRes = parseInt(e.target.value);
            document.getElementById('gridValue').textContent = params.gridRes;
        });

        document.getElementById('displayMode').addEventListener('change', e => {
            params.displayMode = e.target.value;
            draw();
        });

        document.getElementById('analyze').addEventListener('click', analyze);
        document.getElementById('reset').addEventListener('click', () => {
            loadLayout();
            grid = [];
            analysisResults = [];
            draw();
        });

        // Custom wall drawing
        canvas.addEventListener('mousedown', e => {
            if (params.layout !== 'custom') return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            drawStart = {
                x: (e.clientX - rect.left) * dpr,
                y: (e.clientY - rect.top) * dpr
            };
        });

        canvas.addEventListener('mousemove', e => {
            if (!isDrawing || params.layout !== 'custom') return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;

            draw();
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                Math.min(drawStart.x, x) / dpr,
                Math.min(drawStart.y, y) / dpr,
                Math.abs(x - drawStart.x) / dpr,
                Math.abs(y - drawStart.y) / dpr
            );
        });

        canvas.addEventListener('mouseup', e => {
            if (!isDrawing || params.layout !== 'custom') return;
            isDrawing = false;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left);
            const y = (e.clientY - rect.top);

            walls.push({
                x: Math.min(drawStart.x / dpr, x),
                y: Math.min(drawStart.y / dpr, y),
                w: Math.abs(x - drawStart.x / dpr),
                h: Math.abs(y - drawStart.y / dpr)
            });

            draw();
        });

        window.addEventListener('resize', () => {
            resize();
            loadLayout();
            if (grid.length > 0) analyze();
            else draw();
        });

        // Initialize
        resize();
        loadLayout();
        draw();
    </script>
</body>
</html>
