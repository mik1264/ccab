<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Art - Interactive Aesthetic Evolution</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .gallery { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
        .art-cell { aspect-ratio: 1; border-radius: 12px; overflow: hidden; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.1); position: relative; }
        .art-cell:hover { transform: scale(1.02); box-shadow: 0 6px 20px rgba(0,0,0,0.15); }
        .art-cell.selected { border: 4px solid #606C38; }
        .art-cell canvas { width: 100%; height: 100%; }
        .art-cell .fitness { position: absolute; bottom: 5px; right: 5px; background: rgba(0,0,0,0.6); color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); display: flex; gap: 20px; flex-wrap: wrap; align-items: center; justify-content: center; }
        button { padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.95rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .btn-primary:hover, .btn-secondary:hover { transform: translateY(-2px); }
        .stats { display: flex; gap: 30px; }
        .stat { text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.3rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.8rem; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.9rem; color: #606C38; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .selection-hint { color: #BC6C25; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Evolutionary Art</h1>
            <p class="subtitle">Click to select your favorites — they'll breed to create the next generation</p>
        </header>

        <div class="gallery" id="gallery"></div>

        <div class="controls">
            <button class="btn-primary" onclick="evolveGeneration()">Evolve Selected</button>
            <button class="btn-secondary" onclick="randomGeneration()">Random Generation</button>
            <button class="btn-secondary" onclick="mutateAll()">Mutate All</button>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="generation">1</div>
                    <div class="stat-label">Generation</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="selected">0</div>
                    <div class="stat-label">Selected</div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <span class="selection-hint">Select 2-4 artworks</span> you find aesthetically pleasing, then click "Evolve Selected" to create offspring.
            Genomes encode mathematical functions that generate visual patterns using sine, cosine, and other operators.
        </div>
    </div>

    <script>
        const POPULATION_SIZE = 12;
        let population = [];
        let selected = new Set();
        let generation = 1;

        // Genome: tree of mathematical operations
        const OPERATIONS = ['sin', 'cos', 'mul', 'add', 'mod', 'abs', 'sqrt', 'pow', 'noise'];
        const TERMINALS = ['x', 'y', 't', 'r', 'const'];

        function randomNode(depth = 0, maxDepth = 4) {
            if (depth >= maxDepth || (depth > 1 && Math.random() < 0.3)) {
                // Terminal
                const terminal = TERMINALS[Math.floor(Math.random() * TERMINALS.length)];
                if (terminal === 'const') {
                    return { type: 'const', value: Math.random() * 4 - 2 };
                }
                return { type: terminal };
            } else {
                // Operation
                const op = OPERATIONS[Math.floor(Math.random() * OPERATIONS.length)];
                const node = { type: op };

                switch (op) {
                    case 'sin':
                    case 'cos':
                    case 'abs':
                    case 'sqrt':
                        node.child = randomNode(depth + 1, maxDepth);
                        break;
                    case 'mul':
                    case 'add':
                    case 'mod':
                    case 'pow':
                        node.left = randomNode(depth + 1, maxDepth);
                        node.right = randomNode(depth + 1, maxDepth);
                        break;
                    case 'noise':
                        node.left = randomNode(depth + 1, maxDepth);
                        node.right = randomNode(depth + 1, maxDepth);
                        break;
                }
                return node;
            }
        }

        function evaluateNode(node, x, y, t) {
            const r = Math.sqrt(x * x + y * y);

            switch (node.type) {
                case 'x': return x;
                case 'y': return y;
                case 't': return t;
                case 'r': return r;
                case 'const': return node.value;
                case 'sin': return Math.sin(evaluateNode(node.child, x, y, t) * Math.PI);
                case 'cos': return Math.cos(evaluateNode(node.child, x, y, t) * Math.PI);
                case 'abs': return Math.abs(evaluateNode(node.child, x, y, t));
                case 'sqrt': {
                    const v = evaluateNode(node.child, x, y, t);
                    return v >= 0 ? Math.sqrt(v) : -Math.sqrt(-v);
                }
                case 'mul': return evaluateNode(node.left, x, y, t) * evaluateNode(node.right, x, y, t);
                case 'add': return evaluateNode(node.left, x, y, t) + evaluateNode(node.right, x, y, t);
                case 'mod': {
                    const l = evaluateNode(node.left, x, y, t);
                    const r = evaluateNode(node.right, x, y, t);
                    return r !== 0 ? l % r : l;
                }
                case 'pow': {
                    const base = evaluateNode(node.left, x, y, t);
                    const exp = Math.min(3, Math.max(-3, evaluateNode(node.right, x, y, t)));
                    return Math.pow(Math.abs(base), exp) * Math.sign(base);
                }
                case 'noise': {
                    const nx = evaluateNode(node.left, x, y, t);
                    const ny = evaluateNode(node.right, x, y, t);
                    return Math.sin(nx * 12.9898 + ny * 78.233) * 43758.5453 % 1;
                }
                default: return 0;
            }
        }

        function cloneNode(node) {
            if (!node) return null;
            const clone = { type: node.type };
            if (node.value !== undefined) clone.value = node.value;
            if (node.child) clone.child = cloneNode(node.child);
            if (node.left) clone.left = cloneNode(node.left);
            if (node.right) clone.right = cloneNode(node.right);
            return clone;
        }

        function mutateNode(node, rate = 0.1) {
            if (!node) return randomNode(0, 2);

            if (Math.random() < rate) {
                // Replace entire subtree
                return randomNode(0, 3);
            }

            if (node.value !== undefined && Math.random() < rate * 2) {
                node.value += (Math.random() - 0.5) * 0.5;
            }

            if (node.child) node.child = mutateNode(node.child, rate);
            if (node.left) node.left = mutateNode(node.left, rate);
            if (node.right) node.right = mutateNode(node.right, rate);

            return node;
        }

        function crossover(parent1, parent2) {
            const child = cloneNode(parent1);

            // Pick random node from parent2 and insert into child
            function getRandomSubtree(node, depth = 0) {
                if (!node) return null;
                if (Math.random() < 0.3 || depth > 3) return cloneNode(node);

                if (node.child && Math.random() > 0.5) return getRandomSubtree(node.child, depth + 1);
                if (node.left && Math.random() > 0.5) return getRandomSubtree(node.left, depth + 1);
                if (node.right && Math.random() > 0.5) return getRandomSubtree(node.right, depth + 1);

                return cloneNode(node);
            }

            function replaceRandomSubtree(node, replacement, depth = 0) {
                if (!node) return;
                if (Math.random() < 0.2 && depth > 0) {
                    if (node.child) node.child = cloneNode(replacement);
                    else if (node.left) node.left = cloneNode(replacement);
                    else if (node.right) node.right = cloneNode(replacement);
                    return;
                }
                if (node.child) replaceRandomSubtree(node.child, replacement, depth + 1);
                if (node.left) replaceRandomSubtree(node.left, replacement, depth + 1);
                if (node.right) replaceRandomSubtree(node.right, replacement, depth + 1);
            }

            const subtree = getRandomSubtree(parent2);
            replaceRandomSubtree(child, subtree);

            return child;
        }

        class Artwork {
            constructor(genome = null) {
                this.rTree = genome ? cloneNode(genome.rTree) : randomNode();
                this.gTree = genome ? cloneNode(genome.gTree) : randomNode();
                this.bTree = genome ? cloneNode(genome.bTree) : randomNode();
                this.canvas = null;
            }

            render(size = 150) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(size, size);
                const data = imageData.data;
                const t = Date.now() * 0.001;

                for (let py = 0; py < size; py++) {
                    for (let px = 0; px < size; px++) {
                        const x = (px / size) * 2 - 1;
                        const y = (py / size) * 2 - 1;

                        let r = evaluateNode(this.rTree, x, y, t);
                        let g = evaluateNode(this.gTree, x, y, t);
                        let b = evaluateNode(this.bTree, x, y, t);

                        // Normalize to [0, 255]
                        r = Math.floor(((Math.tanh(r) + 1) / 2) * 255);
                        g = Math.floor(((Math.tanh(g) + 1) / 2) * 255);
                        b = Math.floor(((Math.tanh(b) + 1) / 2) * 255);

                        const idx = (py * size + px) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                this.canvas = canvas;
                return canvas;
            }

            mutate(rate = 0.1) {
                const child = new Artwork({
                    rTree: mutateNode(cloneNode(this.rTree), rate),
                    gTree: mutateNode(cloneNode(this.gTree), rate),
                    bTree: mutateNode(cloneNode(this.bTree), rate)
                });
                return child;
            }

            crossoverWith(other) {
                return new Artwork({
                    rTree: Math.random() > 0.5 ? crossover(this.rTree, other.rTree) : crossover(other.rTree, this.rTree),
                    gTree: Math.random() > 0.5 ? crossover(this.gTree, other.gTree) : crossover(other.gTree, this.gTree),
                    bTree: Math.random() > 0.5 ? crossover(this.bTree, other.bTree) : crossover(other.bTree, this.bTree)
                });
            }
        }

        function initGallery() {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            for (let i = 0; i < POPULATION_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'art-cell';
                cell.dataset.index = i;
                cell.onclick = () => toggleSelection(i);

                const canvas = population[i].render(200);
                cell.appendChild(canvas);

                gallery.appendChild(cell);
            }

            updateSelectionDisplay();
        }

        function toggleSelection(index) {
            if (selected.has(index)) {
                selected.delete(index);
            } else {
                if (selected.size < 4) {
                    selected.add(index);
                }
            }
            updateSelectionDisplay();
        }

        function updateSelectionDisplay() {
            document.querySelectorAll('.art-cell').forEach((cell, i) => {
                cell.classList.toggle('selected', selected.has(i));
            });
            document.getElementById('selected').textContent = selected.size;
        }

        function randomGeneration() {
            population = [];
            for (let i = 0; i < POPULATION_SIZE; i++) {
                population.push(new Artwork());
            }
            selected.clear();
            generation = 1;
            document.getElementById('generation').textContent = generation;
            initGallery();
        }

        function evolveGeneration() {
            if (selected.size < 2) {
                alert('Please select at least 2 artworks to breed!');
                return;
            }

            const parents = Array.from(selected).map(i => population[i]);
            const newPopulation = [];

            // Keep selected parents
            parents.forEach(p => newPopulation.push(p));

            // Create offspring
            while (newPopulation.length < POPULATION_SIZE) {
                const parent1 = parents[Math.floor(Math.random() * parents.length)];
                const parent2 = parents[Math.floor(Math.random() * parents.length)];

                let child;
                if (Math.random() > 0.3) {
                    child = parent1.crossoverWith(parent2);
                } else {
                    child = parent1.mutate(0.15);
                }

                // Always apply some mutation
                child = child.mutate(0.05);
                newPopulation.push(child);
            }

            population = newPopulation;
            selected.clear();
            generation++;
            document.getElementById('generation').textContent = generation;
            initGallery();
        }

        function mutateAll() {
            population = population.map(art => art.mutate(0.2));
            selected.clear();
            initGallery();
        }

        // Initialize
        randomGeneration();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
