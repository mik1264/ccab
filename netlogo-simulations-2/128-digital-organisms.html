<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Organisms - Avida-style Evolution</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #0a0a12; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .genome-display { background: #1a1a2e; color: #4fc3f7; font-family: monospace; font-size: 10px; padding: 8px; border-radius: 4px; margin-top: 10px; overflow-x: auto; white-space: nowrap; }
        .task-panel { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-top: 10px; font-size: 0.7rem; }
        .task { padding: 4px; border-radius: 3px; text-align: center; background: #eee; }
        .task.completed { background: #81c784; color: white; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Digital Organisms</h1>
            <p class="subtitle">Avida-inspired self-replicating programs evolving computational functions</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Mutation Rate</label>
                    <input type="range" id="mutationRate" min="1" max="50" value="10">
                    <div class="control-value"><span id="mutationRateVal">10</span>%</div>
                </div>
                <div class="control-group">
                    <label>Grid Size</label>
                    <input type="range" id="gridSize" min="20" max="60" value="40">
                    <div class="control-value"><span id="gridSizeVal">40</span>×<span id="gridSizeVal2">40</span></div>
                </div>
                <div class="control-group">
                    <label>Task Reward Multiplier</label>
                    <input type="range" id="reward" min="1" max="10" value="3">
                    <div class="control-value"><span id="rewardVal">3</span>×</div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset World</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="generation">0</div><div class="stat-label">Generation</div></div>
                    <div class="stat-box"><div class="stat-value" id="population">0</div><div class="stat-label">Population</div></div>
                    <div class="stat-box"><div class="stat-value" id="avgFitness">0</div><div class="stat-label">Avg Fitness</div></div>
                    <div class="stat-box"><div class="stat-value" id="maxFitness">0</div><div class="stat-label">Max Fitness</div></div>
                </div>

                <div class="control-group">
                    <label>Evolved Tasks</label>
                    <div class="task-panel" id="tasks">
                        <div class="task" id="task-not">NOT</div>
                        <div class="task" id="task-and">AND</div>
                        <div class="task" id="task-or">OR</div>
                        <div class="task" id="task-xor">XOR</div>
                        <div class="task" id="task-nand">NAND</div>
                        <div class="task" id="task-nor">NOR</div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Fittest Genome</label>
                    <div class="genome-display" id="genome">---</div>
                </div>

                <div class="info-panel">
                    <strong>Avida Model:</strong> Digital organisms with instruction-set genomes compete for CPU cycles. Organisms that evolve logic operations (NOT, AND, OR, XOR) gain fitness bonuses and replicate faster.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * dpr;
            canvas.style.height = rect.width + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); });

        // Instruction set (Avida-like)
        const INSTRUCTIONS = [
            'nop-A', 'nop-B', 'nop-C', // No-ops for template matching
            'if-n-equ', 'if-less',     // Conditionals
            'inc', 'dec',              // Arithmetic
            'push', 'pop', 'swap',     // Stack operations
            'shift-r', 'shift-l',      // Bit shifts
            'nand',                    // NAND operation (universal gate)
            'h-alloc', 'h-copy',       // Replication
            'h-divide',                // Division/reproduction
            'IO'                       // Input/Output
        ];

        // Logic tasks and rewards
        const TASKS = {
            'not': { test: (a, b) => ~a, reward: 1, evolved: false },
            'and': { test: (a, b) => a & b, reward: 2, evolved: false },
            'or': { test: (a, b) => a | b, reward: 2, evolved: false },
            'xor': { test: (a, b) => a ^ b, reward: 4, evolved: false },
            'nand': { test: (a, b) => ~(a & b), reward: 3, evolved: false },
            'nor': { test: (a, b) => ~(a | b), reward: 3, evolved: false }
        };

        class Organism {
            constructor(genome = null) {
                this.genome = genome || this.createGenome();
                this.registers = { A: 0, B: 0, C: 0 };
                this.stack = [];
                this.inputBuffer = [];
                this.outputBuffer = [];
                this.ip = 0; // Instruction pointer
                this.merit = 1;
                this.age = 0;
                this.tasksCompleted = new Set();
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
            }

            createGenome() {
                const length = 15 + Math.floor(Math.random() * 10);
                const genome = [];
                for (let i = 0; i < length; i++) {
                    genome.push(INSTRUCTIONS[Math.floor(Math.random() * INSTRUCTIONS.length)]);
                }
                // Essential replication instructions
                genome.push('h-alloc', 'h-copy', 'h-copy', 'h-divide');
                return genome;
            }

            execute(cycles = 10) {
                this.age++;
                for (let c = 0; c < cycles; c++) {
                    if (this.ip >= this.genome.length) this.ip = 0;
                    const instr = this.genome[this.ip];
                    this.executeInstruction(instr);
                    this.ip++;
                }
            }

            executeInstruction(instr) {
                switch(instr) {
                    case 'nop-A':
                    case 'nop-B':
                    case 'nop-C':
                        break;
                    case 'inc':
                        this.registers.A++;
                        break;
                    case 'dec':
                        this.registers.A--;
                        break;
                    case 'push':
                        this.stack.push(this.registers.A);
                        break;
                    case 'pop':
                        if (this.stack.length > 0) this.registers.A = this.stack.pop();
                        break;
                    case 'swap':
                        [this.registers.A, this.registers.B] = [this.registers.B, this.registers.A];
                        break;
                    case 'shift-r':
                        this.registers.A = this.registers.A >> 1;
                        break;
                    case 'shift-l':
                        this.registers.A = this.registers.A << 1;
                        break;
                    case 'nand':
                        this.registers.A = ~(this.registers.A & this.registers.B) & 0xFF;
                        break;
                    case 'if-n-equ':
                        if (this.registers.A === this.registers.B) this.ip++;
                        break;
                    case 'if-less':
                        if (this.registers.A >= this.registers.B) this.ip++;
                        break;
                    case 'IO':
                        if (this.inputBuffer.length > 0) {
                            this.registers.A = this.inputBuffer.shift();
                        }
                        this.outputBuffer.push(this.registers.A & 0xFF);
                        break;
                }
            }

            testTasks(rewardMultiplier) {
                if (this.outputBuffer.length >= 1 && this.inputBuffer.length === 0) {
                    const inputA = Math.floor(Math.random() * 256);
                    const inputB = Math.floor(Math.random() * 256);
                    this.inputBuffer = [inputA, inputB];

                    const output = this.outputBuffer[this.outputBuffer.length - 1];

                    for (const [name, task] of Object.entries(TASKS)) {
                        const expected = task.test(inputA, inputB) & 0xFF;
                        if (output === expected && !this.tasksCompleted.has(name)) {
                            this.tasksCompleted.add(name);
                            this.merit *= (1 + task.reward * rewardMultiplier * 0.1);
                            task.evolved = true;
                        }
                    }

                    this.outputBuffer = [];
                }
            }

            mutate(rate) {
                const newGenome = [...this.genome];
                for (let i = 0; i < newGenome.length; i++) {
                    if (Math.random() < rate) {
                        // Point mutation
                        newGenome[i] = INSTRUCTIONS[Math.floor(Math.random() * INSTRUCTIONS.length)];
                    }
                }
                // Insertion/deletion
                if (Math.random() < rate * 0.3 && newGenome.length < 50) {
                    const pos = Math.floor(Math.random() * newGenome.length);
                    newGenome.splice(pos, 0, INSTRUCTIONS[Math.floor(Math.random() * INSTRUCTIONS.length)]);
                }
                if (Math.random() < rate * 0.2 && newGenome.length > 10) {
                    const pos = Math.floor(Math.random() * newGenome.length);
                    newGenome.splice(pos, 1);
                }
                return newGenome;
            }

            reproduce(rate) {
                const child = new Organism(this.mutate(rate));
                child.color = this.color;
                // Slight color variation
                const hue = parseInt(child.color.match(/\d+/)[0]);
                child.color = `hsl(${(hue + Math.random() * 20 - 10 + 360) % 360}, 70%, 50%)`;
                return child;
            }
        }

        let state = {
            running: false,
            grid: [],
            gridSize: 40,
            generation: 0
        };

        function initGrid() {
            state.gridSize = parseInt(document.getElementById('gridSize').value);
            state.grid = [];
            state.generation = 0;

            // Reset tasks
            Object.values(TASKS).forEach(t => t.evolved = false);

            for (let i = 0; i < state.gridSize; i++) {
                state.grid[i] = [];
                for (let j = 0; j < state.gridSize; j++) {
                    // Sparse initial population
                    if (Math.random() < 0.3) {
                        state.grid[i][j] = new Organism();
                    } else {
                        state.grid[i][j] = null;
                    }
                }
            }
        }

        function update() {
            if (!state.running) return;

            const mutationRate = parseInt(document.getElementById('mutationRate').value) / 100;
            const rewardMultiplier = parseInt(document.getElementById('reward').value);

            state.generation++;

            // Execute organisms
            for (let i = 0; i < state.gridSize; i++) {
                for (let j = 0; j < state.gridSize; j++) {
                    const org = state.grid[i][j];
                    if (org) {
                        org.execute(5);
                        org.testTasks(rewardMultiplier);
                    }
                }
            }

            // Reproduction and competition
            const newGrid = state.grid.map(row => [...row]);

            for (let i = 0; i < state.gridSize; i++) {
                for (let j = 0; j < state.gridSize; j++) {
                    const org = state.grid[i][j];
                    if (org && org.age > 10 && Math.random() < org.merit * 0.1) {
                        // Try to reproduce into adjacent cell
                        const neighbors = [
                            [i-1, j], [i+1, j], [i, j-1], [i, j+1],
                            [i-1, j-1], [i+1, j+1], [i-1, j+1], [i+1, j-1]
                        ].filter(([ni, nj]) =>
                            ni >= 0 && ni < state.gridSize && nj >= 0 && nj < state.gridSize
                        );

                        if (neighbors.length > 0) {
                            const [ni, nj] = neighbors[Math.floor(Math.random() * neighbors.length)];
                            const target = state.grid[ni][nj];

                            // Replace if empty or less fit
                            if (!target || target.merit < org.merit * 0.8) {
                                newGrid[ni][nj] = org.reproduce(mutationRate);
                            }
                        }
                    }

                    // Death from old age
                    if (org && org.age > 500 + org.merit * 100) {
                        if (Math.random() < 0.1) {
                            newGrid[i][j] = null;
                        }
                    }
                }
            }

            state.grid = newGrid;
            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, dims.width, dims.height);

            const cellSize = dims.width / state.gridSize;

            for (let i = 0; i < state.gridSize; i++) {
                for (let j = 0; j < state.gridSize; j++) {
                    const org = state.grid[i][j];
                    if (org) {
                        // Color intensity based on fitness
                        const brightness = Math.min(80, 30 + org.merit * 10);
                        ctx.fillStyle = org.color.replace('50%', brightness + '%');
                        ctx.fillRect(
                            i * cellSize + 0.5,
                            j * cellSize + 0.5,
                            cellSize - 1,
                            cellSize - 1
                        );

                        // Task completion indicator
                        if (org.tasksCompleted.size > 0) {
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                            ctx.beginPath();
                            ctx.arc(
                                i * cellSize + cellSize / 2,
                                j * cellSize + cellSize / 2,
                                cellSize / 4,
                                0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                }
            }

            // Grid lines
            ctx.strokeStyle = 'rgba(50, 50, 80, 0.3)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= state.gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, dims.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(dims.width, i * cellSize);
                ctx.stroke();
            }

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '14px Lora';
            ctx.fillText(`Digital Evolution | Gen ${state.generation}`, 10, 20);
        }

        function updateStats() {
            let population = 0;
            let totalFitness = 0;
            let maxFitness = 0;
            let fittest = null;

            for (let i = 0; i < state.gridSize; i++) {
                for (let j = 0; j < state.gridSize; j++) {
                    const org = state.grid[i][j];
                    if (org) {
                        population++;
                        totalFitness += org.merit;
                        if (org.merit > maxFitness) {
                            maxFitness = org.merit;
                            fittest = org;
                        }
                    }
                }
            }

            document.getElementById('generation').textContent = state.generation;
            document.getElementById('population').textContent = population;
            document.getElementById('avgFitness').textContent = population > 0 ?
                (totalFitness / population).toFixed(2) : '0';
            document.getElementById('maxFitness').textContent = maxFitness.toFixed(2);

            // Update task indicators
            for (const [name, task] of Object.entries(TASKS)) {
                const el = document.getElementById('task-' + name);
                if (el) {
                    el.className = task.evolved ? 'task completed' : 'task';
                }
            }

            // Show fittest genome
            if (fittest) {
                document.getElementById('genome').textContent =
                    fittest.genome.slice(0, 20).join(' ') + (fittest.genome.length > 20 ? '...' : '');
            }
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            initGrid();
            draw();
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('mutationRateVal').textContent = document.getElementById('mutationRate').value;
            const gs = document.getElementById('gridSize').value;
            document.getElementById('gridSizeVal').textContent = gs;
            document.getElementById('gridSizeVal2').textContent = gs;
            document.getElementById('rewardVal').textContent = document.getElementById('reward').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));

        initGrid();
        draw();
    </script>
</body>
</html>
