<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autopoiesis - Self-Producing Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #0a1628; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .legend { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; margin-top: 10px; font-size: 0.75rem; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        .status-indicator { padding: 8px; border-radius: 6px; text-align: center; font-weight: 600; margin-top: 10px; }
        .status-alive { background: #c8e6c9; color: #2e7d32; }
        .status-dying { background: #ffecb3; color: #f57f17; }
        .status-dead { background: #ffcdd2; color: #c62828; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Autopoiesis</h1>
            <p class="subtitle">Self-producing chemical reaction networks with membrane formation</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Food Particle Inflow</label>
                    <input type="range" id="foodRate" min="0" max="100" value="40">
                    <div class="control-value"><span id="foodRateVal">40</span>%</div>
                </div>
                <div class="control-group">
                    <label>Catalyst Efficiency</label>
                    <input type="range" id="catalystRate" min="10" max="100" value="50">
                    <div class="control-value"><span id="catalystRateVal">50</span>%</div>
                </div>
                <div class="control-group">
                    <label>Membrane Stability</label>
                    <input type="range" id="membraneStability" min="10" max="100" value="60">
                    <div class="control-value"><span id="membraneStabilityVal">60</span>%</div>
                </div>
                <div class="control-group">
                    <label>Decay Rate</label>
                    <input type="range" id="decayRate" min="1" max="50" value="15">
                    <div class="control-value"><span id="decayRateVal">15</span>%</div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset System</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="food">0</div><div class="stat-label">Food (S)</div></div>
                    <div class="stat-box"><div class="stat-value" id="membrane">0</div><div class="stat-label">Membrane (L)</div></div>
                    <div class="stat-box"><div class="stat-value" id="catalyst">0</div><div class="stat-label">Catalyst (K)</div></div>
                    <div class="stat-box"><div class="stat-value" id="waste">0</div><div class="stat-label">Waste (W)</div></div>
                </div>

                <div class="status-indicator status-alive" id="status">AUTOPOIETIC</div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#4fc3f7"></div>Substrate (S)</div>
                    <div class="legend-item"><div class="legend-color" style="background:#f06292"></div>Membrane (L)</div>
                    <div class="legend-item"><div class="legend-color" style="background:#ffd54f"></div>Catalyst (K)</div>
                    <div class="legend-item"><div class="legend-color" style="background:#90a4ae"></div>Waste (W)</div>
                </div>

                <div class="info-panel">
                    <strong>Autopoiesis (Maturana & Varela):</strong> A system that continuously produces and maintains itself. The membrane (L) is produced from substrate (S) catalyzed by internal components (K), creating a self-bounded unity.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * dpr;
            canvas.style.height = rect.width + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); });

        // Particle types
        const TYPES = {
            S: { name: 'Substrate', color: '#4fc3f7', radius: 3 },
            L: { name: 'Lipid', color: '#f06292', radius: 4 },
            K: { name: 'Catalyst', color: '#ffd54f', radius: 5 },
            W: { name: 'Waste', color: '#90a4ae', radius: 2 }
        };

        class Particle {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.age = 0;
                this.bonded = false;
                this.bondPartner = null;
            }

            update(membrane, center) {
                this.age++;

                // Brownian motion
                this.vx += (Math.random() - 0.5) * 0.5;
                this.vy += (Math.random() - 0.5) * 0.5;

                // Damping
                this.vx *= 0.95;
                this.vy *= 0.95;

                // Membrane particles are attracted to the membrane ring
                if (this.type === 'L' && membrane.radius > 0) {
                    const dx = this.x - center.x;
                    const dy = this.y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const targetDist = membrane.radius;

                    if (dist > 0) {
                        const force = (dist - targetDist) * 0.01;
                        this.vx -= (dx / dist) * force;
                        this.vy -= (dy / dist) * force;
                    }

                    // Align with tangent (form chain)
                    const tangentX = -dy / dist;
                    const tangentY = dx / dist;
                    this.vx += tangentX * 0.05;
                    this.vy += tangentY * 0.05;
                }

                // Catalyst stays inside
                if (this.type === 'K') {
                    const dx = this.x - center.x;
                    const dy = this.y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > membrane.radius * 0.7 && membrane.radius > 0) {
                        this.vx -= (dx / dist) * 0.3;
                        this.vy -= (dy / dist) * 0.3;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                // Boundary
                const margin = 20;
                if (this.x < margin) { this.x = margin; this.vx *= -0.5; }
                if (this.x > dims.width - margin) { this.x = dims.width - margin; this.vx *= -0.5; }
                if (this.y < margin) { this.y = margin; this.vy *= -0.5; }
                if (this.y > dims.height - margin) { this.y = dims.height - margin; this.vy *= -0.5; }
            }

            draw() {
                const info = TYPES[this.type];
                ctx.fillStyle = info.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, info.radius, 0, Math.PI * 2);
                ctx.fill();

                // Catalyst glow
                if (this.type === 'K') {
                    ctx.fillStyle = info.color + '40';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, info.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            distTo(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }

        let state = {
            running: false,
            particles: [],
            membrane: { radius: 80, integrity: 1 },
            center: { x: 0, y: 0 },
            time: 0,
            isAutopoietic: true
        };

        function initSystem() {
            state.particles = [];
            state.time = 0;
            state.center = { x: dims.width / 2, y: dims.height / 2 };
            state.membrane = { radius: 80, integrity: 1 };
            state.isAutopoietic = true;

            // Create initial membrane (lipid ring)
            const numLipids = 40;
            for (let i = 0; i < numLipids; i++) {
                const angle = (i / numLipids) * Math.PI * 2;
                state.particles.push(new Particle(
                    'L',
                    state.center.x + Math.cos(angle) * state.membrane.radius,
                    state.center.y + Math.sin(angle) * state.membrane.radius
                ));
            }

            // Create internal catalysts
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * state.membrane.radius * 0.5;
                state.particles.push(new Particle(
                    'K',
                    state.center.x + Math.cos(angle) * r,
                    state.center.y + Math.sin(angle) * r
                ));
            }

            // Some initial substrate
            for (let i = 0; i < 30; i++) {
                state.particles.push(new Particle(
                    'S',
                    Math.random() * dims.width,
                    Math.random() * dims.height
                ));
            }
        }

        function update() {
            if (!state.running) return;

            const params = {
                foodRate: parseInt(document.getElementById('foodRate').value) / 100,
                catalystRate: parseInt(document.getElementById('catalystRate').value) / 100,
                membraneStability: parseInt(document.getElementById('membraneStability').value) / 100,
                decayRate: parseInt(document.getElementById('decayRate').value) / 100
            };

            state.time++;

            // Add food particles from outside
            if (Math.random() < params.foodRate * 0.1) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                switch (side) {
                    case 0: x = 10; y = Math.random() * dims.height; break;
                    case 1: x = dims.width - 10; y = Math.random() * dims.height; break;
                    case 2: x = Math.random() * dims.width; y = 10; break;
                    case 3: x = Math.random() * dims.width; y = dims.height - 10; break;
                }
                state.particles.push(new Particle('S', x, y));
            }

            // Update particles
            for (const p of state.particles) {
                p.update(state.membrane, state.center);
            }

            // Chemical reactions
            const catalysts = state.particles.filter(p => p.type === 'K');
            const substrates = state.particles.filter(p => p.type === 'S');
            const lipids = state.particles.filter(p => p.type === 'L');

            // S + K -> L + K (catalyzed lipid production)
            for (const cat of catalysts) {
                for (const sub of substrates) {
                    if (cat.distTo(sub) < 15 && Math.random() < params.catalystRate * 0.1) {
                        // Convert substrate to lipid
                        sub.type = 'L';
                        // New lipid appears near catalyst
                        sub.x = cat.x + (Math.random() - 0.5) * 10;
                        sub.y = cat.y + (Math.random() - 0.5) * 10;
                        break;
                    }
                }
            }

            // Lipid decay (L -> W)
            for (const lip of lipids) {
                if (Math.random() < params.decayRate * 0.001) {
                    lip.type = 'W';
                }
            }

            // Catalyst can regenerate from substrate + lipid
            if (catalysts.length < 3 && substrates.length > 5 && lipids.length > 5) {
                for (const sub of substrates) {
                    for (const lip of lipids) {
                        if (sub.distTo(lip) < 10 && Math.random() < 0.01) {
                            sub.type = 'K';
                            lip.type = 'W';
                            break;
                        }
                    }
                }
            }

            // Remove waste that leaves the area
            state.particles = state.particles.filter(p => {
                if (p.type === 'W') {
                    return p.x > 5 && p.x < dims.width - 5 && p.y > 5 && p.y < dims.height - 5;
                }
                return true;
            });

            // Limit total particles
            if (state.particles.length > 500) {
                const waste = state.particles.filter(p => p.type === 'W');
                for (let i = 0; i < 10 && waste.length > i; i++) {
                    state.particles.splice(state.particles.indexOf(waste[i]), 1);
                }
            }

            // Calculate membrane radius and integrity
            const currentLipids = state.particles.filter(p => p.type === 'L');
            if (currentLipids.length > 0) {
                let avgDist = 0;
                for (const lip of currentLipids) {
                    avgDist += Math.sqrt((lip.x - state.center.x) ** 2 + (lip.y - state.center.y) ** 2);
                }
                state.membrane.radius = avgDist / currentLipids.length;

                // Integrity based on lipid count
                state.membrane.integrity = Math.min(1, currentLipids.length / 30);
            } else {
                state.membrane.radius = 0;
                state.membrane.integrity = 0;
            }

            // Check autopoietic status
            const hasEnoughLipids = currentLipids.length >= 20;
            const hasCatalysts = catalysts.length > 0;
            const hasStructure = state.membrane.integrity > 0.5;

            state.isAutopoietic = hasEnoughLipids && hasCatalysts && hasStructure;

            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            // Background gradient (aqueous environment)
            const gradient = ctx.createRadialGradient(
                state.center.x, state.center.y, 0,
                state.center.x, state.center.y, dims.width
            );
            gradient.addColorStop(0, '#0d1f3c');
            gradient.addColorStop(1, '#0a1628');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, dims.width, dims.height);

            // Draw membrane boundary (faint circle)
            if (state.membrane.radius > 0) {
                ctx.strokeStyle = `rgba(240, 98, 146, ${state.membrane.integrity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(state.center.x, state.center.y, state.membrane.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner glow
                const innerGradient = ctx.createRadialGradient(
                    state.center.x, state.center.y, 0,
                    state.center.x, state.center.y, state.membrane.radius
                );
                innerGradient.addColorStop(0, 'rgba(255, 213, 79, 0.1)');
                innerGradient.addColorStop(0.8, 'rgba(255, 213, 79, 0.05)');
                innerGradient.addColorStop(1, 'rgba(240, 98, 146, 0.1)');
                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(state.center.x, state.center.y, state.membrane.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw lipid connections
            const lipids = state.particles.filter(p => p.type === 'L');
            ctx.strokeStyle = 'rgba(240, 98, 146, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < lipids.length; i++) {
                for (let j = i + 1; j < lipids.length; j++) {
                    const d = lipids[i].distTo(lipids[j]);
                    if (d < 20) {
                        ctx.beginPath();
                        ctx.moveTo(lipids[i].x, lipids[i].y);
                        ctx.lineTo(lipids[j].x, lipids[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw particles
            for (const p of state.particles) {
                p.draw();
            }

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '14px Lora';
            ctx.fillText(`Autopoietic System | t=${state.time}`, 10, 25);
        }

        function updateStats() {
            const counts = { S: 0, L: 0, K: 0, W: 0 };
            for (const p of state.particles) {
                counts[p.type]++;
            }

            document.getElementById('food').textContent = counts.S;
            document.getElementById('membrane').textContent = counts.L;
            document.getElementById('catalyst').textContent = counts.K;
            document.getElementById('waste').textContent = counts.W;

            const statusEl = document.getElementById('status');
            if (state.isAutopoietic) {
                statusEl.textContent = 'AUTOPOIETIC ✓';
                statusEl.className = 'status-indicator status-alive';
            } else if (state.membrane.integrity > 0.3) {
                statusEl.textContent = 'DEGRADING ⚠';
                statusEl.className = 'status-indicator status-dying';
            } else {
                statusEl.textContent = 'DEAD ✗';
                statusEl.className = 'status-indicator status-dead';
            }
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            initSystem();
            draw();
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('foodRateVal').textContent = document.getElementById('foodRate').value;
            document.getElementById('catalystRateVal').textContent = document.getElementById('catalystRate').value;
            document.getElementById('membraneStabilityVal').textContent = document.getElementById('membraneStability').value;
            document.getElementById('decayRateVal').textContent = document.getElementById('decayRate').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));

        initSystem();
        draw();
    </script>
</body>
</html>
