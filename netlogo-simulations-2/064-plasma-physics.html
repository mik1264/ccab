<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plasma Physics - PIC Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            min-height: 100vh;
            color: #e0e0ff;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2rem;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            margin-bottom: 5px;
        }

        .subtitle {
            color: #ff00ff;
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 1;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .simulation-area {
            background: rgba(0, 0, 20, 0.8);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background: #000010;
        }

        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: rgba(20, 10, 40, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 0, 255, 0.3);
        }

        .control-group h3 {
            color: #ff00ff;
            font-size: 0.85rem;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            margin-bottom: 10px;
        }

        .control-row label {
            display: block;
            font-size: 0.8rem;
            color: #aaf;
            margin-bottom: 4px;
        }

        .control-row input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .control-row select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #e0e0ff;
            font-size: 0.85rem;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ffff, #0088ff);
            color: #000;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff00ff, #8800ff);
            color: #fff;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #ff0088);
            color: #fff;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.4);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            background: rgba(0, 0, 30, 0.6);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #00ffff;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .stat-value.positive {
            color: #ff4444;
        }

        .stat-value.negative {
            color: #4444ff;
        }

        .info-box {
            background: rgba(0, 40, 60, 0.6);
            border-radius: 10px;
            padding: 12px;
            font-size: 0.8rem;
            line-height: 1.5;
            border-left: 3px solid #00ffff;
        }

        .info-box h4 {
            color: #00ffff;
            margin-bottom: 8px;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .electron {
            background: #4488ff;
            box-shadow: 0 0 8px #4488ff;
        }

        .ion {
            background: #ff4444;
            box-shadow: 0 0 8px #ff4444;
        }

        .field {
            background: linear-gradient(45deg, #00ff88, #00ffff);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Simulations</a>

    <div class="container">
        <header>
            <h1>⚡ Plasma Physics Simulation</h1>
            <p class="subtitle">Particle-in-Cell (PIC) Method with Electromagnetic Fields</p>
        </header>

        <div class="main-content">
            <div class="simulation-area">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot electron"></div>
                        <span>Electrons (e⁻)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot ion"></div>
                        <span>Ions (e⁺)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot field"></div>
                        <span>Electric Field</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <h3>Simulation Controls</h3>
                    <div class="buttons">
                        <button class="btn-primary" id="startBtn">▶ Start</button>
                        <button class="btn-secondary" id="stepBtn">⏭ Step</button>
                        <button class="btn-danger" id="resetBtn">↺ Reset</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Plasma Parameters</h3>
                    <div class="control-row">
                        <label>Number of Particles: <span id="numParticlesVal">500</span></label>
                        <input type="range" id="numParticles" min="100" max="2000" value="500" step="100">
                    </div>
                    <div class="control-row">
                        <label>Temperature (eV): <span id="temperatureVal">10</span></label>
                        <input type="range" id="temperature" min="1" max="100" value="10">
                    </div>
                    <div class="control-row">
                        <label>Ion/Electron Mass Ratio: <span id="massRatioVal">100</span></label>
                        <input type="range" id="massRatio" min="10" max="1000" value="100" step="10">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Configuration</h3>
                    <div class="control-row">
                        <label>Scenario</label>
                        <select id="scenario">
                            <option value="thermal">Thermal Equilibrium</option>
                            <option value="two-stream">Two-Stream Instability</option>
                            <option value="beam">Electron Beam</option>
                            <option value="sheath">Plasma Sheath</option>
                            <option value="langmuir">Langmuir Waves</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Show Electric Field</label>
                        <select id="showField">
                            <option value="arrows">Field Arrows</option>
                            <option value="heatmap">Heatmap</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Boundary Conditions</label>
                        <select id="boundary">
                            <option value="periodic">Periodic</option>
                            <option value="reflecting">Reflecting</option>
                            <option value="absorbing">Absorbing</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value negative" id="numElectrons">0</div>
                            <div class="stat-label">Electrons</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value positive" id="numIons">0</div>
                            <div class="stat-label">Ions</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="kineticEnergy">0</div>
                            <div class="stat-label">Kinetic E</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="potentialEnergy">0</div>
                            <div class="stat-label">Potential E</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="debyeLength">0</div>
                            <div class="stat-label">λD (cells)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="plasmaFreq">0</div>
                            <div class="stat-label">ωp (norm)</div>
                        </div>
                    </div>
                </div>

                <div class="control-group info-box">
                    <h4>About Plasma Physics</h4>
                    <p>
                        This PIC simulation models charged particles (electrons and ions)
                        interacting through self-consistent electromagnetic fields.
                        Key phenomena include:
                    </p>
                    <ul style="margin-top: 8px; padding-left: 15px;">
                        <li><b>Debye Shielding:</b> Collective screening of charges</li>
                        <li><b>Plasma Oscillations:</b> Collective electron motion</li>
                        <li><b>Two-Stream Instability:</b> Counter-streaming beams</li>
                        <li><b>Langmuir Waves:</b> Electrostatic oscillations</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth - 30;
            const height = Math.min(width * 0.7, window.innerHeight - 250);
            canvas.width = width;
            canvas.height = height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation parameters
        const gridSize = 128;  // Number of grid cells
        let dt = 0.1;          // Time step (normalized)
        let running = false;

        // Particle arrays
        let electrons = [];
        let ions = [];

        // Field arrays (1D electrostatic for simplicity)
        let phi = new Float64Array(gridSize);      // Potential
        let E = new Float64Array(gridSize);         // Electric field
        let rho = new Float64Array(gridSize);       // Charge density

        // Parameters from controls
        let numParticles = 500;
        let temperature = 10;
        let massRatio = 100;
        let scenario = 'thermal';
        let showField = 'arrows';
        let boundary = 'periodic';

        // Physical constants (normalized units)
        const qe = -1;  // Electron charge
        const qi = 1;   // Ion charge
        const me = 1;   // Electron mass
        let mi = 100;   // Ion mass

        // Particle class
        class Particle {
            constructor(x, v, q, m, type) {
                this.x = x;
                this.v = v;
                this.q = q;
                this.m = m;
                this.type = type;
            }
        }

        // Initialize particles
        function initParticles() {
            electrons = [];
            ions = [];
            mi = massRatio;

            const n = numParticles;
            const vth_e = Math.sqrt(temperature / me);  // Electron thermal velocity
            const vth_i = Math.sqrt(temperature / mi);  // Ion thermal velocity

            switch(scenario) {
                case 'thermal':
                    // Uniform distribution with Maxwellian velocities
                    for (let i = 0; i < n; i++) {
                        const x = Math.random() * gridSize;
                        const ve = gaussianRandom() * vth_e;
                        const vi = gaussianRandom() * vth_i;
                        electrons.push(new Particle(x, ve, qe, me, 'electron'));
                        ions.push(new Particle(x, vi, qi, mi, 'ion'));
                    }
                    break;

                case 'two-stream':
                    // Two counter-streaming electron beams
                    const vbeam = 3 * vth_e;
                    for (let i = 0; i < n; i++) {
                        const x = Math.random() * gridSize;
                        const dir = i < n / 2 ? 1 : -1;
                        const ve = dir * vbeam + gaussianRandom() * vth_e * 0.3;
                        const vi = gaussianRandom() * vth_i;
                        electrons.push(new Particle(x, ve, qe, me, 'electron'));
                        ions.push(new Particle(x, vi, qi, mi, 'ion'));
                    }
                    break;

                case 'beam':
                    // Electron beam through background plasma
                    for (let i = 0; i < n * 0.8; i++) {
                        const x = Math.random() * gridSize;
                        const ve = gaussianRandom() * vth_e;
                        const vi = gaussianRandom() * vth_i;
                        electrons.push(new Particle(x, ve, qe, me, 'electron'));
                        ions.push(new Particle(x, vi, qi, mi, 'ion'));
                    }
                    // Add beam electrons
                    for (let i = 0; i < n * 0.2; i++) {
                        const x = Math.random() * gridSize * 0.2;
                        const ve = 5 * vth_e + gaussianRandom() * vth_e * 0.2;
                        electrons.push(new Particle(x, ve, qe, me, 'electron'));
                    }
                    break;

                case 'sheath':
                    // Plasma with wall on left side
                    for (let i = 0; i < n; i++) {
                        const x = gridSize * 0.2 + Math.random() * gridSize * 0.7;
                        const ve = gaussianRandom() * vth_e;
                        const vi = gaussianRandom() * vth_i;
                        electrons.push(new Particle(x, ve, qe, me, 'electron'));
                        ions.push(new Particle(x, vi, qi, mi, 'ion'));
                    }
                    break;

                case 'langmuir':
                    // Perturbed uniform plasma for Langmuir oscillations
                    const k = 2 * Math.PI / gridSize;  // Wave number
                    const amp = 0.1;  // Perturbation amplitude
                    for (let i = 0; i < n; i++) {
                        const x0 = i * gridSize / n;
                        const x = x0 + amp * Math.sin(k * x0) * gridSize / (2 * Math.PI);
                        const ve = gaussianRandom() * vth_e * 0.5;
                        const vi = gaussianRandom() * vth_i;
                        electrons.push(new Particle(x, ve, qe, me, 'electron'));
                        ions.push(new Particle(x0, vi, qi, mi, 'ion'));
                    }
                    break;
            }

            // Reset fields
            phi.fill(0);
            E.fill(0);
            rho.fill(0);
        }

        // Gaussian random number generator (Box-Muller)
        function gaussianRandom() {
            let u1, u2;
            do {
                u1 = Math.random();
                u2 = Math.random();
            } while (u1 === 0);
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        // Deposit charge to grid (linear interpolation)
        function depositCharge() {
            rho.fill(0);

            // Electrons
            for (const p of electrons) {
                const gx = ((p.x % gridSize) + gridSize) % gridSize;
                const i = Math.floor(gx);
                const i1 = (i + 1) % gridSize;
                const w1 = gx - i;
                const w0 = 1 - w1;
                rho[i] += p.q * w0;
                rho[i1] += p.q * w1;
            }

            // Ions
            for (const p of ions) {
                const gx = ((p.x % gridSize) + gridSize) % gridSize;
                const i = Math.floor(gx);
                const i1 = (i + 1) % gridSize;
                const w1 = gx - i;
                const w0 = 1 - w1;
                rho[i] += p.q * w0;
                rho[i1] += p.q * w1;
            }

            // Normalize
            const norm = gridSize / (electrons.length + ions.length);
            for (let i = 0; i < gridSize; i++) {
                rho[i] *= norm;
            }
        }

        // Solve Poisson equation using FFT-like iterative method
        function solvePoissonJacobi() {
            // Simple Jacobi iteration for ∇²φ = -ρ
            const newPhi = new Float64Array(gridSize);
            const omega = 1.5;  // Relaxation parameter

            for (let iter = 0; iter < 50; iter++) {
                for (let i = 0; i < gridSize; i++) {
                    const im = (i - 1 + gridSize) % gridSize;
                    const ip = (i + 1) % gridSize;
                    newPhi[i] = (1 - omega) * phi[i] + omega * 0.5 * (phi[im] + phi[ip] + rho[i]);
                }

                // Apply boundary conditions and copy
                if (boundary === 'periodic') {
                    for (let i = 0; i < gridSize; i++) {
                        phi[i] = newPhi[i];
                    }
                } else {
                    phi[0] = 0;
                    phi[gridSize - 1] = 0;
                    for (let i = 1; i < gridSize - 1; i++) {
                        phi[i] = newPhi[i];
                    }
                }
            }

            // Compute electric field E = -∇φ
            for (let i = 0; i < gridSize; i++) {
                const im = (i - 1 + gridSize) % gridSize;
                const ip = (i + 1) % gridSize;
                E[i] = -(phi[ip] - phi[im]) / 2;
            }
        }

        // Interpolate field to particle position
        function interpolateField(x) {
            const gx = ((x % gridSize) + gridSize) % gridSize;
            const i = Math.floor(gx);
            const i1 = (i + 1) % gridSize;
            const w1 = gx - i;
            const w0 = 1 - w1;
            return E[i] * w0 + E[i1] * w1;
        }

        // Push particles (leapfrog integration)
        function pushParticles() {
            // Electrons
            for (const p of electrons) {
                const Ex = interpolateField(p.x);
                p.v += (p.q / p.m) * Ex * dt;
                p.x += p.v * dt;

                // Boundary conditions
                applyBoundary(p);
            }

            // Ions
            for (const p of ions) {
                const Ex = interpolateField(p.x);
                p.v += (p.q / p.m) * Ex * dt;
                p.x += p.v * dt;

                applyBoundary(p);
            }
        }

        function applyBoundary(p) {
            switch(boundary) {
                case 'periodic':
                    p.x = ((p.x % gridSize) + gridSize) % gridSize;
                    break;
                case 'reflecting':
                    if (p.x < 0) {
                        p.x = -p.x;
                        p.v = -p.v;
                    } else if (p.x >= gridSize) {
                        p.x = 2 * gridSize - p.x;
                        p.v = -p.v;
                    }
                    break;
                case 'absorbing':
                    // Particles at boundaries are removed
                    break;
            }
        }

        // Remove absorbed particles
        function removeAbsorbedParticles() {
            if (boundary === 'absorbing') {
                electrons = electrons.filter(p => p.x >= 0 && p.x < gridSize);
                ions = ions.filter(p => p.x >= 0 && p.x < gridSize);
            }
        }

        // Calculate statistics
        function calculateStats() {
            let KE = 0;
            let PE = 0;

            // Kinetic energy
            for (const p of electrons) {
                KE += 0.5 * p.m * p.v * p.v;
            }
            for (const p of ions) {
                KE += 0.5 * p.m * p.v * p.v;
            }

            // Potential energy (from field)
            for (let i = 0; i < gridSize; i++) {
                PE += 0.5 * E[i] * E[i];
            }

            // Debye length estimate
            const n0 = electrons.length / gridSize;
            const vth = Math.sqrt(temperature / me);
            const lambdaD = vth / Math.sqrt(n0 + 0.001);

            // Plasma frequency
            const omega_p = Math.sqrt(n0);

            document.getElementById('numElectrons').textContent = electrons.length;
            document.getElementById('numIons').textContent = ions.length;
            document.getElementById('kineticEnergy').textContent = KE.toFixed(1);
            document.getElementById('potentialEnergy').textContent = PE.toFixed(2);
            document.getElementById('debyeLength').textContent = lambdaD.toFixed(2);
            document.getElementById('plasmaFreq').textContent = omega_p.toFixed(3);
        }

        // Main simulation step
        function step() {
            depositCharge();
            solvePoissonJacobi();
            pushParticles();
            removeAbsorbedParticles();
            calculateStats();
        }

        // Render
        function render() {
            const width = canvas.width;
            const height = canvas.height;
            const scaleX = width / gridSize;
            const scaleY = height;

            // Clear canvas
            ctx.fillStyle = '#000010';
            ctx.fillRect(0, 0, width, height);

            // Draw electric field
            if (showField === 'heatmap') {
                // Field strength as heatmap
                const maxE = Math.max(...E.map(Math.abs)) + 0.001;
                for (let i = 0; i < gridSize; i++) {
                    const intensity = Math.abs(E[i]) / maxE;
                    const hue = E[i] > 0 ? 0 : 240;  // Red for positive, blue for negative
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${intensity * 0.3})`;
                    ctx.fillRect(i * scaleX, 0, scaleX + 1, height);
                }
            } else if (showField === 'arrows') {
                // Field arrows
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.4)';
                ctx.lineWidth = 1;
                const arrowSpacing = 8;
                const maxE = Math.max(...E.map(Math.abs)) + 0.001;

                for (let i = 0; i < gridSize; i += arrowSpacing) {
                    const x = (i + 0.5) * scaleX;
                    const y = height / 2;
                    const len = (E[i] / maxE) * 30;

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + len, y);
                    // Arrow head
                    if (Math.abs(len) > 5) {
                        const dir = len > 0 ? 1 : -1;
                        ctx.lineTo(x + len - 5 * dir, y - 3);
                        ctx.moveTo(x + len, y);
                        ctx.lineTo(x + len - 5 * dir, y + 3);
                    }
                    ctx.stroke();
                }
            }

            // Draw phase space diagram at bottom
            const phaseHeight = height * 0.25;
            const phaseTop = height - phaseHeight;

            ctx.fillStyle = 'rgba(20, 10, 40, 0.7)';
            ctx.fillRect(0, phaseTop, width, phaseHeight);

            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, phaseTop + phaseHeight / 2);
            ctx.lineTo(width, phaseTop + phaseHeight / 2);
            ctx.stroke();

            // Draw particles in phase space
            const vMax = Math.sqrt(temperature) * 5;

            // Electrons in phase space
            ctx.fillStyle = 'rgba(68, 136, 255, 0.6)';
            for (const p of electrons) {
                const px = (((p.x % gridSize) + gridSize) % gridSize) * scaleX;
                const py = phaseTop + phaseHeight / 2 - (p.v / vMax) * phaseHeight * 0.4;
                ctx.beginPath();
                ctx.arc(px, Math.max(phaseTop, Math.min(height, py)), 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw particles in main view (top portion)
            const mainHeight = height * 0.7;

            // Ions (larger, red)
            ctx.fillStyle = '#ff4444';
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 4;
            for (const p of ions) {
                const px = (((p.x % gridSize) + gridSize) % gridSize) * scaleX;
                // Spread ions vertically based on velocity
                const py = mainHeight / 2 + (p.v / vMax) * mainHeight * 0.3;
                ctx.beginPath();
                ctx.arc(px, Math.max(5, Math.min(mainHeight - 5, py)), 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Electrons (smaller, blue)
            ctx.fillStyle = '#4488ff';
            ctx.shadowColor = '#4488ff';
            ctx.shadowBlur = 3;
            for (const p of electrons) {
                const px = (((p.x % gridSize) + gridSize) % gridSize) * scaleX;
                const py = mainHeight / 2 + (p.v / vMax) * mainHeight * 0.3;
                ctx.beginPath();
                ctx.arc(px, Math.max(5, Math.min(mainHeight - 5, py)), 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Position Space', 10, 15);
            ctx.fillText('Phase Space (x, vx)', 10, phaseTop + 12);
        }

        // Animation loop
        function animate() {
            if (running) {
                for (let i = 0; i < 3; i++) {
                    step();
                }
            }
            render();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? '⏸ Pause' : '▶ Start';
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            step();
            render();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = '▶ Start';
            initParticles();
            render();
        });

        // Parameter controls
        document.getElementById('numParticles').addEventListener('input', (e) => {
            numParticles = parseInt(e.target.value);
            document.getElementById('numParticlesVal').textContent = numParticles;
        });

        document.getElementById('temperature').addEventListener('input', (e) => {
            temperature = parseFloat(e.target.value);
            document.getElementById('temperatureVal').textContent = temperature;
        });

        document.getElementById('massRatio').addEventListener('input', (e) => {
            massRatio = parseInt(e.target.value);
            document.getElementById('massRatioVal').textContent = massRatio;
        });

        document.getElementById('scenario').addEventListener('change', (e) => {
            scenario = e.target.value;
            initParticles();
            render();
        });

        document.getElementById('showField').addEventListener('change', (e) => {
            showField = e.target.value;
        });

        document.getElementById('boundary').addEventListener('change', (e) => {
            boundary = e.target.value;
        });

        // Initialize
        initParticles();
        animate();
    </script>
</body>
</html>
