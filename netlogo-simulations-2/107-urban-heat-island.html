<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Heat Island - Temperature Gradient Model</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .section-title {
            font-family: 'Lora', serif;
            color: var(--moss);
            font-size: 1rem;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--terracotta);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--sage);
        }

        button.scenario-btn {
            font-size: 0.85rem;
            padding: 8px 12px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--sage) 0%, var(--moss) 100%);
            color: white;
            padding: 12px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-box .label {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .stat-box .value {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Lora', serif;
        }

        .stat-box.hot { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .stat-box.cool { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); }

        .info-panel {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .info-panel h3 {
            color: var(--moss);
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .colorbar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .colorbar-gradient {
            width: 200px;
            height: 20px;
            border-radius: 10px;
            background: linear-gradient(to right, #3498db, #2ecc71, #f1c40f, #e67e22, #e74c3c);
        }

        .colorbar-label {
            font-size: 0.85rem;
            font-weight: 600;
        }

        @media (max-width: 900px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span>‚Üê</span>
        <span>Back to Gallery</span>
    </a>

    <div class="container">
        <h1>Urban Heat Island</h1>
        <p class="subtitle">Surface Properties, Vegetation & Anthropogenic Heat Model</p>

        <div class="simulation-area">
            <div class="controls">
                <h3 class="section-title">Urban Structure</h3>
                <div class="control-group">
                    <label>Impervious Surface (%)</label>
                    <input type="range" id="imperviousPct" min="10" max="90" value="60">
                    <div class="value" id="imperviousPctValue">60%</div>
                </div>

                <div class="control-group">
                    <label>Building Density</label>
                    <input type="range" id="buildingDensity" min="0.1" max="1" step="0.1" value="0.5">
                    <div class="value" id="buildingDensityValue">0.50</div>
                </div>

                <div class="control-group">
                    <label>Avg Building Height (m)</label>
                    <input type="range" id="buildingHeight" min="5" max="50" value="15">
                    <div class="value" id="buildingHeightValue">15m</div>
                </div>

                <h3 class="section-title">Vegetation</h3>
                <div class="control-group">
                    <label>Tree Cover (%)</label>
                    <input type="range" id="treeCover" min="0" max="40" value="15">
                    <div class="value" id="treeCoverValue">15%</div>
                </div>

                <div class="control-group">
                    <label>Green Space (%)</label>
                    <input type="range" id="greenSpace" min="0" max="50" value="20">
                    <div class="value" id="greenSpaceValue">20%</div>
                </div>

                <h3 class="section-title">Surface Properties</h3>
                <div class="control-group">
                    <label>Urban Albedo</label>
                    <input type="range" id="urbanAlbedo" min="0.1" max="0.5" step="0.05" value="0.15">
                    <div class="value" id="urbanAlbedoValue">0.15</div>
                </div>

                <h3 class="section-title">Climate Conditions</h3>
                <div class="control-group">
                    <label>Solar Radiation (W/m¬≤)</label>
                    <input type="range" id="solarRadiation" min="200" max="1000" step="50" value="600">
                    <div class="value" id="solarRadiationValue">600</div>
                </div>

                <div class="control-group">
                    <label>Anthropogenic Heat (W/m¬≤)</label>
                    <input type="range" id="anthropogenicHeat" min="0" max="100" step="5" value="30">
                    <div class="value" id="anthropogenicHeatValue">30</div>
                </div>

                <div class="control-group">
                    <label>Rural Temperature (¬∞C)</label>
                    <input type="range" id="ruralTemp" min="15" max="35" value="25">
                    <div class="value" id="ruralTempValue">25¬∞C</div>
                </div>

                <button id="runBtn">‚ñ∂ Run Simulation</button>
                <button id="resetBtn" class="secondary">Reset</button>

                <div class="info-panel">
                    <h3>Mitigation Scenarios</h3>
                    <button class="scenario-btn" onclick="applyScenario('greenRoofs')">üåø Green Roofs</button>
                    <button class="scenario-btn" onclick="applyScenario('coolPavements')">‚¨ú Cool Pavements</button>
                    <button class="scenario-btn" onclick="applyScenario('urbanForest')">üå≥ Urban Forest</button>
                    <button class="scenario-btn" onclick="applyScenario('denseDevelopment')">üèôÔ∏è Dense Development</button>
                </div>

                <div class="info-panel">
                    <h3>Key Factors</h3>
                    <ul style="margin-left: 15px;">
                        <li><strong>Albedo:</strong> Lower reflectivity = more heat</li>
                        <li><strong>Vegetation:</strong> Evapotranspiration cools air</li>
                        <li><strong>Building mass:</strong> Stores heat during day</li>
                        <li><strong>Traffic/Industry:</strong> Anthropogenic heat</li>
                    </ul>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas"></canvas>

                <div class="colorbar">
                    <span class="colorbar-label">Cool</span>
                    <div class="colorbar-gradient"></div>
                    <span class="colorbar-label">Hot</span>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div class="label">Hour</div>
                        <div class="value" id="statHour">12:00</div>
                    </div>
                    <div class="stat-box hot">
                        <div class="label">UHI Intensity</div>
                        <div class="value" id="statUHI">+0¬∞C</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Max Urban Temp</div>
                        <div class="value" id="statMaxTemp">0¬∞C</div>
                    </div>
                    <div class="stat-box cool">
                        <div class="label">Cooling Effect</div>
                        <div class="value" id="statCooling">0¬∞C</div>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>Analysis</h3>
                    <p id="analysisText">Run the simulation to observe the urban heat island effect...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 40) * dpr;
            canvas.height = 400 * dpr;
            canvas.style.width = (rect.width - 40) + 'px';
            canvas.style.height = '400px';
            ctx.scale(dpr, dpr);
        }
        setupCanvas();
        window.addEventListener('resize', () => {
            setupCanvas();
            initGrid();
            draw();
        });

        // Parameters
        let params = {
            imperviousPct: 60,
            buildingDensity: 0.5,
            buildingHeight: 15,
            treeCover: 15,
            greenSpace: 20,
            urbanAlbedo: 0.15,
            solarRadiation: 600,
            anthropogenicHeat: 30,
            ruralTemp: 25
        };

        // Grid simulation
        const GRID_SIZE = 8;
        let grid = [];
        let temperatures = [];
        let hour = 12;
        let running = false;
        let animationId = null;

        // Land use types
        const LAND_USE = {
            RURAL: 0,
            SUBURBAN: 1,
            URBAN: 2,
            DOWNTOWN: 3,
            PARK: 4,
            WATER: 5
        };

        // Initialize grid
        function initGrid() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            const cols = Math.floor(width / GRID_SIZE);
            const rows = Math.floor(height / GRID_SIZE);
            const centerX = cols / 2;
            const centerY = rows / 2;

            grid = [];
            temperatures = [];

            for (let y = 0; y < rows; y++) {
                const gridRow = [];
                const tempRow = [];
                for (let x = 0; x < cols; x++) {
                    // Distance from center (city center)
                    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2);
                    const normalizedDist = dist / maxDist;

                    // Determine land use based on distance from center
                    let landUse;
                    if (normalizedDist < 0.15) {
                        landUse = LAND_USE.DOWNTOWN;
                    } else if (normalizedDist < 0.35) {
                        landUse = LAND_USE.URBAN;
                    } else if (normalizedDist < 0.6) {
                        landUse = LAND_USE.SUBURBAN;
                    } else {
                        landUse = LAND_USE.RURAL;
                    }

                    // Add some parks
                    if (Math.random() < params.greenSpace / 100 * (1 - normalizedDist * 0.5)) {
                        if (landUse !== LAND_USE.RURAL) {
                            landUse = LAND_USE.PARK;
                        }
                    }

                    gridRow.push({
                        landUse: landUse,
                        hasTree: Math.random() < params.treeCover / 100,
                        buildingHeight: landUse >= LAND_USE.URBAN ?
                            params.buildingHeight * (1 + (LAND_USE.DOWNTOWN - landUse) * 0.3) * (0.5 + Math.random()) : 0,
                        albedo: calculateAlbedo(landUse),
                        distFromCenter: normalizedDist
                    });

                    tempRow.push(params.ruralTemp);
                }
                grid.push(gridRow);
                temperatures.push(tempRow);
            }
        }

        // Calculate albedo based on land use
        function calculateAlbedo(landUse) {
            switch (landUse) {
                case LAND_USE.RURAL: return 0.25;
                case LAND_USE.SUBURBAN: return 0.2;
                case LAND_USE.URBAN: return params.urbanAlbedo;
                case LAND_USE.DOWNTOWN: return params.urbanAlbedo * 0.9;
                case LAND_USE.PARK: return 0.2;
                case LAND_USE.WATER: return 0.08;
                default: return 0.2;
            }
        }

        // Calculate temperature for a cell
        function calculateTemperature(cell, x, y, currentTemp) {
            let temp = params.ruralTemp;

            // Solar heating (depends on hour and albedo)
            const solarFactor = Math.max(0, Math.sin((hour - 6) / 12 * Math.PI));
            const absorbed = params.solarRadiation * solarFactor * (1 - cell.albedo);
            const solarHeating = absorbed * 0.015; // Simplified heat conversion

            // Anthropogenic heat
            let anthropogenic = 0;
            if (cell.landUse >= LAND_USE.URBAN) {
                anthropogenic = params.anthropogenicHeat * (cell.landUse === LAND_USE.DOWNTOWN ? 1.5 : 1.0);
                // Less at night
                if (hour < 6 || hour > 22) anthropogenic *= 0.3;
            }
            const anthropogenicHeating = anthropogenic * 0.02;

            // Building heat storage effect
            let storageEffect = 0;
            if (cell.buildingHeight > 0) {
                // Buildings store heat during day, release at night
                if (hour >= 12 && hour <= 18) {
                    storageEffect = cell.buildingHeight * 0.02;
                } else if (hour >= 20 || hour <= 6) {
                    storageEffect = cell.buildingHeight * 0.03; // Slower nighttime cooling
                }
            }

            // Vegetation cooling (evapotranspiration)
            let vegCooling = 0;
            if (cell.hasTree) {
                vegCooling = 2.0 * solarFactor; // Trees cool during day
            }
            if (cell.landUse === LAND_USE.PARK) {
                vegCooling += 1.5 * solarFactor;
            }
            if (cell.landUse === LAND_USE.RURAL) {
                vegCooling += 0.5 * solarFactor;
            }

            // Impervious surface effect
            let imperviousEffect = 0;
            if (cell.landUse >= LAND_USE.SUBURBAN) {
                const impervious = params.imperviousPct / 100;
                imperviousEffect = impervious * 2 * solarFactor;
            }

            // Calculate final temperature
            temp += solarHeating + anthropogenicHeating + storageEffect + imperviousEffect - vegCooling;

            // Thermal diffusion from neighbors
            if (x > 0 && x < grid[0].length - 1 && y > 0 && y < grid.length - 1) {
                const neighbors = [
                    temperatures[y - 1][x],
                    temperatures[y + 1][x],
                    temperatures[y][x - 1],
                    temperatures[y][x + 1]
                ];
                const avgNeighbor = neighbors.reduce((a, b) => a + b, 0) / 4;
                temp = temp * 0.8 + avgNeighbor * 0.2;
            }

            return temp;
        }

        // Step simulation
        function step() {
            hour = (hour + 0.5) % 24;

            // Update all temperatures
            const newTemps = [];
            for (let y = 0; y < grid.length; y++) {
                const row = [];
                for (let x = 0; x < grid[0].length; x++) {
                    row.push(calculateTemperature(grid[y][x], x, y, temperatures[y][x]));
                }
                newTemps.push(row);
            }
            temperatures = newTemps;

            updateStats();
        }

        // Get temperature color
        function getTempColor(temp, minTemp, maxTemp) {
            const t = (temp - minTemp) / (maxTemp - minTemp);
            const clamped = Math.max(0, Math.min(1, t));

            // Color gradient: blue -> green -> yellow -> orange -> red
            let r, g, b;
            if (clamped < 0.25) {
                const t2 = clamped / 0.25;
                r = 52;
                g = 152 + (204 - 152) * t2;
                b = 219 - 100 * t2;
            } else if (clamped < 0.5) {
                const t2 = (clamped - 0.25) / 0.25;
                r = 52 + (241 - 52) * t2;
                g = 204 - 8 * t2;
                b = 119 - 55 * t2;
            } else if (clamped < 0.75) {
                const t2 = (clamped - 0.5) / 0.25;
                r = 241 - 11 * t2;
                g = 196 - 70 * t2;
                b = 64 - 25 * t2;
            } else {
                const t2 = (clamped - 0.75) / 0.25;
                r = 230 + 1 * t2;
                g = 126 - 50 * t2;
                b = 39 - 13 * t2;
            }

            return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
        }

        // Update statistics
        function updateStats() {
            const hourStr = String(Math.floor(hour)).padStart(2, '0') + ':' +
                           String(Math.round((hour % 1) * 60)).padStart(2, '0');
            document.getElementById('statHour').textContent = hourStr;

            // Find min/max temps and UHI
            let maxTemp = -Infinity;
            let minTemp = Infinity;
            let urbanSum = 0, urbanCount = 0;
            let ruralSum = 0, ruralCount = 0;

            for (let y = 0; y < temperatures.length; y++) {
                for (let x = 0; x < temperatures[0].length; x++) {
                    const temp = temperatures[y][x];
                    maxTemp = Math.max(maxTemp, temp);
                    minTemp = Math.min(minTemp, temp);

                    if (grid[y][x].landUse >= LAND_USE.URBAN) {
                        urbanSum += temp;
                        urbanCount++;
                    }
                    if (grid[y][x].landUse === LAND_USE.RURAL) {
                        ruralSum += temp;
                        ruralCount++;
                    }
                }
            }

            const avgUrban = urbanCount > 0 ? urbanSum / urbanCount : params.ruralTemp;
            const avgRural = ruralCount > 0 ? ruralSum / ruralCount : params.ruralTemp;
            const uhi = avgUrban - avgRural;

            document.getElementById('statUHI').textContent = (uhi >= 0 ? '+' : '') + uhi.toFixed(1) + '¬∞C';
            document.getElementById('statMaxTemp').textContent = maxTemp.toFixed(1) + '¬∞C';

            // Cooling from vegetation
            const cooling = params.treeCover * 0.1 + params.greenSpace * 0.05;
            document.getElementById('statCooling').textContent = '-' + cooling.toFixed(1) + '¬∞C';

            // Analysis
            const analysis = document.getElementById('analysisText');
            if (uhi > 4) {
                analysis.innerHTML = '<span style="color: #e74c3c;">‚ö†Ô∏è Severe UHI effect (>4¬∞C). Consider increasing vegetation and albedo.</span>';
            } else if (uhi > 2) {
                analysis.innerHTML = '<span style="color: #f39c12;">Moderate UHI effect. Tree cover of 16%+ recommended for significant cooling.</span>';
            } else {
                analysis.innerHTML = '<span style="color: #27ae60;">UHI effect within acceptable range. Current mitigation measures are effective.</span>';
            }
        }

        // Draw simulation
        function draw() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            if (temperatures.length === 0) return;

            // Find temperature range
            let minTemp = Infinity, maxTemp = -Infinity;
            for (const row of temperatures) {
                for (const t of row) {
                    minTemp = Math.min(minTemp, t);
                    maxTemp = Math.max(maxTemp, t);
                }
            }

            // Ensure minimum range
            if (maxTemp - minTemp < 5) {
                const mid = (maxTemp + minTemp) / 2;
                minTemp = mid - 2.5;
                maxTemp = mid + 2.5;
            }

            // Draw temperature grid
            for (let y = 0; y < temperatures.length; y++) {
                for (let x = 0; x < temperatures[0].length; x++) {
                    const temp = temperatures[y][x];
                    ctx.fillStyle = getTempColor(temp, minTemp, maxTemp);
                    ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                }
            }

            // Draw land use overlay
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[0].length; x++) {
                    const cell = grid[y][x];

                    // Draw trees
                    if (cell.hasTree) {
                        ctx.fillStyle = 'rgba(39, 174, 96, 0.6)';
                        ctx.beginPath();
                        ctx.arc(x * GRID_SIZE + GRID_SIZE/2, y * GRID_SIZE + GRID_SIZE/2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Draw buildings (as darker spots)
                    if (cell.buildingHeight > 10) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.fillRect(x * GRID_SIZE + 1, y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    }
                }
            }

            // Draw center marker
            const centerX = Math.floor(grid[0].length / 2) * GRID_SIZE;
            const centerY = Math.floor(grid.length / 2) * GRID_SIZE;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Nunito';
            ctx.textAlign = 'center';
            ctx.fillText('CBD', centerX, centerY + 4);

            // Time indicator
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Nunito';
            ctx.textAlign = 'left';
            const period = hour < 12 ? 'AM' : 'PM';
            const displayHour = hour === 0 || hour === 12 ? 12 : (hour > 12 ? hour - 12 : hour);
            ctx.fillText(`${Math.floor(displayHour)}:00 ${period}`, 10, 20);

            // Legend
            ctx.font = '11px Nunito';
            ctx.fillText(`${minTemp.toFixed(0)}¬∞C - ${maxTemp.toFixed(0)}¬∞C`, 10, height - 10);
        }

        // Animation loop
        function animate() {
            if (!running) return;

            step();
            draw();

            animationId = setTimeout(() => requestAnimationFrame(animate), 200);
        }

        // Scenarios
        window.applyScenario = function(scenario) {
            switch (scenario) {
                case 'greenRoofs':
                    params.urbanAlbedo = 0.3;
                    params.treeCover = 20;
                    break;
                case 'coolPavements':
                    params.urbanAlbedo = 0.4;
                    params.imperviousPct = 50;
                    break;
                case 'urbanForest':
                    params.treeCover = 35;
                    params.greenSpace = 35;
                    break;
                case 'denseDevelopment':
                    params.imperviousPct = 85;
                    params.buildingDensity = 0.9;
                    params.buildingHeight = 40;
                    params.treeCover = 5;
                    params.greenSpace = 5;
                    params.anthropogenicHeat = 60;
                    break;
            }

            // Update UI
            document.getElementById('imperviousPct').value = params.imperviousPct;
            document.getElementById('imperviousPctValue').textContent = params.imperviousPct + '%';
            document.getElementById('treeCover').value = params.treeCover;
            document.getElementById('treeCoverValue').textContent = params.treeCover + '%';
            document.getElementById('greenSpace').value = params.greenSpace;
            document.getElementById('greenSpaceValue').textContent = params.greenSpace + '%';
            document.getElementById('urbanAlbedo').value = params.urbanAlbedo;
            document.getElementById('urbanAlbedoValue').textContent = params.urbanAlbedo;
            document.getElementById('buildingHeight').value = params.buildingHeight;
            document.getElementById('buildingHeightValue').textContent = params.buildingHeight + 'm';
            document.getElementById('anthropogenicHeat').value = params.anthropogenicHeat;
            document.getElementById('anthropogenicHeatValue').textContent = params.anthropogenicHeat;

            initGrid();
            step();
            draw();
        };

        // Event handlers
        document.getElementById('runBtn').addEventListener('click', () => {
            if (running) {
                running = false;
                clearTimeout(animationId);
                document.getElementById('runBtn').textContent = '‚ñ∂ Run Simulation';
            } else {
                running = true;
                document.getElementById('runBtn').textContent = '‚è∏ Pause';
                animate();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            clearTimeout(animationId);
            document.getElementById('runBtn').textContent = '‚ñ∂ Run Simulation';
            hour = 12;
            initGrid();
            step();
            draw();
        });

        // Parameter controls
        const controls = [
            { id: 'imperviousPct', param: 'imperviousPct', display: 'imperviousPctValue', format: v => v + '%' },
            { id: 'buildingDensity', param: 'buildingDensity', display: 'buildingDensityValue', format: v => v.toFixed(2) },
            { id: 'buildingHeight', param: 'buildingHeight', display: 'buildingHeightValue', format: v => v + 'm' },
            { id: 'treeCover', param: 'treeCover', display: 'treeCoverValue', format: v => v + '%' },
            { id: 'greenSpace', param: 'greenSpace', display: 'greenSpaceValue', format: v => v + '%' },
            { id: 'urbanAlbedo', param: 'urbanAlbedo', display: 'urbanAlbedoValue', format: v => v },
            { id: 'solarRadiation', param: 'solarRadiation', display: 'solarRadiationValue', format: v => v },
            { id: 'anthropogenicHeat', param: 'anthropogenicHeat', display: 'anthropogenicHeatValue', format: v => v },
            { id: 'ruralTemp', param: 'ruralTemp', display: 'ruralTempValue', format: v => v + '¬∞C' }
        ];

        controls.forEach(ctrl => {
            const input = document.getElementById(ctrl.id);
            const display = document.getElementById(ctrl.display);

            input.addEventListener('input', () => {
                const val = parseFloat(input.value);
                display.textContent = ctrl.format(val);
                params[ctrl.param] = val;

                // Reinitialize if structural change
                if (['imperviousPct', 'treeCover', 'greenSpace', 'buildingHeight', 'buildingDensity'].includes(ctrl.param)) {
                    initGrid();
                    step();
                    draw();
                }
            });
        });

        // Initialize
        initGrid();
        step();
        draw();
    </script>
</body>
</html>
