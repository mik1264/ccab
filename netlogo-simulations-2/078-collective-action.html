<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collective Action Problem - NetLogo-Style Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .panel h3 {
            color: #f39c12;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(243, 156, 18, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85em;
            color: #f39c12;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-wrapper h4 {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #f39c12;
            font-size: 0.95em;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #f39c12;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .outcome-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .outcome-success {
            background: rgba(39, 174, 96, 0.3);
            color: #27ae60;
        }

        .outcome-failure {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .outcome-partial {
            background: rgba(243, 156, 18, 0.3);
            color: #f39c12;
        }

        .payoff-matrix {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .payoff-matrix table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }

        .payoff-matrix td, .payoff-matrix th {
            padding: 5px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .payoff-matrix th {
            background: rgba(243, 156, 18, 0.2);
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f39c12;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Collective Action Problem</h1>
            <p class="subtitle">Olson's Logic: Group Size Effects, Selective Incentives, and Political Entrepreneurs</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h3>Group Parameters</h3>

                <div class="control-group">
                    <label>Group Size</label>
                    <input type="range" id="groupSize" min="5" max="500" value="50">
                    <div class="value"><span id="groupSizeVal">50</span></div>
                </div>

                <div class="control-group">
                    <label>Public Good Value (per capita)</label>
                    <input type="range" id="publicGoodValue" min="0.1" max="5" step="0.1" value="2">
                    <div class="value"><span id="publicGoodValueVal">2.0</span></div>
                </div>

                <div class="control-group">
                    <label>Contribution Cost</label>
                    <input type="range" id="contributionCost" min="0.1" max="3" step="0.1" value="1">
                    <div class="value"><span id="contributionCostVal">1.0</span></div>
                </div>

                <div class="control-group">
                    <label>Production Function</label>
                    <select id="productionFunction">
                        <option value="linear">Linear</option>
                        <option value="accelerating">Accelerating (Critical Mass)</option>
                        <option value="decelerating">Decelerating (Saturation)</option>
                        <option value="threshold">Step Threshold</option>
                    </select>
                </div>

                <h3>Incentive Mechanisms</h3>

                <div class="control-group">
                    <label>Selective Incentive (reward)</label>
                    <input type="range" id="selectiveIncentive" min="0" max="2" step="0.1" value="0">
                    <div class="value"><span id="selectiveIncentiveVal">0.0</span></div>
                </div>

                <div class="control-group">
                    <label>Punishment for Free-Riding</label>
                    <input type="range" id="punishment" min="0" max="2" step="0.1" value="0">
                    <div class="value"><span id="punishmentVal">0.0</span></div>
                </div>

                <div class="control-group">
                    <label>Political Entrepreneurs</label>
                    <input type="range" id="entrepreneurs" min="0" max="10" value="0">
                    <div class="value"><span id="entrepreneursVal">0</span></div>
                </div>

                <h3>Agent Behavior</h3>

                <div class="control-group">
                    <label>Initial Participation Rate</label>
                    <input type="range" id="initParticipation" min="0" max="1" step="0.01" value="0.5">
                    <div class="value"><span id="initParticipationVal">50</span>%</div>
                </div>

                <div class="control-group">
                    <label>Learning Rate</label>
                    <input type="range" id="learningRate" min="0" max="0.5" step="0.01" value="0.1">
                    <div class="value"><span id="learningRateVal">0.10</span></div>
                </div>

                <h3>Simulation Control</h3>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-success" id="resetBtn">Reset</button>
                </div>

                <div class="button-group">
                    <button class="btn-secondary" id="varyGroupBtn">Vary Group Size</button>
                </div>

                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="speed" min="1" max="20" value="5">
                    <div class="value"><span id="speedVal">5</span> steps/frame</div>
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <h4>Agent Population</h4>
                        <canvas id="populationCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Participation Over Time</h4>
                        <canvas id="participationCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Group Size Effect</h4>
                        <canvas id="groupSizeCanvas" width="400" height="250"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Payoff Distribution</h4>
                        <canvas id="payoffCanvas" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Collective Action Outcome</h3>

                <div class="outcome-status outcome-partial" id="outcomeStatus">INSUFFICIENT</div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="round">0</div>
                        <div class="label">Round</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="participationRate">50.0</div>
                        <div class="label">Participation (%)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="publicGoodProvided">0.00</div>
                        <div class="label">Public Good Level</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="totalContributions">0</div>
                        <div class="label">Contributors</div>
                    </div>
                </div>

                <h3>Payoffs</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="avgContributorPayoff">0.00</div>
                        <div class="label">Contributor Payoff</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="avgFreeRiderPayoff">0.00</div>
                        <div class="label">Free-Rider Payoff</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="avgPayoff">0.00</div>
                        <div class="label">Average Payoff</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="socialWelfare">0.00</div>
                        <div class="label">Social Welfare</div>
                    </div>
                </div>

                <h3>Payoff Matrix</h3>
                <div class="payoff-matrix">
                    <table>
                        <tr>
                            <th></th>
                            <th>Others Contribute</th>
                            <th>Others Defect</th>
                        </tr>
                        <tr>
                            <th>Contribute</th>
                            <td id="payoffCC">-</td>
                            <td id="payoffCD">-</td>
                        </tr>
                        <tr>
                            <th>Defect</th>
                            <td id="payoffDC">-</td>
                            <td id="payoffDD">-</td>
                        </tr>
                    </table>
                </div>

                <h3>Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Contributor</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Free-Rider</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Entrepreneur</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Olson's Paradox:</strong><br>
                    Large groups are less likely to achieve collective action than small groups.
                    Free-riding incentives increase with group size while individual impact decreases.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const populationCanvas = document.getElementById('populationCanvas');
        const participationCanvas = document.getElementById('participationCanvas');
        const groupSizeCanvas = document.getElementById('groupSizeCanvas');
        const payoffCanvas = document.getElementById('payoffCanvas');

        const popCtx = populationCanvas.getContext('2d');
        const partCtx = participationCanvas.getContext('2d');
        const gsCtx = groupSizeCanvas.getContext('2d');
        const payCtx = payoffCanvas.getContext('2d');

        // Simulation state
        let agents = [];
        let round = 0;
        let isRunning = false;
        let animationId = null;
        let participationHistory = [];
        let groupSizeResults = [];
        let payoffHistory = [];

        // Parameters
        let groupSize = 50;
        let publicGoodValue = 2.0;
        let contributionCost = 1.0;
        let productionFunction = 'linear';
        let selectiveIncentive = 0;
        let punishment = 0;
        let numEntrepreneurs = 0;
        let initParticipation = 0.5;
        let learningRate = 0.1;
        let speed = 5;

        // UI Elements
        const elements = {
            groupSize: document.getElementById('groupSize'),
            groupSizeVal: document.getElementById('groupSizeVal'),
            publicGoodValue: document.getElementById('publicGoodValue'),
            publicGoodValueVal: document.getElementById('publicGoodValueVal'),
            contributionCost: document.getElementById('contributionCost'),
            contributionCostVal: document.getElementById('contributionCostVal'),
            productionFunction: document.getElementById('productionFunction'),
            selectiveIncentive: document.getElementById('selectiveIncentive'),
            selectiveIncentiveVal: document.getElementById('selectiveIncentiveVal'),
            punishment: document.getElementById('punishment'),
            punishmentVal: document.getElementById('punishmentVal'),
            entrepreneurs: document.getElementById('entrepreneurs'),
            entrepreneursVal: document.getElementById('entrepreneursVal'),
            initParticipation: document.getElementById('initParticipation'),
            initParticipationVal: document.getElementById('initParticipationVal'),
            learningRate: document.getElementById('learningRate'),
            learningRateVal: document.getElementById('learningRateVal'),
            speed: document.getElementById('speed'),
            speedVal: document.getElementById('speedVal'),
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            varyGroupBtn: document.getElementById('varyGroupBtn'),
            round: document.getElementById('round'),
            participationRate: document.getElementById('participationRate'),
            publicGoodProvided: document.getElementById('publicGoodProvided'),
            totalContributions: document.getElementById('totalContributions'),
            avgContributorPayoff: document.getElementById('avgContributorPayoff'),
            avgFreeRiderPayoff: document.getElementById('avgFreeRiderPayoff'),
            avgPayoff: document.getElementById('avgPayoff'),
            socialWelfare: document.getElementById('socialWelfare'),
            outcomeStatus: document.getElementById('outcomeStatus'),
            payoffCC: document.getElementById('payoffCC'),
            payoffCD: document.getElementById('payoffCD'),
            payoffDC: document.getElementById('payoffDC'),
            payoffDD: document.getElementById('payoffDD')
        };

        // Initialize simulation
        function initialize() {
            agents = [];
            round = 0;
            participationHistory = [];
            payoffHistory = [];

            const width = populationCanvas.width;
            const height = populationCanvas.height;

            // Create agents
            for (let i = 0; i < groupSize; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * Math.min(width, height) * 0.4;

                const isEntrepreneur = i < numEntrepreneurs;

                agents.push({
                    id: i,
                    x: width / 2 + radius * Math.cos(angle),
                    y: height / 2 + radius * Math.sin(angle),
                    contributes: isEntrepreneur || Math.random() < initParticipation,
                    isEntrepreneur: isEntrepreneur,
                    payoff: 0,
                    cumulativePayoff: 0,
                    propensity: initParticipation // Probability of contributing
                });
            }

            updatePayoffMatrix();
            calculatePayoffs();
            updateStats();
            draw();
        }

        // Calculate public good production based on function type
        function calculatePublicGood(numContributors) {
            const n = groupSize;
            const fraction = numContributors / n;

            switch (productionFunction) {
                case 'linear':
                    return publicGoodValue * fraction;

                case 'accelerating':
                    // Critical mass effect - accelerates after threshold
                    const threshold = 0.3;
                    if (fraction < threshold) {
                        return publicGoodValue * fraction * 0.5;
                    }
                    return publicGoodValue * (0.5 * threshold + (fraction - threshold) * 2);

                case 'decelerating':
                    // Diminishing returns
                    return publicGoodValue * Math.sqrt(fraction);

                case 'threshold':
                    // Step function - need majority
                    return fraction >= 0.5 ? publicGoodValue : 0;

                default:
                    return publicGoodValue * fraction;
            }
        }

        // Calculate individual payoffs
        function calculatePayoffs() {
            const contributors = agents.filter(a => a.contributes);
            const freeRiders = agents.filter(a => !a.contributes);
            const numContributors = contributors.length;

            const publicGood = calculatePublicGood(numContributors);

            // Contributors
            contributors.forEach(agent => {
                agent.payoff = publicGood - contributionCost;

                // Add selective incentive
                agent.payoff += selectiveIncentive;

                // Entrepreneurs get extra benefit from organization
                if (agent.isEntrepreneur) {
                    agent.payoff += 0.5;
                }

                agent.cumulativePayoff += agent.payoff;
            });

            // Free-riders
            freeRiders.forEach(agent => {
                agent.payoff = publicGood;

                // Punishment
                agent.payoff -= punishment;

                agent.cumulativePayoff += agent.payoff;
            });
        }

        // Update agent decisions (reinforcement learning)
        function updateDecisions() {
            agents.forEach(agent => {
                if (agent.isEntrepreneur) {
                    // Entrepreneurs always contribute
                    agent.contributes = true;
                    return;
                }

                // Aspiration-based learning
                const avgPayoff = agents.reduce((sum, a) => sum + a.payoff, 0) / agents.length;

                if (agent.payoff > avgPayoff) {
                    // Reinforce current behavior
                    if (agent.contributes) {
                        agent.propensity = Math.min(1, agent.propensity + learningRate);
                    } else {
                        agent.propensity = Math.max(0, agent.propensity - learningRate);
                    }
                } else {
                    // Explore alternative
                    if (agent.contributes) {
                        agent.propensity = Math.max(0, agent.propensity - learningRate);
                    } else {
                        agent.propensity = Math.min(1, agent.propensity + learningRate);
                    }
                }

                // Make decision based on propensity
                agent.contributes = Math.random() < agent.propensity;
            });
        }

        // Simulation step
        function step() {
            round++;

            calculatePayoffs();
            updateDecisions();

            // Record history
            const participation = agents.filter(a => a.contributes).length / groupSize;
            participationHistory.push(participation);

            const avgPayoff = agents.reduce((sum, a) => sum + a.payoff, 0) / agents.length;
            payoffHistory.push({ contributors: getAvgContributorPayoff(), freeRiders: getAvgFreeRiderPayoff() });

            if (participationHistory.length > 500) participationHistory.shift();
            if (payoffHistory.length > 500) payoffHistory.shift();
        }

        // Helper functions for stats
        function getAvgContributorPayoff() {
            const contributors = agents.filter(a => a.contributes);
            if (contributors.length === 0) return 0;
            return contributors.reduce((sum, a) => sum + a.payoff, 0) / contributors.length;
        }

        function getAvgFreeRiderPayoff() {
            const freeRiders = agents.filter(a => !a.contributes);
            if (freeRiders.length === 0) return 0;
            return freeRiders.reduce((sum, a) => sum + a.payoff, 0) / freeRiders.length;
        }

        // Update payoff matrix display
        function updatePayoffMatrix() {
            // Payoffs when most others contribute
            const highContrib = 0.8 * groupSize;
            const pgHigh = calculatePublicGood(highContrib);

            // Payoffs when few others contribute
            const lowContrib = 0.2 * groupSize;
            const pgLow = calculatePublicGood(lowContrib);

            elements.payoffCC.textContent = (pgHigh - contributionCost + selectiveIncentive).toFixed(2);
            elements.payoffCD.textContent = (pgLow - contributionCost + selectiveIncentive).toFixed(2);
            elements.payoffDC.textContent = (pgHigh - punishment).toFixed(2);
            elements.payoffDD.textContent = (pgLow - punishment).toFixed(2);
        }

        // Run group size analysis
        function runGroupSizeAnalysis() {
            groupSizeResults = [];

            const testSizes = [5, 10, 20, 50, 100, 200, 500];

            testSizes.forEach(size => {
                // Temporarily set group size
                const savedSize = groupSize;
                groupSize = size;

                // Initialize with this size
                agents = [];
                for (let i = 0; i < size; i++) {
                    agents.push({
                        contributes: Math.random() < 0.5,
                        isEntrepreneur: false,
                        payoff: 0,
                        propensity: 0.5
                    });
                }

                // Run for 100 steps
                for (let r = 0; r < 100; r++) {
                    calculatePayoffs();
                    updateDecisions();
                }

                const finalParticipation = agents.filter(a => a.contributes).length / size;
                groupSizeResults.push({ size, participation: finalParticipation });

                groupSize = savedSize;
            });

            // Reinitialize with current settings
            initialize();
            draw();
        }

        // Update statistics display
        function updateStats() {
            elements.round.textContent = round;

            const numContributors = agents.filter(a => a.contributes).length;
            const participation = (numContributors / groupSize * 100).toFixed(1);
            elements.participationRate.textContent = participation;

            const publicGood = calculatePublicGood(numContributors);
            elements.publicGoodProvided.textContent = publicGood.toFixed(2);

            elements.totalContributions.textContent = numContributors;

            elements.avgContributorPayoff.textContent = getAvgContributorPayoff().toFixed(2);
            elements.avgFreeRiderPayoff.textContent = getAvgFreeRiderPayoff().toFixed(2);

            const avgPayoff = agents.reduce((sum, a) => sum + a.payoff, 0) / agents.length;
            elements.avgPayoff.textContent = avgPayoff.toFixed(2);

            const socialWelfare = agents.reduce((sum, a) => sum + a.payoff, 0);
            elements.socialWelfare.textContent = socialWelfare.toFixed(2);

            // Update outcome status
            const participationPct = numContributors / groupSize;
            elements.outcomeStatus.className = 'outcome-status';

            if (participationPct >= 0.7 && publicGood > contributionCost) {
                elements.outcomeStatus.classList.add('outcome-success');
                elements.outcomeStatus.textContent = 'COLLECTIVE ACTION SUCCESS';
            } else if (participationPct <= 0.2) {
                elements.outcomeStatus.classList.add('outcome-failure');
                elements.outcomeStatus.textContent = 'FREE-RIDER COLLAPSE';
            } else {
                elements.outcomeStatus.classList.add('outcome-partial');
                elements.outcomeStatus.textContent = 'INSUFFICIENT PARTICIPATION';
            }
        }

        // Draw population
        function drawPopulation() {
            const width = populationCanvas.width;
            const height = populationCanvas.height;

            popCtx.clearRect(0, 0, width, height);
            popCtx.fillStyle = '#1a1a2e';
            popCtx.fillRect(0, 0, width, height);

            // Draw agents
            agents.forEach(agent => {
                let color;
                if (agent.isEntrepreneur) {
                    color = '#f39c12';
                } else if (agent.contributes) {
                    color = '#27ae60';
                } else {
                    color = '#e74c3c';
                }

                const radius = agent.isEntrepreneur ? 8 : 5;

                popCtx.fillStyle = color;
                popCtx.beginPath();
                popCtx.arc(agent.x, agent.y, radius, 0, Math.PI * 2);
                popCtx.fill();

                // Draw payoff indicator
                if (Math.abs(agent.payoff) > 0.1) {
                    popCtx.fillStyle = agent.payoff > 0 ? '#27ae60' : '#e74c3c';
                    popCtx.font = '10px sans-serif';
                    popCtx.textAlign = 'center';
                    popCtx.fillText(agent.payoff > 0 ? '+' : '-', agent.x, agent.y - 10);
                }
            });

            // Draw participation rate
            popCtx.fillStyle = '#fff';
            popCtx.font = 'bold 14px sans-serif';
            popCtx.textAlign = 'center';
            const rate = (agents.filter(a => a.contributes).length / groupSize * 100).toFixed(0);
            popCtx.fillText(`Participation: ${rate}%`, width / 2, 25);
        }

        // Draw participation history
        function drawParticipation() {
            const width = participationCanvas.width;
            const height = participationCanvas.height;
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            partCtx.clearRect(0, 0, width, height);
            partCtx.fillStyle = '#1a1a2e';
            partCtx.fillRect(0, 0, width, height);

            // Axes
            partCtx.strokeStyle = '#666';
            partCtx.lineWidth = 1;
            partCtx.beginPath();
            partCtx.moveTo(margin.left, margin.top);
            partCtx.lineTo(margin.left, height - margin.bottom);
            partCtx.lineTo(width - margin.right, height - margin.bottom);
            partCtx.stroke();

            // Labels
            partCtx.fillStyle = '#aaa';
            partCtx.font = '11px sans-serif';
            partCtx.textAlign = 'center';
            partCtx.fillText('Round', width / 2, height - 5);

            partCtx.save();
            partCtx.translate(12, height / 2);
            partCtx.rotate(-Math.PI / 2);
            partCtx.fillText('Participation Rate', 0, 0);
            partCtx.restore();

            if (participationHistory.length < 2) return;

            // Draw participation line
            partCtx.strokeStyle = '#27ae60';
            partCtx.lineWidth = 2;
            partCtx.beginPath();

            participationHistory.forEach((p, i) => {
                const x = margin.left + (i / participationHistory.length) * chartWidth;
                const y = margin.top + (1 - p) * chartHeight;

                if (i === 0) {
                    partCtx.moveTo(x, y);
                } else {
                    partCtx.lineTo(x, y);
                }
            });
            partCtx.stroke();

            // Draw threshold lines
            partCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            partCtx.setLineDash([5, 5]);

            // 50% line
            partCtx.beginPath();
            partCtx.moveTo(margin.left, margin.top + chartHeight * 0.5);
            partCtx.lineTo(width - margin.right, margin.top + chartHeight * 0.5);
            partCtx.stroke();

            partCtx.setLineDash([]);

            // Y-axis labels
            partCtx.fillStyle = '#aaa';
            partCtx.font = '10px sans-serif';
            partCtx.textAlign = 'right';

            for (let p = 0; p <= 1; p += 0.25) {
                const y = margin.top + (1 - p) * chartHeight;
                partCtx.fillText((p * 100).toFixed(0) + '%', margin.left - 5, y + 4);
            }
        }

        // Draw group size effect
        function drawGroupSizeEffect() {
            const width = groupSizeCanvas.width;
            const height = groupSizeCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            gsCtx.clearRect(0, 0, width, height);
            gsCtx.fillStyle = '#1a1a2e';
            gsCtx.fillRect(0, 0, width, height);

            // Axes
            gsCtx.strokeStyle = '#666';
            gsCtx.lineWidth = 1;
            gsCtx.beginPath();
            gsCtx.moveTo(margin.left, margin.top);
            gsCtx.lineTo(margin.left, height - margin.bottom);
            gsCtx.lineTo(width - margin.right, height - margin.bottom);
            gsCtx.stroke();

            // Labels
            gsCtx.fillStyle = '#aaa';
            gsCtx.font = '10px sans-serif';
            gsCtx.textAlign = 'center';
            gsCtx.fillText('Group Size (log scale)', width / 2, height - 5);

            gsCtx.save();
            gsCtx.translate(10, height / 2);
            gsCtx.rotate(-Math.PI / 2);
            gsCtx.fillText('Participation', 0, 0);
            gsCtx.restore();

            if (groupSizeResults.length < 2) {
                gsCtx.fillStyle = '#666';
                gsCtx.font = '12px sans-serif';
                gsCtx.textAlign = 'center';
                gsCtx.fillText('Click "Vary Group Size" to run analysis', width / 2, height / 2);
                return;
            }

            const maxSize = Math.max(...groupSizeResults.map(r => r.size));

            // Draw line and points
            gsCtx.strokeStyle = '#f39c12';
            gsCtx.lineWidth = 2;
            gsCtx.beginPath();

            groupSizeResults.forEach((result, i) => {
                const x = margin.left + (Math.log10(result.size) / Math.log10(maxSize)) * chartWidth;
                const y = margin.top + (1 - result.participation) * chartHeight;

                if (i === 0) {
                    gsCtx.moveTo(x, y);
                } else {
                    gsCtx.lineTo(x, y);
                }
            });
            gsCtx.stroke();

            // Draw points
            groupSizeResults.forEach(result => {
                const x = margin.left + (Math.log10(result.size) / Math.log10(maxSize)) * chartWidth;
                const y = margin.top + (1 - result.participation) * chartHeight;

                gsCtx.fillStyle = '#f39c12';
                gsCtx.beginPath();
                gsCtx.arc(x, y, 5, 0, Math.PI * 2);
                gsCtx.fill();

                // Label
                gsCtx.fillStyle = '#aaa';
                gsCtx.font = '9px sans-serif';
                gsCtx.textAlign = 'center';
                gsCtx.fillText(result.size, x, height - margin.bottom + 12);
            });

            // Olson's prediction (theoretical decline)
            gsCtx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            gsCtx.setLineDash([5, 5]);
            gsCtx.beginPath();

            for (let s = 5; s <= maxSize; s *= 1.5) {
                const x = margin.left + (Math.log10(s) / Math.log10(maxSize)) * chartWidth;
                // Theoretical: participation decreases with 1/N
                const theoreticalP = 1 / (1 + s * 0.02);
                const y = margin.top + (1 - theoreticalP) * chartHeight;

                if (s === 5) {
                    gsCtx.moveTo(x, y);
                } else {
                    gsCtx.lineTo(x, y);
                }
            }
            gsCtx.stroke();
            gsCtx.setLineDash([]);

            gsCtx.fillStyle = '#e74c3c';
            gsCtx.font = '9px sans-serif';
            gsCtx.textAlign = 'left';
            gsCtx.fillText('Olson\'s prediction', margin.left + 5, margin.top + 15);
        }

        // Draw payoff distribution
        function drawPayoffDistribution() {
            const width = payoffCanvas.width;
            const height = payoffCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            payCtx.clearRect(0, 0, width, height);
            payCtx.fillStyle = '#1a1a2e';
            payCtx.fillRect(0, 0, width, height);

            // Axes
            payCtx.strokeStyle = '#666';
            payCtx.lineWidth = 1;
            payCtx.beginPath();
            payCtx.moveTo(margin.left, margin.top);
            payCtx.lineTo(margin.left, height - margin.bottom);
            payCtx.lineTo(width - margin.right, height - margin.bottom);
            payCtx.stroke();

            // Labels
            payCtx.fillStyle = '#aaa';
            payCtx.font = '10px sans-serif';
            payCtx.textAlign = 'center';
            payCtx.fillText('Round', width / 2, height - 5);

            payCtx.save();
            payCtx.translate(10, height / 2);
            payCtx.rotate(-Math.PI / 2);
            payCtx.fillText('Payoff', 0, 0);
            payCtx.restore();

            if (payoffHistory.length < 2) return;

            const allPayoffs = payoffHistory.flatMap(p => [p.contributors, p.freeRiders]);
            const minPayoff = Math.min(...allPayoffs, 0);
            const maxPayoff = Math.max(...allPayoffs, 1);
            const range = maxPayoff - minPayoff || 1;

            // Draw contributor payoff line
            payCtx.strokeStyle = '#27ae60';
            payCtx.lineWidth = 2;
            payCtx.beginPath();

            payoffHistory.forEach((p, i) => {
                const x = margin.left + (i / payoffHistory.length) * chartWidth;
                const y = margin.top + (1 - (p.contributors - minPayoff) / range) * chartHeight;

                if (i === 0) {
                    payCtx.moveTo(x, y);
                } else {
                    payCtx.lineTo(x, y);
                }
            });
            payCtx.stroke();

            // Draw free-rider payoff line
            payCtx.strokeStyle = '#e74c3c';
            payCtx.beginPath();

            payoffHistory.forEach((p, i) => {
                const x = margin.left + (i / payoffHistory.length) * chartWidth;
                const y = margin.top + (1 - (p.freeRiders - minPayoff) / range) * chartHeight;

                if (i === 0) {
                    payCtx.moveTo(x, y);
                } else {
                    payCtx.lineTo(x, y);
                }
            });
            payCtx.stroke();

            // Draw zero line
            const zeroY = margin.top + (1 - (0 - minPayoff) / range) * chartHeight;
            if (zeroY >= margin.top && zeroY <= height - margin.bottom) {
                payCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                payCtx.setLineDash([5, 5]);
                payCtx.beginPath();
                payCtx.moveTo(margin.left, zeroY);
                payCtx.lineTo(width - margin.right, zeroY);
                payCtx.stroke();
                payCtx.setLineDash([]);
            }

            // Legend
            payCtx.fillStyle = '#27ae60';
            payCtx.font = '10px sans-serif';
            payCtx.textAlign = 'left';
            payCtx.fillText('Contributors', margin.left + 10, margin.top + 15);

            payCtx.fillStyle = '#e74c3c';
            payCtx.fillText('Free-Riders', margin.left + 90, margin.top + 15);
        }

        // Main draw function
        function draw() {
            drawPopulation();
            drawParticipation();
            drawGroupSizeEffect();
            drawPayoffDistribution();
            updateStats();
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;

            for (let i = 0; i < speed; i++) {
                step();
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        elements.groupSize.addEventListener('input', (e) => {
            groupSize = parseInt(e.target.value);
            elements.groupSizeVal.textContent = groupSize;
        });

        elements.publicGoodValue.addEventListener('input', (e) => {
            publicGoodValue = parseFloat(e.target.value);
            elements.publicGoodValueVal.textContent = publicGoodValue.toFixed(1);
            updatePayoffMatrix();
        });

        elements.contributionCost.addEventListener('input', (e) => {
            contributionCost = parseFloat(e.target.value);
            elements.contributionCostVal.textContent = contributionCost.toFixed(1);
            updatePayoffMatrix();
        });

        elements.productionFunction.addEventListener('change', (e) => {
            productionFunction = e.target.value;
            updatePayoffMatrix();
        });

        elements.selectiveIncentive.addEventListener('input', (e) => {
            selectiveIncentive = parseFloat(e.target.value);
            elements.selectiveIncentiveVal.textContent = selectiveIncentive.toFixed(1);
            updatePayoffMatrix();
        });

        elements.punishment.addEventListener('input', (e) => {
            punishment = parseFloat(e.target.value);
            elements.punishmentVal.textContent = punishment.toFixed(1);
            updatePayoffMatrix();
        });

        elements.entrepreneurs.addEventListener('input', (e) => {
            numEntrepreneurs = parseInt(e.target.value);
            elements.entrepreneursVal.textContent = numEntrepreneurs;
        });

        elements.initParticipation.addEventListener('input', (e) => {
            initParticipation = parseFloat(e.target.value);
            elements.initParticipationVal.textContent = (initParticipation * 100).toFixed(0);
        });

        elements.learningRate.addEventListener('input', (e) => {
            learningRate = parseFloat(e.target.value);
            elements.learningRateVal.textContent = learningRate.toFixed(2);
        });

        elements.speed.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            elements.speedVal.textContent = speed;
        });

        elements.startBtn.addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                elements.startBtn.textContent = 'Running...';
                animate();
            }
        });

        elements.pauseBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        });

        elements.resetBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            initialize();
        });

        elements.varyGroupBtn.addEventListener('click', runGroupSizeAnalysis);

        // Initialize
        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
