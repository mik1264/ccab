<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pollination Networks - Plant-Pollinator Mutualism & Nestedness</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--dark-moss);
            font-size: 0.95rem;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--moss);
            font-size: 0.8rem;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--dark-moss);
            background: white;
        }

        .value-display {
            text-align: right;
            font-size: 0.75rem;
            color: var(--terracotta);
            font-weight: 600;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .btn-full {
            grid-column: span 2;
        }

        .btn-event {
            background: var(--terracotta);
            color: white;
            grid-column: span 2;
            margin-top: 8px;
        }

        .btn-event:hover {
            background: #a55a1f;
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 16px;
        }

        .viz-panel {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .viz-panel h4 {
            color: var(--dark-moss);
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 280px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .stats-panel {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 12px;
            background: var(--cream);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--moss);
            margin-top: 4px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.7rem;
            color: var(--dark-moss);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .info-panel {
            grid-column: span 2;
            background: linear-gradient(135deg, var(--sage) 0%, var(--moss) 100%);
            color: white;
            padding: 16px;
            border-radius: 12px;
            margin-top: 12px;
        }

        .info-panel h4 {
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .info-panel p {
            font-size: 0.8rem;
            opacity: 0.95;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Simulations</a>

    <div class="container">
        <header>
            <h1>Pollination Networks</h1>
            <p class="subtitle">Plant-Pollinator Mutualism - Nestedness, Modularity & Robustness</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Network Parameters</h3>
                    <div class="control-group">
                        <label>Number of Plants</label>
                        <input type="range" id="numPlants" min="5" max="30" step="1" value="15">
                        <div class="value-display" id="numPlantsValue">15</div>
                    </div>
                    <div class="control-group">
                        <label>Number of Pollinators</label>
                        <input type="range" id="numPollinators" min="5" max="40" step="1" value="20">
                        <div class="value-display" id="numPollinatorsValue">20</div>
                    </div>
                    <div class="control-group">
                        <label>Connectance</label>
                        <input type="range" id="connectance" min="0.1" max="0.5" step="0.05" value="0.25">
                        <div class="value-display" id="connectanceValue">0.25</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Specialization</h3>
                    <div class="control-group">
                        <label>Pollinator Specialization</label>
                        <input type="range" id="pollinatorSpecialization" min="0" max="1" step="0.1" value="0.5">
                        <div class="value-display" id="pollinatorSpecializationValue">0.50</div>
                    </div>
                    <div class="control-group">
                        <label>Trait Matching Strength</label>
                        <input type="range" id="traitMatching" min="0" max="1" step="0.1" value="0.5">
                        <div class="value-display" id="traitMatchingValue">0.50</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Dynamics</h3>
                    <div class="control-group">
                        <label>Mutualistic Benefit</label>
                        <input type="range" id="mutualisticBenefit" min="0.1" max="1" step="0.1" value="0.5">
                        <div class="value-display" id="mutualisticBenefitValue">0.50</div>
                    </div>
                    <div class="control-group">
                        <label>Adaptive Rewiring</label>
                        <input type="range" id="rewiring" min="0" max="0.2" step="0.02" value="0.05">
                        <div class="value-display" id="rewiringValue">0.05</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Perturbation</h3>
                    <div class="control-group">
                        <label>Removal Target</label>
                        <select id="removalTarget">
                            <option value="random">Random Species</option>
                            <option value="mostConnected">Most Connected</option>
                            <option value="leastConnected">Least Connected</option>
                            <option value="generalist">Generalists First</option>
                            <option value="specialist">Specialists First</option>
                        </select>
                    </div>
                    <button class="btn-event" id="removeSpecies">Remove Species</button>
                    <button class="btn-event" id="runRobustness">Run Robustness Analysis</button>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="generateBtn">Generate Network</button>
                    <button class="btn-secondary" id="stepBtn">Step</button>
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50;"></div>
                        <span>Plants</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800;"></div>
                        <span>Pollinators</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(100,150,255,0.5);"></div>
                        <span>Interactions</span>
                    </div>
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h4>Bipartite Network</h4>
                    <div class="canvas-container">
                        <canvas id="networkCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Interaction Matrix (Nestedness)</h4>
                    <div class="canvas-container">
                        <canvas id="matrixCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Degree Distribution</h4>
                    <div class="canvas-container">
                        <canvas id="degreeCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Robustness Curve</h4>
                    <div class="canvas-container">
                        <canvas id="robustnessCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="plantCount">0</div>
                    <div class="stat-label">Plants</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="pollinatorCount">0</div>
                    <div class="stat-label">Pollinators</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="linkCount">0</div>
                    <div class="stat-label">Interactions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="actualConnectance">0</div>
                    <div class="stat-label">Connectance</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="nestedness">0</div>
                    <div class="stat-label">Nestedness (NODF)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="modularity">0</div>
                    <div class="stat-label">Modularity</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgDegree">0</div>
                    <div class="stat-label">Avg. Degree</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="r50">-</div>
                    <div class="stat-label">R50 Robustness</div>
                </div>
            </div>
            <div class="info-panel">
                <h4>Pollination Network Structure (Bascompte et al.)</h4>
                <p><strong>Nestedness:</strong> Specialists interact with proper subsets of generalists' partners - creates redundancy and robustness.
                <strong>Modularity:</strong> Groups of tightly interacting species - enhances stability but may reduce feasibility.
                <strong>Trait Matching:</strong> Phenological and morphological compatibility determines interaction probability.</p>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const networkCanvas = document.getElementById('networkCanvas');
        const matrixCanvas = document.getElementById('matrixCanvas');
        const degreeCanvas = document.getElementById('degreeCanvas');
        const robustnessCanvas = document.getElementById('robustnessCanvas');

        const nCtx = networkCanvas.getContext('2d');
        const mCtx = matrixCanvas.getContext('2d');
        const dCtx = degreeCanvas.getContext('2d');
        const rCtx = robustnessCanvas.getContext('2d');

        function resizeCanvas(canvas) {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        [networkCanvas, matrixCanvas, degreeCanvas, robustnessCanvas].forEach(resizeCanvas);
        window.addEventListener('resize', () => {
            [networkCanvas, matrixCanvas, degreeCanvas, robustnessCanvas].forEach(resizeCanvas);
        });

        // Model state
        let plants = [];
        let pollinators = [];
        let interactions = [];
        let params = {};
        let isRunning = false;
        let tick = 0;
        let robustnessData = [];

        function updateParams() {
            params = {
                numPlants: parseInt(document.getElementById('numPlants').value),
                numPollinators: parseInt(document.getElementById('numPollinators').value),
                connectance: parseFloat(document.getElementById('connectance').value),
                pollinatorSpecialization: parseFloat(document.getElementById('pollinatorSpecialization').value),
                traitMatching: parseFloat(document.getElementById('traitMatching').value),
                mutualisticBenefit: parseFloat(document.getElementById('mutualisticBenefit').value),
                rewiring: parseFloat(document.getElementById('rewiring').value),
                removalTarget: document.getElementById('removalTarget').value
            };
        }

        function generateNetwork() {
            plants = [];
            pollinators = [];
            interactions = [];
            robustnessData = [];
            tick = 0;

            // Create plants with traits
            for (let i = 0; i < params.numPlants; i++) {
                plants.push({
                    id: i,
                    type: 'plant',
                    trait: Math.random(), // Flowering phenology/morphology
                    abundance: 0.5 + Math.random() * 0.5,
                    alive: true,
                    x: 0, y: 0
                });
            }

            // Create pollinators with traits
            for (let i = 0; i < params.numPollinators; i++) {
                // Specialization affects trait range
                const traitCenter = Math.random();
                const traitRange = 1 - params.pollinatorSpecialization * 0.8;

                pollinators.push({
                    id: i,
                    type: 'pollinator',
                    traitCenter: traitCenter,
                    traitRange: traitRange,
                    abundance: 0.5 + Math.random() * 0.5,
                    alive: true,
                    x: 0, y: 0
                });
            }

            // Generate interactions based on trait matching
            const targetLinks = Math.floor(params.connectance * params.numPlants * params.numPollinators);

            // Sort plants and pollinators by trait/abundance for nested structure
            plants.sort((a, b) => b.abundance - a.abundance);
            pollinators.sort((a, b) => b.traitRange - a.traitRange); // Generalists first

            // Create interaction matrix with nested structure tendency
            for (let p = 0; p < plants.length; p++) {
                for (let q = 0; q < pollinators.length; q++) {
                    const plant = plants[p];
                    const poll = pollinators[q];

                    // Trait matching probability
                    const traitDiff = Math.abs(plant.trait - poll.traitCenter);
                    const traitMatch = traitDiff < poll.traitRange ? 1 - traitDiff / poll.traitRange : 0;

                    // Nestedness bias (generalists interact with more plants)
                    const nestednessBias = (1 - p / plants.length) * poll.traitRange;

                    // Random component
                    const random = Math.random();

                    // Combined probability
                    const prob = params.traitMatching * traitMatch +
                                (1 - params.traitMatching) * (nestednessBias * 0.5 + random * 0.5);

                    if (prob > (1 - params.connectance) && interactions.length < targetLinks * 1.5) {
                        const strength = 0.5 + Math.random() * 0.5;
                        interactions.push({
                            plant: p,
                            pollinator: q,
                            strength: strength,
                            alive: true
                        });
                    }
                }
            }

            // Position nodes for visualization
            positionNodes();
            updateDegrees();
        }

        function positionNodes() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            const margin = 50;

            // Plants on bottom
            plants.forEach((p, i) => {
                p.x = margin + (i / (plants.length - 1 || 1)) * (width - 2 * margin);
                p.y = height - margin;
            });

            // Pollinators on top
            pollinators.forEach((p, i) => {
                p.x = margin + (i / (pollinators.length - 1 || 1)) * (width - 2 * margin);
                p.y = margin;
            });
        }

        function updateDegrees() {
            plants.forEach(p => p.degree = 0);
            pollinators.forEach(p => p.degree = 0);

            interactions.filter(i => i.alive).forEach(int => {
                if (plants[int.plant].alive) plants[int.plant].degree++;
                if (pollinators[int.pollinator].alive) pollinators[int.pollinator].degree++;
            });
        }

        function calculateNestedness() {
            // NODF (Nestedness metric based on Overlap and Decreasing Fill)
            const alivePlants = plants.filter(p => p.alive);
            const alivePolls = pollinators.filter(p => p.alive);
            const aliveInts = interactions.filter(i => i.alive);

            if (alivePlants.length < 2 || alivePolls.length < 2) return 0;

            // Build interaction matrix
            const matrix = [];
            alivePlants.forEach((plant, pi) => {
                matrix[pi] = [];
                alivePolls.forEach((poll, qi) => {
                    const hasInt = aliveInts.some(int =>
                        plants[int.plant] === plant && pollinators[int.pollinator] === poll
                    );
                    matrix[pi][qi] = hasInt ? 1 : 0;
                });
            });

            // Calculate row and column sums
            const rowSums = matrix.map(row => row.reduce((a, b) => a + b, 0));
            const colSums = matrix[0].map((_, j) => matrix.reduce((sum, row) => sum + row[j], 0));

            // Sort by decreasing fill
            const rowOrder = rowSums.map((s, i) => ({ i, s })).sort((a, b) => b.s - a.s).map(x => x.i);
            const colOrder = colSums.map((s, j) => ({ j, s })).sort((a, b) => b.s - a.s).map(x => x.j);

            // Calculate NODF
            let nodfRow = 0, nodfCol = 0;
            let pairsRow = 0, pairsCol = 0;

            for (let i = 0; i < rowOrder.length; i++) {
                for (let j = i + 1; j < rowOrder.length; j++) {
                    const ri = rowOrder[i];
                    const rj = rowOrder[j];
                    if (rowSums[ri] > rowSums[rj]) {
                        let overlap = 0;
                        for (let k = 0; k < colOrder.length; k++) {
                            if (matrix[ri][k] === 1 && matrix[rj][k] === 1) overlap++;
                        }
                        nodfRow += overlap / rowSums[rj];
                        pairsRow++;
                    }
                }
            }

            for (let i = 0; i < colOrder.length; i++) {
                for (let j = i + 1; j < colOrder.length; j++) {
                    const ci = colOrder[i];
                    const cj = colOrder[j];
                    if (colSums[ci] > colSums[cj]) {
                        let overlap = 0;
                        for (let k = 0; k < rowOrder.length; k++) {
                            if (matrix[k][ci] === 1 && matrix[k][cj] === 1) overlap++;
                        }
                        nodfCol += overlap / colSums[cj];
                        pairsCol++;
                    }
                }
            }

            const nodf = ((pairsRow > 0 ? nodfRow / pairsRow : 0) +
                         (pairsCol > 0 ? nodfCol / pairsCol : 0)) / 2;

            return nodf * 100;
        }

        function calculateModularity() {
            // Simplified modularity estimation
            const alivePlants = plants.filter(p => p.alive);
            const alivePolls = pollinators.filter(p => p.alive);
            const aliveInts = interactions.filter(i => i.alive);

            if (aliveInts.length < 4) return 0;

            // Simple clustering by trait similarity
            const numModules = Math.min(4, Math.floor(Math.sqrt(alivePlants.length)));
            const traitStep = 1 / numModules;

            let withinModule = 0;
            let totalLinks = aliveInts.length;

            aliveInts.forEach(int => {
                const plant = plants[int.plant];
                const poll = pollinators[int.pollinator];
                const plantModule = Math.floor(plant.trait / traitStep);
                const pollModule = Math.floor(poll.traitCenter / traitStep);
                if (plantModule === pollModule) withinModule++;
            });

            return (withinModule / totalLinks - 1 / numModules) * numModules / (numModules - 1);
        }

        function update() {
            tick++;

            // Population dynamics
            plants.filter(p => p.alive).forEach(plant => {
                const ints = interactions.filter(i => i.alive && i.plant === plant.id);
                const benefit = ints.reduce((sum, int) => {
                    const poll = pollinators[int.pollinator];
                    return poll.alive ? sum + int.strength * poll.abundance * params.mutualisticBenefit : sum;
                }, 0);

                plant.abundance = Math.max(0.1, Math.min(1, plant.abundance + benefit * 0.01 - 0.005));
            });

            pollinators.filter(p => p.alive).forEach(poll => {
                const ints = interactions.filter(i => i.alive && i.pollinator === poll.id);
                const benefit = ints.reduce((sum, int) => {
                    const plant = plants[int.plant];
                    return plant.alive ? sum + int.strength * plant.abundance * params.mutualisticBenefit : sum;
                }, 0);

                poll.abundance = Math.max(0.1, Math.min(1, poll.abundance + benefit * 0.01 - 0.005));
            });

            // Adaptive rewiring
            if (Math.random() < params.rewiring) {
                // Find weak interaction
                const weakInts = interactions.filter(i => i.alive && i.strength < 0.3);
                if (weakInts.length > 0) {
                    const toRemove = weakInts[Math.floor(Math.random() * weakInts.length)];

                    // Try to rewire to better partner
                    const poll = pollinators[toRemove.pollinator];
                    if (poll.alive) {
                        const availablePlants = plants.filter(p =>
                            p.alive && !interactions.some(i =>
                                i.alive && i.plant === p.id && i.pollinator === toRemove.pollinator
                            )
                        );

                        if (availablePlants.length > 0) {
                            // Choose plant with matching trait
                            const bestPlant = availablePlants.reduce((best, p) => {
                                const match = 1 - Math.abs(p.trait - poll.traitCenter) / poll.traitRange;
                                return match > best.match ? { plant: p, match } : best;
                            }, { plant: null, match: -1 });

                            if (bestPlant.plant && bestPlant.match > 0.5) {
                                toRemove.alive = false;
                                interactions.push({
                                    plant: bestPlant.plant.id,
                                    pollinator: poll.id,
                                    strength: 0.5 + Math.random() * 0.5,
                                    alive: true
                                });
                            }
                        }
                    }
                }
            }

            updateDegrees();
        }

        function removeSpecies() {
            const target = params.removalTarget;
            let candidates;

            if (target === 'random') {
                candidates = [...plants.filter(p => p.alive), ...pollinators.filter(p => p.alive)];
            } else if (target === 'mostConnected') {
                candidates = [...plants.filter(p => p.alive), ...pollinators.filter(p => p.alive)]
                    .sort((a, b) => b.degree - a.degree);
            } else if (target === 'leastConnected') {
                candidates = [...plants.filter(p => p.alive), ...pollinators.filter(p => p.alive)]
                    .sort((a, b) => a.degree - b.degree);
            } else if (target === 'generalist') {
                candidates = pollinators.filter(p => p.alive).sort((a, b) => b.traitRange - a.traitRange);
            } else if (target === 'specialist') {
                candidates = pollinators.filter(p => p.alive).sort((a, b) => a.traitRange - b.traitRange);
            }

            if (candidates.length > 0) {
                const toRemove = target === 'random' ?
                    candidates[Math.floor(Math.random() * candidates.length)] :
                    candidates[0];

                toRemove.alive = false;

                // Remove interactions
                interactions.forEach(int => {
                    if (toRemove.type === 'plant' && int.plant === toRemove.id) {
                        int.alive = false;
                    }
                    if (toRemove.type === 'pollinator' && int.pollinator === toRemove.id) {
                        int.alive = false;
                    }
                });

                // Trigger secondary extinctions
                let changed = true;
                while (changed) {
                    changed = false;

                    plants.filter(p => p.alive).forEach(plant => {
                        const hasPartner = interactions.some(i =>
                            i.alive && i.plant === plant.id && pollinators[i.pollinator].alive
                        );
                        if (!hasPartner) {
                            plant.alive = false;
                            interactions.forEach(int => {
                                if (int.plant === plant.id) int.alive = false;
                            });
                            changed = true;
                        }
                    });

                    pollinators.filter(p => p.alive).forEach(poll => {
                        const hasPartner = interactions.some(i =>
                            i.alive && i.pollinator === poll.id && plants[i.plant].alive
                        );
                        if (!hasPartner) {
                            poll.alive = false;
                            interactions.forEach(int => {
                                if (int.pollinator === poll.id) int.alive = false;
                            });
                            changed = true;
                        }
                    });
                }

                updateDegrees();
            }
        }

        function runRobustnessAnalysis() {
            generateNetwork();
            robustnessData = [];

            const initialTotal = plants.length + pollinators.length;
            let removals = 0;

            while (plants.some(p => p.alive) || pollinators.some(p => p.alive)) {
                const surviving = plants.filter(p => p.alive).length + pollinators.filter(p => p.alive).length;
                robustnessData.push({
                    removals: removals,
                    surviving: surviving / initialTotal
                });

                removeSpecies();
                removals++;

                if (removals > initialTotal) break;
            }

            robustnessData.push({
                removals: removals,
                surviving: 0
            });

            // Calculate R50
            const r50 = robustnessData.find(d => d.surviving <= 0.5);
            if (r50) {
                document.getElementById('r50').textContent = (r50.removals / initialTotal).toFixed(2);
            }

            draw();
        }

        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            nCtx.fillStyle = '#1a1a1a';
            nCtx.fillRect(0, 0, width, height);

            // Draw interactions
            interactions.filter(i => i.alive).forEach(int => {
                const plant = plants[int.plant];
                const poll = pollinators[int.pollinator];
                if (!plant.alive || !poll.alive) return;

                nCtx.strokeStyle = `rgba(100, 150, 255, ${int.strength * 0.5})`;
                nCtx.lineWidth = int.strength * 2;
                nCtx.beginPath();
                nCtx.moveTo(plant.x, plant.y);
                nCtx.lineTo(poll.x, poll.y);
                nCtx.stroke();
            });

            // Draw plants
            plants.forEach(plant => {
                const radius = 5 + plant.degree * 1.5;
                nCtx.beginPath();
                nCtx.arc(plant.x, plant.y, radius, 0, Math.PI * 2);
                nCtx.fillStyle = plant.alive ? '#4CAF50' : '#333';
                nCtx.fill();
                nCtx.strokeStyle = '#fff';
                nCtx.lineWidth = 1;
                nCtx.stroke();
            });

            // Draw pollinators
            pollinators.forEach(poll => {
                const radius = 4 + poll.degree * 1.2;
                nCtx.beginPath();
                nCtx.arc(poll.x, poll.y, radius, 0, Math.PI * 2);
                nCtx.fillStyle = poll.alive ? '#FF9800' : '#333';
                nCtx.fill();
                nCtx.strokeStyle = '#fff';
                nCtx.lineWidth = 1;
                nCtx.stroke();
            });

            // Labels
            nCtx.fillStyle = '#aaa';
            nCtx.font = '11px sans-serif';
            nCtx.textAlign = 'left';
            nCtx.fillText('Pollinators', 10, 25);
            nCtx.fillText('Plants', 10, height - 10);
        }

        function drawMatrix() {
            const width = matrixCanvas.width;
            const height = matrixCanvas.height;

            mCtx.fillStyle = '#1a1a1a';
            mCtx.fillRect(0, 0, width, height);

            const margin = { top: 30, right: 20, bottom: 20, left: 40 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const alivePlants = plants.filter(p => p.alive).sort((a, b) => b.degree - a.degree);
            const alivePolls = pollinators.filter(p => p.alive).sort((a, b) => b.degree - a.degree);

            if (alivePlants.length === 0 || alivePolls.length === 0) return;

            const cellWidth = plotWidth / alivePolls.length;
            const cellHeight = plotHeight / alivePlants.length;

            alivePlants.forEach((plant, pi) => {
                alivePolls.forEach((poll, qi) => {
                    const hasInt = interactions.some(int =>
                        int.alive && int.plant === plant.id && int.pollinator === poll.id
                    );

                    const x = margin.left + qi * cellWidth;
                    const y = margin.top + pi * cellHeight;

                    mCtx.fillStyle = hasInt ? '#4a90d9' : '#222';
                    mCtx.fillRect(x, y, cellWidth - 1, cellHeight - 1);
                });
            });

            // Labels
            mCtx.fillStyle = '#aaa';
            mCtx.font = '10px sans-serif';
            mCtx.textAlign = 'center';
            mCtx.fillText('Pollinators →', margin.left + plotWidth / 2, 15);

            mCtx.save();
            mCtx.translate(12, margin.top + plotHeight / 2);
            mCtx.rotate(-Math.PI / 2);
            mCtx.fillText('Plants →', 0, 0);
            mCtx.restore();
        }

        function drawDegree() {
            const width = degreeCanvas.width;
            const height = degreeCanvas.height;

            dCtx.fillStyle = '#1a1a1a';
            dCtx.fillRect(0, 0, width, height);

            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Calculate degree distributions
            const plantDegrees = {};
            const pollDegrees = {};

            plants.filter(p => p.alive).forEach(p => {
                plantDegrees[p.degree] = (plantDegrees[p.degree] || 0) + 1;
            });

            pollinators.filter(p => p.alive).forEach(p => {
                pollDegrees[p.degree] = (pollDegrees[p.degree] || 0) + 1;
            });

            const maxDegree = Math.max(
                ...Object.keys(plantDegrees).map(Number),
                ...Object.keys(pollDegrees).map(Number),
                1
            );
            const maxCount = Math.max(
                ...Object.values(plantDegrees),
                ...Object.values(pollDegrees),
                1
            );

            const barWidth = plotWidth / (maxDegree + 1) / 2 - 2;

            // Draw plant degrees
            Object.entries(plantDegrees).forEach(([deg, count]) => {
                const x = margin.left + (parseInt(deg) / (maxDegree + 1)) * plotWidth;
                const barHeight = (count / maxCount) * plotHeight;
                const y = margin.top + plotHeight - barHeight;

                dCtx.fillStyle = '#4CAF50';
                dCtx.fillRect(x, y, barWidth, barHeight);
            });

            // Draw pollinator degrees
            Object.entries(pollDegrees).forEach(([deg, count]) => {
                const x = margin.left + (parseInt(deg) / (maxDegree + 1)) * plotWidth + barWidth + 2;
                const barHeight = (count / maxCount) * plotHeight;
                const y = margin.top + plotHeight - barHeight;

                dCtx.fillStyle = '#FF9800';
                dCtx.fillRect(x, y, barWidth, barHeight);
            });

            // Axes
            dCtx.strokeStyle = '#666';
            dCtx.lineWidth = 1;
            dCtx.beginPath();
            dCtx.moveTo(margin.left, margin.top);
            dCtx.lineTo(margin.left, margin.top + plotHeight);
            dCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            dCtx.stroke();

            // Labels
            dCtx.fillStyle = '#aaa';
            dCtx.font = '10px sans-serif';
            dCtx.textAlign = 'center';
            dCtx.fillText('Degree', width / 2, height - 5);

            dCtx.fillStyle = '#fff';
            dCtx.font = 'bold 12px sans-serif';
            dCtx.fillText('Degree Distribution', width / 2, 18);
        }

        function drawRobustness() {
            const width = robustnessCanvas.width;
            const height = robustnessCanvas.height;

            rCtx.fillStyle = '#1a1a1a';
            rCtx.fillRect(0, 0, width, height);

            if (robustnessData.length < 2) {
                rCtx.fillStyle = '#666';
                rCtx.font = '12px sans-serif';
                rCtx.textAlign = 'center';
                rCtx.fillText('Click "Run Robustness Analysis"', width / 2, height / 2);
                return;
            }

            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const maxRemovals = robustnessData[robustnessData.length - 1].removals;
            const xScale = plotWidth / maxRemovals;

            // Draw curve
            rCtx.strokeStyle = '#e74c3c';
            rCtx.lineWidth = 2;
            rCtx.beginPath();

            robustnessData.forEach((d, i) => {
                const x = margin.left + d.removals * xScale;
                const y = margin.top + plotHeight - d.surviving * plotHeight;
                if (i === 0) rCtx.moveTo(x, y);
                else rCtx.lineTo(x, y);
            });

            rCtx.stroke();

            // 50% line
            const halfY = margin.top + plotHeight * 0.5;
            rCtx.strokeStyle = 'rgba(100, 200, 100, 0.5)';
            rCtx.setLineDash([5, 5]);
            rCtx.beginPath();
            rCtx.moveTo(margin.left, halfY);
            rCtx.lineTo(margin.left + plotWidth, halfY);
            rCtx.stroke();
            rCtx.setLineDash([]);

            // Axes
            rCtx.strokeStyle = '#666';
            rCtx.lineWidth = 1;
            rCtx.beginPath();
            rCtx.moveTo(margin.left, margin.top);
            rCtx.lineTo(margin.left, margin.top + plotHeight);
            rCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            rCtx.stroke();

            rCtx.fillStyle = '#aaa';
            rCtx.font = '10px sans-serif';
            rCtx.textAlign = 'center';
            rCtx.fillText('Species Removed', width / 2, height - 5);

            rCtx.fillStyle = '#fff';
            rCtx.font = 'bold 12px sans-serif';
            rCtx.fillText('Network Robustness', width / 2, 18);
        }

        function updateStats() {
            const alivePlants = plants.filter(p => p.alive);
            const alivePolls = pollinators.filter(p => p.alive);
            const aliveInts = interactions.filter(i => i.alive);

            document.getElementById('plantCount').textContent = alivePlants.length;
            document.getElementById('pollinatorCount').textContent = alivePolls.length;
            document.getElementById('linkCount').textContent = aliveInts.length;

            const C = (alivePlants.length * alivePolls.length) > 0 ?
                aliveInts.length / (alivePlants.length * alivePolls.length) : 0;
            document.getElementById('actualConnectance').textContent = C.toFixed(3);

            const avgDegree = (alivePlants.length + alivePolls.length) > 0 ?
                (alivePlants.reduce((s, p) => s + p.degree, 0) +
                 alivePolls.reduce((s, p) => s + p.degree, 0)) /
                (alivePlants.length + alivePolls.length) : 0;
            document.getElementById('avgDegree').textContent = avgDegree.toFixed(2);

            document.getElementById('nestedness').textContent = calculateNestedness().toFixed(1);
            document.getElementById('modularity').textContent = calculateModularity().toFixed(3);
        }

        function draw() {
            drawNetwork();
            drawMatrix();
            drawDegree();
            drawRobustness();
            updateStats();
        }

        function animate() {
            if (!isRunning) return;

            update();
            draw();

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', () => {
            updateParams();
            generateNetwork();
            draw();
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = true;
            animate();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            update();
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            updateParams();
            generateNetwork();
            draw();
        });

        document.getElementById('removeSpecies').addEventListener('click', () => {
            removeSpecies();
            draw();
        });

        document.getElementById('runRobustness').addEventListener('click', () => {
            updateParams();
            runRobustnessAnalysis();
        });

        // Sliders
        const sliders = ['numPlants', 'numPollinators', 'connectance', 'pollinatorSpecialization',
                        'traitMatching', 'mutualisticBenefit', 'rewiring'];
        sliders.forEach(id => {
            const slider = document.getElementById(id);
            const display = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                let value = parseFloat(slider.value);
                if (id === 'numPlants' || id === 'numPollinators') {
                    display.textContent = value;
                } else {
                    display.textContent = value.toFixed(2);
                }
                updateParams();
            });
        });

        document.getElementById('removalTarget').addEventListener('change', updateParams);

        // Initialize
        updateParams();
        generateNetwork();
        draw();
    </script>
</body>
</html>
