<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Learning - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            color: var(--dark-moss);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Social Learning</h1>
            <p class="subtitle">Cultural Transmission, Conformist Bias, and Prestige Bias</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Population Size</label>
                    <input type="range" id="population" min="50" max="200" value="100">
                    <div class="value-display" id="populationVal">100</div>
                </div>

                <div class="control-group">
                    <label>Number of Traits</label>
                    <input type="range" id="numTraits" min="2" max="10" value="5">
                    <div class="value-display" id="numTraitsVal">5</div>
                </div>

                <div class="control-group">
                    <label>Individual Learning Cost</label>
                    <input type="range" id="indivCost" min="1" max="50" value="20">
                    <div class="value-display" id="indivCostVal">20</div>
                </div>

                <div class="control-group">
                    <label>Individual Learning Accuracy</label>
                    <input type="range" id="indivAccuracy" min="20" max="100" value="70">
                    <div class="value-display" id="indivAccuracyVal">70%</div>
                </div>

                <div class="control-group">
                    <label>Conformist Bias Strength</label>
                    <input type="range" id="conformistBias" min="0" max="100" value="50">
                    <div class="value-display" id="conformistBiasVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Prestige Bias Strength</label>
                    <input type="range" id="prestigeBias" min="0" max="100" value="30">
                    <div class="value-display" id="prestigeBiasVal">30%</div>
                </div>

                <div class="control-group">
                    <label>Environmental Change Rate</label>
                    <input type="range" id="envChange" min="0" max="50" value="5">
                    <div class="value-display" id="envChangeVal">5%</div>
                </div>

                <div class="control-group">
                    <label>Dominant Strategy</label>
                    <select id="strategyMode">
                        <option value="mixed">Mixed (Evolution)</option>
                        <option value="individual">Individual Only</option>
                        <option value="social">Social Only</option>
                        <option value="conformist">Conformist Only</option>
                        <option value="prestige">Prestige Only</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="avgFitness">0</div>
                        <div class="stat-label">Avg Fitness</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="optimalTraits">0%</div>
                        <div class="stat-label">Optimal Traits</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="culturalDiversity">0</div>
                        <div class="stat-label">Diversity</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="genNumber">0</div>
                        <div class="stat-label">Generation</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Learning Trade-offs:</strong> Individual learning is costly but accurate.
                    Social learning is cheap but may spread outdated info. Conformist bias
                    homogenizes groups. Prestige bias enables cumulative culture.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Population & Traits</h3>
                    <canvas id="arenaCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Strategy Distribution</h3>
                    <canvas id="strategyCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Trait Frequencies</h3>
                    <canvas id="traitCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Fitness & Cultural Evolution</h3>
                    <canvas id="evolutionCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const strategyCanvas = document.getElementById('strategyCanvas');
        const traitCanvas = document.getElementById('traitCanvas');
        const evolutionCanvas = document.getElementById('evolutionCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const strategyCtx = strategyCanvas.getContext('2d');
        const traitCtx = traitCanvas.getContext('2d');
        const evolutionCtx = evolutionCanvas.getContext('2d');

        function resizeCanvases() {
            [arenaCanvas, strategyCanvas, traitCanvas, evolutionCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let generation = 0;
        let agents = [];
        let optimalTraits = [];
        let history = [];
        let strategyHistory = [];

        // Learning strategies
        const INDIVIDUAL = 'individual';
        const UNBIASED_SOCIAL = 'unbiased_social';
        const CONFORMIST = 'conformist';
        const PRESTIGE = 'prestige';

        class Agent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const numTraits = parseInt(document.getElementById('numTraits').value);
                this.traits = [];
                for (let i = 0; i < numTraits; i++) {
                    this.traits.push(Math.floor(Math.random() * 3)); // 0, 1, or 2
                }
                this.fitness = 0;
                this.prestige = Math.random() * 50;
                this.learningStrategy = this.randomStrategy();
                this.age = 0;
            }

            randomStrategy() {
                const strategies = [INDIVIDUAL, UNBIASED_SOCIAL, CONFORMIST, PRESTIGE];
                return strategies[Math.floor(Math.random() * strategies.length)];
            }

            calculateFitness(optimalTraits) {
                let matches = 0;
                for (let i = 0; i < this.traits.length; i++) {
                    if (this.traits[i] === optimalTraits[i]) {
                        matches++;
                    }
                }
                return (matches / this.traits.length) * 100;
            }

            learn(agents, optimalTraits, params) {
                const mode = params.strategyMode;
                let strategy = this.learningStrategy;

                // Override strategy if mode is set
                if (mode !== 'mixed') {
                    if (mode === 'individual') strategy = INDIVIDUAL;
                    else if (mode === 'social') strategy = UNBIASED_SOCIAL;
                    else if (mode === 'conformist') strategy = CONFORMIST;
                    else if (mode === 'prestige') strategy = PRESTIGE;
                }

                const traitIndex = Math.floor(Math.random() * this.traits.length);

                switch (strategy) {
                    case INDIVIDUAL:
                        this.individualLearn(traitIndex, optimalTraits, params);
                        break;
                    case UNBIASED_SOCIAL:
                        this.unbiasedSocialLearn(traitIndex, agents);
                        break;
                    case CONFORMIST:
                        this.conformistLearn(traitIndex, agents, params);
                        break;
                    case PRESTIGE:
                        this.prestigeLearn(traitIndex, agents, params);
                        break;
                }
            }

            individualLearn(traitIndex, optimalTraits, params) {
                // Costly but accurate
                this.fitness -= params.indivCost / 10;

                // Probability of finding optimal trait
                if (Math.random() < params.indivAccuracy / 100) {
                    this.traits[traitIndex] = optimalTraits[traitIndex];
                } else {
                    // Error - random trait
                    this.traits[traitIndex] = Math.floor(Math.random() * 3);
                }
            }

            unbiasedSocialLearn(traitIndex, agents) {
                // Copy random individual (cheap)
                const model = agents[Math.floor(Math.random() * agents.length)];
                this.traits[traitIndex] = model.traits[traitIndex];
            }

            conformistLearn(traitIndex, agents, params) {
                // Sample several individuals, copy most common trait
                const sampleSize = Math.min(5, agents.length);
                const sample = [];

                for (let i = 0; i < sampleSize; i++) {
                    sample.push(agents[Math.floor(Math.random() * agents.length)]);
                }

                // Count trait frequencies
                const counts = [0, 0, 0];
                sample.forEach(a => {
                    counts[a.traits[traitIndex]]++;
                });

                // Find most common
                let maxCount = 0;
                let mostCommon = 0;
                counts.forEach((c, i) => {
                    if (c > maxCount) {
                        maxCount = c;
                        mostCommon = i;
                    }
                });

                // Conformist bias: disproportionately copy common trait
                const conformity = params.conformistBias / 100;
                const frequency = maxCount / sampleSize;

                // If 60% have it and conformity is strong, probability becomes higher
                const copyProb = frequency + (1 - frequency) * conformity * (frequency - 0.33);

                if (Math.random() < Math.max(frequency, copyProb)) {
                    this.traits[traitIndex] = mostCommon;
                } else {
                    // Copy random from sample
                    this.traits[traitIndex] = sample[0].traits[traitIndex];
                }
            }

            prestigeLearn(traitIndex, agents, params) {
                // Copy from high-prestige individual
                const prestigeBias = params.prestigeBias / 100;

                // Sort by prestige
                const sorted = [...agents].sort((a, b) => b.prestige - a.prestige);

                // Top individuals more likely to be copied
                let model;
                if (Math.random() < prestigeBias) {
                    // Copy from top 10%
                    const topN = Math.max(1, Math.floor(agents.length * 0.1));
                    model = sorted[Math.floor(Math.random() * topN)];
                } else {
                    // Random
                    model = agents[Math.floor(Math.random() * agents.length)];
                }

                this.traits[traitIndex] = model.traits[traitIndex];
            }

            updatePrestige() {
                // Prestige based on fitness and success
                this.prestige = this.prestige * 0.9 + this.fitness * 0.1;
            }
        }

        function initSimulation() {
            const population = parseInt(document.getElementById('population').value);
            const numTraits = parseInt(document.getElementById('numTraits').value);

            agents = [];
            history = [];
            strategyHistory = [];
            tick = 0;
            generation = 0;

            // Initialize optimal traits
            optimalTraits = [];
            for (let i = 0; i < numTraits; i++) {
                optimalTraits.push(Math.floor(Math.random() * 3));
            }

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Create agents
            for (let i = 0; i < population; i++) {
                agents.push(new Agent(
                    Math.random() * w,
                    Math.random() * h
                ));
            }
        }

        function getParams() {
            return {
                numTraits: parseInt(document.getElementById('numTraits').value),
                indivCost: parseInt(document.getElementById('indivCost').value),
                indivAccuracy: parseInt(document.getElementById('indivAccuracy').value),
                conformistBias: parseInt(document.getElementById('conformistBias').value),
                prestigeBias: parseInt(document.getElementById('prestigeBias').value),
                envChange: parseInt(document.getElementById('envChange').value),
                strategyMode: document.getElementById('strategyMode').value
            };
        }

        function simulationStep() {
            const params = getParams();
            tick++;

            // Environmental change
            if (Math.random() < params.envChange / 1000) {
                const traitIndex = Math.floor(Math.random() * optimalTraits.length);
                optimalTraits[traitIndex] = Math.floor(Math.random() * 3);
            }

            // Learning phase
            agents.forEach(agent => {
                if (Math.random() < 0.3) {
                    agent.learn(agents, optimalTraits, params);
                }
            });

            // Update fitness and prestige
            agents.forEach(agent => {
                agent.fitness = agent.calculateFitness(optimalTraits);
                agent.updatePrestige();
                agent.age++;
            });

            // Reproduction based on fitness
            if (tick % 50 === 0) {
                generation++;
                reproduce(params);
            }

            // Record history
            if (tick % 5 === 0) {
                const avgFitness = agents.reduce((s, a) => s + a.fitness, 0) / agents.length;

                // Count strategies
                const strategies = {
                    [INDIVIDUAL]: 0,
                    [UNBIASED_SOCIAL]: 0,
                    [CONFORMIST]: 0,
                    [PRESTIGE]: 0
                };
                agents.forEach(a => strategies[a.learningStrategy]++);

                // Calculate cultural diversity (Shannon entropy)
                const traitFreqs = [];
                for (let t = 0; t < params.numTraits; t++) {
                    const counts = [0, 0, 0];
                    agents.forEach(a => counts[a.traits[t]]++);
                    traitFreqs.push(counts.map(c => c / agents.length));
                }

                let entropy = 0;
                traitFreqs.forEach(freqs => {
                    freqs.forEach(f => {
                        if (f > 0) entropy -= f * Math.log2(f);
                    });
                });

                history.push({
                    avgFitness,
                    diversity: entropy,
                    optimalProp: agents.filter(a => a.fitness === 100).length / agents.length
                });
                if (history.length > 200) history.shift();

                strategyHistory.push(strategies);
                if (strategyHistory.length > 200) strategyHistory.shift();
            }

            updateStats();
        }

        function reproduce(params) {
            const population = parseInt(document.getElementById('population').value);

            // Sort by fitness
            agents.sort((a, b) => b.fitness - a.fitness);

            // Top 50% reproduce
            const survivors = agents.slice(0, Math.floor(agents.length / 2));
            const newAgents = [];

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            while (newAgents.length < population) {
                const parent = survivors[Math.floor(Math.random() * survivors.length)];
                const child = new Agent(
                    parent.x + (Math.random() - 0.5) * 50,
                    parent.y + (Math.random() - 0.5) * 50
                );

                // Inherit traits with mutation
                child.traits = parent.traits.map(t => {
                    if (Math.random() < 0.05) {
                        return Math.floor(Math.random() * 3);
                    }
                    return t;
                });

                // Inherit learning strategy with mutation
                if (Math.random() < 0.1) {
                    child.learningStrategy = child.randomStrategy();
                } else {
                    child.learningStrategy = parent.learningStrategy;
                }

                child.prestige = parent.prestige * 0.5;

                // Bounds
                child.x = Math.max(10, Math.min(w - 10, child.x));
                child.y = Math.max(10, Math.min(h - 10, child.y));

                newAgents.push(child);
            }

            agents = newAgents;
        }

        function updateStats() {
            const params = getParams();
            const avgFitness = agents.reduce((s, a) => s + a.fitness, 0) / agents.length;
            const optimalProp = agents.filter(a => a.fitness === 100).length / agents.length;

            document.getElementById('avgFitness').textContent = avgFitness.toFixed(1);
            document.getElementById('optimalTraits').textContent = (optimalProp * 100).toFixed(0) + '%';
            document.getElementById('genNumber').textContent = generation;

            // Calculate diversity
            let totalVariants = 0;
            for (let t = 0; t < params.numTraits; t++) {
                const seen = new Set();
                agents.forEach(a => seen.add(a.traits[t]));
                totalVariants += seen.size;
            }
            document.getElementById('culturalDiversity').textContent =
                (totalVariants / params.numTraits).toFixed(1);
        }

        function draw() {
            drawArena();
            drawStrategyDistribution();
            drawTraitFrequencies();
            drawEvolution();
        }

        function drawArena() {
            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;
            const params = getParams();

            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, w, h);

            // Draw agents colored by their traits
            agents.forEach(agent => {
                // Color based on traits (as RGB-ish)
                const r = Math.round(agent.traits[0] * 85 + 50);
                const g = Math.round((agent.traits[1] || 0) * 85 + 50);
                const b = Math.round((agent.traits[2] || 0) * 85 + 50);

                arenaCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;

                // Size based on prestige
                const size = 3 + agent.prestige / 20;

                arenaCtx.beginPath();
                arenaCtx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
                arenaCtx.fill();

                // Strategy indicator
                const stratColors = {
                    [INDIVIDUAL]: '#f44336',
                    [UNBIASED_SOCIAL]: '#2196F3',
                    [CONFORMIST]: '#4CAF50',
                    [PRESTIGE]: '#ff9800'
                };

                arenaCtx.strokeStyle = stratColors[agent.learningStrategy];
                arenaCtx.lineWidth = 1.5;
                arenaCtx.beginPath();
                arenaCtx.arc(agent.x, agent.y, size + 2, 0, Math.PI * 2);
                arenaCtx.stroke();
            });

            // Optimal trait indicator
            arenaCtx.fillStyle = '#fff';
            arenaCtx.font = '10px sans-serif';
            arenaCtx.fillText(`Optimal: [${optimalTraits.join(',')}]`, 10, 20);

            // Legend
            const legends = [
                { color: '#f44336', label: 'Individual' },
                { color: '#2196F3', label: 'Unbiased' },
                { color: '#4CAF50', label: 'Conformist' },
                { color: '#ff9800', label: 'Prestige' }
            ];

            legends.forEach((l, i) => {
                arenaCtx.fillStyle = l.color;
                arenaCtx.fillRect(10 + i * 70, h - 20, 10, 10);
                arenaCtx.fillStyle = '#aaa';
                arenaCtx.fillText(l.label, 22 + i * 70, h - 12);
            });
        }

        function drawStrategyDistribution() {
            const w = strategyCanvas.width / window.devicePixelRatio;
            const h = strategyCanvas.height / window.devicePixelRatio;

            strategyCtx.fillStyle = '#1a1a2e';
            strategyCtx.fillRect(0, 0, w, h);

            if (strategyHistory.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            strategyCtx.strokeStyle = '#666';
            strategyCtx.beginPath();
            strategyCtx.moveTo(padding, padding);
            strategyCtx.lineTo(padding, h - padding);
            strategyCtx.lineTo(w - padding, h - padding);
            strategyCtx.stroke();

            // Labels
            strategyCtx.fillStyle = '#aaa';
            strategyCtx.font = '10px sans-serif';
            strategyCtx.fillText('Freq', 5, h / 2);
            strategyCtx.fillText('Time', w / 2 - 10, h - 5);

            const total = agents.length;
            const colors = {
                [INDIVIDUAL]: '#f44336',
                [UNBIASED_SOCIAL]: '#2196F3',
                [CONFORMIST]: '#4CAF50',
                [PRESTIGE]: '#ff9800'
            };

            // Draw stacked area
            const strategies = [INDIVIDUAL, UNBIASED_SOCIAL, CONFORMIST, PRESTIGE];

            strategies.forEach((strat, si) => {
                strategyCtx.fillStyle = colors[strat].replace(')', ', 0.6)').replace('rgb', 'rgba');
                strategyCtx.beginPath();

                // Top edge
                strategyHistory.forEach((d, i) => {
                    let cumSum = 0;
                    for (let j = 0; j <= si; j++) {
                        cumSum += d[strategies[j]] / total;
                    }
                    const x = padding + (i / (strategyHistory.length - 1)) * plotW;
                    const y = h - padding - cumSum * plotH;

                    if (i === 0) strategyCtx.moveTo(x, y);
                    else strategyCtx.lineTo(x, y);
                });

                // Bottom edge (reverse)
                for (let i = strategyHistory.length - 1; i >= 0; i--) {
                    let cumSum = 0;
                    for (let j = 0; j < si; j++) {
                        cumSum += strategyHistory[i][strategies[j]] / total;
                    }
                    const x = padding + (i / (strategyHistory.length - 1)) * plotW;
                    const y = h - padding - cumSum * plotH;
                    strategyCtx.lineTo(x, y);
                }

                strategyCtx.closePath();
                strategyCtx.fill();
            });

            // Legend
            let legendY = 15;
            strategies.forEach((strat, i) => {
                strategyCtx.fillStyle = colors[strat];
                strategyCtx.fillRect(w - 85, legendY, 10, 10);
                strategyCtx.fillStyle = '#aaa';
                strategyCtx.font = '9px sans-serif';
                strategyCtx.fillText(strat.split('_')[0], w - 70, legendY + 9);
                legendY += 14;
            });
        }

        function drawTraitFrequencies() {
            const w = traitCanvas.width / window.devicePixelRatio;
            const h = traitCanvas.height / window.devicePixelRatio;
            const params = getParams();

            traitCtx.fillStyle = '#1a1a2e';
            traitCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            traitCtx.strokeStyle = '#666';
            traitCtx.beginPath();
            traitCtx.moveTo(padding, padding);
            traitCtx.lineTo(padding, h - padding);
            traitCtx.lineTo(w - padding, h - padding);
            traitCtx.stroke();

            // Labels
            traitCtx.fillStyle = '#aaa';
            traitCtx.font = '10px sans-serif';
            traitCtx.fillText('Frequency', 5, h / 2);
            traitCtx.fillText('Trait', w / 2 - 10, h - 5);

            // Calculate trait frequencies for each trait position
            const numTraits = params.numTraits;
            const barWidth = plotW / numTraits * 0.7;
            const gapWidth = plotW / numTraits * 0.3;

            for (let t = 0; t < numTraits; t++) {
                const counts = [0, 0, 0];
                agents.forEach(a => {
                    if (a.traits[t] !== undefined) {
                        counts[a.traits[t]]++;
                    }
                });

                const x = padding + (t / numTraits) * plotW + gapWidth / 2;
                const subBarWidth = barWidth / 3;

                // Draw bars for each variant
                counts.forEach((c, v) => {
                    const freq = c / agents.length;
                    const barH = freq * plotH;
                    const barX = x + v * subBarWidth;
                    const barY = h - padding - barH;

                    // Color based on whether it matches optimal
                    const isOptimal = v === optimalTraits[t];
                    traitCtx.fillStyle = isOptimal ? '#4CAF50' : `hsl(${v * 120}, 50%, 40%)`;

                    traitCtx.fillRect(barX, barY, subBarWidth - 1, barH);
                });

                // Trait label
                traitCtx.fillStyle = '#888';
                traitCtx.font = '9px sans-serif';
                traitCtx.fillText(`T${t + 1}`, x + barWidth / 2 - 5, h - padding + 12);
            }

            // Legend
            traitCtx.fillStyle = '#4CAF50';
            traitCtx.fillText('■ Optimal', w - 70, 20);
        }

        function drawEvolution() {
            const w = evolutionCanvas.width / window.devicePixelRatio;
            const h = evolutionCanvas.height / window.devicePixelRatio;

            evolutionCtx.fillStyle = '#1a1a2e';
            evolutionCtx.fillRect(0, 0, w, h);

            if (history.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            evolutionCtx.strokeStyle = '#666';
            evolutionCtx.beginPath();
            evolutionCtx.moveTo(padding, padding);
            evolutionCtx.lineTo(padding, h - padding);
            evolutionCtx.lineTo(w - padding, h - padding);
            evolutionCtx.stroke();

            // Labels
            evolutionCtx.fillStyle = '#aaa';
            evolutionCtx.font = '10px sans-serif';
            evolutionCtx.fillText('Value', 5, h / 2);
            evolutionCtx.fillText('Time', w / 2 - 10, h - 5);

            // Draw fitness
            evolutionCtx.strokeStyle = '#4CAF50';
            evolutionCtx.lineWidth = 2;
            evolutionCtx.beginPath();
            history.forEach((d, i) => {
                const x = padding + (i / (history.length - 1)) * plotW;
                const y = h - padding - (d.avgFitness / 100) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();

            // Draw diversity
            const maxDiv = Math.max(...history.map(d => d.diversity), 1);
            evolutionCtx.strokeStyle = '#ff9800';
            evolutionCtx.beginPath();
            history.forEach((d, i) => {
                const x = padding + (i / (history.length - 1)) * plotW;
                const y = h - padding - (d.diversity / maxDiv) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();

            // Draw optimal proportion
            evolutionCtx.strokeStyle = '#2196F3';
            evolutionCtx.setLineDash([5, 5]);
            evolutionCtx.beginPath();
            history.forEach((d, i) => {
                const x = padding + (i / (history.length - 1)) * plotW;
                const y = h - padding - d.optimalProp * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();
            evolutionCtx.setLineDash([]);

            // Legend
            evolutionCtx.fillStyle = '#4CAF50';
            evolutionCtx.fillText('● Fitness', w - 80, 20);
            evolutionCtx.fillStyle = '#ff9800';
            evolutionCtx.fillText('● Diversity', w - 80, 35);
            evolutionCtx.fillStyle = '#2196F3';
            evolutionCtx.fillText('- Optimal', w - 80, 50);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['population', 'populationVal', v => v],
            ['numTraits', 'numTraitsVal', v => v],
            ['indivCost', 'indivCostVal', v => v],
            ['indivAccuracy', 'indivAccuracyVal', v => v + '%'],
            ['conformistBias', 'conformistBiasVal', v => v + '%'],
            ['prestigeBias', 'prestigeBiasVal', v => v + '%'],
            ['envChange', 'envChangeVal', v => v + '%']
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
</body>
</html>
