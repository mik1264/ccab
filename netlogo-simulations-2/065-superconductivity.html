<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superconductivity - Meissner Effect & Cooper Pairs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a2030 100%);
            min-height: 100vh;
            color: #e0f0ff;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2rem;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            margin-bottom: 5px;
        }

        .subtitle {
            color: #88ccff;
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00d4ff;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 1;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .simulation-area {
            background: rgba(10, 20, 40, 0.9);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background: #050a15;
        }

        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: rgba(20, 40, 70, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(0, 150, 255, 0.3);
        }

        .control-group h3 {
            color: #00d4ff;
            font-size: 0.85rem;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            margin-bottom: 10px;
        }

        .control-row label {
            display: block;
            font-size: 0.8rem;
            color: #88ccff;
            margin-bottom: 4px;
        }

        .control-row input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 212, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        .control-row select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            background: rgba(10, 30, 60, 0.9);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #e0f0ff;
            font-size: 0.85rem;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #0088cc);
            color: #000;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #00ff88, #00aa55);
            color: #000;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6666, #cc3333);
            color: #fff;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            background: rgba(0, 20, 50, 0.6);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #88a;
            text-transform: uppercase;
        }

        .state-indicator {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            transition: all 0.5s;
        }

        .state-normal {
            background: linear-gradient(135deg, #553300, #442200);
            color: #ffaa44;
            border: 1px solid #885500;
        }

        .state-super {
            background: linear-gradient(135deg, #003366, #002255);
            color: #00d4ff;
            border: 1px solid #0088cc;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 212, 255, 0.3); }
            50% { box-shadow: 0 0 25px rgba(0, 212, 255, 0.6); }
        }

        .info-box {
            background: rgba(0, 40, 80, 0.6);
            border-radius: 10px;
            padding: 12px;
            font-size: 0.8rem;
            line-height: 1.5;
            border-left: 3px solid #00d4ff;
        }

        .info-box h4 {
            color: #00d4ff;
            margin-bottom: 8px;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .cooper-pair {
            background: #00ffff;
            box-shadow: 0 0 8px #00ffff;
        }

        .field-line {
            background: linear-gradient(45deg, #44ff44, #00aa00);
        }

        .phonon {
            background: #ffaa00;
            box-shadow: 0 0 8px #ffaa00;
        }

        .thermometer {
            width: 100%;
            height: 20px;
            background: linear-gradient(to right, #0066ff 0%, #00d4ff 30%, #44ff88 50%, #ffaa00 70%, #ff4444 100%);
            border-radius: 10px;
            position: relative;
            margin-top: 5px;
        }

        .temp-marker {
            position: absolute;
            top: -5px;
            width: 4px;
            height: 30px;
            background: #fff;
            border-radius: 2px;
            transition: left 0.3s;
        }

        .tc-marker {
            position: absolute;
            top: 25px;
            font-size: 0.7rem;
            color: #aaa;
            transform: translateX(-50%);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Simulations</a>

    <div class="container">
        <header>
            <h1>❄️ Superconductivity Simulation</h1>
            <p class="subtitle">Meissner Effect, Cooper Pairs & Flux Quantization</p>
        </header>

        <div class="main-content">
            <div class="simulation-area">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot cooper-pair"></div>
                        <span>Cooper Pairs</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot field-line"></div>
                        <span>Magnetic Field</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot phonon"></div>
                        <span>Phonons</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <div class="state-indicator state-normal" id="stateIndicator">
                        NORMAL STATE
                    </div>
                    <div class="buttons">
                        <button class="btn-primary" id="startBtn">▶ Start</button>
                        <button class="btn-danger" id="resetBtn">↺ Reset</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Temperature Control</h3>
                    <div class="control-row">
                        <label>Temperature: <span id="tempVal">150</span> K</label>
                        <input type="range" id="temperature" min="0" max="300" value="150">
                        <div class="thermometer">
                            <div class="temp-marker" id="tempMarker" style="left: 50%"></div>
                            <span class="tc-marker" style="left: 30%">Tc</span>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Critical Temperature Tc: <span id="tcVal">90</span> K</label>
                        <input type="range" id="criticalTemp" min="20" max="150" value="90">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Magnetic Field</h3>
                    <div class="control-row">
                        <label>Applied Field B: <span id="fieldVal">0.5</span> T</label>
                        <input type="range" id="magneticField" min="0" max="2" value="0.5" step="0.1">
                    </div>
                    <div class="control-row">
                        <label>Field Direction</label>
                        <select id="fieldDirection">
                            <option value="vertical">Vertical (↓)</option>
                            <option value="horizontal">Horizontal (→)</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Material Type</h3>
                    <div class="control-row">
                        <select id="material">
                            <option value="typeI">Type I (Mercury, Lead)</option>
                            <option value="typeII">Type II (YBCO, NbTi)</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Penetration Depth λ: <span id="lambdaVal">50</span> nm</label>
                        <input type="range" id="penetrationDepth" min="10" max="200" value="50">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="cooperPairs">0</div>
                            <div class="stat-label">Cooper Pairs</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="orderParam">0</div>
                            <div class="stat-label">Order Δ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="fluxQuanta">0</div>
                            <div class="stat-label">Φ/Φ₀</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="screenCurrent">0</div>
                            <div class="stat-label">Screen J</div>
                        </div>
                    </div>
                </div>

                <div class="control-group info-box">
                    <h4>Superconductivity Physics</h4>
                    <p>
                        Below the critical temperature Tc, electrons form
                        <b>Cooper pairs</b> via phonon-mediated attraction.
                        The <b>Meissner effect</b> expels magnetic fields
                        from the superconductor's interior.
                    </p>
                    <ul style="margin-top: 8px; padding-left: 15px;">
                        <li><b>Type I:</b> Complete field expulsion</li>
                        <li><b>Type II:</b> Flux vortices above Hc1</li>
                        <li><b>Φ₀ = h/2e:</b> Flux quantum</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth - 30;
            const height = Math.min(width * 0.7, window.innerHeight - 280);
            canvas.width = width;
            canvas.height = height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let running = false;
        let time = 0;

        // Physical parameters
        let temperature = 150;      // Current temperature (K)
        let criticalTemp = 90;      // Tc (K)
        let magneticField = 0.5;    // Applied field (T)
        let penetrationDepth = 50;  // London penetration depth (nm)
        let fieldDirection = 'vertical';
        let materialType = 'typeI';

        // Derived quantities
        let isSuperconducting = false;
        let orderParameter = 0;     // BCS gap Δ
        let fluxQuantum = 2.067833848e-15;  // Φ₀ = h/2e

        // Particles and fields
        let cooperPairs = [];
        let phonons = [];
        let fieldLines = [];
        let vortices = [];

        // Superconductor geometry
        const sample = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };

        function updateSampleGeometry() {
            sample.width = canvas.width * 0.5;
            sample.height = canvas.height * 0.6;
            sample.x = (canvas.width - sample.width) / 2;
            sample.y = (canvas.height - sample.height) / 2;
        }

        // Cooper pair class
        class CooperPair {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.phase = Math.random() * Math.PI * 2;
                this.paired = true;
            }

            update() {
                // Move within superconductor
                this.x += this.vx * (1 - temperature / 300);
                this.y += this.vy * (1 - temperature / 300);
                this.phase += 0.1;

                // Reflect at boundaries
                if (this.x < sample.x || this.x > sample.x + sample.width) {
                    this.vx *= -1;
                    this.x = Math.max(sample.x, Math.min(sample.x + sample.width, this.x));
                }
                if (this.y < sample.y || this.y > sample.y + sample.height) {
                    this.vy *= -1;
                    this.y = Math.max(sample.y, Math.min(sample.y + sample.height, this.y));
                }

                // Thermal breakup probability
                if (temperature > criticalTemp) {
                    if (Math.random() < (temperature - criticalTemp) / 100) {
                        this.paired = false;
                    }
                }
            }

            draw() {
                if (!this.paired) return;

                const glow = Math.sin(this.phase) * 0.3 + 0.7;
                const size = 4;

                // Draw as paired electrons with connection
                ctx.save();
                ctx.translate(this.x, this.y);

                // Electron 1
                ctx.beginPath();
                ctx.arc(-size, 0, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 255, ${glow})`;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;
                ctx.fill();

                // Electron 2
                ctx.beginPath();
                ctx.arc(size, 0, 3, 0, Math.PI * 2);
                ctx.fill();

                // Connection (phonon mediated)
                ctx.strokeStyle = `rgba(255, 170, 0, ${glow * 0.5})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(-size, 0);
                ctx.lineTo(size, 0);
                ctx.stroke();

                ctx.restore();
            }
        }

        // Phonon class (lattice vibration)
        class Phonon {
            constructor() {
                this.x = sample.x + Math.random() * sample.width;
                this.y = sample.y + Math.random() * sample.height;
                this.amplitude = Math.random() * 5 + 2;
                this.phase = Math.random() * Math.PI * 2;
                this.frequency = Math.random() * 0.2 + 0.1;
                this.life = 1;
            }

            update() {
                this.phase += this.frequency;
                this.life -= 0.01 * (temperature / 100);
                this.amplitude *= 0.99;
            }

            draw() {
                if (this.life <= 0) return;

                const alpha = this.life * 0.5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.amplitude * Math.sin(this.phase), 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 170, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Flux vortex for Type II superconductors
        class Vortex {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.phase = Math.random() * Math.PI * 2;
                this.radius = 10 + Math.random() * 5;
            }

            update() {
                this.phase += 0.05;
                // Vortices repel each other
                for (const v of vortices) {
                    if (v === this) continue;
                    const dx = this.x - v.x;
                    const dy = this.y - v.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 50 && dist > 0) {
                        this.x += dx / dist * 0.5;
                        this.y += dy / dist * 0.5;
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Vortex core (normal region)
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#553300';
                ctx.fill();

                // Circulating current
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 1;
                for (let r = 8; r <= this.radius; r += 4) {
                    ctx.beginPath();
                    const segments = 8;
                    for (let i = 0; i < segments; i++) {
                        const angle = (i / segments) * Math.PI * 2 + this.phase;
                        const nextAngle = ((i + 0.7) / segments) * Math.PI * 2 + this.phase;
                        ctx.moveTo(r * Math.cos(angle), r * Math.sin(angle));
                        ctx.lineTo(r * Math.cos(nextAngle), r * Math.sin(nextAngle));
                    }
                    ctx.stroke();
                }

                // Field line through core
                ctx.strokeStyle = '#44ff44';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(0, 20);
                ctx.stroke();

                // Arrow
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(-4, 14);
                ctx.moveTo(0, 20);
                ctx.lineTo(4, 14);
                ctx.stroke();

                ctx.restore();
            }
        }

        // Initialize simulation
        function initialize() {
            updateSampleGeometry();
            cooperPairs = [];
            phonons = [];
            vortices = [];

            // Create initial Cooper pairs
            const numPairs = Math.floor(100 * (1 - temperature / 300));
            for (let i = 0; i < numPairs; i++) {
                const x = sample.x + Math.random() * sample.width;
                const y = sample.y + Math.random() * sample.height;
                cooperPairs.push(new CooperPair(x, y));
            }

            // Create initial phonons
            for (let i = 0; i < 20; i++) {
                phonons.push(new Phonon());
            }

            updateState();
        }

        // Update superconducting state
        function updateState() {
            const previousState = isSuperconducting;
            isSuperconducting = temperature < criticalTemp;

            // BCS order parameter (simplified)
            if (isSuperconducting) {
                orderParameter = 1.76 * 1.38e-23 * criticalTemp *
                    Math.sqrt(1 - Math.pow(temperature / criticalTemp, 2));
            } else {
                orderParameter = 0;
            }

            // Update state indicator
            const indicator = document.getElementById('stateIndicator');
            if (isSuperconducting) {
                indicator.className = 'state-indicator state-super';
                indicator.textContent = 'SUPERCONDUCTING';
            } else {
                indicator.className = 'state-indicator state-normal';
                indicator.textContent = 'NORMAL STATE';
            }

            // State transition effects
            if (previousState !== isSuperconducting) {
                if (isSuperconducting) {
                    // Create Cooper pairs
                    const targetPairs = Math.floor(150 * (1 - temperature / criticalTemp));
                    while (cooperPairs.filter(p => p.paired).length < targetPairs) {
                        const x = sample.x + Math.random() * sample.width;
                        const y = sample.y + Math.random() * sample.height;
                        cooperPairs.push(new CooperPair(x, y));
                    }
                } else {
                    // Break up Cooper pairs
                    cooperPairs.forEach(p => {
                        if (Math.random() < 0.5) p.paired = false;
                    });
                    vortices = [];
                }
            }

            // Type II: create vortices if field exceeds Hc1
            if (materialType === 'typeII' && isSuperconducting && magneticField > 0.3) {
                const numVortices = Math.floor((magneticField - 0.3) * 10);
                while (vortices.length < numVortices) {
                    const x = sample.x + 20 + Math.random() * (sample.width - 40);
                    const y = sample.y + 20 + Math.random() * (sample.height - 40);
                    vortices.push(new Vortex(x, y));
                }
                while (vortices.length > numVortices) {
                    vortices.pop();
                }
            } else if (materialType === 'typeI' || !isSuperconducting) {
                vortices = [];
            }
        }

        // Draw magnetic field lines
        function drawFieldLines() {
            const fieldStrength = magneticField;
            const numLines = Math.floor(fieldStrength * 15);

            ctx.strokeStyle = isSuperconducting ? '#44ff44' : '#88ff88';
            ctx.lineWidth = 1.5;

            if (fieldDirection === 'vertical') {
                // Vertical field lines
                for (let i = 0; i < numLines; i++) {
                    const baseX = (i + 0.5) * canvas.width / numLines;

                    ctx.beginPath();

                    if (isSuperconducting && materialType === 'typeI') {
                        // Meissner effect: field goes around superconductor
                        if (baseX < sample.x - 20 || baseX > sample.x + sample.width + 20) {
                            // Far from sample - straight line
                            ctx.moveTo(baseX, 0);
                            ctx.lineTo(baseX, canvas.height);
                        } else {
                            // Near sample - deflect around
                            const distFromCenter = baseX - (sample.x + sample.width / 2);
                            const deflection = Math.sign(distFromCenter) * 50;

                            ctx.moveTo(baseX, 0);
                            ctx.quadraticCurveTo(
                                baseX + deflection, sample.y - 30,
                                sample.x + (distFromCenter > 0 ? sample.width + 30 : -30),
                                sample.y + sample.height / 2
                            );
                            ctx.quadraticCurveTo(
                                baseX + deflection, sample.y + sample.height + 30,
                                baseX, canvas.height
                            );
                        }
                    } else {
                        // Normal state or Type II with vortices
                        ctx.moveTo(baseX, 0);
                        ctx.lineTo(baseX, canvas.height);
                    }

                    ctx.stroke();

                    // Arrow heads
                    const arrowY = canvas.height * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(baseX, arrowY);
                    ctx.lineTo(baseX - 4, arrowY - 8);
                    ctx.moveTo(baseX, arrowY);
                    ctx.lineTo(baseX + 4, arrowY - 8);
                    ctx.stroke();
                }
            } else {
                // Horizontal field lines
                for (let i = 0; i < numLines; i++) {
                    const baseY = (i + 0.5) * canvas.height / numLines;

                    ctx.beginPath();

                    if (isSuperconducting && materialType === 'typeI') {
                        if (baseY < sample.y - 20 || baseY > sample.y + sample.height + 20) {
                            ctx.moveTo(0, baseY);
                            ctx.lineTo(canvas.width, baseY);
                        } else {
                            const distFromCenter = baseY - (sample.y + sample.height / 2);
                            const deflection = Math.sign(distFromCenter) * 50;

                            ctx.moveTo(0, baseY);
                            ctx.quadraticCurveTo(
                                sample.x - 30, baseY + deflection,
                                sample.x + sample.width / 2,
                                sample.y + (distFromCenter > 0 ? sample.height + 30 : -30)
                            );
                            ctx.quadraticCurveTo(
                                sample.x + sample.width + 30, baseY + deflection,
                                canvas.width, baseY
                            );
                        }
                    } else {
                        ctx.moveTo(0, baseY);
                        ctx.lineTo(canvas.width, baseY);
                    }

                    ctx.stroke();
                }
            }
        }

        // Draw superconductor sample
        function drawSample() {
            // Sample body
            const gradient = ctx.createLinearGradient(
                sample.x, sample.y,
                sample.x + sample.width, sample.y + sample.height
            );

            if (isSuperconducting) {
                gradient.addColorStop(0, '#002244');
                gradient.addColorStop(0.5, '#003366');
                gradient.addColorStop(1, '#001133');
            } else {
                gradient.addColorStop(0, '#443322');
                gradient.addColorStop(0.5, '#553311');
                gradient.addColorStop(1, '#332211');
            }

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(sample.x, sample.y, sample.width, sample.height, 10);
            ctx.fill();

            // Border with glow for superconducting state
            ctx.strokeStyle = isSuperconducting ? '#00d4ff' : '#886644';
            ctx.lineWidth = 2;
            if (isSuperconducting) {
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 15;
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Penetration depth visualization
            if (isSuperconducting) {
                const lambda = penetrationDepth / 5;  // Scale for visualization
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                ctx.lineWidth = lambda;
                ctx.beginPath();
                ctx.roundRect(
                    sample.x + lambda / 2,
                    sample.y + lambda / 2,
                    sample.width - lambda,
                    sample.height - lambda,
                    10
                );
                ctx.stroke();
            }

            // Label
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(
                isSuperconducting ? 'Superconductor' : 'Normal Metal',
                sample.x + sample.width / 2,
                sample.y + sample.height + 20
            );
        }

        // Draw screening currents
        function drawScreeningCurrents() {
            if (!isSuperconducting || magneticField < 0.1) return;

            ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.lineWidth = 1;

            const margin = 15;
            const numCurrents = 4;

            for (let i = 0; i < numCurrents; i++) {
                const offset = margin + i * 5;
                ctx.beginPath();
                ctx.roundRect(
                    sample.x + offset,
                    sample.y + offset,
                    sample.width - 2 * offset,
                    sample.height - 2 * offset,
                    8
                );
                ctx.stroke();
            }

            // Current direction arrows
            ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
            const arrowPositions = [
                { x: sample.x + sample.width / 2, y: sample.y + 8, angle: 0 },
                { x: sample.x + sample.width - 8, y: sample.y + sample.height / 2, angle: Math.PI / 2 },
                { x: sample.x + sample.width / 2, y: sample.y + sample.height - 8, angle: Math.PI },
                { x: sample.x + 8, y: sample.y + sample.height / 2, angle: -Math.PI / 2 }
            ];

            for (const pos of arrowPositions) {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.angle + time * 0.05);
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(0, -4);
                ctx.lineTo(0, 4);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // Update statistics
        function updateStats() {
            const activePairs = cooperPairs.filter(p => p.paired).length;
            document.getElementById('cooperPairs').textContent = activePairs;

            // Order parameter (normalized)
            const normOrder = isSuperconducting ?
                (1 - temperature / criticalTemp).toFixed(2) : '0';
            document.getElementById('orderParam').textContent = normOrder;

            // Flux quanta (for Type II with vortices)
            document.getElementById('fluxQuanta').textContent = vortices.length;

            // Screening current (proportional to B for Meissner)
            const screenJ = isSuperconducting ?
                (magneticField * (1 - temperature / criticalTemp)).toFixed(2) : '0';
            document.getElementById('screenCurrent').textContent = screenJ;
        }

        // Main update loop
        function update() {
            time++;

            // Update Cooper pairs
            cooperPairs.forEach(p => p.update());
            cooperPairs = cooperPairs.filter(p => p.paired || Math.random() > 0.01);

            // Maintain Cooper pair population
            if (isSuperconducting) {
                const targetPairs = Math.floor(100 * (1 - temperature / criticalTemp));
                while (cooperPairs.filter(p => p.paired).length < targetPairs &&
                       cooperPairs.length < 200) {
                    const x = sample.x + Math.random() * sample.width;
                    const y = sample.y + Math.random() * sample.height;
                    cooperPairs.push(new CooperPair(x, y));
                }
            }

            // Update phonons
            phonons.forEach(p => p.update());
            phonons = phonons.filter(p => p.life > 0);

            // Add new phonons based on temperature
            if (Math.random() < temperature / 500) {
                phonons.push(new Phonon());
            }

            // Update vortices
            vortices.forEach(v => v.update());

            updateStats();
        }

        // Render
        function render() {
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#050a15';
            ctx.fillRect(0, 0, width, height);

            // Update geometry
            updateSampleGeometry();

            // Draw components
            drawFieldLines();
            drawSample();
            drawScreeningCurrents();

            // Draw phonons (inside sample)
            ctx.save();
            ctx.beginPath();
            ctx.roundRect(sample.x, sample.y, sample.width, sample.height, 10);
            ctx.clip();
            phonons.forEach(p => p.draw());
            ctx.restore();

            // Draw Cooper pairs
            cooperPairs.forEach(p => p.draw());

            // Draw vortices (Type II)
            vortices.forEach(v => v.draw());

            // Temperature label
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`T = ${temperature} K`, 10, 20);
            ctx.fillText(`Tc = ${criticalTemp} K`, 10, 35);
            ctx.fillText(`B = ${magneticField.toFixed(1)} T`, 10, 50);

            // Material type
            ctx.textAlign = 'right';
            ctx.fillText(materialType === 'typeI' ? 'Type I' : 'Type II', width - 10, 20);
        }

        // Animation loop
        function animate() {
            if (running) {
                update();
            }
            render();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? '⏸ Pause' : '▶ Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = '▶ Start';
            initialize();
        });

        // Temperature control
        document.getElementById('temperature').addEventListener('input', (e) => {
            temperature = parseInt(e.target.value);
            document.getElementById('tempVal').textContent = temperature;
            document.getElementById('tempMarker').style.left = `${(temperature / 300) * 100}%`;
            updateState();
        });

        document.getElementById('criticalTemp').addEventListener('input', (e) => {
            criticalTemp = parseInt(e.target.value);
            document.getElementById('tcVal').textContent = criticalTemp;
            // Update Tc marker position
            const tcPercent = (criticalTemp / 300) * 100;
            document.querySelector('.tc-marker').style.left = `${tcPercent}%`;
            updateState();
        });

        // Field controls
        document.getElementById('magneticField').addEventListener('input', (e) => {
            magneticField = parseFloat(e.target.value);
            document.getElementById('fieldVal').textContent = magneticField.toFixed(1);
            updateState();
        });

        document.getElementById('fieldDirection').addEventListener('change', (e) => {
            fieldDirection = e.target.value;
        });

        // Material and penetration depth
        document.getElementById('material').addEventListener('change', (e) => {
            materialType = e.target.value;
            updateState();
        });

        document.getElementById('penetrationDepth').addEventListener('input', (e) => {
            penetrationDepth = parseInt(e.target.value);
            document.getElementById('lambdaVal').textContent = penetrationDepth;
        });

        // Initialize
        initialize();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
