<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artificial Metabolism - Chemical Reaction Network</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #1e1e2e; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; font-family: inherit; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .energy-bar { height: 24px; background: #333; border-radius: 4px; margin-top: 10px; overflow: hidden; position: relative; }
        .energy-fill { height: 100%; transition: width 0.3s; position: absolute; }
        .atp-fill { background: linear-gradient(90deg, #ffd700, #ffed4a); left: 0; }
        .adp-fill { background: linear-gradient(90deg, #888, #aaa); }
        .energy-labels { display: flex; justify-content: space-between; font-size: 0.7rem; color: #666; margin-top: 4px; }
        .metabolite-panel { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin-top: 10px; }
        .metabolite { padding: 5px; border-radius: 4px; text-align: center; font-size: 0.7rem; color: white; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Artificial Metabolism</h1>
            <p class="subtitle">ATP-driven chemical reaction network with autocatalytic cycles</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Metabolic Mode</label>
                    <select id="mode">
                        <option value="glycolysis">Glycolysis (Glucose → Pyruvate)</option>
                        <option value="krebs">Krebs Cycle (Citric Acid)</option>
                        <option value="synthetic">Synthetic Metabolism</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Glucose Input Rate</label>
                    <input type="range" id="glucoseRate" min="0" max="100" value="50">
                    <div class="control-value"><span id="glucoseRateVal">50</span>%</div>
                </div>
                <div class="control-group">
                    <label>Enzyme Activity</label>
                    <input type="range" id="enzymeActivity" min="10" max="100" value="60">
                    <div class="control-value"><span id="enzymeActivityVal">60</span>%</div>
                </div>
                <div class="control-group">
                    <label>O₂ Availability</label>
                    <input type="range" id="oxygen" min="0" max="100" value="80">
                    <div class="control-value"><span id="oxygenVal">80</span>%</div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset Network</button>

                <div class="control-group" style="margin-top: 15px;">
                    <label>Energy Currency (ATP/ADP)</label>
                    <div class="energy-bar">
                        <div class="energy-fill atp-fill" id="atpBar" style="width: 50%;"></div>
                    </div>
                    <div class="energy-labels">
                        <span>ADP</span>
                        <span id="atpLevel">50% ATP</span>
                        <span>ATP</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="atpProduced">0</div><div class="stat-label">ATP Produced</div></div>
                    <div class="stat-box"><div class="stat-value" id="atpConsumed">0</div><div class="stat-label">ATP Consumed</div></div>
                    <div class="stat-box"><div class="stat-value" id="flux">0</div><div class="stat-label">Flux (mol/s)</div></div>
                    <div class="stat-box"><div class="stat-value" id="efficiency">0%</div><div class="stat-label">Efficiency</div></div>
                </div>

                <div class="metabolite-panel" id="metabolites">
                    <!-- Filled dynamically -->
                </div>

                <div class="info-panel">
                    <strong>Metabolic Networks:</strong> ATP is the universal energy currency. Glycolysis produces 2 ATP/glucose anaerobically; with O₂, the Krebs cycle yields 36 ATP total.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = (rect.width * 0.65) * dpr;
            canvas.style.height = (rect.width * 0.65) + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width * 0.65 };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); initNetwork(); });

        // Metabolite definitions
        const METABOLITES = {
            glucose: { name: 'Glucose', color: '#4fc3f7', formula: 'C₆H₁₂O₆' },
            g6p: { name: 'G6P', color: '#64b5f6', formula: 'C₆H₁₃O₉P' },
            f6p: { name: 'F6P', color: '#42a5f5', formula: 'C₆H₁₃O₉P' },
            fbp: { name: 'FBP', color: '#2196f3', formula: 'C₆H₁₄O₁₂P₂' },
            g3p: { name: 'G3P', color: '#1e88e5', formula: 'C₃H₇O₆P' },
            bpg: { name: '1,3-BPG', color: '#1976d2', formula: 'C₃H₈O₁₀P₂' },
            pg3: { name: '3-PG', color: '#1565c0', formula: 'C₃H₇O₇P' },
            pep: { name: 'PEP', color: '#0d47a1', formula: 'C₃H₅O₆P' },
            pyruvate: { name: 'Pyruvate', color: '#ff7043', formula: 'C₃H₄O₃' },
            acetylCoA: { name: 'Acetyl-CoA', color: '#ffb74d', formula: 'C₂₃H₃₈N₇O₁₇P₃S' },
            citrate: { name: 'Citrate', color: '#81c784', formula: 'C₆H₈O₇' },
            isocitrate: { name: 'Isocitrate', color: '#66bb6a', formula: 'C₆H₈O₇' },
            alphaKG: { name: 'α-KG', color: '#4caf50', formula: 'C₅H₆O₅' },
            succinylCoA: { name: 'Succinyl-CoA', color: '#43a047', formula: 'C₂₅H₄₀N₇O₁₉P₃S' },
            succinate: { name: 'Succinate', color: '#388e3c', formula: 'C₄H₆O₄' },
            fumarate: { name: 'Fumarate', color: '#2e7d32', formula: 'C₄H₄O₄' },
            malate: { name: 'Malate', color: '#1b5e20', formula: 'C₄H₆O₅' },
            oaa: { name: 'OAA', color: '#a5d6a7', formula: 'C₄H₄O₅' },
            atp: { name: 'ATP', color: '#ffd700', formula: 'C₁₀H₁₆N₅O₁₃P₃' },
            adp: { name: 'ADP', color: '#888888', formula: 'C₁₀H₁₅N₅O₁₀P₂' },
            nadh: { name: 'NADH', color: '#ce93d8', formula: 'C₂₁H₂₉N₇O₁₄P₂' },
            nad: { name: 'NAD⁺', color: '#9575cd', formula: 'C₂₁H₂₇N₇O₁₄P₂' },
            co2: { name: 'CO₂', color: '#90a4ae', formula: 'CO₂' }
        };

        // Network nodes and edges
        let nodes = [];
        let edges = [];
        let particles = [];

        // State
        let state = {
            running: false,
            time: 0,
            concentrations: {},
            atpPool: 50,
            atpProduced: 0,
            atpConsumed: 0,
            flux: 0
        };

        function initNetwork() {
            const mode = document.getElementById('mode').value;
            nodes = [];
            edges = [];
            particles = [];

            // Initialize concentrations
            Object.keys(METABOLITES).forEach(m => {
                state.concentrations[m] = m === 'glucose' ? 100 : 20;
            });
            state.concentrations.atp = state.atpPool;
            state.concentrations.adp = 100 - state.atpPool;

            const cx = dims.width / 2;
            const cy = dims.height / 2;

            if (mode === 'glycolysis') {
                // Glycolysis pathway (linear with some branches)
                const metabolites = ['glucose', 'g6p', 'f6p', 'fbp', 'g3p', 'bpg', 'pg3', 'pep', 'pyruvate'];
                metabolites.forEach((m, i) => {
                    const x = 80 + i * (dims.width - 160) / (metabolites.length - 1);
                    const y = cy + Math.sin(i * 0.5) * 40;
                    nodes.push({ id: m, x, y, ...METABOLITES[m], concentration: 20 });
                });

                // Edges with ATP production/consumption
                edges = [
                    { from: 'glucose', to: 'g6p', enzyme: 'Hexokinase', atpCost: -1 },
                    { from: 'g6p', to: 'f6p', enzyme: 'Isomerase', atpCost: 0 },
                    { from: 'f6p', to: 'fbp', enzyme: 'PFK-1', atpCost: -1 },
                    { from: 'fbp', to: 'g3p', enzyme: 'Aldolase', atpCost: 0 },
                    { from: 'g3p', to: 'bpg', enzyme: 'GAPDH', atpCost: 0, producesNADH: true },
                    { from: 'bpg', to: 'pg3', enzyme: 'PGK', atpCost: 2 },
                    { from: 'pg3', to: 'pep', enzyme: 'Enolase', atpCost: 0 },
                    { from: 'pep', to: 'pyruvate', enzyme: 'Pyruvate Kinase', atpCost: 2 }
                ];

            } else if (mode === 'krebs') {
                // Krebs cycle (circular)
                const metabolites = ['acetylCoA', 'citrate', 'isocitrate', 'alphaKG', 'succinylCoA', 'succinate', 'fumarate', 'malate', 'oaa'];
                const radius = Math.min(dims.width, dims.height) * 0.35;
                metabolites.forEach((m, i) => {
                    const angle = (i / metabolites.length) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    nodes.push({ id: m, x, y, ...METABOLITES[m], concentration: 20 });
                });

                edges = [
                    { from: 'acetylCoA', to: 'citrate', enzyme: 'Citrate Synthase', atpCost: 0 },
                    { from: 'citrate', to: 'isocitrate', enzyme: 'Aconitase', atpCost: 0 },
                    { from: 'isocitrate', to: 'alphaKG', enzyme: 'IDH', atpCost: 0, producesNADH: true, producesCO2: true },
                    { from: 'alphaKG', to: 'succinylCoA', enzyme: 'α-KGDH', atpCost: 0, producesNADH: true, producesCO2: true },
                    { from: 'succinylCoA', to: 'succinate', enzyme: 'SCS', atpCost: 1 },
                    { from: 'succinate', to: 'fumarate', enzyme: 'SDH', atpCost: 0 },
                    { from: 'fumarate', to: 'malate', enzyme: 'Fumarase', atpCost: 0 },
                    { from: 'malate', to: 'oaa', enzyme: 'MDH', atpCost: 0, producesNADH: true },
                    { from: 'oaa', to: 'acetylCoA', enzyme: '(Acetyl-CoA input)', atpCost: 0 }
                ];

            } else {
                // Synthetic metabolism - autocatalytic set
                const metabolites = ['A', 'B', 'C', 'D', 'E', 'F'];
                metabolites.forEach((m, i) => {
                    const angle = (i / metabolites.length) * Math.PI * 2;
                    const x = cx + Math.cos(angle) * 120;
                    const y = cy + Math.sin(angle) * 100;
                    nodes.push({ id: m, x, y, name: m, color: `hsl(${i * 60}, 70%, 55%)`, concentration: 20 });
                });

                // Autocatalytic network
                edges = [
                    { from: 'A', to: 'B', enzyme: 'E₁', atpCost: -1 },
                    { from: 'B', to: 'C', enzyme: 'E₂', atpCost: 1 },
                    { from: 'C', to: 'D', enzyme: 'E₃ (autocatalyst)', atpCost: 0, autocatalytic: true },
                    { from: 'D', to: 'E', enzyme: 'E₄', atpCost: 1 },
                    { from: 'E', to: 'F', enzyme: 'E₅', atpCost: 0 },
                    { from: 'F', to: 'A', enzyme: 'E₆ (cycle closure)', atpCost: -1 },
                    { from: 'C', to: 'A', enzyme: 'Feedback', atpCost: 0 }
                ];
            }
        }

        function update() {
            if (!state.running) return;

            const glucoseRate = parseInt(document.getElementById('glucoseRate').value) / 100;
            const enzymeActivity = parseInt(document.getElementById('enzymeActivity').value) / 100;
            const oxygen = parseInt(document.getElementById('oxygen').value) / 100;

            state.time++;

            // Add glucose input
            if (Math.random() < glucoseRate * 0.1) {
                const inputNode = nodes[0];
                if (inputNode) {
                    particles.push({
                        x: 20,
                        y: inputNode.y,
                        targetNode: 0,
                        progress: 0,
                        type: 'substrate',
                        color: METABOLITES.glucose.color
                    });
                }
            }

            // Process reactions along edges
            for (const edge of edges) {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) continue;

                // Reaction rate depends on enzyme activity and substrate availability
                let rate = enzymeActivity * 0.05;
                if (edge.atpCost < 0 && state.atpPool < Math.abs(edge.atpCost) * 10) {
                    rate *= 0.1; // Limited by ATP
                }
                if (edge.producesNADH && oxygen < 0.3) {
                    rate *= 0.3; // NAD+ regeneration limited without O2
                }

                if (Math.random() < rate) {
                    // Create particle moving from source to target
                    particles.push({
                        x: fromNode.x,
                        y: fromNode.y,
                        targetX: toNode.x,
                        targetY: toNode.y,
                        progress: 0,
                        type: 'metabolite',
                        color: toNode.color,
                        edge: edge
                    });

                    // Handle ATP
                    if (edge.atpCost > 0) {
                        state.atpPool = Math.min(100, state.atpPool + edge.atpCost * 0.5);
                        state.atpProduced += edge.atpCost;
                        // ATP particle
                        particles.push({
                            x: (fromNode.x + toNode.x) / 2,
                            y: (fromNode.y + toNode.y) / 2 - 10,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -2,
                            life: 60,
                            type: 'atp',
                            color: '#ffd700'
                        });
                    } else if (edge.atpCost < 0) {
                        state.atpPool = Math.max(0, state.atpPool + edge.atpCost * 0.5);
                        state.atpConsumed += Math.abs(edge.atpCost);
                    }

                    // CO2 production
                    if (edge.producesCO2) {
                        particles.push({
                            x: (fromNode.x + toNode.x) / 2,
                            y: (fromNode.y + toNode.y) / 2,
                            vx: (Math.random() - 0.5) * 1,
                            vy: -3,
                            life: 80,
                            type: 'co2',
                            color: '#90a4ae'
                        });
                    }
                }
            }

            // Update particles
            particles = particles.filter(p => {
                if (p.type === 'atp' || p.type === 'co2') {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    return p.life > 0;
                } else {
                    p.progress += 0.03;
                    if (p.targetX !== undefined) {
                        p.x = p.x + (p.targetX - p.x) * 0.05;
                        p.y = p.y + (p.targetY - p.y) * 0.05;
                    }
                    return p.progress < 1;
                }
            });

            // Calculate flux
            state.flux = particles.filter(p => p.type === 'metabolite').length;

            updateStats();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            // Background
            ctx.fillStyle = '#1e1e2e';
            ctx.fillRect(0, 0, dims.width, dims.height);

            // Draw edges (reaction arrows)
            for (const edge of edges) {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) continue;

                // Arrow line
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / len;
                const ny = dy / len;

                const startX = fromNode.x + nx * 25;
                const startY = fromNode.y + ny * 25;
                const endX = toNode.x - nx * 25;
                const endY = toNode.y - ny * 25;

                // Gradient based on ATP cost
                let color = 'rgba(100, 100, 150, 0.5)';
                if (edge.atpCost > 0) color = 'rgba(255, 215, 0, 0.6)';
                if (edge.atpCost < 0) color = 'rgba(255, 100, 100, 0.5)';

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Arrowhead
                const arrowSize = 8;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - nx * arrowSize - ny * arrowSize * 0.5, endY - ny * arrowSize + nx * arrowSize * 0.5);
                ctx.lineTo(endX - nx * arrowSize + ny * arrowSize * 0.5, endY - ny * arrowSize - nx * arrowSize * 0.5);
                ctx.closePath();
                ctx.fill();

                // Enzyme label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '9px Nunito';
                ctx.textAlign = 'center';
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                ctx.fillText(edge.enzyme, midX, midY - 8);

                // ATP indicator
                if (edge.atpCost !== 0) {
                    ctx.fillStyle = edge.atpCost > 0 ? '#ffd700' : '#ff6b6b';
                    ctx.font = 'bold 10px Nunito';
                    ctx.fillText((edge.atpCost > 0 ? '+' : '') + edge.atpCost + ' ATP', midX, midY + 10);
                }
            }

            // Draw nodes (metabolites)
            for (const node of nodes) {
                // Glow based on concentration
                const glowSize = 20 + (node.concentration || 20) * 0.3;
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowSize);
                gradient.addColorStop(0, node.color + '80');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Node circle
                ctx.fillStyle = node.color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 18, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(node.name, node.x, node.y + 4);

                // Formula below
                if (node.formula) {
                    ctx.font = '8px Nunito';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(node.formula, node.x, node.y + 32);
                }
            }

            // Draw particles
            for (const p of particles) {
                if (p.type === 'atp') {
                    ctx.fillStyle = p.color;
                    ctx.font = 'bold 12px Nunito';
                    ctx.globalAlpha = p.life / 60;
                    ctx.fillText('⚡ATP', p.x, p.y);
                    ctx.globalAlpha = 1;
                } else if (p.type === 'co2') {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 80;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '8px Nunito';
                    ctx.fillText('CO₂', p.x, p.y - 8);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '14px Lora';
            ctx.textAlign = 'left';
            ctx.fillText('Metabolic Network Visualization', 20, 25);
        }

        function updateStats() {
            document.getElementById('atpBar').style.width = state.atpPool + '%';
            document.getElementById('atpLevel').textContent = Math.round(state.atpPool) + '% ATP';
            document.getElementById('atpProduced').textContent = state.atpProduced;
            document.getElementById('atpConsumed').textContent = state.atpConsumed;
            document.getElementById('flux').textContent = state.flux;

            const efficiency = state.atpConsumed > 0 ?
                Math.round((state.atpProduced / (state.atpConsumed + state.atpProduced)) * 100) : 0;
            document.getElementById('efficiency').textContent = efficiency + '%';

            // Update metabolite panel
            const panel = document.getElementById('metabolites');
            panel.innerHTML = nodes.slice(0, 6).map(n =>
                `<div class="metabolite" style="background:${n.color}">${n.name}</div>`
            ).join('');
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            state.time = 0;
            state.atpPool = 50;
            state.atpProduced = 0;
            state.atpConsumed = 0;
            particles = [];
            initNetwork();
            draw();
        }

        document.getElementById('mode').addEventListener('change', () => {
            initNetwork();
            draw();
        });

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('glucoseRateVal').textContent = document.getElementById('glucoseRate').value;
            document.getElementById('enzymeActivityVal').textContent = document.getElementById('enzymeActivity').value;
            document.getElementById('oxygenVal').textContent = document.getElementById('oxygen').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));

        initNetwork();
        draw();
    </script>
</body>
</html>
