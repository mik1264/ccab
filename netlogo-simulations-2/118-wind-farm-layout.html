<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wind Farm Layout - Wake Effect Optimization</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .back-link:hover { color: #BC6C25; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-primary:hover { background: #606C38; }
        .btn-secondary { background: #DDA15E; color: white; }
        .btn-secondary:hover { background: #BC6C25; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; font-family: 'Nunito', sans-serif; background: white; color: #606C38; }
        .wind-indicator { display: flex; align-items: center; justify-content: center; gap: 10px; padding: 10px; background: linear-gradient(135deg, #E3F2FD, #BBDEFB); border-radius: 8px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Wind Farm Layout Optimization</h1>
            <p class="subtitle">Wake effects, terrain influence, and capacity factor maximization</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="wind-indicator">
                    <span style="font-size:24px">üí®</span>
                    <span id="windInfo">Wind: 8 m/s from W</span>
                </div>
                <div class="control-group">
                    <label>Layout Strategy</label>
                    <select id="layout">
                        <option value="grid">Regular Grid</option>
                        <option value="staggered" selected>Staggered Grid</option>
                        <option value="optimized">Optimized Spacing</option>
                        <option value="random">Random Placement</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Number of Turbines</label>
                    <input type="range" id="turbineCount" min="6" max="25" value="12">
                    <div class="control-value"><span id="turbineCountVal">12</span></div>
                </div>
                <div class="control-group">
                    <label>Wind Direction (¬∞)</label>
                    <input type="range" id="windDir" min="0" max="359" value="270">
                    <div class="control-value"><span id="windDirVal">270</span>¬∞ (W)</div>
                </div>
                <div class="control-group">
                    <label>Wind Speed (m/s)</label>
                    <input type="range" id="windSpeed" min="3" max="15" value="8">
                    <div class="control-value"><span id="windSpeedVal">8</span></div>
                </div>
                <div class="control-group">
                    <label>Rotor Diameter (m)</label>
                    <input type="range" id="rotorDiam" min="80" max="180" value="120">
                    <div class="control-value"><span id="rotorDiamVal">120</span>m</div>
                </div>
                <button class="btn-primary" onclick="calculateOutput()">Calculate Output</button>
                <button class="btn-secondary" onclick="resetLayout()">Reset Layout</button>
                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="totalPower">0</div><div class="stat-label">Total Power (MW)</div></div>
                    <div class="stat-box"><div class="stat-value" id="avgWake">0%</div><div class="stat-label">Avg Wake Loss</div></div>
                    <div class="stat-box"><div class="stat-value" id="capacityFactor">0%</div><div class="stat-label">Capacity Factor</div></div>
                    <div class="stat-box"><div class="stat-value" id="efficiency">0%</div><div class="stat-label">Array Efficiency</div></div>
                </div>
                <div class="info-panel">
                    <strong>Jensen Wake Model:</strong> Velocity deficit spreads linearly with distance. Downstream turbines receive reduced wind speed proportional to wake overlap.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = (rect.width * 0.65) * dpr;
            canvas.style.height = (rect.width * 0.65) + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width * 0.65 };
        }
        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); draw(); });

        let turbines = [];

        function generateLayout() {
            const layout = document.getElementById('layout').value;
            const count = parseInt(document.getElementById('turbineCount').value);
            const rotorD = parseInt(document.getElementById('rotorDiam').value);
            turbines = [];

            const fieldW = dims.width * 0.6 - 40;
            const fieldH = dims.height - 80;
            const spacing = Math.min(rotorD * 5, Math.sqrt(fieldW * fieldH / count));

            switch (layout) {
                case 'grid':
                    const cols = Math.ceil(Math.sqrt(count));
                    const rows = Math.ceil(count / cols);
                    for (let i = 0; i < count; i++) {
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        turbines.push({
                            x: 50 + col * (fieldW / cols) + fieldW / cols / 2,
                            y: 50 + row * (fieldH / rows) + fieldH / rows / 2,
                            power: 0, wakeLoss: 0, rotation: 0
                        });
                    }
                    break;
                case 'staggered':
                    const sCols = Math.ceil(Math.sqrt(count));
                    const sRows = Math.ceil(count / sCols);
                    for (let i = 0; i < count; i++) {
                        const col = i % sCols;
                        const row = Math.floor(i / sCols);
                        const offset = row % 2 === 0 ? 0 : fieldW / sCols / 2;
                        turbines.push({
                            x: 50 + col * (fieldW / sCols) + fieldW / sCols / 2 + offset,
                            y: 50 + row * (fieldH / sRows) + fieldH / sRows / 2,
                            power: 0, wakeLoss: 0, rotation: 0
                        });
                    }
                    break;
                case 'optimized':
                    for (let i = 0; i < count; i++) {
                        let bestX, bestY, bestScore = -Infinity;
                        for (let attempt = 0; attempt < 50; attempt++) {
                            const x = 50 + Math.random() * fieldW;
                            const y = 50 + Math.random() * fieldH;
                            let score = 0;
                            turbines.forEach(t => {
                                const dist = Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2);
                                score += Math.min(dist / spacing, 1);
                            });
                            if (score > bestScore || turbines.length === 0) {
                                bestScore = score;
                                bestX = x;
                                bestY = y;
                            }
                        }
                        turbines.push({ x: bestX, y: bestY, power: 0, wakeLoss: 0, rotation: 0 });
                    }
                    break;
                case 'random':
                    for (let i = 0; i < count; i++) {
                        turbines.push({
                            x: 50 + Math.random() * fieldW,
                            y: 50 + Math.random() * fieldH,
                            power: 0, wakeLoss: 0, rotation: 0
                        });
                    }
                    break;
            }
        }

        function calculateWake(upstreamX, upstreamY, downstreamX, downstreamY, windDir, rotorD) {
            // Jensen wake model
            const windRad = windDir * Math.PI / 180;
            const dx = downstreamX - upstreamX;
            const dy = downstreamY - upstreamY;

            // Distance along wind direction
            const alongWind = dx * Math.cos(windRad) + dy * Math.sin(windRad);
            if (alongWind <= 0) return 0; // Upstream, no wake

            // Perpendicular distance
            const perpDist = Math.abs(-dx * Math.sin(windRad) + dy * Math.cos(windRad));

            // Wake expansion
            const k = 0.075; // Wake decay constant
            const wakeRadius = rotorD / 2 + k * alongWind;

            if (perpDist > wakeRadius) return 0; // Outside wake cone

            // Velocity deficit
            const Ct = 0.8; // Thrust coefficient
            const deficit = (1 - Math.sqrt(1 - Ct)) * Math.pow(rotorD / (2 * wakeRadius), 2);

            // Partial overlap
            const overlap = Math.max(0, 1 - perpDist / wakeRadius);

            return deficit * overlap;
        }

        function calculateOutput() {
            const windSpeed = parseInt(document.getElementById('windSpeed').value);
            const windDir = parseInt(document.getElementById('windDir').value);
            const rotorD = parseInt(document.getElementById('rotorDiam').value);

            // Power curve (simplified)
            function getPower(speed) {
                if (speed < 3) return 0;
                if (speed > 25) return 0;
                if (speed > 12) return 3; // Rated power
                return 3 * Math.pow((speed - 3) / 9, 3);
            }

            const freestreamPower = getPower(windSpeed);

            turbines.forEach((t, i) => {
                let totalDeficit = 0;

                // Sum wake effects from all upstream turbines
                turbines.forEach((upstream, j) => {
                    if (i !== j) {
                        const deficit = calculateWake(upstream.x, upstream.y, t.x, t.y, windDir, rotorD);
                        totalDeficit = 1 - (1 - totalDeficit) * (1 - deficit); // Combine deficits
                    }
                });

                const effectiveSpeed = windSpeed * (1 - totalDeficit);
                t.power = getPower(effectiveSpeed);
                t.wakeLoss = totalDeficit * 100;
            });

            const totalPower = turbines.reduce((s, t) => s + t.power, 0);
            const avgWake = turbines.reduce((s, t) => s + t.wakeLoss, 0) / turbines.length;
            const maxPower = turbines.length * freestreamPower;
            const efficiency = maxPower > 0 ? (totalPower / maxPower) * 100 : 0;
            const capacityFactor = (totalPower / (turbines.length * 3)) * 100;

            document.getElementById('totalPower').textContent = totalPower.toFixed(1);
            document.getElementById('avgWake').textContent = avgWake.toFixed(0) + '%';
            document.getElementById('capacityFactor').textContent = capacityFactor.toFixed(0) + '%';
            document.getElementById('efficiency').textContent = efficiency.toFixed(0) + '%';

            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, dims.width, dims.height);

            const windDir = parseInt(document.getElementById('windDir').value);
            const rotorD = parseInt(document.getElementById('rotorDiam').value);

            // Ground
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(20, 40, dims.width * 0.6, dims.height - 60);

            // Wind direction arrow
            const windRad = windDir * Math.PI / 180;
            const arrowX = dims.width * 0.35;
            const arrowY = dims.height - 30;
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(arrowX - Math.cos(windRad) * 40, arrowY - Math.sin(windRad) * 40);
            ctx.lineTo(arrowX + Math.cos(windRad) * 40, arrowY + Math.sin(windRad) * 40);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(arrowX + Math.cos(windRad) * 40, arrowY + Math.sin(windRad) * 40);
            ctx.lineTo(arrowX + Math.cos(windRad - 0.3) * 25, arrowY + Math.sin(windRad - 0.3) * 25);
            ctx.moveTo(arrowX + Math.cos(windRad) * 40, arrowY + Math.sin(windRad) * 40);
            ctx.lineTo(arrowX + Math.cos(windRad + 0.3) * 25, arrowY + Math.sin(windRad + 0.3) * 25);
            ctx.stroke();
            ctx.lineWidth = 1;

            // Draw wake zones
            ctx.globalAlpha = 0.2;
            turbines.forEach(t => {
                const wakeLen = 300;
                ctx.fillStyle = '#4682B4';
                ctx.beginPath();
                ctx.moveTo(t.x, t.y);
                ctx.lineTo(t.x + Math.cos(windRad - 0.3) * wakeLen, t.y + Math.sin(windRad - 0.3) * wakeLen);
                ctx.lineTo(t.x + Math.cos(windRad + 0.3) * wakeLen, t.y + Math.sin(windRad + 0.3) * wakeLen);
                ctx.closePath();
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw turbines
            turbines.forEach(t => {
                // Tower
                ctx.fillStyle = '#666';
                ctx.fillRect(t.x - 3, t.y - 20, 6, 40);

                // Nacelle
                ctx.fillStyle = '#eee';
                ctx.fillRect(t.x - 8, t.y - 25, 16, 10);

                // Blades (rotating)
                t.rotation += 0.05 * (1 - t.wakeLoss / 100);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                for (let b = 0; b < 3; b++) {
                    const angle = t.rotation + b * 2 * Math.PI / 3;
                    ctx.beginPath();
                    ctx.moveTo(t.x, t.y - 20);
                    ctx.lineTo(t.x + Math.cos(angle) * 25, t.y - 20 + Math.sin(angle) * 25);
                    ctx.stroke();
                }

                // Power indicator
                const powerColor = t.wakeLoss < 10 ? '#228B22' : t.wakeLoss < 30 ? '#FFD700' : '#FF6347';
                ctx.fillStyle = powerColor;
                ctx.beginPath();
                ctx.arc(t.x, t.y + 25, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.lineWidth = 1;

            // Stats panel
            const panelX = dims.width * 0.65;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(panelX, 40, dims.width * 0.3, dims.height - 60);

            ctx.fillStyle = '#606C38';
            ctx.font = '12px Nunito';
            ctx.fillText('Turbine Power Output', panelX + 10, 60);

            turbines.forEach((t, i) => {
                const y = 80 + i * 18;
                if (y < dims.height - 40) {
                    const barWidth = (t.power / 3) * 100;
                    ctx.fillStyle = '#E0E0E0';
                    ctx.fillRect(panelX + 10, y, 100, 12);
                    ctx.fillStyle = t.wakeLoss < 10 ? '#228B22' : t.wakeLoss < 30 ? '#DAA520' : '#BC6C25';
                    ctx.fillRect(panelX + 10, y, barWidth, 12);
                    ctx.fillStyle = '#333';
                    ctx.font = '9px Nunito';
                    ctx.fillText(`T${i + 1}: ${t.power.toFixed(1)}MW`, panelX + 115, y + 10);
                }
            });

            // Title
            ctx.fillStyle = '#606C38';
            ctx.font = '14px Lora';
            ctx.fillText(`Wind Farm Layout | ${turbines.length} Turbines`, 30, 28);
        }

        function resetLayout() {
            generateLayout();
            calculateOutput();
        }

        function updateSliderDisplays() {
            document.getElementById('turbineCountVal').textContent = document.getElementById('turbineCount').value;
            const dir = parseInt(document.getElementById('windDir').value);
            const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            document.getElementById('windDirVal').textContent = dir + '¬∞ (' + dirs[Math.round(dir / 45) % 8] + ')';
            document.getElementById('windSpeedVal').textContent = document.getElementById('windSpeed').value;
            document.getElementById('rotorDiamVal').textContent = document.getElementById('rotorDiam').value;

            const speed = document.getElementById('windSpeed').value;
            document.getElementById('windInfo').textContent = `Wind: ${speed} m/s from ${dirs[Math.round(dir / 45) % 8]}`;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', () => { updateSliderDisplays(); }));
        document.getElementById('layout').addEventListener('change', resetLayout);

        generateLayout();
        calculateOutput();
    </script>
</body>
</html>
