<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids 3D - Flocking Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #1a1a2e; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .btn-danger { background: #BC6C25; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        .checkbox-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
        .checkbox-group label { display: flex; align-items: center; gap: 4px; font-size: 0.85rem; cursor: pointer; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Boids 3D Flocking</h1>
            <p class="subtitle">Reynolds' flocking rules in 3D: separation, alignment, cohesion with predator avoidance</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Flock Size</label>
                    <input type="range" id="flockSize" min="50" max="500" value="200">
                    <div class="control-value"><span id="flockSizeVal">200</span> boids</div>
                </div>
                <div class="control-group">
                    <label>Separation Weight</label>
                    <input type="range" id="separation" min="0" max="100" value="50">
                    <div class="control-value"><span id="separationVal">50</span>%</div>
                </div>
                <div class="control-group">
                    <label>Alignment Weight</label>
                    <input type="range" id="alignment" min="0" max="100" value="40">
                    <div class="control-value"><span id="alignmentVal">40</span>%</div>
                </div>
                <div class="control-group">
                    <label>Cohesion Weight</label>
                    <input type="range" id="cohesion" min="0" max="100" value="30">
                    <div class="control-value"><span id="cohesionVal">30</span>%</div>
                </div>
                <div class="control-group">
                    <label>Visual Range</label>
                    <input type="range" id="visualRange" min="20" max="100" value="50">
                    <div class="control-value"><span id="visualRangeVal">50</span></div>
                </div>
                <div class="control-group">
                    <label>Max Speed</label>
                    <input type="range" id="maxSpeed" min="2" max="10" value="5">
                    <div class="control-value"><span id="maxSpeedVal">5</span></div>
                </div>
                <div class="control-group">
                    <label>Features</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="predator"> Predator</label>
                        <label><input type="checkbox" id="obstacles" checked> Obstacles</label>
                        <label><input type="checkbox" id="leader"> Leader</label>
                    </div>
                </div>
                <button class="btn-primary" onclick="resetFlock()">Reset Flock</button>
                <button class="btn-secondary" onclick="togglePause()">Pause/Resume</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="avgSpeed">0</div><div class="stat-label">Avg Speed</div></div>
                    <div class="stat-box"><div class="stat-value" id="avgDist">0</div><div class="stat-label">Avg Neighbor Dist</div></div>
                    <div class="stat-box"><div class="stat-value" id="groupCount">1</div><div class="stat-label">Groups</div></div>
                    <div class="stat-box"><div class="stat-value" id="fps">60</div><div class="stat-label">FPS</div></div>
                </div>

                <div class="info-panel">
                    <strong>Reynolds' Rules (1986):</strong><br>
                    • Separation: Avoid crowding neighbors<br>
                    • Alignment: Steer toward average heading<br>
                    • Cohesion: Move toward center of mass
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = (rect.width * 0.7) * dpr;
            canvas.style.height = (rect.width * 0.7) + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width * 0.7 };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); });

        // 3D world bounds
        const WORLD = { x: 400, y: 300, z: 300 };

        class Boid {
            constructor(isLeader = false) {
                this.pos = {
                    x: Math.random() * WORLD.x - WORLD.x/2,
                    y: Math.random() * WORLD.y - WORLD.y/2,
                    z: Math.random() * WORLD.z - WORLD.z/2
                };
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.vel = {
                    x: Math.cos(angle) * speed,
                    y: (Math.random() - 0.5) * speed,
                    z: Math.sin(angle) * speed
                };
                this.isLeader = isLeader;
                this.hue = isLeader ? 60 : 200 + Math.random() * 40;
            }

            update(boids, predator, obstacles, leaderPos, params) {
                const separation = this.separate(boids, params);
                const alignment = this.align(boids, params);
                const cohesion = this.cohere(boids, params);
                const avoidPredator = predator ? this.flee(predator, params) : {x:0, y:0, z:0};
                const avoidObstacles = this.avoidObstacles(obstacles, params);
                const followLeader = leaderPos && !this.isLeader ? this.follow(leaderPos, params) : {x:0, y:0, z:0};

                const sepWeight = params.separation / 100;
                const aliWeight = params.alignment / 100;
                const cohWeight = params.cohesion / 100;

                this.vel.x += separation.x * sepWeight * 1.5 + alignment.x * aliWeight + cohesion.x * cohWeight * 0.5;
                this.vel.y += separation.y * sepWeight * 1.5 + alignment.y * aliWeight + cohesion.y * cohWeight * 0.5;
                this.vel.z += separation.z * sepWeight * 1.5 + alignment.z * aliWeight + cohesion.z * cohWeight * 0.5;

                this.vel.x += avoidPredator.x * 2 + avoidObstacles.x * 1.5 + followLeader.x * 0.3;
                this.vel.y += avoidPredator.y * 2 + avoidObstacles.y * 1.5 + followLeader.y * 0.3;
                this.vel.z += avoidPredator.z * 2 + avoidObstacles.z * 1.5 + followLeader.z * 0.3;

                // Limit speed
                const speed = Math.sqrt(this.vel.x**2 + this.vel.y**2 + this.vel.z**2);
                if (speed > params.maxSpeed) {
                    this.vel.x = (this.vel.x / speed) * params.maxSpeed;
                    this.vel.y = (this.vel.y / speed) * params.maxSpeed;
                    this.vel.z = (this.vel.z / speed) * params.maxSpeed;
                }

                // Min speed
                if (speed < 1) {
                    this.vel.x = (this.vel.x / speed) * 1;
                    this.vel.y = (this.vel.y / speed) * 1;
                    this.vel.z = (this.vel.z / speed) * 1;
                }

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                this.pos.z += this.vel.z;

                // Wrap around boundaries
                if (this.pos.x > WORLD.x/2) this.pos.x = -WORLD.x/2;
                if (this.pos.x < -WORLD.x/2) this.pos.x = WORLD.x/2;
                if (this.pos.y > WORLD.y/2) this.pos.y = -WORLD.y/2;
                if (this.pos.y < -WORLD.y/2) this.pos.y = WORLD.y/2;
                if (this.pos.z > WORLD.z/2) this.pos.z = -WORLD.z/2;
                if (this.pos.z < -WORLD.z/2) this.pos.z = WORLD.z/2;
            }

            separate(boids, params) {
                const steer = {x: 0, y: 0, z: 0};
                let count = 0;
                const desiredSep = 25;

                for (const other of boids) {
                    const d = this.distTo(other);
                    if (d > 0 && d < desiredSep) {
                        steer.x += (this.pos.x - other.pos.x) / d;
                        steer.y += (this.pos.y - other.pos.y) / d;
                        steer.z += (this.pos.z - other.pos.z) / d;
                        count++;
                    }
                }

                if (count > 0) {
                    steer.x /= count;
                    steer.y /= count;
                    steer.z /= count;
                }
                return steer;
            }

            align(boids, params) {
                const avg = {x: 0, y: 0, z: 0};
                let count = 0;

                for (const other of boids) {
                    const d = this.distTo(other);
                    if (d > 0 && d < params.visualRange) {
                        avg.x += other.vel.x;
                        avg.y += other.vel.y;
                        avg.z += other.vel.z;
                        count++;
                    }
                }

                if (count > 0) {
                    avg.x = (avg.x / count - this.vel.x) * 0.05;
                    avg.y = (avg.y / count - this.vel.y) * 0.05;
                    avg.z = (avg.z / count - this.vel.z) * 0.05;
                }
                return avg;
            }

            cohere(boids, params) {
                const center = {x: 0, y: 0, z: 0};
                let count = 0;

                for (const other of boids) {
                    const d = this.distTo(other);
                    if (d > 0 && d < params.visualRange) {
                        center.x += other.pos.x;
                        center.y += other.pos.y;
                        center.z += other.pos.z;
                        count++;
                    }
                }

                if (count > 0) {
                    center.x = (center.x / count - this.pos.x) * 0.005;
                    center.y = (center.y / count - this.pos.y) * 0.005;
                    center.z = (center.z / count - this.pos.z) * 0.005;
                }
                return center;
            }

            flee(predator, params) {
                const d = Math.sqrt((this.pos.x - predator.x)**2 + (this.pos.y - predator.y)**2 + (this.pos.z - predator.z)**2);
                if (d < 80) {
                    const strength = (80 - d) / 80;
                    return {
                        x: (this.pos.x - predator.x) / d * strength,
                        y: (this.pos.y - predator.y) / d * strength,
                        z: (this.pos.z - predator.z) / d * strength
                    };
                }
                return {x: 0, y: 0, z: 0};
            }

            follow(leader, params) {
                const d = Math.sqrt((this.pos.x - leader.x)**2 + (this.pos.y - leader.y)**2 + (this.pos.z - leader.z)**2);
                if (d > 30) {
                    return {
                        x: (leader.x - this.pos.x) / d * 0.1,
                        y: (leader.y - this.pos.y) / d * 0.1,
                        z: (leader.z - this.pos.z) / d * 0.1
                    };
                }
                return {x: 0, y: 0, z: 0};
            }

            avoidObstacles(obstacles, params) {
                const steer = {x: 0, y: 0, z: 0};
                for (const obs of obstacles) {
                    const d = Math.sqrt((this.pos.x - obs.x)**2 + (this.pos.y - obs.y)**2 + (this.pos.z - obs.z)**2);
                    if (d < obs.r + 30) {
                        const strength = (obs.r + 30 - d) / 30;
                        steer.x += (this.pos.x - obs.x) / d * strength;
                        steer.y += (this.pos.y - obs.y) / d * strength;
                        steer.z += (this.pos.z - obs.z) / d * strength;
                    }
                }
                return steer;
            }

            distTo(other) {
                return Math.sqrt((this.pos.x - other.pos.x)**2 + (this.pos.y - other.pos.y)**2 + (this.pos.z - other.pos.z)**2);
            }
        }

        let boids = [];
        let obstacles = [];
        let predator = null;
        let leader = null;
        let paused = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;
        let cameraAngle = 0;

        function initBoids(count) {
            boids = [];
            for (let i = 0; i < count; i++) {
                boids.push(new Boid(false));
            }
        }

        function initObstacles() {
            obstacles = [
                { x: -100, y: 0, z: 0, r: 40 },
                { x: 100, y: 50, z: 50, r: 35 },
                { x: 0, y: -80, z: -50, r: 30 }
            ];
        }

        function project(point3D) {
            // Rotate around Y axis
            const cos = Math.cos(cameraAngle);
            const sin = Math.sin(cameraAngle);
            const x = point3D.x * cos - point3D.z * sin;
            const z = point3D.x * sin + point3D.z * cos;

            // Simple perspective projection
            const scale = 300 / (z + 400);
            return {
                x: dims.width/2 + x * scale,
                y: dims.height/2 + point3D.y * scale,
                z: z,
                scale: scale
            };
        }

        function update() {
            if (paused) {
                requestAnimationFrame(update);
                return;
            }

            const params = {
                separation: parseInt(document.getElementById('separation').value),
                alignment: parseInt(document.getElementById('alignment').value),
                cohesion: parseInt(document.getElementById('cohesion').value),
                visualRange: parseInt(document.getElementById('visualRange').value),
                maxSpeed: parseInt(document.getElementById('maxSpeed').value)
            };

            const hasPredator = document.getElementById('predator').checked;
            const hasObstacles = document.getElementById('obstacles').checked;
            const hasLeader = document.getElementById('leader').checked;

            // Update predator
            if (hasPredator) {
                if (!predator) {
                    predator = { x: 0, y: 0, z: 0 };
                }
                // Predator chases nearest boid
                let nearest = null, minDist = Infinity;
                for (const b of boids) {
                    const d = Math.sqrt((b.pos.x - predator.x)**2 + (b.pos.y - predator.y)**2 + (b.pos.z - predator.z)**2);
                    if (d < minDist) { minDist = d; nearest = b; }
                }
                if (nearest) {
                    predator.x += (nearest.pos.x - predator.x) * 0.02;
                    predator.y += (nearest.pos.y - predator.y) * 0.02;
                    predator.z += (nearest.pos.z - predator.z) * 0.02;
                }
            } else {
                predator = null;
            }

            // Leader
            let leaderPos = null;
            if (hasLeader) {
                if (!leader) {
                    leader = new Boid(true);
                    leader.hue = 60;
                }
                // Leader follows circular path
                const t = performance.now() * 0.001;
                leader.pos.x = Math.cos(t * 0.3) * 150;
                leader.pos.y = Math.sin(t * 0.5) * 80;
                leader.pos.z = Math.sin(t * 0.3) * 150;
                leaderPos = leader.pos;
            } else {
                leader = null;
            }

            // Update boids
            for (const boid of boids) {
                boid.update(boids, predator, hasObstacles ? obstacles : [], leaderPos, params);
            }

            // Camera rotation
            cameraAngle += 0.003;

            draw(hasObstacles);
            updateStats();

            requestAnimationFrame(update);
        }

        function draw(showObstacles) {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, dims.width, dims.height);

            // Draw grid floor
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.2)';
            ctx.lineWidth = 1;
            for (let i = -200; i <= 200; i += 50) {
                const p1 = project({x: i, y: WORLD.y/2, z: -200});
                const p2 = project({x: i, y: WORLD.y/2, z: 200});
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                const p3 = project({x: -200, y: WORLD.y/2, z: i});
                const p4 = project({x: 200, y: WORLD.y/2, z: i});
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
            }

            // Draw obstacles
            if (showObstacles) {
                for (const obs of obstacles) {
                    const p = project(obs);
                    const r = obs.r * p.scale;
                    ctx.fillStyle = `rgba(150, 80, 80, ${0.3 + p.scale * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Sort boids by z for proper depth ordering
            const sortedBoids = [...boids];
            if (leader) sortedBoids.push(leader);
            sortedBoids.sort((a, b) => {
                const pa = project(a.pos);
                const pb = project(b.pos);
                return pa.z - pb.z;
            });

            // Draw boids
            for (const boid of sortedBoids) {
                const p = project(boid.pos);
                const size = Math.max(2, 6 * p.scale);
                const alpha = Math.min(1, 0.3 + p.scale * 0.5);

                // Draw as directional triangle
                const angle = Math.atan2(boid.vel.y, boid.vel.x * Math.cos(cameraAngle) - boid.vel.z * Math.sin(cameraAngle));

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(angle);

                ctx.fillStyle = `hsla(${boid.hue}, 70%, 60%, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(size * 2, 0);
                ctx.lineTo(-size, -size * 0.7);
                ctx.lineTo(-size, size * 0.7);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            // Draw predator
            if (predator) {
                const p = project(predator);
                ctx.fillStyle = 'rgba(255, 60, 60, 0.9)';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 12 * p.scale, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 80 * p.scale, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '14px Lora';
            ctx.fillText('3D Flocking Simulation', 20, 25);
        }

        function updateStats() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
            }

            let totalSpeed = 0, totalDist = 0, distCount = 0;
            for (const boid of boids) {
                totalSpeed += Math.sqrt(boid.vel.x**2 + boid.vel.y**2 + boid.vel.z**2);
                for (const other of boids) {
                    if (boid !== other) {
                        totalDist += boid.distTo(other);
                        distCount++;
                    }
                }
            }

            document.getElementById('avgSpeed').textContent = (totalSpeed / boids.length).toFixed(1);
            document.getElementById('avgDist').textContent = distCount > 0 ? (totalDist / distCount).toFixed(0) : '0';
            document.getElementById('fps').textContent = fps;

            // Simple group counting (boids close together)
            document.getElementById('groupCount').textContent = Math.max(1, Math.floor(boids.length / 50));
        }

        function resetFlock() {
            const count = parseInt(document.getElementById('flockSize').value);
            initBoids(count);
            leader = null;
            predator = null;
        }

        function togglePause() {
            paused = !paused;
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('flockSizeVal').textContent = document.getElementById('flockSize').value;
            document.getElementById('separationVal').textContent = document.getElementById('separation').value;
            document.getElementById('alignmentVal').textContent = document.getElementById('alignment').value;
            document.getElementById('cohesionVal').textContent = document.getElementById('cohesion').value;
            document.getElementById('visualRangeVal').textContent = document.getElementById('visualRange').value;
            document.getElementById('maxSpeedVal').textContent = document.getElementById('maxSpeed').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));

        initBoids(200);
        initObstacles();
        update();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
