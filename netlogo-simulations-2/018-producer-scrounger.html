<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Producer-Scrounger Game</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        h1 { color: var(--dark-moss); font-size: 1.8em; margin-bottom: 5px; }
        .subtitle { color: var(--moss); font-size: 1em; }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section { margin-bottom: 20px; }
        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group { margin-bottom: 12px; }
        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .button-group { display: flex; gap: 8px; margin-top: 15px; }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
        }

        .btn-primary { background: var(--sage); color: white; }
        .btn-primary:hover { background: var(--moss); }
        .btn-secondary { background: var(--earth); color: white; }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight { border-left-color: var(--terracotta); }
        .stat-box.success { border-left-color: #4CAF50; }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Producer-Scrounger Game</h1>
            <p class="subtitle">Frequency-Dependent Foraging Strategies & ESS</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Population</h3>
                    <div class="control-group">
                        <label>Group Size: <span id="groupSizeVal">30</span></label>
                        <input type="range" id="groupSize" min="10" max="100" value="30" step="5">
                    </div>
                    <div class="control-group">
                        <label>Initial Producer %: <span id="initProdVal">50</span></label>
                        <input type="range" id="initProd" min="10" max="90" value="50" step="5">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Resource Dynamics</h3>
                    <div class="control-group">
                        <label>Food Patches: <span id="numPatchesVal">20</span></label>
                        <input type="range" id="numPatches" min="5" max="50" value="20">
                    </div>
                    <div class="control-group">
                        <label>Patch Size (a): <span id="patchSizeVal">10</span></label>
                        <input type="range" id="patchSize" min="2" max="30" value="10">
                        <div class="value">food items per patch</div>
                    </div>
                    <div class="control-group">
                        <label>Finder's Share (F): <span id="finderShareVal">0.30</span></label>
                        <input type="range" id="finderShare" min="5" max="95" value="30">
                        <div class="value">proportion kept by finder</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Evolution</h3>
                    <div class="control-group">
                        <label>Strategy Updating:</label>
                        <select id="updateRule">
                            <option value="replicator">Replicator Dynamics</option>
                            <option value="imitation">Imitate Best</option>
                            <option value="learning">Individual Learning</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Update Rate: <span id="updateRateVal">0.10</span></label>
                        <input type="range" id="updateRate" min="1" max="50" value="10">
                    </div>
                    <div class="control-group">
                        <label>Mutation Rate: <span id="mutRateVal">0.02</span></label>
                        <input type="range" id="mutRate" min="0" max="20" value="2">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box">
                    <strong>Producer-Scrounger Game:</strong><br>
                    Producers find food but share it; Scroungers exploit discoveries. At equilibrium (ESS), both strategies have equal payoffs.
                    <br><br>
                    <em>ESS prediction: p* = F × a / (a - 1)</em>
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Foraging Arena</h3>
                    <canvas id="arenaCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>Producers</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E91E63;"></div>
                            <span>Scroungers</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>Food Patches</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Strategy Frequency Over Time</h3>
                        <canvas id="frequencyCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Strategy Payoffs</h3>
                        <canvas id="payoffCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>ESS Convergence</h3>
                        <canvas id="essCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Payoff Difference</h3>
                        <canvas id="diffCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Producer %</div>
                        <div class="value" id="prodStat">50%</div>
                    </div>
                    <div class="stat-box success">
                        <div class="label">ESS Prediction</div>
                        <div class="value" id="essStat">--</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Producer Payoff</div>
                        <div class="value" id="prodPayStat">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Scrounger Payoff</div>
                        <div class="value" id="scrPayStat">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">At ESS?</div>
                        <div class="value" id="atEssStat">No</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Frequency-Dependent Selection</h3>
                    <canvas id="fdsCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const payoffCanvas = document.getElementById('payoffCanvas');
        const essCanvas = document.getElementById('essCanvas');
        const diffCanvas = document.getElementById('diffCanvas');
        const fdsCanvas = document.getElementById('fdsCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const frequencyCtx = frequencyCanvas.getContext('2d');
        const payoffCtx = payoffCanvas.getContext('2d');
        const essCtx = essCanvas.getContext('2d');
        const diffCtx = diffCanvas.getContext('2d');
        const fdsCtx = fdsCanvas.getContext('2d');

        // Parameters
        let groupSize = 30;
        let initProd = 50;
        let numPatches = 20;
        let patchSize = 10;
        let finderShare = 0.30;
        let updateRule = 'replicator';
        let updateRate = 0.10;
        let mutRate = 0.02;

        // State
        let foragers = [];
        let patches = [];
        let generation = 0;
        let frequencyHistory = [];
        let payoffHistory = [];
        let running = false;
        let animationId = null;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function calculateESS() {
            // ESS producer proportion: p* where payoffs equal
            // For simple model: p* = F (finder's share)
            // More complex: p* depends on a, F, and group structure
            return finderShare;
        }

        function initSimulation() {
            generation = 0;
            frequencyHistory = [];
            payoffHistory = [];

            // Create foragers
            foragers = [];
            const numProducers = Math.round(groupSize * initProd / 100);

            for (let i = 0; i < groupSize; i++) {
                foragers.push({
                    id: i,
                    isProducer: i < numProducers,
                    x: Math.random(),
                    y: Math.random(),
                    payoff: 0,
                    totalPayoff: 0
                });
            }

            // Create initial patches
            generatePatches();
        }

        function generatePatches() {
            patches = [];
            for (let i = 0; i < numPatches; i++) {
                patches.push({
                    x: Math.random(),
                    y: Math.random(),
                    food: patchSize,
                    discovered: false,
                    finder: null
                });
            }
        }

        function getProducerCount() {
            return foragers.filter(f => f.isProducer).length;
        }

        function getProducerProportion() {
            return getProducerCount() / groupSize;
        }

        function forage() {
            // Reset payoffs
            for (const f of foragers) {
                f.payoff = 0;
            }

            // Producers search for patches
            const producers = foragers.filter(f => f.isProducer);
            const scroungers = foragers.filter(f => !f.isProducer);

            // Each producer has a chance to find a patch
            const undiscovered = patches.filter(p => !p.discovered);

            for (const prod of producers) {
                if (undiscovered.length === 0) break;

                // Find nearby undiscovered patch
                const findProb = undiscovered.length / numPatches;
                if (Math.random() < findProb) {
                    const patch = undiscovered[Math.floor(Math.random() * undiscovered.length)];
                    patch.discovered = true;
                    patch.finder = prod.id;

                    // Finder gets finder's share
                    const finderFood = patch.food * finderShare;
                    prod.payoff += finderFood;
                    prod.x = patch.x + (Math.random() - 0.5) * 0.05;
                    prod.y = patch.y + (Math.random() - 0.5) * 0.05;

                    // Remaining food shared with scroungers
                    const remaining = patch.food - finderFood;
                    const numScroungers = scroungers.length;

                    if (numScroungers > 0 && remaining > 0) {
                        const sharePerScrounger = remaining / numScroungers;
                        for (const scr of scroungers) {
                            scr.payoff += sharePerScrounger;
                            // Move scrounger toward patch
                            scr.x = patch.x + (Math.random() - 0.5) * 0.1;
                            scr.y = patch.y + (Math.random() - 0.5) * 0.1;
                        }
                    }
                }
            }

            // Update total payoffs
            for (const f of foragers) {
                f.totalPayoff += f.payoff;
            }

            // Reset patches for next round
            generatePatches();
        }

        function updateStrategies() {
            const prodPayoff = getAveragePayoff(true);
            const scrPayoff = getAveragePayoff(false);

            if (updateRule === 'replicator') {
                // Replicator dynamics
                for (const f of foragers) {
                    if (Math.random() > updateRate) continue;

                    const otherPayoff = f.isProducer ? scrPayoff : prodPayoff;
                    const myPayoff = f.isProducer ? prodPayoff : scrPayoff;

                    // Switch if other strategy is better
                    if (otherPayoff > myPayoff) {
                        const switchProb = (otherPayoff - myPayoff) / (patchSize * finderShare + 1);
                        if (Math.random() < switchProb) {
                            f.isProducer = !f.isProducer;
                        }
                    }
                }
            } else if (updateRule === 'imitation') {
                // Imitate best neighbor
                for (const f of foragers) {
                    if (Math.random() > updateRate) continue;

                    const other = foragers[Math.floor(Math.random() * foragers.length)];
                    if (other.payoff > f.payoff) {
                        f.isProducer = other.isProducer;
                    }
                }
            } else {
                // Individual learning - sample strategies
                for (const f of foragers) {
                    if (Math.random() > updateRate) continue;

                    const expected = f.isProducer ? prodPayoff : scrPayoff;
                    if (f.payoff < expected * 0.8) {
                        // Try switching
                        if (Math.random() < 0.5) {
                            f.isProducer = !f.isProducer;
                        }
                    }
                }
            }

            // Mutation
            for (const f of foragers) {
                if (Math.random() < mutRate) {
                    f.isProducer = !f.isProducer;
                }
            }
        }

        function getAveragePayoff(isProducer) {
            const group = foragers.filter(f => f.isProducer === isProducer);
            if (group.length === 0) return 0;
            return group.reduce((s, f) => s + f.payoff, 0) / group.length;
        }

        function step() {
            forage();
            updateStrategies();
            generation++;

            // Record history
            const prodProp = getProducerProportion();
            const prodPayoff = getAveragePayoff(true);
            const scrPayoff = getAveragePayoff(false);

            frequencyHistory.push({ gen: generation, prod: prodProp });
            payoffHistory.push({ gen: generation, prod: prodPayoff, scr: scrPayoff });

            if (frequencyHistory.length > 300) {
                frequencyHistory = frequencyHistory.filter((_, i) => i % 2 === 0);
                payoffHistory = payoffHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawArena() {
            const width = arenaCanvas.width / (window.devicePixelRatio || 1);
            const height = arenaCanvas.height / (window.devicePixelRatio || 1);

            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, width, height);

            const padding = 20;
            const size = Math.min(width, height) - 2 * padding;
            const offsetX = (width - size) / 2;
            const offsetY = (height - size) / 2;

            // Draw patches
            for (const p of patches) {
                const x = offsetX + p.x * size;
                const y = offsetY + p.y * size;

                arenaCtx.fillStyle = p.discovered ? '#FFC10788' : '#FFC10733';
                arenaCtx.beginPath();
                arenaCtx.arc(x, y, 15, 0, Math.PI * 2);
                arenaCtx.fill();
            }

            // Draw foragers
            for (const f of foragers) {
                const x = offsetX + f.x * size;
                const y = offsetY + f.y * size;

                arenaCtx.fillStyle = f.isProducer ? '#4CAF50' : '#E91E63';
                arenaCtx.beginPath();
                arenaCtx.arc(x, y, 8, 0, Math.PI * 2);
                arenaCtx.fill();

                arenaCtx.strokeStyle = '#fff';
                arenaCtx.lineWidth = 1;
                arenaCtx.stroke();
            }

            // Stats
            arenaCtx.fillStyle = '#ffffffaa';
            arenaCtx.font = '11px sans-serif';
            arenaCtx.fillText(`Producers: ${getProducerCount()} | Scroungers: ${groupSize - getProducerCount()}`, padding, height - 10);
        }

        function drawFrequency() {
            const width = frequencyCanvas.width / (window.devicePixelRatio || 1);
            const height = frequencyCanvas.height / (window.devicePixelRatio || 1);

            frequencyCtx.fillStyle = '#1a1a2e';
            frequencyCtx.fillRect(0, 0, width, height);

            if (frequencyHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxGen = frequencyHistory[frequencyHistory.length - 1].gen;
            const ess = calculateESS();

            // ESS line
            frequencyCtx.strokeStyle = '#E91E63';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.setLineDash([5, 5]);
            const essY = height - padding - ess * graphHeight;
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(padding, essY);
            frequencyCtx.lineTo(width - padding, essY);
            frequencyCtx.stroke();
            frequencyCtx.setLineDash([]);

            // Producer frequency
            frequencyCtx.strokeStyle = '#4CAF50';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.beginPath();

            frequencyHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - point.prod * graphHeight;

                if (i === 0) {
                    frequencyCtx.moveTo(x, y);
                } else {
                    frequencyCtx.lineTo(x, y);
                }
            });
            frequencyCtx.stroke();

            // Axes
            frequencyCtx.strokeStyle = '#ffffff44';
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(padding, padding);
            frequencyCtx.lineTo(padding, height - padding);
            frequencyCtx.lineTo(width - padding, height - padding);
            frequencyCtx.stroke();

            frequencyCtx.fillStyle = '#ffffffaa';
            frequencyCtx.font = '10px sans-serif';
            frequencyCtx.fillText('Producer Freq', padding + 5, padding - 5);

            frequencyCtx.fillStyle = '#E91E63';
            frequencyCtx.fillText(`ESS = ${(ess * 100).toFixed(0)}%`, width - padding - 60, essY - 5);
        }

        function drawPayoff() {
            const width = payoffCanvas.width / (window.devicePixelRatio || 1);
            const height = payoffCanvas.height / (window.devicePixelRatio || 1);

            payoffCtx.fillStyle = '#1a1a2e';
            payoffCtx.fillRect(0, 0, width, height);

            if (payoffHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxGen = payoffHistory[payoffHistory.length - 1].gen;
            const maxPay = Math.max(...payoffHistory.map(p => Math.max(p.prod, p.scr)), 1);

            // Producer payoff
            payoffCtx.strokeStyle = '#4CAF50';
            payoffCtx.lineWidth = 2;
            payoffCtx.beginPath();

            payoffHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.prod / maxPay) * graphHeight;

                if (i === 0) {
                    payoffCtx.moveTo(x, y);
                } else {
                    payoffCtx.lineTo(x, y);
                }
            });
            payoffCtx.stroke();

            // Scrounger payoff
            payoffCtx.strokeStyle = '#E91E63';
            payoffCtx.beginPath();

            payoffHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.scr / maxPay) * graphHeight;

                if (i === 0) {
                    payoffCtx.moveTo(x, y);
                } else {
                    payoffCtx.lineTo(x, y);
                }
            });
            payoffCtx.stroke();

            // Axes
            payoffCtx.strokeStyle = '#ffffff44';
            payoffCtx.beginPath();
            payoffCtx.moveTo(padding, padding);
            payoffCtx.lineTo(padding, height - padding);
            payoffCtx.lineTo(width - padding, height - padding);
            payoffCtx.stroke();

            payoffCtx.fillStyle = '#ffffffaa';
            payoffCtx.font = '10px sans-serif';
            payoffCtx.fillText('Payoffs', padding + 5, padding - 5);

            // Legend
            payoffCtx.fillStyle = '#4CAF50';
            payoffCtx.fillText('Producer', width - padding - 100, padding + 15);
            payoffCtx.fillStyle = '#E91E63';
            payoffCtx.fillText('Scrounger', width - padding - 100, padding + 30);
        }

        function drawESS() {
            const width = essCanvas.width / (window.devicePixelRatio || 1);
            const height = essCanvas.height / (window.devicePixelRatio || 1);

            essCtx.fillStyle = '#1a1a2e';
            essCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw phase diagram
            // X = producer freq, Y = payoff difference

            essCtx.strokeStyle = '#ffffff44';
            essCtx.beginPath();
            essCtx.moveTo(padding, height / 2);
            essCtx.lineTo(width - padding, height / 2);
            essCtx.moveTo(width / 2, padding);
            essCtx.lineTo(width / 2, height - padding);
            essCtx.stroke();

            // Draw theoretical payoff difference curve
            essCtx.strokeStyle = '#9C27B0';
            essCtx.lineWidth = 2;
            essCtx.beginPath();

            for (let p = 0; p <= 1; p += 0.02) {
                // Payoff difference (prod - scr) as function of p
                // At ESS, this equals zero
                const prodPay = finderShare * patchSize * (numPatches / (p * groupSize + 0.1));
                const scrPay = (1 - finderShare) * patchSize * (numPatches / (groupSize + 0.1));
                const diff = prodPay - scrPay;

                const x = padding + p * graphWidth;
                const y = height / 2 - (diff / (patchSize * 2)) * graphHeight;

                if (p === 0) {
                    essCtx.moveTo(x, y);
                } else {
                    essCtx.lineTo(x, y);
                }
            }
            essCtx.stroke();

            // Current position
            const currentP = getProducerProportion();
            const currentProdPay = getAveragePayoff(true);
            const currentScrPay = getAveragePayoff(false);
            const currentDiff = currentProdPay - currentScrPay;

            const cx = padding + currentP * graphWidth;
            const cy = height / 2 - (currentDiff / (patchSize * 2)) * graphHeight;

            essCtx.fillStyle = '#FFC107';
            essCtx.beginPath();
            essCtx.arc(cx, cy, 8, 0, Math.PI * 2);
            essCtx.fill();

            essCtx.fillStyle = '#ffffffaa';
            essCtx.font = '10px sans-serif';
            essCtx.fillText('Producer Frequency', width / 2 - 40, height - 10);
            essCtx.fillText('Payoff Diff', 5, height / 2 - 5);
            essCtx.fillText('(Prod - Scr)', 5, height / 2 + 10);
        }

        function drawDiff() {
            const width = diffCanvas.width / (window.devicePixelRatio || 1);
            const height = diffCanvas.height / (window.devicePixelRatio || 1);

            diffCtx.fillStyle = '#1a1a2e';
            diffCtx.fillRect(0, 0, width, height);

            if (payoffHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxGen = payoffHistory[payoffHistory.length - 1].gen;
            const diffs = payoffHistory.map(p => p.prod - p.scr);
            const maxDiff = Math.max(...diffs.map(Math.abs), 0.1);

            // Zero line
            diffCtx.strokeStyle = '#4CAF50';
            diffCtx.lineWidth = 2;
            diffCtx.setLineDash([5, 5]);
            diffCtx.beginPath();
            diffCtx.moveTo(padding, height / 2);
            diffCtx.lineTo(width - padding, height / 2);
            diffCtx.stroke();
            diffCtx.setLineDash([]);

            // Difference line
            diffCtx.strokeStyle = '#FFC107';
            diffCtx.lineWidth = 2;
            diffCtx.beginPath();

            payoffHistory.forEach((point, i) => {
                const diff = point.prod - point.scr;
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height / 2 - (diff / maxDiff) * (graphHeight / 2);

                if (i === 0) {
                    diffCtx.moveTo(x, y);
                } else {
                    diffCtx.lineTo(x, y);
                }
            });
            diffCtx.stroke();

            // Axes
            diffCtx.strokeStyle = '#ffffff44';
            diffCtx.beginPath();
            diffCtx.moveTo(padding, padding);
            diffCtx.lineTo(padding, height - padding);
            diffCtx.lineTo(width - padding, height - padding);
            diffCtx.stroke();

            diffCtx.fillStyle = '#ffffffaa';
            diffCtx.font = '10px sans-serif';
            diffCtx.fillText('Payoff Difference', padding + 5, padding - 5);
            diffCtx.fillStyle = '#4CAF50';
            diffCtx.fillText('ESS = 0', width - padding - 50, height / 2 - 5);
        }

        function drawFDS() {
            const width = fdsCanvas.width / (window.devicePixelRatio || 1);
            const height = fdsCanvas.height / (window.devicePixelRatio || 1);

            fdsCtx.fillStyle = '#1a1a2e';
            fdsCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw payoff curves as function of producer frequency
            // Producer payoff (green)
            fdsCtx.strokeStyle = '#4CAF50';
            fdsCtx.lineWidth = 2;
            fdsCtx.beginPath();

            for (let p = 0.05; p <= 0.95; p += 0.02) {
                // Simplified model: more producers = less per discovery
                const numProd = p * groupSize;
                const numScr = (1 - p) * groupSize;
                const discoveryRate = numPatches / numProd;
                const prodPay = finderShare * patchSize * discoveryRate;

                const x = padding + p * graphWidth;
                const y = height - padding - (prodPay / (patchSize * 2)) * graphHeight;

                if (p === 0.05) {
                    fdsCtx.moveTo(x, y);
                } else {
                    fdsCtx.lineTo(x, y);
                }
            }
            fdsCtx.stroke();

            // Scrounger payoff (pink) - increases with producer frequency
            fdsCtx.strokeStyle = '#E91E63';
            fdsCtx.beginPath();

            for (let p = 0.05; p <= 0.95; p += 0.02) {
                const numProd = p * groupSize;
                const numScr = Math.max(1, (1 - p) * groupSize);
                const discoveryRate = numPatches / numProd;
                const scrPay = (1 - finderShare) * patchSize * discoveryRate / numScr * numProd;

                const x = padding + p * graphWidth;
                const y = height - padding - (scrPay / (patchSize * 2)) * graphHeight;

                if (p === 0.05) {
                    fdsCtx.moveTo(x, y);
                } else {
                    fdsCtx.lineTo(x, y);
                }
            }
            fdsCtx.stroke();

            // ESS vertical line
            const ess = calculateESS();
            const essX = padding + ess * graphWidth;
            fdsCtx.strokeStyle = '#ffffffaa';
            fdsCtx.setLineDash([5, 5]);
            fdsCtx.beginPath();
            fdsCtx.moveTo(essX, padding);
            fdsCtx.lineTo(essX, height - padding);
            fdsCtx.stroke();
            fdsCtx.setLineDash([]);

            // Current position
            const currentP = getProducerProportion();
            const currentX = padding + currentP * graphWidth;
            fdsCtx.fillStyle = '#FFC107';
            fdsCtx.beginPath();
            fdsCtx.arc(currentX, height - padding, 6, 0, Math.PI * 2);
            fdsCtx.fill();

            // Axes
            fdsCtx.strokeStyle = '#ffffff44';
            fdsCtx.beginPath();
            fdsCtx.moveTo(padding, padding);
            fdsCtx.lineTo(padding, height - padding);
            fdsCtx.lineTo(width - padding, height - padding);
            fdsCtx.stroke();

            fdsCtx.fillStyle = '#ffffffaa';
            fdsCtx.font = '10px sans-serif';
            fdsCtx.fillText('Payoff', 5, padding + 10);
            fdsCtx.textAlign = 'center';
            fdsCtx.fillText('Producer Frequency', width / 2, height - 5);
            fdsCtx.fillText('ESS', essX, padding - 5);

            // Legend
            fdsCtx.textAlign = 'left';
            fdsCtx.fillStyle = '#4CAF50';
            fdsCtx.fillText('Producer payoff', padding + 10, padding + 15);
            fdsCtx.fillStyle = '#E91E63';
            fdsCtx.fillText('Scrounger payoff', padding + 10, padding + 30);
        }

        function updateStats() {
            const prodProp = getProducerProportion();
            const ess = calculateESS();
            const prodPay = getAveragePayoff(true);
            const scrPay = getAveragePayoff(false);
            const atEss = Math.abs(prodProp - ess) < 0.1;

            document.getElementById('genStat').textContent = generation;
            document.getElementById('prodStat').textContent = (prodProp * 100).toFixed(0) + '%';
            document.getElementById('essStat').textContent = (ess * 100).toFixed(0) + '%';
            document.getElementById('prodPayStat').textContent = prodPay.toFixed(2);
            document.getElementById('scrPayStat').textContent = scrPay.toFixed(2);
            document.getElementById('atEssStat').textContent = atEss ? 'Yes!' : 'No';
            document.getElementById('atEssStat').style.color = atEss ? '#4CAF50' : 'inherit';
        }

        function animate() {
            step();

            drawArena();
            drawFrequency();
            drawPayoff();
            drawESS();
            drawDiff();
            drawFDS();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            groupSize = parseInt(document.getElementById('groupSize').value);
            initProd = parseInt(document.getElementById('initProd').value);
            numPatches = parseInt(document.getElementById('numPatches').value);
            patchSize = parseInt(document.getElementById('patchSize').value);
            finderShare = parseInt(document.getElementById('finderShare').value) / 100;
            updateRule = document.getElementById('updateRule').value;
            updateRate = parseInt(document.getElementById('updateRate').value) / 100;
            mutRate = parseInt(document.getElementById('mutRate').value) / 100;

            initSimulation();
            drawArena();
            drawFrequency();
            drawPayoff();
            drawESS();
            drawDiff();
            drawFDS();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        ['groupSize', 'initProd', 'numPatches', 'patchSize', 'finderShare', 'updateRate', 'mutRate'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                const suffix = id === 'finderShare' || id === 'updateRate' || id === 'mutRate' ?
                    (e.target.value / 100).toFixed(2) : e.target.value;
                document.getElementById(id + 'Val').textContent = suffix;
            });
        });

        // Initialize
        function init() {
            setupCanvas(arenaCanvas, arenaCtx, 280);
            setupCanvas(frequencyCanvas, frequencyCtx, 180);
            setupCanvas(payoffCanvas, payoffCtx, 180);
            setupCanvas(essCanvas, essCtx, 180);
            setupCanvas(diffCanvas, diffCtx, 180);
            setupCanvas(fdsCanvas, fdsCtx, 150);

            initSimulation();
            drawArena();
            drawFrequency();
            drawPayoff();
            drawESS();
            drawDiff();
            drawFDS();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(arenaCanvas, arenaCtx, 280);
            setupCanvas(frequencyCanvas, frequencyCtx, 180);
            setupCanvas(payoffCanvas, payoffCtx, 180);
            setupCanvas(essCanvas, essCtx, 180);
            setupCanvas(diffCanvas, diffCtx, 180);
            setupCanvas(fdsCanvas, fdsCtx, 150);
            drawArena();
            drawFrequency();
            drawPayoff();
            drawESS();
            drawDiff();
            drawFDS();
        });

        init();
    </script>
</body>
</html>
