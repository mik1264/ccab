<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Living Decisions - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            color: var(--dark-moss);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Group Living Decisions</h1>
            <p class="subtitle">Predator Dilution, Information Sharing, Competition & Disease Trade-offs</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Initial Population</label>
                    <input type="range" id="population" min="50" max="200" value="100">
                    <div class="value-display" id="populationVal">100</div>
                </div>

                <div class="control-group">
                    <label>Predation Risk</label>
                    <input type="range" id="predationRisk" min="0" max="50" value="20">
                    <div class="value-display" id="predationRiskVal">20%</div>
                </div>

                <div class="control-group">
                    <label>Dilution Effect Strength</label>
                    <input type="range" id="dilutionStrength" min="0" max="100" value="70">
                    <div class="value-display" id="dilutionStrengthVal">70%</div>
                </div>

                <div class="control-group">
                    <label>Information Sharing Benefit</label>
                    <input type="range" id="infoSharing" min="0" max="100" value="50">
                    <div class="value-display" id="infoSharingVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Within-Group Competition</label>
                    <input type="range" id="competition" min="0" max="100" value="40">
                    <div class="value-display" id="competitionVal">40%</div>
                </div>

                <div class="control-group">
                    <label>Disease Transmission</label>
                    <input type="range" id="diseaseRisk" min="0" max="50" value="15">
                    <div class="value-display" id="diseaseRiskVal">15%</div>
                </div>

                <div class="control-group">
                    <label>Resource Density</label>
                    <input type="range" id="resourceDensity" min="20" max="100" value="60">
                    <div class="value-display" id="resourceDensityVal">60</div>
                </div>

                <div class="control-group">
                    <label>Group Dynamics Model</label>
                    <select id="dynamicsModel">
                        <option value="fission_fusion">Fission-Fusion</option>
                        <option value="stable">Stable Groups</option>
                        <option value="solitary_bias">Solitary Bias</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="numGroups">0</div>
                        <div class="stat-label">Groups</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgGroupSize">0</div>
                        <div class="stat-label">Avg Group Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="optimalSize">0</div>
                        <div class="stat-label">Optimal Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgFitness">0</div>
                        <div class="stat-label">Avg Fitness</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Trade-offs:</strong> Larger groups reduce predation (dilution) and
                    improve foraging (information). But competition for resources and disease
                    spread increase. Intermediate sizes may be optimal.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Population & Groups</h3>
                    <canvas id="arenaCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Benefits vs Costs by Group Size</h3>
                    <canvas id="tradeoffCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Group Size Distribution</h3>
                    <canvas id="distributionCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Fitness & Group Size Over Time</h3>
                    <canvas id="evolutionCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const tradeoffCanvas = document.getElementById('tradeoffCanvas');
        const distributionCanvas = document.getElementById('distributionCanvas');
        const evolutionCanvas = document.getElementById('evolutionCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const tradeoffCtx = tradeoffCanvas.getContext('2d');
        const distributionCtx = distributionCanvas.getContext('2d');
        const evolutionCtx = evolutionCanvas.getContext('2d');

        function resizeCanvases() {
            [arenaCanvas, tradeoffCanvas, distributionCanvas, evolutionCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let agents = [];
        let groups = [];
        let resources = [];
        let predators = [];
        let history = [];

        class Agent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.groupId = null;
                this.fitness = 50;
                this.healthy = true;
                this.infected = false;
                this.infectionTimer = 0;
                this.foodGained = 0;
                this.groupPreference = Math.random(); // 0 = solitary, 1 = social
            }

            update(params, groups, resources) {
                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;

                // Disease progression
                if (this.infected) {
                    this.infectionTimer++;
                    this.fitness -= 0.2;
                    if (this.infectionTimer > 100) {
                        this.infected = false;
                        this.infectionTimer = 0;
                    }
                }

                // Basic fitness decay
                this.fitness -= 0.1;

                // Movement
                if (this.groupId !== null) {
                    const group = groups.find(g => g.id === this.groupId);
                    if (group) {
                        // Move with group
                        const dx = group.x - this.x;
                        const dy = group.y - this.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist > 30) {
                            this.vx += dx / dist * 0.3;
                            this.vy += dy / dist * 0.3;
                        }
                    }
                }

                // Add randomness
                this.vx += (Math.random() - 0.5) * 0.2;
                this.vy += (Math.random() - 0.5) * 0.2;

                // Speed limit
                const speed = Math.hypot(this.vx, this.vy);
                if (speed > 3) {
                    this.vx = (this.vx / speed) * 3;
                    this.vy = (this.vy / speed) * 3;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounds
                if (this.x < 10 || this.x > w - 10) this.vx *= -1;
                if (this.y < 10 || this.y > h - 10) this.vy *= -1;
                this.x = Math.max(10, Math.min(w - 10, this.x));
                this.y = Math.max(10, Math.min(h - 10, this.y));
            }

            forage(resources, groupSize, params) {
                // Information sharing: larger groups find food easier
                const infoBonus = 1 + (groupSize - 1) * params.infoSharing / 100 * 0.1;

                // Competition: larger groups share food
                const competitionCost = 1 + (groupSize - 1) * params.competition / 100 * 0.05;

                resources.forEach(r => {
                    const dist = Math.hypot(r.x - this.x, r.y - this.y);
                    if (dist < 20 && r.value > 0) {
                        const gained = Math.min(r.value, 2 * infoBonus / competitionCost);
                        r.value -= gained;
                        this.fitness += gained;
                        this.foodGained += gained;
                    }
                });
            }
        }

        class Group {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = (Math.random() - 0.5) * 1;
                this.members = [];
            }

            getSize() {
                return this.members.length;
            }

            updateCenter() {
                if (this.members.length === 0) return;

                let sumX = 0, sumY = 0;
                this.members.forEach(m => {
                    sumX += m.x;
                    sumY += m.y;
                });
                this.x = sumX / this.members.length;
                this.y = sumY / this.members.length;
            }

            move() {
                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;

                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;

                const speed = Math.hypot(this.vx, this.vy);
                if (speed > 1.5) {
                    this.vx = (this.vx / speed) * 1.5;
                    this.vy = (this.vy / speed) * 1.5;
                }

                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 50 || this.x > w - 50) this.vx *= -1;
                if (this.y < 50 || this.y > h - 50) this.vy *= -1;
                this.x = Math.max(50, Math.min(w - 50, this.x));
                this.y = Math.max(50, Math.min(h - 50, this.y));
            }
        }

        class Predator {
            constructor() {
                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.targetGroup = null;
            }

            hunt(groups, agents, params) {
                if (!this.targetGroup || Math.random() < 0.02) {
                    // Pick a group to target
                    if (groups.length > 0) {
                        this.targetGroup = groups[Math.floor(Math.random() * groups.length)];
                    }
                }

                if (this.targetGroup) {
                    // Move towards group
                    const dx = this.targetGroup.x - this.x;
                    const dy = this.targetGroup.y - this.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist > 5) {
                        this.x += (dx / dist) * 2;
                        this.y += (dy / dist) * 2;
                    }

                    // Attack
                    if (dist < 30) {
                        const groupMembers = this.targetGroup.members;
                        const groupSize = groupMembers.length;

                        if (groupSize > 0) {
                            // Dilution effect: larger groups = lower individual risk
                            const dilution = params.dilutionStrength / 100;
                            const baseRisk = params.predationRisk / 100;
                            const individualRisk = baseRisk / Math.pow(groupSize, dilution);

                            // Pick a victim (periphery more vulnerable - selfish herd)
                            groupMembers.forEach(agent => {
                                const agentDist = Math.hypot(agent.x - this.targetGroup.x, agent.y - this.targetGroup.y);
                                const peripheryMultiplier = 1 + agentDist / 30;
                                const risk = individualRisk * peripheryMultiplier;

                                if (Math.random() < risk * 0.1) {
                                    // Killed
                                    agent.fitness = 0;
                                }
                            });
                        }

                        this.targetGroup = null;
                    }
                }

                // Random movement
                this.x += (Math.random() - 0.5) * 3;
                this.y += (Math.random() - 0.5) * 3;

                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;
                this.x = Math.max(0, Math.min(w, this.x));
                this.y = Math.max(0, Math.min(h, this.y));
            }
        }

        function initSimulation() {
            const population = parseInt(document.getElementById('population').value);
            const resourceDensity = parseInt(document.getElementById('resourceDensity').value);

            agents = [];
            groups = [];
            resources = [];
            predators = [];
            history = [];
            tick = 0;

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Create agents
            for (let i = 0; i < population; i++) {
                agents.push(new Agent(
                    Math.random() * w,
                    Math.random() * h
                ));
            }

            // Create initial groups
            const numGroups = Math.floor(population / 10);
            for (let i = 0; i < numGroups; i++) {
                groups.push(new Group(
                    i,
                    50 + Math.random() * (w - 100),
                    50 + Math.random() * (h - 100)
                ));
            }

            // Assign agents to groups
            agents.forEach(agent => {
                const nearestGroup = findNearestGroup(agent, groups);
                if (nearestGroup && Math.hypot(agent.x - nearestGroup.x, agent.y - nearestGroup.y) < 100) {
                    agent.groupId = nearestGroup.id;
                    nearestGroup.members.push(agent);
                }
            });

            // Create resources
            for (let i = 0; i < resourceDensity; i++) {
                resources.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    value: 5 + Math.random() * 10,
                    maxValue: 15
                });
            }

            // Create predators
            const numPredators = 2;
            for (let i = 0; i < numPredators; i++) {
                predators.push(new Predator());
            }
        }

        function findNearestGroup(agent, groups) {
            let nearest = null;
            let minDist = Infinity;

            groups.forEach(g => {
                const dist = Math.hypot(g.x - agent.x, g.y - agent.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = g;
                }
            });

            return nearest;
        }

        function getParams() {
            return {
                predationRisk: parseInt(document.getElementById('predationRisk').value),
                dilutionStrength: parseInt(document.getElementById('dilutionStrength').value),
                infoSharing: parseInt(document.getElementById('infoSharing').value),
                competition: parseInt(document.getElementById('competition').value),
                diseaseRisk: parseInt(document.getElementById('diseaseRisk').value),
                resourceDensity: parseInt(document.getElementById('resourceDensity').value),
                dynamicsModel: document.getElementById('dynamicsModel').value
            };
        }

        function simulationStep() {
            const params = getParams();
            tick++;

            // Update groups
            groups.forEach(g => {
                g.members = agents.filter(a => a.groupId === g.id && a.fitness > 0);
                g.updateCenter();
                g.move();
            });

            // Update agents
            agents.forEach(agent => {
                if (agent.fitness <= 0) return;

                agent.update(params, groups, resources);

                const groupSize = agent.groupId !== null ?
                    groups.find(g => g.id === agent.groupId)?.getSize() || 1 : 1;

                agent.forage(resources, groupSize, params);
            });

            // Disease transmission within groups
            groups.forEach(group => {
                if (group.members.length < 2) return;

                const infected = group.members.filter(m => m.infected);
                const healthy = group.members.filter(m => !m.infected && m.healthy);

                infected.forEach(inf => {
                    healthy.forEach(hlth => {
                        const dist = Math.hypot(inf.x - hlth.x, inf.y - hlth.y);
                        // Transmission increases with group size
                        const transmissionProb = params.diseaseRisk / 100 *
                            (1 + group.members.length * 0.05) / (dist + 10);

                        if (Math.random() < transmissionProb * 0.1) {
                            hlth.infected = true;
                            hlth.healthy = false;
                        }
                    });
                });
            });

            // Introduce new infections occasionally
            if (tick % 100 === 0) {
                const healthyAgents = agents.filter(a => a.fitness > 0 && !a.infected);
                if (healthyAgents.length > 0 && Math.random() < 0.3) {
                    const victim = healthyAgents[Math.floor(Math.random() * healthyAgents.length)];
                    victim.infected = true;
                }
            }

            // Predator hunting
            predators.forEach(p => p.hunt(groups, agents, params));

            // Fission-fusion dynamics
            if (params.dynamicsModel === 'fission_fusion' && tick % 20 === 0) {
                fissionFusion(params);
            }

            // Remove dead agents
            agents = agents.filter(a => a.fitness > 0);

            // Regenerate resources
            resources.forEach(r => {
                if (r.value < r.maxValue) {
                    r.value += 0.1;
                }
            });

            // Remove empty groups
            groups = groups.filter(g => g.members.length > 0);

            // Record history
            if (tick % 5 === 0) {
                const groupSizes = groups.map(g => g.getSize());
                const avgSize = groupSizes.length > 0 ?
                    groupSizes.reduce((a, b) => a + b, 0) / groupSizes.length : 0;
                const avgFitness = agents.length > 0 ?
                    agents.reduce((s, a) => s + a.fitness, 0) / agents.length : 0;

                history.push({
                    avgGroupSize: avgSize,
                    avgFitness: avgFitness,
                    numGroups: groups.length,
                    population: agents.length
                });
                if (history.length > 200) history.shift();
            }

            updateStats();
        }

        function fissionFusion(params) {
            // Groups may split or merge
            groups.forEach(group => {
                const size = group.getSize();

                // Calculate optimal group size based on current parameters
                const benefits = calcBenefits(size, params);
                const costs = calcCosts(size, params);
                const netBenefit = benefits - costs;

                // Fission: group too large, members may leave
                if (netBenefit < calcBenefits(size - 1, params) - calcCosts(size - 1, params)) {
                    // Some members want to leave
                    const leavers = group.members.filter(m => Math.random() < 0.2);
                    leavers.forEach(m => {
                        m.groupId = null;
                        const idx = group.members.indexOf(m);
                        if (idx > -1) group.members.splice(idx, 1);
                    });
                }
            });

            // Fusion: solitary individuals may join groups
            const solitary = agents.filter(a => a.groupId === null);
            solitary.forEach(agent => {
                const nearestGroup = findNearestGroup(agent, groups);
                if (nearestGroup) {
                    const dist = Math.hypot(agent.x - nearestGroup.x, agent.y - nearestGroup.y);
                    const size = nearestGroup.getSize();
                    const newBenefit = calcBenefits(size + 1, params) - calcCosts(size + 1, params);
                    const solitaryBenefit = calcBenefits(1, params) - calcCosts(1, params);

                    if (dist < 80 && newBenefit > solitaryBenefit * 0.8) {
                        agent.groupId = nearestGroup.id;
                        nearestGroup.members.push(agent);
                    }
                }
            });

            // Form new groups from solitary individuals
            const remainingSolitary = agents.filter(a => a.groupId === null);
            for (let i = 0; i < remainingSolitary.length; i++) {
                const agent1 = remainingSolitary[i];
                if (agent1.groupId !== null) continue;

                const nearby = remainingSolitary.filter(a => a !== agent1 &&
                    a.groupId === null &&
                    Math.hypot(a.x - agent1.x, a.y - agent1.y) < 50
                );

                if (nearby.length >= 2) {
                    const newGroup = new Group(
                        groups.length,
                        agent1.x,
                        agent1.y
                    );
                    groups.push(newGroup);

                    agent1.groupId = newGroup.id;
                    newGroup.members.push(agent1);

                    nearby.slice(0, 4).forEach(a => {
                        a.groupId = newGroup.id;
                        newGroup.members.push(a);
                    });
                }
            }
        }

        function calcBenefits(size, params) {
            // Predator dilution benefit
            const dilutionBenefit = params.dilutionStrength / 100 * Math.log(size + 1) * 10;
            // Information sharing benefit
            const infoBenefit = params.infoSharing / 100 * Math.sqrt(size) * 5;
            return dilutionBenefit + infoBenefit;
        }

        function calcCosts(size, params) {
            // Competition cost
            const compCost = params.competition / 100 * size * 0.5;
            // Disease cost
            const diseaseCost = params.diseaseRisk / 100 * size * 0.3;
            return compCost + diseaseCost;
        }

        function calculateOptimalSize(params) {
            let bestSize = 1;
            let bestNet = calcBenefits(1, params) - calcCosts(1, params);

            for (let s = 2; s <= 30; s++) {
                const net = calcBenefits(s, params) - calcCosts(s, params);
                if (net > bestNet) {
                    bestNet = net;
                    bestSize = s;
                }
            }
            return bestSize;
        }

        function updateStats() {
            const params = getParams();
            const groupSizes = groups.map(g => g.getSize());

            document.getElementById('numGroups').textContent = groups.length;
            document.getElementById('avgGroupSize').textContent = groupSizes.length > 0 ?
                (groupSizes.reduce((a, b) => a + b, 0) / groupSizes.length).toFixed(1) : '0';
            document.getElementById('optimalSize').textContent = calculateOptimalSize(params);
            document.getElementById('avgFitness').textContent = agents.length > 0 ?
                (agents.reduce((s, a) => s + a.fitness, 0) / agents.length).toFixed(1) : '0';
        }

        function draw() {
            drawArena();
            drawTradeoffs();
            drawDistribution();
            drawEvolution();
        }

        function drawArena() {
            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, w, h);

            // Draw resources
            resources.forEach(r => {
                const alpha = r.value / r.maxValue;
                arenaCtx.fillStyle = `rgba(139, 195, 74, ${alpha})`;
                arenaCtx.beginPath();
                arenaCtx.arc(r.x, r.y, 4, 0, Math.PI * 2);
                arenaCtx.fill();
            });

            // Draw group territories
            groups.forEach((group, i) => {
                if (group.members.length === 0) return;

                const hue = (i * 137) % 360;

                // Group boundary
                arenaCtx.strokeStyle = `hsla(${hue}, 60%, 50%, 0.3)`;
                arenaCtx.lineWidth = 2;
                arenaCtx.beginPath();
                arenaCtx.arc(group.x, group.y, 40, 0, Math.PI * 2);
                arenaCtx.stroke();

                // Group center
                arenaCtx.fillStyle = `hsla(${hue}, 60%, 50%, 0.5)`;
                arenaCtx.beginPath();
                arenaCtx.arc(group.x, group.y, 5, 0, Math.PI * 2);
                arenaCtx.fill();
            });

            // Draw agents
            agents.forEach(agent => {
                let color;
                if (agent.infected) {
                    color = '#f44336';
                } else if (agent.groupId !== null) {
                    const hue = (agent.groupId * 137) % 360;
                    color = `hsl(${hue}, 60%, 50%)`;
                } else {
                    color = '#888';
                }

                arenaCtx.fillStyle = color;
                arenaCtx.beginPath();
                arenaCtx.arc(agent.x, agent.y, 4, 0, Math.PI * 2);
                arenaCtx.fill();
            });

            // Draw predators
            predators.forEach(p => {
                arenaCtx.fillStyle = '#ff5722';
                arenaCtx.beginPath();
                arenaCtx.moveTo(p.x, p.y - 10);
                arenaCtx.lineTo(p.x - 7, p.y + 7);
                arenaCtx.lineTo(p.x + 7, p.y + 7);
                arenaCtx.closePath();
                arenaCtx.fill();
            });

            // Legend
            arenaCtx.font = '10px sans-serif';
            arenaCtx.fillStyle = '#4CAF50';
            arenaCtx.fillText('● Group Member', 10, h - 30);
            arenaCtx.fillStyle = '#888';
            arenaCtx.fillText('● Solitary', 100, h - 30);
            arenaCtx.fillStyle = '#f44336';
            arenaCtx.fillText('● Infected', 10, h - 15);
            arenaCtx.fillStyle = '#ff5722';
            arenaCtx.fillText('▲ Predator', 100, h - 15);
        }

        function drawTradeoffs() {
            const w = tradeoffCanvas.width / window.devicePixelRatio;
            const h = tradeoffCanvas.height / window.devicePixelRatio;
            const params = getParams();

            tradeoffCtx.fillStyle = '#1a1a2e';
            tradeoffCtx.fillRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            tradeoffCtx.strokeStyle = '#666';
            tradeoffCtx.beginPath();
            tradeoffCtx.moveTo(padding, padding);
            tradeoffCtx.lineTo(padding, h - padding);
            tradeoffCtx.lineTo(w - padding, h - padding);
            tradeoffCtx.stroke();

            // Labels
            tradeoffCtx.fillStyle = '#aaa';
            tradeoffCtx.font = '10px sans-serif';
            tradeoffCtx.fillText('Value', 5, h / 2);
            tradeoffCtx.fillText('Group Size', w / 2 - 25, h - 5);

            const maxSize = 25;
            let maxVal = 0;

            // Calculate max for scaling
            for (let s = 1; s <= maxSize; s++) {
                maxVal = Math.max(maxVal, calcBenefits(s, params), calcCosts(s, params));
            }

            // Draw benefits curve
            tradeoffCtx.strokeStyle = '#4CAF50';
            tradeoffCtx.lineWidth = 2;
            tradeoffCtx.beginPath();
            for (let s = 1; s <= maxSize; s++) {
                const x = padding + ((s - 1) / (maxSize - 1)) * plotW;
                const y = h - padding - (calcBenefits(s, params) / maxVal) * plotH;
                if (s === 1) tradeoffCtx.moveTo(x, y);
                else tradeoffCtx.lineTo(x, y);
            }
            tradeoffCtx.stroke();

            // Draw costs curve
            tradeoffCtx.strokeStyle = '#f44336';
            tradeoffCtx.beginPath();
            for (let s = 1; s <= maxSize; s++) {
                const x = padding + ((s - 1) / (maxSize - 1)) * plotW;
                const y = h - padding - (calcCosts(s, params) / maxVal) * plotH;
                if (s === 1) tradeoffCtx.moveTo(x, y);
                else tradeoffCtx.lineTo(x, y);
            }
            tradeoffCtx.stroke();

            // Draw net benefit curve
            tradeoffCtx.strokeStyle = '#ff9800';
            tradeoffCtx.setLineDash([5, 5]);
            tradeoffCtx.beginPath();
            for (let s = 1; s <= maxSize; s++) {
                const x = padding + ((s - 1) / (maxSize - 1)) * plotW;
                const net = calcBenefits(s, params) - calcCosts(s, params);
                const y = h - padding - ((net + maxVal) / (2 * maxVal)) * plotH;
                if (s === 1) tradeoffCtx.moveTo(x, y);
                else tradeoffCtx.lineTo(x, y);
            }
            tradeoffCtx.stroke();
            tradeoffCtx.setLineDash([]);

            // Mark optimal size
            const optimal = calculateOptimalSize(params);
            const optX = padding + ((optimal - 1) / (maxSize - 1)) * plotW;
            tradeoffCtx.strokeStyle = '#fff';
            tradeoffCtx.lineWidth = 1;
            tradeoffCtx.beginPath();
            tradeoffCtx.moveTo(optX, padding);
            tradeoffCtx.lineTo(optX, h - padding);
            tradeoffCtx.stroke();
            tradeoffCtx.fillStyle = '#fff';
            tradeoffCtx.fillText(`Opt: ${optimal}`, optX + 5, padding + 15);

            // Legend
            tradeoffCtx.fillStyle = '#4CAF50';
            tradeoffCtx.fillText('Benefits', w - 70, 20);
            tradeoffCtx.fillStyle = '#f44336';
            tradeoffCtx.fillText('Costs', w - 70, 35);
            tradeoffCtx.fillStyle = '#ff9800';
            tradeoffCtx.fillText('Net', w - 70, 50);
        }

        function drawDistribution() {
            const w = distributionCanvas.width / window.devicePixelRatio;
            const h = distributionCanvas.height / window.devicePixelRatio;

            distributionCtx.fillStyle = '#1a1a2e';
            distributionCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Create histogram
            const sizes = groups.map(g => g.getSize());
            const maxSize = Math.max(...sizes, 15);
            const bins = Math.min(maxSize, 15);
            const histogram = new Array(bins).fill(0);

            sizes.forEach(s => {
                const bin = Math.min(s - 1, bins - 1);
                if (bin >= 0) histogram[bin]++;
            });

            const maxCount = Math.max(...histogram, 1);

            // Axes
            distributionCtx.strokeStyle = '#666';
            distributionCtx.beginPath();
            distributionCtx.moveTo(padding, padding);
            distributionCtx.lineTo(padding, h - padding);
            distributionCtx.lineTo(w - padding, h - padding);
            distributionCtx.stroke();

            // Labels
            distributionCtx.fillStyle = '#aaa';
            distributionCtx.font = '10px sans-serif';
            distributionCtx.fillText('Groups', 5, h / 2);
            distributionCtx.fillText('Size', w / 2 - 10, h - 5);

            // Draw bars
            const barWidth = plotW / bins * 0.8;
            histogram.forEach((count, i) => {
                const x = padding + (i / bins) * plotW + (plotW / bins * 0.1);
                const barH = (count / maxCount) * plotH;
                const y = h - padding - barH;

                distributionCtx.fillStyle = '#4CAF50';
                distributionCtx.fillRect(x, y, barWidth, barH);

                distributionCtx.fillStyle = '#888';
                distributionCtx.font = '8px sans-serif';
                distributionCtx.fillText(i + 1, x + barWidth / 2 - 3, h - padding + 12);
            });
        }

        function drawEvolution() {
            const w = evolutionCanvas.width / window.devicePixelRatio;
            const h = evolutionCanvas.height / window.devicePixelRatio;

            evolutionCtx.fillStyle = '#1a1a2e';
            evolutionCtx.fillRect(0, 0, w, h);

            if (history.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            evolutionCtx.strokeStyle = '#666';
            evolutionCtx.beginPath();
            evolutionCtx.moveTo(padding, padding);
            evolutionCtx.lineTo(padding, h - padding);
            evolutionCtx.lineTo(w - padding, h - padding);
            evolutionCtx.stroke();

            // Labels
            evolutionCtx.fillStyle = '#aaa';
            evolutionCtx.font = '10px sans-serif';
            evolutionCtx.fillText('Value', 5, h / 2);
            evolutionCtx.fillText('Time', w / 2 - 10, h - 5);

            const maxGroupSize = Math.max(...history.map(d => d.avgGroupSize), 10);
            const maxFitness = Math.max(...history.map(d => d.avgFitness), 50);

            // Draw group size
            evolutionCtx.strokeStyle = '#4CAF50';
            evolutionCtx.lineWidth = 2;
            evolutionCtx.beginPath();
            history.forEach((d, i) => {
                const x = padding + (i / (history.length - 1)) * plotW;
                const y = h - padding - (d.avgGroupSize / maxGroupSize) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();

            // Draw fitness
            evolutionCtx.strokeStyle = '#2196F3';
            evolutionCtx.beginPath();
            history.forEach((d, i) => {
                const x = padding + (i / (history.length - 1)) * plotW;
                const y = h - padding - (d.avgFitness / maxFitness) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();

            // Legend
            evolutionCtx.fillStyle = '#4CAF50';
            evolutionCtx.fillText('● Avg Size', w - 80, 20);
            evolutionCtx.fillStyle = '#2196F3';
            evolutionCtx.fillText('● Avg Fitness', w - 80, 35);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['population', 'populationVal', v => v],
            ['predationRisk', 'predationRiskVal', v => v + '%'],
            ['dilutionStrength', 'dilutionStrengthVal', v => v + '%'],
            ['infoSharing', 'infoSharingVal', v => v + '%'],
            ['competition', 'competitionVal', v => v + '%'],
            ['diseaseRisk', 'diseaseRiskVal', v => v + '%'],
            ['resourceDensity', 'resourceDensityVal', v => v]
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
</body>
</html>
