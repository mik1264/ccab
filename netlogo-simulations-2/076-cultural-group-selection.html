<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cultural Group Selection - NetLogo-Style Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .panel h3 {
            color: #27ae60;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(39, 174, 96, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85em;
            color: #27ae60;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-wrapper h4 {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #27ae60;
            font-size: 0.95em;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #27ae60;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .group-list {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .group-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85em;
        }

        .group-item:last-child {
            border-bottom: none;
        }

        .cooperation-bar {
            width: 50px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
        }

        .cooperation-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            transition: width 0.3s ease;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #27ae60;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Cultural Group Selection</h1>
            <p class="subtitle">Multilevel Selection Model: Within-Group vs Between-Group Competition</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h3>Population Parameters</h3>

                <div class="control-group">
                    <label>Number of Groups</label>
                    <input type="range" id="numGroups" min="4" max="20" value="10">
                    <div class="value"><span id="numGroupsVal">10</span></div>
                </div>

                <div class="control-group">
                    <label>Individuals per Group</label>
                    <input type="range" id="groupSize" min="10" max="100" value="30">
                    <div class="value"><span id="groupSizeVal">30</span></div>
                </div>

                <div class="control-group">
                    <label>Initial Cooperation (%)</label>
                    <input type="range" id="initCooperation" min="0" max="100" value="50">
                    <div class="value"><span id="initCooperationVal">50</span>%</div>
                </div>

                <h3>Selection Parameters</h3>

                <div class="control-group">
                    <label>Benefit of Cooperation (b)</label>
                    <input type="range" id="benefitCoop" min="1" max="5" step="0.1" value="3">
                    <div class="value"><span id="benefitCoopVal">3.0</span></div>
                </div>

                <div class="control-group">
                    <label>Cost of Cooperation (c)</label>
                    <input type="range" id="costCoop" min="0.1" max="2" step="0.1" value="1">
                    <div class="value"><span id="costCoopVal">1.0</span></div>
                </div>

                <div class="control-group">
                    <label>Group Selection Strength</label>
                    <input type="range" id="groupSelectionStrength" min="0" max="1" step="0.01" value="0.3">
                    <div class="value"><span id="groupSelectionStrengthVal">0.30</span></div>
                </div>

                <div class="control-group">
                    <label>Migration Rate</label>
                    <input type="range" id="migrationRate" min="0" max="0.2" step="0.01" value="0.05">
                    <div class="value"><span id="migrationRateVal">0.05</span></div>
                </div>

                <div class="control-group">
                    <label>Conformity Bias</label>
                    <input type="range" id="conformityBias" min="0" max="1" step="0.01" value="0.5">
                    <div class="value"><span id="conformityBiasVal">0.50</span></div>
                </div>

                <h3>Punishment</h3>

                <div class="control-group">
                    <label>Enable Altruistic Punishment</label>
                    <select id="enablePunishment">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Punishment Cost</label>
                    <input type="range" id="punishmentCost" min="0" max="1" step="0.05" value="0.2">
                    <div class="value"><span id="punishmentCostVal">0.20</span></div>
                </div>

                <h3>Simulation Control</h3>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-danger" id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="speed" min="1" max="20" value="10">
                    <div class="value"><span id="speedVal">10</span> steps/frame</div>
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <h4>Group Landscape</h4>
                        <canvas id="landscapeCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Cooperation Evolution</h4>
                        <canvas id="evolutionCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Group Fitness Distribution</h4>
                        <canvas id="fitnessCanvas" width="400" height="250"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Between vs Within-Group Variation</h4>
                        <canvas id="variationCanvas" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Population Statistics</h3>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="generation">0</div>
                        <div class="label">Generation</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="globalCooperation">50.0</div>
                        <div class="label">Global Coop (%)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="numGroupsDisplay">10</div>
                        <div class="label">Active Groups</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="avgFitness">0.00</div>
                        <div class="label">Avg Fitness</div>
                    </div>
                </div>

                <h3>Multilevel Selection</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="betweenGroupVar">0.00</div>
                        <div class="label">Between-Group Var</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="withinGroupVar">0.00</div>
                        <div class="label">Within-Group Var</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="fst">0.00</div>
                        <div class="label">F_ST Index</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="groupConflicts">0</div>
                        <div class="label">Group Conflicts</div>
                    </div>
                </div>

                <h3>Group Rankings</h3>
                <div class="group-list" id="groupList"></div>

                <h3>Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Cooperator</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Defector</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>Punisher</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Cultural Group Selection:</strong><br>
                    Cooperation can evolve when between-group competition favors cooperative groups,
                    and cultural transmission (conformity) maintains between-group variation despite migration.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const landscapeCanvas = document.getElementById('landscapeCanvas');
        const evolutionCanvas = document.getElementById('evolutionCanvas');
        const fitnessCanvas = document.getElementById('fitnessCanvas');
        const variationCanvas = document.getElementById('variationCanvas');

        const landCtx = landscapeCanvas.getContext('2d');
        const evoCtx = evolutionCanvas.getContext('2d');
        const fitCtx = fitnessCanvas.getContext('2d');
        const varCtx = variationCanvas.getContext('2d');

        // Simulation state
        let groups = [];
        let generation = 0;
        let isRunning = false;
        let animationId = null;
        let history = [];
        let variationHistory = [];
        let groupConflicts = 0;

        // Parameters
        let numGroups = 10;
        let groupSize = 30;
        let initCooperation = 0.5;
        let benefitCoop = 3.0;
        let costCoop = 1.0;
        let groupSelectionStrength = 0.3;
        let migrationRate = 0.05;
        let conformityBias = 0.5;
        let enablePunishment = true;
        let punishmentCost = 0.2;
        let speed = 10;

        // Strategy types
        const DEFECTOR = 0;
        const COOPERATOR = 1;
        const PUNISHER = 2;

        // UI Elements
        const elements = {
            numGroups: document.getElementById('numGroups'),
            numGroupsVal: document.getElementById('numGroupsVal'),
            groupSize: document.getElementById('groupSize'),
            groupSizeVal: document.getElementById('groupSizeVal'),
            initCooperation: document.getElementById('initCooperation'),
            initCooperationVal: document.getElementById('initCooperationVal'),
            benefitCoop: document.getElementById('benefitCoop'),
            benefitCoopVal: document.getElementById('benefitCoopVal'),
            costCoop: document.getElementById('costCoop'),
            costCoopVal: document.getElementById('costCoopVal'),
            groupSelectionStrength: document.getElementById('groupSelectionStrength'),
            groupSelectionStrengthVal: document.getElementById('groupSelectionStrengthVal'),
            migrationRate: document.getElementById('migrationRate'),
            migrationRateVal: document.getElementById('migrationRateVal'),
            conformityBias: document.getElementById('conformityBias'),
            conformityBiasVal: document.getElementById('conformityBiasVal'),
            enablePunishment: document.getElementById('enablePunishment'),
            punishmentCost: document.getElementById('punishmentCost'),
            punishmentCostVal: document.getElementById('punishmentCostVal'),
            speed: document.getElementById('speed'),
            speedVal: document.getElementById('speedVal'),
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            generation: document.getElementById('generation'),
            globalCooperation: document.getElementById('globalCooperation'),
            numGroupsDisplay: document.getElementById('numGroupsDisplay'),
            avgFitness: document.getElementById('avgFitness'),
            betweenGroupVar: document.getElementById('betweenGroupVar'),
            withinGroupVar: document.getElementById('withinGroupVar'),
            fst: document.getElementById('fst'),
            groupConflicts: document.getElementById('groupConflicts'),
            groupList: document.getElementById('groupList')
        };

        // Initialize groups
        function initializeGroups() {
            groups = [];
            generation = 0;
            history = [];
            variationHistory = [];
            groupConflicts = 0;

            const width = landscapeCanvas.width;
            const height = landscapeCanvas.height;

            // Create groups in a grid layout
            const cols = Math.ceil(Math.sqrt(numGroups));
            const rows = Math.ceil(numGroups / cols);
            const cellWidth = width / cols;
            const cellHeight = height / rows;

            for (let i = 0; i < numGroups; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);

                const group = {
                    id: i,
                    x: cellWidth * (col + 0.5),
                    y: cellHeight * (row + 0.5),
                    individuals: [],
                    cooperation: 0,
                    fitness: 0,
                    color: `hsl(${(i / numGroups) * 360}, 70%, 50%)`
                };

                // Create individuals
                for (let j = 0; j < groupSize; j++) {
                    let strategy;
                    const rand = Math.random();

                    if (enablePunishment && rand < initCooperation * 0.3) {
                        strategy = PUNISHER;
                    } else if (rand < initCooperation) {
                        strategy = COOPERATOR;
                    } else {
                        strategy = DEFECTOR;
                    }

                    group.individuals.push({
                        strategy: strategy,
                        fitness: 0
                    });
                }

                calculateGroupStats(group);
                groups.push(group);
            }

            updateStats();
            draw();
        }

        // Calculate group statistics
        function calculateGroupStats(group) {
            if (group.individuals.length === 0) {
                group.cooperation = 0;
                group.fitness = 0;
                return;
            }

            let cooperators = 0;
            let punishers = 0;

            group.individuals.forEach(ind => {
                if (ind.strategy === COOPERATOR) cooperators++;
                if (ind.strategy === PUNISHER) {
                    cooperators++; // Punishers also cooperate
                    punishers++;
                }
            });

            group.cooperation = cooperators / group.individuals.length;
            group.punisherFraction = punishers / group.individuals.length;

            // Calculate individual fitness within group
            const n = group.individuals.length;
            const coopFraction = group.cooperation;

            group.individuals.forEach(ind => {
                // Public goods game payoff
                const publicGood = benefitCoop * coopFraction * n / n;

                if (ind.strategy === DEFECTOR) {
                    // Defector gets benefit without paying cost
                    ind.fitness = publicGood;

                    // But gets punished
                    if (enablePunishment) {
                        ind.fitness -= group.punisherFraction * 1.0; // Punishment damage
                    }
                } else if (ind.strategy === COOPERATOR) {
                    // Cooperator pays cost
                    ind.fitness = publicGood - costCoop;
                } else if (ind.strategy === PUNISHER) {
                    // Punisher pays cost of cooperation and cost of punishment
                    ind.fitness = publicGood - costCoop - punishmentCost * (1 - coopFraction);
                }
            });

            // Group fitness is average of individual fitness
            const totalFitness = group.individuals.reduce((sum, ind) => sum + ind.fitness, 0);
            group.fitness = totalFitness / n;
        }

        // Within-group selection (cultural learning)
        function withinGroupSelection() {
            groups.forEach(group => {
                if (group.individuals.length < 2) return;

                // Each individual may update strategy via social learning
                const newStrategies = group.individuals.map(ind => ind.strategy);

                group.individuals.forEach((ind, idx) => {
                    // Pick random model from same group
                    let modelIdx = Math.floor(Math.random() * group.individuals.length);
                    while (modelIdx === idx) {
                        modelIdx = Math.floor(Math.random() * group.individuals.length);
                    }
                    const model = group.individuals[modelIdx];

                    // Payoff-biased learning probability
                    const fitnessDiff = model.fitness - ind.fitness;
                    let switchProb = 1 / (1 + Math.exp(-fitnessDiff));

                    // Conformity bias
                    const strategyFreq = getStrategyFrequency(group, model.strategy);
                    const conformityEffect = strategyFreq * conformityBias;
                    switchProb = switchProb * (1 - conformityBias) + conformityEffect;

                    if (Math.random() < switchProb * 0.1) {
                        newStrategies[idx] = model.strategy;
                    }
                });

                // Apply new strategies
                group.individuals.forEach((ind, idx) => {
                    ind.strategy = newStrategies[idx];
                });
            });
        }

        // Get frequency of a strategy in a group
        function getStrategyFrequency(group, strategy) {
            const count = group.individuals.filter(ind => ind.strategy === strategy).length;
            return count / group.individuals.length;
        }

        // Between-group selection (group competition)
        function betweenGroupSelection() {
            if (groups.length < 2) return;

            // Number of pairwise conflicts proportional to group selection strength
            const numConflicts = Math.floor(groups.length * groupSelectionStrength);

            for (let c = 0; c < numConflicts; c++) {
                // Pick two random groups
                const idx1 = Math.floor(Math.random() * groups.length);
                let idx2 = Math.floor(Math.random() * groups.length);
                while (idx2 === idx1) {
                    idx2 = Math.floor(Math.random() * groups.length);
                }

                const group1 = groups[idx1];
                const group2 = groups[idx2];

                // Probability of winning based on fitness difference
                const fitnessDiff = group1.fitness - group2.fitness;
                const winProb1 = 1 / (1 + Math.exp(-fitnessDiff * 2));

                groupConflicts++;

                if (Math.random() < winProb1) {
                    // Group 1 wins - some of group 2 adopts group 1's culture
                    spreadCulture(group1, group2);
                } else {
                    // Group 2 wins
                    spreadCulture(group2, group1);
                }
            }
        }

        // Cultural spread from winner to loser group
        function spreadCulture(winner, loser) {
            // Some fraction of loser adopts winner's predominant strategy
            const winnerDominant = getDominantStrategy(winner);
            const spreadFraction = 0.3;

            loser.individuals.forEach(ind => {
                if (Math.random() < spreadFraction) {
                    ind.strategy = winnerDominant;
                }
            });
        }

        // Get dominant strategy in a group
        function getDominantStrategy(group) {
            const counts = [0, 0, 0];
            group.individuals.forEach(ind => {
                counts[ind.strategy]++;
            });

            let maxIdx = 0;
            counts.forEach((c, i) => {
                if (c > counts[maxIdx]) maxIdx = i;
            });

            return maxIdx;
        }

        // Migration between groups
        function migration() {
            if (groups.length < 2) return;

            groups.forEach(group => {
                // Some individuals migrate out
                const migrants = [];
                group.individuals = group.individuals.filter(ind => {
                    if (Math.random() < migrationRate) {
                        migrants.push(ind);
                        return false;
                    }
                    return true;
                });

                // Migrants join random other groups
                migrants.forEach(migrant => {
                    let targetIdx = Math.floor(Math.random() * groups.length);
                    while (groups[targetIdx] === group && groups.length > 1) {
                        targetIdx = Math.floor(Math.random() * groups.length);
                    }
                    groups[targetIdx].individuals.push(migrant);
                });
            });
        }

        // Calculate multilevel selection statistics
        function calculateVariation() {
            if (groups.length === 0) return { between: 0, within: 0, fst: 0 };

            // Global cooperation frequency
            let totalCoop = 0;
            let totalN = 0;
            groups.forEach(group => {
                totalCoop += group.cooperation * group.individuals.length;
                totalN += group.individuals.length;
            });
            const globalP = totalN > 0 ? totalCoop / totalN : 0;

            // Between-group variance
            let betweenVar = 0;
            groups.forEach(group => {
                betweenVar += Math.pow(group.cooperation - globalP, 2);
            });
            betweenVar /= groups.length;

            // Within-group variance
            let withinVar = 0;
            groups.forEach(group => {
                const p = group.cooperation;
                withinVar += p * (1 - p); // Binomial variance
            });
            withinVar /= groups.length;

            // F_ST (Wright's fixation index)
            const totalVar = betweenVar + withinVar;
            const fst = totalVar > 0 ? betweenVar / totalVar : 0;

            return { between: betweenVar, within: withinVar, fst: fst };
        }

        // Simulation step
        function step() {
            generation++;

            // Update all group stats
            groups.forEach(calculateGroupStats);

            // Within-group selection (cultural learning)
            withinGroupSelection();

            // Between-group selection
            betweenGroupSelection();

            // Migration
            migration();

            // Recalculate stats
            groups.forEach(calculateGroupStats);

            // Record history
            const globalCoop = calculateGlobalCooperation();
            history.push(globalCoop);
            if (history.length > 500) history.shift();

            const variation = calculateVariation();
            variationHistory.push(variation);
            if (variationHistory.length > 500) variationHistory.shift();
        }

        // Calculate global cooperation
        function calculateGlobalCooperation() {
            let totalCoop = 0;
            let totalN = 0;
            groups.forEach(group => {
                totalCoop += group.cooperation * group.individuals.length;
                totalN += group.individuals.length;
            });
            return totalN > 0 ? totalCoop / totalN : 0;
        }

        // Update statistics display
        function updateStats() {
            elements.generation.textContent = generation;

            const globalCoop = calculateGlobalCooperation();
            elements.globalCooperation.textContent = (globalCoop * 100).toFixed(1);

            elements.numGroupsDisplay.textContent = groups.length;

            const avgFitness = groups.reduce((sum, g) => sum + g.fitness, 0) / groups.length;
            elements.avgFitness.textContent = avgFitness.toFixed(2);

            const variation = calculateVariation();
            elements.betweenGroupVar.textContent = variation.between.toFixed(3);
            elements.withinGroupVar.textContent = variation.within.toFixed(3);
            elements.fst.textContent = variation.fst.toFixed(3);
            elements.groupConflicts.textContent = groupConflicts;

            // Update group list
            updateGroupList();
        }

        // Update group rankings list
        function updateGroupList() {
            const sortedGroups = [...groups].sort((a, b) => b.cooperation - a.cooperation);

            let html = '';
            sortedGroups.slice(0, 5).forEach((group, idx) => {
                html += `
                    <div class="group-item">
                        <span>Group ${group.id + 1}</span>
                        <span>${(group.cooperation * 100).toFixed(0)}%</span>
                        <div class="cooperation-bar">
                            <div class="cooperation-fill" style="width: ${group.cooperation * 100}%"></div>
                        </div>
                    </div>
                `;
            });

            elements.groupList.innerHTML = html;
        }

        // Draw landscape
        function drawLandscape() {
            const width = landscapeCanvas.width;
            const height = landscapeCanvas.height;

            landCtx.clearRect(0, 0, width, height);
            landCtx.fillStyle = '#1a1a2e';
            landCtx.fillRect(0, 0, width, height);

            // Draw groups as circles with individuals
            const cols = Math.ceil(Math.sqrt(numGroups));
            const rows = Math.ceil(numGroups / cols);
            const cellWidth = width / cols;
            const cellHeight = height / rows;
            const maxRadius = Math.min(cellWidth, cellHeight) * 0.4;

            groups.forEach((group, gIdx) => {
                const col = gIdx % cols;
                const row = Math.floor(gIdx / cols);
                const centerX = cellWidth * (col + 0.5);
                const centerY = cellHeight * (row + 0.5);

                // Group circle
                const radius = maxRadius * Math.sqrt(group.individuals.length / groupSize);

                // Draw group territory
                landCtx.fillStyle = `rgba(${Math.floor(255 * (1 - group.cooperation))}, ${Math.floor(255 * group.cooperation)}, 100, 0.2)`;
                landCtx.beginPath();
                landCtx.arc(centerX, centerY, radius + 10, 0, Math.PI * 2);
                landCtx.fill();

                // Draw individuals
                const n = group.individuals.length;
                const indRadius = Math.min(8, radius * 0.3);

                group.individuals.forEach((ind, iIdx) => {
                    const angle = (iIdx / n) * Math.PI * 2;
                    const r = radius * 0.7 * Math.sqrt(iIdx / n);
                    const x = centerX + r * Math.cos(angle + gIdx);
                    const y = centerY + r * Math.sin(angle + gIdx);

                    let color;
                    switch (ind.strategy) {
                        case DEFECTOR:
                            color = '#e74c3c';
                            break;
                        case COOPERATOR:
                            color = '#27ae60';
                            break;
                        case PUNISHER:
                            color = '#9b59b6';
                            break;
                    }

                    landCtx.fillStyle = color;
                    landCtx.beginPath();
                    landCtx.arc(x, y, indRadius, 0, Math.PI * 2);
                    landCtx.fill();
                });

                // Group label
                landCtx.fillStyle = '#fff';
                landCtx.font = '10px sans-serif';
                landCtx.textAlign = 'center';
                landCtx.fillText(`G${gIdx + 1}`, centerX, centerY + radius + 20);

                // Cooperation percentage
                landCtx.fillStyle = '#aaa';
                landCtx.font = '9px sans-serif';
                landCtx.fillText(`${(group.cooperation * 100).toFixed(0)}%`, centerX, centerY + radius + 30);
            });
        }

        // Draw evolution chart
        function drawEvolution() {
            const width = evolutionCanvas.width;
            const height = evolutionCanvas.height;
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            evoCtx.clearRect(0, 0, width, height);
            evoCtx.fillStyle = '#1a1a2e';
            evoCtx.fillRect(0, 0, width, height);

            // Axes
            evoCtx.strokeStyle = '#666';
            evoCtx.lineWidth = 1;
            evoCtx.beginPath();
            evoCtx.moveTo(margin.left, margin.top);
            evoCtx.lineTo(margin.left, height - margin.bottom);
            evoCtx.lineTo(width - margin.right, height - margin.bottom);
            evoCtx.stroke();

            // Labels
            evoCtx.fillStyle = '#aaa';
            evoCtx.font = '11px sans-serif';
            evoCtx.textAlign = 'center';
            evoCtx.fillText('Generation', width / 2, height - 5);

            evoCtx.save();
            evoCtx.translate(12, height / 2);
            evoCtx.rotate(-Math.PI / 2);
            evoCtx.fillText('Cooperation Frequency', 0, 0);
            evoCtx.restore();

            if (history.length < 2) return;

            // Draw global cooperation line
            evoCtx.strokeStyle = '#27ae60';
            evoCtx.lineWidth = 2;
            evoCtx.beginPath();

            history.forEach((coop, i) => {
                const x = margin.left + (i / history.length) * chartWidth;
                const y = margin.top + (1 - coop) * chartHeight;

                if (i === 0) {
                    evoCtx.moveTo(x, y);
                } else {
                    evoCtx.lineTo(x, y);
                }
            });

            evoCtx.stroke();

            // Draw threshold lines
            evoCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            evoCtx.setLineDash([5, 5]);

            // 50% line
            evoCtx.beginPath();
            evoCtx.moveTo(margin.left, margin.top + chartHeight * 0.5);
            evoCtx.lineTo(width - margin.right, margin.top + chartHeight * 0.5);
            evoCtx.stroke();

            evoCtx.setLineDash([]);

            // Tick labels
            evoCtx.fillStyle = '#aaa';
            evoCtx.font = '10px sans-serif';
            evoCtx.textAlign = 'right';

            for (let p = 0; p <= 1; p += 0.25) {
                const y = margin.top + (1 - p) * chartHeight;
                evoCtx.fillText((p * 100).toFixed(0) + '%', margin.left - 5, y + 4);
            }
        }

        // Draw fitness distribution
        function drawFitnessDistribution() {
            const width = fitnessCanvas.width;
            const height = fitnessCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            fitCtx.clearRect(0, 0, width, height);
            fitCtx.fillStyle = '#1a1a2e';
            fitCtx.fillRect(0, 0, width, height);

            // Axes
            fitCtx.strokeStyle = '#666';
            fitCtx.lineWidth = 1;
            fitCtx.beginPath();
            fitCtx.moveTo(margin.left, margin.top);
            fitCtx.lineTo(margin.left, height - margin.bottom);
            fitCtx.lineTo(width - margin.right, height - margin.bottom);
            fitCtx.stroke();

            // Labels
            fitCtx.fillStyle = '#aaa';
            fitCtx.font = '10px sans-serif';
            fitCtx.textAlign = 'center';
            fitCtx.fillText('Group', width / 2, height - 5);

            fitCtx.save();
            fitCtx.translate(10, height / 2);
            fitCtx.rotate(-Math.PI / 2);
            fitCtx.fillText('Fitness', 0, 0);
            fitCtx.restore();

            if (groups.length === 0) return;

            const minFitness = Math.min(...groups.map(g => g.fitness)) - 0.5;
            const maxFitness = Math.max(...groups.map(g => g.fitness)) + 0.5;
            const range = maxFitness - minFitness || 1;

            const barWidth = chartWidth / groups.length * 0.8;

            groups.forEach((group, i) => {
                const x = margin.left + (i / groups.length) * chartWidth + barWidth * 0.1;
                const barHeight = ((group.fitness - minFitness) / range) * chartHeight;
                const y = margin.top + chartHeight - barHeight;

                // Color based on cooperation
                const hue = 120 * group.cooperation; // 0 = red, 120 = green
                fitCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;

                fitCtx.fillRect(x, y, barWidth, barHeight);

                // Group label
                fitCtx.fillStyle = '#aaa';
                fitCtx.font = '8px sans-serif';
                fitCtx.textAlign = 'center';
                fitCtx.fillText(`${i + 1}`, x + barWidth / 2, height - margin.bottom + 12);
            });
        }

        // Draw variation chart
        function drawVariation() {
            const width = variationCanvas.width;
            const height = variationCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            varCtx.clearRect(0, 0, width, height);
            varCtx.fillStyle = '#1a1a2e';
            varCtx.fillRect(0, 0, width, height);

            // Axes
            varCtx.strokeStyle = '#666';
            varCtx.lineWidth = 1;
            varCtx.beginPath();
            varCtx.moveTo(margin.left, margin.top);
            varCtx.lineTo(margin.left, height - margin.bottom);
            varCtx.lineTo(width - margin.right, height - margin.bottom);
            varCtx.stroke();

            // Labels
            varCtx.fillStyle = '#aaa';
            varCtx.font = '10px sans-serif';
            varCtx.textAlign = 'center';
            varCtx.fillText('Generation', width / 2, height - 5);

            varCtx.save();
            varCtx.translate(10, height / 2);
            varCtx.rotate(-Math.PI / 2);
            varCtx.fillText('Variance', 0, 0);
            varCtx.restore();

            if (variationHistory.length < 2) return;

            const maxVar = Math.max(
                ...variationHistory.map(v => Math.max(v.between, v.within)),
                0.01
            );

            // Between-group variance
            varCtx.strokeStyle = '#3498db';
            varCtx.lineWidth = 2;
            varCtx.beginPath();

            variationHistory.forEach((v, i) => {
                const x = margin.left + (i / variationHistory.length) * chartWidth;
                const y = margin.top + (1 - v.between / maxVar) * chartHeight;

                if (i === 0) {
                    varCtx.moveTo(x, y);
                } else {
                    varCtx.lineTo(x, y);
                }
            });
            varCtx.stroke();

            // Within-group variance
            varCtx.strokeStyle = '#e74c3c';
            varCtx.beginPath();

            variationHistory.forEach((v, i) => {
                const x = margin.left + (i / variationHistory.length) * chartWidth;
                const y = margin.top + (1 - v.within / maxVar) * chartHeight;

                if (i === 0) {
                    varCtx.moveTo(x, y);
                } else {
                    varCtx.lineTo(x, y);
                }
            });
            varCtx.stroke();

            // Legend
            varCtx.fillStyle = '#3498db';
            varCtx.font = '10px sans-serif';
            varCtx.textAlign = 'left';
            varCtx.fillText('Between-group', margin.left + 10, margin.top + 15);

            varCtx.fillStyle = '#e74c3c';
            varCtx.fillText('Within-group', margin.left + 100, margin.top + 15);
        }

        // Main draw function
        function draw() {
            drawLandscape();
            drawEvolution();
            drawFitnessDistribution();
            drawVariation();
            updateStats();
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;

            for (let i = 0; i < speed; i++) {
                step();
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        elements.numGroups.addEventListener('input', (e) => {
            numGroups = parseInt(e.target.value);
            elements.numGroupsVal.textContent = numGroups;
        });

        elements.groupSize.addEventListener('input', (e) => {
            groupSize = parseInt(e.target.value);
            elements.groupSizeVal.textContent = groupSize;
        });

        elements.initCooperation.addEventListener('input', (e) => {
            initCooperation = parseInt(e.target.value) / 100;
            elements.initCooperationVal.textContent = e.target.value;
        });

        elements.benefitCoop.addEventListener('input', (e) => {
            benefitCoop = parseFloat(e.target.value);
            elements.benefitCoopVal.textContent = benefitCoop.toFixed(1);
        });

        elements.costCoop.addEventListener('input', (e) => {
            costCoop = parseFloat(e.target.value);
            elements.costCoopVal.textContent = costCoop.toFixed(1);
        });

        elements.groupSelectionStrength.addEventListener('input', (e) => {
            groupSelectionStrength = parseFloat(e.target.value);
            elements.groupSelectionStrengthVal.textContent = groupSelectionStrength.toFixed(2);
        });

        elements.migrationRate.addEventListener('input', (e) => {
            migrationRate = parseFloat(e.target.value);
            elements.migrationRateVal.textContent = migrationRate.toFixed(2);
        });

        elements.conformityBias.addEventListener('input', (e) => {
            conformityBias = parseFloat(e.target.value);
            elements.conformityBiasVal.textContent = conformityBias.toFixed(2);
        });

        elements.enablePunishment.addEventListener('change', (e) => {
            enablePunishment = e.target.value === 'true';
        });

        elements.punishmentCost.addEventListener('input', (e) => {
            punishmentCost = parseFloat(e.target.value);
            elements.punishmentCostVal.textContent = punishmentCost.toFixed(2);
        });

        elements.speed.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            elements.speedVal.textContent = speed;
        });

        elements.startBtn.addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                elements.startBtn.textContent = 'Running...';
                animate();
            }
        });

        elements.pauseBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        });

        elements.resetBtn.addEventListener('click', () => {
            isRunning = false;
            elements.startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            initializeGroups();
        });

        // Initialize
        initializeGroups();
    </script>
</body>
</html>
