<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pedestrian Dynamics - Social Force Model</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .section-title {
            font-family: 'Lora', serif;
            color: var(--moss);
            font-size: 1rem;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--terracotta);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--sage);
        }

        button.scenario-btn {
            font-size: 0.85rem;
            padding: 8px 12px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--sage) 0%, var(--moss) 100%);
            color: white;
            padding: 12px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-box .label {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .stat-box .value {
            font-size: 1.3rem;
            font-weight: 700;
            font-family: 'Lora', serif;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .info-panel h3 {
            color: var(--moss);
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        @media (max-width: 900px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span>←</span>
        <span>Back to Gallery</span>
    </a>

    <div class="container">
        <h1>Pedestrian Dynamics</h1>
        <p class="subtitle">Social Force Model with Emergent Lane Formation</p>

        <div class="simulation-area">
            <div class="controls">
                <h3 class="section-title">Population</h3>
                <div class="control-group">
                    <label>Number of Pedestrians</label>
                    <input type="range" id="numPeds" min="20" max="200" value="80">
                    <div class="value" id="numPedsValue">80</div>
                </div>

                <div class="control-group">
                    <label>Desired Speed (m/s)</label>
                    <input type="range" id="desiredSpeed" min="0.5" max="3.0" step="0.1" value="1.4">
                    <div class="value" id="desiredSpeedValue">1.4</div>
                </div>

                <h3 class="section-title">Social Forces</h3>
                <div class="control-group">
                    <label>Repulsion Strength</label>
                    <input type="range" id="repulsion" min="0.5" max="5" step="0.1" value="2.0">
                    <div class="value" id="repulsionValue">2.0</div>
                </div>

                <div class="control-group">
                    <label>Repulsion Range (m)</label>
                    <input type="range" id="repulsionRange" min="0.2" max="2.0" step="0.1" value="0.8">
                    <div class="value" id="repulsionRangeValue">0.8</div>
                </div>

                <div class="control-group">
                    <label>Wall Repulsion</label>
                    <input type="range" id="wallRepulsion" min="1" max="10" step="0.5" value="5">
                    <div class="value" id="wallRepulsionValue">5.0</div>
                </div>

                <h3 class="section-title">Environment</h3>
                <div class="control-group">
                    <label>Corridor Width (m)</label>
                    <input type="range" id="corridorWidth" min="3" max="12" step="0.5" value="6">
                    <div class="value" id="corridorWidthValue">6.0</div>
                </div>

                <div class="control-group">
                    <label>Bottleneck Width (m)</label>
                    <input type="range" id="bottleneckWidth" min="0.5" max="4" step="0.25" value="2">
                    <div class="value" id="bottleneckWidthValue">2.0</div>
                </div>

                <button id="runBtn">▶ Run Simulation</button>
                <button id="resetBtn" class="secondary">Reset</button>

                <div class="info-panel">
                    <h3>Scenarios</h3>
                    <button class="scenario-btn" onclick="applyScenario('bidirectional')">Bidirectional Flow</button>
                    <button class="scenario-btn" onclick="applyScenario('bottleneck')">Bottleneck</button>
                    <button class="scenario-btn" onclick="applyScenario('panic')">Panic Mode</button>
                    <button class="scenario-btn" onclick="applyScenario('crossing')">Crossing Flows</button>
                </div>

                <div class="info-panel">
                    <h3>About Social Force Model</h3>
                    <p>Pedestrian motion follows Newton's second law with social forces:</p>
                    <ul style="margin-left: 15px; margin-top: 5px;">
                        <li><strong>Driving force:</strong> Accelerate toward goal</li>
                        <li><strong>Repulsive force:</strong> Maintain distance from others</li>
                        <li><strong>Wall force:</strong> Avoid obstacles/walls</li>
                    </ul>
                    <p style="margin-top: 8px;">Watch for emergent <strong>lane formation</strong> in bidirectional flows!</p>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas"></canvas>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #3498db;"></div>
                        <span>Moving Right →</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #e74c3c;"></div>
                        <span>← Moving Left</span>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div class="label">Time (s)</div>
                        <div class="value" id="statTime">0.0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Avg Speed</div>
                        <div class="value" id="statSpeed">0.0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Flow Rate</div>
                        <div class="value" id="statFlow">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Lanes</div>
                        <div class="value" id="statLanes">0</div>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>Key Phenomena</h3>
                    <p><strong>Lane Formation:</strong> In bidirectional flows, pedestrians spontaneously organize into lanes of uniform direction.</p>
                    <p style="margin-top: 5px;"><strong>Faster-is-Slower:</strong> At bottlenecks, increasing desired speed can reduce throughput due to jamming.</p>
                    <p style="margin-top: 5px;"><strong>Arch Formation:</strong> High density at exits creates arch-shaped blockages.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 40) * dpr;
            canvas.height = 500 * dpr;
            canvas.style.width = (rect.width - 40) + 'px';
            canvas.style.height = '500px';
            ctx.scale(dpr, dpr);
        }
        setupCanvas();
        window.addEventListener('resize', () => {
            setupCanvas();
            draw();
        });

        // Simulation parameters
        let params = {
            numPeds: 80,
            desiredSpeed: 1.4,
            repulsion: 2.0,
            repulsionRange: 0.8,
            wallRepulsion: 5.0,
            corridorWidth: 6.0,
            bottleneckWidth: 2.0,
            scenario: 'bidirectional'
        };

        // Physics constants
        const TAU = 0.5; // Relaxation time
        const DT = 0.05; // Time step
        const PEDESTRIAN_RADIUS = 0.25; // meters

        // Simulation state
        let pedestrians = [];
        let walls = [];
        let time = 0;
        let running = false;
        let animationId = null;
        let flowCounter = 0;
        let lastFlowTime = 0;

        // Scale: pixels per meter
        let scale = 40;

        // Pedestrian class
        class Pedestrian {
            constructor(x, y, direction) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = PEDESTRIAN_RADIUS + (Math.random() - 0.5) * 0.1;
                this.desiredSpeed = params.desiredSpeed * (0.8 + Math.random() * 0.4);
                this.direction = direction; // 1 = right, -1 = left
                this.color = direction > 0 ? '#3498db' : '#e74c3c';
                this.reached = false;
            }

            getDesiredVelocity() {
                if (params.scenario === 'crossing') {
                    // Diagonal crossing
                    const angle = this.direction > 0 ? Math.PI / 6 : Math.PI - Math.PI / 6;
                    return {
                        vx: this.desiredSpeed * Math.cos(angle) * this.direction,
                        vy: this.desiredSpeed * Math.sin(angle) * (this.direction > 0 ? 1 : -1)
                    };
                }
                return {
                    vx: this.desiredSpeed * this.direction,
                    vy: 0
                };
            }

            calculateForces(others) {
                // Driving force (toward desired velocity)
                const desired = this.getDesiredVelocity();
                let fx = (desired.vx - this.vx) / TAU;
                let fy = (desired.vy - this.vy) / TAU;

                // Social forces from other pedestrians
                for (const other of others) {
                    if (other === this) continue;

                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = this.radius + other.radius;

                    if (dist < params.repulsionRange + minDist && dist > 0) {
                        // Exponential repulsion
                        const force = params.repulsion * Math.exp((minDist - dist) / params.repulsionRange);
                        fx += force * dx / dist;
                        fy += force * dy / dist;

                        // Physical contact force (if overlapping)
                        if (dist < minDist) {
                            const overlap = minDist - dist;
                            fx += 10 * overlap * dx / dist;
                            fy += 10 * overlap * dy / dist;
                        }
                    }
                }

                // Wall forces
                for (const wall of walls) {
                    const wallForce = this.calculateWallForce(wall);
                    fx += wallForce.fx;
                    fy += wallForce.fy;
                }

                return { fx, fy };
            }

            calculateWallForce(wall) {
                // Find closest point on wall segment
                const { x1, y1, x2, y2 } = wall;
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len2 = dx * dx + dy * dy;

                let t = Math.max(0, Math.min(1, ((this.x - x1) * dx + (this.y - y1) * dy) / len2));
                const closestX = x1 + t * dx;
                const closestY = y1 + t * dy;

                const distX = this.x - closestX;
                const distY = this.y - closestY;
                const dist = Math.sqrt(distX * distX + distY * distY);

                const minDist = this.radius;
                let fx = 0, fy = 0;

                if (dist < params.repulsionRange + minDist && dist > 0) {
                    const force = params.wallRepulsion * Math.exp((minDist - dist) / 0.3);
                    fx = force * distX / dist;
                    fy = force * distY / dist;

                    // Physical contact
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        fx += 20 * overlap * distX / dist;
                        fy += 20 * overlap * distY / dist;
                    }
                }

                return { fx, fy };
            }

            update(others) {
                const forces = this.calculateForces(others);

                // Apply forces (with mass = 1)
                this.vx += forces.fx * DT;
                this.vy += forces.fy * DT;

                // Speed limit
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const maxSpeed = params.scenario === 'panic' ? this.desiredSpeed * 2 : this.desiredSpeed * 1.5;
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                // Update position
                this.x += this.vx * DT;
                this.y += this.vy * DT;
            }
        }

        // Initialize walls based on scenario
        function initWalls() {
            walls = [];
            const width = canvas.width / (window.devicePixelRatio || 1) / scale;
            const height = params.corridorWidth;
            const centerY = (canvas.height / (window.devicePixelRatio || 1) / scale) / 2;

            // Top and bottom walls
            walls.push({ x1: 0, y1: centerY - height/2, x2: width, y2: centerY - height/2 });
            walls.push({ x1: 0, y1: centerY + height/2, x2: width, y2: centerY + height/2 });

            // Add bottleneck if applicable
            if (params.scenario === 'bottleneck') {
                const bottleX = width / 2;
                const bottleLen = 1.5;
                const opening = params.bottleneckWidth / 2;

                // Top bottleneck wall
                walls.push({
                    x1: bottleX - bottleLen, y1: centerY - height/2,
                    x2: bottleX + bottleLen, y2: centerY - opening
                });
                walls.push({
                    x1: bottleX + bottleLen, y1: centerY - opening,
                    x2: bottleX + bottleLen, y2: centerY - height/2
                });

                // Bottom bottleneck wall
                walls.push({
                    x1: bottleX - bottleLen, y1: centerY + height/2,
                    x2: bottleX + bottleLen, y2: centerY + opening
                });
                walls.push({
                    x1: bottleX + bottleLen, y1: centerY + opening,
                    x2: bottleX + bottleLen, y2: centerY + height/2
                });
            }
        }

        // Initialize pedestrians
        function initPedestrians() {
            pedestrians = [];
            const width = canvas.width / (window.devicePixelRatio || 1) / scale;
            const height = params.corridorWidth;
            const centerY = (canvas.height / (window.devicePixelRatio || 1) / scale) / 2;

            for (let i = 0; i < params.numPeds; i++) {
                let x, y, direction;

                if (params.scenario === 'bidirectional' || params.scenario === 'bottleneck') {
                    direction = i < params.numPeds / 2 ? 1 : -1;
                    x = direction > 0 ?
                        Math.random() * width * 0.3 + 0.5 :
                        width - Math.random() * width * 0.3 - 0.5;
                    y = centerY - height/2 + 0.5 + Math.random() * (height - 1);
                } else if (params.scenario === 'panic') {
                    direction = 1;
                    x = Math.random() * width * 0.4 + 0.5;
                    y = centerY - height/2 + 0.5 + Math.random() * (height - 1);
                } else { // crossing
                    direction = i < params.numPeds / 2 ? 1 : -1;
                    if (direction > 0) {
                        x = Math.random() * width * 0.3 + 0.5;
                        y = centerY + height/4 + Math.random() * height/4;
                    } else {
                        x = width - Math.random() * width * 0.3 - 0.5;
                        y = centerY - height/4 - Math.random() * height/4;
                    }
                }

                pedestrians.push(new Pedestrian(x, y, direction));
            }

            // Ensure no initial overlaps
            for (let iter = 0; iter < 20; iter++) {
                for (let i = 0; i < pedestrians.length; i++) {
                    for (let j = i + 1; j < pedestrians.length; j++) {
                        const p1 = pedestrians[i];
                        const p2 = pedestrians[j];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = p1.radius + p2.radius + 0.1;

                        if (dist < minDist && dist > 0) {
                            const push = (minDist - dist) / 2;
                            p1.x -= push * dx / dist;
                            p1.y -= push * dy / dist;
                            p2.x += push * dx / dist;
                            p2.y += push * dy / dist;
                        }
                    }
                }
            }
        }

        // Initialize simulation
        function initSimulation() {
            initWalls();
            initPedestrians();
            time = 0;
            flowCounter = 0;
            lastFlowTime = 0;
            updateStats();
        }

        // Step simulation
        function step() {
            time += DT;

            // Update all pedestrians
            for (const ped of pedestrians) {
                ped.update(pedestrians);
            }

            // Wrap or respawn pedestrians
            const width = canvas.width / (window.devicePixelRatio || 1) / scale;
            const height = params.corridorWidth;
            const centerY = (canvas.height / (window.devicePixelRatio || 1) / scale) / 2;

            for (const ped of pedestrians) {
                if (ped.direction > 0 && ped.x > width - 0.5) {
                    flowCounter++;
                    ped.x = 0.5 + Math.random() * 0.5;
                    ped.y = centerY - height/2 + 0.5 + Math.random() * (height - 1);
                    ped.vx = 0;
                    ped.vy = 0;
                } else if (ped.direction < 0 && ped.x < 0.5) {
                    flowCounter++;
                    ped.x = width - 0.5 - Math.random() * 0.5;
                    ped.y = centerY - height/2 + 0.5 + Math.random() * (height - 1);
                    ped.vx = 0;
                    ped.vy = 0;
                }
            }

            updateStats();
        }

        // Update statistics
        function updateStats() {
            document.getElementById('statTime').textContent = time.toFixed(1);

            // Average speed
            let totalSpeed = 0;
            for (const ped of pedestrians) {
                totalSpeed += Math.sqrt(ped.vx * ped.vx + ped.vy * ped.vy);
            }
            const avgSpeed = pedestrians.length > 0 ? totalSpeed / pedestrians.length : 0;
            document.getElementById('statSpeed').textContent = avgSpeed.toFixed(2) + ' m/s';

            // Flow rate (pedestrians per minute)
            const flowRate = time > 1 ? (flowCounter / time) * 60 : 0;
            document.getElementById('statFlow').textContent = Math.round(flowRate) + '/min';

            // Estimate number of lanes
            const lanes = detectLanes();
            document.getElementById('statLanes').textContent = lanes;
        }

        // Detect lane formation
        function detectLanes() {
            if (pedestrians.length < 10) return 0;

            const height = params.corridorWidth;
            const centerY = (canvas.height / (window.devicePixelRatio || 1) / scale) / 2;
            const bands = 10;
            const bandHeight = height / bands;

            let laneCount = 0;
            let lastDirection = 0;

            for (let b = 0; b < bands; b++) {
                const bandY = centerY - height/2 + (b + 0.5) * bandHeight;
                let rightCount = 0, leftCount = 0;

                for (const ped of pedestrians) {
                    if (Math.abs(ped.y - bandY) < bandHeight / 2) {
                        if (ped.direction > 0) rightCount++;
                        else leftCount++;
                    }
                }

                const total = rightCount + leftCount;
                if (total > 0) {
                    const dominance = Math.max(rightCount, leftCount) / total;
                    if (dominance > 0.7) {
                        const dir = rightCount > leftCount ? 1 : -1;
                        if (dir !== lastDirection && lastDirection !== 0) {
                            laneCount++;
                        }
                        lastDirection = dir;
                    }
                }
            }

            return Math.max(1, laneCount + 1);
        }

        // Draw simulation
        function draw() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            // Clear
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            // Draw floor
            const corridorTop = height/2 - (params.corridorWidth * scale)/2;
            const corridorBottom = height/2 + (params.corridorWidth * scale)/2;
            ctx.fillStyle = '#E8E4D4';
            ctx.fillRect(0, corridorTop, width, corridorBottom - corridorTop);

            // Draw walls
            ctx.strokeStyle = '#606C38';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';

            for (const wall of walls) {
                ctx.beginPath();
                ctx.moveTo(wall.x1 * scale, wall.y1 * scale);
                ctx.lineTo(wall.x2 * scale, wall.y2 * scale);
                ctx.stroke();
            }

            // Draw pedestrians
            for (const ped of pedestrians) {
                const x = ped.x * scale;
                const y = ped.y * scale;
                const r = ped.radius * scale;

                // Shadow
                ctx.beginPath();
                ctx.arc(x + 2, y + 2, r, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = ped.color;
                ctx.fill();

                // Direction indicator
                const speed = Math.sqrt(ped.vx * ped.vx + ped.vy * ped.vy);
                if (speed > 0.1) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + (ped.vx / speed) * r * 0.8, y + (ped.vy / speed) * r * 0.8);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Draw info
            ctx.fillStyle = '#606C38';
            ctx.font = 'bold 14px Nunito';
            ctx.textAlign = 'left';
            ctx.fillText(`Scenario: ${params.scenario}`, 10, 20);
        }

        // Animation loop
        function animate() {
            if (!running) return;

            step();
            draw();

            animationId = requestAnimationFrame(animate);
        }

        // Event handlers
        document.getElementById('runBtn').addEventListener('click', () => {
            if (running) {
                running = false;
                cancelAnimationFrame(animationId);
                document.getElementById('runBtn').textContent = '▶ Run Simulation';
            } else {
                running = true;
                document.getElementById('runBtn').textContent = '⏸ Pause';
                animate();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            cancelAnimationFrame(animationId);
            document.getElementById('runBtn').textContent = '▶ Run Simulation';
            initSimulation();
            draw();
        });

        // Scenario presets
        window.applyScenario = function(scenario) {
            running = false;
            cancelAnimationFrame(animationId);
            document.getElementById('runBtn').textContent = '▶ Run Simulation';

            params.scenario = scenario;

            switch(scenario) {
                case 'bidirectional':
                    params.numPeds = 80;
                    params.desiredSpeed = 1.4;
                    params.corridorWidth = 6;
                    params.bottleneckWidth = 2;
                    break;
                case 'bottleneck':
                    params.numPeds = 60;
                    params.desiredSpeed = 1.2;
                    params.corridorWidth = 8;
                    params.bottleneckWidth = 1.5;
                    break;
                case 'panic':
                    params.numPeds = 100;
                    params.desiredSpeed = 3.0;
                    params.corridorWidth = 6;
                    params.repulsion = 3.0;
                    break;
                case 'crossing':
                    params.numPeds = 60;
                    params.desiredSpeed = 1.4;
                    params.corridorWidth = 8;
                    break;
            }

            // Update UI
            document.getElementById('numPeds').value = params.numPeds;
            document.getElementById('numPedsValue').textContent = params.numPeds;
            document.getElementById('desiredSpeed').value = params.desiredSpeed;
            document.getElementById('desiredSpeedValue').textContent = params.desiredSpeed;
            document.getElementById('corridorWidth').value = params.corridorWidth;
            document.getElementById('corridorWidthValue').textContent = params.corridorWidth;
            document.getElementById('bottleneckWidth').value = params.bottleneckWidth;
            document.getElementById('bottleneckWidthValue').textContent = params.bottleneckWidth;

            initSimulation();
            draw();
        };

        // Parameter controls
        const controls = [
            { id: 'numPeds', param: 'numPeds', display: 'numPedsValue' },
            { id: 'desiredSpeed', param: 'desiredSpeed', display: 'desiredSpeedValue' },
            { id: 'repulsion', param: 'repulsion', display: 'repulsionValue' },
            { id: 'repulsionRange', param: 'repulsionRange', display: 'repulsionRangeValue' },
            { id: 'wallRepulsion', param: 'wallRepulsion', display: 'wallRepulsionValue' },
            { id: 'corridorWidth', param: 'corridorWidth', display: 'corridorWidthValue' },
            { id: 'bottleneckWidth', param: 'bottleneckWidth', display: 'bottleneckWidthValue' }
        ];

        controls.forEach(ctrl => {
            const input = document.getElementById(ctrl.id);
            const display = document.getElementById(ctrl.display);

            input.addEventListener('input', () => {
                const val = parseFloat(input.value);
                display.textContent = val;
                params[ctrl.param] = val;
            });
        });

        // Initialize
        initSimulation();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
