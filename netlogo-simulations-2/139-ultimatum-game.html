<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimatum Game - Fairness & Rejection</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { display: block; width: 100%; border-radius: 8px; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; }
        .control-group .value { color: #8A9A5B; font-size: 0.85rem; }
        button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; margin-right: 8px; margin-bottom: 8px; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-box { background: #FEFAE0; border-radius: 8px; padding: 12px; margin-top: 15px; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #EDE8D5; }
        .stat:last-child { border-bottom: none; }
        .stat-label { color: #606C38; font-size: 0.85rem; }
        .stat-value { color: #BC6C25; font-weight: 600; font-size: 0.9rem; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.85rem; color: #606C38; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .offer-display { text-align: center; padding: 15px; background: #E9F5E9; border-radius: 8px; margin-bottom: 15px; }
        .offer-display .amount { font-size: 2rem; color: #606C38; font-family: 'Lora', serif; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Ultimatum Game</h1>
            <p class="subtitle">Fairness preferences, rejection behavior, and reputation effects</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="offer-display">
                    <div>Stake: $<span id="stakeAmount">100</span></div>
                    <div class="amount">Avg Offer: <span id="avgOffer">50%</span></div>
                </div>

                <div class="control-group">
                    <label>Stake Amount: <span class="value" id="valueStake">$100</span></label>
                    <input type="range" id="stake" min="10" max="1000" value="100" step="10">
                </div>

                <div class="control-group">
                    <label>Population: <span class="value" id="valuePop">100</span></label>
                    <input type="range" id="population" min="20" max="300" value="100">
                </div>

                <div class="control-group">
                    <label>Fairness Weight (β): <span class="value" id="valueFair">0.30</span></label>
                    <input type="range" id="fairness" min="0" max="100" value="30">
                </div>

                <div class="control-group">
                    <label>Reputation Effect: <span class="value" id="valueRep">0.20</span></label>
                    <input type="range" id="reputation" min="0" max="100" value="20">
                </div>

                <div class="control-group">
                    <label>Mutation Rate: <span class="value" id="valueMut">0.05</span></label>
                    <input type="range" id="mutation" min="0" max="100" value="50">
                </div>

                <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                <button class="btn-secondary" onclick="togglePause()">Pause</button>

                <div class="stats-box">
                    <div class="stat"><span class="stat-label">Generation:</span><span class="stat-value" id="genStat">0</span></div>
                    <div class="stat"><span class="stat-label">Avg Offer:</span><span class="stat-value" id="offerStat">50%</span></div>
                    <div class="stat"><span class="stat-label">Avg Threshold:</span><span class="stat-value" id="threshStat">30%</span></div>
                    <div class="stat"><span class="stat-label">Acceptance Rate:</span><span class="stat-value" id="acceptStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Avg Payoff:</span><span class="stat-value" id="payoffStat">$0</span></div>
                    <div class="stat"><span class="stat-label">Game Theory Prediction:</span><span class="stat-value" id="gtStat">1%, Accept</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <strong>About this simulation:</strong> The Ultimatum Game (Güth et al., 1982) reveals human fairness preferences.
            A <strong>proposer</strong> offers a split of money; a <strong>responder</strong> accepts or rejects.
            If rejected, both get nothing. Rational self-interest predicts minimal offers, but experiments show
            offers around 40-50% and rejections of offers below 30%. This simulation evolves both offer strategies
            and rejection thresholds, demonstrating how <strong>fairness norms</strong> emerge.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = 600 * dpr;
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = 600;

        let stake = 100;
        let popSize = 100;
        let fairnessWeight = 0.3;
        let reputationEffect = 0.2;
        let mutationRate = 0.05;

        let agents = [];
        let history = { offers: [], thresholds: [], acceptance: [] };
        let generation = 0;
        let paused = false;

        function initSimulation() {
            agents = [];
            history = { offers: [], thresholds: [], acceptance: [] };
            generation = 0;

            for (let i = 0; i < popSize; i++) {
                agents.push({
                    // Offer percentage when proposer (0-100)
                    offerPct: Math.random() * 60 + 20, // Start between 20-80%
                    // Minimum acceptable offer when responder (0-100)
                    threshold: Math.random() * 50, // Start between 0-50%
                    fitness: 0,
                    reputation: 0.5,
                    x: Math.random() * (width - 100) + 50,
                    y: Math.random() * (height - 250) + 50
                });
            }
        }

        function playGames() {
            // Reset fitness
            agents.forEach(a => a.fitness = 0);

            // Random matchings - each agent plays as both proposer and responder
            const shuffled = [...agents].sort(() => Math.random() - 0.5);

            for (let i = 0; i < agents.length; i++) {
                const partner = shuffled[(i + 1) % agents.length];

                // Agent i as proposer, partner as responder
                const offer1 = agents[i].offerPct;
                const threshold1 = partner.threshold;

                // Fairness-adjusted threshold (more fair people have lower thresholds)
                const adjustedThreshold1 = threshold1 * (1 - partner.reputation * reputationEffect);

                if (offer1 >= adjustedThreshold1) {
                    // Accept
                    agents[i].fitness += stake * (100 - offer1) / 100;
                    partner.fitness += stake * offer1 / 100;
                    partner.reputation = Math.min(1, partner.reputation + 0.01);
                } else {
                    // Reject - both get nothing
                    // Responder pays fairness cost but maintains reputation
                    partner.fitness -= fairnessWeight * stake * offer1 / 100;
                    agents[i].reputation = Math.max(0, agents[i].reputation - 0.02);
                }

                // Partner as proposer, agent i as responder
                const offer2 = partner.offerPct;
                const threshold2 = agents[i].threshold;
                const adjustedThreshold2 = threshold2 * (1 - agents[i].reputation * reputationEffect);

                if (offer2 >= adjustedThreshold2) {
                    partner.fitness += stake * (100 - offer2) / 100;
                    agents[i].fitness += stake * offer2 / 100;
                    agents[i].reputation = Math.min(1, agents[i].reputation + 0.01);
                } else {
                    agents[i].fitness -= fairnessWeight * stake * offer2 / 100;
                    partner.reputation = Math.max(0, partner.reputation - 0.02);
                }
            }
        }

        function calculateAcceptanceRate() {
            let accepts = 0;
            let total = 0;

            for (let i = 0; i < agents.length; i++) {
                for (let j = i + 1; j < agents.length; j++) {
                    const offer = agents[i].offerPct;
                    const threshold = agents[j].threshold * (1 - agents[j].reputation * reputationEffect);
                    if (offer >= threshold) accepts++;
                    total++;

                    const offer2 = agents[j].offerPct;
                    const threshold2 = agents[i].threshold * (1 - agents[i].reputation * reputationEffect);
                    if (offer2 >= threshold2) accepts++;
                    total++;
                }
            }

            return total > 0 ? accepts / total : 0;
        }

        function evolve() {
            // Normalize fitness
            const minFitness = Math.min(...agents.map(a => a.fitness));
            agents.forEach(a => a.fitness = a.fitness - minFitness + 1);

            const totalFitness = agents.reduce((sum, a) => sum + a.fitness, 0);

            const newAgents = [];

            for (let i = 0; i < popSize; i++) {
                // Fitness-proportional selection
                let r = Math.random() * totalFitness;
                let parent = agents[0];
                for (const a of agents) {
                    r -= a.fitness;
                    if (r <= 0) {
                        parent = a;
                        break;
                    }
                }

                let offerPct = parent.offerPct;
                let threshold = parent.threshold;

                // Mutation
                if (Math.random() < mutationRate) {
                    offerPct += (Math.random() - 0.5) * 20;
                }
                if (Math.random() < mutationRate) {
                    threshold += (Math.random() - 0.5) * 20;
                }

                // Clamp values
                offerPct = Math.max(0, Math.min(100, offerPct));
                threshold = Math.max(0, Math.min(100, threshold));

                newAgents.push({
                    offerPct,
                    threshold,
                    fitness: 0,
                    reputation: 0.5,
                    x: Math.random() * (width - 100) + 50,
                    y: Math.random() * (height - 250) + 50
                });
            }

            agents = newAgents;
            generation++;
        }

        function getStats() {
            const avgOffer = agents.reduce((sum, a) => sum + a.offerPct, 0) / popSize;
            const avgThreshold = agents.reduce((sum, a) => sum + a.threshold, 0) / popSize;
            const avgPayoff = agents.reduce((sum, a) => sum + a.fitness, 0) / popSize;
            return { avgOffer, avgThreshold, avgPayoff };
        }

        function draw() {
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            // Draw agents as bubbles positioned by their strategies
            const plotWidth = width - 100;
            const plotHeight = 300;
            const plotX = 50;
            const plotY = 30;

            // Axes
            ctx.strokeStyle = '#DDA15E';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(plotX, plotY + plotHeight);
            ctx.lineTo(plotX + plotWidth, plotY + plotHeight);
            ctx.moveTo(plotX, plotY);
            ctx.lineTo(plotX, plotY + plotHeight);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = '#606C38';
            ctx.font = '12px Nunito';
            ctx.fillText('Offer % (proposer strategy)', plotX + plotWidth/2 - 80, plotY + plotHeight + 25);
            ctx.save();
            ctx.translate(15, plotY + plotHeight/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Threshold % (responder strategy)', -80, 0);
            ctx.restore();

            // Tick marks
            for (let i = 0; i <= 100; i += 20) {
                const x = plotX + (i / 100) * plotWidth;
                ctx.fillText(i + '%', x - 10, plotY + plotHeight + 15);

                const y = plotY + plotHeight - (i / 100) * plotHeight;
                ctx.fillText(i + '%', plotX - 30, y + 4);
            }

            // 50% fairness line
            ctx.strokeStyle = '#E63946';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            const x50 = plotX + 0.5 * plotWidth;
            ctx.moveTo(x50, plotY);
            ctx.lineTo(x50, plotY + plotHeight);
            ctx.stroke();

            // 30% rejection threshold line
            const y30 = plotY + plotHeight - 0.3 * plotHeight;
            ctx.moveTo(plotX, y30);
            ctx.lineTo(plotX + plotWidth, y30);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw agents
            agents.forEach(a => {
                const x = plotX + (a.offerPct / 100) * plotWidth;
                const y = plotY + plotHeight - (a.threshold / 100) * plotHeight;

                // Color based on fitness
                const normalizedFitness = Math.min(1, Math.max(0, a.fitness / (stake * 2)));
                const hue = 120 * normalizedFitness; // Green = high fitness
                ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.6)`;
                ctx.beginPath();
                ctx.arc(x, y, 4 + a.reputation * 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw offer distribution histogram
            const histY = plotY + plotHeight + 50;
            const histHeight = 80;
            const bins = new Array(20).fill(0);

            agents.forEach(a => {
                const bin = Math.min(19, Math.floor(a.offerPct / 5));
                bins[bin]++;
            });

            const maxBin = Math.max(...bins, 1);
            const binWidth = plotWidth / 20;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(plotX, histY, plotWidth, histHeight + 20);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(plotX, histY, plotWidth, histHeight + 20);

            bins.forEach((count, i) => {
                const h = (count / maxBin) * histHeight;
                const x = plotX + i * binWidth;
                ctx.fillStyle = '#8A9A5B';
                ctx.fillRect(x + 1, histY + histHeight - h + 5, binWidth - 2, h);
            });

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Offer Distribution', plotX + 5, histY + 15);

            // Draw history chart
            const chartY = height - 130;
            const chartHeight = 110;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, chartY, width - 40, chartHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, chartY, width - 40, chartHeight);

            if (history.offers.length > 1) {
                const maxPoints = 200;
                const startIdx = Math.max(0, history.offers.length - maxPoints);
                const step = (width - 60) / Math.max(1, Math.min(history.offers.length, maxPoints) - 1);

                // Average offer
                ctx.beginPath();
                for (let i = startIdx; i < history.offers.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - (history.offers[i] / 100) * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#8A9A5B';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Average threshold
                ctx.beginPath();
                for (let i = startIdx; i < history.thresholds.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - (history.thresholds[i] / 100) * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#BC6C25';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Acceptance rate
                ctx.beginPath();
                for (let i = startIdx; i < history.acceptance.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.acceptance[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#457B9D';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Green: Avg Offer, Orange: Avg Threshold, Blue dashed: Acceptance Rate', 30, chartY + 12);
        }

        function updateStats() {
            const stats = getStats();
            const acceptRate = calculateAcceptanceRate();

            document.getElementById('genStat').textContent = generation;
            document.getElementById('offerStat').textContent = stats.avgOffer.toFixed(1) + '%';
            document.getElementById('threshStat').textContent = stats.avgThreshold.toFixed(1) + '%';
            document.getElementById('acceptStat').textContent = (acceptRate * 100).toFixed(1) + '%';
            document.getElementById('payoffStat').textContent = '$' + stats.avgPayoff.toFixed(2);
            document.getElementById('avgOffer').textContent = stats.avgOffer.toFixed(0) + '%';
        }

        function updateControls() {
            stake = parseInt(document.getElementById('stake').value);
            popSize = parseInt(document.getElementById('population').value);
            fairnessWeight = parseInt(document.getElementById('fairness').value) / 100;
            reputationEffect = parseInt(document.getElementById('reputation').value) / 100;
            mutationRate = parseInt(document.getElementById('mutation').value) / 1000;

            document.getElementById('valueStake').textContent = '$' + stake;
            document.getElementById('valuePop').textContent = popSize;
            document.getElementById('valueFair').textContent = fairnessWeight.toFixed(2);
            document.getElementById('valueRep').textContent = reputationEffect.toFixed(2);
            document.getElementById('valueMut').textContent = mutationRate.toFixed(3);
            document.getElementById('stakeAmount').textContent = stake;
        }

        function resetSimulation() {
            updateControls();
            initSimulation();
        }

        function togglePause() {
            paused = !paused;
        }

        let frameCount = 0;
        function animate() {
            if (!paused) {
                frameCount++;
                if (frameCount % 10 === 0) {
                    playGames();
                    evolve();

                    const stats = getStats();
                    const acceptRate = calculateAcceptanceRate();
                    history.offers.push(stats.avgOffer);
                    history.thresholds.push(stats.avgThreshold);
                    history.acceptance.push(acceptRate);

                    if (history.offers.length > 500) {
                        history.offers.shift();
                        history.thresholds.shift();
                        history.acceptance.shift();
                    }

                    updateStats();
                }
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', updateControls);
        });

        updateControls();
        initSimulation();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
