<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Linked Polymer Networks - NetLogo-Style Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #9b59b6, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .panel h3 {
            color: #9b59b6;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(155, 89, 182, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85em;
            color: #9b59b6;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #9b59b6, #3498db);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-stretch {
            background: linear-gradient(135deg, #e74c3c, #f39c12);
            color: white;
        }

        .btn-swell {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-wrapper h4 {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #9b59b6;
            font-size: 0.95em;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #9b59b6;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .stress-indicator {
            height: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        .stress-bar {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #f39c12, #e74c3c);
            transition: width 0.3s ease;
        }

        .mode-indicator {
            padding: 8px 15px;
            border-radius: 20px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .mode-relaxed {
            background: rgba(39, 174, 96, 0.3);
            color: #27ae60;
        }

        .mode-stretched {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .mode-swollen {
            background: rgba(52, 152, 219, 0.3);
            color: #3498db;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #9b59b6;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Cross-Linked Polymer Networks</h1>
            <p class="subtitle">Rubber Elasticity, Swelling Behavior, and Mechanical Properties</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h3>Network Parameters</h3>

                <div class="control-group">
                    <label>Network Type</label>
                    <select id="networkType">
                        <option value="random">Random Crosslinking</option>
                        <option value="tetrahedra">Tetrahedral Network</option>
                        <option value="diamond">Diamond-like Network</option>
                        <option value="star">Star Polymer Network</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Number of Chains</label>
                    <input type="range" id="numChains" min="20" max="200" value="80">
                    <div class="value"><span id="numChainsVal">80</span></div>
                </div>

                <div class="control-group">
                    <label>Crosslink Density (mol/cm³)</label>
                    <input type="range" id="crosslinkDensity" min="0.01" max="0.5" step="0.01" value="0.15">
                    <div class="value"><span id="crosslinkDensityVal">0.15</span></div>
                </div>

                <div class="control-group">
                    <label>Chain Length (segments)</label>
                    <input type="range" id="chainLength" min="5" max="30" value="12">
                    <div class="value"><span id="chainLengthVal">12</span></div>
                </div>

                <div class="control-group">
                    <label>Flory-Huggins χ Parameter</label>
                    <input type="range" id="chiParameter" min="0" max="1" step="0.01" value="0.4">
                    <div class="value"><span id="chiParameterVal">0.40</span></div>
                </div>

                <h3>Deformation Controls</h3>

                <div class="control-group">
                    <label>Stretch Ratio (λ)</label>
                    <input type="range" id="stretchRatio" min="1" max="3" step="0.01" value="1">
                    <div class="value"><span id="stretchRatioVal">1.00</span></div>
                </div>

                <div class="button-group">
                    <button class="btn-stretch" id="stretchBtn">Stretch</button>
                    <button class="btn-secondary" id="relaxBtn">Relax</button>
                </div>

                <div class="control-group">
                    <label>Solvent Volume Fraction</label>
                    <input type="range" id="solventFraction" min="0" max="0.9" step="0.01" value="0">
                    <div class="value"><span id="solventFractionVal">0.00</span></div>
                </div>

                <div class="button-group">
                    <button class="btn-swell" id="swellBtn">Swell</button>
                    <button class="btn-secondary" id="desorbBtn">Desorb</button>
                </div>

                <h3>Simulation Control</h3>

                <div class="button-group">
                    <button class="btn-primary" id="generateBtn">Generate Network</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box">
                    <strong>Flory-Rehner Equation:</strong><br>
                    Equilibrium swelling relates crosslink density to solvent uptake through mixing entropy and elastic response.
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <h4>Network Structure</h4>
                        <canvas id="networkCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Stress-Strain Response</h4>
                        <canvas id="stressStrainCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Swelling Isotherm</h4>
                        <canvas id="swellingCanvas" width="400" height="250"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Chain Conformation Distribution</h4>
                        <canvas id="conformationCanvas" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Network State</h3>

                <div class="mode-indicator mode-relaxed" id="modeIndicator">RELAXED</div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="currentStretch">1.00</div>
                        <div class="label">Stretch Ratio (λ)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="swellingRatio">1.00</div>
                        <div class="label">Swelling Ratio (Q)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="stress">0.00</div>
                        <div class="label">Stress (MPa)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="modulus">0.00</div>
                        <div class="label">Shear Modulus (MPa)</div>
                    </div>
                </div>

                <h3>Stress Level</h3>
                <div class="stress-indicator">
                    <div class="stress-bar" id="stressBar" style="width: 0%"></div>
                </div>

                <h3>Network Properties</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="numCrosslinks">0</div>
                        <div class="label">Crosslinks</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="avgMc">0</div>
                        <div class="label">Avg Mc (g/mol)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="networkConnectivity">0</div>
                        <div class="label">Connectivity</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="endToEndDist">0</div>
                        <div class="label">⟨R²⟩^0.5 (nm)</div>
                    </div>
                </div>

                <h3>Thermodynamics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="elasticEnergy">0.00</div>
                        <div class="label">Elastic (kJ/mol)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="mixingEnergy">0.00</div>
                        <div class="label">Mixing (kJ/mol)</div>
                    </div>
                </div>

                <h3>Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Polymer Chain</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Crosslink</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Solvent</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Stressed Chain</span>
                    </div>
                </div>

                <div class="info-box" id="modelInfo">
                    <strong>Affine Network Model:</strong><br>
                    Assumes chain ends deform affinely with macroscopic strain. Shear modulus G = νkT, where ν is crosslink density.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const networkCanvas = document.getElementById('networkCanvas');
        const stressStrainCanvas = document.getElementById('stressStrainCanvas');
        const swellingCanvas = document.getElementById('swellingCanvas');
        const conformationCanvas = document.getElementById('conformationCanvas');

        const netCtx = networkCanvas.getContext('2d');
        const ssCtx = stressStrainCanvas.getContext('2d');
        const swCtx = swellingCanvas.getContext('2d');
        const confCtx = conformationCanvas.getContext('2d');

        // Physical constants
        const kB = 1.38e-23;  // Boltzmann constant (J/K)
        const R = 8.314;       // Gas constant (J/mol·K)
        const T = 300;         // Temperature (K)
        const NA = 6.022e23;   // Avogadro's number

        // Network state
        let nodes = [];
        let chains = [];
        let crosslinks = [];
        let stretchRatio = 1.0;
        let solventFraction = 0.0;
        let targetStretch = 1.0;
        let targetSolvent = 0.0;

        // Parameters
        let numChains = 80;
        let crosslinkDensity = 0.15;
        let chainLength = 12;
        let chiParameter = 0.4;
        let networkType = 'random';

        // Animation
        let animationId = null;

        // UI Elements
        const elements = {
            networkType: document.getElementById('networkType'),
            numChains: document.getElementById('numChains'),
            numChainsVal: document.getElementById('numChainsVal'),
            crosslinkDensity: document.getElementById('crosslinkDensity'),
            crosslinkDensityVal: document.getElementById('crosslinkDensityVal'),
            chainLength: document.getElementById('chainLength'),
            chainLengthVal: document.getElementById('chainLengthVal'),
            chiParameter: document.getElementById('chiParameter'),
            chiParameterVal: document.getElementById('chiParameterVal'),
            stretchRatio: document.getElementById('stretchRatio'),
            stretchRatioVal: document.getElementById('stretchRatioVal'),
            solventFraction: document.getElementById('solventFraction'),
            solventFractionVal: document.getElementById('solventFractionVal'),
            generateBtn: document.getElementById('generateBtn'),
            resetBtn: document.getElementById('resetBtn'),
            stretchBtn: document.getElementById('stretchBtn'),
            relaxBtn: document.getElementById('relaxBtn'),
            swellBtn: document.getElementById('swellBtn'),
            desorbBtn: document.getElementById('desorbBtn'),
            currentStretch: document.getElementById('currentStretch'),
            swellingRatio: document.getElementById('swellingRatio'),
            stress: document.getElementById('stress'),
            modulus: document.getElementById('modulus'),
            stressBar: document.getElementById('stressBar'),
            numCrosslinks: document.getElementById('numCrosslinks'),
            avgMc: document.getElementById('avgMc'),
            networkConnectivity: document.getElementById('networkConnectivity'),
            endToEndDist: document.getElementById('endToEndDist'),
            elasticEnergy: document.getElementById('elasticEnergy'),
            mixingEnergy: document.getElementById('mixingEnergy'),
            modeIndicator: document.getElementById('modeIndicator'),
            modelInfo: document.getElementById('modelInfo')
        };

        // Generate polymer network
        function generateNetwork() {
            nodes = [];
            chains = [];
            crosslinks = [];

            const width = networkCanvas.width;
            const height = networkCanvas.height;
            const margin = 50;

            // Create nodes (monomers/crosslink points)
            const numNodes = numChains * 2;

            for (let i = 0; i < numNodes; i++) {
                nodes.push({
                    x: margin + Math.random() * (width - 2 * margin),
                    y: margin + Math.random() * (height - 2 * margin),
                    origX: 0,
                    origY: 0,
                    isCrosslink: false,
                    connections: []
                });
            }

            // Store original positions
            nodes.forEach(node => {
                node.origX = node.x;
                node.origY = node.y;
            });

            // Create chains connecting nodes
            const usedNodes = new Set();

            for (let i = 0; i < numChains && usedNodes.size < numNodes - 1; i++) {
                // Find unused node pair
                let n1 = -1, n2 = -1;

                for (let j = 0; j < numNodes && n1 < 0; j++) {
                    if (!usedNodes.has(j)) {
                        n1 = j;
                        usedNodes.add(j);
                    }
                }

                for (let j = 0; j < numNodes && n2 < 0; j++) {
                    if (!usedNodes.has(j)) {
                        n2 = j;
                        usedNodes.add(j);
                    }
                }

                if (n1 >= 0 && n2 >= 0) {
                    const chain = {
                        node1: n1,
                        node2: n2,
                        segments: chainLength,
                        points: [],
                        stress: 0
                    };

                    // Generate chain path with random walk
                    generateChainPath(chain);

                    chains.push(chain);
                    nodes[n1].connections.push(chains.length - 1);
                    nodes[n2].connections.push(chains.length - 1);
                }
            }

            // Create crosslinks based on density
            const numCrosslinksTarget = Math.floor(crosslinkDensity * numChains);

            for (let i = 0; i < numCrosslinksTarget; i++) {
                // Find two nearby chain midpoints
                if (chains.length < 2) break;

                const c1 = Math.floor(Math.random() * chains.length);
                let c2 = Math.floor(Math.random() * chains.length);
                while (c2 === c1 && chains.length > 1) {
                    c2 = Math.floor(Math.random() * chains.length);
                }

                const chain1 = chains[c1];
                const chain2 = chains[c2];

                if (chain1.points.length > 2 && chain2.points.length > 2) {
                    const midIdx1 = Math.floor(chain1.points.length / 2);
                    const midIdx2 = Math.floor(chain2.points.length / 2);

                    // Create crosslink node at average position
                    const crosslinkNode = {
                        x: (chain1.points[midIdx1].x + chain2.points[midIdx2].x) / 2,
                        y: (chain1.points[midIdx1].y + chain2.points[midIdx2].y) / 2,
                        origX: 0,
                        origY: 0,
                        isCrosslink: true,
                        connections: [c1, c2]
                    };
                    crosslinkNode.origX = crosslinkNode.x;
                    crosslinkNode.origY = crosslinkNode.y;

                    // Insert crosslink into chain paths
                    chain1.points[midIdx1] = { ...crosslinkNode };
                    chain2.points[midIdx2] = { ...crosslinkNode };

                    crosslinks.push({
                        x: crosslinkNode.x,
                        y: crosslinkNode.y,
                        origX: crosslinkNode.origX,
                        origY: crosslinkNode.origY,
                        chains: [c1, c2]
                    });
                }
            }

            updateStats();
            draw();
        }

        // Generate random walk chain path
        function generateChainPath(chain) {
            const n1 = nodes[chain.node1];
            const n2 = nodes[chain.node2];

            chain.points = [];

            const segments = chain.segments;
            const dx = (n2.x - n1.x) / segments;
            const dy = (n2.y - n1.y) / segments;

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                // Add random walk component
                const noise = (1 - Math.abs(2 * t - 1)) * 20; // Maximum in middle
                const randomX = (Math.random() - 0.5) * noise;
                const randomY = (Math.random() - 0.5) * noise;

                chain.points.push({
                    x: n1.x + dx * i + randomX,
                    y: n1.y + dy * i + randomY,
                    origX: n1.origX + dx * i + randomX,
                    origY: n1.origY + dy * i + randomY
                });
            }
        }

        // Apply deformation to network
        function applyDeformation() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;

            // Swelling effect (isotropic expansion)
            const swellFactor = 1 + solventFraction * 2;

            // Update node positions
            nodes.forEach(node => {
                const relX = node.origX - centerX;
                const relY = node.origY - centerY;

                // Apply stretch in x-direction (uniaxial)
                // For incompressibility: λ_y = λ_z = 1/√λ_x
                const lambdaY = 1 / Math.sqrt(stretchRatio);

                node.x = centerX + relX * stretchRatio * swellFactor;
                node.y = centerY + relY * lambdaY * swellFactor;
            });

            // Update crosslink positions
            crosslinks.forEach(cl => {
                const relX = cl.origX - centerX;
                const relY = cl.origY - centerY;
                const lambdaY = 1 / Math.sqrt(stretchRatio);

                cl.x = centerX + relX * stretchRatio * swellFactor;
                cl.y = centerY + relY * lambdaY * swellFactor;
            });

            // Update chain paths
            chains.forEach(chain => {
                chain.points.forEach(point => {
                    const relX = point.origX - centerX;
                    const relY = point.origY - centerY;
                    const lambdaY = 1 / Math.sqrt(stretchRatio);

                    point.x = centerX + relX * stretchRatio * swellFactor;
                    point.y = centerY + relY * lambdaY * swellFactor;
                });

                // Calculate chain stress
                const n1 = nodes[chain.node1];
                const n2 = nodes[chain.node2];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const currentLength = Math.sqrt(dx * dx + dy * dy);

                const origDx = n2.origX - n1.origX;
                const origDy = n2.origY - n1.origY;
                const origLength = Math.sqrt(origDx * origDx + origDy * origDy);

                chain.stress = Math.abs(currentLength / origLength - 1);
            });
        }

        // Calculate stress using rubber elasticity theory
        function calculateStress() {
            // Neo-Hookean model: σ = G(λ - 1/λ²)
            // where G is shear modulus
            const G = calculateModulus();
            const lambda = stretchRatio;
            const stress = G * (lambda - 1 / (lambda * lambda));
            return stress;
        }

        // Calculate shear modulus
        function calculateModulus() {
            // Affine network model: G = ν_c * R * T
            // where ν_c is crosslink density in mol/m³
            const nu = crosslinkDensity * 1000; // Convert to mol/m³
            const G = nu * R * T / 1e6; // Convert to MPa
            return G;
        }

        // Calculate swelling equilibrium (Flory-Rehner)
        function calculateSwellingEquilibrium() {
            // Simplified Flory-Rehner: balance of mixing and elastic terms
            const phi2 = 1 - solventFraction; // Polymer volume fraction
            const chi = chiParameter;
            const nu = crosslinkDensity;

            // Mixing free energy: χφ₂² + ln(1-φ₂) + φ₂
            const mixingTerm = chi * phi2 * phi2 + Math.log(1 - phi2 + 0.001) + phi2;

            // Elastic free energy
            const V1 = 18e-6; // Molar volume of solvent (water) m³/mol
            const elasticTerm = nu * V1 * (Math.pow(phi2, 1/3) - phi2 / 2);

            return { mixing: mixingTerm, elastic: elasticTerm };
        }

        // Draw network
        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            netCtx.clearRect(0, 0, width, height);

            // Background
            netCtx.fillStyle = '#1a1a2e';
            netCtx.fillRect(0, 0, width, height);

            // Draw solvent as background dots if swollen
            if (solventFraction > 0.01) {
                netCtx.fillStyle = 'rgba(39, 174, 96, 0.3)';
                const numDots = Math.floor(solventFraction * 500);
                for (let i = 0; i < numDots; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    netCtx.beginPath();
                    netCtx.arc(x, y, 2, 0, Math.PI * 2);
                    netCtx.fill();
                }
            }

            // Draw chains
            chains.forEach(chain => {
                if (chain.points.length < 2) return;

                // Color based on stress
                const stressColor = chain.stress > 0.2 ?
                    `rgb(${Math.min(255, 52 + chain.stress * 400)}, ${Math.max(0, 152 - chain.stress * 200)}, ${Math.max(0, 219 - chain.stress * 400)})` :
                    '#3498db';

                netCtx.strokeStyle = stressColor;
                netCtx.lineWidth = 2;
                netCtx.beginPath();
                netCtx.moveTo(chain.points[0].x, chain.points[0].y);

                for (let i = 1; i < chain.points.length; i++) {
                    netCtx.lineTo(chain.points[i].x, chain.points[i].y);
                }

                netCtx.stroke();
            });

            // Draw nodes (chain endpoints)
            nodes.forEach(node => {
                netCtx.fillStyle = node.isCrosslink ? '#e74c3c' : '#9b59b6';
                netCtx.beginPath();
                netCtx.arc(node.x, node.y, node.isCrosslink ? 5 : 3, 0, Math.PI * 2);
                netCtx.fill();
            });

            // Draw crosslinks
            crosslinks.forEach(cl => {
                netCtx.fillStyle = '#e74c3c';
                netCtx.beginPath();
                netCtx.arc(cl.x, cl.y, 6, 0, Math.PI * 2);
                netCtx.fill();

                netCtx.strokeStyle = '#fff';
                netCtx.lineWidth = 1;
                netCtx.beginPath();
                netCtx.moveTo(cl.x - 3, cl.y);
                netCtx.lineTo(cl.x + 3, cl.y);
                netCtx.moveTo(cl.x, cl.y - 3);
                netCtx.lineTo(cl.x, cl.y + 3);
                netCtx.stroke();
            });

            // Draw scale bar
            const scaleLength = 50 * (1 + solventFraction * 2);
            netCtx.strokeStyle = '#fff';
            netCtx.lineWidth = 2;
            netCtx.beginPath();
            netCtx.moveTo(20, height - 20);
            netCtx.lineTo(20 + scaleLength, height - 20);
            netCtx.stroke();

            netCtx.fillStyle = '#aaa';
            netCtx.font = '10px sans-serif';
            netCtx.textAlign = 'center';
            netCtx.fillText('50 nm', 20 + scaleLength / 2, height - 8);
        }

        // Draw stress-strain curve
        function drawStressStrain() {
            const width = stressStrainCanvas.width;
            const height = stressStrainCanvas.height;
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            ssCtx.clearRect(0, 0, width, height);
            ssCtx.fillStyle = '#1a1a2e';
            ssCtx.fillRect(0, 0, width, height);

            // Axes
            ssCtx.strokeStyle = '#666';
            ssCtx.lineWidth = 1;
            ssCtx.beginPath();
            ssCtx.moveTo(margin.left, margin.top);
            ssCtx.lineTo(margin.left, height - margin.bottom);
            ssCtx.lineTo(width - margin.right, height - margin.bottom);
            ssCtx.stroke();

            // Labels
            ssCtx.fillStyle = '#aaa';
            ssCtx.font = '11px sans-serif';
            ssCtx.textAlign = 'center';
            ssCtx.fillText('Stretch Ratio (λ)', width / 2, height - 5);

            ssCtx.save();
            ssCtx.translate(12, height / 2);
            ssCtx.rotate(-Math.PI / 2);
            ssCtx.fillText('Stress (MPa)', 0, 0);
            ssCtx.restore();

            // Theoretical curve (Neo-Hookean)
            const G = calculateModulus();
            const maxLambda = 3;
            const maxStress = G * (maxLambda - 1 / (maxLambda * maxLambda));

            ssCtx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
            ssCtx.lineWidth = 2;
            ssCtx.setLineDash([5, 5]);
            ssCtx.beginPath();

            for (let lambda = 1; lambda <= maxLambda; lambda += 0.05) {
                const stress = G * (lambda - 1 / (lambda * lambda));
                const x = margin.left + ((lambda - 1) / (maxLambda - 1)) * chartWidth;
                const y = margin.top + (1 - stress / maxStress) * chartHeight;

                if (lambda === 1) {
                    ssCtx.moveTo(x, y);
                } else {
                    ssCtx.lineTo(x, y);
                }
            }
            ssCtx.stroke();
            ssCtx.setLineDash([]);

            // Current point
            const currentStress = calculateStress();
            const x = margin.left + ((stretchRatio - 1) / (maxLambda - 1)) * chartWidth;
            const y = margin.top + (1 - currentStress / maxStress) * chartHeight;

            ssCtx.fillStyle = '#9b59b6';
            ssCtx.beginPath();
            ssCtx.arc(x, y, 8, 0, Math.PI * 2);
            ssCtx.fill();

            ssCtx.fillStyle = '#fff';
            ssCtx.beginPath();
            ssCtx.arc(x, y, 4, 0, Math.PI * 2);
            ssCtx.fill();

            // Tick labels
            ssCtx.fillStyle = '#aaa';
            ssCtx.font = '10px sans-serif';
            ssCtx.textAlign = 'center';

            for (let l = 1; l <= maxLambda; l += 0.5) {
                const tx = margin.left + ((l - 1) / (maxLambda - 1)) * chartWidth;
                ssCtx.fillText(l.toFixed(1), tx, height - margin.bottom + 15);
            }

            ssCtx.textAlign = 'right';
            for (let s = 0; s <= maxStress; s += maxStress / 4) {
                const ty = margin.top + (1 - s / maxStress) * chartHeight;
                ssCtx.fillText(s.toFixed(2), margin.left - 5, ty + 4);
            }

            // Legend
            ssCtx.fillStyle = '#3498db';
            ssCtx.font = '10px sans-serif';
            ssCtx.textAlign = 'left';
            ssCtx.fillText('Neo-Hookean Model', margin.left + 10, margin.top + 15);
        }

        // Draw swelling isotherm
        function drawSwellingIsotherm() {
            const width = swellingCanvas.width;
            const height = swellingCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            swCtx.clearRect(0, 0, width, height);
            swCtx.fillStyle = '#1a1a2e';
            swCtx.fillRect(0, 0, width, height);

            // Axes
            swCtx.strokeStyle = '#666';
            swCtx.lineWidth = 1;
            swCtx.beginPath();
            swCtx.moveTo(margin.left, margin.top);
            swCtx.lineTo(margin.left, height - margin.bottom);
            swCtx.lineTo(width - margin.right, height - margin.bottom);
            swCtx.stroke();

            // Labels
            swCtx.fillStyle = '#aaa';
            swCtx.font = '10px sans-serif';
            swCtx.textAlign = 'center';
            swCtx.fillText('χ Parameter', width / 2, height - 5);

            swCtx.save();
            swCtx.translate(10, height / 2);
            swCtx.rotate(-Math.PI / 2);
            swCtx.fillText('Swelling Ratio (Q)', 0, 0);
            swCtx.restore();

            // Theoretical swelling curve
            swCtx.strokeStyle = '#27ae60';
            swCtx.lineWidth = 2;
            swCtx.beginPath();

            const maxQ = 10;
            let started = false;

            for (let chi = 0; chi <= 1; chi += 0.02) {
                // Simplified swelling prediction
                // Higher χ = worse solvent = less swelling
                const Q = 1 + (1 - chi) * (9 / (crosslinkDensity + 0.1));

                const x = margin.left + chi * chartWidth;
                const y = margin.top + (1 - Q / maxQ) * chartHeight;

                if (!started) {
                    swCtx.moveTo(x, y);
                    started = true;
                } else {
                    swCtx.lineTo(x, y);
                }
            }
            swCtx.stroke();

            // Current point
            const currentQ = 1 + solventFraction * 2;
            const x = margin.left + chiParameter * chartWidth;
            const y = margin.top + (1 - currentQ / maxQ) * chartHeight;

            swCtx.fillStyle = '#27ae60';
            swCtx.beginPath();
            swCtx.arc(x, y, 8, 0, Math.PI * 2);
            swCtx.fill();

            swCtx.fillStyle = '#fff';
            swCtx.beginPath();
            swCtx.arc(x, y, 4, 0, Math.PI * 2);
            swCtx.fill();

            // Mark theta solvent
            swCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            swCtx.setLineDash([5, 5]);
            swCtx.beginPath();
            const thetaX = margin.left + 0.5 * chartWidth;
            swCtx.moveTo(thetaX, margin.top);
            swCtx.lineTo(thetaX, height - margin.bottom);
            swCtx.stroke();
            swCtx.setLineDash([]);

            swCtx.fillStyle = '#aaa';
            swCtx.font = '9px sans-serif';
            swCtx.textAlign = 'center';
            swCtx.fillText('θ', thetaX, margin.top - 5);
        }

        // Draw chain conformation distribution
        function drawConformationDistribution() {
            const width = conformationCanvas.width;
            const height = conformationCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            confCtx.clearRect(0, 0, width, height);
            confCtx.fillStyle = '#1a1a2e';
            confCtx.fillRect(0, 0, width, height);

            // Axes
            confCtx.strokeStyle = '#666';
            confCtx.lineWidth = 1;
            confCtx.beginPath();
            confCtx.moveTo(margin.left, margin.top);
            confCtx.lineTo(margin.left, height - margin.bottom);
            confCtx.lineTo(width - margin.right, height - margin.bottom);
            confCtx.stroke();

            // Labels
            confCtx.fillStyle = '#aaa';
            confCtx.font = '10px sans-serif';
            confCtx.textAlign = 'center';
            confCtx.fillText('End-to-End Distance (R/R₀)', width / 2, height - 5);

            confCtx.save();
            confCtx.translate(10, height / 2);
            confCtx.rotate(-Math.PI / 2);
            confCtx.fillText('P(R)', 0, 0);
            confCtx.restore();

            // Calculate end-to-end distances
            const distances = [];
            chains.forEach(chain => {
                const n1 = nodes[chain.node1];
                const n2 = nodes[chain.node2];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const r = Math.sqrt(dx * dx + dy * dy);

                const origDx = n2.origX - n1.origX;
                const origDy = n2.origY - n1.origY;
                const r0 = Math.sqrt(origDx * origDx + origDy * origDy);

                distances.push(r / r0);
            });

            // Create histogram
            const numBins = 20;
            const bins = new Array(numBins).fill(0);
            const maxR = 3;

            distances.forEach(r => {
                const binIdx = Math.min(numBins - 1, Math.floor(r / maxR * numBins));
                if (binIdx >= 0 && binIdx < numBins) {
                    bins[binIdx]++;
                }
            });

            const maxCount = Math.max(...bins, 1);

            // Draw histogram bars
            const barWidth = chartWidth / numBins;

            bins.forEach((count, i) => {
                const x = margin.left + i * barWidth;
                const barHeight = (count / maxCount) * chartHeight;
                const y = margin.top + chartHeight - barHeight;

                confCtx.fillStyle = 'rgba(155, 89, 182, 0.7)';
                confCtx.fillRect(x, y, barWidth - 2, barHeight);
            });

            // Draw Gaussian fit (undeformed)
            confCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            confCtx.lineWidth = 2;
            confCtx.setLineDash([5, 5]);
            confCtx.beginPath();

            const sigma = 0.4;
            for (let r = 0; r <= maxR; r += 0.05) {
                const gaussian = Math.exp(-Math.pow(r - 1, 2) / (2 * sigma * sigma));
                const x = margin.left + (r / maxR) * chartWidth;
                const y = margin.top + (1 - gaussian) * chartHeight;

                if (r === 0) {
                    confCtx.moveTo(x, y);
                } else {
                    confCtx.lineTo(x, y);
                }
            }
            confCtx.stroke();
            confCtx.setLineDash([]);

            // Mark current average
            const avgR = distances.length > 0 ? distances.reduce((a, b) => a + b, 0) / distances.length : 1;
            const avgX = margin.left + (avgR / maxR) * chartWidth;

            confCtx.strokeStyle = '#f39c12';
            confCtx.lineWidth = 2;
            confCtx.beginPath();
            confCtx.moveTo(avgX, margin.top);
            confCtx.lineTo(avgX, height - margin.bottom);
            confCtx.stroke();

            confCtx.fillStyle = '#f39c12';
            confCtx.font = '10px sans-serif';
            confCtx.textAlign = 'center';
            confCtx.fillText('⟨R⟩', avgX, margin.top - 5);
        }

        // Update statistics
        function updateStats() {
            elements.currentStretch.textContent = stretchRatio.toFixed(2);
            elements.swellingRatio.textContent = (1 + solventFraction * 2).toFixed(2);

            const stress = calculateStress();
            elements.stress.textContent = stress.toFixed(3);

            const modulus = calculateModulus();
            elements.modulus.textContent = modulus.toFixed(3);

            // Stress bar
            const maxStress = modulus * 2;
            const stressPercent = Math.min(100, (Math.abs(stress) / maxStress) * 100);
            elements.stressBar.style.width = stressPercent + '%';

            // Network properties
            elements.numCrosslinks.textContent = crosslinks.length;

            // Average molecular weight between crosslinks
            const Mc = 100 / (crosslinkDensity + 0.01) * 100; // Simplified
            elements.avgMc.textContent = Math.round(Mc);

            // Connectivity (average chains per crosslink)
            const avgConnections = chains.length > 0 ? (2 * chains.length / (nodes.length || 1)).toFixed(2) : '0';
            elements.networkConnectivity.textContent = avgConnections;

            // End-to-end distance
            let sumR2 = 0;
            chains.forEach(chain => {
                const n1 = nodes[chain.node1];
                const n2 = nodes[chain.node2];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                sumR2 += dx * dx + dy * dy;
            });
            const rmsR = chains.length > 0 ? Math.sqrt(sumR2 / chains.length) : 0;
            elements.endToEndDist.textContent = (rmsR * 0.1).toFixed(1); // Scale to nm

            // Thermodynamics
            const energies = calculateSwellingEquilibrium();
            elements.elasticEnergy.textContent = (energies.elastic * R * T / 1000).toFixed(2);
            elements.mixingEnergy.textContent = (energies.mixing * R * T / 1000).toFixed(2);

            // Mode indicator
            if (stretchRatio > 1.1) {
                elements.modeIndicator.className = 'mode-indicator mode-stretched';
                elements.modeIndicator.textContent = 'STRETCHED';
            } else if (solventFraction > 0.1) {
                elements.modeIndicator.className = 'mode-indicator mode-swollen';
                elements.modeIndicator.textContent = 'SWOLLEN';
            } else {
                elements.modeIndicator.className = 'mode-indicator mode-relaxed';
                elements.modeIndicator.textContent = 'RELAXED';
            }

            // Update info box
            updateModelInfo();
        }

        function updateModelInfo() {
            let info = '';

            if (stretchRatio > 1.1) {
                info = `<strong>Rubber Elasticity:</strong><br>
                        Neo-Hookean stress: σ = G(λ - 1/λ²)<br>
                        Current strain energy stored in network.`;
            } else if (solventFraction > 0.1) {
                info = `<strong>Swelling Equilibrium:</strong><br>
                        Flory-Rehner: Mixing entropy vs elastic penalty<br>
                        χ = ${chiParameter.toFixed(2)} → ${chiParameter < 0.5 ? 'good solvent' : 'poor solvent'}`;
            } else {
                info = `<strong>Affine Network Model:</strong><br>
                        Assumes chain ends deform affinely with macroscopic strain.<br>
                        Shear modulus G = νkT = ${calculateModulus().toFixed(3)} MPa`;
            }

            elements.modelInfo.innerHTML = info;
        }

        // Main draw function
        function draw() {
            applyDeformation();
            drawNetwork();
            drawStressStrain();
            drawSwellingIsotherm();
            drawConformationDistribution();
            updateStats();
        }

        // Animation loop
        function animate() {
            // Smoothly approach target values
            const dt = 0.1;

            if (Math.abs(stretchRatio - targetStretch) > 0.01) {
                stretchRatio += (targetStretch - stretchRatio) * dt;
                elements.stretchRatioVal.textContent = stretchRatio.toFixed(2);
            }

            if (Math.abs(solventFraction - targetSolvent) > 0.01) {
                solventFraction += (targetSolvent - solventFraction) * dt;
                elements.solventFractionVal.textContent = solventFraction.toFixed(2);
            }

            draw();

            if (Math.abs(stretchRatio - targetStretch) > 0.01 ||
                Math.abs(solventFraction - targetSolvent) > 0.01) {
                animationId = requestAnimationFrame(animate);
            } else {
                animationId = null;
            }
        }

        // Start animation if needed
        function startAnimation() {
            if (!animationId) {
                animate();
            }
        }

        // Event listeners
        elements.networkType.addEventListener('change', (e) => {
            networkType = e.target.value;
            generateNetwork();
        });

        elements.numChains.addEventListener('input', (e) => {
            numChains = parseInt(e.target.value);
            elements.numChainsVal.textContent = numChains;
        });

        elements.crosslinkDensity.addEventListener('input', (e) => {
            crosslinkDensity = parseFloat(e.target.value);
            elements.crosslinkDensityVal.textContent = crosslinkDensity.toFixed(2);
        });

        elements.chainLength.addEventListener('input', (e) => {
            chainLength = parseInt(e.target.value);
            elements.chainLengthVal.textContent = chainLength;
        });

        elements.chiParameter.addEventListener('input', (e) => {
            chiParameter = parseFloat(e.target.value);
            elements.chiParameterVal.textContent = chiParameter.toFixed(2);
            draw();
        });

        elements.stretchRatio.addEventListener('input', (e) => {
            targetStretch = parseFloat(e.target.value);
            elements.stretchRatioVal.textContent = targetStretch.toFixed(2);
            startAnimation();
        });

        elements.solventFraction.addEventListener('input', (e) => {
            targetSolvent = parseFloat(e.target.value);
            elements.solventFractionVal.textContent = targetSolvent.toFixed(2);
            startAnimation();
        });

        elements.generateBtn.addEventListener('click', generateNetwork);

        elements.resetBtn.addEventListener('click', () => {
            targetStretch = 1.0;
            targetSolvent = 0.0;
            elements.stretchRatio.value = 1.0;
            elements.stretchRatioVal.textContent = '1.00';
            elements.solventFraction.value = 0;
            elements.solventFractionVal.textContent = '0.00';
            startAnimation();
        });

        elements.stretchBtn.addEventListener('click', () => {
            targetStretch = 2.0;
            elements.stretchRatio.value = 2.0;
            elements.stretchRatioVal.textContent = '2.00';
            startAnimation();
        });

        elements.relaxBtn.addEventListener('click', () => {
            targetStretch = 1.0;
            elements.stretchRatio.value = 1.0;
            elements.stretchRatioVal.textContent = '1.00';
            startAnimation();
        });

        elements.swellBtn.addEventListener('click', () => {
            targetSolvent = 0.7;
            elements.solventFraction.value = 0.7;
            elements.solventFractionVal.textContent = '0.70';
            startAnimation();
        });

        elements.desorbBtn.addEventListener('click', () => {
            targetSolvent = 0;
            elements.solventFraction.value = 0;
            elements.solventFractionVal.textContent = '0.00';
            startAnimation();
        });

        // Initialize
        generateNetwork();
    </script>
</body>
</html>
